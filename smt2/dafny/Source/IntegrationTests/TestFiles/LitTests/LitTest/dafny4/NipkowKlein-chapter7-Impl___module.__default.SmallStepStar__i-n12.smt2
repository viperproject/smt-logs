(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :auto_config false)
(set-option :type_check true)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.delay_units true)
(set-option :model_evaluator.completion true)
(set-option :model.completion true)
(set-option :model.compact false)
(set-option :smt.case_split 3)
(set-option :smt.mbqi false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
(set-option :smt.arith.solver 2)
; done setting options


(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TORDINAL () T@U)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagORDINAL () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun alloc () T@U)
(declare-fun |##_System._tuple#2._#Make2| () T@U)
(declare-fun Tagclass._System.Tuple2 () T@U)
(declare-fun Tagclass._module.aexp () T@U)
(declare-fun Tagclass._module.bexp () T@U)
(declare-fun Tagclass._module.com () T@U)
(declare-fun |##_module.aexp.N| () T@U)
(declare-fun |##_module.aexp.V| () T@U)
(declare-fun |##_module.aexp.Plus| () T@U)
(declare-fun |##_module.bexp.Bc| () T@U)
(declare-fun |##_module.bexp.Not| () T@U)
(declare-fun |##_module.bexp.And| () T@U)
(declare-fun |##_module.bexp.Less| () T@U)
(declare-fun |##_module.com.SKIP| () T@U)
(declare-fun |##_module.com.Assign| () T@U)
(declare-fun |##_module.com.Seq| () T@U)
(declare-fun |##_module.com.If| () T@U)
(declare-fun |##_module.com.While| () T@U)
(declare-fun |tytagFamily$_tuple#2| () T@U)
(declare-fun tytagFamily$aexp () T@U)
(declare-fun tytagFamily$bexp () T@U)
(declare-fun tytagFamily$com () T@U)
(declare-fun Ctor (T@T) Int)
(declare-fun boolType () T@T)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun |_module.bexp#Equal| (T@U T@U) Bool)
(declare-fun _module.bexp.Bc_q (T@U) Bool)
(declare-fun _module.bexp.v (T@U) Bool)
(declare-fun Tag (T@U) T@U)
(declare-fun $FunctionContextHeight () Int)
(declare-fun _module.__default.big__step (T@U T@U T@U T@U) Bool)
(declare-fun $LS (T@U) T@U)
(declare-fun $Is (T@T T@U T@U) Bool)
(declare-fun DatatypeTypeType () T@T)
(declare-fun Tclass._module.com () T@U)
(declare-fun MapType () T@T)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun _module.__default.big__step_h (T@U T@U T@U T@U T@U) Bool)
(declare-fun |#_module.aexp.Plus| (T@U T@U) T@U)
(declare-fun Tclass._module.aexp () T@U)
(declare-fun |#_module.bexp.And| (T@U T@U) T@U)
(declare-fun Tclass._module.bexp () T@U)
(declare-fun |#_module.bexp.Less| (T@U T@U) T@U)
(declare-fun |#_module.com.Seq| (T@U T@U) T@U)
(declare-fun |#_module.com.While| (T@U T@U) T@U)
(declare-fun _module.__default.small__step (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |#_module.com.Assign| (T@U T@U) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun DtRank (T@U) Int)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun |ORD#Less| (T@U T@U) Bool)
(declare-fun |#_module.com.If| (T@U T@U T@U) T@U)
(declare-fun |_module.aexp#Equal| (T@U T@U) Bool)
(declare-fun _module.aexp.N_q (T@U) Bool)
(declare-fun _module.aexp.n (T@U) Int)
(declare-fun |#_module.aexp.V| (T@U) T@U)
(declare-fun DatatypeCtorId (T@U) T@U)
(declare-fun _module.com._h4 (T@U) T@U)
(declare-fun _module.com._h5 (T@U) T@U)
(declare-fun _module.com._h6 (T@U) T@U)
(declare-fun _module.__default.small__step_h (T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun |ORD#Minus| (T@U T@U) T@U)
(declare-fun |ORD#FromNat| (Int) T@U)
(declare-fun |ORD#Offset| (T@U) Int)
(declare-fun _System.Tuple2.___hMake2_q (T@U) Bool)
(declare-fun Tclass._System.Tuple2 (T@U T@U) T@U)
(declare-fun Lit (T@T T@U) T@U)
(declare-fun BoxType () T@T)
(declare-fun |_module.__default.small__step_h#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun _module.com.SKIP_q (T@U) Bool)
(declare-fun _module.com.Assign_q (T@U) Bool)
(declare-fun _module.com._h1 (T@U) T@U)
(declare-fun |$IsA#_module.com| (T@U) Bool)
(declare-fun |_module.com#Equal| (T@U T@U) Bool)
(declare-fun |#_module.com.SKIP| () T@U)
(declare-fun |_module.__default.aval#canCall| (T@U T@U) Bool)
(declare-fun _module.com.Seq_q (T@U) Bool)
(declare-fun _module.com._h3 (T@U) T@U)
(declare-fun _module.com._h2 (T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun _module.com.If_q (T@U) Bool)
(declare-fun _module.__default.bval (T@U T@U T@U) Bool)
(declare-fun $LZ () T@U)
(declare-fun |_module.__default.bval#canCall| (T@U T@U) Bool)
(declare-fun _module.com._h0 (T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun $Box (T@T T@U) T@U)
(declare-fun SeqType () T@T)
(declare-fun _module.__default.aval (T@U T@U T@U) Int)
(declare-fun _module.com._h8 (T@U) T@U)
(declare-fun _module.com._h7 (T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun |ORD#LessThanLimit| (T@U T@U) Bool)
(declare-fun |_module.__default.big__step_h#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Seq#Empty| () T@U)
(declare-fun |#_System._tuple#2._#Make2| (T@U T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun _module.aexp.V_q (T@U) Bool)
(declare-fun _module.aexp._1 (T@U) T@U)
(declare-fun _module.aexp._0 (T@U) T@U)
(declare-fun _module.aexp.x (T@U) T@U)
(declare-fun |Set#IsMember| (T@U T@U) Bool)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun MapType0Select (T@T T@T T@U T@U) T@U)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun MapType0Store (T@T T@T T@U T@U T@U) T@U)
(declare-fun _module.bexp.Not_q (T@U) Bool)
(declare-fun _module.bexp.op (T@U) T@U)
(declare-fun _module.bexp.And_q (T@U) Bool)
(declare-fun _module.bexp._1 (T@U) T@U)
(declare-fun _module.bexp._0 (T@U) T@U)
(declare-fun _module.bexp.a1 (T@U) T@U)
(declare-fun _module.bexp.a0 (T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun $IsAlloc (T@T T@U T@U T@U) Bool)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun _module.aexp.Plus_q (T@U) Bool)
(declare-fun _module.bexp.Less_q (T@U) Bool)
(declare-fun _module.com.While_q (T@U) Bool)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |_module.__default.small__step#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun SetType () T@T)
(declare-fun TSet (T@U) T@U)
(declare-fun |#_module.aexp.N| (Int) T@U)
(declare-fun |#_module.bexp.Bc| (Bool) T@U)
(declare-fun |#_module.bexp.Not| (T@U) T@U)
(declare-fun _module.__default.small__step__star_h (T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun |_module.__default.small__step__star_h#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |ORD#IsNat| (T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun charType () T@T)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun Tclass._System.Tuple2_0 (T@U) T@U)
(declare-fun Tclass._System.Tuple2_1 (T@U) T@U)
(declare-fun _System.Tuple2._0 (T@U) T@U)
(declare-fun _System.Tuple2._1 (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun BoxRank (T@U) Int)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |_module.__default.big__step#canCall| (T@U T@U T@U) Bool)
(declare-fun |Map#Empty| () T@U)
(declare-fun MapType1Select (T@T T@T T@T T@U T@U T@U) T@U)
(declare-fun refType () T@T)
(declare-fun FieldType () T@T)
(declare-fun |lambda#0| (T@U T@U T@U Bool) T@U)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType1Store (T@T T@T T@T T@U T@U T@U T@U) T@U)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun TagFamily (T@U) T@U)
(declare-fun |Map#Values| (T@U) T@U)
(declare-fun |Map#Items| (T@U) T@U)
(assert  (and (and (and (and (and (and (and (and (= (Ctor boolType) 0) (= (Ctor intType) 1)) (= (Ctor realType) 2)) (forall ((arg0 Bool) ) (! (= (U_2_bool (bool_2_U arg0)) arg0)
 :pattern ( (bool_2_U arg0))
))) (forall ((x T@U) ) (! (= (bool_2_U (U_2_bool x)) x)
 :pattern ( (U_2_bool x))
))) (forall ((arg0@@0 Int) ) (! (= (U_2_int (int_2_U arg0@@0)) arg0@@0)
 :pattern ( (int_2_U arg0@@0))
))) (forall ((x@@0 T@U) ) (! (= (int_2_U (U_2_int x@@0)) x@@0)
 :pattern ( (U_2_int x@@0))
))) (forall ((arg0@@1 Real) ) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
 :pattern ( (real_2_U arg0@@1))
))) (forall ((x@@1 T@U) ) (! (= (real_2_U (U_2_real x@@1)) x@@1)
 :pattern ( (U_2_real x@@1))
))))
(assert (distinct TBool TChar TInt TORDINAL TagBool TagChar TagInt TagORDINAL TagSet TagSeq TagMap alloc |##_System._tuple#2._#Make2| Tagclass._System.Tuple2 Tagclass._module.aexp Tagclass._module.bexp Tagclass._module.com |##_module.aexp.N| |##_module.aexp.V| |##_module.aexp.Plus| |##_module.bexp.Bc| |##_module.bexp.Not| |##_module.bexp.And| |##_module.bexp.Less| |##_module.com.SKIP| |##_module.com.Assign| |##_module.com.Seq| |##_module.com.If| |##_module.com.While| |tytagFamily$_tuple#2| tytagFamily$aexp tytagFamily$bexp tytagFamily$com)
)
(assert (forall ((a T@U) (b T@U) ) (!  (=> (and (_module.bexp.Bc_q a) (_module.bexp.Bc_q b)) (= (|_module.bexp#Equal| a b) (= (_module.bexp.v a) (_module.bexp.v b))))
 :pattern ( (|_module.bexp#Equal| a b) (_module.bexp.Bc_q a))
 :pattern ( (|_module.bexp#Equal| a b) (_module.bexp.Bc_q b))
)))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TORDINAL) TagORDINAL))
(assert  (and (= (Ctor DatatypeTypeType) 3) (= (Ctor MapType) 4)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly T@U) (|c#0| T@U) (|s#0| T@U) (|t#0| T@U) ) (!  (=> (and (and (and ($Is DatatypeTypeType |c#0| Tclass._module.com) ($Is MapType |s#0| (TMap (TSeq TChar) TInt))) ($Is MapType |t#0| (TMap (TSeq TChar) TInt))) (exists ((|_k#0| T@U) ) (! (_module.__default.big__step_h ($LS $ly) |_k#0| |c#0| |s#0| |t#0|)
 :pattern ( (_module.__default.big__step_h ($LS $ly) |_k#0| |c#0| |s#0| |t#0|))
))) (_module.__default.big__step ($LS $ly) |c#0| |s#0| |t#0|))
 :pattern ( (_module.__default.big__step ($LS $ly) |c#0| |s#0| |t#0|))
))))
(assert (forall ((|a#26#0#0| T@U) (|a#26#1#0| T@U) ) (! (= ($Is DatatypeTypeType (|#_module.aexp.Plus| |a#26#0#0| |a#26#1#0|) Tclass._module.aexp)  (and ($Is DatatypeTypeType |a#26#0#0| Tclass._module.aexp) ($Is DatatypeTypeType |a#26#1#0| Tclass._module.aexp)))
 :pattern ( ($Is DatatypeTypeType (|#_module.aexp.Plus| |a#26#0#0| |a#26#1#0|) Tclass._module.aexp))
)))
(assert (forall ((|a#45#0#0| T@U) (|a#45#1#0| T@U) ) (! (= ($Is DatatypeTypeType (|#_module.bexp.And| |a#45#0#0| |a#45#1#0|) Tclass._module.bexp)  (and ($Is DatatypeTypeType |a#45#0#0| Tclass._module.bexp) ($Is DatatypeTypeType |a#45#1#0| Tclass._module.bexp)))
 :pattern ( ($Is DatatypeTypeType (|#_module.bexp.And| |a#45#0#0| |a#45#1#0|) Tclass._module.bexp))
)))
(assert (forall ((|a#53#0#0| T@U) (|a#53#1#0| T@U) ) (! (= ($Is DatatypeTypeType (|#_module.bexp.Less| |a#53#0#0| |a#53#1#0|) Tclass._module.bexp)  (and ($Is DatatypeTypeType |a#53#0#0| Tclass._module.aexp) ($Is DatatypeTypeType |a#53#1#0| Tclass._module.aexp)))
 :pattern ( ($Is DatatypeTypeType (|#_module.bexp.Less| |a#53#0#0| |a#53#1#0|) Tclass._module.bexp))
)))
(assert (forall ((|a#74#0#0| T@U) (|a#74#1#0| T@U) ) (! (= ($Is DatatypeTypeType (|#_module.com.Seq| |a#74#0#0| |a#74#1#0|) Tclass._module.com)  (and ($Is DatatypeTypeType |a#74#0#0| Tclass._module.com) ($Is DatatypeTypeType |a#74#1#0| Tclass._module.com)))
 :pattern ( ($Is DatatypeTypeType (|#_module.com.Seq| |a#74#0#0| |a#74#1#0|) Tclass._module.com))
)))
(assert (forall ((|a#92#0#0| T@U) (|a#92#1#0| T@U) ) (! (= ($Is DatatypeTypeType (|#_module.com.While| |a#92#0#0| |a#92#1#0|) Tclass._module.com)  (and ($Is DatatypeTypeType |a#92#0#0| Tclass._module.bexp) ($Is DatatypeTypeType |a#92#1#0| Tclass._module.com)))
 :pattern ( ($Is DatatypeTypeType (|#_module.com.While| |a#92#0#0| |a#92#1#0|) Tclass._module.com))
)))
(assert (forall (($ly@@0 T@U) (|_k#0@@0| T@U) (|c#0@@0| T@U) (|s#0@@0| T@U) (|t#0@@0| T@U) ) (! (= (_module.__default.big__step_h ($LS $ly@@0) |_k#0@@0| |c#0@@0| |s#0@@0| |t#0@@0|) (_module.__default.big__step_h $ly@@0 |_k#0@@0| |c#0@@0| |s#0@@0| |t#0@@0|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@0) |_k#0@@0| |c#0@@0| |s#0@@0| |t#0@@0|))
)))
(assert (forall (($ly@@1 T@U) (|c#0@@1| T@U) (|s#0@@1| T@U) (|c'#0| T@U) (|s'#0| T@U) ) (! (= (_module.__default.small__step ($LS $ly@@1) |c#0@@1| |s#0@@1| |c'#0| |s'#0|) (_module.__default.small__step $ly@@1 |c#0@@1| |s#0@@1| |c'#0| |s'#0|))
 :pattern ( (_module.__default.small__step ($LS $ly@@1) |c#0@@1| |s#0@@1| |c'#0| |s'#0|))
)))
(assert (forall ((|a#68#0#0| T@U) (|a#68#1#0| T@U) (i Int) ) (!  (=> (and (<= 0 i) (< i (|Seq#Length| |a#68#0#0|))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#68#0#0| i))) (DtRank (|#_module.com.Assign| |a#68#0#0| |a#68#1#0|))))
 :pattern ( (|Seq#Index| |a#68#0#0| i) (|#_module.com.Assign| |a#68#0#0| |a#68#1#0|))
)))
(assert (forall ((o T@U) (p T@U) (r T@U) ) (!  (=> (and (|ORD#Less| o p) (|ORD#Less| p r)) (|ORD#Less| o r))
 :pattern ( (|ORD#Less| o p) (|ORD#Less| p r))
 :pattern ( (|ORD#Less| o p) (|ORD#Less| o r))
)))
(assert (forall ((|a#82#0#0| T@U) (|a#82#1#0| T@U) (|a#82#2#0| T@U) ) (! (= ($Is DatatypeTypeType (|#_module.com.If| |a#82#0#0| |a#82#1#0| |a#82#2#0|) Tclass._module.com)  (and (and ($Is DatatypeTypeType |a#82#0#0| Tclass._module.bexp) ($Is DatatypeTypeType |a#82#1#0| Tclass._module.com)) ($Is DatatypeTypeType |a#82#2#0| Tclass._module.com)))
 :pattern ( ($Is DatatypeTypeType (|#_module.com.If| |a#82#0#0| |a#82#1#0| |a#82#2#0|) Tclass._module.com))
)))
(assert (forall ((a@@0 T@U) (b@@0 T@U) ) (!  (=> (and (_module.aexp.N_q a@@0) (_module.aexp.N_q b@@0)) (= (|_module.aexp#Equal| a@@0 b@@0) (= (_module.aexp.n a@@0) (_module.aexp.n b@@0))))
 :pattern ( (|_module.aexp#Equal| a@@0 b@@0) (_module.aexp.N_q a@@0))
 :pattern ( (|_module.aexp#Equal| a@@0 b@@0) (_module.aexp.N_q b@@0))
)))
(assert (forall ((|a#22#0#0| T@U) (i@@0 Int) ) (!  (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| |a#22#0#0|))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#22#0#0| i@@0))) (DtRank (|#_module.aexp.V| |a#22#0#0|))))
 :pattern ( (|Seq#Index| |a#22#0#0| i@@0) (|#_module.aexp.V| |a#22#0#0|))
)))
(assert (forall ((|a#80#0#0| T@U) (|a#80#1#0| T@U) (|a#80#2#0| T@U) ) (! (= (DatatypeCtorId (|#_module.com.If| |a#80#0#0| |a#80#1#0| |a#80#2#0|)) |##_module.com.If|)
 :pattern ( (|#_module.com.If| |a#80#0#0| |a#80#1#0| |a#80#2#0|))
)))
(assert (forall ((|a#84#0#0| T@U) (|a#84#1#0| T@U) (|a#84#2#0| T@U) ) (! (= (_module.com._h4 (|#_module.com.If| |a#84#0#0| |a#84#1#0| |a#84#2#0|)) |a#84#0#0|)
 :pattern ( (|#_module.com.If| |a#84#0#0| |a#84#1#0| |a#84#2#0|))
)))
(assert (forall ((|a#86#0#0| T@U) (|a#86#1#0| T@U) (|a#86#2#0| T@U) ) (! (= (_module.com._h5 (|#_module.com.If| |a#86#0#0| |a#86#1#0| |a#86#2#0|)) |a#86#1#0|)
 :pattern ( (|#_module.com.If| |a#86#0#0| |a#86#1#0| |a#86#2#0|))
)))
(assert (forall ((|a#88#0#0| T@U) (|a#88#1#0| T@U) (|a#88#2#0| T@U) ) (! (= (_module.com._h6 (|#_module.com.If| |a#88#0#0| |a#88#1#0| |a#88#2#0|)) |a#88#2#0|)
 :pattern ( (|#_module.com.If| |a#88#0#0| |a#88#1#0| |a#88#2#0|))
)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@2 T@U) (|c#0@@2| T@U) (|s#0@@2| T@U) (|c'#0@@0| T@U) (|s'#0@@0| T@U) ) (!  (=> (and (and (and (and ($Is DatatypeTypeType |c#0@@2| Tclass._module.com) ($Is MapType |s#0@@2| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@0| Tclass._module.com)) ($Is MapType |s'#0@@0| (TMap (TSeq TChar) TInt))) (_module.__default.small__step ($LS $ly@@2) |c#0@@2| |s#0@@2| |c'#0@@0| |s'#0@@0|)) (exists ((|_k#0@@1| T@U) ) (! (_module.__default.small__step_h ($LS $ly@@2) |_k#0@@1| |c#0@@2| |s#0@@2| |c'#0@@0| |s'#0@@0|)
 :pattern ( (_module.__default.small__step_h ($LS $ly@@2) |_k#0@@1| |c#0@@2| |s#0@@2| |c'#0@@0| |s'#0@@0|))
)))
 :pattern ( (_module.__default.small__step ($LS $ly@@2) |c#0@@2| |s#0@@2| |c'#0@@0| |s'#0@@0|))
))))
(assert (forall ((o@@0 T@U) (m Int) (n Int) ) (!  (=> (and (and (<= 0 m) (<= 0 n)) (<= (+ m n) (|ORD#Offset| o@@0))) (= (|ORD#Minus| (|ORD#Minus| o@@0 (|ORD#FromNat| m)) (|ORD#FromNat| n)) (|ORD#Minus| o@@0 (|ORD#FromNat| (+ m n)))))
 :pattern ( (|ORD#Minus| (|ORD#Minus| o@@0 (|ORD#FromNat| m)) (|ORD#FromNat| n)))
)))
(assert (forall ((|_System._tuple#2$T0| T@U) (|_System._tuple#2$T1| T@U) (d T@U) ) (!  (=> ($Is DatatypeTypeType d (Tclass._System.Tuple2 |_System._tuple#2$T0| |_System._tuple#2$T1|)) (_System.Tuple2.___hMake2_q d))
 :pattern ( (_System.Tuple2.___hMake2_q d) ($Is DatatypeTypeType d (Tclass._System.Tuple2 |_System._tuple#2$T0| |_System._tuple#2$T1|)))
)))
(assert  (and (= (Ctor BoxType) 5) (= (Ctor SeqType) 6)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@3 T@U) (|_k#0@@2| T@U) (|c#0@@3| T@U) (|s#0@@3| T@U) (|c'#0@@1| T@U) (|s'#0@@1| T@U) ) (!  (=> (or (|_module.__default.small__step_h#canCall| (Lit BoxType |_k#0@@2|) |c#0@@3| |s#0@@3| |c'#0@@1| |s'#0@@1|) (and (< 5 $FunctionContextHeight) (and (and (and ($Is DatatypeTypeType |c#0@@3| Tclass._module.com) ($Is MapType |s#0@@3| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@1| Tclass._module.com)) ($Is MapType |s'#0@@1| (TMap (TSeq TChar) TInt))))) (and (and (=> (< 0 (|ORD#Offset| |_k#0@@2|)) (=> (not (_module.com.SKIP_q |c#0@@3|)) (and (=> (_module.com.Assign_q |c#0@@3|) (let ((|a#6| (_module.com._h1 |c#0@@3|)))
 (and (|$IsA#_module.com| |c'#0@@1|) (=> (|_module.com#Equal| |c'#0@@1| |#_module.com.SKIP|) (|_module.__default.aval#canCall| |a#6| |s#0@@3|))))) (=> (not (_module.com.Assign_q |c#0@@3|)) (and (=> (_module.com.Seq_q |c#0@@3|) (let ((|c1#6| (_module.com._h3 |c#0@@3|)))
(let ((|c0#6| (_module.com._h2 |c#0@@3|)))
 (and (and (|$IsA#_module.com| |c0#6|) (=> (|_module.com#Equal| |c0#6| |#_module.com.SKIP|) (and (|$IsA#_module.com| |c'#0@@1|) (|$IsA#_module.com| |c1#6|)))) (=> (not (and (and (|_module.com#Equal| |c0#6| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@1| |c1#6|)) (|Map#Equal| |s'#0@@1| |s#0@@3|))) (forall ((|c0'#8| T@U) ) (!  (=> ($Is DatatypeTypeType |c0'#8| Tclass._module.com) (and (|$IsA#_module.com| |c'#0@@1|) (=> (|_module.com#Equal| |c'#0@@1| (|#_module.com.Seq| |c0'#8| |c1#6|)) (|_module.__default.small__step_h#canCall| (|ORD#Minus| |_k#0@@2| (|ORD#FromNat| 1)) |c0#6| |s#0@@3| |c0'#8| |s'#0@@1|))))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@3) (|ORD#Minus| |_k#0@@2| (|ORD#FromNat| 1)) |c0#6| |s#0@@3| |c0'#8| |s'#0@@1|))
 :pattern ( (|#_module.com.Seq| |c0'#8| |c1#6|))
))))))) (=> (not (_module.com.Seq_q |c#0@@3|)) (and (=> (_module.com.If_q |c#0@@3|) (let ((|els#6| (_module.com._h6 |c#0@@3|)))
(let ((|thn#6| (_module.com._h5 |c#0@@3|)))
(let ((|b#12| (_module.com._h4 |c#0@@3|)))
 (and (and (|$IsA#_module.com| |c'#0@@1|) (|$IsA#_module.com| (ite (_module.__default.bval ($LS $LZ) |b#12| |s#0@@3|) |thn#6| |els#6|))) (|_module.__default.bval#canCall| |b#12| |s#0@@3|)))))) (=> (not (_module.com.If_q |c#0@@3|)) (|$IsA#_module.com| |c'#0@@1|))))))))) (=> (=> (< 0 (|ORD#Offset| |_k#0@@2|)) (ite (_module.com.SKIP_q |c#0@@3|) false (ite (_module.com.Assign_q |c#0@@3|) (let ((|a#7| (_module.com._h1 |c#0@@3|)))
(let ((|x#7| (_module.com._h0 |c#0@@3|)))
 (and (|_module.com#Equal| |c'#0@@1| |#_module.com.SKIP|) (|Map#Equal| |s'#0@@1| (|Map#Build| |s#0@@3| ($Box SeqType |x#7|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#7| |s#0@@3|)))))))) (ite (_module.com.Seq_q |c#0@@3|) (let ((|c1#7| (_module.com._h3 |c#0@@3|)))
(let ((|c0#7| (_module.com._h2 |c#0@@3|)))
 (or (and (and (|_module.com#Equal| |c0#7| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@1| |c1#7|)) (|Map#Equal| |s'#0@@1| |s#0@@3|)) (exists ((|c0'#9| T@U) ) (!  (and ($Is DatatypeTypeType |c0'#9| Tclass._module.com) (and (|_module.com#Equal| |c'#0@@1| (|#_module.com.Seq| |c0'#9| |c1#7|)) (_module.__default.small__step_h ($LS $ly@@3) (|ORD#Minus| |_k#0@@2| (|ORD#FromNat| 1)) |c0#7| |s#0@@3| |c0'#9| |s'#0@@1|)))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@3) (|ORD#Minus| |_k#0@@2| (|ORD#FromNat| 1)) |c0#7| |s#0@@3| |c0'#9| |s'#0@@1|))
 :pattern ( (|#_module.com.Seq| |c0'#9| |c1#7|))
))))) (ite (_module.com.If_q |c#0@@3|) (let ((|els#7| (_module.com._h6 |c#0@@3|)))
(let ((|thn#7| (_module.com._h5 |c#0@@3|)))
(let ((|b#14| (_module.com._h4 |c#0@@3|)))
 (and (|_module.com#Equal| |c'#0@@1| (ite (_module.__default.bval ($LS $LZ) |b#14| |s#0@@3|) |thn#7| |els#7|)) (|Map#Equal| |s'#0@@1| |s#0@@3|))))) (let ((|body#7| (_module.com._h8 |c#0@@3|)))
(let ((|b#15| (_module.com._h7 |c#0@@3|)))
 (and (|_module.com#Equal| |c'#0@@1| (|#_module.com.If| |b#15| (|#_module.com.Seq| |body#7| (|#_module.com.While| |b#15| |body#7|)) (Lit DatatypeTypeType |#_module.com.SKIP|))) (|Map#Equal| |s'#0@@1| |s#0@@3|))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@2|)) (forall ((|_k'#1| T@U) ) (!  (=> (|ORD#LessThanLimit| |_k'#1| |_k#0@@2|) (|_module.__default.small__step_h#canCall| |_k'#1| |c#0@@3| |s#0@@3| |c'#0@@1| |s'#0@@1|))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@3) |_k'#1| |c#0@@3| |s#0@@3| |c'#0@@1| |s'#0@@1|))
))))) (= (_module.__default.small__step_h ($LS $ly@@3) (Lit BoxType |_k#0@@2|) |c#0@@3| |s#0@@3| |c'#0@@1| |s'#0@@1|)  (and (=> (< 0 (|ORD#Offset| |_k#0@@2|)) (ite (_module.com.SKIP_q |c#0@@3|) false (ite (_module.com.Assign_q |c#0@@3|) (let ((|a#5| (_module.com._h1 |c#0@@3|)))
(let ((|x#5| (_module.com._h0 |c#0@@3|)))
 (and (|_module.com#Equal| |c'#0@@1| |#_module.com.SKIP|) (|Map#Equal| |s'#0@@1| (|Map#Build| |s#0@@3| ($Box SeqType |x#5|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#5| |s#0@@3|)))))))) (ite (_module.com.Seq_q |c#0@@3|) (let ((|c1#5| (_module.com._h3 |c#0@@3|)))
(let ((|c0#5| (_module.com._h2 |c#0@@3|)))
 (or (and (and (|_module.com#Equal| |c0#5| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@1| |c1#5|)) (|Map#Equal| |s'#0@@1| |s#0@@3|)) (exists ((|c0'#7| T@U) ) (!  (and ($Is DatatypeTypeType |c0'#7| Tclass._module.com) (and (|_module.com#Equal| |c'#0@@1| (|#_module.com.Seq| |c0'#7| |c1#5|)) (_module.__default.small__step_h ($LS $ly@@3) (|ORD#Minus| |_k#0@@2| (|ORD#FromNat| 1)) |c0#5| |s#0@@3| |c0'#7| |s'#0@@1|)))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@3) (|ORD#Minus| |_k#0@@2| (|ORD#FromNat| 1)) |c0#5| |s#0@@3| |c0'#7| |s'#0@@1|))
 :pattern ( (|#_module.com.Seq| |c0'#7| |c1#5|))
))))) (ite (_module.com.If_q |c#0@@3|) (let ((|els#5| (_module.com._h6 |c#0@@3|)))
(let ((|thn#5| (_module.com._h5 |c#0@@3|)))
(let ((|b#10| (_module.com._h4 |c#0@@3|)))
 (and (|_module.com#Equal| |c'#0@@1| (ite (_module.__default.bval ($LS $LZ) |b#10| |s#0@@3|) |thn#5| |els#5|)) (|Map#Equal| |s'#0@@1| |s#0@@3|))))) (let ((|body#5| (_module.com._h8 |c#0@@3|)))
(let ((|b#11| (_module.com._h7 |c#0@@3|)))
 (and (|_module.com#Equal| |c'#0@@1| (|#_module.com.If| |b#11| (|#_module.com.Seq| |body#5| (|#_module.com.While| |b#11| |body#5|)) (Lit DatatypeTypeType |#_module.com.SKIP|))) (|Map#Equal| |s'#0@@1| |s#0@@3|))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@2|)) (exists ((|_k'#1@@0| T@U) ) (!  (and (|ORD#LessThanLimit| |_k'#1@@0| |_k#0@@2|) (_module.__default.small__step_h ($LS $ly@@3) |_k'#1@@0| |c#0@@3| |s#0@@3| |c'#0@@1| |s'#0@@1|))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@3) |_k'#1@@0| |c#0@@3| |s#0@@3| |c'#0@@1| |s'#0@@1|))
)))))))
 :weight 3
 :pattern ( (_module.__default.small__step_h ($LS $ly@@3) (Lit BoxType |_k#0@@2|) |c#0@@3| |s#0@@3| |c'#0@@1| |s'#0@@1|))
))))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@4 T@U) (|_k#0@@3| T@U) (|c#0@@4| T@U) (|s#0@@4| T@U) (|t#0@@1| T@U) ) (!  (=> (or (|_module.__default.big__step_h#canCall| (Lit BoxType |_k#0@@3|) |c#0@@4| |s#0@@4| |t#0@@1|) (and (< 5 $FunctionContextHeight) (and (and ($Is DatatypeTypeType |c#0@@4| Tclass._module.com) ($Is MapType |s#0@@4| (TMap (TSeq TChar) TInt))) ($Is MapType |t#0@@1| (TMap (TSeq TChar) TInt))))) (and (and (=> (< 0 (|ORD#Offset| |_k#0@@3|)) (=> (not (_module.com.SKIP_q |c#0@@4|)) (and (=> (_module.com.Assign_q |c#0@@4|) (let ((|a#6@@0| (_module.com._h1 |c#0@@4|)))
(|_module.__default.aval#canCall| |a#6@@0| |s#0@@4|))) (=> (not (_module.com.Assign_q |c#0@@4|)) (and (=> (_module.com.Seq_q |c#0@@4|) (let ((|c1#6@@0| (_module.com._h3 |c#0@@4|)))
(let ((|c0#6@@0| (_module.com._h2 |c#0@@4|)))
(forall ((|s'#16| T@U) ) (!  (=> ($Is MapType |s'#16| (TMap (TSeq TChar) TInt)) (and (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c0#6@@0| |s#0@@4| |s'#16|) (=> (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c0#6@@0| |s#0@@4| |s'#16|) (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c1#6@@0| |s'#16| |t#0@@1|))))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c1#6@@0| |s'#16| |t#0@@1|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c0#6@@0| |s#0@@4| |s'#16|))
))))) (=> (not (_module.com.Seq_q |c#0@@4|)) (and (=> (_module.com.If_q |c#0@@4|) (let ((|els#6@@0| (_module.com._h6 |c#0@@4|)))
(let ((|thn#6@@0| (_module.com._h5 |c#0@@4|)))
(let ((|b#12@@0| (_module.com._h4 |c#0@@4|)))
 (and (|_module.__default.bval#canCall| |b#12@@0| |s#0@@4|) (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) (ite (_module.__default.bval ($LS $LZ) |b#12@@0| |s#0@@4|) |thn#6@@0| |els#6@@0|) |s#0@@4| |t#0@@1|)))))) (=> (not (_module.com.If_q |c#0@@4|)) (let ((|body#6| (_module.com._h8 |c#0@@4|)))
(let ((|b#13| (_module.com._h7 |c#0@@4|)))
 (and (|_module.__default.bval#canCall| |b#13| |s#0@@4|) (=> (not (and (not (_module.__default.bval ($LS $LZ) |b#13| |s#0@@4|)) (|Map#Equal| |s#0@@4| |t#0@@1|))) (and (|_module.__default.bval#canCall| |b#13| |s#0@@4|) (=> (_module.__default.bval ($LS $LZ) |b#13| |s#0@@4|) (forall ((|s'#17| T@U) ) (!  (=> ($Is MapType |s'#17| (TMap (TSeq TChar) TInt)) (and (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |body#6| |s#0@@4| |s'#17|) (=> (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |body#6| |s#0@@4| |s'#17|) (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) (|#_module.com.While| |b#13| |body#6|) |s'#17| |t#0@@1|))))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) (|#_module.com.While| |b#13| |body#6|) |s'#17| |t#0@@1|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |body#6| |s#0@@4| |s'#17|))
)))))))))))))))) (=> (=> (< 0 (|ORD#Offset| |_k#0@@3|)) (ite (_module.com.SKIP_q |c#0@@4|) (|Map#Equal| |s#0@@4| |t#0@@1|) (ite (_module.com.Assign_q |c#0@@4|) (let ((|a#7@@0| (_module.com._h1 |c#0@@4|)))
(let ((|x#7@@0| (_module.com._h0 |c#0@@4|)))
(|Map#Equal| |t#0@@1| (|Map#Build| |s#0@@4| ($Box SeqType |x#7@@0|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#7@@0| |s#0@@4|))))))) (ite (_module.com.Seq_q |c#0@@4|) (let ((|c1#7@@0| (_module.com._h3 |c#0@@4|)))
(let ((|c0#7@@0| (_module.com._h2 |c#0@@4|)))
(exists ((|s'#18| T@U) ) (!  (and ($Is MapType |s'#18| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c0#7@@0| |s#0@@4| |s'#18|) (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c1#7@@0| |s'#18| |t#0@@1|)))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c1#7@@0| |s'#18| |t#0@@1|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c0#7@@0| |s#0@@4| |s'#18|))
)))) (ite (_module.com.If_q |c#0@@4|) (let ((|els#7@@0| (_module.com._h6 |c#0@@4|)))
(let ((|thn#7@@0| (_module.com._h5 |c#0@@4|)))
(let ((|b#14@@0| (_module.com._h4 |c#0@@4|)))
(_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) (ite (_module.__default.bval ($LS $LZ) |b#14@@0| |s#0@@4|) |thn#7@@0| |els#7@@0|) |s#0@@4| |t#0@@1|)))) (let ((|body#7@@0| (_module.com._h8 |c#0@@4|)))
(let ((|b#15@@0| (_module.com._h7 |c#0@@4|)))
 (or (and (not (_module.__default.bval ($LS $LZ) |b#15@@0| |s#0@@4|)) (|Map#Equal| |s#0@@4| |t#0@@1|)) (and (_module.__default.bval ($LS $LZ) |b#15@@0| |s#0@@4|) (exists ((|s'#19| T@U) ) (!  (and ($Is MapType |s'#19| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |body#7@@0| |s#0@@4| |s'#19|) (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) (|#_module.com.While| |b#15@@0| |body#7@@0|) |s'#19| |t#0@@1|)))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) (|#_module.com.While| |b#15@@0| |body#7@@0|) |s'#19| |t#0@@1|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |body#7@@0| |s#0@@4| |s'#19|))
))))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@3|)) (forall ((|_k'#1@@1| T@U) ) (!  (=> (|ORD#LessThanLimit| |_k'#1@@1| |_k#0@@3|) (|_module.__default.big__step_h#canCall| |_k'#1@@1| |c#0@@4| |s#0@@4| |t#0@@1|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) |_k'#1@@1| |c#0@@4| |s#0@@4| |t#0@@1|))
))))) (= (_module.__default.big__step_h ($LS $ly@@4) (Lit BoxType |_k#0@@3|) |c#0@@4| |s#0@@4| |t#0@@1|)  (and (=> (< 0 (|ORD#Offset| |_k#0@@3|)) (ite (_module.com.SKIP_q |c#0@@4|) (|Map#Equal| |s#0@@4| |t#0@@1|) (ite (_module.com.Assign_q |c#0@@4|) (let ((|a#5@@0| (_module.com._h1 |c#0@@4|)))
(let ((|x#5@@0| (_module.com._h0 |c#0@@4|)))
(|Map#Equal| |t#0@@1| (|Map#Build| |s#0@@4| ($Box SeqType |x#5@@0|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#5@@0| |s#0@@4|))))))) (ite (_module.com.Seq_q |c#0@@4|) (let ((|c1#5@@0| (_module.com._h3 |c#0@@4|)))
(let ((|c0#5@@0| (_module.com._h2 |c#0@@4|)))
(exists ((|s'#14| T@U) ) (!  (and ($Is MapType |s'#14| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c0#5@@0| |s#0@@4| |s'#14|) (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c1#5@@0| |s'#14| |t#0@@1|)))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c1#5@@0| |s'#14| |t#0@@1|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |c0#5@@0| |s#0@@4| |s'#14|))
)))) (ite (_module.com.If_q |c#0@@4|) (let ((|els#5@@0| (_module.com._h6 |c#0@@4|)))
(let ((|thn#5@@0| (_module.com._h5 |c#0@@4|)))
(let ((|b#10@@0| (_module.com._h4 |c#0@@4|)))
(_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) (ite (_module.__default.bval ($LS $LZ) |b#10@@0| |s#0@@4|) |thn#5@@0| |els#5@@0|) |s#0@@4| |t#0@@1|)))) (let ((|body#5@@0| (_module.com._h8 |c#0@@4|)))
(let ((|b#11@@0| (_module.com._h7 |c#0@@4|)))
 (or (and (not (_module.__default.bval ($LS $LZ) |b#11@@0| |s#0@@4|)) (|Map#Equal| |s#0@@4| |t#0@@1|)) (and (_module.__default.bval ($LS $LZ) |b#11@@0| |s#0@@4|) (exists ((|s'#15| T@U) ) (!  (and ($Is MapType |s'#15| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |body#5@@0| |s#0@@4| |s'#15|) (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) (|#_module.com.While| |b#11@@0| |body#5@@0|) |s'#15| |t#0@@1|)))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) (|#_module.com.While| |b#11@@0| |body#5@@0|) |s'#15| |t#0@@1|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (|ORD#Minus| |_k#0@@3| (|ORD#FromNat| 1)) |body#5@@0| |s#0@@4| |s'#15|))
))))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@3|)) (exists ((|_k'#1@@2| T@U) ) (!  (and (|ORD#LessThanLimit| |_k'#1@@2| |_k#0@@3|) (_module.__default.big__step_h ($LS $ly@@4) |_k'#1@@2| |c#0@@4| |s#0@@4| |t#0@@1|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) |_k'#1@@2| |c#0@@4| |s#0@@4| |t#0@@1|))
)))))))
 :weight 3
 :pattern ( (_module.__default.big__step_h ($LS $ly@@4) (Lit BoxType |_k#0@@3|) |c#0@@4| |s#0@@4| |t#0@@1|))
))))
(assert (= (|Seq#Length| |Seq#Empty|) 0))
(assert (= (DatatypeCtorId |#_module.com.SKIP|) |##_module.com.SKIP|))
(assert (forall ((|_System._tuple#2$T0@@0| T@U) (|_System._tuple#2$T1@@0| T@U) (|a#2#0#0| T@U) (|a#2#1#0| T@U) ) (! (= ($Is DatatypeTypeType (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@0| |_System._tuple#2$T1@@0|))  (and ($IsBox |a#2#0#0| |_System._tuple#2$T0@@0|) ($IsBox |a#2#1#0| |_System._tuple#2$T1@@0|)))
 :pattern ( ($Is DatatypeTypeType (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@0| |_System._tuple#2$T1@@0|)))
)))
(assert ($Is DatatypeTypeType |#_module.com.SKIP| Tclass._module.com))
(assert (forall ((a@@1 T@U) (b@@1 T@U) ) (!  (=> (and (_module.com.If_q a@@1) (_module.com.If_q b@@1)) (= (|_module.com#Equal| a@@1 b@@1)  (and (and (|_module.bexp#Equal| (_module.com._h4 a@@1) (_module.com._h4 b@@1)) (|_module.com#Equal| (_module.com._h5 a@@1) (_module.com._h5 b@@1))) (|_module.com#Equal| (_module.com._h6 a@@1) (_module.com._h6 b@@1)))))
 :pattern ( (|_module.com#Equal| a@@1 b@@1) (_module.com.If_q a@@1))
 :pattern ( (|_module.com#Equal| a@@1 b@@1) (_module.com.If_q b@@1))
)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@5 T@U) (|c#0@@5| T@U) (|s#0@@5| T@U) (|c'#0@@2| T@U) (|s'#0@@2| T@U) ) (!  (=> (and (and (and (and ($Is DatatypeTypeType |c#0@@5| Tclass._module.com) ($Is MapType |s#0@@5| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@2| Tclass._module.com)) ($Is MapType |s'#0@@2| (TMap (TSeq TChar) TInt))) (exists ((|_k#0@@4| T@U) ) (! (_module.__default.small__step_h ($LS $ly@@5) |_k#0@@4| |c#0@@5| |s#0@@5| |c'#0@@2| |s'#0@@2|)
 :pattern ( (_module.__default.small__step_h ($LS $ly@@5) |_k#0@@4| |c#0@@5| |s#0@@5| |c'#0@@2| |s'#0@@2|))
))) (_module.__default.small__step ($LS $ly@@5) |c#0@@5| |s#0@@5| |c'#0@@2| |s'#0@@2|))
 :pattern ( (_module.__default.small__step ($LS $ly@@5) |c#0@@5| |s#0@@5| |c'#0@@2| |s'#0@@2|))
))))
(assert (forall ((a@@2 T@U) (b@@2 T@U) ) (! (= (|_module.aexp#Equal| a@@2 b@@2) (= a@@2 b@@2))
 :pattern ( (|_module.aexp#Equal| a@@2 b@@2))
)))
(assert (forall ((a@@3 T@U) (b@@3 T@U) ) (! (= (|_module.bexp#Equal| a@@3 b@@3) (= a@@3 b@@3))
 :pattern ( (|_module.bexp#Equal| a@@3 b@@3))
)))
(assert (forall ((a@@4 T@U) (b@@4 T@U) ) (! (= (|_module.com#Equal| a@@4 b@@4) (= a@@4 b@@4))
 :pattern ( (|_module.com#Equal| a@@4 b@@4))
)))
(assert  (and (forall ((t0 T@T) (t1 T@T) (val T@U) (m@@0 T@U) (x0 T@U) ) (! (= (MapType0Select t0 t1 (MapType0Store t0 t1 m@@0 x0 val) x0) val)
 :weight 0
)) (forall ((u0 T@T) (u1 T@T) (val@@0 T@U) (m@@1 T@U) (x0@@0 T@U) (y0 T@U) ) (!  (or (= x0@@0 y0) (= (MapType0Select u0 u1 (MapType0Store u0 u1 m@@1 x0@@0 val@@0) y0) (MapType0Select u0 u1 m@@1 y0)))
 :weight 0
))))
(assert  (=> (<= 2 $FunctionContextHeight) (forall (($ly@@6 T@U) (|a#0| T@U) (|s#0@@6| T@U) ) (!  (=> (or (|_module.__default.aval#canCall| (Lit DatatypeTypeType |a#0|) (Lit MapType |s#0@@6|)) (and (< 2 $FunctionContextHeight) (and ($Is DatatypeTypeType |a#0| Tclass._module.aexp) ($Is MapType |s#0@@6| (TMap (TSeq TChar) TInt))))) (and (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.aexp.N_q (Lit DatatypeTypeType |a#0|)))))) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.aexp.V_q (Lit DatatypeTypeType |a#0|)))))) (let ((|a1#3| (Lit DatatypeTypeType (_module.aexp._1 (Lit DatatypeTypeType |a#0|)))))
(let ((|a0#3| (Lit DatatypeTypeType (_module.aexp._0 (Lit DatatypeTypeType |a#0|)))))
 (and (|_module.__default.aval#canCall| |a0#3| (Lit MapType |s#0@@6|)) (|_module.__default.aval#canCall| |a1#3| (Lit MapType |s#0@@6|))))))) (= (_module.__default.aval ($LS $ly@@6) (Lit DatatypeTypeType |a#0|) (Lit MapType |s#0@@6|)) (ite (_module.aexp.N_q (Lit DatatypeTypeType |a#0|)) (let ((|n#2| (LitInt (_module.aexp.n (Lit DatatypeTypeType |a#0|)))))
|n#2|) (ite (_module.aexp.V_q (Lit DatatypeTypeType |a#0|)) (let ((|x#2| (Lit SeqType (_module.aexp.x (Lit DatatypeTypeType |a#0|)))))
(ite (|Set#IsMember| (|Map#Domain| |s#0@@6|) ($Box SeqType |x#2|)) (U_2_int ($Unbox intType (MapType0Select BoxType BoxType (|Map#Elements| (Lit MapType |s#0@@6|)) ($Box SeqType |x#2|)))) 0)) (let ((|a1#2| (Lit DatatypeTypeType (_module.aexp._1 (Lit DatatypeTypeType |a#0|)))))
(let ((|a0#2| (Lit DatatypeTypeType (_module.aexp._0 (Lit DatatypeTypeType |a#0|)))))
(LitInt (+ (_module.__default.aval ($LS $ly@@6) |a0#2| (Lit MapType |s#0@@6|)) (_module.__default.aval ($LS $ly@@6) |a1#2| (Lit MapType |s#0@@6|)))))))))))
 :weight 3
 :pattern ( (_module.__default.aval ($LS $ly@@6) (Lit DatatypeTypeType |a#0|) (Lit MapType |s#0@@6|)))
))))
(assert  (=> (<= 3 $FunctionContextHeight) (forall (($ly@@7 T@U) (|b#0| T@U) (|s#0@@7| T@U) ) (!  (=> (or (|_module.__default.bval#canCall| (Lit DatatypeTypeType |b#0|) (Lit MapType |s#0@@7|)) (and (< 3 $FunctionContextHeight) (and ($Is DatatypeTypeType |b#0| Tclass._module.bexp) ($Is MapType |s#0@@7| (TMap (TSeq TChar) TInt))))) (and (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.bexp.Bc_q (Lit DatatypeTypeType |b#0|)))))) (and (=> (U_2_bool (Lit boolType (bool_2_U (_module.bexp.Not_q (Lit DatatypeTypeType |b#0|))))) (let ((|b#4| (Lit DatatypeTypeType (_module.bexp.op (Lit DatatypeTypeType |b#0|)))))
(|_module.__default.bval#canCall| |b#4| (Lit MapType |s#0@@7|)))) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.bexp.Not_q (Lit DatatypeTypeType |b#0|)))))) (and (=> (U_2_bool (Lit boolType (bool_2_U (_module.bexp.And_q (Lit DatatypeTypeType |b#0|))))) (let ((|b1#3| (Lit DatatypeTypeType (_module.bexp._1 (Lit DatatypeTypeType |b#0|)))))
(let ((|b0#3| (Lit DatatypeTypeType (_module.bexp._0 (Lit DatatypeTypeType |b#0|)))))
 (and (|_module.__default.bval#canCall| |b0#3| (Lit MapType |s#0@@7|)) (=> (_module.__default.bval ($LS $ly@@7) |b0#3| (Lit MapType |s#0@@7|)) (|_module.__default.bval#canCall| |b1#3| (Lit MapType |s#0@@7|))))))) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.bexp.And_q (Lit DatatypeTypeType |b#0|)))))) (let ((|a1#3@@0| (Lit DatatypeTypeType (_module.bexp.a1 (Lit DatatypeTypeType |b#0|)))))
(let ((|a0#3@@0| (Lit DatatypeTypeType (_module.bexp.a0 (Lit DatatypeTypeType |b#0|)))))
 (and (|_module.__default.aval#canCall| |a0#3@@0| (Lit MapType |s#0@@7|)) (|_module.__default.aval#canCall| |a1#3@@0| (Lit MapType |s#0@@7|)))))))))) (= (_module.__default.bval ($LS $ly@@7) (Lit DatatypeTypeType |b#0|) (Lit MapType |s#0@@7|)) (ite (_module.bexp.Bc_q (Lit DatatypeTypeType |b#0|)) (let ((|v#2| (U_2_bool (Lit boolType (bool_2_U (_module.bexp.v (Lit DatatypeTypeType |b#0|)))))))
|v#2|) (ite (_module.bexp.Not_q (Lit DatatypeTypeType |b#0|)) (let ((|b#3| (Lit DatatypeTypeType (_module.bexp.op (Lit DatatypeTypeType |b#0|)))))
 (not (U_2_bool (Lit boolType (bool_2_U (_module.__default.bval ($LS $ly@@7) |b#3| (Lit MapType |s#0@@7|))))))) (ite (_module.bexp.And_q (Lit DatatypeTypeType |b#0|)) (U_2_bool (let ((|b1#2| (Lit DatatypeTypeType (_module.bexp._1 (Lit DatatypeTypeType |b#0|)))))
(let ((|b0#2| (Lit DatatypeTypeType (_module.bexp._0 (Lit DatatypeTypeType |b#0|)))))
(Lit boolType (bool_2_U  (and (_module.__default.bval ($LS $ly@@7) |b0#2| (Lit MapType |s#0@@7|)) (_module.__default.bval ($LS $ly@@7) |b1#2| (Lit MapType |s#0@@7|)))))))) (U_2_bool (let ((|a1#2@@0| (Lit DatatypeTypeType (_module.bexp.a1 (Lit DatatypeTypeType |b#0|)))))
(let ((|a0#2@@0| (Lit DatatypeTypeType (_module.bexp.a0 (Lit DatatypeTypeType |b#0|)))))
(Lit boolType (bool_2_U (< (_module.__default.aval ($LS $LZ) |a0#2@@0| (Lit MapType |s#0@@7|)) (_module.__default.aval ($LS $LZ) |a1#2@@0| (Lit MapType |s#0@@7|))))))))))))))
 :weight 3
 :pattern ( (_module.__default.bval ($LS $ly@@7) (Lit DatatypeTypeType |b#0|) (Lit MapType |s#0@@7|)))
))))
(assert (forall ((x@@2 Int) ) (! (= (LitInt x@@2) x@@2)
 :pattern ( (LitInt x@@2))
)))
(assert (forall ((x@@3 T@U) (T T@T) ) (! (= (Lit T x@@3) x@@3)
 :pattern ( (Lit T x@@3))
)))
(assert (forall ((a@@5 T@U) (b@@5 T@U) ) (! (= (|Set#Subset| a@@5 b@@5) (forall ((o@@1 T@U) ) (!  (=> (|Set#IsMember| a@@5 o@@1) (|Set#IsMember| b@@5 o@@1))
 :pattern ( (|Set#IsMember| a@@5 o@@1))
 :pattern ( (|Set#IsMember| b@@5 o@@1))
)))
 :pattern ( (|Set#Subset| a@@5 b@@5))
)))
(assert (forall ((|_System._tuple#2$T0@@1| T@U) (|_System._tuple#2$T1@@1| T@U) (|a#2#0#0@@0| T@U) (|a#2#1#0@@0| T@U) ($h T@U) ) (!  (=> ($IsGoodHeap $h) (= ($IsAlloc DatatypeTypeType (|#_System._tuple#2._#Make2| |a#2#0#0@@0| |a#2#1#0@@0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@1| |_System._tuple#2$T1@@1|) $h)  (and ($IsAllocBox |a#2#0#0@@0| |_System._tuple#2$T0@@1| $h) ($IsAllocBox |a#2#1#0@@0| |_System._tuple#2$T1@@1| $h))))
 :pattern ( ($IsAlloc DatatypeTypeType (|#_System._tuple#2._#Make2| |a#2#0#0@@0| |a#2#1#0@@0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@1| |_System._tuple#2$T1@@1|) $h))
)))
(assert (forall ((d@@0 T@U) ) (! (= (_System.Tuple2.___hMake2_q d@@0) (= (DatatypeCtorId d@@0) |##_System._tuple#2._#Make2|))
 :pattern ( (_System.Tuple2.___hMake2_q d@@0))
)))
(assert (forall ((d@@1 T@U) ) (! (= (_module.aexp.N_q d@@1) (= (DatatypeCtorId d@@1) |##_module.aexp.N|))
 :pattern ( (_module.aexp.N_q d@@1))
)))
(assert (forall ((d@@2 T@U) ) (! (= (_module.aexp.V_q d@@2) (= (DatatypeCtorId d@@2) |##_module.aexp.V|))
 :pattern ( (_module.aexp.V_q d@@2))
)))
(assert (forall ((d@@3 T@U) ) (! (= (_module.aexp.Plus_q d@@3) (= (DatatypeCtorId d@@3) |##_module.aexp.Plus|))
 :pattern ( (_module.aexp.Plus_q d@@3))
)))
(assert (forall ((d@@4 T@U) ) (! (= (_module.bexp.Bc_q d@@4) (= (DatatypeCtorId d@@4) |##_module.bexp.Bc|))
 :pattern ( (_module.bexp.Bc_q d@@4))
)))
(assert (forall ((d@@5 T@U) ) (! (= (_module.bexp.Not_q d@@5) (= (DatatypeCtorId d@@5) |##_module.bexp.Not|))
 :pattern ( (_module.bexp.Not_q d@@5))
)))
(assert (forall ((d@@6 T@U) ) (! (= (_module.bexp.And_q d@@6) (= (DatatypeCtorId d@@6) |##_module.bexp.And|))
 :pattern ( (_module.bexp.And_q d@@6))
)))
(assert (forall ((d@@7 T@U) ) (! (= (_module.bexp.Less_q d@@7) (= (DatatypeCtorId d@@7) |##_module.bexp.Less|))
 :pattern ( (_module.bexp.Less_q d@@7))
)))
(assert (forall ((d@@8 T@U) ) (! (= (_module.com.SKIP_q d@@8) (= (DatatypeCtorId d@@8) |##_module.com.SKIP|))
 :pattern ( (_module.com.SKIP_q d@@8))
)))
(assert (forall ((d@@9 T@U) ) (! (= (_module.com.Assign_q d@@9) (= (DatatypeCtorId d@@9) |##_module.com.Assign|))
 :pattern ( (_module.com.Assign_q d@@9))
)))
(assert (forall ((d@@10 T@U) ) (! (= (_module.com.Seq_q d@@10) (= (DatatypeCtorId d@@10) |##_module.com.Seq|))
 :pattern ( (_module.com.Seq_q d@@10))
)))
(assert (forall ((d@@11 T@U) ) (! (= (_module.com.If_q d@@11) (= (DatatypeCtorId d@@11) |##_module.com.If|))
 :pattern ( (_module.com.If_q d@@11))
)))
(assert (forall ((d@@12 T@U) ) (! (= (_module.com.While_q d@@12) (= (DatatypeCtorId d@@12) |##_module.com.While|))
 :pattern ( (_module.com.While_q d@@12))
)))
(assert (forall ((s0 T@U) (s1 T@U) ) (! (= (|Seq#Equal| s0 s1)  (and (= (|Seq#Length| s0) (|Seq#Length| s1)) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|Seq#Length| s0))) (= (|Seq#Index| s0 j) (|Seq#Index| s1 j)))
 :pattern ( (|Seq#Index| s0 j))
 :pattern ( (|Seq#Index| s1 j))
))))
 :pattern ( (|Seq#Equal| s0 s1))
)))
(assert (forall ((x@@4 T@U) (T@@0 T@T) ) (! (= ($Box T@@0 ($Unbox T@@0 x@@4)) x@@4)
 :pattern ( ($Unbox T@@0 x@@4))
)))
(assert (forall ((d@@13 T@U) ) (!  (=> (_module.com.If_q d@@13) (exists ((|a#81#0#0| T@U) (|a#81#1#0| T@U) (|a#81#2#0| T@U) ) (= d@@13 (|#_module.com.If| |a#81#0#0| |a#81#1#0| |a#81#2#0|))))
 :pattern ( (_module.com.If_q d@@13))
)))
(assert (forall ((d@@14 T@U) ) (!  (=> (_System.Tuple2.___hMake2_q d@@14) (exists ((|a#1#0#0| T@U) (|a#1#1#0| T@U) ) (= d@@14 (|#_System._tuple#2._#Make2| |a#1#0#0| |a#1#1#0|))))
 :pattern ( (_System.Tuple2.___hMake2_q d@@14))
)))
(assert (forall ((d@@15 T@U) ) (!  (=> (_module.aexp.Plus_q d@@15) (exists ((|a#25#0#0| T@U) (|a#25#1#0| T@U) ) (= d@@15 (|#_module.aexp.Plus| |a#25#0#0| |a#25#1#0|))))
 :pattern ( (_module.aexp.Plus_q d@@15))
)))
(assert (forall ((d@@16 T@U) ) (!  (=> (_module.bexp.And_q d@@16) (exists ((|a#44#0#0| T@U) (|a#44#1#0| T@U) ) (= d@@16 (|#_module.bexp.And| |a#44#0#0| |a#44#1#0|))))
 :pattern ( (_module.bexp.And_q d@@16))
)))
(assert (forall ((d@@17 T@U) ) (!  (=> (_module.bexp.Less_q d@@17) (exists ((|a#52#0#0| T@U) (|a#52#1#0| T@U) ) (= d@@17 (|#_module.bexp.Less| |a#52#0#0| |a#52#1#0|))))
 :pattern ( (_module.bexp.Less_q d@@17))
)))
(assert (forall ((d@@18 T@U) ) (!  (=> (_module.com.Assign_q d@@18) (exists ((|a#64#0#0| T@U) (|a#64#1#0| T@U) ) (= d@@18 (|#_module.com.Assign| |a#64#0#0| |a#64#1#0|))))
 :pattern ( (_module.com.Assign_q d@@18))
)))
(assert (forall ((d@@19 T@U) ) (!  (=> (_module.com.Seq_q d@@19) (exists ((|a#73#0#0| T@U) (|a#73#1#0| T@U) ) (= d@@19 (|#_module.com.Seq| |a#73#0#0| |a#73#1#0|))))
 :pattern ( (_module.com.Seq_q d@@19))
)))
(assert (forall ((d@@20 T@U) ) (!  (=> (_module.com.While_q d@@20) (exists ((|a#91#0#0| T@U) (|a#91#1#0| T@U) ) (= d@@20 (|#_module.com.While| |a#91#0#0| |a#91#1#0|))))
 :pattern ( (_module.com.While_q d@@20))
)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@8 T@U) (|c#0@@6| T@U) (|s#0@@8| T@U) (|t#0@@2| T@U) (|_k#0@@5| T@U) ) (!  (=> (and (and (and ($Is DatatypeTypeType |c#0@@6| Tclass._module.com) ($Is MapType |s#0@@8| (TMap (TSeq TChar) TInt))) ($Is MapType |t#0@@2| (TMap (TSeq TChar) TInt))) (= |_k#0@@5| (|ORD#FromNat| 0))) (not (_module.__default.big__step_h $ly@@8 |_k#0@@5| |c#0@@6| |s#0@@8| |t#0@@2|)))
 :pattern ( (_module.__default.big__step_h $ly@@8 |_k#0@@5| |c#0@@6| |s#0@@8| |t#0@@2|))
))))
(assert  (=> (<= 4 $FunctionContextHeight) (forall (($ly@@9 T@U) (|c#0@@7| T@U) (|s#0@@9| T@U) (|c'#0@@3| T@U) (|s'#0@@3| T@U) ) (!  (=> (or (|_module.__default.small__step#canCall| |c#0@@7| |s#0@@9| |c'#0@@3| |s'#0@@3|) (and (< 4 $FunctionContextHeight) (and (and (and ($Is DatatypeTypeType |c#0@@7| Tclass._module.com) ($Is MapType |s#0@@9| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@3| Tclass._module.com)) ($Is MapType |s'#0@@3| (TMap (TSeq TChar) TInt))))) (and (=> (not (_module.com.SKIP_q |c#0@@7|)) (and (=> (_module.com.Assign_q |c#0@@7|) (let ((|a#1| (_module.com._h1 |c#0@@7|)))
 (and (|$IsA#_module.com| |c'#0@@3|) (=> (|_module.com#Equal| |c'#0@@3| |#_module.com.SKIP|) (|_module.__default.aval#canCall| |a#1| |s#0@@9|))))) (=> (not (_module.com.Assign_q |c#0@@7|)) (and (=> (_module.com.Seq_q |c#0@@7|) (let ((|c1#1| (_module.com._h3 |c#0@@7|)))
(let ((|c0#1| (_module.com._h2 |c#0@@7|)))
 (and (and (|$IsA#_module.com| |c0#1|) (=> (|_module.com#Equal| |c0#1| |#_module.com.SKIP|) (and (|$IsA#_module.com| |c'#0@@3|) (|$IsA#_module.com| |c1#1|)))) (=> (not (and (and (|_module.com#Equal| |c0#1| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@3| |c1#1|)) (|Map#Equal| |s'#0@@3| |s#0@@9|))) (forall ((|c0'#1| T@U) ) (!  (=> ($Is DatatypeTypeType |c0'#1| Tclass._module.com) (and (|$IsA#_module.com| |c'#0@@3|) (=> (|_module.com#Equal| |c'#0@@3| (|#_module.com.Seq| |c0'#1| |c1#1|)) (|_module.__default.small__step#canCall| |c0#1| |s#0@@9| |c0'#1| |s'#0@@3|))))
 :pattern ( (_module.__default.small__step $ly@@9 |c0#1| |s#0@@9| |c0'#1| |s'#0@@3|))
 :pattern ( (|#_module.com.Seq| |c0'#1| |c1#1|))
))))))) (=> (not (_module.com.Seq_q |c#0@@7|)) (and (=> (_module.com.If_q |c#0@@7|) (let ((|els#1| (_module.com._h6 |c#0@@7|)))
(let ((|thn#1| (_module.com._h5 |c#0@@7|)))
(let ((|b#2| (_module.com._h4 |c#0@@7|)))
 (and (and (|$IsA#_module.com| |c'#0@@3|) (|$IsA#_module.com| (ite (_module.__default.bval ($LS $LZ) |b#2| |s#0@@9|) |thn#1| |els#1|))) (|_module.__default.bval#canCall| |b#2| |s#0@@9|)))))) (=> (not (_module.com.If_q |c#0@@7|)) (|$IsA#_module.com| |c'#0@@3|)))))))) (= (_module.__default.small__step ($LS $ly@@9) |c#0@@7| |s#0@@9| |c'#0@@3| |s'#0@@3|) (ite (_module.com.SKIP_q |c#0@@7|) false (ite (_module.com.Assign_q |c#0@@7|) (let ((|a#0@@0| (_module.com._h1 |c#0@@7|)))
(let ((|x#0| (_module.com._h0 |c#0@@7|)))
 (and (|_module.com#Equal| |c'#0@@3| |#_module.com.SKIP|) (|Map#Equal| |s'#0@@3| (|Map#Build| |s#0@@9| ($Box SeqType |x#0|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#0@@0| |s#0@@9|)))))))) (ite (_module.com.Seq_q |c#0@@7|) (let ((|c1#0| (_module.com._h3 |c#0@@7|)))
(let ((|c0#0| (_module.com._h2 |c#0@@7|)))
 (or (and (and (|_module.com#Equal| |c0#0| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@3| |c1#0|)) (|Map#Equal| |s'#0@@3| |s#0@@9|)) (exists ((|c0'#0| T@U) ) (!  (and ($Is DatatypeTypeType |c0'#0| Tclass._module.com) (and (|_module.com#Equal| |c'#0@@3| (|#_module.com.Seq| |c0'#0| |c1#0|)) (_module.__default.small__step $ly@@9 |c0#0| |s#0@@9| |c0'#0| |s'#0@@3|)))
 :pattern ( (_module.__default.small__step $ly@@9 |c0#0| |s#0@@9| |c0'#0| |s'#0@@3|))
 :pattern ( (|#_module.com.Seq| |c0'#0| |c1#0|))
))))) (ite (_module.com.If_q |c#0@@7|) (let ((|els#0| (_module.com._h6 |c#0@@7|)))
(let ((|thn#0| (_module.com._h5 |c#0@@7|)))
(let ((|b#0@@0| (_module.com._h4 |c#0@@7|)))
 (and (|_module.com#Equal| |c'#0@@3| (ite (_module.__default.bval ($LS $LZ) |b#0@@0| |s#0@@9|) |thn#0| |els#0|)) (|Map#Equal| |s'#0@@3| |s#0@@9|))))) (let ((|body#0| (_module.com._h8 |c#0@@7|)))
(let ((|b#1| (_module.com._h7 |c#0@@7|)))
 (and (|_module.com#Equal| |c'#0@@3| (|#_module.com.If| |b#1| (|#_module.com.Seq| |body#0| (|#_module.com.While| |b#1| |body#0|)) (Lit DatatypeTypeType |#_module.com.SKIP|))) (|Map#Equal| |s'#0@@3| |s#0@@9|)))))))))))
 :pattern ( (_module.__default.small__step ($LS $ly@@9) |c#0@@7| |s#0@@9| |c'#0@@3| |s'#0@@3|))
))))
(assert (forall ((d@@21 T@U) ) (!  (=> (_module.com.SKIP_q d@@21) (= d@@21 |#_module.com.SKIP|))
 :pattern ( (_module.com.SKIP_q d@@21))
)))
(assert (= (Ctor SetType) 7))
(assert (forall ((v T@U) (t0@@0 T@U) ) (! (= ($Is SetType v (TSet t0@@0)) (forall ((bx T@U) ) (!  (=> (|Set#IsMember| v bx) ($IsBox bx t0@@0))
 :pattern ( (|Set#IsMember| v bx))
)))
 :pattern ( ($Is SetType v (TSet t0@@0)))
)))
(assert (forall ((d@@22 T@U) ) (!  (=> (_module.aexp.N_q d@@22) (exists ((|a#13#0#0| Int) ) (= d@@22 (|#_module.aexp.N| |a#13#0#0|))))
 :pattern ( (_module.aexp.N_q d@@22))
)))
(assert (forall ((d@@23 T@U) ) (!  (=> (_module.aexp.V_q d@@23) (exists ((|a#18#0#0| T@U) ) (= d@@23 (|#_module.aexp.V| |a#18#0#0|))))
 :pattern ( (_module.aexp.V_q d@@23))
)))
(assert (forall ((d@@24 T@U) ) (!  (=> (_module.bexp.Bc_q d@@24) (exists ((|a#33#0#0| Bool) ) (= d@@24 (|#_module.bexp.Bc| |a#33#0#0|))))
 :pattern ( (_module.bexp.Bc_q d@@24))
)))
(assert (forall ((d@@25 T@U) ) (!  (=> (_module.bexp.Not_q d@@25) (exists ((|a#38#0#0| T@U) ) (= d@@25 (|#_module.bexp.Not| |a#38#0#0|))))
 :pattern ( (_module.bexp.Not_q d@@25))
)))
(assert  (=> (<= 6 $FunctionContextHeight) (forall (($ly@@10 T@U) (|_k#0@@6| T@U) (|c#0@@8| T@U) (|s#0@@10| T@U) (|c'#0@@4| T@U) (|s'#0@@4| T@U) ) (!  (=> (or (|_module.__default.small__step__star_h#canCall| |_k#0@@6| |c#0@@8| |s#0@@10| |c'#0@@4| |s'#0@@4|) (and (< 6 $FunctionContextHeight) (and (and (and ($Is DatatypeTypeType |c#0@@8| Tclass._module.com) ($Is MapType |s#0@@10| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@4| Tclass._module.com)) ($Is MapType |s'#0@@4| (TMap (TSeq TChar) TInt))))) (and (and (=> (< 0 (|ORD#Offset| |_k#0@@6|)) (and (and (|$IsA#_module.com| |c#0@@8|) (|$IsA#_module.com| |c'#0@@4|)) (=> (not (and (|_module.com#Equal| |c#0@@8| |c'#0@@4|) (|Map#Equal| |s#0@@10| |s'#0@@4|))) (forall ((|c''#3| T@U) (|s''#3| T@U) ) (!  (=> (and ($Is DatatypeTypeType |c''#3| Tclass._module.com) ($Is MapType |s''#3| (TMap (TSeq TChar) TInt))) (and (|_module.__default.small__step#canCall| |c#0@@8| |s#0@@10| |c''#3| |s''#3|) (=> (_module.__default.small__step ($LS $LZ) |c#0@@8| |s#0@@10| |c''#3| |s''#3|) (|_module.__default.small__step__star_h#canCall| (|ORD#Minus| |_k#0@@6| (|ORD#FromNat| 1)) |c''#3| |s''#3| |c'#0@@4| |s'#0@@4|))))
 :pattern ( (_module.__default.small__step__star_h $ly@@10 (|ORD#Minus| |_k#0@@6| (|ORD#FromNat| 1)) |c''#3| |s''#3| |c'#0@@4| |s'#0@@4|))
 :pattern ( (_module.__default.small__step ($LS $LZ) |c#0@@8| |s#0@@10| |c''#3| |s''#3|))
))))) (=> (=> (< 0 (|ORD#Offset| |_k#0@@6|)) (or (and (|_module.com#Equal| |c#0@@8| |c'#0@@4|) (|Map#Equal| |s#0@@10| |s'#0@@4|)) (exists ((|c''#3@@0| T@U) (|s''#3@@0| T@U) ) (!  (and (and ($Is DatatypeTypeType |c''#3@@0| Tclass._module.com) ($Is MapType |s''#3@@0| (TMap (TSeq TChar) TInt))) (and (_module.__default.small__step ($LS $LZ) |c#0@@8| |s#0@@10| |c''#3@@0| |s''#3@@0|) (_module.__default.small__step__star_h $ly@@10 (|ORD#Minus| |_k#0@@6| (|ORD#FromNat| 1)) |c''#3@@0| |s''#3@@0| |c'#0@@4| |s'#0@@4|)))
 :pattern ( (_module.__default.small__step__star_h $ly@@10 (|ORD#Minus| |_k#0@@6| (|ORD#FromNat| 1)) |c''#3@@0| |s''#3@@0| |c'#0@@4| |s'#0@@4|))
 :pattern ( (_module.__default.small__step ($LS $LZ) |c#0@@8| |s#0@@10| |c''#3@@0| |s''#3@@0|))
)))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@6|)) (forall ((|_k'#0| T@U) ) (!  (=> (|ORD#LessThanLimit| |_k'#0| |_k#0@@6|) (|_module.__default.small__step__star_h#canCall| |_k'#0| |c#0@@8| |s#0@@10| |c'#0@@4| |s'#0@@4|))
 :pattern ( (_module.__default.small__step__star_h $ly@@10 |_k'#0| |c#0@@8| |s#0@@10| |c'#0@@4| |s'#0@@4|))
))))) (= (_module.__default.small__step__star_h ($LS $ly@@10) |_k#0@@6| |c#0@@8| |s#0@@10| |c'#0@@4| |s'#0@@4|)  (and (=> (< 0 (|ORD#Offset| |_k#0@@6|)) (or (and (|_module.com#Equal| |c#0@@8| |c'#0@@4|) (|Map#Equal| |s#0@@10| |s'#0@@4|)) (exists ((|c''#3@@1| T@U) (|s''#3@@1| T@U) ) (!  (and (and ($Is DatatypeTypeType |c''#3@@1| Tclass._module.com) ($Is MapType |s''#3@@1| (TMap (TSeq TChar) TInt))) (and (_module.__default.small__step ($LS $LZ) |c#0@@8| |s#0@@10| |c''#3@@1| |s''#3@@1|) (_module.__default.small__step__star_h $ly@@10 (|ORD#Minus| |_k#0@@6| (|ORD#FromNat| 1)) |c''#3@@1| |s''#3@@1| |c'#0@@4| |s'#0@@4|)))
 :pattern ( (_module.__default.small__step__star_h $ly@@10 (|ORD#Minus| |_k#0@@6| (|ORD#FromNat| 1)) |c''#3@@1| |s''#3@@1| |c'#0@@4| |s'#0@@4|))
 :pattern ( (_module.__default.small__step ($LS $LZ) |c#0@@8| |s#0@@10| |c''#3@@1| |s''#3@@1|))
)))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@6|)) (exists ((|_k'#0@@0| T@U) ) (!  (and (|ORD#LessThanLimit| |_k'#0@@0| |_k#0@@6|) (_module.__default.small__step__star_h $ly@@10 |_k'#0@@0| |c#0@@8| |s#0@@10| |c'#0@@4| |s'#0@@4|))
 :pattern ( (_module.__default.small__step__star_h $ly@@10 |_k'#0@@0| |c#0@@8| |s#0@@10| |c'#0@@4| |s'#0@@4|))
)))))))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@10) |_k#0@@6| |c#0@@8| |s#0@@10| |c'#0@@4| |s'#0@@4|))
))))
(assert  (=> (<= 6 $FunctionContextHeight) (forall (($ly@@11 T@U) (|_k#0@@7| T@U) (|c#0@@9| T@U) (|s#0@@11| T@U) (|c'#0@@5| T@U) (|s'#0@@5| T@U) ) (!  (=> (or (|_module.__default.small__step__star_h#canCall| (Lit BoxType |_k#0@@7|) (Lit DatatypeTypeType |c#0@@9|) (Lit MapType |s#0@@11|) (Lit DatatypeTypeType |c'#0@@5|) (Lit MapType |s'#0@@5|)) (and (< 6 $FunctionContextHeight) (and (and (and ($Is DatatypeTypeType |c#0@@9| Tclass._module.com) ($Is MapType |s#0@@11| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@5| Tclass._module.com)) ($Is MapType |s'#0@@5| (TMap (TSeq TChar) TInt))))) (and (and (=> (< 0 (|ORD#Offset| |_k#0@@7|)) (and (and (|$IsA#_module.com| (Lit DatatypeTypeType |c#0@@9|)) (|$IsA#_module.com| (Lit DatatypeTypeType |c'#0@@5|))) (=> (not (and (|_module.com#Equal| |c#0@@9| |c'#0@@5|) (|Map#Equal| |s#0@@11| |s'#0@@5|))) (forall ((|c''#5| T@U) (|s''#5| T@U) ) (!  (=> (and ($Is DatatypeTypeType |c''#5| Tclass._module.com) ($Is MapType |s''#5| (TMap (TSeq TChar) TInt))) (and (|_module.__default.small__step#canCall| (Lit DatatypeTypeType |c#0@@9|) (Lit MapType |s#0@@11|) |c''#5| |s''#5|) (=> (_module.__default.small__step ($LS $LZ) (Lit DatatypeTypeType |c#0@@9|) (Lit MapType |s#0@@11|) |c''#5| |s''#5|) (|_module.__default.small__step__star_h#canCall| (|ORD#Minus| |_k#0@@7| (|ORD#FromNat| 1)) |c''#5| |s''#5| (Lit DatatypeTypeType |c'#0@@5|) (Lit MapType |s'#0@@5|)))))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@11) (|ORD#Minus| |_k#0@@7| (|ORD#FromNat| 1)) |c''#5| |s''#5| |c'#0@@5| |s'#0@@5|))
 :pattern ( (_module.__default.small__step ($LS $LZ) |c#0@@9| |s#0@@11| |c''#5| |s''#5|))
))))) (=> (=> (< 0 (|ORD#Offset| |_k#0@@7|)) (or (and (|_module.com#Equal| |c#0@@9| |c'#0@@5|) (|Map#Equal| |s#0@@11| |s'#0@@5|)) (exists ((|c''#5@@0| T@U) (|s''#5@@0| T@U) ) (!  (and (and ($Is DatatypeTypeType |c''#5@@0| Tclass._module.com) ($Is MapType |s''#5@@0| (TMap (TSeq TChar) TInt))) (and (_module.__default.small__step ($LS $LZ) (Lit DatatypeTypeType |c#0@@9|) (Lit MapType |s#0@@11|) |c''#5@@0| |s''#5@@0|) (_module.__default.small__step__star_h ($LS $ly@@11) (|ORD#Minus| |_k#0@@7| (|ORD#FromNat| 1)) |c''#5@@0| |s''#5@@0| (Lit DatatypeTypeType |c'#0@@5|) (Lit MapType |s'#0@@5|))))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@11) (|ORD#Minus| |_k#0@@7| (|ORD#FromNat| 1)) |c''#5@@0| |s''#5@@0| |c'#0@@5| |s'#0@@5|))
 :pattern ( (_module.__default.small__step ($LS $LZ) |c#0@@9| |s#0@@11| |c''#5@@0| |s''#5@@0|))
)))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@7|)) (forall ((|_k'#2| T@U) ) (!  (=> (|ORD#LessThanLimit| |_k'#2| |_k#0@@7|) (|_module.__default.small__step__star_h#canCall| |_k'#2| |c#0@@9| |s#0@@11| |c'#0@@5| |s'#0@@5|))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@11) |_k'#2| |c#0@@9| |s#0@@11| |c'#0@@5| |s'#0@@5|))
))))) (= (_module.__default.small__step__star_h ($LS $ly@@11) (Lit BoxType |_k#0@@7|) (Lit DatatypeTypeType |c#0@@9|) (Lit MapType |s#0@@11|) (Lit DatatypeTypeType |c'#0@@5|) (Lit MapType |s'#0@@5|))  (and (=> (< 0 (|ORD#Offset| |_k#0@@7|)) (or (and (|_module.com#Equal| |c#0@@9| |c'#0@@5|) (|Map#Equal| |s#0@@11| |s'#0@@5|)) (exists ((|c''#5@@1| T@U) (|s''#5@@1| T@U) ) (!  (and (and ($Is DatatypeTypeType |c''#5@@1| Tclass._module.com) ($Is MapType |s''#5@@1| (TMap (TSeq TChar) TInt))) (and (_module.__default.small__step ($LS $LZ) (Lit DatatypeTypeType |c#0@@9|) (Lit MapType |s#0@@11|) |c''#5@@1| |s''#5@@1|) (_module.__default.small__step__star_h ($LS $ly@@11) (|ORD#Minus| |_k#0@@7| (|ORD#FromNat| 1)) |c''#5@@1| |s''#5@@1| (Lit DatatypeTypeType |c'#0@@5|) (Lit MapType |s'#0@@5|))))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@11) (|ORD#Minus| |_k#0@@7| (|ORD#FromNat| 1)) |c''#5@@1| |s''#5@@1| |c'#0@@5| |s'#0@@5|))
 :pattern ( (_module.__default.small__step ($LS $LZ) |c#0@@9| |s#0@@11| |c''#5@@1| |s''#5@@1|))
)))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@7|)) (exists ((|_k'#2@@0| T@U) ) (!  (and (|ORD#LessThanLimit| |_k'#2@@0| |_k#0@@7|) (_module.__default.small__step__star_h ($LS $ly@@11) |_k'#2@@0| |c#0@@9| |s#0@@11| |c'#0@@5| |s'#0@@5|))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@11) |_k'#2@@0| |c#0@@9| |s#0@@11| |c'#0@@5| |s'#0@@5|))
)))))))
 :weight 3
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@11) (Lit BoxType |_k#0@@7|) (Lit DatatypeTypeType |c#0@@9|) (Lit MapType |s#0@@11|) (Lit DatatypeTypeType |c'#0@@5|) (Lit MapType |s'#0@@5|)))
))))
(assert (forall (($ly@@12 T@U) (|b#0@@1| T@U) (|s#0@@12| T@U) ) (! (= (_module.__default.bval ($LS $ly@@12) |b#0@@1| |s#0@@12|) (_module.__default.bval $ly@@12 |b#0@@1| |s#0@@12|))
 :pattern ( (_module.__default.bval ($LS $ly@@12) |b#0@@1| |s#0@@12|))
)))
(assert (forall ((v@@0 T@U) (t T@U) (h T@U) (T@@1 T@T) ) (! (= ($IsAllocBox ($Box T@@1 v@@0) t h) ($IsAlloc T@@1 v@@0 t h))
 :pattern ( ($IsAllocBox ($Box T@@1 v@@0) t h))
)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@13 T@U) (|c#0@@10| T@U) (|s#0@@13| T@U) (|t#0@@3| T@U) ) (!  (=> (and (and (and ($Is DatatypeTypeType |c#0@@10| Tclass._module.com) ($Is MapType |s#0@@13| (TMap (TSeq TChar) TInt))) ($Is MapType |t#0@@3| (TMap (TSeq TChar) TInt))) (_module.__default.big__step ($LS $ly@@13) |c#0@@10| |s#0@@13| |t#0@@3|)) (exists ((|_k#0@@8| T@U) ) (! (_module.__default.big__step_h ($LS $ly@@13) |_k#0@@8| |c#0@@10| |s#0@@13| |t#0@@3|)
 :pattern ( (_module.__default.big__step_h ($LS $ly@@13) |_k#0@@8| |c#0@@10| |s#0@@13| |t#0@@3|))
)))
 :pattern ( (_module.__default.big__step ($LS $ly@@13) |c#0@@10| |s#0@@13| |t#0@@3|))
))))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@14 T@U) (|c#0@@11| T@U) (|s#0@@14| T@U) (|c'#0@@6| T@U) (|s'#0@@6| T@U) (|_k#0@@9| T@U) ) (!  (=> (and (and (and (and ($Is DatatypeTypeType |c#0@@11| Tclass._module.com) ($Is MapType |s#0@@14| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@6| Tclass._module.com)) ($Is MapType |s'#0@@6| (TMap (TSeq TChar) TInt))) (= |_k#0@@9| (|ORD#FromNat| 0))) (not (_module.__default.small__step_h $ly@@14 |_k#0@@9| |c#0@@11| |s#0@@14| |c'#0@@6| |s'#0@@6|)))
 :pattern ( (_module.__default.small__step_h $ly@@14 |_k#0@@9| |c#0@@11| |s#0@@14| |c'#0@@6| |s'#0@@6|))
))))
(assert  (=> (<= 6 $FunctionContextHeight) (forall (($ly@@15 T@U) (|c#0@@12| T@U) (|s#0@@15| T@U) (|c'#0@@7| T@U) (|s'#0@@7| T@U) (|_k#0@@10| T@U) ) (!  (=> (and (and (and (and ($Is DatatypeTypeType |c#0@@12| Tclass._module.com) ($Is MapType |s#0@@15| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@7| Tclass._module.com)) ($Is MapType |s'#0@@7| (TMap (TSeq TChar) TInt))) (= |_k#0@@10| (|ORD#FromNat| 0))) (not (_module.__default.small__step__star_h $ly@@15 |_k#0@@10| |c#0@@12| |s#0@@15| |c'#0@@7| |s'#0@@7|)))
 :pattern ( (_module.__default.small__step__star_h $ly@@15 |_k#0@@10| |c#0@@12| |s#0@@15| |c'#0@@7| |s'#0@@7|))
))))
(assert (forall ((o@@2 T@U) (p@@0 T@U) ) (!  (=> (and (|ORD#IsNat| p@@0) (<= (|ORD#Offset| p@@0) (|ORD#Offset| o@@2))) (and (= (|ORD#IsNat| (|ORD#Minus| o@@2 p@@0)) (|ORD#IsNat| o@@2)) (= (|ORD#Offset| (|ORD#Minus| o@@2 p@@0)) (- (|ORD#Offset| o@@2) (|ORD#Offset| p@@0)))))
 :pattern ( (|ORD#Minus| o@@2 p@@0))
)))
(assert (forall ((n@@0 Int) ) (!  (=> (<= 0 n@@0) (and (|ORD#IsNat| (|ORD#FromNat| n@@0)) (= (|ORD#Offset| (|ORD#FromNat| n@@0)) n@@0)))
 :pattern ( (|ORD#FromNat| n@@0))
)))
(assert (forall ((bx@@0 T@U) ) (!  (=> ($IsBox bx@@0 Tclass._module.aexp) (and (= ($Box DatatypeTypeType ($Unbox DatatypeTypeType bx@@0)) bx@@0) ($Is DatatypeTypeType ($Unbox DatatypeTypeType bx@@0) Tclass._module.aexp)))
 :pattern ( ($IsBox bx@@0 Tclass._module.aexp))
)))
(assert (forall ((bx@@1 T@U) ) (!  (=> ($IsBox bx@@1 Tclass._module.bexp) (and (= ($Box DatatypeTypeType ($Unbox DatatypeTypeType bx@@1)) bx@@1) ($Is DatatypeTypeType ($Unbox DatatypeTypeType bx@@1) Tclass._module.bexp)))
 :pattern ( ($IsBox bx@@1 Tclass._module.bexp))
)))
(assert (forall ((bx@@2 T@U) ) (!  (=> ($IsBox bx@@2 Tclass._module.com) (and (= ($Box DatatypeTypeType ($Unbox DatatypeTypeType bx@@2)) bx@@2) ($Is DatatypeTypeType ($Unbox DatatypeTypeType bx@@2) Tclass._module.com)))
 :pattern ( ($IsBox bx@@2 Tclass._module.com))
)))
(assert (forall ((|a#39#0#0| T@U) ) (! (= ($Is DatatypeTypeType (|#_module.bexp.Not| |a#39#0#0|) Tclass._module.bexp) ($Is DatatypeTypeType |a#39#0#0| Tclass._module.bexp))
 :pattern ( ($Is DatatypeTypeType (|#_module.bexp.Not| |a#39#0#0|) Tclass._module.bexp))
)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@16 T@U) (|c#0@@13| T@U) (|s#0@@16| T@U) (|t#0@@4| T@U) (|_k#0@@11| T@U) (_m T@U) (_limit T@U) ) (!  (=> (|ORD#Less| |_k#0@@11| _m) (=> (_module.__default.big__step_h $ly@@16 |_k#0@@11| |c#0@@13| |s#0@@16| |t#0@@4|) (_module.__default.big__step_h $ly@@16 _m |c#0@@13| |s#0@@16| |t#0@@4|)))
 :pattern ( (_module.__default.big__step_h $ly@@16 |_k#0@@11| |c#0@@13| |s#0@@16| |t#0@@4|) (|ORD#LessThanLimit| |_k#0@@11| _limit) (|ORD#LessThanLimit| _m _limit))
))))
(assert (forall ((a@@6 T@U) (b@@6 T@U) ) (!  (=> (and (_module.aexp.V_q a@@6) (_module.aexp.V_q b@@6)) (= (|_module.aexp#Equal| a@@6 b@@6) (|Seq#Equal| (_module.aexp.x a@@6) (_module.aexp.x b@@6))))
 :pattern ( (|_module.aexp#Equal| a@@6 b@@6) (_module.aexp.V_q a@@6))
 :pattern ( (|_module.aexp#Equal| a@@6 b@@6) (_module.aexp.V_q b@@6))
)))
(assert (forall ((a@@7 T@U) (b@@7 T@U) ) (!  (=> (and (_module.bexp.Not_q a@@7) (_module.bexp.Not_q b@@7)) (= (|_module.bexp#Equal| a@@7 b@@7) (|_module.bexp#Equal| (_module.bexp.op a@@7) (_module.bexp.op b@@7))))
 :pattern ( (|_module.bexp#Equal| a@@7 b@@7) (_module.bexp.Not_q a@@7))
 :pattern ( (|_module.bexp#Equal| a@@7 b@@7) (_module.bexp.Not_q b@@7))
)))
(assert (forall ((m@@2 T@U) (|m'| T@U) ) (! (= (|Map#Equal| m@@2 |m'|)  (and (forall ((u T@U) ) (= (|Set#IsMember| (|Map#Domain| m@@2) u) (|Set#IsMember| (|Map#Domain| |m'|) u))) (forall ((u@@0 T@U) )  (=> (|Set#IsMember| (|Map#Domain| m@@2) u@@0) (= (MapType0Select BoxType BoxType (|Map#Elements| m@@2) u@@0) (MapType0Select BoxType BoxType (|Map#Elements| |m'|) u@@0))))))
 :pattern ( (|Map#Equal| m@@2 |m'|))
)))
(assert (forall (($ly@@17 T@U) (|a#0@@1| T@U) (|s#0@@17| T@U) ) (! (= (_module.__default.aval ($LS $ly@@17) |a#0@@1| |s#0@@17|) (_module.__default.aval $ly@@17 |a#0@@1| |s#0@@17|))
 :pattern ( (_module.__default.aval ($LS $ly@@17) |a#0@@1| |s#0@@17|))
)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@18 T@U) (|_k#0@@12| T@U) (|c#0@@14| T@U) (|s#0@@18| T@U) (|t#0@@5| T@U) ) (!  (=> (or (|_module.__default.big__step_h#canCall| |_k#0@@12| |c#0@@14| |s#0@@18| |t#0@@5|) (and (< 5 $FunctionContextHeight) (and (and ($Is DatatypeTypeType |c#0@@14| Tclass._module.com) ($Is MapType |s#0@@18| (TMap (TSeq TChar) TInt))) ($Is MapType |t#0@@5| (TMap (TSeq TChar) TInt))))) (and (and (=> (< 0 (|ORD#Offset| |_k#0@@12|)) (=> (not (_module.com.SKIP_q |c#0@@14|)) (and (=> (_module.com.Assign_q |c#0@@14|) (let ((|a#3| (_module.com._h1 |c#0@@14|)))
(|_module.__default.aval#canCall| |a#3| |s#0@@18|))) (=> (not (_module.com.Assign_q |c#0@@14|)) (and (=> (_module.com.Seq_q |c#0@@14|) (let ((|c1#3| (_module.com._h3 |c#0@@14|)))
(let ((|c0#3| (_module.com._h2 |c#0@@14|)))
(forall ((|s'#10| T@U) ) (!  (=> ($Is MapType |s'#10| (TMap (TSeq TChar) TInt)) (and (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c0#3| |s#0@@18| |s'#10|) (=> (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c0#3| |s#0@@18| |s'#10|) (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c1#3| |s'#10| |t#0@@5|))))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c1#3| |s'#10| |t#0@@5|))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c0#3| |s#0@@18| |s'#10|))
))))) (=> (not (_module.com.Seq_q |c#0@@14|)) (and (=> (_module.com.If_q |c#0@@14|) (let ((|els#3| (_module.com._h6 |c#0@@14|)))
(let ((|thn#3| (_module.com._h5 |c#0@@14|)))
(let ((|b#6| (_module.com._h4 |c#0@@14|)))
 (and (|_module.__default.bval#canCall| |b#6| |s#0@@18|) (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) (ite (_module.__default.bval ($LS $LZ) |b#6| |s#0@@18|) |thn#3| |els#3|) |s#0@@18| |t#0@@5|)))))) (=> (not (_module.com.If_q |c#0@@14|)) (let ((|body#3| (_module.com._h8 |c#0@@14|)))
(let ((|b#7| (_module.com._h7 |c#0@@14|)))
 (and (|_module.__default.bval#canCall| |b#7| |s#0@@18|) (=> (not (and (not (_module.__default.bval ($LS $LZ) |b#7| |s#0@@18|)) (|Map#Equal| |s#0@@18| |t#0@@5|))) (and (|_module.__default.bval#canCall| |b#7| |s#0@@18|) (=> (_module.__default.bval ($LS $LZ) |b#7| |s#0@@18|) (forall ((|s'#11| T@U) ) (!  (=> ($Is MapType |s'#11| (TMap (TSeq TChar) TInt)) (and (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |body#3| |s#0@@18| |s'#11|) (=> (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |body#3| |s#0@@18| |s'#11|) (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) (|#_module.com.While| |b#7| |body#3|) |s'#11| |t#0@@5|))))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) (|#_module.com.While| |b#7| |body#3|) |s'#11| |t#0@@5|))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |body#3| |s#0@@18| |s'#11|))
)))))))))))))))) (=> (=> (< 0 (|ORD#Offset| |_k#0@@12|)) (ite (_module.com.SKIP_q |c#0@@14|) (|Map#Equal| |s#0@@18| |t#0@@5|) (ite (_module.com.Assign_q |c#0@@14|) (let ((|a#4| (_module.com._h1 |c#0@@14|)))
(let ((|x#4| (_module.com._h0 |c#0@@14|)))
(|Map#Equal| |t#0@@5| (|Map#Build| |s#0@@18| ($Box SeqType |x#4|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#4| |s#0@@18|))))))) (ite (_module.com.Seq_q |c#0@@14|) (let ((|c1#4| (_module.com._h3 |c#0@@14|)))
(let ((|c0#4| (_module.com._h2 |c#0@@14|)))
(exists ((|s'#12| T@U) ) (!  (and ($Is MapType |s'#12| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c0#4| |s#0@@18| |s'#12|) (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c1#4| |s'#12| |t#0@@5|)))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c1#4| |s'#12| |t#0@@5|))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c0#4| |s#0@@18| |s'#12|))
)))) (ite (_module.com.If_q |c#0@@14|) (let ((|els#4| (_module.com._h6 |c#0@@14|)))
(let ((|thn#4| (_module.com._h5 |c#0@@14|)))
(let ((|b#8| (_module.com._h4 |c#0@@14|)))
(_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) (ite (_module.__default.bval ($LS $LZ) |b#8| |s#0@@18|) |thn#4| |els#4|) |s#0@@18| |t#0@@5|)))) (let ((|body#4| (_module.com._h8 |c#0@@14|)))
(let ((|b#9| (_module.com._h7 |c#0@@14|)))
 (or (and (not (_module.__default.bval ($LS $LZ) |b#9| |s#0@@18|)) (|Map#Equal| |s#0@@18| |t#0@@5|)) (and (_module.__default.bval ($LS $LZ) |b#9| |s#0@@18|) (exists ((|s'#13| T@U) ) (!  (and ($Is MapType |s'#13| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |body#4| |s#0@@18| |s'#13|) (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) (|#_module.com.While| |b#9| |body#4|) |s'#13| |t#0@@5|)))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) (|#_module.com.While| |b#9| |body#4|) |s'#13| |t#0@@5|))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |body#4| |s#0@@18| |s'#13|))
))))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@12|)) (forall ((|_k'#0@@1| T@U) ) (!  (=> (|ORD#LessThanLimit| |_k'#0@@1| |_k#0@@12|) (|_module.__default.big__step_h#canCall| |_k'#0@@1| |c#0@@14| |s#0@@18| |t#0@@5|))
 :pattern ( (_module.__default.big__step_h $ly@@18 |_k'#0@@1| |c#0@@14| |s#0@@18| |t#0@@5|))
))))) (= (_module.__default.big__step_h ($LS $ly@@18) |_k#0@@12| |c#0@@14| |s#0@@18| |t#0@@5|)  (and (=> (< 0 (|ORD#Offset| |_k#0@@12|)) (ite (_module.com.SKIP_q |c#0@@14|) (|Map#Equal| |s#0@@18| |t#0@@5|) (ite (_module.com.Assign_q |c#0@@14|) (let ((|a#2| (_module.com._h1 |c#0@@14|)))
(let ((|x#2@@0| (_module.com._h0 |c#0@@14|)))
(|Map#Equal| |t#0@@5| (|Map#Build| |s#0@@18| ($Box SeqType |x#2@@0|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#2| |s#0@@18|))))))) (ite (_module.com.Seq_q |c#0@@14|) (let ((|c1#2| (_module.com._h3 |c#0@@14|)))
(let ((|c0#2| (_module.com._h2 |c#0@@14|)))
(exists ((|s'#8| T@U) ) (!  (and ($Is MapType |s'#8| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c0#2| |s#0@@18| |s'#8|) (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c1#2| |s'#8| |t#0@@5|)))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c1#2| |s'#8| |t#0@@5|))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |c0#2| |s#0@@18| |s'#8|))
)))) (ite (_module.com.If_q |c#0@@14|) (let ((|els#2| (_module.com._h6 |c#0@@14|)))
(let ((|thn#2| (_module.com._h5 |c#0@@14|)))
(let ((|b#4@@0| (_module.com._h4 |c#0@@14|)))
(_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) (ite (_module.__default.bval ($LS $LZ) |b#4@@0| |s#0@@18|) |thn#2| |els#2|) |s#0@@18| |t#0@@5|)))) (let ((|body#2| (_module.com._h8 |c#0@@14|)))
(let ((|b#5| (_module.com._h7 |c#0@@14|)))
 (or (and (not (_module.__default.bval ($LS $LZ) |b#5| |s#0@@18|)) (|Map#Equal| |s#0@@18| |t#0@@5|)) (and (_module.__default.bval ($LS $LZ) |b#5| |s#0@@18|) (exists ((|s'#9| T@U) ) (!  (and ($Is MapType |s'#9| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |body#2| |s#0@@18| |s'#9|) (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) (|#_module.com.While| |b#5| |body#2|) |s'#9| |t#0@@5|)))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) (|#_module.com.While| |b#5| |body#2|) |s'#9| |t#0@@5|))
 :pattern ( (_module.__default.big__step_h $ly@@18 (|ORD#Minus| |_k#0@@12| (|ORD#FromNat| 1)) |body#2| |s#0@@18| |s'#9|))
))))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@12|)) (exists ((|_k'#0@@2| T@U) ) (!  (and (|ORD#LessThanLimit| |_k'#0@@2| |_k#0@@12|) (_module.__default.big__step_h $ly@@18 |_k'#0@@2| |c#0@@14| |s#0@@18| |t#0@@5|))
 :pattern ( (_module.__default.big__step_h $ly@@18 |_k'#0@@2| |c#0@@14| |s#0@@18| |t#0@@5|))
)))))))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@18) |_k#0@@12| |c#0@@14| |s#0@@18| |t#0@@5|))
))))
(assert  (=> (<= 3 $FunctionContextHeight) (forall (($ly@@19 T@U) (|b#0@@2| T@U) (|s#0@@19| T@U) ) (!  (=> (or (|_module.__default.bval#canCall| |b#0@@2| |s#0@@19|) (and (< 3 $FunctionContextHeight) (and ($Is DatatypeTypeType |b#0@@2| Tclass._module.bexp) ($Is MapType |s#0@@19| (TMap (TSeq TChar) TInt))))) (and (=> (not (_module.bexp.Bc_q |b#0@@2|)) (and (=> (_module.bexp.Not_q |b#0@@2|) (let ((|b#2@@0| (_module.bexp.op |b#0@@2|)))
(|_module.__default.bval#canCall| |b#2@@0| |s#0@@19|))) (=> (not (_module.bexp.Not_q |b#0@@2|)) (and (=> (_module.bexp.And_q |b#0@@2|) (let ((|b1#1| (_module.bexp._1 |b#0@@2|)))
(let ((|b0#1| (_module.bexp._0 |b#0@@2|)))
 (and (|_module.__default.bval#canCall| |b0#1| |s#0@@19|) (=> (_module.__default.bval $ly@@19 |b0#1| |s#0@@19|) (|_module.__default.bval#canCall| |b1#1| |s#0@@19|)))))) (=> (not (_module.bexp.And_q |b#0@@2|)) (let ((|a1#1| (_module.bexp.a1 |b#0@@2|)))
(let ((|a0#1| (_module.bexp.a0 |b#0@@2|)))
 (and (|_module.__default.aval#canCall| |a0#1| |s#0@@19|) (|_module.__default.aval#canCall| |a1#1| |s#0@@19|))))))))) (= (_module.__default.bval ($LS $ly@@19) |b#0@@2| |s#0@@19|) (ite (_module.bexp.Bc_q |b#0@@2|) (let ((|v#0| (_module.bexp.v |b#0@@2|)))
|v#0|) (ite (_module.bexp.Not_q |b#0@@2|) (let ((|b#1@@0| (_module.bexp.op |b#0@@2|)))
 (not (_module.__default.bval $ly@@19 |b#1@@0| |s#0@@19|))) (ite (_module.bexp.And_q |b#0@@2|) (let ((|b1#0| (_module.bexp._1 |b#0@@2|)))
(let ((|b0#0| (_module.bexp._0 |b#0@@2|)))
 (and (_module.__default.bval $ly@@19 |b0#0| |s#0@@19|) (_module.__default.bval $ly@@19 |b1#0| |s#0@@19|)))) (let ((|a1#0| (_module.bexp.a1 |b#0@@2|)))
(let ((|a0#0| (_module.bexp.a0 |b#0@@2|)))
(< (_module.__default.aval ($LS $LZ) |a0#0| |s#0@@19|) (_module.__default.aval ($LS $LZ) |a1#0| |s#0@@19|))))))))))
 :pattern ( (_module.__default.bval ($LS $ly@@19) |b#0@@2| |s#0@@19|))
))))
(assert  (=> (<= 6 $FunctionContextHeight) (forall (($ly@@20 T@U) (|_k#0@@13| T@U) (|c#0@@15| T@U) (|s#0@@20| T@U) (|c'#0@@8| T@U) (|s'#0@@8| T@U) ) (!  (=> (or (|_module.__default.small__step__star_h#canCall| (Lit BoxType |_k#0@@13|) |c#0@@15| |s#0@@20| |c'#0@@8| |s'#0@@8|) (and (< 6 $FunctionContextHeight) (and (and (and ($Is DatatypeTypeType |c#0@@15| Tclass._module.com) ($Is MapType |s#0@@20| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@8| Tclass._module.com)) ($Is MapType |s'#0@@8| (TMap (TSeq TChar) TInt))))) (and (and (=> (< 0 (|ORD#Offset| |_k#0@@13|)) (and (and (|$IsA#_module.com| |c#0@@15|) (|$IsA#_module.com| |c'#0@@8|)) (=> (not (and (|_module.com#Equal| |c#0@@15| |c'#0@@8|) (|Map#Equal| |s#0@@20| |s'#0@@8|))) (forall ((|c''#4| T@U) (|s''#4| T@U) ) (!  (=> (and ($Is DatatypeTypeType |c''#4| Tclass._module.com) ($Is MapType |s''#4| (TMap (TSeq TChar) TInt))) (and (|_module.__default.small__step#canCall| |c#0@@15| |s#0@@20| |c''#4| |s''#4|) (=> (_module.__default.small__step ($LS $LZ) |c#0@@15| |s#0@@20| |c''#4| |s''#4|) (|_module.__default.small__step__star_h#canCall| (|ORD#Minus| |_k#0@@13| (|ORD#FromNat| 1)) |c''#4| |s''#4| |c'#0@@8| |s'#0@@8|))))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@20) (|ORD#Minus| |_k#0@@13| (|ORD#FromNat| 1)) |c''#4| |s''#4| |c'#0@@8| |s'#0@@8|))
 :pattern ( (_module.__default.small__step ($LS $LZ) |c#0@@15| |s#0@@20| |c''#4| |s''#4|))
))))) (=> (=> (< 0 (|ORD#Offset| |_k#0@@13|)) (or (and (|_module.com#Equal| |c#0@@15| |c'#0@@8|) (|Map#Equal| |s#0@@20| |s'#0@@8|)) (exists ((|c''#4@@0| T@U) (|s''#4@@0| T@U) ) (!  (and (and ($Is DatatypeTypeType |c''#4@@0| Tclass._module.com) ($Is MapType |s''#4@@0| (TMap (TSeq TChar) TInt))) (and (_module.__default.small__step ($LS $LZ) |c#0@@15| |s#0@@20| |c''#4@@0| |s''#4@@0|) (_module.__default.small__step__star_h ($LS $ly@@20) (|ORD#Minus| |_k#0@@13| (|ORD#FromNat| 1)) |c''#4@@0| |s''#4@@0| |c'#0@@8| |s'#0@@8|)))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@20) (|ORD#Minus| |_k#0@@13| (|ORD#FromNat| 1)) |c''#4@@0| |s''#4@@0| |c'#0@@8| |s'#0@@8|))
 :pattern ( (_module.__default.small__step ($LS $LZ) |c#0@@15| |s#0@@20| |c''#4@@0| |s''#4@@0|))
)))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@13|)) (forall ((|_k'#1@@3| T@U) ) (!  (=> (|ORD#LessThanLimit| |_k'#1@@3| |_k#0@@13|) (|_module.__default.small__step__star_h#canCall| |_k'#1@@3| |c#0@@15| |s#0@@20| |c'#0@@8| |s'#0@@8|))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@20) |_k'#1@@3| |c#0@@15| |s#0@@20| |c'#0@@8| |s'#0@@8|))
))))) (= (_module.__default.small__step__star_h ($LS $ly@@20) (Lit BoxType |_k#0@@13|) |c#0@@15| |s#0@@20| |c'#0@@8| |s'#0@@8|)  (and (=> (< 0 (|ORD#Offset| |_k#0@@13|)) (or (and (|_module.com#Equal| |c#0@@15| |c'#0@@8|) (|Map#Equal| |s#0@@20| |s'#0@@8|)) (exists ((|c''#4@@1| T@U) (|s''#4@@1| T@U) ) (!  (and (and ($Is DatatypeTypeType |c''#4@@1| Tclass._module.com) ($Is MapType |s''#4@@1| (TMap (TSeq TChar) TInt))) (and (_module.__default.small__step ($LS $LZ) |c#0@@15| |s#0@@20| |c''#4@@1| |s''#4@@1|) (_module.__default.small__step__star_h ($LS $ly@@20) (|ORD#Minus| |_k#0@@13| (|ORD#FromNat| 1)) |c''#4@@1| |s''#4@@1| |c'#0@@8| |s'#0@@8|)))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@20) (|ORD#Minus| |_k#0@@13| (|ORD#FromNat| 1)) |c''#4@@1| |s''#4@@1| |c'#0@@8| |s'#0@@8|))
 :pattern ( (_module.__default.small__step ($LS $LZ) |c#0@@15| |s#0@@20| |c''#4@@1| |s''#4@@1|))
)))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@13|)) (exists ((|_k'#1@@4| T@U) ) (!  (and (|ORD#LessThanLimit| |_k'#1@@4| |_k#0@@13|) (_module.__default.small__step__star_h ($LS $ly@@20) |_k'#1@@4| |c#0@@15| |s#0@@20| |c'#0@@8| |s'#0@@8|))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@20) |_k'#1@@4| |c#0@@15| |s#0@@20| |c'#0@@8| |s'#0@@8|))
)))))))
 :weight 3
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@20) (Lit BoxType |_k#0@@13|) |c#0@@15| |s#0@@20| |c'#0@@8| |s'#0@@8|))
))))
(assert (forall ((o@@3 T@U) (p@@1 T@U) ) (!  (or (or (|ORD#Less| o@@3 p@@1) (= o@@3 p@@1)) (|ORD#Less| p@@1 o@@3))
 :pattern ( (|ORD#Less| o@@3 p@@1) (|ORD#Less| p@@1 o@@3))
)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@21 T@U) (|_k#0@@14| T@U) (|c#0@@16| T@U) (|s#0@@21| T@U) (|t#0@@6| T@U) ) (!  (=> (or (|_module.__default.big__step_h#canCall| (Lit BoxType |_k#0@@14|) (Lit DatatypeTypeType |c#0@@16|) (Lit MapType |s#0@@21|) (Lit MapType |t#0@@6|)) (and (< 5 $FunctionContextHeight) (and (and ($Is DatatypeTypeType |c#0@@16| Tclass._module.com) ($Is MapType |s#0@@21| (TMap (TSeq TChar) TInt))) ($Is MapType |t#0@@6| (TMap (TSeq TChar) TInt))))) (and (and (=> (< 0 (|ORD#Offset| |_k#0@@14|)) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.com.SKIP_q (Lit DatatypeTypeType |c#0@@16|)))))) (and (=> (U_2_bool (Lit boolType (bool_2_U (_module.com.Assign_q (Lit DatatypeTypeType |c#0@@16|))))) (let ((|a#9| (Lit DatatypeTypeType (_module.com._h1 (Lit DatatypeTypeType |c#0@@16|)))))
(|_module.__default.aval#canCall| |a#9| (Lit MapType |s#0@@21|)))) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.com.Assign_q (Lit DatatypeTypeType |c#0@@16|)))))) (and (=> (U_2_bool (Lit boolType (bool_2_U (_module.com.Seq_q (Lit DatatypeTypeType |c#0@@16|))))) (let ((|c1#9| (Lit DatatypeTypeType (_module.com._h3 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|c0#9| (Lit DatatypeTypeType (_module.com._h2 (Lit DatatypeTypeType |c#0@@16|)))))
(forall ((|s'#22| T@U) ) (!  (=> ($Is MapType |s'#22| (TMap (TSeq TChar) TInt)) (and (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c0#9| (Lit MapType |s#0@@21|) |s'#22|) (=> (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c0#9| (Lit MapType |s#0@@21|) |s'#22|) (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c1#9| |s'#22| (Lit MapType |t#0@@6|)))))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c1#9| |s'#22| |t#0@@6|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c0#9| |s#0@@21| |s'#22|))
))))) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.com.Seq_q (Lit DatatypeTypeType |c#0@@16|)))))) (and (=> (U_2_bool (Lit boolType (bool_2_U (_module.com.If_q (Lit DatatypeTypeType |c#0@@16|))))) (let ((|els#9| (Lit DatatypeTypeType (_module.com._h6 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|thn#9| (Lit DatatypeTypeType (_module.com._h5 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|b#18| (Lit DatatypeTypeType (_module.com._h4 (Lit DatatypeTypeType |c#0@@16|)))))
 (and (|_module.__default.bval#canCall| |b#18| (Lit MapType |s#0@@21|)) (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) (ite (_module.__default.bval ($LS $LZ) |b#18| (Lit MapType |s#0@@21|)) |thn#9| |els#9|) (Lit MapType |s#0@@21|) (Lit MapType |t#0@@6|))))))) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.com.If_q (Lit DatatypeTypeType |c#0@@16|)))))) (let ((|body#9| (Lit DatatypeTypeType (_module.com._h8 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|b#19| (Lit DatatypeTypeType (_module.com._h7 (Lit DatatypeTypeType |c#0@@16|)))))
 (and (|_module.__default.bval#canCall| |b#19| (Lit MapType |s#0@@21|)) (=> (not (and (not (_module.__default.bval ($LS $LZ) |b#19| (Lit MapType |s#0@@21|))) (|Map#Equal| |s#0@@21| |t#0@@6|))) (and (|_module.__default.bval#canCall| |b#19| (Lit MapType |s#0@@21|)) (=> (_module.__default.bval ($LS $LZ) |b#19| (Lit MapType |s#0@@21|)) (forall ((|s'#23| T@U) ) (!  (=> ($Is MapType |s'#23| (TMap (TSeq TChar) TInt)) (and (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |body#9| (Lit MapType |s#0@@21|) |s'#23|) (=> (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |body#9| (Lit MapType |s#0@@21|) |s'#23|) (|_module.__default.big__step_h#canCall| (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) (|#_module.com.While| |b#19| |body#9|) |s'#23| (Lit MapType |t#0@@6|)))))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) (|#_module.com.While| |b#19| |body#9|) |s'#23| |t#0@@6|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |body#9| |s#0@@21| |s'#23|))
)))))))))))))))) (=> (=> (< 0 (|ORD#Offset| |_k#0@@14|)) (ite (_module.com.SKIP_q (Lit DatatypeTypeType |c#0@@16|)) (|Map#Equal| |s#0@@21| |t#0@@6|) (ite (_module.com.Assign_q (Lit DatatypeTypeType |c#0@@16|)) (let ((|a#10| (Lit DatatypeTypeType (_module.com._h1 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|x#10| (Lit SeqType (_module.com._h0 (Lit DatatypeTypeType |c#0@@16|)))))
(|Map#Equal| |t#0@@6| (|Map#Build| (Lit MapType |s#0@@21|) ($Box SeqType |x#10|) ($Box intType (int_2_U (LitInt (_module.__default.aval ($LS $LZ) |a#10| (Lit MapType |s#0@@21|))))))))) (ite (_module.com.Seq_q (Lit DatatypeTypeType |c#0@@16|)) (let ((|c1#10| (Lit DatatypeTypeType (_module.com._h3 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|c0#10| (Lit DatatypeTypeType (_module.com._h2 (Lit DatatypeTypeType |c#0@@16|)))))
(exists ((|s'#24| T@U) ) (!  (and ($Is MapType |s'#24| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c0#10| (Lit MapType |s#0@@21|) |s'#24|) (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c1#10| |s'#24| (Lit MapType |t#0@@6|))))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c1#10| |s'#24| |t#0@@6|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c0#10| |s#0@@21| |s'#24|))
)))) (ite (_module.com.If_q (Lit DatatypeTypeType |c#0@@16|)) (let ((|els#10| (Lit DatatypeTypeType (_module.com._h6 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|thn#10| (Lit DatatypeTypeType (_module.com._h5 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|b#20| (Lit DatatypeTypeType (_module.com._h4 (Lit DatatypeTypeType |c#0@@16|)))))
(_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) (ite (_module.__default.bval ($LS $LZ) |b#20| (Lit MapType |s#0@@21|)) |thn#10| |els#10|) (Lit MapType |s#0@@21|) (Lit MapType |t#0@@6|))))) (let ((|body#10| (Lit DatatypeTypeType (_module.com._h8 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|b#21| (Lit DatatypeTypeType (_module.com._h7 (Lit DatatypeTypeType |c#0@@16|)))))
 (or (and (not (U_2_bool (Lit boolType (bool_2_U (_module.__default.bval ($LS $LZ) |b#21| (Lit MapType |s#0@@21|)))))) (|Map#Equal| |s#0@@21| |t#0@@6|)) (and (_module.__default.bval ($LS $LZ) |b#21| (Lit MapType |s#0@@21|)) (exists ((|s'#25| T@U) ) (!  (and ($Is MapType |s'#25| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |body#10| (Lit MapType |s#0@@21|) |s'#25|) (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) (Lit DatatypeTypeType (|#_module.com.While| |b#21| |body#10|)) |s'#25| (Lit MapType |t#0@@6|))))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) (|#_module.com.While| |b#21| |body#10|) |s'#25| |t#0@@6|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |body#10| |s#0@@21| |s'#25|))
))))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@14|)) (forall ((|_k'#2@@1| T@U) ) (!  (=> (|ORD#LessThanLimit| |_k'#2@@1| |_k#0@@14|) (|_module.__default.big__step_h#canCall| |_k'#2@@1| |c#0@@16| |s#0@@21| |t#0@@6|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) |_k'#2@@1| |c#0@@16| |s#0@@21| |t#0@@6|))
))))) (= (_module.__default.big__step_h ($LS $ly@@21) (Lit BoxType |_k#0@@14|) (Lit DatatypeTypeType |c#0@@16|) (Lit MapType |s#0@@21|) (Lit MapType |t#0@@6|))  (and (=> (< 0 (|ORD#Offset| |_k#0@@14|)) (ite (_module.com.SKIP_q (Lit DatatypeTypeType |c#0@@16|)) (|Map#Equal| |s#0@@21| |t#0@@6|) (ite (_module.com.Assign_q (Lit DatatypeTypeType |c#0@@16|)) (let ((|a#8| (Lit DatatypeTypeType (_module.com._h1 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|x#8| (Lit SeqType (_module.com._h0 (Lit DatatypeTypeType |c#0@@16|)))))
(|Map#Equal| |t#0@@6| (|Map#Build| (Lit MapType |s#0@@21|) ($Box SeqType |x#8|) ($Box intType (int_2_U (LitInt (_module.__default.aval ($LS $LZ) |a#8| (Lit MapType |s#0@@21|))))))))) (ite (_module.com.Seq_q (Lit DatatypeTypeType |c#0@@16|)) (let ((|c1#8| (Lit DatatypeTypeType (_module.com._h3 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|c0#8| (Lit DatatypeTypeType (_module.com._h2 (Lit DatatypeTypeType |c#0@@16|)))))
(exists ((|s'#20| T@U) ) (!  (and ($Is MapType |s'#20| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c0#8| (Lit MapType |s#0@@21|) |s'#20|) (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c1#8| |s'#20| (Lit MapType |t#0@@6|))))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c1#8| |s'#20| |t#0@@6|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |c0#8| |s#0@@21| |s'#20|))
)))) (ite (_module.com.If_q (Lit DatatypeTypeType |c#0@@16|)) (let ((|els#8| (Lit DatatypeTypeType (_module.com._h6 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|thn#8| (Lit DatatypeTypeType (_module.com._h5 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|b#16| (Lit DatatypeTypeType (_module.com._h4 (Lit DatatypeTypeType |c#0@@16|)))))
(_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) (ite (_module.__default.bval ($LS $LZ) |b#16| (Lit MapType |s#0@@21|)) |thn#8| |els#8|) (Lit MapType |s#0@@21|) (Lit MapType |t#0@@6|))))) (let ((|body#8| (Lit DatatypeTypeType (_module.com._h8 (Lit DatatypeTypeType |c#0@@16|)))))
(let ((|b#17| (Lit DatatypeTypeType (_module.com._h7 (Lit DatatypeTypeType |c#0@@16|)))))
 (or (and (not (U_2_bool (Lit boolType (bool_2_U (_module.__default.bval ($LS $LZ) |b#17| (Lit MapType |s#0@@21|)))))) (|Map#Equal| |s#0@@21| |t#0@@6|)) (and (_module.__default.bval ($LS $LZ) |b#17| (Lit MapType |s#0@@21|)) (exists ((|s'#21| T@U) ) (!  (and ($Is MapType |s'#21| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |body#8| (Lit MapType |s#0@@21|) |s'#21|) (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) (Lit DatatypeTypeType (|#_module.com.While| |b#17| |body#8|)) |s'#21| (Lit MapType |t#0@@6|))))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) (|#_module.com.While| |b#17| |body#8|) |s'#21| |t#0@@6|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (|ORD#Minus| |_k#0@@14| (|ORD#FromNat| 1)) |body#8| |s#0@@21| |s'#21|))
))))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@14|)) (exists ((|_k'#2@@2| T@U) ) (!  (and (|ORD#LessThanLimit| |_k'#2@@2| |_k#0@@14|) (_module.__default.big__step_h ($LS $ly@@21) |_k'#2@@2| |c#0@@16| |s#0@@21| |t#0@@6|))
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) |_k'#2@@2| |c#0@@16| |s#0@@21| |t#0@@6|))
)))))))
 :weight 3
 :pattern ( (_module.__default.big__step_h ($LS $ly@@21) (Lit BoxType |_k#0@@14|) (Lit DatatypeTypeType |c#0@@16|) (Lit MapType |s#0@@21|) (Lit MapType |t#0@@6|)))
))))
(assert (forall ((o@@4 T@U) (p@@2 T@U) ) (! (= (|ORD#LessThanLimit| o@@4 p@@2) (|ORD#Less| o@@4 p@@2))
 :pattern ( (|ORD#LessThanLimit| o@@4 p@@2))
)))
(assert (forall ((a@@8 T@U) (b@@8 T@U) ) (!  (=> (|Set#Equal| a@@8 b@@8) (= a@@8 b@@8))
 :pattern ( (|Set#Equal| a@@8 b@@8))
)))
(assert (forall ((a@@9 T@U) (b@@9 T@U) ) (!  (=> (|Seq#Equal| a@@9 b@@9) (= a@@9 b@@9))
 :pattern ( (|Seq#Equal| a@@9 b@@9))
)))
(assert (forall ((m@@3 T@U) (|m'@@0| T@U) ) (!  (=> (|Map#Equal| m@@3 |m'@@0|) (= m@@3 |m'@@0|))
 :pattern ( (|Map#Equal| m@@3 |m'@@0|))
)))
(assert (forall (($ly@@22 T@U) (|_k#0@@15| T@U) (|c#0@@17| T@U) (|s#0@@22| T@U) (|c'#0@@9| T@U) (|s'#0@@9| T@U) ) (! (= (_module.__default.small__step_h ($LS $ly@@22) |_k#0@@15| |c#0@@17| |s#0@@22| |c'#0@@9| |s'#0@@9|) (_module.__default.small__step_h $ly@@22 |_k#0@@15| |c#0@@17| |s#0@@22| |c'#0@@9| |s'#0@@9|))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@22) |_k#0@@15| |c#0@@17| |s#0@@22| |c'#0@@9| |s'#0@@9|))
)))
(assert (forall (($ly@@23 T@U) (|_k#0@@16| T@U) (|c#0@@18| T@U) (|s#0@@23| T@U) (|c'#0@@10| T@U) (|s'#0@@10| T@U) ) (! (= (_module.__default.small__step__star_h ($LS $ly@@23) |_k#0@@16| |c#0@@18| |s#0@@23| |c'#0@@10| |s'#0@@10|) (_module.__default.small__step__star_h $ly@@23 |_k#0@@16| |c#0@@18| |s#0@@23| |c'#0@@10| |s'#0@@10|))
 :pattern ( (_module.__default.small__step__star_h ($LS $ly@@23) |_k#0@@16| |c#0@@18| |s#0@@23| |c'#0@@10| |s'#0@@10|))
)))
(assert (forall ((|a#36#0#0| Bool) ) (! (= (_module.bexp.v (|#_module.bexp.Bc| |a#36#0#0|)) |a#36#0#0|)
 :pattern ( (|#_module.bexp.Bc| |a#36#0#0|))
)))
(assert (forall ((bx@@3 T@U) ) (!  (=> ($IsBox bx@@3 TInt) (and (= ($Box intType ($Unbox intType bx@@3)) bx@@3) ($Is intType ($Unbox intType bx@@3) TInt)))
 :pattern ( ($IsBox bx@@3 TInt))
)))
(assert (forall ((bx@@4 T@U) ) (!  (=> ($IsBox bx@@4 TBool) (and (= ($Box boolType ($Unbox boolType bx@@4)) bx@@4) ($Is boolType ($Unbox boolType bx@@4) TBool)))
 :pattern ( ($IsBox bx@@4 TBool))
)))
(assert (= (Ctor charType) 8))
(assert (forall ((bx@@5 T@U) ) (!  (=> ($IsBox bx@@5 TChar) (and (= ($Box charType ($Unbox charType bx@@5)) bx@@5) ($Is charType ($Unbox charType bx@@5) TChar)))
 :pattern ( ($IsBox bx@@5 TChar))
)))
(assert (forall ((a@@10 T@U) (b@@10 T@U) ) (!  (=> (and (_module.aexp.Plus_q a@@10) (_module.aexp.Plus_q b@@10)) (= (|_module.aexp#Equal| a@@10 b@@10)  (and (|_module.aexp#Equal| (_module.aexp._0 a@@10) (_module.aexp._0 b@@10)) (|_module.aexp#Equal| (_module.aexp._1 a@@10) (_module.aexp._1 b@@10)))))
 :pattern ( (|_module.aexp#Equal| a@@10 b@@10) (_module.aexp.Plus_q a@@10))
 :pattern ( (|_module.aexp#Equal| a@@10 b@@10) (_module.aexp.Plus_q b@@10))
)))
(assert (forall ((a@@11 T@U) (b@@11 T@U) ) (!  (=> (and (_module.bexp.And_q a@@11) (_module.bexp.And_q b@@11)) (= (|_module.bexp#Equal| a@@11 b@@11)  (and (|_module.bexp#Equal| (_module.bexp._0 a@@11) (_module.bexp._0 b@@11)) (|_module.bexp#Equal| (_module.bexp._1 a@@11) (_module.bexp._1 b@@11)))))
 :pattern ( (|_module.bexp#Equal| a@@11 b@@11) (_module.bexp.And_q a@@11))
 :pattern ( (|_module.bexp#Equal| a@@11 b@@11) (_module.bexp.And_q b@@11))
)))
(assert (forall ((a@@12 T@U) (b@@12 T@U) ) (!  (=> (and (_module.bexp.Less_q a@@12) (_module.bexp.Less_q b@@12)) (= (|_module.bexp#Equal| a@@12 b@@12)  (and (|_module.aexp#Equal| (_module.bexp.a0 a@@12) (_module.bexp.a0 b@@12)) (|_module.aexp#Equal| (_module.bexp.a1 a@@12) (_module.bexp.a1 b@@12)))))
 :pattern ( (|_module.bexp#Equal| a@@12 b@@12) (_module.bexp.Less_q a@@12))
 :pattern ( (|_module.bexp#Equal| a@@12 b@@12) (_module.bexp.Less_q b@@12))
)))
(assert (forall ((a@@13 T@U) (b@@13 T@U) ) (!  (=> (and (_module.com.Assign_q a@@13) (_module.com.Assign_q b@@13)) (= (|_module.com#Equal| a@@13 b@@13)  (and (|Seq#Equal| (_module.com._h0 a@@13) (_module.com._h0 b@@13)) (|_module.aexp#Equal| (_module.com._h1 a@@13) (_module.com._h1 b@@13)))))
 :pattern ( (|_module.com#Equal| a@@13 b@@13) (_module.com.Assign_q a@@13))
 :pattern ( (|_module.com#Equal| a@@13 b@@13) (_module.com.Assign_q b@@13))
)))
(assert (forall ((a@@14 T@U) (b@@14 T@U) ) (!  (=> (and (_module.com.Seq_q a@@14) (_module.com.Seq_q b@@14)) (= (|_module.com#Equal| a@@14 b@@14)  (and (|_module.com#Equal| (_module.com._h2 a@@14) (_module.com._h2 b@@14)) (|_module.com#Equal| (_module.com._h3 a@@14) (_module.com._h3 b@@14)))))
 :pattern ( (|_module.com#Equal| a@@14 b@@14) (_module.com.Seq_q a@@14))
 :pattern ( (|_module.com#Equal| a@@14 b@@14) (_module.com.Seq_q b@@14))
)))
(assert (forall ((a@@15 T@U) (b@@15 T@U) ) (!  (=> (and (_module.com.While_q a@@15) (_module.com.While_q b@@15)) (= (|_module.com#Equal| a@@15 b@@15)  (and (|_module.bexp#Equal| (_module.com._h7 a@@15) (_module.com._h7 b@@15)) (|_module.com#Equal| (_module.com._h8 a@@15) (_module.com._h8 b@@15)))))
 :pattern ( (|_module.com#Equal| a@@15 b@@15) (_module.com.While_q a@@15))
 :pattern ( (|_module.com#Equal| a@@15 b@@15) (_module.com.While_q b@@15))
)))
(assert (forall ((v@@1 T@U) (t@@0 T@U) (T@@2 T@T) ) (! (= ($IsBox ($Box T@@2 v@@1) t@@0) ($Is T@@2 v@@1 t@@0))
 :pattern ( ($IsBox ($Box T@@2 v@@1) t@@0))
)))
(assert (forall (($ly@@24 T@U) (|c#0@@19| T@U) (|s#0@@24| T@U) (|t#0@@7| T@U) ) (! (= (_module.__default.big__step ($LS $ly@@24) |c#0@@19| |s#0@@24| |t#0@@7|) (_module.__default.big__step $ly@@24 |c#0@@19| |s#0@@24| |t#0@@7|))
 :pattern ( (_module.__default.big__step ($LS $ly@@24) |c#0@@19| |s#0@@24| |t#0@@7|))
)))
(assert (forall ((o@@5 T@U) ) (! (<= 0 (|ORD#Offset| o@@5))
 :pattern ( (|ORD#Offset| o@@5))
)))
(assert (forall ((s T@U) ) (! (<= 0 (|Seq#Length| s))
 :pattern ( (|Seq#Length| s))
)))
(assert (forall ((a@@16 T@U) (b@@16 T@U) ) (!  (=> (and (_module.com.SKIP_q a@@16) (_module.com.SKIP_q b@@16)) (|_module.com#Equal| a@@16 b@@16))
 :pattern ( (|_module.com#Equal| a@@16 b@@16) (_module.com.SKIP_q a@@16))
 :pattern ( (|_module.com#Equal| a@@16 b@@16) (_module.com.SKIP_q b@@16))
)))
(assert (forall ((v@@2 T@U) (t0@@1 T@U) (h@@0 T@U) ) (! (= ($IsAlloc SetType v@@2 (TSet t0@@1) h@@0) (forall ((bx@@6 T@U) ) (!  (=> (|Set#IsMember| v@@2 bx@@6) ($IsAllocBox bx@@6 t0@@1 h@@0))
 :pattern ( (|Set#IsMember| v@@2 bx@@6))
)))
 :pattern ( ($IsAlloc SetType v@@2 (TSet t0@@1) h@@0))
)))
(assert (forall ((t@@1 T@U) (u@@1 T@U) ) (! (= (Inv0_TMap (TMap t@@1 u@@1)) t@@1)
 :pattern ( (TMap t@@1 u@@1))
)))
(assert (forall ((t@@2 T@U) (u@@2 T@U) ) (! (= (Inv1_TMap (TMap t@@2 u@@2)) u@@2)
 :pattern ( (TMap t@@2 u@@2))
)))
(assert (forall ((t@@3 T@U) (u@@3 T@U) ) (! (= (Tag (TMap t@@3 u@@3)) TagMap)
 :pattern ( (TMap t@@3 u@@3))
)))
(assert (forall ((|a#0#0#0| T@U) (|a#0#1#0| T@U) ) (! (= (DatatypeCtorId (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|)) |##_System._tuple#2._#Make2|)
 :pattern ( (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|))
)))
(assert (forall ((|_System._tuple#2$T0@@2| T@U) (|_System._tuple#2$T1@@2| T@U) ) (! (= (Tclass._System.Tuple2_0 (Tclass._System.Tuple2 |_System._tuple#2$T0@@2| |_System._tuple#2$T1@@2|)) |_System._tuple#2$T0@@2|)
 :pattern ( (Tclass._System.Tuple2 |_System._tuple#2$T0@@2| |_System._tuple#2$T1@@2|))
)))
(assert (forall ((|_System._tuple#2$T0@@3| T@U) (|_System._tuple#2$T1@@3| T@U) ) (! (= (Tclass._System.Tuple2_1 (Tclass._System.Tuple2 |_System._tuple#2$T0@@3| |_System._tuple#2$T1@@3|)) |_System._tuple#2$T1@@3|)
 :pattern ( (Tclass._System.Tuple2 |_System._tuple#2$T0@@3| |_System._tuple#2$T1@@3|))
)))
(assert (forall ((|a#4#0#0| T@U) (|a#4#1#0| T@U) ) (! (= (_System.Tuple2._0 (|#_System._tuple#2._#Make2| |a#4#0#0| |a#4#1#0|)) |a#4#0#0|)
 :pattern ( (|#_System._tuple#2._#Make2| |a#4#0#0| |a#4#1#0|))
)))
(assert (forall ((|a#6#0#0| T@U) (|a#6#1#0| T@U) ) (! (= (_System.Tuple2._1 (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|)) |a#6#1#0|)
 :pattern ( (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|))
)))
(assert (forall ((|a#24#0#0| T@U) (|a#24#1#0| T@U) ) (! (= (DatatypeCtorId (|#_module.aexp.Plus| |a#24#0#0| |a#24#1#0|)) |##_module.aexp.Plus|)
 :pattern ( (|#_module.aexp.Plus| |a#24#0#0| |a#24#1#0|))
)))
(assert (forall ((|a#28#0#0| T@U) (|a#28#1#0| T@U) ) (! (= (_module.aexp._0 (|#_module.aexp.Plus| |a#28#0#0| |a#28#1#0|)) |a#28#0#0|)
 :pattern ( (|#_module.aexp.Plus| |a#28#0#0| |a#28#1#0|))
)))
(assert (forall ((|a#30#0#0| T@U) (|a#30#1#0| T@U) ) (! (= (_module.aexp._1 (|#_module.aexp.Plus| |a#30#0#0| |a#30#1#0|)) |a#30#1#0|)
 :pattern ( (|#_module.aexp.Plus| |a#30#0#0| |a#30#1#0|))
)))
(assert (forall ((|a#43#0#0| T@U) (|a#43#1#0| T@U) ) (! (= (DatatypeCtorId (|#_module.bexp.And| |a#43#0#0| |a#43#1#0|)) |##_module.bexp.And|)
 :pattern ( (|#_module.bexp.And| |a#43#0#0| |a#43#1#0|))
)))
(assert (forall ((|a#47#0#0| T@U) (|a#47#1#0| T@U) ) (! (= (_module.bexp._0 (|#_module.bexp.And| |a#47#0#0| |a#47#1#0|)) |a#47#0#0|)
 :pattern ( (|#_module.bexp.And| |a#47#0#0| |a#47#1#0|))
)))
(assert (forall ((|a#49#0#0| T@U) (|a#49#1#0| T@U) ) (! (= (_module.bexp._1 (|#_module.bexp.And| |a#49#0#0| |a#49#1#0|)) |a#49#1#0|)
 :pattern ( (|#_module.bexp.And| |a#49#0#0| |a#49#1#0|))
)))
(assert (forall ((|a#51#0#0| T@U) (|a#51#1#0| T@U) ) (! (= (DatatypeCtorId (|#_module.bexp.Less| |a#51#0#0| |a#51#1#0|)) |##_module.bexp.Less|)
 :pattern ( (|#_module.bexp.Less| |a#51#0#0| |a#51#1#0|))
)))
(assert (forall ((|a#55#0#0| T@U) (|a#55#1#0| T@U) ) (! (= (_module.bexp.a0 (|#_module.bexp.Less| |a#55#0#0| |a#55#1#0|)) |a#55#0#0|)
 :pattern ( (|#_module.bexp.Less| |a#55#0#0| |a#55#1#0|))
)))
(assert (forall ((|a#57#0#0| T@U) (|a#57#1#0| T@U) ) (! (= (_module.bexp.a1 (|#_module.bexp.Less| |a#57#0#0| |a#57#1#0|)) |a#57#1#0|)
 :pattern ( (|#_module.bexp.Less| |a#57#0#0| |a#57#1#0|))
)))
(assert (forall ((|a#63#0#0| T@U) (|a#63#1#0| T@U) ) (! (= (DatatypeCtorId (|#_module.com.Assign| |a#63#0#0| |a#63#1#0|)) |##_module.com.Assign|)
 :pattern ( (|#_module.com.Assign| |a#63#0#0| |a#63#1#0|))
)))
(assert (forall ((|a#67#0#0| T@U) (|a#67#1#0| T@U) ) (! (= (_module.com._h0 (|#_module.com.Assign| |a#67#0#0| |a#67#1#0|)) |a#67#0#0|)
 :pattern ( (|#_module.com.Assign| |a#67#0#0| |a#67#1#0|))
)))
(assert (forall ((|a#70#0#0| T@U) (|a#70#1#0| T@U) ) (! (= (_module.com._h1 (|#_module.com.Assign| |a#70#0#0| |a#70#1#0|)) |a#70#1#0|)
 :pattern ( (|#_module.com.Assign| |a#70#0#0| |a#70#1#0|))
)))
(assert (forall ((|a#72#0#0| T@U) (|a#72#1#0| T@U) ) (! (= (DatatypeCtorId (|#_module.com.Seq| |a#72#0#0| |a#72#1#0|)) |##_module.com.Seq|)
 :pattern ( (|#_module.com.Seq| |a#72#0#0| |a#72#1#0|))
)))
(assert (forall ((|a#76#0#0| T@U) (|a#76#1#0| T@U) ) (! (= (_module.com._h2 (|#_module.com.Seq| |a#76#0#0| |a#76#1#0|)) |a#76#0#0|)
 :pattern ( (|#_module.com.Seq| |a#76#0#0| |a#76#1#0|))
)))
(assert (forall ((|a#78#0#0| T@U) (|a#78#1#0| T@U) ) (! (= (_module.com._h3 (|#_module.com.Seq| |a#78#0#0| |a#78#1#0|)) |a#78#1#0|)
 :pattern ( (|#_module.com.Seq| |a#78#0#0| |a#78#1#0|))
)))
(assert (forall ((|a#90#0#0| T@U) (|a#90#1#0| T@U) ) (! (= (DatatypeCtorId (|#_module.com.While| |a#90#0#0| |a#90#1#0|)) |##_module.com.While|)
 :pattern ( (|#_module.com.While| |a#90#0#0| |a#90#1#0|))
)))
(assert (forall ((|a#94#0#0| T@U) (|a#94#1#0| T@U) ) (! (= (_module.com._h7 (|#_module.com.While| |a#94#0#0| |a#94#1#0|)) |a#94#0#0|)
 :pattern ( (|#_module.com.While| |a#94#0#0| |a#94#1#0|))
)))
(assert (forall ((|a#96#0#0| T@U) (|a#96#1#0| T@U) ) (! (= (_module.com._h8 (|#_module.com.While| |a#96#0#0| |a#96#1#0|)) |a#96#1#0|)
 :pattern ( (|#_module.com.While| |a#96#0#0| |a#96#1#0|))
)))
(assert (forall ((v@@3 T@U) (t0@@2 T@U) (h@@1 T@U) ) (! (= ($IsAlloc SeqType v@@3 (TSeq t0@@2) h@@1) (forall ((i@@1 Int) ) (!  (=> (and (<= 0 i@@1) (< i@@1 (|Seq#Length| v@@3))) ($IsAllocBox (|Seq#Index| v@@3 i@@1) t0@@2 h@@1))
 :pattern ( (|Seq#Index| v@@3 i@@1))
)))
 :pattern ( ($IsAlloc SeqType v@@3 (TSeq t0@@2) h@@1))
)))
(assert (forall ((|a#83#0#0| T@U) (|a#83#1#0| T@U) (|a#83#2#0| T@U) ) (! (= (|#_module.com.If| (Lit DatatypeTypeType |a#83#0#0|) (Lit DatatypeTypeType |a#83#1#0|) (Lit DatatypeTypeType |a#83#2#0|)) (Lit DatatypeTypeType (|#_module.com.If| |a#83#0#0| |a#83#1#0| |a#83#2#0|)))
 :pattern ( (|#_module.com.If| (Lit DatatypeTypeType |a#83#0#0|) (Lit DatatypeTypeType |a#83#1#0|) (Lit DatatypeTypeType |a#83#2#0|)))
)))
(assert (forall ((t@@4 T@U) ) (! (= (Inv0_TSet (TSet t@@4)) t@@4)
 :pattern ( (TSet t@@4))
)))
(assert (forall ((t@@5 T@U) ) (! (= (Tag (TSet t@@5)) TagSet)
 :pattern ( (TSet t@@5))
)))
(assert (forall ((t@@6 T@U) ) (! (= (Inv0_TSeq (TSeq t@@6)) t@@6)
 :pattern ( (TSeq t@@6))
)))
(assert (forall ((t@@7 T@U) ) (! (= (Tag (TSeq t@@7)) TagSeq)
 :pattern ( (TSeq t@@7))
)))
(assert (forall ((|a#12#0#0| Int) ) (! (= (DatatypeCtorId (|#_module.aexp.N| |a#12#0#0|)) |##_module.aexp.N|)
 :pattern ( (|#_module.aexp.N| |a#12#0#0|))
)))
(assert (forall ((|a#16#0#0| Int) ) (! (= (_module.aexp.n (|#_module.aexp.N| |a#16#0#0|)) |a#16#0#0|)
 :pattern ( (|#_module.aexp.N| |a#16#0#0|))
)))
(assert (forall ((|a#17#0#0| T@U) ) (! (= (DatatypeCtorId (|#_module.aexp.V| |a#17#0#0|)) |##_module.aexp.V|)
 :pattern ( (|#_module.aexp.V| |a#17#0#0|))
)))
(assert (forall ((|a#21#0#0| T@U) ) (! (= (_module.aexp.x (|#_module.aexp.V| |a#21#0#0|)) |a#21#0#0|)
 :pattern ( (|#_module.aexp.V| |a#21#0#0|))
)))
(assert (forall ((|a#32#0#0| Bool) ) (! (= (DatatypeCtorId (|#_module.bexp.Bc| |a#32#0#0|)) |##_module.bexp.Bc|)
 :pattern ( (|#_module.bexp.Bc| |a#32#0#0|))
)))
(assert (forall ((|a#37#0#0| T@U) ) (! (= (DatatypeCtorId (|#_module.bexp.Not| |a#37#0#0|)) |##_module.bexp.Not|)
 :pattern ( (|#_module.bexp.Not| |a#37#0#0|))
)))
(assert (forall ((|a#41#0#0| T@U) ) (! (= (_module.bexp.op (|#_module.bexp.Not| |a#41#0#0|)) |a#41#0#0|)
 :pattern ( (|#_module.bexp.Not| |a#41#0#0|))
)))
(assert (forall ((x@@5 T@U) (T@@3 T@T) ) (! (= ($Unbox T@@3 ($Box T@@3 x@@5)) x@@5)
 :pattern ( ($Box T@@3 x@@5))
)))
(assert (forall ((v@@4 T@U) (t0@@3 T@U) (t1@@0 T@U) (h@@2 T@U) ) (! (= ($IsAlloc MapType v@@4 (TMap t0@@3 t1@@0) h@@2) (forall ((bx@@7 T@U) ) (!  (=> (|Set#IsMember| (|Map#Domain| v@@4) bx@@7) (and ($IsAllocBox (MapType0Select BoxType BoxType (|Map#Elements| v@@4) bx@@7) t1@@0 h@@2) ($IsAllocBox bx@@7 t0@@3 h@@2)))
 :pattern ( (MapType0Select BoxType BoxType (|Map#Elements| v@@4) bx@@7))
 :pattern ( (|Set#IsMember| (|Map#Domain| v@@4) bx@@7))
)))
 :pattern ( ($IsAlloc MapType v@@4 (TMap t0@@3 t1@@0) h@@2))
)))
(assert (forall ((|a#85#0#0| T@U) (|a#85#1#0| T@U) (|a#85#2#0| T@U) ) (! (< (DtRank |a#85#0#0|) (DtRank (|#_module.com.If| |a#85#0#0| |a#85#1#0| |a#85#2#0|)))
 :pattern ( (|#_module.com.If| |a#85#0#0| |a#85#1#0| |a#85#2#0|))
)))
(assert (forall ((|a#87#0#0| T@U) (|a#87#1#0| T@U) (|a#87#2#0| T@U) ) (! (< (DtRank |a#87#1#0|) (DtRank (|#_module.com.If| |a#87#0#0| |a#87#1#0| |a#87#2#0|)))
 :pattern ( (|#_module.com.If| |a#87#0#0| |a#87#1#0| |a#87#2#0|))
)))
(assert (forall ((|a#89#0#0| T@U) (|a#89#1#0| T@U) (|a#89#2#0| T@U) ) (! (< (DtRank |a#89#2#0|) (DtRank (|#_module.com.If| |a#89#0#0| |a#89#1#0| |a#89#2#0|)))
 :pattern ( (|#_module.com.If| |a#89#0#0| |a#89#1#0| |a#89#2#0|))
)))
(assert (forall ((o@@6 T@U) (p@@3 T@U) ) (!  (and (and (and (=> (|ORD#Less| o@@6 p@@3) (or (not (= o@@6 p@@3)) (not true))) (=> (and (|ORD#IsNat| o@@6) (not (|ORD#IsNat| p@@3))) (|ORD#Less| o@@6 p@@3))) (=> (and (|ORD#IsNat| o@@6) (|ORD#IsNat| p@@3)) (= (|ORD#Less| o@@6 p@@3) (< (|ORD#Offset| o@@6) (|ORD#Offset| p@@3))))) (=> (and (|ORD#Less| o@@6 p@@3) (|ORD#IsNat| p@@3)) (|ORD#IsNat| o@@6)))
 :pattern ( (|ORD#Less| o@@6 p@@3))
)))
(assert (forall ((|a#5#0#0| T@U) (|a#5#1#0| T@U) ) (! (< (BoxRank |a#5#0#0|) (DtRank (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|)))
 :pattern ( (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|))
)))
(assert (forall ((|a#7#0#0| T@U) (|a#7#1#0| T@U) ) (! (< (BoxRank |a#7#1#0|) (DtRank (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|)))
 :pattern ( (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|))
)))
(assert (forall ((|a#29#0#0| T@U) (|a#29#1#0| T@U) ) (! (< (DtRank |a#29#0#0|) (DtRank (|#_module.aexp.Plus| |a#29#0#0| |a#29#1#0|)))
 :pattern ( (|#_module.aexp.Plus| |a#29#0#0| |a#29#1#0|))
)))
(assert (forall ((|a#31#0#0| T@U) (|a#31#1#0| T@U) ) (! (< (DtRank |a#31#1#0|) (DtRank (|#_module.aexp.Plus| |a#31#0#0| |a#31#1#0|)))
 :pattern ( (|#_module.aexp.Plus| |a#31#0#0| |a#31#1#0|))
)))
(assert (forall ((|a#48#0#0| T@U) (|a#48#1#0| T@U) ) (! (< (DtRank |a#48#0#0|) (DtRank (|#_module.bexp.And| |a#48#0#0| |a#48#1#0|)))
 :pattern ( (|#_module.bexp.And| |a#48#0#0| |a#48#1#0|))
)))
(assert (forall ((|a#50#0#0| T@U) (|a#50#1#0| T@U) ) (! (< (DtRank |a#50#1#0|) (DtRank (|#_module.bexp.And| |a#50#0#0| |a#50#1#0|)))
 :pattern ( (|#_module.bexp.And| |a#50#0#0| |a#50#1#0|))
)))
(assert (forall ((|a#56#0#0| T@U) (|a#56#1#0| T@U) ) (! (< (DtRank |a#56#0#0|) (DtRank (|#_module.bexp.Less| |a#56#0#0| |a#56#1#0|)))
 :pattern ( (|#_module.bexp.Less| |a#56#0#0| |a#56#1#0|))
)))
(assert (forall ((|a#58#0#0| T@U) (|a#58#1#0| T@U) ) (! (< (DtRank |a#58#1#0|) (DtRank (|#_module.bexp.Less| |a#58#0#0| |a#58#1#0|)))
 :pattern ( (|#_module.bexp.Less| |a#58#0#0| |a#58#1#0|))
)))
(assert (forall ((|a#69#0#0| T@U) (|a#69#1#0| T@U) ) (! (< (|Seq#Rank| |a#69#0#0|) (DtRank (|#_module.com.Assign| |a#69#0#0| |a#69#1#0|)))
 :pattern ( (|#_module.com.Assign| |a#69#0#0| |a#69#1#0|))
)))
(assert (forall ((|a#71#0#0| T@U) (|a#71#1#0| T@U) ) (! (< (DtRank |a#71#1#0|) (DtRank (|#_module.com.Assign| |a#71#0#0| |a#71#1#0|)))
 :pattern ( (|#_module.com.Assign| |a#71#0#0| |a#71#1#0|))
)))
(assert (forall ((|a#77#0#0| T@U) (|a#77#1#0| T@U) ) (! (< (DtRank |a#77#0#0|) (DtRank (|#_module.com.Seq| |a#77#0#0| |a#77#1#0|)))
 :pattern ( (|#_module.com.Seq| |a#77#0#0| |a#77#1#0|))
)))
(assert (forall ((|a#79#0#0| T@U) (|a#79#1#0| T@U) ) (! (< (DtRank |a#79#1#0|) (DtRank (|#_module.com.Seq| |a#79#0#0| |a#79#1#0|)))
 :pattern ( (|#_module.com.Seq| |a#79#0#0| |a#79#1#0|))
)))
(assert (forall ((|a#95#0#0| T@U) (|a#95#1#0| T@U) ) (! (< (DtRank |a#95#0#0|) (DtRank (|#_module.com.While| |a#95#0#0| |a#95#1#0|)))
 :pattern ( (|#_module.com.While| |a#95#0#0| |a#95#1#0|))
)))
(assert (forall ((|a#97#0#0| T@U) (|a#97#1#0| T@U) ) (! (< (DtRank |a#97#1#0|) (DtRank (|#_module.com.While| |a#97#0#0| |a#97#1#0|)))
 :pattern ( (|#_module.com.While| |a#97#0#0| |a#97#1#0|))
)))
(assert  (=> (<= 4 $FunctionContextHeight) (forall (($ly@@25 T@U) (|c#0@@20| T@U) (|s#0@@25| T@U) (|t#0@@8| T@U) ) (!  (=> (or (|_module.__default.big__step#canCall| |c#0@@20| |s#0@@25| |t#0@@8|) (and (< 4 $FunctionContextHeight) (and (and ($Is DatatypeTypeType |c#0@@20| Tclass._module.com) ($Is MapType |s#0@@25| (TMap (TSeq TChar) TInt))) ($Is MapType |t#0@@8| (TMap (TSeq TChar) TInt))))) (and (=> (not (_module.com.SKIP_q |c#0@@20|)) (and (=> (_module.com.Assign_q |c#0@@20|) (let ((|a#1@@0| (_module.com._h1 |c#0@@20|)))
(|_module.__default.aval#canCall| |a#1@@0| |s#0@@25|))) (=> (not (_module.com.Assign_q |c#0@@20|)) (and (=> (_module.com.Seq_q |c#0@@20|) (let ((|c1#1@@0| (_module.com._h3 |c#0@@20|)))
(let ((|c0#1@@0| (_module.com._h2 |c#0@@20|)))
(forall ((|s'#2| T@U) ) (!  (=> ($Is MapType |s'#2| (TMap (TSeq TChar) TInt)) (and (|_module.__default.big__step#canCall| |c0#1@@0| |s#0@@25| |s'#2|) (=> (_module.__default.big__step $ly@@25 |c0#1@@0| |s#0@@25| |s'#2|) (|_module.__default.big__step#canCall| |c1#1@@0| |s'#2| |t#0@@8|))))
 :pattern ( (_module.__default.big__step $ly@@25 |c1#1@@0| |s'#2| |t#0@@8|))
 :pattern ( (_module.__default.big__step $ly@@25 |c0#1@@0| |s#0@@25| |s'#2|))
))))) (=> (not (_module.com.Seq_q |c#0@@20|)) (and (=> (_module.com.If_q |c#0@@20|) (let ((|els#1@@0| (_module.com._h6 |c#0@@20|)))
(let ((|thn#1@@0| (_module.com._h5 |c#0@@20|)))
(let ((|b#2@@1| (_module.com._h4 |c#0@@20|)))
 (and (|_module.__default.bval#canCall| |b#2@@1| |s#0@@25|) (|_module.__default.big__step#canCall| (ite (_module.__default.bval ($LS $LZ) |b#2@@1| |s#0@@25|) |thn#1@@0| |els#1@@0|) |s#0@@25| |t#0@@8|)))))) (=> (not (_module.com.If_q |c#0@@20|)) (let ((|body#1| (_module.com._h8 |c#0@@20|)))
(let ((|b#3@@0| (_module.com._h7 |c#0@@20|)))
 (and (|_module.__default.bval#canCall| |b#3@@0| |s#0@@25|) (=> (not (and (not (_module.__default.bval ($LS $LZ) |b#3@@0| |s#0@@25|)) (|Map#Equal| |s#0@@25| |t#0@@8|))) (and (|_module.__default.bval#canCall| |b#3@@0| |s#0@@25|) (=> (_module.__default.bval ($LS $LZ) |b#3@@0| |s#0@@25|) (forall ((|s'#3| T@U) ) (!  (=> ($Is MapType |s'#3| (TMap (TSeq TChar) TInt)) (and (|_module.__default.big__step#canCall| |body#1| |s#0@@25| |s'#3|) (=> (_module.__default.big__step $ly@@25 |body#1| |s#0@@25| |s'#3|) (|_module.__default.big__step#canCall| (|#_module.com.While| |b#3@@0| |body#1|) |s'#3| |t#0@@8|))))
 :pattern ( (_module.__default.big__step $ly@@25 (|#_module.com.While| |b#3@@0| |body#1|) |s'#3| |t#0@@8|))
 :pattern ( (_module.__default.big__step $ly@@25 |body#1| |s#0@@25| |s'#3|))
))))))))))))))) (= (_module.__default.big__step ($LS $ly@@25) |c#0@@20| |s#0@@25| |t#0@@8|) (ite (_module.com.SKIP_q |c#0@@20|) (|Map#Equal| |s#0@@25| |t#0@@8|) (ite (_module.com.Assign_q |c#0@@20|) (let ((|a#0@@2| (_module.com._h1 |c#0@@20|)))
(let ((|x#0@@0| (_module.com._h0 |c#0@@20|)))
(|Map#Equal| |t#0@@8| (|Map#Build| |s#0@@25| ($Box SeqType |x#0@@0|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#0@@2| |s#0@@25|))))))) (ite (_module.com.Seq_q |c#0@@20|) (let ((|c1#0@@0| (_module.com._h3 |c#0@@20|)))
(let ((|c0#0@@0| (_module.com._h2 |c#0@@20|)))
(exists ((|s'#0@@11| T@U) ) (!  (and ($Is MapType |s'#0@@11| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step $ly@@25 |c0#0@@0| |s#0@@25| |s'#0@@11|) (_module.__default.big__step $ly@@25 |c1#0@@0| |s'#0@@11| |t#0@@8|)))
 :pattern ( (_module.__default.big__step $ly@@25 |c1#0@@0| |s'#0@@11| |t#0@@8|))
 :pattern ( (_module.__default.big__step $ly@@25 |c0#0@@0| |s#0@@25| |s'#0@@11|))
)))) (ite (_module.com.If_q |c#0@@20|) (let ((|els#0@@0| (_module.com._h6 |c#0@@20|)))
(let ((|thn#0@@0| (_module.com._h5 |c#0@@20|)))
(let ((|b#0@@3| (_module.com._h4 |c#0@@20|)))
(_module.__default.big__step $ly@@25 (ite (_module.__default.bval ($LS $LZ) |b#0@@3| |s#0@@25|) |thn#0@@0| |els#0@@0|) |s#0@@25| |t#0@@8|)))) (let ((|body#0@@0| (_module.com._h8 |c#0@@20|)))
(let ((|b#1@@1| (_module.com._h7 |c#0@@20|)))
 (or (and (not (_module.__default.bval ($LS $LZ) |b#1@@1| |s#0@@25|)) (|Map#Equal| |s#0@@25| |t#0@@8|)) (and (_module.__default.bval ($LS $LZ) |b#1@@1| |s#0@@25|) (exists ((|s'#1| T@U) ) (!  (and ($Is MapType |s'#1| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step $ly@@25 |body#0@@0| |s#0@@25| |s'#1|) (_module.__default.big__step $ly@@25 (|#_module.com.While| |b#1@@1| |body#0@@0|) |s'#1| |t#0@@8|)))
 :pattern ( (_module.__default.big__step $ly@@25 (|#_module.com.While| |b#1@@1| |body#0@@0|) |s'#1| |t#0@@8|))
 :pattern ( (_module.__default.big__step $ly@@25 |body#0@@0| |s#0@@25| |s'#1|))
)))))))))))))
 :pattern ( (_module.__default.big__step ($LS $ly@@25) |c#0@@20| |s#0@@25| |t#0@@8|))
))))
(assert (forall ((u@@4 T@U) ) (!  (not (|Set#IsMember| (|Map#Domain| |Map#Empty|) u@@4))
 :pattern ( (|Set#IsMember| (|Map#Domain| |Map#Empty|) u@@4))
)))
(assert (forall ((|a#14#0#0| Int) ) (! (= ($Is DatatypeTypeType (|#_module.aexp.N| |a#14#0#0|) Tclass._module.aexp) ($Is intType (int_2_U |a#14#0#0|) TInt))
 :pattern ( ($Is DatatypeTypeType (|#_module.aexp.N| |a#14#0#0|) Tclass._module.aexp))
)))
(assert (forall ((|a#34#0#0| Bool) ) (! (= ($Is DatatypeTypeType (|#_module.bexp.Bc| |a#34#0#0|) Tclass._module.bexp) ($Is boolType (bool_2_U |a#34#0#0|) TBool))
 :pattern ( ($Is DatatypeTypeType (|#_module.bexp.Bc| |a#34#0#0|) Tclass._module.bexp))
)))
(assert (forall ((bx@@8 T@U) (s@@0 T@U) (t@@8 T@U) ) (!  (=> ($IsBox bx@@8 (TMap s@@0 t@@8)) (and (= ($Box MapType ($Unbox MapType bx@@8)) bx@@8) ($Is MapType ($Unbox MapType bx@@8) (TMap s@@0 t@@8))))
 :pattern ( ($IsBox bx@@8 (TMap s@@0 t@@8)))
)))
(assert (forall ((|_System._tuple#2$T0@@4| T@U) (|_System._tuple#2$T1@@4| T@U) (bx@@9 T@U) ) (!  (=> ($IsBox bx@@9 (Tclass._System.Tuple2 |_System._tuple#2$T0@@4| |_System._tuple#2$T1@@4|)) (and (= ($Box DatatypeTypeType ($Unbox DatatypeTypeType bx@@9)) bx@@9) ($Is DatatypeTypeType ($Unbox DatatypeTypeType bx@@9) (Tclass._System.Tuple2 |_System._tuple#2$T0@@4| |_System._tuple#2$T1@@4|))))
 :pattern ( ($IsBox bx@@9 (Tclass._System.Tuple2 |_System._tuple#2$T0@@4| |_System._tuple#2$T1@@4|)))
)))
(assert (forall ((|a#23#0#0| T@U) ) (! (< (|Seq#Rank| |a#23#0#0|) (DtRank (|#_module.aexp.V| |a#23#0#0|)))
 :pattern ( (|#_module.aexp.V| |a#23#0#0|))
)))
(assert (forall ((|a#42#0#0| T@U) ) (! (< (DtRank |a#42#0#0|) (DtRank (|#_module.bexp.Not| |a#42#0#0|)))
 :pattern ( (|#_module.bexp.Not| |a#42#0#0|))
)))
(assert  (and (and (and (and (and (and (forall ((t0@@4 T@T) (t1@@1 T@T) (t2 T@T) (val@@1 T@U) (m@@4 T@U) (x0@@1 T@U) (x1 T@U) ) (! (= (MapType1Select t0@@4 t1@@1 t2 (MapType1Store t0@@4 t1@@1 t2 m@@4 x0@@1 x1 val@@1) x0@@1 x1) val@@1)
 :weight 0
)) (and (forall ((u0@@0 T@T) (u1@@0 T@T) (u2 T@T) (val@@2 T@U) (m@@5 T@U) (x0@@2 T@U) (x1@@0 T@U) (y0@@0 T@U) (y1 T@U) ) (!  (or (= x0@@2 y0@@0) (= (MapType1Select u0@@0 u1@@0 u2 (MapType1Store u0@@0 u1@@0 u2 m@@5 x0@@2 x1@@0 val@@2) y0@@0 y1) (MapType1Select u0@@0 u1@@0 u2 m@@5 y0@@0 y1)))
 :weight 0
)) (forall ((u0@@1 T@T) (u1@@1 T@T) (u2@@0 T@T) (val@@3 T@U) (m@@6 T@U) (x0@@3 T@U) (x1@@1 T@U) (y0@@1 T@U) (y1@@0 T@U) ) (!  (or (= x1@@1 y1@@0) (= (MapType1Select u0@@1 u1@@1 u2@@0 (MapType1Store u0@@1 u1@@1 u2@@0 m@@6 x0@@3 x1@@1 val@@3) y0@@1 y1@@0) (MapType1Select u0@@1 u1@@1 u2@@0 m@@6 y0@@1 y1@@0)))
 :weight 0
)))) (= (Ctor refType) 9)) (= (Ctor FieldType) 10)) (forall ((arg0@@2 T@T) (arg1 T@T) ) (= (Ctor (MapType0Type arg0@@2 arg1)) 11))) (forall ((arg0@@3 T@T) (arg1@@0 T@T) ) (! (= (MapType0TypeInv0 (MapType0Type arg0@@3 arg1@@0)) arg0@@3)
 :pattern ( (MapType0Type arg0@@3 arg1@@0))
))) (forall ((arg0@@4 T@T) (arg1@@1 T@T) ) (! (= (MapType0TypeInv1 (MapType0Type arg0@@4 arg1@@1)) arg1@@1)
 :pattern ( (MapType0Type arg0@@4 arg1@@1))
))))
(assert (forall ((|l#0| T@U) (|l#1| T@U) (|l#2| T@U) (|l#3| Bool) ($o T@U) ($f T@U) ) (! (= (U_2_bool (MapType1Select refType FieldType boolType (|lambda#0| |l#0| |l#1| |l#2| |l#3|) $o $f))  (=> (and (or (not (= $o |l#0|)) (not true)) (U_2_bool ($Unbox boolType (MapType0Select FieldType BoxType (MapType0Select refType (MapType0Type FieldType BoxType) |l#1| $o) |l#2|)))) |l#3|))
 :pattern ( (MapType1Select refType FieldType boolType (|lambda#0| |l#0| |l#1| |l#2| |l#3|) $o $f))
)))
(assert (forall ((d@@26 T@U) ) (!  (=> (|$IsA#_module.com| d@@26) (or (or (or (or (_module.com.SKIP_q d@@26) (_module.com.Assign_q d@@26)) (_module.com.Seq_q d@@26)) (_module.com.If_q d@@26)) (_module.com.While_q d@@26)))
 :pattern ( (|$IsA#_module.com| d@@26))
)))
(assert (forall ((|_System._tuple#2$T0@@5| T@U) (|_System._tuple#2$T1@@5| T@U) ) (!  (and (= (Tag (Tclass._System.Tuple2 |_System._tuple#2$T0@@5| |_System._tuple#2$T1@@5|)) Tagclass._System.Tuple2) (= (TagFamily (Tclass._System.Tuple2 |_System._tuple#2$T0@@5| |_System._tuple#2$T1@@5|)) |tytagFamily$_tuple#2|))
 :pattern ( (Tclass._System.Tuple2 |_System._tuple#2$T0@@5| |_System._tuple#2$T1@@5|))
)))
(assert (forall ((d@@27 T@U) ($h@@0 T@U) ) (!  (=> (and ($IsGoodHeap $h@@0) (and (_module.aexp.N_q d@@27) ($IsAlloc DatatypeTypeType d@@27 Tclass._module.aexp $h@@0))) ($IsAlloc intType (int_2_U (_module.aexp.n d@@27)) TInt $h@@0))
 :pattern ( ($IsAlloc intType (int_2_U (_module.aexp.n d@@27)) TInt $h@@0))
)))
(assert (forall ((d@@28 T@U) ($h@@1 T@U) ) (!  (=> (and ($IsGoodHeap $h@@1) (and (_module.bexp.Bc_q d@@28) ($IsAlloc DatatypeTypeType d@@28 Tclass._module.bexp $h@@1))) ($IsAlloc boolType (bool_2_U (_module.bexp.v d@@28)) TBool $h@@1))
 :pattern ( ($IsAlloc boolType (bool_2_U (_module.bexp.v d@@28)) TBool $h@@1))
)))
(assert (forall ((d@@29 T@U) ) (!  (=> ($Is DatatypeTypeType d@@29 Tclass._module.aexp) (or (or (_module.aexp.N_q d@@29) (_module.aexp.V_q d@@29)) (_module.aexp.Plus_q d@@29)))
 :pattern ( (_module.aexp.Plus_q d@@29) ($Is DatatypeTypeType d@@29 Tclass._module.aexp))
 :pattern ( (_module.aexp.V_q d@@29) ($Is DatatypeTypeType d@@29 Tclass._module.aexp))
 :pattern ( (_module.aexp.N_q d@@29) ($Is DatatypeTypeType d@@29 Tclass._module.aexp))
)))
(assert (forall ((m@@7 T@U) ) (!  (or (= m@@7 |Map#Empty|) (exists ((k T@U) ) (|Set#IsMember| (|Map#Domain| m@@7) k)))
 :pattern ( (|Map#Domain| m@@7))
)))
(assert (forall ((m@@8 T@U) ) (!  (or (= m@@8 |Map#Empty|) (exists ((v@@5 T@U) ) (|Set#IsMember| (|Map#Values| m@@8) v@@5)))
 :pattern ( (|Map#Values| m@@8))
)))
(assert (forall ((m@@9 T@U) (item T@U) ) (! (= (|Set#IsMember| (|Map#Items| m@@9) item)  (and (|Set#IsMember| (|Map#Domain| m@@9) (_System.Tuple2._0 ($Unbox DatatypeTypeType item))) (= (MapType0Select BoxType BoxType (|Map#Elements| m@@9) (_System.Tuple2._0 ($Unbox DatatypeTypeType item))) (_System.Tuple2._1 ($Unbox DatatypeTypeType item)))))
 :pattern ( (|Set#IsMember| (|Map#Items| m@@9) item))
)))
(assert (forall ((m@@10 T@U) (v@@6 T@U) ) (! (= (|Set#IsMember| (|Map#Values| m@@10) v@@6) (exists ((u@@5 T@U) ) (!  (and (|Set#IsMember| (|Map#Domain| m@@10) u@@5) (= v@@6 (MapType0Select BoxType BoxType (|Map#Elements| m@@10) u@@5)))
 :pattern ( (|Set#IsMember| (|Map#Domain| m@@10) u@@5))
 :pattern ( (MapType0Select BoxType BoxType (|Map#Elements| m@@10) u@@5))
)))
 :pattern ( (|Set#IsMember| (|Map#Values| m@@10) v@@6))
)))
(assert (forall ((m@@11 T@U) (u@@6 T@U) (|u'| T@U) (v@@7 T@U) ) (!  (and (=> (= |u'| u@@6) (and (|Set#IsMember| (|Map#Domain| (|Map#Build| m@@11 u@@6 v@@7)) |u'|) (= (MapType0Select BoxType BoxType (|Map#Elements| (|Map#Build| m@@11 u@@6 v@@7)) |u'|) v@@7))) (=> (or (not (= |u'| u@@6)) (not true)) (and (= (|Set#IsMember| (|Map#Domain| (|Map#Build| m@@11 u@@6 v@@7)) |u'|) (|Set#IsMember| (|Map#Domain| m@@11) |u'|)) (= (MapType0Select BoxType BoxType (|Map#Elements| (|Map#Build| m@@11 u@@6 v@@7)) |u'|) (MapType0Select BoxType BoxType (|Map#Elements| m@@11) |u'|)))))
 :pattern ( (|Set#IsMember| (|Map#Domain| (|Map#Build| m@@11 u@@6 v@@7)) |u'|))
 :pattern ( (MapType0Select BoxType BoxType (|Map#Elements| (|Map#Build| m@@11 u@@6 v@@7)) |u'|))
)))
(assert (forall ((d@@30 T@U) ) (! (= (BoxRank ($Box DatatypeTypeType d@@30)) (DtRank d@@30))
 :pattern ( (BoxRank ($Box DatatypeTypeType d@@30)))
)))
(assert (forall ((bx@@10 T@U) (t@@9 T@U) ) (!  (=> ($IsBox bx@@10 (TSet t@@9)) (and (= ($Box SetType ($Unbox SetType bx@@10)) bx@@10) ($Is SetType ($Unbox SetType bx@@10) (TSet t@@9))))
 :pattern ( ($IsBox bx@@10 (TSet t@@9)))
)))
(assert (forall ((bx@@11 T@U) (t@@10 T@U) ) (!  (=> ($IsBox bx@@11 (TSeq t@@10)) (and (= ($Box SeqType ($Unbox SeqType bx@@11)) bx@@11) ($Is SeqType ($Unbox SeqType bx@@11) (TSeq t@@10))))
 :pattern ( ($IsBox bx@@11 (TSeq t@@10)))
)))
(assert (forall ((v@@8 T@U) (t0@@5 T@U) (t1@@2 T@U) ) (! (= ($Is MapType v@@8 (TMap t0@@5 t1@@2)) (forall ((bx@@12 T@U) ) (!  (=> (|Set#IsMember| (|Map#Domain| v@@8) bx@@12) (and ($IsBox (MapType0Select BoxType BoxType (|Map#Elements| v@@8) bx@@12) t1@@2) ($IsBox bx@@12 t0@@5)))
 :pattern ( (MapType0Select BoxType BoxType (|Map#Elements| v@@8) bx@@12))
 :pattern ( (|Set#IsMember| (|Map#Domain| v@@8) bx@@12))
)))
 :pattern ( ($Is MapType v@@8 (TMap t0@@5 t1@@2)))
)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@26 T@U) (|_k#0@@17| T@U) (|c#0@@21| T@U) (|s#0@@26| T@U) (|c'#0@@11| T@U) (|s'#0@@12| T@U) ) (!  (=> (or (|_module.__default.small__step_h#canCall| |_k#0@@17| |c#0@@21| |s#0@@26| |c'#0@@11| |s'#0@@12|) (and (< 5 $FunctionContextHeight) (and (and (and ($Is DatatypeTypeType |c#0@@21| Tclass._module.com) ($Is MapType |s#0@@26| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@11| Tclass._module.com)) ($Is MapType |s'#0@@12| (TMap (TSeq TChar) TInt))))) (and (and (=> (< 0 (|ORD#Offset| |_k#0@@17|)) (=> (not (_module.com.SKIP_q |c#0@@21|)) (and (=> (_module.com.Assign_q |c#0@@21|) (let ((|a#3@@0| (_module.com._h1 |c#0@@21|)))
 (and (|$IsA#_module.com| |c'#0@@11|) (=> (|_module.com#Equal| |c'#0@@11| |#_module.com.SKIP|) (|_module.__default.aval#canCall| |a#3@@0| |s#0@@26|))))) (=> (not (_module.com.Assign_q |c#0@@21|)) (and (=> (_module.com.Seq_q |c#0@@21|) (let ((|c1#3@@0| (_module.com._h3 |c#0@@21|)))
(let ((|c0#3@@0| (_module.com._h2 |c#0@@21|)))
 (and (and (|$IsA#_module.com| |c0#3@@0|) (=> (|_module.com#Equal| |c0#3@@0| |#_module.com.SKIP|) (and (|$IsA#_module.com| |c'#0@@11|) (|$IsA#_module.com| |c1#3@@0|)))) (=> (not (and (and (|_module.com#Equal| |c0#3@@0| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@11| |c1#3@@0|)) (|Map#Equal| |s'#0@@12| |s#0@@26|))) (forall ((|c0'#5| T@U) ) (!  (=> ($Is DatatypeTypeType |c0'#5| Tclass._module.com) (and (|$IsA#_module.com| |c'#0@@11|) (=> (|_module.com#Equal| |c'#0@@11| (|#_module.com.Seq| |c0'#5| |c1#3@@0|)) (|_module.__default.small__step_h#canCall| (|ORD#Minus| |_k#0@@17| (|ORD#FromNat| 1)) |c0#3@@0| |s#0@@26| |c0'#5| |s'#0@@12|))))
 :pattern ( (_module.__default.small__step_h $ly@@26 (|ORD#Minus| |_k#0@@17| (|ORD#FromNat| 1)) |c0#3@@0| |s#0@@26| |c0'#5| |s'#0@@12|))
 :pattern ( (|#_module.com.Seq| |c0'#5| |c1#3@@0|))
))))))) (=> (not (_module.com.Seq_q |c#0@@21|)) (and (=> (_module.com.If_q |c#0@@21|) (let ((|els#3@@0| (_module.com._h6 |c#0@@21|)))
(let ((|thn#3@@0| (_module.com._h5 |c#0@@21|)))
(let ((|b#6@@0| (_module.com._h4 |c#0@@21|)))
 (and (and (|$IsA#_module.com| |c'#0@@11|) (|$IsA#_module.com| (ite (_module.__default.bval ($LS $LZ) |b#6@@0| |s#0@@26|) |thn#3@@0| |els#3@@0|))) (|_module.__default.bval#canCall| |b#6@@0| |s#0@@26|)))))) (=> (not (_module.com.If_q |c#0@@21|)) (|$IsA#_module.com| |c'#0@@11|))))))))) (=> (=> (< 0 (|ORD#Offset| |_k#0@@17|)) (ite (_module.com.SKIP_q |c#0@@21|) false (ite (_module.com.Assign_q |c#0@@21|) (let ((|a#4@@0| (_module.com._h1 |c#0@@21|)))
(let ((|x#4@@0| (_module.com._h0 |c#0@@21|)))
 (and (|_module.com#Equal| |c'#0@@11| |#_module.com.SKIP|) (|Map#Equal| |s'#0@@12| (|Map#Build| |s#0@@26| ($Box SeqType |x#4@@0|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#4@@0| |s#0@@26|)))))))) (ite (_module.com.Seq_q |c#0@@21|) (let ((|c1#4@@0| (_module.com._h3 |c#0@@21|)))
(let ((|c0#4@@0| (_module.com._h2 |c#0@@21|)))
 (or (and (and (|_module.com#Equal| |c0#4@@0| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@11| |c1#4@@0|)) (|Map#Equal| |s'#0@@12| |s#0@@26|)) (exists ((|c0'#6| T@U) ) (!  (and ($Is DatatypeTypeType |c0'#6| Tclass._module.com) (and (|_module.com#Equal| |c'#0@@11| (|#_module.com.Seq| |c0'#6| |c1#4@@0|)) (_module.__default.small__step_h $ly@@26 (|ORD#Minus| |_k#0@@17| (|ORD#FromNat| 1)) |c0#4@@0| |s#0@@26| |c0'#6| |s'#0@@12|)))
 :pattern ( (_module.__default.small__step_h $ly@@26 (|ORD#Minus| |_k#0@@17| (|ORD#FromNat| 1)) |c0#4@@0| |s#0@@26| |c0'#6| |s'#0@@12|))
 :pattern ( (|#_module.com.Seq| |c0'#6| |c1#4@@0|))
))))) (ite (_module.com.If_q |c#0@@21|) (let ((|els#4@@0| (_module.com._h6 |c#0@@21|)))
(let ((|thn#4@@0| (_module.com._h5 |c#0@@21|)))
(let ((|b#8@@0| (_module.com._h4 |c#0@@21|)))
 (and (|_module.com#Equal| |c'#0@@11| (ite (_module.__default.bval ($LS $LZ) |b#8@@0| |s#0@@26|) |thn#4@@0| |els#4@@0|)) (|Map#Equal| |s'#0@@12| |s#0@@26|))))) (let ((|body#4@@0| (_module.com._h8 |c#0@@21|)))
(let ((|b#9@@0| (_module.com._h7 |c#0@@21|)))
 (and (|_module.com#Equal| |c'#0@@11| (|#_module.com.If| |b#9@@0| (|#_module.com.Seq| |body#4@@0| (|#_module.com.While| |b#9@@0| |body#4@@0|)) (Lit DatatypeTypeType |#_module.com.SKIP|))) (|Map#Equal| |s'#0@@12| |s#0@@26|))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@17|)) (forall ((|_k'#0@@3| T@U) ) (!  (=> (|ORD#LessThanLimit| |_k'#0@@3| |_k#0@@17|) (|_module.__default.small__step_h#canCall| |_k'#0@@3| |c#0@@21| |s#0@@26| |c'#0@@11| |s'#0@@12|))
 :pattern ( (_module.__default.small__step_h $ly@@26 |_k'#0@@3| |c#0@@21| |s#0@@26| |c'#0@@11| |s'#0@@12|))
))))) (= (_module.__default.small__step_h ($LS $ly@@26) |_k#0@@17| |c#0@@21| |s#0@@26| |c'#0@@11| |s'#0@@12|)  (and (=> (< 0 (|ORD#Offset| |_k#0@@17|)) (ite (_module.com.SKIP_q |c#0@@21|) false (ite (_module.com.Assign_q |c#0@@21|) (let ((|a#2@@0| (_module.com._h1 |c#0@@21|)))
(let ((|x#2@@1| (_module.com._h0 |c#0@@21|)))
 (and (|_module.com#Equal| |c'#0@@11| |#_module.com.SKIP|) (|Map#Equal| |s'#0@@12| (|Map#Build| |s#0@@26| ($Box SeqType |x#2@@1|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#2@@0| |s#0@@26|)))))))) (ite (_module.com.Seq_q |c#0@@21|) (let ((|c1#2@@0| (_module.com._h3 |c#0@@21|)))
(let ((|c0#2@@0| (_module.com._h2 |c#0@@21|)))
 (or (and (and (|_module.com#Equal| |c0#2@@0| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@11| |c1#2@@0|)) (|Map#Equal| |s'#0@@12| |s#0@@26|)) (exists ((|c0'#4| T@U) ) (!  (and ($Is DatatypeTypeType |c0'#4| Tclass._module.com) (and (|_module.com#Equal| |c'#0@@11| (|#_module.com.Seq| |c0'#4| |c1#2@@0|)) (_module.__default.small__step_h $ly@@26 (|ORD#Minus| |_k#0@@17| (|ORD#FromNat| 1)) |c0#2@@0| |s#0@@26| |c0'#4| |s'#0@@12|)))
 :pattern ( (_module.__default.small__step_h $ly@@26 (|ORD#Minus| |_k#0@@17| (|ORD#FromNat| 1)) |c0#2@@0| |s#0@@26| |c0'#4| |s'#0@@12|))
 :pattern ( (|#_module.com.Seq| |c0'#4| |c1#2@@0|))
))))) (ite (_module.com.If_q |c#0@@21|) (let ((|els#2@@0| (_module.com._h6 |c#0@@21|)))
(let ((|thn#2@@0| (_module.com._h5 |c#0@@21|)))
(let ((|b#4@@1| (_module.com._h4 |c#0@@21|)))
 (and (|_module.com#Equal| |c'#0@@11| (ite (_module.__default.bval ($LS $LZ) |b#4@@1| |s#0@@26|) |thn#2@@0| |els#2@@0|)) (|Map#Equal| |s'#0@@12| |s#0@@26|))))) (let ((|body#2@@0| (_module.com._h8 |c#0@@21|)))
(let ((|b#5@@0| (_module.com._h7 |c#0@@21|)))
 (and (|_module.com#Equal| |c'#0@@11| (|#_module.com.If| |b#5@@0| (|#_module.com.Seq| |body#2@@0| (|#_module.com.While| |b#5@@0| |body#2@@0|)) (Lit DatatypeTypeType |#_module.com.SKIP|))) (|Map#Equal| |s'#0@@12| |s#0@@26|))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@17|)) (exists ((|_k'#0@@4| T@U) ) (!  (and (|ORD#LessThanLimit| |_k'#0@@4| |_k#0@@17|) (_module.__default.small__step_h $ly@@26 |_k'#0@@4| |c#0@@21| |s#0@@26| |c'#0@@11| |s'#0@@12|))
 :pattern ( (_module.__default.small__step_h $ly@@26 |_k'#0@@4| |c#0@@21| |s#0@@26| |c'#0@@11| |s'#0@@12|))
)))))))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@26) |_k#0@@17| |c#0@@21| |s#0@@26| |c'#0@@11| |s'#0@@12|))
))))
(assert (forall ((o@@7 T@U) ) (!  (=> (|ORD#IsNat| o@@7) (= o@@7 (|ORD#FromNat| (|ORD#Offset| o@@7))))
 :pattern ( (|ORD#Offset| o@@7))
 :pattern ( (|ORD#IsNat| o@@7))
)))
(assert (forall ((d@@31 T@U) ($h@@2 T@U) ) (!  (=> (and ($IsGoodHeap $h@@2) ($Is DatatypeTypeType d@@31 Tclass._module.aexp)) ($IsAlloc DatatypeTypeType d@@31 Tclass._module.aexp $h@@2))
 :pattern ( ($IsAlloc DatatypeTypeType d@@31 Tclass._module.aexp $h@@2))
)))
(assert (forall ((d@@32 T@U) ($h@@3 T@U) ) (!  (=> (and ($IsGoodHeap $h@@3) ($Is DatatypeTypeType d@@32 Tclass._module.bexp)) ($IsAlloc DatatypeTypeType d@@32 Tclass._module.bexp $h@@3))
 :pattern ( ($IsAlloc DatatypeTypeType d@@32 Tclass._module.bexp $h@@3))
)))
(assert (forall ((d@@33 T@U) ($h@@4 T@U) ) (!  (=> (and ($IsGoodHeap $h@@4) ($Is DatatypeTypeType d@@33 Tclass._module.com)) ($IsAlloc DatatypeTypeType d@@33 Tclass._module.com $h@@4))
 :pattern ( ($IsAlloc DatatypeTypeType d@@33 Tclass._module.com $h@@4))
)))
(assert (= (Tag Tclass._module.aexp) Tagclass._module.aexp))
(assert (= (TagFamily Tclass._module.aexp) tytagFamily$aexp))
(assert (= (Tag Tclass._module.bexp) Tagclass._module.bexp))
(assert (= (TagFamily Tclass._module.bexp) tytagFamily$bexp))
(assert (= (Tag Tclass._module.com) Tagclass._module.com))
(assert (= (TagFamily Tclass._module.com) tytagFamily$com))
(assert (= |#_module.com.SKIP| (Lit DatatypeTypeType |#_module.com.SKIP|)))
(assert (forall ((|a#19#0#0| T@U) ) (! (= ($Is DatatypeTypeType (|#_module.aexp.V| |a#19#0#0|) Tclass._module.aexp) ($Is SeqType |a#19#0#0| (TSeq TChar)))
 :pattern ( ($Is DatatypeTypeType (|#_module.aexp.V| |a#19#0#0|) Tclass._module.aexp))
)))
(assert (forall ((o@@8 T@U) (p@@4 T@U) ) (!  (=> (and (|ORD#IsNat| p@@4) (<= (|ORD#Offset| p@@4) (|ORD#Offset| o@@8))) (or (and (= p@@4 (|ORD#FromNat| 0)) (= (|ORD#Minus| o@@8 p@@4) o@@8)) (and (or (not (= p@@4 (|ORD#FromNat| 0))) (not true)) (|ORD#Less| (|ORD#Minus| o@@8 p@@4) o@@8))))
 :pattern ( (|ORD#Minus| o@@8 p@@4))
)))
(assert (forall ((d@@34 T@U) ($h@@5 T@U) ) (!  (=> (and ($IsGoodHeap $h@@5) (and (_module.aexp.V_q d@@34) ($IsAlloc DatatypeTypeType d@@34 Tclass._module.aexp $h@@5))) ($IsAlloc SeqType (_module.aexp.x d@@34) (TSeq TChar) $h@@5))
 :pattern ( ($IsAlloc SeqType (_module.aexp.x d@@34) (TSeq TChar) $h@@5))
)))
(assert (forall ((d@@35 T@U) ($h@@6 T@U) ) (!  (=> (and ($IsGoodHeap $h@@6) (and (_module.com.Assign_q d@@35) ($IsAlloc DatatypeTypeType d@@35 Tclass._module.com $h@@6))) ($IsAlloc SeqType (_module.com._h0 d@@35) (TSeq TChar) $h@@6))
 :pattern ( ($IsAlloc SeqType (_module.com._h0 d@@35) (TSeq TChar) $h@@6))
)))
(assert (forall ((d@@36 T@U) ) (!  (=> ($Is DatatypeTypeType d@@36 Tclass._module.com) (or (or (or (or (_module.com.SKIP_q d@@36) (_module.com.Assign_q d@@36)) (_module.com.Seq_q d@@36)) (_module.com.If_q d@@36)) (_module.com.While_q d@@36)))
 :pattern ( (_module.com.While_q d@@36) ($Is DatatypeTypeType d@@36 Tclass._module.com))
 :pattern ( (_module.com.If_q d@@36) ($Is DatatypeTypeType d@@36 Tclass._module.com))
 :pattern ( (_module.com.Seq_q d@@36) ($Is DatatypeTypeType d@@36 Tclass._module.com))
 :pattern ( (_module.com.Assign_q d@@36) ($Is DatatypeTypeType d@@36 Tclass._module.com))
 :pattern ( (_module.com.SKIP_q d@@36) ($Is DatatypeTypeType d@@36 Tclass._module.com))
)))
(assert (forall ((a@@17 T@U) (b@@17 T@U) ) (! (= (|Set#Equal| a@@17 b@@17) (forall ((o@@9 T@U) ) (! (= (|Set#IsMember| a@@17 o@@9) (|Set#IsMember| b@@17 o@@9))
 :pattern ( (|Set#IsMember| a@@17 o@@9))
 :pattern ( (|Set#IsMember| b@@17 o@@9))
)))
 :pattern ( (|Set#Equal| a@@17 b@@17))
)))
(assert  (=> (<= 2 $FunctionContextHeight) (forall (($ly@@27 T@U) (|a#0@@3| T@U) (|s#0@@27| T@U) ) (!  (=> (or (|_module.__default.aval#canCall| |a#0@@3| |s#0@@27|) (and (< 2 $FunctionContextHeight) (and ($Is DatatypeTypeType |a#0@@3| Tclass._module.aexp) ($Is MapType |s#0@@27| (TMap (TSeq TChar) TInt))))) (and (=> (not (_module.aexp.N_q |a#0@@3|)) (=> (not (_module.aexp.V_q |a#0@@3|)) (let ((|a1#1@@0| (_module.aexp._1 |a#0@@3|)))
(let ((|a0#1@@0| (_module.aexp._0 |a#0@@3|)))
 (and (|_module.__default.aval#canCall| |a0#1@@0| |s#0@@27|) (|_module.__default.aval#canCall| |a1#1@@0| |s#0@@27|)))))) (= (_module.__default.aval ($LS $ly@@27) |a#0@@3| |s#0@@27|) (ite (_module.aexp.N_q |a#0@@3|) (let ((|n#0| (_module.aexp.n |a#0@@3|)))
|n#0|) (ite (_module.aexp.V_q |a#0@@3|) (let ((|x#0@@1| (_module.aexp.x |a#0@@3|)))
(ite (|Set#IsMember| (|Map#Domain| |s#0@@27|) ($Box SeqType |x#0@@1|)) (U_2_int ($Unbox intType (MapType0Select BoxType BoxType (|Map#Elements| |s#0@@27|) ($Box SeqType |x#0@@1|)))) 0)) (let ((|a1#0@@0| (_module.aexp._1 |a#0@@3|)))
(let ((|a0#0@@0| (_module.aexp._0 |a#0@@3|)))
(+ (_module.__default.aval $ly@@27 |a0#0@@0| |s#0@@27|) (_module.__default.aval $ly@@27 |a1#0@@0| |s#0@@27|)))))))))
 :pattern ( (_module.__default.aval ($LS $ly@@27) |a#0@@3| |s#0@@27|))
))))
(assert (forall ((d@@37 T@U) (|_System._tuple#2$T0@@6| T@U) ($h@@7 T@U) ) (!  (=> (and ($IsGoodHeap $h@@7) (and (_System.Tuple2.___hMake2_q d@@37) (exists ((|_System._tuple#2$T1@@6| T@U) ) (! ($IsAlloc DatatypeTypeType d@@37 (Tclass._System.Tuple2 |_System._tuple#2$T0@@6| |_System._tuple#2$T1@@6|) $h@@7)
 :pattern ( ($IsAlloc DatatypeTypeType d@@37 (Tclass._System.Tuple2 |_System._tuple#2$T0@@6| |_System._tuple#2$T1@@6|) $h@@7))
)))) ($IsAllocBox (_System.Tuple2._0 d@@37) |_System._tuple#2$T0@@6| $h@@7))
 :pattern ( ($IsAllocBox (_System.Tuple2._0 d@@37) |_System._tuple#2$T0@@6| $h@@7))
)))
(assert (forall ((d@@38 T@U) (|_System._tuple#2$T1@@7| T@U) ($h@@8 T@U) ) (!  (=> (and ($IsGoodHeap $h@@8) (and (_System.Tuple2.___hMake2_q d@@38) (exists ((|_System._tuple#2$T0@@7| T@U) ) (! ($IsAlloc DatatypeTypeType d@@38 (Tclass._System.Tuple2 |_System._tuple#2$T0@@7| |_System._tuple#2$T1@@7|) $h@@8)
 :pattern ( ($IsAlloc DatatypeTypeType d@@38 (Tclass._System.Tuple2 |_System._tuple#2$T0@@7| |_System._tuple#2$T1@@7|) $h@@8))
)))) ($IsAllocBox (_System.Tuple2._1 d@@38) |_System._tuple#2$T1@@7| $h@@8))
 :pattern ( ($IsAllocBox (_System.Tuple2._1 d@@38) |_System._tuple#2$T1@@7| $h@@8))
)))
(assert (forall ((d@@39 T@U) ($h@@9 T@U) ) (!  (=> (and ($IsGoodHeap $h@@9) (and (_module.aexp.Plus_q d@@39) ($IsAlloc DatatypeTypeType d@@39 Tclass._module.aexp $h@@9))) ($IsAlloc DatatypeTypeType (_module.aexp._0 d@@39) Tclass._module.aexp $h@@9))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.aexp._0 d@@39) Tclass._module.aexp $h@@9))
)))
(assert (forall ((d@@40 T@U) ($h@@10 T@U) ) (!  (=> (and ($IsGoodHeap $h@@10) (and (_module.aexp.Plus_q d@@40) ($IsAlloc DatatypeTypeType d@@40 Tclass._module.aexp $h@@10))) ($IsAlloc DatatypeTypeType (_module.aexp._1 d@@40) Tclass._module.aexp $h@@10))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.aexp._1 d@@40) Tclass._module.aexp $h@@10))
)))
(assert (forall ((d@@41 T@U) ($h@@11 T@U) ) (!  (=> (and ($IsGoodHeap $h@@11) (and (_module.bexp.Not_q d@@41) ($IsAlloc DatatypeTypeType d@@41 Tclass._module.bexp $h@@11))) ($IsAlloc DatatypeTypeType (_module.bexp.op d@@41) Tclass._module.bexp $h@@11))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.bexp.op d@@41) Tclass._module.bexp $h@@11))
)))
(assert (forall ((d@@42 T@U) ($h@@12 T@U) ) (!  (=> (and ($IsGoodHeap $h@@12) (and (_module.bexp.And_q d@@42) ($IsAlloc DatatypeTypeType d@@42 Tclass._module.bexp $h@@12))) ($IsAlloc DatatypeTypeType (_module.bexp._0 d@@42) Tclass._module.bexp $h@@12))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.bexp._0 d@@42) Tclass._module.bexp $h@@12))
)))
(assert (forall ((d@@43 T@U) ($h@@13 T@U) ) (!  (=> (and ($IsGoodHeap $h@@13) (and (_module.bexp.And_q d@@43) ($IsAlloc DatatypeTypeType d@@43 Tclass._module.bexp $h@@13))) ($IsAlloc DatatypeTypeType (_module.bexp._1 d@@43) Tclass._module.bexp $h@@13))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.bexp._1 d@@43) Tclass._module.bexp $h@@13))
)))
(assert (forall ((d@@44 T@U) ($h@@14 T@U) ) (!  (=> (and ($IsGoodHeap $h@@14) (and (_module.bexp.Less_q d@@44) ($IsAlloc DatatypeTypeType d@@44 Tclass._module.bexp $h@@14))) ($IsAlloc DatatypeTypeType (_module.bexp.a0 d@@44) Tclass._module.aexp $h@@14))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.bexp.a0 d@@44) Tclass._module.aexp $h@@14))
)))
(assert (forall ((d@@45 T@U) ($h@@15 T@U) ) (!  (=> (and ($IsGoodHeap $h@@15) (and (_module.bexp.Less_q d@@45) ($IsAlloc DatatypeTypeType d@@45 Tclass._module.bexp $h@@15))) ($IsAlloc DatatypeTypeType (_module.bexp.a1 d@@45) Tclass._module.aexp $h@@15))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.bexp.a1 d@@45) Tclass._module.aexp $h@@15))
)))
(assert (forall ((d@@46 T@U) ($h@@16 T@U) ) (!  (=> (and ($IsGoodHeap $h@@16) (and (_module.com.Assign_q d@@46) ($IsAlloc DatatypeTypeType d@@46 Tclass._module.com $h@@16))) ($IsAlloc DatatypeTypeType (_module.com._h1 d@@46) Tclass._module.aexp $h@@16))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.com._h1 d@@46) Tclass._module.aexp $h@@16))
)))
(assert (forall ((d@@47 T@U) ($h@@17 T@U) ) (!  (=> (and ($IsGoodHeap $h@@17) (and (_module.com.Seq_q d@@47) ($IsAlloc DatatypeTypeType d@@47 Tclass._module.com $h@@17))) ($IsAlloc DatatypeTypeType (_module.com._h2 d@@47) Tclass._module.com $h@@17))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.com._h2 d@@47) Tclass._module.com $h@@17))
)))
(assert (forall ((d@@48 T@U) ($h@@18 T@U) ) (!  (=> (and ($IsGoodHeap $h@@18) (and (_module.com.Seq_q d@@48) ($IsAlloc DatatypeTypeType d@@48 Tclass._module.com $h@@18))) ($IsAlloc DatatypeTypeType (_module.com._h3 d@@48) Tclass._module.com $h@@18))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.com._h3 d@@48) Tclass._module.com $h@@18))
)))
(assert (forall ((d@@49 T@U) ($h@@19 T@U) ) (!  (=> (and ($IsGoodHeap $h@@19) (and (_module.com.If_q d@@49) ($IsAlloc DatatypeTypeType d@@49 Tclass._module.com $h@@19))) ($IsAlloc DatatypeTypeType (_module.com._h4 d@@49) Tclass._module.bexp $h@@19))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.com._h4 d@@49) Tclass._module.bexp $h@@19))
)))
(assert (forall ((d@@50 T@U) ($h@@20 T@U) ) (!  (=> (and ($IsGoodHeap $h@@20) (and (_module.com.If_q d@@50) ($IsAlloc DatatypeTypeType d@@50 Tclass._module.com $h@@20))) ($IsAlloc DatatypeTypeType (_module.com._h5 d@@50) Tclass._module.com $h@@20))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.com._h5 d@@50) Tclass._module.com $h@@20))
)))
(assert (forall ((d@@51 T@U) ($h@@21 T@U) ) (!  (=> (and ($IsGoodHeap $h@@21) (and (_module.com.If_q d@@51) ($IsAlloc DatatypeTypeType d@@51 Tclass._module.com $h@@21))) ($IsAlloc DatatypeTypeType (_module.com._h6 d@@51) Tclass._module.com $h@@21))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.com._h6 d@@51) Tclass._module.com $h@@21))
)))
(assert (forall ((d@@52 T@U) ($h@@22 T@U) ) (!  (=> (and ($IsGoodHeap $h@@22) (and (_module.com.While_q d@@52) ($IsAlloc DatatypeTypeType d@@52 Tclass._module.com $h@@22))) ($IsAlloc DatatypeTypeType (_module.com._h7 d@@52) Tclass._module.bexp $h@@22))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.com._h7 d@@52) Tclass._module.bexp $h@@22))
)))
(assert (forall ((d@@53 T@U) ($h@@23 T@U) ) (!  (=> (and ($IsGoodHeap $h@@23) (and (_module.com.While_q d@@53) ($IsAlloc DatatypeTypeType d@@53 Tclass._module.com $h@@23))) ($IsAlloc DatatypeTypeType (_module.com._h8 d@@53) Tclass._module.com $h@@23))
 :pattern ( ($IsAlloc DatatypeTypeType (_module.com._h8 d@@53) Tclass._module.com $h@@23))
)))
(assert (forall ((|a#3#0#0| T@U) (|a#3#1#0| T@U) ) (! (= (|#_System._tuple#2._#Make2| (Lit BoxType |a#3#0#0|) (Lit BoxType |a#3#1#0|)) (Lit DatatypeTypeType (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|)))
 :pattern ( (|#_System._tuple#2._#Make2| (Lit BoxType |a#3#0#0|) (Lit BoxType |a#3#1#0|)))
)))
(assert (forall ((|a#27#0#0| T@U) (|a#27#1#0| T@U) ) (! (= (|#_module.aexp.Plus| (Lit DatatypeTypeType |a#27#0#0|) (Lit DatatypeTypeType |a#27#1#0|)) (Lit DatatypeTypeType (|#_module.aexp.Plus| |a#27#0#0| |a#27#1#0|)))
 :pattern ( (|#_module.aexp.Plus| (Lit DatatypeTypeType |a#27#0#0|) (Lit DatatypeTypeType |a#27#1#0|)))
)))
(assert (forall ((|a#46#0#0| T@U) (|a#46#1#0| T@U) ) (! (= (|#_module.bexp.And| (Lit DatatypeTypeType |a#46#0#0|) (Lit DatatypeTypeType |a#46#1#0|)) (Lit DatatypeTypeType (|#_module.bexp.And| |a#46#0#0| |a#46#1#0|)))
 :pattern ( (|#_module.bexp.And| (Lit DatatypeTypeType |a#46#0#0|) (Lit DatatypeTypeType |a#46#1#0|)))
)))
(assert (forall ((|a#54#0#0| T@U) (|a#54#1#0| T@U) ) (! (= (|#_module.bexp.Less| (Lit DatatypeTypeType |a#54#0#0|) (Lit DatatypeTypeType |a#54#1#0|)) (Lit DatatypeTypeType (|#_module.bexp.Less| |a#54#0#0| |a#54#1#0|)))
 :pattern ( (|#_module.bexp.Less| (Lit DatatypeTypeType |a#54#0#0|) (Lit DatatypeTypeType |a#54#1#0|)))
)))
(assert (forall ((|a#66#0#0| T@U) (|a#66#1#0| T@U) ) (! (= (|#_module.com.Assign| (Lit SeqType |a#66#0#0|) (Lit DatatypeTypeType |a#66#1#0|)) (Lit DatatypeTypeType (|#_module.com.Assign| |a#66#0#0| |a#66#1#0|)))
 :pattern ( (|#_module.com.Assign| (Lit SeqType |a#66#0#0|) (Lit DatatypeTypeType |a#66#1#0|)))
)))
(assert (forall ((|a#75#0#0| T@U) (|a#75#1#0| T@U) ) (! (= (|#_module.com.Seq| (Lit DatatypeTypeType |a#75#0#0|) (Lit DatatypeTypeType |a#75#1#0|)) (Lit DatatypeTypeType (|#_module.com.Seq| |a#75#0#0| |a#75#1#0|)))
 :pattern ( (|#_module.com.Seq| (Lit DatatypeTypeType |a#75#0#0|) (Lit DatatypeTypeType |a#75#1#0|)))
)))
(assert (forall ((|a#93#0#0| T@U) (|a#93#1#0| T@U) ) (! (= (|#_module.com.While| (Lit DatatypeTypeType |a#93#0#0|) (Lit DatatypeTypeType |a#93#1#0|)) (Lit DatatypeTypeType (|#_module.com.While| |a#93#0#0| |a#93#1#0|)))
 :pattern ( (|#_module.com.While| (Lit DatatypeTypeType |a#93#0#0|) (Lit DatatypeTypeType |a#93#1#0|)))
)))
(assert (forall ((x@@6 Int) ) (! (= ($Box intType (int_2_U (LitInt x@@6))) (Lit BoxType ($Box intType (int_2_U x@@6))))
 :pattern ( ($Box intType (int_2_U (LitInt x@@6))))
)))
(assert (forall ((|a#15#0#0| Int) ) (! (= (|#_module.aexp.N| (LitInt |a#15#0#0|)) (Lit DatatypeTypeType (|#_module.aexp.N| |a#15#0#0|)))
 :pattern ( (|#_module.aexp.N| (LitInt |a#15#0#0|)))
)))
(assert (forall ((|a#20#0#0| T@U) ) (! (= (|#_module.aexp.V| (Lit SeqType |a#20#0#0|)) (Lit DatatypeTypeType (|#_module.aexp.V| |a#20#0#0|)))
 :pattern ( (|#_module.aexp.V| (Lit SeqType |a#20#0#0|)))
)))
(assert (forall ((|a#35#0#0| T@U) ) (! (= (|#_module.bexp.Bc| (U_2_bool (Lit boolType |a#35#0#0|))) (Lit DatatypeTypeType (|#_module.bexp.Bc| (U_2_bool |a#35#0#0|))))
 :pattern ( (|#_module.bexp.Bc| (U_2_bool (Lit boolType |a#35#0#0|))))
)))
(assert (forall ((|a#40#0#0| T@U) ) (! (= (|#_module.bexp.Not| (Lit DatatypeTypeType |a#40#0#0|)) (Lit DatatypeTypeType (|#_module.bexp.Not| |a#40#0#0|)))
 :pattern ( (|#_module.bexp.Not| (Lit DatatypeTypeType |a#40#0#0|)))
)))
(assert (forall ((x@@7 T@U) (T@@4 T@T) ) (! (= ($Box T@@4 (Lit T@@4 x@@7)) (Lit BoxType ($Box T@@4 x@@7)))
 :pattern ( ($Box T@@4 (Lit T@@4 x@@7)))
)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@28 T@U) (|_k#0@@18| T@U) (|c#0@@22| T@U) (|s#0@@28| T@U) (|c'#0@@12| T@U) (|s'#0@@13| T@U) ) (!  (=> (or (|_module.__default.small__step_h#canCall| (Lit BoxType |_k#0@@18|) (Lit DatatypeTypeType |c#0@@22|) (Lit MapType |s#0@@28|) (Lit DatatypeTypeType |c'#0@@12|) (Lit MapType |s'#0@@13|)) (and (< 5 $FunctionContextHeight) (and (and (and ($Is DatatypeTypeType |c#0@@22| Tclass._module.com) ($Is MapType |s#0@@28| (TMap (TSeq TChar) TInt))) ($Is DatatypeTypeType |c'#0@@12| Tclass._module.com)) ($Is MapType |s'#0@@13| (TMap (TSeq TChar) TInt))))) (and (and (=> (< 0 (|ORD#Offset| |_k#0@@18|)) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.com.SKIP_q (Lit DatatypeTypeType |c#0@@22|)))))) (and (=> (U_2_bool (Lit boolType (bool_2_U (_module.com.Assign_q (Lit DatatypeTypeType |c#0@@22|))))) (let ((|a#9@@0| (Lit DatatypeTypeType (_module.com._h1 (Lit DatatypeTypeType |c#0@@22|)))))
 (and (|$IsA#_module.com| (Lit DatatypeTypeType |c'#0@@12|)) (=> (|_module.com#Equal| |c'#0@@12| |#_module.com.SKIP|) (|_module.__default.aval#canCall| |a#9@@0| (Lit MapType |s#0@@28|)))))) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.com.Assign_q (Lit DatatypeTypeType |c#0@@22|)))))) (and (=> (U_2_bool (Lit boolType (bool_2_U (_module.com.Seq_q (Lit DatatypeTypeType |c#0@@22|))))) (let ((|c1#9@@0| (Lit DatatypeTypeType (_module.com._h3 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|c0#9@@0| (Lit DatatypeTypeType (_module.com._h2 (Lit DatatypeTypeType |c#0@@22|)))))
 (and (and (|$IsA#_module.com| |c0#9@@0|) (=> (|_module.com#Equal| |c0#9@@0| |#_module.com.SKIP|) (and (|$IsA#_module.com| (Lit DatatypeTypeType |c'#0@@12|)) (|$IsA#_module.com| |c1#9@@0|)))) (=> (not (and (and (|_module.com#Equal| |c0#9@@0| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@12| |c1#9@@0|)) (|Map#Equal| |s'#0@@13| |s#0@@28|))) (forall ((|c0'#11| T@U) ) (!  (=> ($Is DatatypeTypeType |c0'#11| Tclass._module.com) (and (|$IsA#_module.com| (Lit DatatypeTypeType |c'#0@@12|)) (=> (|_module.com#Equal| |c'#0@@12| (|#_module.com.Seq| |c0'#11| |c1#9@@0|)) (|_module.__default.small__step_h#canCall| (|ORD#Minus| |_k#0@@18| (|ORD#FromNat| 1)) |c0#9@@0| (Lit MapType |s#0@@28|) |c0'#11| (Lit MapType |s'#0@@13|)))))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@28) (|ORD#Minus| |_k#0@@18| (|ORD#FromNat| 1)) |c0#9@@0| |s#0@@28| |c0'#11| |s'#0@@13|))
 :pattern ( (|#_module.com.Seq| |c0'#11| |c1#9@@0|))
))))))) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.com.Seq_q (Lit DatatypeTypeType |c#0@@22|)))))) (and (=> (U_2_bool (Lit boolType (bool_2_U (_module.com.If_q (Lit DatatypeTypeType |c#0@@22|))))) (let ((|els#9@@0| (Lit DatatypeTypeType (_module.com._h6 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|thn#9@@0| (Lit DatatypeTypeType (_module.com._h5 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|b#18@@0| (Lit DatatypeTypeType (_module.com._h4 (Lit DatatypeTypeType |c#0@@22|)))))
 (and (and (|$IsA#_module.com| (Lit DatatypeTypeType |c'#0@@12|)) (|$IsA#_module.com| (ite (_module.__default.bval ($LS $LZ) |b#18@@0| (Lit MapType |s#0@@28|)) |thn#9@@0| |els#9@@0|))) (|_module.__default.bval#canCall| |b#18@@0| (Lit MapType |s#0@@28|))))))) (=> (not (U_2_bool (Lit boolType (bool_2_U (_module.com.If_q (Lit DatatypeTypeType |c#0@@22|)))))) (|$IsA#_module.com| (Lit DatatypeTypeType |c'#0@@12|)))))))))) (=> (=> (< 0 (|ORD#Offset| |_k#0@@18|)) (ite (_module.com.SKIP_q (Lit DatatypeTypeType |c#0@@22|)) false (ite (_module.com.Assign_q (Lit DatatypeTypeType |c#0@@22|)) (let ((|a#10@@0| (Lit DatatypeTypeType (_module.com._h1 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|x#10@@0| (Lit SeqType (_module.com._h0 (Lit DatatypeTypeType |c#0@@22|)))))
 (and (|_module.com#Equal| |c'#0@@12| |#_module.com.SKIP|) (|Map#Equal| |s'#0@@13| (|Map#Build| (Lit MapType |s#0@@28|) ($Box SeqType |x#10@@0|) ($Box intType (int_2_U (LitInt (_module.__default.aval ($LS $LZ) |a#10@@0| (Lit MapType |s#0@@28|)))))))))) (ite (_module.com.Seq_q (Lit DatatypeTypeType |c#0@@22|)) (let ((|c1#10@@0| (Lit DatatypeTypeType (_module.com._h3 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|c0#10@@0| (Lit DatatypeTypeType (_module.com._h2 (Lit DatatypeTypeType |c#0@@22|)))))
 (or (and (and (|_module.com#Equal| |c0#10@@0| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@12| |c1#10@@0|)) (|Map#Equal| |s'#0@@13| |s#0@@28|)) (exists ((|c0'#12| T@U) ) (!  (and ($Is DatatypeTypeType |c0'#12| Tclass._module.com) (and (|_module.com#Equal| |c'#0@@12| (|#_module.com.Seq| |c0'#12| |c1#10@@0|)) (_module.__default.small__step_h ($LS $ly@@28) (|ORD#Minus| |_k#0@@18| (|ORD#FromNat| 1)) |c0#10@@0| (Lit MapType |s#0@@28|) |c0'#12| (Lit MapType |s'#0@@13|))))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@28) (|ORD#Minus| |_k#0@@18| (|ORD#FromNat| 1)) |c0#10@@0| |s#0@@28| |c0'#12| |s'#0@@13|))
 :pattern ( (|#_module.com.Seq| |c0'#12| |c1#10@@0|))
))))) (ite (_module.com.If_q (Lit DatatypeTypeType |c#0@@22|)) (let ((|els#10@@0| (Lit DatatypeTypeType (_module.com._h6 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|thn#10@@0| (Lit DatatypeTypeType (_module.com._h5 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|b#20@@0| (Lit DatatypeTypeType (_module.com._h4 (Lit DatatypeTypeType |c#0@@22|)))))
 (and (|_module.com#Equal| |c'#0@@12| (ite (_module.__default.bval ($LS $LZ) |b#20@@0| (Lit MapType |s#0@@28|)) |thn#10@@0| |els#10@@0|)) (|Map#Equal| |s'#0@@13| |s#0@@28|))))) (let ((|body#10@@0| (Lit DatatypeTypeType (_module.com._h8 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|b#21@@0| (Lit DatatypeTypeType (_module.com._h7 (Lit DatatypeTypeType |c#0@@22|)))))
 (and (|_module.com#Equal| |c'#0@@12| (|#_module.com.If| |b#21@@0| (Lit DatatypeTypeType (|#_module.com.Seq| |body#10@@0| (Lit DatatypeTypeType (|#_module.com.While| |b#21@@0| |body#10@@0|)))) (Lit DatatypeTypeType |#_module.com.SKIP|))) (|Map#Equal| |s'#0@@13| |s#0@@28|))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@18|)) (forall ((|_k'#2@@3| T@U) ) (!  (=> (|ORD#LessThanLimit| |_k'#2@@3| |_k#0@@18|) (|_module.__default.small__step_h#canCall| |_k'#2@@3| |c#0@@22| |s#0@@28| |c'#0@@12| |s'#0@@13|))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@28) |_k'#2@@3| |c#0@@22| |s#0@@28| |c'#0@@12| |s'#0@@13|))
))))) (= (_module.__default.small__step_h ($LS $ly@@28) (Lit BoxType |_k#0@@18|) (Lit DatatypeTypeType |c#0@@22|) (Lit MapType |s#0@@28|) (Lit DatatypeTypeType |c'#0@@12|) (Lit MapType |s'#0@@13|))  (and (=> (< 0 (|ORD#Offset| |_k#0@@18|)) (ite (_module.com.SKIP_q (Lit DatatypeTypeType |c#0@@22|)) false (ite (_module.com.Assign_q (Lit DatatypeTypeType |c#0@@22|)) (let ((|a#8@@0| (Lit DatatypeTypeType (_module.com._h1 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|x#8@@0| (Lit SeqType (_module.com._h0 (Lit DatatypeTypeType |c#0@@22|)))))
 (and (|_module.com#Equal| |c'#0@@12| |#_module.com.SKIP|) (|Map#Equal| |s'#0@@13| (|Map#Build| (Lit MapType |s#0@@28|) ($Box SeqType |x#8@@0|) ($Box intType (int_2_U (LitInt (_module.__default.aval ($LS $LZ) |a#8@@0| (Lit MapType |s#0@@28|)))))))))) (ite (_module.com.Seq_q (Lit DatatypeTypeType |c#0@@22|)) (let ((|c1#8@@0| (Lit DatatypeTypeType (_module.com._h3 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|c0#8@@0| (Lit DatatypeTypeType (_module.com._h2 (Lit DatatypeTypeType |c#0@@22|)))))
 (or (and (and (|_module.com#Equal| |c0#8@@0| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@@12| |c1#8@@0|)) (|Map#Equal| |s'#0@@13| |s#0@@28|)) (exists ((|c0'#10| T@U) ) (!  (and ($Is DatatypeTypeType |c0'#10| Tclass._module.com) (and (|_module.com#Equal| |c'#0@@12| (|#_module.com.Seq| |c0'#10| |c1#8@@0|)) (_module.__default.small__step_h ($LS $ly@@28) (|ORD#Minus| |_k#0@@18| (|ORD#FromNat| 1)) |c0#8@@0| (Lit MapType |s#0@@28|) |c0'#10| (Lit MapType |s'#0@@13|))))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@28) (|ORD#Minus| |_k#0@@18| (|ORD#FromNat| 1)) |c0#8@@0| |s#0@@28| |c0'#10| |s'#0@@13|))
 :pattern ( (|#_module.com.Seq| |c0'#10| |c1#8@@0|))
))))) (ite (_module.com.If_q (Lit DatatypeTypeType |c#0@@22|)) (let ((|els#8@@0| (Lit DatatypeTypeType (_module.com._h6 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|thn#8@@0| (Lit DatatypeTypeType (_module.com._h5 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|b#16@@0| (Lit DatatypeTypeType (_module.com._h4 (Lit DatatypeTypeType |c#0@@22|)))))
 (and (|_module.com#Equal| |c'#0@@12| (ite (_module.__default.bval ($LS $LZ) |b#16@@0| (Lit MapType |s#0@@28|)) |thn#8@@0| |els#8@@0|)) (|Map#Equal| |s'#0@@13| |s#0@@28|))))) (let ((|body#8@@0| (Lit DatatypeTypeType (_module.com._h8 (Lit DatatypeTypeType |c#0@@22|)))))
(let ((|b#17@@0| (Lit DatatypeTypeType (_module.com._h7 (Lit DatatypeTypeType |c#0@@22|)))))
 (and (|_module.com#Equal| |c'#0@@12| (|#_module.com.If| |b#17@@0| (Lit DatatypeTypeType (|#_module.com.Seq| |body#8@@0| (Lit DatatypeTypeType (|#_module.com.While| |b#17@@0| |body#8@@0|)))) (Lit DatatypeTypeType |#_module.com.SKIP|))) (|Map#Equal| |s'#0@@13| |s#0@@28|))))))))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@18|)) (exists ((|_k'#2@@4| T@U) ) (!  (and (|ORD#LessThanLimit| |_k'#2@@4| |_k#0@@18|) (_module.__default.small__step_h ($LS $ly@@28) |_k'#2@@4| |c#0@@22| |s#0@@28| |c'#0@@12| |s'#0@@13|))
 :pattern ( (_module.__default.small__step_h ($LS $ly@@28) |_k'#2@@4| |c#0@@22| |s#0@@28| |c'#0@@12| |s'#0@@13|))
)))))))
 :weight 3
 :pattern ( (_module.__default.small__step_h ($LS $ly@@28) (Lit BoxType |_k#0@@18|) (Lit DatatypeTypeType |c#0@@22|) (Lit MapType |s#0@@28|) (Lit DatatypeTypeType |c'#0@@12|) (Lit MapType |s'#0@@13|)))
))))
(assert (forall ((s@@1 T@U) ) (!  (=> (= (|Seq#Length| s@@1) 0) (= s@@1 |Seq#Empty|))
 :pattern ( (|Seq#Length| s@@1))
)))
(assert (forall ((d@@54 T@U) ) (!  (=> ($Is DatatypeTypeType d@@54 Tclass._module.bexp) (or (or (or (_module.bexp.Bc_q d@@54) (_module.bexp.Not_q d@@54)) (_module.bexp.And_q d@@54)) (_module.bexp.Less_q d@@54)))
 :pattern ( (_module.bexp.Less_q d@@54) ($Is DatatypeTypeType d@@54 Tclass._module.bexp))
 :pattern ( (_module.bexp.And_q d@@54) ($Is DatatypeTypeType d@@54 Tclass._module.bexp))
 :pattern ( (_module.bexp.Not_q d@@54) ($Is DatatypeTypeType d@@54 Tclass._module.bexp))
 :pattern ( (_module.bexp.Bc_q d@@54) ($Is DatatypeTypeType d@@54 Tclass._module.bexp))
)))
(assert (forall ((h@@3 T@U) (v@@9 T@U) ) (! ($IsAlloc intType v@@9 TInt h@@3)
 :pattern ( ($IsAlloc intType v@@9 TInt h@@3))
)))
(assert (forall ((h@@4 T@U) (v@@10 T@U) ) (! ($IsAlloc boolType v@@10 TBool h@@4)
 :pattern ( ($IsAlloc boolType v@@10 TBool h@@4))
)))
(assert (forall ((h@@5 T@U) (v@@11 T@U) ) (! ($IsAlloc charType v@@11 TChar h@@5)
 :pattern ( ($IsAlloc charType v@@11 TChar h@@5))
)))
(assert (forall ((h@@6 T@U) (v@@12 T@U) ) (! ($IsAlloc BoxType v@@12 TORDINAL h@@6)
 :pattern ( ($IsAlloc BoxType v@@12 TORDINAL h@@6))
)))
(assert (forall ((v@@13 T@U) (t0@@6 T@U) ) (! (= ($Is SeqType v@@13 (TSeq t0@@6)) (forall ((i@@2 Int) ) (!  (=> (and (<= 0 i@@2) (< i@@2 (|Seq#Length| v@@13))) ($IsBox (|Seq#Index| v@@13 i@@2) t0@@6))
 :pattern ( (|Seq#Index| v@@13 i@@2))
)))
 :pattern ( ($Is SeqType v@@13 (TSeq t0@@6)))
)))
(assert (forall ((m@@12 T@U) ) (!  (or (= m@@12 |Map#Empty|) (exists ((k@@0 T@U) (v@@14 T@U) ) (|Set#IsMember| (|Map#Items| m@@12) ($Box DatatypeTypeType (|#_System._tuple#2._#Make2| k@@0 v@@14)))))
 :pattern ( (|Map#Items| m@@12))
)))
(assert  (=> (<= 5 $FunctionContextHeight) (forall (($ly@@29 T@U) (|c#0@@23| T@U) (|s#0@@29| T@U) (|c'#0@@13| T@U) (|s'#0@@14| T@U) (|_k#0@@19| T@U) (_m@@0 T@U) (_limit@@0 T@U) ) (!  (=> (|ORD#Less| |_k#0@@19| _m@@0) (=> (_module.__default.small__step_h $ly@@29 |_k#0@@19| |c#0@@23| |s#0@@29| |c'#0@@13| |s'#0@@14|) (_module.__default.small__step_h $ly@@29 _m@@0 |c#0@@23| |s#0@@29| |c'#0@@13| |s'#0@@14|)))
 :pattern ( (_module.__default.small__step_h $ly@@29 |_k#0@@19| |c#0@@23| |s#0@@29| |c'#0@@13| |s'#0@@14|) (|ORD#LessThanLimit| |_k#0@@19| _limit@@0) (|ORD#LessThanLimit| _m@@0 _limit@@0))
))))
(assert  (=> (<= 6 $FunctionContextHeight) (forall (($ly@@30 T@U) (|c#0@@24| T@U) (|s#0@@30| T@U) (|c'#0@@14| T@U) (|s'#0@@15| T@U) (|_k#0@@20| T@U) (_m@@1 T@U) (_limit@@1 T@U) ) (!  (=> (|ORD#Less| |_k#0@@20| _m@@1) (=> (_module.__default.small__step__star_h $ly@@30 |_k#0@@20| |c#0@@24| |s#0@@30| |c'#0@@14| |s'#0@@15|) (_module.__default.small__step__star_h $ly@@30 _m@@1 |c#0@@24| |s#0@@30| |c'#0@@14| |s'#0@@15|)))
 :pattern ( (_module.__default.small__step__star_h $ly@@30 |_k#0@@20| |c#0@@24| |s#0@@30| |c'#0@@14| |s'#0@@15|) (|ORD#LessThanLimit| |_k#0@@20| _limit@@1) (|ORD#LessThanLimit| _m@@1 _limit@@1))
))))
(assert (forall ((s@@2 T@U) (i@@3 Int) ) (!  (=> (and (<= 0 i@@3) (< i@@3 (|Seq#Length| s@@2))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@2 i@@3))) (|Seq#Rank| s@@2)))
 :pattern ( (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@2 i@@3))))
)))
(assert (forall ((v@@15 T@U) (t0@@7 T@U) (t1@@3 T@U) ) (!  (=> ($Is MapType v@@15 (TMap t0@@7 t1@@3)) (and (and ($Is SetType (|Map#Domain| v@@15) (TSet t0@@7)) ($Is SetType (|Map#Values| v@@15) (TSet t1@@3))) ($Is SetType (|Map#Items| v@@15) (TSet (Tclass._System.Tuple2 t0@@7 t1@@3)))))
 :pattern ( ($Is MapType v@@15 (TMap t0@@7 t1@@3)))
)))
(assert (forall ((v@@16 T@U) ) (! ($Is intType v@@16 TInt)
 :pattern ( ($Is intType v@@16 TInt))
)))
(assert (forall ((v@@17 T@U) ) (! ($Is boolType v@@17 TBool)
 :pattern ( ($Is boolType v@@17 TBool))
)))
(assert (forall ((v@@18 T@U) ) (! ($Is charType v@@18 TChar)
 :pattern ( ($Is charType v@@18 TChar))
)))
(assert (forall ((v@@19 T@U) ) (! ($Is BoxType v@@19 TORDINAL)
 :pattern ( ($Is BoxType v@@19 TORDINAL))
)))
(assert (forall ((|a#65#0#0| T@U) (|a#65#1#0| T@U) ) (! (= ($Is DatatypeTypeType (|#_module.com.Assign| |a#65#0#0| |a#65#1#0|) Tclass._module.com)  (and ($Is SeqType |a#65#0#0| (TSeq TChar)) ($Is DatatypeTypeType |a#65#1#0| Tclass._module.aexp)))
 :pattern ( ($Is DatatypeTypeType (|#_module.com.Assign| |a#65#0#0| |a#65#1#0|) Tclass._module.com))
)))
(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun |c#1| () T@U)
(declare-fun |s#1| () T@U)
(declare-fun |t#1| () T@U)
(declare-fun |_k#0@@21| () T@U)
(declare-fun |c'#0@0| () T@U)
(declare-fun $Heap@0 () T@U)
(declare-fun |s'#12@0| () T@U)
(declare-fun $Heap@2 () T@U)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun |c'#1@0| () T@U)
(declare-fun |s'#13@0| () T@U)
(declare-fun |##_k#0@0| () T@U)
(declare-fun |##c'#2@0| () T@U)
(declare-fun $Heap@1 () T@U)
(declare-fun $_ModifiesFrame@0 () T@U)
(declare-fun null () T@U)
(declare-fun $Heap () T@U)
(declare-fun |c'#0@@15| () T@U)
(declare-fun |s'#12@@0| () T@U)
(set-option :timeout 10000)
(set-option :rlimit 0)
(set-option :auto_config false)
(set-option :type_check true)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.delay_units true)
(set-option :model_evaluator.completion true)
(set-option :model.completion true)
(set-option :model.compact false)
(set-option :smt.case_split 3)
(set-option :smt.mbqi false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
(set-option :smt.arith.solver 2)
(assert (not
 (=> (= (ControlFlow 0 0) 32) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 2) (- 0 6)) (=> (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|) (or (_module.__default.big__step ($LS $LZ) |c#1| |s#1| |t#1|) (=> (_module.com.SKIP_q |c#1|) (|Map#Equal| |s#1| |t#1|))))) (=> (=> (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|) (or (_module.__default.big__step ($LS $LZ) |c#1| |s#1| |t#1|) (=> (_module.com.SKIP_q |c#1|) (|Map#Equal| |s#1| |t#1|)))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (=> (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|) (or (_module.__default.big__step ($LS $LZ) |c#1| |s#1| |t#1|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (_module.com.Assign_q |c#1|) (let ((|a#4@@1| (_module.com._h1 |c#1|)))
(let ((|x#4@@1| (_module.com._h0 |c#1|)))
(|Map#Equal| |t#1| (|Map#Build| |s#1| ($Box SeqType |x#4@@1|) ($Box intType (int_2_U (_module.__default.aval ($LS ($LS $LZ)) |a#4@@1| |s#1|)))))))))))) (=> (=> (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|) (or (_module.__default.big__step ($LS $LZ) |c#1| |s#1| |t#1|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (_module.com.Assign_q |c#1|) (let ((|a#4@@2| (_module.com._h1 |c#1|)))
(let ((|x#4@@2| (_module.com._h0 |c#1|)))
(|Map#Equal| |t#1| (|Map#Build| |s#1| ($Box SeqType |x#4@@2|) ($Box intType (int_2_U (_module.__default.aval ($LS ($LS $LZ)) |a#4@@2| |s#1|))))))))))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (=> (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|) (or (_module.__default.big__step ($LS $LZ) |c#1| |s#1| |t#1|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (_module.com.Seq_q |c#1|) (let ((|c1#4@@1| (_module.com._h3 |c#1|)))
(let ((|c0#4@@1| (_module.com._h2 |c#1|)))
(exists ((|s'#8@@0| T@U) ) (!  (and ($Is MapType |s'#8@@0| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step ($LS $LZ) |c0#4@@1| |s#1| |s'#8@@0|) (_module.__default.big__step ($LS $LZ) |c1#4@@1| |s'#8@@0| |t#1|)))
 :pattern ( (_module.__default.big__step ($LS $LZ) |c1#4@@1| |s'#8@@0| |t#1|))
 :pattern ( (_module.__default.big__step ($LS $LZ) |c0#4@@1| |s#1| |s'#8@@0|))
)))))))))) (=> (=> (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|) (or (_module.__default.big__step ($LS $LZ) |c#1| |s#1| |t#1|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (_module.com.Seq_q |c#1|) (let ((|c1#4@@2| (_module.com._h3 |c#1|)))
(let ((|c0#4@@2| (_module.com._h2 |c#1|)))
(exists ((|s'#8@@1| T@U) ) (!  (and ($Is MapType |s'#8@@1| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step ($LS $LZ) |c0#4@@2| |s#1| |s'#8@@1|) (_module.__default.big__step ($LS $LZ) |c1#4@@2| |s'#8@@1| |t#1|)))
 :pattern ( (_module.__default.big__step ($LS $LZ) |c1#4@@2| |s'#8@@1| |t#1|))
 :pattern ( (_module.__default.big__step ($LS $LZ) |c0#4@@2| |s#1| |s'#8@@1|))
))))))))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (=> (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|) (or (_module.__default.big__step ($LS $LZ) |c#1| |s#1| |t#1|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (_module.com.If_q |c#1|) (let ((|els#4@@1| (_module.com._h6 |c#1|)))
(let ((|thn#4@@1| (_module.com._h5 |c#1|)))
(let ((|b#8@@1| (_module.com._h4 |c#1|)))
(_module.__default.big__step ($LS ($LS $LZ)) (ite (_module.__default.bval ($LS ($LS $LZ)) |b#8@@1| |s#1|) |thn#4@@1| |els#4@@1|) |s#1| |t#1|))))))))))) (=> (=> (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|) (or (_module.__default.big__step ($LS $LZ) |c#1| |s#1| |t#1|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (_module.com.If_q |c#1|) (let ((|els#4@@2| (_module.com._h6 |c#1|)))
(let ((|thn#4@@2| (_module.com._h5 |c#1|)))
(let ((|b#8@@2| (_module.com._h4 |c#1|)))
(_module.__default.big__step ($LS ($LS $LZ)) (ite (_module.__default.bval ($LS ($LS $LZ)) |b#8@@2| |s#1|) |thn#4@@2| |els#4@@2|) |s#1| |t#1|)))))))))) (=> (= (ControlFlow 0 2) (- 0 1)) (=> (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|) (or (_module.__default.big__step ($LS $LZ) |c#1| |s#1| |t#1|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (not (_module.com.If_q |c#1|)) (let ((|body#4@@1| (_module.com._h8 |c#1|)))
(let ((|b#9@@1| (_module.com._h7 |c#1|)))
 (or (and (not (_module.__default.bval ($LS ($LS $LZ)) |b#9@@1| |s#1|)) (|Map#Equal| |s#1| |t#1|)) (and (_module.__default.bval ($LS ($LS $LZ)) |b#9@@1| |s#1|) (exists ((|s'#9@@0| T@U) ) (!  (and ($Is MapType |s'#9@@0| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step ($LS ($LS $LZ)) |body#4@@1| |s#1| |s'#9@@0|) (_module.__default.big__step ($LS ($LS $LZ)) (|#_module.com.While| |b#9@@1| |body#4@@1|) |s'#9@@0| |t#1|)))
 :pattern ( (_module.__default.big__step ($LS ($LS $LZ)) (|#_module.com.While| |b#9@@1| |body#4@@1|) |s'#9@@0| |t#1|))
 :pattern ( (_module.__default.big__step ($LS ($LS $LZ)) |body#4@@1| |s#1| |s'#9@@0|))
)))))))))))))))))))))))
(let ((anon9_correct  (and (=> (= (ControlFlow 0 9) (- 0 18)) (or (exists ((|$as#s'0_1_0#0| T@U) )  (and ($Is MapType |$as#s'0_1_0#0| (TMap (TSeq TChar) TInt)) (and ($Is DatatypeTypeType (Lit DatatypeTypeType |#_module.com.SKIP|) Tclass._module.com) (and (_module.__default.small__step ($LS $LZ) |c#1| |s#1| (Lit DatatypeTypeType |#_module.com.SKIP|) |$as#s'0_1_0#0|) (_module.__default.small__step__star_h ($LS $LZ) (|ORD#Minus| |_k#0@@21| (|ORD#FromNat| 1)) (Lit DatatypeTypeType |#_module.com.SKIP|) |$as#s'0_1_0#0| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|))))) (exists ((|$as#c'0_1_0#0| T@U) (|$as#s'0_1_0#0@@0| T@U) )  (and (and ($Is DatatypeTypeType |$as#c'0_1_0#0| Tclass._module.com) ($Is MapType |$as#s'0_1_0#0@@0| (TMap (TSeq TChar) TInt))) (and (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |$as#c'0_1_0#0| |$as#s'0_1_0#0@@0|) (_module.__default.small__step__star_h ($LS $LZ) (|ORD#Minus| |_k#0@@21| (|ORD#FromNat| 1)) |$as#c'0_1_0#0| |$as#s'0_1_0#0@@0| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|)))))) (=> (or (exists ((|$as#s'0_1_0#0@@1| T@U) )  (and ($Is MapType |$as#s'0_1_0#0@@1| (TMap (TSeq TChar) TInt)) (and ($Is DatatypeTypeType (Lit DatatypeTypeType |#_module.com.SKIP|) Tclass._module.com) (and (_module.__default.small__step ($LS $LZ) |c#1| |s#1| (Lit DatatypeTypeType |#_module.com.SKIP|) |$as#s'0_1_0#0@@1|) (_module.__default.small__step__star_h ($LS $LZ) (|ORD#Minus| |_k#0@@21| (|ORD#FromNat| 1)) (Lit DatatypeTypeType |#_module.com.SKIP|) |$as#s'0_1_0#0@@1| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|))))) (exists ((|$as#c'0_1_0#0@@0| T@U) (|$as#s'0_1_0#0@@2| T@U) )  (and (and ($Is DatatypeTypeType |$as#c'0_1_0#0@@0| Tclass._module.com) ($Is MapType |$as#s'0_1_0#0@@2| (TMap (TSeq TChar) TInt))) (and (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |$as#c'0_1_0#0@@0| |$as#s'0_1_0#0@@2|) (_module.__default.small__step__star_h ($LS $LZ) (|ORD#Minus| |_k#0@@21| (|ORD#FromNat| 1)) |$as#c'0_1_0#0@@0| |$as#s'0_1_0#0@@2| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|))))) (=> (and ($Is DatatypeTypeType |c'#0@0| Tclass._module.com) ($IsAlloc DatatypeTypeType |c'#0@0| Tclass._module.com $Heap@0)) (=> (and (and ($Is MapType |s'#12@0| (TMap (TSeq TChar) TInt)) ($IsAlloc MapType |s'#12@0| (TMap (TSeq TChar) TInt) $Heap@0)) (and (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (_module.__default.small__step__star_h ($LS $LZ) (|ORD#Minus| |_k#0@@21| (|ORD#FromNat| 1)) |c'#0@0| |s'#12@0| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|))) (and (=> (= (ControlFlow 0 9) (- 0 17)) (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (_module.com.SKIP_q |c#1|) (U_2_bool (Lit boolType (bool_2_U false))))))) (=> (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (_module.com.SKIP_q |c#1|) (U_2_bool (Lit boolType (bool_2_U false)))))) (and (=> (= (ControlFlow 0 9) (- 0 16)) (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (_module.com.Assign_q |c#1|) (|_module.com#Equal| |c'#0@0| |#_module.com.SKIP|)))))) (=> (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (_module.com.Assign_q |c#1|) (|_module.com#Equal| |c'#0@0| |#_module.com.SKIP|))))) (and (=> (= (ControlFlow 0 9) (- 0 15)) (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (_module.com.Assign_q |c#1|) (let ((|a#0@@4| (_module.com._h1 |c#1|)))
(let ((|x#0@@2| (_module.com._h0 |c#1|)))
(|Map#Equal| |s'#12@0| (|Map#Build| |s#1| ($Box SeqType |x#0@@2|) ($Box intType (int_2_U (_module.__default.aval ($LS ($LS $LZ)) |a#0@@4| |s#1|)))))))))))) (=> (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (_module.com.Assign_q |c#1|) (let ((|a#0@@5| (_module.com._h1 |c#1|)))
(let ((|x#0@@3| (_module.com._h0 |c#1|)))
(|Map#Equal| |s'#12@0| (|Map#Build| |s#1| ($Box SeqType |x#0@@3|) ($Box intType (int_2_U (_module.__default.aval ($LS ($LS $LZ)) |a#0@@5| |s#1|))))))))))) (and (=> (= (ControlFlow 0 9) (- 0 14)) (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (_module.com.Seq_q |c#1|) (let ((|c1#0@@1| (_module.com._h3 |c#1|)))
(let ((|c0#0@@1| (_module.com._h2 |c#1|)))
 (or (and (and (|_module.com#Equal| |c0#0@@1| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@0| |c1#0@@1|)) (|Map#Equal| |s'#12@0| |s#1|)) (exists ((|c0'#0@@0| T@U) ) (!  (and ($Is DatatypeTypeType |c0'#0@@0| Tclass._module.com) (and (|_module.com#Equal| |c'#0@0| (|#_module.com.Seq| |c0'#0@@0| |c1#0@@1|)) (_module.__default.small__step ($LS ($LS $LZ)) |c0#0@@1| |s#1| |c0'#0@@0| |s'#12@0|)))
 :pattern ( (_module.__default.small__step ($LS ($LS $LZ)) |c0#0@@1| |s#1| |c0'#0@@0| |s'#12@0|))
 :pattern ( (|#_module.com.Seq| |c0'#0@@0| |c1#0@@1|))
))))))))))) (=> (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (_module.com.Seq_q |c#1|) (let ((|c1#0@@2| (_module.com._h3 |c#1|)))
(let ((|c0#0@@2| (_module.com._h2 |c#1|)))
 (or (and (and (|_module.com#Equal| |c0#0@@2| |#_module.com.SKIP|) (|_module.com#Equal| |c'#0@0| |c1#0@@2|)) (|Map#Equal| |s'#12@0| |s#1|)) (exists ((|c0'#0@@1| T@U) ) (!  (and ($Is DatatypeTypeType |c0'#0@@1| Tclass._module.com) (and (|_module.com#Equal| |c'#0@0| (|#_module.com.Seq| |c0'#0@@1| |c1#0@@2|)) (_module.__default.small__step ($LS ($LS $LZ)) |c0#0@@2| |s#1| |c0'#0@@1| |s'#12@0|)))
 :pattern ( (_module.__default.small__step ($LS ($LS $LZ)) |c0#0@@2| |s#1| |c0'#0@@1| |s'#12@0|))
 :pattern ( (|#_module.com.Seq| |c0'#0@@1| |c1#0@@2|))
)))))))))) (and (=> (= (ControlFlow 0 9) (- 0 13)) (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (_module.com.If_q |c#1|) (let ((|els#0@@1| (_module.com._h6 |c#1|)))
(let ((|thn#0@@1| (_module.com._h5 |c#1|)))
(let ((|b#0@@4| (_module.com._h4 |c#1|)))
(|_module.com#Equal| |c'#0@0| (ite (_module.__default.bval ($LS ($LS $LZ)) |b#0@@4| |s#1|) |thn#0@@1| |els#0@@1|)))))))))))) (=> (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (_module.com.If_q |c#1|) (let ((|els#0@@2| (_module.com._h6 |c#1|)))
(let ((|thn#0@@2| (_module.com._h5 |c#1|)))
(let ((|b#0@@5| (_module.com._h4 |c#1|)))
(|_module.com#Equal| |c'#0@0| (ite (_module.__default.bval ($LS ($LS $LZ)) |b#0@@5| |s#1|) |thn#0@@2| |els#0@@2|))))))))))) (and (=> (= (ControlFlow 0 9) (- 0 12)) (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (_module.com.If_q |c#1|) (|Map#Equal| |s'#12@0| |s#1|)))))))) (=> (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (_module.com.If_q |c#1|) (|Map#Equal| |s'#12@0| |s#1|))))))) (and (=> (= (ControlFlow 0 9) (- 0 11)) (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (not (_module.com.If_q |c#1|)) (let ((|body#0@@1| (_module.com._h8 |c#1|)))
(let ((|b#1@@2| (_module.com._h7 |c#1|)))
(|_module.com#Equal| |c'#0@0| (|#_module.com.If| |b#1@@2| (|#_module.com.Seq| |body#0@@1| (|#_module.com.While| |b#1@@2| |body#0@@1|)) (Lit DatatypeTypeType |#_module.com.SKIP|)))))))))))) (=> (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (not (_module.com.If_q |c#1|)) (let ((|body#0@@2| (_module.com._h8 |c#1|)))
(let ((|b#1@@3| (_module.com._h7 |c#1|)))
(|_module.com#Equal| |c'#0@0| (|#_module.com.If| |b#1@@3| (|#_module.com.Seq| |body#0@@2| (|#_module.com.While| |b#1@@3| |body#0@@2|)) (Lit DatatypeTypeType |#_module.com.SKIP|))))))))))) (and (=> (= (ControlFlow 0 9) (- 0 10)) (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (not (_module.com.If_q |c#1|)) (|Map#Equal| |s'#12@0| |s#1|)))))))) (=> (=> (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#0@0| |s'#12@0|) (or (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#0@0| |s'#12@0|) (=> (not (_module.com.SKIP_q |c#1|)) (=> (not (_module.com.Assign_q |c#1|)) (=> (not (_module.com.Seq_q |c#1|)) (=> (not (_module.com.If_q |c#1|)) (|Map#Equal| |s'#12@0| |s#1|))))))) (=> (and ($IsGoodHeap $Heap@2) ($IsHeapAnchor $Heap@2)) (=> (and (and (and (|_module.__default.big__step#canCall| |c'#0@0| |s'#12@0| |t#1|) (=> (_module.__default.big__step ($LS $LZ) |c'#0@0| |s'#12@0| |t#1|) (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|))) (=> (_module.__default.big__step ($LS $LZ) |c'#0@0| |s'#12@0| |t#1|) (and (|_module.__default.big__step#canCall| |c#1| |s#1| |t#1|) (and (_module.__default.big__step ($LS $LZ) |c#1| |s#1| |t#1|) (ite (_module.com.SKIP_q |c#1|) (|Map#Equal| |s#1| |t#1|) (ite (_module.com.Assign_q |c#1|) (let ((|a#3@@1| (_module.com._h1 |c#1|)))
(let ((|x#3| (_module.com._h0 |c#1|)))
(|Map#Equal| |t#1| (|Map#Build| |s#1| ($Box SeqType |x#3|) ($Box intType (int_2_U (_module.__default.aval ($LS $LZ) |a#3@@1| |s#1|))))))) (ite (_module.com.Seq_q |c#1|) (let ((|c1#3@@1| (_module.com._h3 |c#1|)))
(let ((|c0#3@@1| (_module.com._h2 |c#1|)))
(exists ((|s'#3@@0| T@U) ) (!  (and ($Is MapType |s'#3@@0| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step ($LS $LZ) |c0#3@@1| |s#1| |s'#3@@0|) (_module.__default.big__step ($LS $LZ) |c1#3@@1| |s'#3@@0| |t#1|)))
 :pattern ( (_module.__default.big__step ($LS $LZ) |c1#3@@1| |s'#3@@0| |t#1|))
 :pattern ( (_module.__default.big__step ($LS $LZ) |c0#3@@1| |s#1| |s'#3@@0|))
)))) (ite (_module.com.If_q |c#1|) (let ((|els#3@@1| (_module.com._h6 |c#1|)))
(let ((|thn#3@@1| (_module.com._h5 |c#1|)))
(let ((|b#6@@1| (_module.com._h4 |c#1|)))
(_module.__default.big__step ($LS $LZ) (ite (_module.__default.bval ($LS $LZ) |b#6@@1| |s#1|) |thn#3@@1| |els#3@@1|) |s#1| |t#1|)))) (let ((|body#3@@0| (_module.com._h8 |c#1|)))
(let ((|b#7@@0| (_module.com._h7 |c#1|)))
 (or (and (not (_module.__default.bval ($LS $LZ) |b#7@@0| |s#1|)) (|Map#Equal| |s#1| |t#1|)) (and (_module.__default.bval ($LS $LZ) |b#7@@0| |s#1|) (exists ((|s'#4| T@U) ) (!  (and ($Is MapType |s'#4| (TMap (TSeq TChar) TInt)) (and (_module.__default.big__step ($LS $LZ) |body#3@@0| |s#1| |s'#4|) (_module.__default.big__step ($LS $LZ) (|#_module.com.While| |b#7@@0| |body#3@@0|) |s'#4| |t#1|)))
 :pattern ( (_module.__default.big__step ($LS $LZ) (|#_module.com.While| |b#7@@0| |body#3@@0|) |s'#4| |t#1|))
 :pattern ( (_module.__default.big__step ($LS $LZ) |body#3@@0| |s#1| |s'#4|))
)))))))))))))) (and (= $Heap@0 $Heap@2) (= (ControlFlow 0 9) 2))) GeneratedUnifiedExit_correct))))))))))))))))))))))))
(let ((anon8_correct  (=> (and (and (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#1@0| |s'#13@0|) (=> (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#1@0| |s'#13@0|) (|_module.__default.small__step__star_h#canCall| (|ORD#Minus| |_k#0@@21| (|ORD#FromNat| 1)) |c'#1@0| |s'#13@0| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|))) (= (ControlFlow 0 20) 9)) anon9_correct)))
(let ((anon15_Else_correct  (=> (and (not (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#1@0| |s'#13@0|)) (= (ControlFlow 0 24) 20)) anon8_correct)))
(let ((anon15_Then_correct  (=> (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c'#1@0| |s'#13@0|) (and (=> (= (ControlFlow 0 21) (- 0 23)) (|ORD#IsNat| (Lit BoxType (|ORD#FromNat| 1)))) (=> (|ORD#IsNat| (Lit BoxType (|ORD#FromNat| 1))) (and (=> (= (ControlFlow 0 21) (- 0 22)) (<= (|ORD#Offset| (Lit BoxType (|ORD#FromNat| 1))) (|ORD#Offset| |_k#0@@21|))) (=> (<= (|ORD#Offset| (Lit BoxType (|ORD#FromNat| 1))) (|ORD#Offset| |_k#0@@21|)) (=> (= |##_k#0@0| (|ORD#Minus| |_k#0@@21| (|ORD#FromNat| 1))) (=> (and (and (and ($IsAlloc BoxType |##_k#0@0| TORDINAL $Heap@0) ($IsAlloc DatatypeTypeType |c'#1@0| Tclass._module.com $Heap@0)) (and ($IsAlloc MapType |s'#13@0| (TMap (TSeq TChar) TInt) $Heap@0) (= |##c'#2@0| (Lit DatatypeTypeType |#_module.com.SKIP|)))) (and (and ($IsAlloc DatatypeTypeType |##c'#2@0| Tclass._module.com $Heap@0) ($IsAlloc MapType |t#1| (TMap (TSeq TChar) TInt) $Heap@0)) (and (|_module.__default.small__step__star_h#canCall| (|ORD#Minus| |_k#0@@21| (|ORD#FromNat| 1)) |c'#1@0| |s'#13@0| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|) (= (ControlFlow 0 21) 20)))) anon8_correct)))))))))
(let ((anon14_Then_correct  (=> (and (and (and (and ($Is DatatypeTypeType |c'#1@0| Tclass._module.com) ($IsAlloc DatatypeTypeType |c'#1@0| Tclass._module.com $Heap@0)) (and ($Is MapType |s'#13@0| (TMap (TSeq TChar) TInt)) ($IsAlloc MapType |s'#13@0| (TMap (TSeq TChar) TInt) $Heap@0))) ($IsAlloc DatatypeTypeType |c#1| Tclass._module.com $Heap@0)) (and (and ($IsAlloc MapType |s#1| (TMap (TSeq TChar) TInt) $Heap@0) ($IsAlloc DatatypeTypeType |c'#1@0| Tclass._module.com $Heap@0)) (and ($IsAlloc MapType |s'#13@0| (TMap (TSeq TChar) TInt) $Heap@0) (|_module.__default.small__step#canCall| |c#1| |s#1| |c'#1@0| |s'#13@0|)))) (and (=> (= (ControlFlow 0 25) 21) anon15_Then_correct) (=> (= (ControlFlow 0 25) 24) anon15_Else_correct)))))
(let ((anon14_Else_correct  (=> (and (not (and (and ($Is DatatypeTypeType |c'#1@0| Tclass._module.com) ($IsAlloc DatatypeTypeType |c'#1@0| Tclass._module.com $Heap@0)) (and ($Is MapType |s'#13@0| (TMap (TSeq TChar) TInt)) ($IsAlloc MapType |s'#13@0| (TMap (TSeq TChar) TInt) $Heap@0)))) (= (ControlFlow 0 19) 9)) anon9_correct)))
(let ((anon13_Else_correct  (=> (not (and (|_module.com#Equal| |c#1| |#_module.com.SKIP|) (|Map#Equal| |s#1| |t#1|))) (and (=> (= (ControlFlow 0 26) 25) anon14_Then_correct) (=> (= (ControlFlow 0 26) 19) anon14_Else_correct)))))
(let ((anon13_Then_correct  (=> (and (and (|_module.com#Equal| |c#1| |#_module.com.SKIP|) (|Map#Equal| |s#1| |t#1|)) (= (ControlFlow 0 8) 2)) GeneratedUnifiedExit_correct)))
(let ((anon3_correct  (=> (|$IsA#_module.com| |c#1|) (and (=> (= (ControlFlow 0 27) 8) anon13_Then_correct) (=> (= (ControlFlow 0 27) 26) anon13_Else_correct)))))
(let ((anon12_Else_correct  (=> (and (not (|_module.com#Equal| |c#1| |#_module.com.SKIP|)) (= (ControlFlow 0 29) 27)) anon3_correct)))
(let ((anon12_Then_correct  (=> (and (|_module.com#Equal| |c#1| |#_module.com.SKIP|) (= (ControlFlow 0 28) 27)) anon3_correct)))
(let ((anon11_Then_correct  (=> (< 0 (|ORD#Offset| |_k#0@@21|)) (and (=> (= (ControlFlow 0 30) 28) anon12_Then_correct) (=> (= (ControlFlow 0 30) 29) anon12_Else_correct)))))
(let ((anon11_Else_correct  (=> (<= (|ORD#Offset| |_k#0@@21|) 0) (=> (and (and (and ($IsGoodHeap $Heap@1) ($IsHeapAnchor $Heap@1)) (= $Heap@0 $Heap@1)) (and (forall ((|_k'#2@@5| T@U) (|c#2| T@U) (|s#2| T@U) (|t#2| T@U) ) (!  (=> (and (and (and ($Is DatatypeTypeType |c#2| Tclass._module.com) ($Is MapType |s#2| (TMap (TSeq TChar) TInt))) ($Is MapType |t#2| (TMap (TSeq TChar) TInt))) (and (|ORD#Less| |_k'#2@@5| |_k#0@@21|) (_module.__default.small__step__star_h ($LS $LZ) |_k'#2@@5| |c#2| |s#2| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#2|))) (_module.__default.big__step ($LS $LZ) |c#2| |s#2| |t#2|))
 :pattern ( (_module.__default.big__step ($LS $LZ) |c#2| |s#2| |t#2|) (|ORD#Less| |_k'#2@@5| |_k#0@@21|))
 :pattern ( (_module.__default.small__step__star_h ($LS $LZ) |_k'#2@@5| |c#2| |s#2| |#_module.com.SKIP| |t#2|))
)) (= (ControlFlow 0 7) 2))) GeneratedUnifiedExit_correct))))
(let ((anon0_correct  (=> (and (= $_ModifiesFrame@0 (|lambda#0| null $Heap alloc false)) (|$IsA#_module.com| |c#1|)) (=> (and (and ($IsGoodHeap $Heap@0) ($IsHeapAnchor $Heap@0)) (and (= $Heap $Heap@0) (forall ((|$ih#_k0#0| T@U) (|$ih#c0#0| T@U) (|$ih#s0#0| T@U) (|$ih#t0#0| T@U) ) (!  (=> (and (and (and (and ($Is DatatypeTypeType |$ih#c0#0| Tclass._module.com) ($Is MapType |$ih#s0#0| (TMap (TSeq TChar) TInt))) ($Is MapType |$ih#t0#0| (TMap (TSeq TChar) TInt))) (_module.__default.small__step__star_h ($LS $LZ) |$ih#_k0#0| |$ih#c0#0| |$ih#s0#0| (Lit DatatypeTypeType |#_module.com.SKIP|) |$ih#t0#0|)) (or (|ORD#Less| |$ih#_k0#0| |_k#0@@21|) (and (= |$ih#_k0#0| |_k#0@@21|) (or (< (DtRank |$ih#c0#0|) (DtRank |c#1|)) (and (= (DtRank |$ih#c0#0|) (DtRank |c#1|)) (or (and (|Set#Subset| (|Map#Domain| |$ih#s0#0|) (|Map#Domain| |s#1|)) (not (|Set#Subset| (|Map#Domain| |s#1|) (|Map#Domain| |$ih#s0#0|)))) (and (|Set#Equal| (|Map#Domain| |$ih#s0#0|) (|Map#Domain| |s#1|)) (and (|Set#Subset| (|Map#Domain| |$ih#t0#0|) (|Map#Domain| |t#1|)) (not (|Set#Subset| (|Map#Domain| |t#1|) (|Map#Domain| |$ih#t0#0|))))))))))) (_module.__default.big__step ($LS $LZ) |$ih#c0#0| |$ih#s0#0| |$ih#t0#0|))
 :pattern ( (_module.__default.small__step__star_h ($LS $LZ) |$ih#_k0#0| |$ih#c0#0| |$ih#s0#0| (Lit DatatypeTypeType |#_module.com.SKIP|) |$ih#t0#0|))
)))) (and (=> (= (ControlFlow 0 31) 30) anon11_Then_correct) (=> (= (ControlFlow 0 31) 7) anon11_Else_correct))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and ($IsGoodHeap $Heap) ($IsHeapAnchor $Heap)) (=> (and (and ($Is DatatypeTypeType |c#1| Tclass._module.com) ($IsAlloc DatatypeTypeType |c#1| Tclass._module.com $Heap)) (|$IsA#_module.com| |c#1|)) (=> (and (and (and ($Is MapType |s#1| (TMap (TSeq TChar) TInt)) ($IsAlloc MapType |s#1| (TMap (TSeq TChar) TInt) $Heap)) (and ($Is MapType |t#1| (TMap (TSeq TChar) TInt)) ($IsAlloc MapType |t#1| (TMap (TSeq TChar) TInt) $Heap))) (and (and ($Is DatatypeTypeType |c'#0@@15| Tclass._module.com) ($IsAlloc DatatypeTypeType |c'#0@@15| Tclass._module.com $Heap)) true)) (=> (and (and (and (and ($Is MapType |s'#12@@0| (TMap (TSeq TChar) TInt)) ($IsAlloc MapType |s'#12@@0| (TMap (TSeq TChar) TInt) $Heap)) true) (= 7 $FunctionContextHeight)) (and (and (|_module.__default.small__step__star_h#canCall| |_k#0@@21| |c#1| |s#1| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|) (and (_module.__default.small__step__star_h ($LS $LZ) |_k#0@@21| |c#1| |s#1| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|) (and (=> (< 0 (|ORD#Offset| |_k#0@@21|)) (or (and (|_module.com#Equal| |c#1| |#_module.com.SKIP|) (|Map#Equal| |s#1| |t#1|)) (exists ((|c''#2| T@U) (|s''#2| T@U) ) (!  (and (and ($Is DatatypeTypeType |c''#2| Tclass._module.com) ($Is MapType |s''#2| (TMap (TSeq TChar) TInt))) (and (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c''#2| |s''#2|) (_module.__default.small__step__star_h ($LS $LZ) (|ORD#Minus| |_k#0@@21| (|ORD#FromNat| 1)) |c''#2| |s''#2| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|)))
 :pattern ( (_module.__default.small__step__star_h ($LS $LZ) (|ORD#Minus| |_k#0@@21| (|ORD#FromNat| 1)) |c''#2| |s''#2| |#_module.com.SKIP| |t#1|))
 :pattern ( (_module.__default.small__step ($LS $LZ) |c#1| |s#1| |c''#2| |s''#2|))
)))) (=> (= (LitInt 0) (|ORD#Offset| |_k#0@@21|)) (exists ((|_k'#1@@5| T@U) ) (!  (and (|ORD#LessThanLimit| |_k'#1@@5| |_k#0@@21|) (_module.__default.small__step__star_h ($LS $LZ) |_k'#1@@5| |c#1| |s#1| (Lit DatatypeTypeType |#_module.com.SKIP|) |t#1|))
 :pattern ( (_module.__default.small__step__star_h ($LS $LZ) |_k'#1@@5| |c#1| |s#1| |#_module.com.SKIP| |t#1|))
)))))) (= (ControlFlow 0 32) 31))) anon0_correct))))))
PreconditionGeneratedEntry_correct)))))))))))))))))
))
(check-sat)
(get-info :rlimit)
(pop 1)
; Valid
(reset)
(set-option :rlimit 0)
; did a full reset
(reset)
