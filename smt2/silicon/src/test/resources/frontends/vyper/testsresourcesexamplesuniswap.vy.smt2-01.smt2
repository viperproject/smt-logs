(get-info :version)
; (:version "4.12.1")
; Started: 2025-01-04 00:22:13
; Silicon.version: 1.1-SNAPSHOT (457c6eca@(detached))
; Input file: <unknown>
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Necessary for push pop mode
(set-option :auto_config false)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :type_check true)
(set-option :smt.mbqi false)
(set-option :pp.bv_literals false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.arith.solver 2)
(set-option :model.v2 true)
(set-option :smt.qi.max_multi_patterns 1000)
; 
; ; /preamble.smt2
(declare-datatypes (($Snap 0)) ((
    ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM 0)
(declare-sort $PPM 0)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<Int> 0)
(declare-sort Set<$Ref> 0)
(declare-sort Set<$Snap> 0)
(declare-sort $StructOps<$Map<Int~_$Map<Int~_Int>>> 0)
(declare-sort s$struct$self 0)
(declare-sort $Struct 0)
(declare-sort s$resource$$creator 0)
(declare-sort $Contract 0)
(declare-sort $Convert 0)
(declare-sort $StructOps<Seq<Int>> 0)
(declare-sort $Range 0)
(declare-sort $Int 0)
(declare-sort $StructOps<$Map<Int~_Int>> 0)
(declare-sort $Math 0)
(declare-sort $StructOps<Int> 0)
(declare-sort s$struct$EtherTokenPair 0)
(declare-sort $Map<Int~_$Struct> 0)
(declare-sort $StructOps<Bool> 0)
(declare-sort $Blockchain 0)
(declare-sort $Array<Int> 0)
(declare-sort $MapInt<Int> 0)
(declare-sort $Map<Int~_Int> 0)
(declare-sort $Map<Int~_$Map<Int~_Int>> 0)
(declare-sort $StructOps<$Struct> 0)
(declare-sort $PSF<e$TokenPurchase> 0)
(declare-sort $PSF<e$EthPurchase> 0)
(declare-sort $PSF<e$AddLiquidity> 0)
(declare-sort $PSF<e$RemoveLiquidity> 0)
(declare-sort $PSF<e$Transfer> 0)
(declare-sort $PSF<e$Approval> 0)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$StructOps<$Map<Int~_$Map<Int~_Int>>>To$Snap ($StructOps<$Map<Int~_$Map<Int~_Int>>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$StructOps<$Map<Int~_$Map<Int~_Int>>> ($Snap) $StructOps<$Map<Int~_$Map<Int~_Int>>>)
(assert (forall ((x $StructOps<$Map<Int~_$Map<Int~_Int>>>)) (!
    (= x ($SortWrappers.$SnapTo$StructOps<$Map<Int~_$Map<Int~_Int>>>($SortWrappers.$StructOps<$Map<Int~_$Map<Int~_Int>>>To$Snap x)))
    :pattern (($SortWrappers.$StructOps<$Map<Int~_$Map<Int~_Int>>>To$Snap x))
    :qid |$Snap.$SnapTo$StructOps<$Map<Int~_$Map<Int~_Int>>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$StructOps<$Map<Int~_$Map<Int~_Int>>>To$Snap($SortWrappers.$SnapTo$StructOps<$Map<Int~_$Map<Int~_Int>>> x)))
    :pattern (($SortWrappers.$SnapTo$StructOps<$Map<Int~_$Map<Int~_Int>>> x))
    :qid |$Snap.$StructOps<$Map<Int~_$Map<Int~_Int>>>To$SnapTo$StructOps<$Map<Int~_$Map<Int~_Int>>>|
    )))
(declare-fun $SortWrappers.s$struct$selfTo$Snap (s$struct$self) $Snap)
(declare-fun $SortWrappers.$SnapTos$struct$self ($Snap) s$struct$self)
(assert (forall ((x s$struct$self)) (!
    (= x ($SortWrappers.$SnapTos$struct$self($SortWrappers.s$struct$selfTo$Snap x)))
    :pattern (($SortWrappers.s$struct$selfTo$Snap x))
    :qid |$Snap.$SnapTos$struct$selfTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.s$struct$selfTo$Snap($SortWrappers.$SnapTos$struct$self x)))
    :pattern (($SortWrappers.$SnapTos$struct$self x))
    :qid |$Snap.s$struct$selfTo$SnapTos$struct$self|
    )))
(declare-fun $SortWrappers.$StructTo$Snap ($Struct) $Snap)
(declare-fun $SortWrappers.$SnapTo$Struct ($Snap) $Struct)
(assert (forall ((x $Struct)) (!
    (= x ($SortWrappers.$SnapTo$Struct($SortWrappers.$StructTo$Snap x)))
    :pattern (($SortWrappers.$StructTo$Snap x))
    :qid |$Snap.$SnapTo$StructTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$StructTo$Snap($SortWrappers.$SnapTo$Struct x)))
    :pattern (($SortWrappers.$SnapTo$Struct x))
    :qid |$Snap.$StructTo$SnapTo$Struct|
    )))
(declare-fun $SortWrappers.s$resource$$creatorTo$Snap (s$resource$$creator) $Snap)
(declare-fun $SortWrappers.$SnapTos$resource$$creator ($Snap) s$resource$$creator)
(assert (forall ((x s$resource$$creator)) (!
    (= x ($SortWrappers.$SnapTos$resource$$creator($SortWrappers.s$resource$$creatorTo$Snap x)))
    :pattern (($SortWrappers.s$resource$$creatorTo$Snap x))
    :qid |$Snap.$SnapTos$resource$$creatorTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.s$resource$$creatorTo$Snap($SortWrappers.$SnapTos$resource$$creator x)))
    :pattern (($SortWrappers.$SnapTos$resource$$creator x))
    :qid |$Snap.s$resource$$creatorTo$SnapTos$resource$$creator|
    )))
(declare-fun $SortWrappers.$ContractTo$Snap ($Contract) $Snap)
(declare-fun $SortWrappers.$SnapTo$Contract ($Snap) $Contract)
(assert (forall ((x $Contract)) (!
    (= x ($SortWrappers.$SnapTo$Contract($SortWrappers.$ContractTo$Snap x)))
    :pattern (($SortWrappers.$ContractTo$Snap x))
    :qid |$Snap.$SnapTo$ContractTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$ContractTo$Snap($SortWrappers.$SnapTo$Contract x)))
    :pattern (($SortWrappers.$SnapTo$Contract x))
    :qid |$Snap.$ContractTo$SnapTo$Contract|
    )))
(declare-fun $SortWrappers.$ConvertTo$Snap ($Convert) $Snap)
(declare-fun $SortWrappers.$SnapTo$Convert ($Snap) $Convert)
(assert (forall ((x $Convert)) (!
    (= x ($SortWrappers.$SnapTo$Convert($SortWrappers.$ConvertTo$Snap x)))
    :pattern (($SortWrappers.$ConvertTo$Snap x))
    :qid |$Snap.$SnapTo$ConvertTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$ConvertTo$Snap($SortWrappers.$SnapTo$Convert x)))
    :pattern (($SortWrappers.$SnapTo$Convert x))
    :qid |$Snap.$ConvertTo$SnapTo$Convert|
    )))
(declare-fun $SortWrappers.$StructOps<Seq<Int>>To$Snap ($StructOps<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$StructOps<Seq<Int>> ($Snap) $StructOps<Seq<Int>>)
(assert (forall ((x $StructOps<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapTo$StructOps<Seq<Int>>($SortWrappers.$StructOps<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.$StructOps<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapTo$StructOps<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$StructOps<Seq<Int>>To$Snap($SortWrappers.$SnapTo$StructOps<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapTo$StructOps<Seq<Int>> x))
    :qid |$Snap.$StructOps<Seq<Int>>To$SnapTo$StructOps<Seq<Int>>|
    )))
(declare-fun $SortWrappers.$RangeTo$Snap ($Range) $Snap)
(declare-fun $SortWrappers.$SnapTo$Range ($Snap) $Range)
(assert (forall ((x $Range)) (!
    (= x ($SortWrappers.$SnapTo$Range($SortWrappers.$RangeTo$Snap x)))
    :pattern (($SortWrappers.$RangeTo$Snap x))
    :qid |$Snap.$SnapTo$RangeTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RangeTo$Snap($SortWrappers.$SnapTo$Range x)))
    :pattern (($SortWrappers.$SnapTo$Range x))
    :qid |$Snap.$RangeTo$SnapTo$Range|
    )))
(declare-fun $SortWrappers.$IntTo$Snap ($Int) $Snap)
(declare-fun $SortWrappers.$SnapTo$Int ($Snap) $Int)
(assert (forall ((x $Int)) (!
    (= x ($SortWrappers.$SnapTo$Int($SortWrappers.$IntTo$Snap x)))
    :pattern (($SortWrappers.$IntTo$Snap x))
    :qid |$Snap.$SnapTo$IntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$IntTo$Snap($SortWrappers.$SnapTo$Int x)))
    :pattern (($SortWrappers.$SnapTo$Int x))
    :qid |$Snap.$IntTo$SnapTo$Int|
    )))
(declare-fun $SortWrappers.$StructOps<$Map<Int~_Int>>To$Snap ($StructOps<$Map<Int~_Int>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$StructOps<$Map<Int~_Int>> ($Snap) $StructOps<$Map<Int~_Int>>)
(assert (forall ((x $StructOps<$Map<Int~_Int>>)) (!
    (= x ($SortWrappers.$SnapTo$StructOps<$Map<Int~_Int>>($SortWrappers.$StructOps<$Map<Int~_Int>>To$Snap x)))
    :pattern (($SortWrappers.$StructOps<$Map<Int~_Int>>To$Snap x))
    :qid |$Snap.$SnapTo$StructOps<$Map<Int~_Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$StructOps<$Map<Int~_Int>>To$Snap($SortWrappers.$SnapTo$StructOps<$Map<Int~_Int>> x)))
    :pattern (($SortWrappers.$SnapTo$StructOps<$Map<Int~_Int>> x))
    :qid |$Snap.$StructOps<$Map<Int~_Int>>To$SnapTo$StructOps<$Map<Int~_Int>>|
    )))
(declare-fun $SortWrappers.$MathTo$Snap ($Math) $Snap)
(declare-fun $SortWrappers.$SnapTo$Math ($Snap) $Math)
(assert (forall ((x $Math)) (!
    (= x ($SortWrappers.$SnapTo$Math($SortWrappers.$MathTo$Snap x)))
    :pattern (($SortWrappers.$MathTo$Snap x))
    :qid |$Snap.$SnapTo$MathTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$MathTo$Snap($SortWrappers.$SnapTo$Math x)))
    :pattern (($SortWrappers.$SnapTo$Math x))
    :qid |$Snap.$MathTo$SnapTo$Math|
    )))
(declare-fun $SortWrappers.$StructOps<Int>To$Snap ($StructOps<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$StructOps<Int> ($Snap) $StructOps<Int>)
(assert (forall ((x $StructOps<Int>)) (!
    (= x ($SortWrappers.$SnapTo$StructOps<Int>($SortWrappers.$StructOps<Int>To$Snap x)))
    :pattern (($SortWrappers.$StructOps<Int>To$Snap x))
    :qid |$Snap.$SnapTo$StructOps<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$StructOps<Int>To$Snap($SortWrappers.$SnapTo$StructOps<Int> x)))
    :pattern (($SortWrappers.$SnapTo$StructOps<Int> x))
    :qid |$Snap.$StructOps<Int>To$SnapTo$StructOps<Int>|
    )))
(declare-fun $SortWrappers.s$struct$EtherTokenPairTo$Snap (s$struct$EtherTokenPair) $Snap)
(declare-fun $SortWrappers.$SnapTos$struct$EtherTokenPair ($Snap) s$struct$EtherTokenPair)
(assert (forall ((x s$struct$EtherTokenPair)) (!
    (= x ($SortWrappers.$SnapTos$struct$EtherTokenPair($SortWrappers.s$struct$EtherTokenPairTo$Snap x)))
    :pattern (($SortWrappers.s$struct$EtherTokenPairTo$Snap x))
    :qid |$Snap.$SnapTos$struct$EtherTokenPairTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.s$struct$EtherTokenPairTo$Snap($SortWrappers.$SnapTos$struct$EtherTokenPair x)))
    :pattern (($SortWrappers.$SnapTos$struct$EtherTokenPair x))
    :qid |$Snap.s$struct$EtherTokenPairTo$SnapTos$struct$EtherTokenPair|
    )))
(declare-fun $SortWrappers.$Map<Int~_$Struct>To$Snap ($Map<Int~_$Struct>) $Snap)
(declare-fun $SortWrappers.$SnapTo$Map<Int~_$Struct> ($Snap) $Map<Int~_$Struct>)
(assert (forall ((x $Map<Int~_$Struct>)) (!
    (= x ($SortWrappers.$SnapTo$Map<Int~_$Struct>($SortWrappers.$Map<Int~_$Struct>To$Snap x)))
    :pattern (($SortWrappers.$Map<Int~_$Struct>To$Snap x))
    :qid |$Snap.$SnapTo$Map<Int~_$Struct>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$Map<Int~_$Struct>To$Snap($SortWrappers.$SnapTo$Map<Int~_$Struct> x)))
    :pattern (($SortWrappers.$SnapTo$Map<Int~_$Struct> x))
    :qid |$Snap.$Map<Int~_$Struct>To$SnapTo$Map<Int~_$Struct>|
    )))
(declare-fun $SortWrappers.$StructOps<Bool>To$Snap ($StructOps<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapTo$StructOps<Bool> ($Snap) $StructOps<Bool>)
(assert (forall ((x $StructOps<Bool>)) (!
    (= x ($SortWrappers.$SnapTo$StructOps<Bool>($SortWrappers.$StructOps<Bool>To$Snap x)))
    :pattern (($SortWrappers.$StructOps<Bool>To$Snap x))
    :qid |$Snap.$SnapTo$StructOps<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$StructOps<Bool>To$Snap($SortWrappers.$SnapTo$StructOps<Bool> x)))
    :pattern (($SortWrappers.$SnapTo$StructOps<Bool> x))
    :qid |$Snap.$StructOps<Bool>To$SnapTo$StructOps<Bool>|
    )))
(declare-fun $SortWrappers.$BlockchainTo$Snap ($Blockchain) $Snap)
(declare-fun $SortWrappers.$SnapTo$Blockchain ($Snap) $Blockchain)
(assert (forall ((x $Blockchain)) (!
    (= x ($SortWrappers.$SnapTo$Blockchain($SortWrappers.$BlockchainTo$Snap x)))
    :pattern (($SortWrappers.$BlockchainTo$Snap x))
    :qid |$Snap.$SnapTo$BlockchainTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$BlockchainTo$Snap($SortWrappers.$SnapTo$Blockchain x)))
    :pattern (($SortWrappers.$SnapTo$Blockchain x))
    :qid |$Snap.$BlockchainTo$SnapTo$Blockchain|
    )))
(declare-fun $SortWrappers.$Array<Int>To$Snap ($Array<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$Array<Int> ($Snap) $Array<Int>)
(assert (forall ((x $Array<Int>)) (!
    (= x ($SortWrappers.$SnapTo$Array<Int>($SortWrappers.$Array<Int>To$Snap x)))
    :pattern (($SortWrappers.$Array<Int>To$Snap x))
    :qid |$Snap.$SnapTo$Array<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$Array<Int>To$Snap($SortWrappers.$SnapTo$Array<Int> x)))
    :pattern (($SortWrappers.$SnapTo$Array<Int> x))
    :qid |$Snap.$Array<Int>To$SnapTo$Array<Int>|
    )))
(declare-fun $SortWrappers.$MapInt<Int>To$Snap ($MapInt<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$MapInt<Int> ($Snap) $MapInt<Int>)
(assert (forall ((x $MapInt<Int>)) (!
    (= x ($SortWrappers.$SnapTo$MapInt<Int>($SortWrappers.$MapInt<Int>To$Snap x)))
    :pattern (($SortWrappers.$MapInt<Int>To$Snap x))
    :qid |$Snap.$SnapTo$MapInt<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$MapInt<Int>To$Snap($SortWrappers.$SnapTo$MapInt<Int> x)))
    :pattern (($SortWrappers.$SnapTo$MapInt<Int> x))
    :qid |$Snap.$MapInt<Int>To$SnapTo$MapInt<Int>|
    )))
(declare-fun $SortWrappers.$Map<Int~_Int>To$Snap ($Map<Int~_Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$Map<Int~_Int> ($Snap) $Map<Int~_Int>)
(assert (forall ((x $Map<Int~_Int>)) (!
    (= x ($SortWrappers.$SnapTo$Map<Int~_Int>($SortWrappers.$Map<Int~_Int>To$Snap x)))
    :pattern (($SortWrappers.$Map<Int~_Int>To$Snap x))
    :qid |$Snap.$SnapTo$Map<Int~_Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$Map<Int~_Int>To$Snap($SortWrappers.$SnapTo$Map<Int~_Int> x)))
    :pattern (($SortWrappers.$SnapTo$Map<Int~_Int> x))
    :qid |$Snap.$Map<Int~_Int>To$SnapTo$Map<Int~_Int>|
    )))
(declare-fun $SortWrappers.$Map<Int~_$Map<Int~_Int>>To$Snap ($Map<Int~_$Map<Int~_Int>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$Map<Int~_$Map<Int~_Int>> ($Snap) $Map<Int~_$Map<Int~_Int>>)
(assert (forall ((x $Map<Int~_$Map<Int~_Int>>)) (!
    (= x ($SortWrappers.$SnapTo$Map<Int~_$Map<Int~_Int>>($SortWrappers.$Map<Int~_$Map<Int~_Int>>To$Snap x)))
    :pattern (($SortWrappers.$Map<Int~_$Map<Int~_Int>>To$Snap x))
    :qid |$Snap.$SnapTo$Map<Int~_$Map<Int~_Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$Map<Int~_$Map<Int~_Int>>To$Snap($SortWrappers.$SnapTo$Map<Int~_$Map<Int~_Int>> x)))
    :pattern (($SortWrappers.$SnapTo$Map<Int~_$Map<Int~_Int>> x))
    :qid |$Snap.$Map<Int~_$Map<Int~_Int>>To$SnapTo$Map<Int~_$Map<Int~_Int>>|
    )))
(declare-fun $SortWrappers.$StructOps<$Struct>To$Snap ($StructOps<$Struct>) $Snap)
(declare-fun $SortWrappers.$SnapTo$StructOps<$Struct> ($Snap) $StructOps<$Struct>)
(assert (forall ((x $StructOps<$Struct>)) (!
    (= x ($SortWrappers.$SnapTo$StructOps<$Struct>($SortWrappers.$StructOps<$Struct>To$Snap x)))
    :pattern (($SortWrappers.$StructOps<$Struct>To$Snap x))
    :qid |$Snap.$SnapTo$StructOps<$Struct>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$StructOps<$Struct>To$Snap($SortWrappers.$SnapTo$StructOps<$Struct> x)))
    :pattern (($SortWrappers.$SnapTo$StructOps<$Struct> x))
    :qid |$Snap.$StructOps<$Struct>To$SnapTo$StructOps<$Struct>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$PSF<e$TokenPurchase>To$Snap ($PSF<e$TokenPurchase>) $Snap)
(declare-fun $SortWrappers.$SnapTo$PSF<e$TokenPurchase> ($Snap) $PSF<e$TokenPurchase>)
(assert (forall ((x $PSF<e$TokenPurchase>)) (!
    (= x ($SortWrappers.$SnapTo$PSF<e$TokenPurchase>($SortWrappers.$PSF<e$TokenPurchase>To$Snap x)))
    :pattern (($SortWrappers.$PSF<e$TokenPurchase>To$Snap x))
    :qid |$Snap.$SnapTo$PSF<e$TokenPurchase>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PSF<e$TokenPurchase>To$Snap($SortWrappers.$SnapTo$PSF<e$TokenPurchase> x)))
    :pattern (($SortWrappers.$SnapTo$PSF<e$TokenPurchase> x))
    :qid |$Snap.$PSF<e$TokenPurchase>To$SnapTo$PSF<e$TokenPurchase>|
    )))
(declare-fun $SortWrappers.$PSF<e$EthPurchase>To$Snap ($PSF<e$EthPurchase>) $Snap)
(declare-fun $SortWrappers.$SnapTo$PSF<e$EthPurchase> ($Snap) $PSF<e$EthPurchase>)
(assert (forall ((x $PSF<e$EthPurchase>)) (!
    (= x ($SortWrappers.$SnapTo$PSF<e$EthPurchase>($SortWrappers.$PSF<e$EthPurchase>To$Snap x)))
    :pattern (($SortWrappers.$PSF<e$EthPurchase>To$Snap x))
    :qid |$Snap.$SnapTo$PSF<e$EthPurchase>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PSF<e$EthPurchase>To$Snap($SortWrappers.$SnapTo$PSF<e$EthPurchase> x)))
    :pattern (($SortWrappers.$SnapTo$PSF<e$EthPurchase> x))
    :qid |$Snap.$PSF<e$EthPurchase>To$SnapTo$PSF<e$EthPurchase>|
    )))
(declare-fun $SortWrappers.$PSF<e$AddLiquidity>To$Snap ($PSF<e$AddLiquidity>) $Snap)
(declare-fun $SortWrappers.$SnapTo$PSF<e$AddLiquidity> ($Snap) $PSF<e$AddLiquidity>)
(assert (forall ((x $PSF<e$AddLiquidity>)) (!
    (= x ($SortWrappers.$SnapTo$PSF<e$AddLiquidity>($SortWrappers.$PSF<e$AddLiquidity>To$Snap x)))
    :pattern (($SortWrappers.$PSF<e$AddLiquidity>To$Snap x))
    :qid |$Snap.$SnapTo$PSF<e$AddLiquidity>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PSF<e$AddLiquidity>To$Snap($SortWrappers.$SnapTo$PSF<e$AddLiquidity> x)))
    :pattern (($SortWrappers.$SnapTo$PSF<e$AddLiquidity> x))
    :qid |$Snap.$PSF<e$AddLiquidity>To$SnapTo$PSF<e$AddLiquidity>|
    )))
(declare-fun $SortWrappers.$PSF<e$RemoveLiquidity>To$Snap ($PSF<e$RemoveLiquidity>) $Snap)
(declare-fun $SortWrappers.$SnapTo$PSF<e$RemoveLiquidity> ($Snap) $PSF<e$RemoveLiquidity>)
(assert (forall ((x $PSF<e$RemoveLiquidity>)) (!
    (= x ($SortWrappers.$SnapTo$PSF<e$RemoveLiquidity>($SortWrappers.$PSF<e$RemoveLiquidity>To$Snap x)))
    :pattern (($SortWrappers.$PSF<e$RemoveLiquidity>To$Snap x))
    :qid |$Snap.$SnapTo$PSF<e$RemoveLiquidity>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PSF<e$RemoveLiquidity>To$Snap($SortWrappers.$SnapTo$PSF<e$RemoveLiquidity> x)))
    :pattern (($SortWrappers.$SnapTo$PSF<e$RemoveLiquidity> x))
    :qid |$Snap.$PSF<e$RemoveLiquidity>To$SnapTo$PSF<e$RemoveLiquidity>|
    )))
(declare-fun $SortWrappers.$PSF<e$Transfer>To$Snap ($PSF<e$Transfer>) $Snap)
(declare-fun $SortWrappers.$SnapTo$PSF<e$Transfer> ($Snap) $PSF<e$Transfer>)
(assert (forall ((x $PSF<e$Transfer>)) (!
    (= x ($SortWrappers.$SnapTo$PSF<e$Transfer>($SortWrappers.$PSF<e$Transfer>To$Snap x)))
    :pattern (($SortWrappers.$PSF<e$Transfer>To$Snap x))
    :qid |$Snap.$SnapTo$PSF<e$Transfer>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PSF<e$Transfer>To$Snap($SortWrappers.$SnapTo$PSF<e$Transfer> x)))
    :pattern (($SortWrappers.$SnapTo$PSF<e$Transfer> x))
    :qid |$Snap.$PSF<e$Transfer>To$SnapTo$PSF<e$Transfer>|
    )))
(declare-fun $SortWrappers.$PSF<e$Approval>To$Snap ($PSF<e$Approval>) $Snap)
(declare-fun $SortWrappers.$SnapTo$PSF<e$Approval> ($Snap) $PSF<e$Approval>)
(assert (forall ((x $PSF<e$Approval>)) (!
    (= x ($SortWrappers.$SnapTo$PSF<e$Approval>($SortWrappers.$PSF<e$Approval>To$Snap x)))
    :pattern (($SortWrappers.$PSF<e$Approval>To$Snap x))
    :qid |$Snap.$SnapTo$PSF<e$Approval>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PSF<e$Approval>To$Snap($SortWrappers.$SnapTo$PSF<e$Approval> x)))
    :pattern (($SortWrappers.$SnapTo$PSF<e$Approval> x))
    :qid |$Snap.$PSF<e$Approval>To$SnapTo$PSF<e$Approval>|
    )))
; ////////// Symbols
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_skolem_diff (Set<$Ref> Set<$Ref>) $Ref)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_skolem_diff (Set<$Snap> Set<$Snap>) $Snap)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_add (Int Int) Int)
(declare-fun Seq_sub (Int Int) Int)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_contains_trigger (Seq<Int> Int) Bool)
(declare-fun Seq_skolem (Seq<Int> Int) Int)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_skolem_diff (Seq<Int> Seq<Int>) Int)
(declare-fun Seq_range (Int Int) Seq<Int>)
(declare-fun $map_init<$Map<Int~_$Struct>> ($Struct) $Map<Int~_$Struct>)
(declare-fun $map_eq<Bool> ($Map<Int~_$Struct> $Map<Int~_$Struct>) Bool)
(declare-fun $map_get<$Struct> ($Map<Int~_$Struct> Int) $Struct)
(declare-fun $map_set<$Map<Int~_$Struct>> ($Map<Int~_$Struct> Int $Struct) $Map<Int~_$Struct>)
(declare-fun $bytes32_to_signed_int<Int> (Seq<Int>) Int)
(declare-fun $bytes32_to_unsigned_int<Int> (Seq<Int>) Int)
(declare-fun $signed_int_to_bytes32<Seq<Int>> (Int) Seq<Int>)
(declare-fun $unsigned_int_to_bytes32<Seq<Int>> (Int) Seq<Int>)
(declare-fun $pad32<Seq<Int>> (Seq<Int>) Seq<Int>)
(declare-fun $struct_get<Int> (Int) Int)
(declare-fun $struct_set<$Struct> ($Struct Int Int) $Struct)
(declare-fun $struct_get<Bool> (Int) Bool)
(declare-fun $struct_set<$Struct> ($Struct Int Bool) $Struct)
(declare-fun $map_init<$Map<Int~_$Map<Int~_Int>>> ($Map<Int~_Int>) $Map<Int~_$Map<Int~_Int>>)
(declare-fun $map_eq<Bool> ($Map<Int~_$Map<Int~_Int>> $Map<Int~_$Map<Int~_Int>>) Bool)
(declare-fun $map_get<$Map<Int~_Int>> ($Map<Int~_$Map<Int~_Int>> Int) $Map<Int~_Int>)
(declare-fun $map_set<$Map<Int~_$Map<Int~_Int>>> ($Map<Int~_$Map<Int~_Int>> Int $Map<Int~_Int>) $Map<Int~_$Map<Int~_Int>>)
(declare-fun $blockhash<Seq<Int>> (Int) Seq<Int>)
(declare-fun $method_id<Seq<Int>> (Seq<Int> Int) Seq<Int>)
(declare-fun $keccak256<Seq<Int>> (Seq<Int>) Seq<Int>)
(declare-fun $sha256<Seq<Int>> (Seq<Int>) Seq<Int>)
(declare-fun $ecrecover<Int> (Seq<Int> Int Int Int) Int)
(declare-fun $ecadd<Seq<Int>> (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun $ecmul<Seq<Int>> (Seq<Int> Int) Seq<Int>)
(declare-fun s$struct$self$init<$Struct> (Seq<Int> Seq<Int> Int Int $Map<Int~_Int> $Map<Int~_$Map<Int~_Int>> Int Int Int Int Bool $Map<Int~_Int> $Map<Int~_Int> Bool) $Struct)
(declare-fun s$struct$self$eq<Bool> ($Struct $Struct) Bool)
(declare-fun $array_init<Seq<Int>> (Int Int) Seq<Int>)
(declare-fun $wrap<$Int> (Int) $Int)
(declare-fun $unwrap<Int> ($Int) Int)
(declare-fun $w_mul<$Int> ($Int $Int) $Int)
(declare-fun $w_mulI<$Int> ($Int $Int) $Int)
(declare-fun $w_mulL<$Int> ($Int $Int) $Int)
(declare-fun $w_abs<Int> ($Int) Int)
(declare-fun $w_mod<$Int> ($Int $Int) $Int)
(declare-fun $w_modL<$Int> ($Int $Int) $Int)
(declare-fun $w_div<$Int> ($Int $Int) $Int)
(declare-fun $w_div_down<$Int> ($Int $Int) $Int)
(declare-fun $w_div_nat<$Int> ($Int $Int) $Int)
(declare-fun $w_div_natL<$Int> ($Int $Int) $Int)
(declare-fun $struct_loc<Int> ($Struct Int) Int)
(declare-fun s$struct$EtherTokenPair$init<$Struct> (Int Int) $Struct)
(declare-fun s$struct$EtherTokenPair$eq<Bool> ($Struct $Struct) Bool)
(declare-fun $map_init<$Map<Int~_Int>> (Int) $Map<Int~_Int>)
(declare-fun $map_eq<Bool> ($Map<Int~_Int> $Map<Int~_Int>) Bool)
(declare-fun $map_get<Int> ($Map<Int~_Int> Int) Int)
(declare-fun $map_set<$Map<Int~_Int>> ($Map<Int~_Int> Int Int) $Map<Int~_Int>)
(declare-fun $sign<Int> (Int) Int)
(declare-fun $div<Int> (Int Int Int) Int)
(declare-fun $mod<Int> (Int Int Int) Int)
(declare-fun $pow<Int> (Int Int) Int)
(declare-fun $sqrt<Int> (Int) Int)
(declare-fun $floor<Int> (Int Int) Int)
(declare-fun $ceil<Int> (Int Int) Int)
(declare-fun $shift<Int> (Int Int) Int)
(declare-fun $bitwise_not<Int> (Int) Int)
(declare-fun $bitwise_and<Int> (Int Int) Int)
(declare-fun $bitwise_or<Int> (Int Int) Int)
(declare-fun $bitwise_xor<Int> (Int Int) Int)
(declare-const $self_address<Int> Int)
(declare-fun $implements<Bool> (Int Int) Bool)
(declare-fun $struct_get<$Map<Int~_$Map<Int~_Int>>> (Int) $Map<Int~_$Map<Int~_Int>>)
(declare-fun $struct_set<$Struct> ($Struct Int $Map<Int~_$Map<Int~_Int>>) $Struct)
(declare-fun $struct_get<$Struct> (Int) $Struct)
(declare-fun $struct_set<$Struct> ($Struct Int $Struct) $Struct)
(declare-fun $range<Seq<Int>> (Int Int) Seq<Int>)
(declare-fun $struct_get<$Map<Int~_Int>> (Int) $Map<Int~_Int>)
(declare-fun $struct_set<$Struct> ($Struct Int $Map<Int~_Int>) $Struct)
(declare-fun $struct_get<Seq<Int>> (Int) Seq<Int>)
(declare-fun $struct_set<$Struct> ($Struct Int Seq<Int>) $Struct)
(declare-fun s$resource$$creator$init<$Struct> ($Struct) $Struct)
(declare-fun s$resource$$creator$eq<Bool> ($Struct $Struct) Bool)
(declare-fun $map_sum<Int> ($Map<Int~_Int>) Int)
; /predicate_snap_functions_declarations.smt2 [e$TokenPurchase: Snap]
(declare-fun $PSF.domain_e$TokenPurchase ($PSF<e$TokenPurchase>) Set<$Snap>)
(declare-fun $PSF.lookup_e$TokenPurchase ($PSF<e$TokenPurchase> $Snap) $Snap)
(declare-fun $PSF.after_e$TokenPurchase ($PSF<e$TokenPurchase> $PSF<e$TokenPurchase>) Bool)
(declare-fun $PSF.loc_e$TokenPurchase ($Snap $Snap) Bool)
(declare-fun $PSF.perm_e$TokenPurchase ($PPM $Snap) $Perm)
(declare-const $psfTOP_e$TokenPurchase $PSF<e$TokenPurchase>)
; /predicate_snap_functions_declarations.smt2 [e$EthPurchase: Snap]
(declare-fun $PSF.domain_e$EthPurchase ($PSF<e$EthPurchase>) Set<$Snap>)
(declare-fun $PSF.lookup_e$EthPurchase ($PSF<e$EthPurchase> $Snap) $Snap)
(declare-fun $PSF.after_e$EthPurchase ($PSF<e$EthPurchase> $PSF<e$EthPurchase>) Bool)
(declare-fun $PSF.loc_e$EthPurchase ($Snap $Snap) Bool)
(declare-fun $PSF.perm_e$EthPurchase ($PPM $Snap) $Perm)
(declare-const $psfTOP_e$EthPurchase $PSF<e$EthPurchase>)
; /predicate_snap_functions_declarations.smt2 [e$AddLiquidity: Snap]
(declare-fun $PSF.domain_e$AddLiquidity ($PSF<e$AddLiquidity>) Set<$Snap>)
(declare-fun $PSF.lookup_e$AddLiquidity ($PSF<e$AddLiquidity> $Snap) $Snap)
(declare-fun $PSF.after_e$AddLiquidity ($PSF<e$AddLiquidity> $PSF<e$AddLiquidity>) Bool)
(declare-fun $PSF.loc_e$AddLiquidity ($Snap $Snap) Bool)
(declare-fun $PSF.perm_e$AddLiquidity ($PPM $Snap) $Perm)
(declare-const $psfTOP_e$AddLiquidity $PSF<e$AddLiquidity>)
; /predicate_snap_functions_declarations.smt2 [e$RemoveLiquidity: Snap]
(declare-fun $PSF.domain_e$RemoveLiquidity ($PSF<e$RemoveLiquidity>) Set<$Snap>)
(declare-fun $PSF.lookup_e$RemoveLiquidity ($PSF<e$RemoveLiquidity> $Snap) $Snap)
(declare-fun $PSF.after_e$RemoveLiquidity ($PSF<e$RemoveLiquidity> $PSF<e$RemoveLiquidity>) Bool)
(declare-fun $PSF.loc_e$RemoveLiquidity ($Snap $Snap) Bool)
(declare-fun $PSF.perm_e$RemoveLiquidity ($PPM $Snap) $Perm)
(declare-const $psfTOP_e$RemoveLiquidity $PSF<e$RemoveLiquidity>)
; /predicate_snap_functions_declarations.smt2 [e$Transfer: Snap]
(declare-fun $PSF.domain_e$Transfer ($PSF<e$Transfer>) Set<$Snap>)
(declare-fun $PSF.lookup_e$Transfer ($PSF<e$Transfer> $Snap) $Snap)
(declare-fun $PSF.after_e$Transfer ($PSF<e$Transfer> $PSF<e$Transfer>) Bool)
(declare-fun $PSF.loc_e$Transfer ($Snap $Snap) Bool)
(declare-fun $PSF.perm_e$Transfer ($PPM $Snap) $Perm)
(declare-const $psfTOP_e$Transfer $PSF<e$Transfer>)
; /predicate_snap_functions_declarations.smt2 [e$Approval: Snap]
(declare-fun $PSF.domain_e$Approval ($PSF<e$Approval>) Set<$Snap>)
(declare-fun $PSF.lookup_e$Approval ($PSF<e$Approval> $Snap) $Snap)
(declare-fun $PSF.after_e$Approval ($PSF<e$Approval> $PSF<e$Approval>) Bool)
(declare-fun $PSF.loc_e$Approval ($Snap $Snap) Bool)
(declare-fun $PSF.perm_e$Approval ($PPM $Snap) $Perm)
(declare-const $psfTOP_e$Approval $PSF<e$Approval>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun $pure$success_get ($Snap $Struct) Bool)
(declare-fun $pure$success_get%limited ($Snap $Struct) Bool)
(declare-fun $pure$success_get%stateless ($Struct) Bool)
(declare-fun $pure$success_get%precondition ($Snap $Struct) Bool)
(declare-fun $pure$return_get ($Snap $Struct) Int)
(declare-fun $pure$return_get%limited ($Snap $Struct) Int)
(declare-fun $pure$return_get%stateless ($Struct) Bool)
(declare-fun $pure$return_get%precondition ($Snap $Struct) Bool)
(declare-fun $range_sum ($Snap Int Int) Int)
(declare-fun $range_sum%limited ($Snap Int Int) Int)
(declare-fun $range_sum%stateless (Int Int) Bool)
(declare-fun $range_sum%precondition ($Snap Int Int) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun $failed%trigger ($Snap Int) Bool)
(declare-fun $failed_0%trigger ($Snap Int) Bool)
(declare-fun $allocation%trigger ($Snap $Struct Int) Bool)
(declare-fun $allocation_0%trigger ($Snap $Struct Int) Bool)
(declare-fun $offer%trigger ($Snap $Struct $Struct Int Int Int Int) Bool)
(declare-fun $offer_0%trigger ($Snap $Struct $Struct Int Int Int Int) Bool)
(declare-fun $trust%trigger ($Snap Int Int) Bool)
(declare-fun $trust_0%trigger ($Snap Int Int) Bool)
(declare-fun $performs$create%trigger ($Snap $Struct Int Int Int) Bool)
(declare-fun $performs$create_0%trigger ($Snap $Struct Int Int Int) Bool)
(declare-fun $performs$destroy%trigger ($Snap $Struct Int Int) Bool)
(declare-fun $performs$destroy_0%trigger ($Snap $Struct Int Int) Bool)
(declare-fun $performs$reallocate%trigger ($Snap $Struct Int Int Int) Bool)
(declare-fun $performs$reallocate_0%trigger ($Snap $Struct Int Int Int) Bool)
(declare-fun $performs$offer%trigger ($Snap $Struct $Struct Int Int Int Int Int) Bool)
(declare-fun $performs$offer_0%trigger ($Snap $Struct $Struct Int Int Int Int Int) Bool)
(declare-fun $performs$revoke%trigger ($Snap $Struct $Struct Int Int Int Int) Bool)
(declare-fun $performs$revoke_0%trigger ($Snap $Struct $Struct Int Int Int Int) Bool)
(declare-fun $performs$trust%trigger ($Snap Int Int Bool) Bool)
(declare-fun $performs$trust_0%trigger ($Snap Int Int Bool) Bool)
(declare-fun e$TokenPurchase%trigger ($Snap Int Int Int) Bool)
(declare-fun e$TokenPurchase_0%trigger ($Snap Int Int Int) Bool)
(declare-fun e$EthPurchase%trigger ($Snap Int Int Int) Bool)
(declare-fun e$EthPurchase_0%trigger ($Snap Int Int Int) Bool)
(declare-fun e$AddLiquidity%trigger ($Snap Int Int Int) Bool)
(declare-fun e$AddLiquidity_0%trigger ($Snap Int Int Int) Bool)
(declare-fun e$RemoveLiquidity%trigger ($Snap Int Int Int) Bool)
(declare-fun e$RemoveLiquidity_0%trigger ($Snap Int Int Int) Bool)
(declare-fun e$Transfer%trigger ($Snap Int Int Int) Bool)
(declare-fun e$Transfer_0%trigger ($Snap Int Int Int) Bool)
(declare-fun e$Approval%trigger ($Snap Int Int Int) Bool)
(declare-fun e$Approval_0%trigger ($Snap Int Int Int) Bool)
(declare-fun $accessible$setup%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$setup_0%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$addLiquidity%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$addLiquidity_0%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$removeLiquidity%trigger ($Snap Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$removeLiquidity_0%trigger ($Snap Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$getInputPrice%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$getInputPrice_0%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$getOutputPrice%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$getOutputPrice_0%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenInput%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenInput_0%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$__default__%trigger ($Snap Int Int Int) Bool)
(declare-fun $accessible$__default___0%trigger ($Snap Int Int Int) Bool)
(declare-fun $accessible$ethToTokenSwapInput%trigger ($Snap Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenSwapInput_0%trigger ($Snap Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenTransferInput%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenTransferInput_0%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenOutput%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenOutput_0%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenSwapOutput%trigger ($Snap Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenSwapOutput_0%trigger ($Snap Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenTransferOutput%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$ethToTokenTransferOutput_0%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthInput%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthInput_0%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthSwapInput%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthSwapInput_0%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthTransferInput%trigger ($Snap Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthTransferInput_0%trigger ($Snap Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthOutput%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthOutput_0%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthSwapOutput%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthSwapOutput_0%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthTransferOutput%trigger ($Snap Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToEthTransferOutput_0%trigger ($Snap Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenInput%trigger ($Snap Int Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenInput_0%trigger ($Snap Int Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenSwapInput%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenSwapInput_0%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenTransferInput%trigger ($Snap Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenTransferInput_0%trigger ($Snap Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenOutput%trigger ($Snap Int Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenOutput_0%trigger ($Snap Int Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenSwapOutput%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenSwapOutput_0%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenTransferOutput%trigger ($Snap Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToTokenTransferOutput_0%trigger ($Snap Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToExchangeSwapInput%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToExchangeSwapInput_0%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToExchangeTransferInput%trigger ($Snap Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToExchangeTransferInput_0%trigger ($Snap Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToExchangeSwapOutput%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToExchangeSwapOutput_0%trigger ($Snap Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToExchangeTransferOutput%trigger ($Snap Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$tokenToExchangeTransferOutput_0%trigger ($Snap Int Int Int Int Int Int Int Int Int) Bool)
(declare-fun $accessible$getEthToTokenInputPrice%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$getEthToTokenInputPrice_0%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$getEthToTokenOutputPrice%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$getEthToTokenOutputPrice_0%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$getTokenToEthInputPrice%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$getTokenToEthInputPrice_0%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$getTokenToEthOutputPrice%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$getTokenToEthOutputPrice_0%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$tokenAddress%trigger ($Snap Int Int Int) Bool)
(declare-fun $accessible$tokenAddress_0%trigger ($Snap Int Int Int) Bool)
(declare-fun $accessible$factoryAddress%trigger ($Snap Int Int Int) Bool)
(declare-fun $accessible$factoryAddress_0%trigger ($Snap Int Int Int) Bool)
(declare-fun $accessible$balanceOf%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$balanceOf_0%trigger ($Snap Int Int Int Int) Bool)
(declare-fun $accessible$transfer%trigger ($Snap Int Int Int Int Int) Bool)
(declare-fun $accessible$transfer_0%trigger ($Snap Int Int Int Int Int) Bool)
(declare-fun $accessible$transferFrom%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$transferFrom_0%trigger ($Snap Int Int Int Int Int Int) Bool)
(declare-fun $accessible$approve%trigger ($Snap Int Int Int Int Int) Bool)
(declare-fun $accessible$approve_0%trigger ($Snap Int Int Int Int Int) Bool)
(declare-fun $accessible$allowance%trigger ($Snap Int Int Int Int Int) Bool)
(declare-fun $accessible$allowance_0%trigger ($Snap Int Int Int Int Int) Bool)
(declare-fun $accessible$__init__%trigger ($Snap Int Int Int) Bool)
(declare-fun $accessible$__init___0%trigger ($Snap Int Int Int) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  )))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (=> (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  )))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (not (= s1 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s0 s1)) (+ (Seq_length s0) (Seq_length s1))))
  :pattern ((Seq_length (Seq_append s0 s1)))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>)) (!
  (and
    (=> (= s0 (as Seq_empty  Seq<Int>)) (= (Seq_append s0 s1) s1))
    (=> (= s1 (as Seq_empty  Seq<Int>)) (= (Seq_append s0 s1) s0)))
  :pattern ((Seq_append s0 s1))
  )))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((i Int) (j Int)) (!
  (= (Seq_add i j) (+ i j))
  :pattern ((Seq_add i j))
  )))
(assert (forall ((i Int) (j Int)) (!
  (= (Seq_sub i j) (- i j))
  :pattern ((Seq_sub i j))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Int>)))
        (and (<= 0 n) (< n (Seq_length s0)))))
    (= (Seq_index (Seq_append s0 s1) n) (Seq_index s0 n)))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  :pattern ((Seq_index s0 n) (Seq_append s0 s1))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Int>)))
        (and (<= (Seq_length s0) n) (< n (Seq_length (Seq_append s0 s1))))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s0)) (Seq_length s0)) n)
      (=
        (Seq_index (Seq_append s0 s1) n)
        (Seq_index s1 (Seq_sub n (Seq_length s0))))))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>) (m Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Int>)))
        (and (<= 0 m) (< m (Seq_length s1)))))
    (and
      (= (Seq_sub (Seq_add m (Seq_length s0)) (Seq_length s0)) m)
      (=
        (Seq_index (Seq_append s0 s1) (Seq_add m (Seq_length s0)))
        (Seq_index s1 m))))
  :pattern ((Seq_index s1 m) (Seq_append s0 s1))
  )))
(assert (forall ((s Seq<Int>) (i Int) (v Int)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i v)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i v)))
  :pattern ((Seq_length s) (Seq_update s i v))
  )))
(assert (forall ((s Seq<Int>) (i Int) (v Int) (n Int)) (!
  (=>
    (and (<= 0 n) (< n (Seq_length s)))
    (and
      (=> (= i n) (= (Seq_index (Seq_update s i v) n) v))
      (=> (not (= i n)) (= (Seq_index (Seq_update s i v) n) (Seq_index s n)))))
  :pattern ((Seq_index (Seq_update s i v) n))
  :pattern ((Seq_index s n) (Seq_update s i v))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=> (<= n (Seq_length s)) (= (Seq_length (Seq_take s n)) n))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_take s n)) (Seq_length s)))))
    (=> (< n 0) (= (Seq_length (Seq_take s n)) 0)))
  :pattern ((Seq_length (Seq_take s n)))
  :pattern ((Seq_take s n) (Seq_length s))
  )))
(assert (forall ((s Seq<Int>) (n Int) (j Int)) (!
  (=>
    (and (<= 0 j) (and (< j n) (< j (Seq_length s))))
    (= (Seq_index (Seq_take s n) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_take s n) j))
  :pattern ((Seq_index s j) (Seq_take s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=>
          (<= n (Seq_length s))
          (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n)))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_drop s n)) 0))))
    (=> (< n 0) (= (Seq_length (Seq_drop s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_drop s n)))
  :pattern ((Seq_length s) (Seq_drop s n))
  )))
(assert (forall ((s Seq<Int>) (n Int) (j Int)) (!
  (=>
    (and (< 0 n) (and (<= 0 j) (< j (- (Seq_length s) n))))
    (and
      (= (Seq_sub (Seq_add j n) n) j)
      (= (Seq_index (Seq_drop s n) j) (Seq_index s (Seq_add j n)))))
  :pattern ((Seq_index (Seq_drop s n) j))
  )))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (=>
    (and (< 0 n) (and (<= n i) (< i (Seq_length s))))
    (and
      (= (Seq_add (Seq_sub i n) n) i)
      (= (Seq_index (Seq_drop s n) (Seq_sub i n)) (Seq_index s i))))
  :pattern ((Seq_drop s n) (Seq_index s i))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_take (Seq_append s t) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (> n 0) (and (> n (Seq_length s)) (< n (Seq_length (Seq_append s t)))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (=
        (Seq_take (Seq_append s t) n)
        (Seq_append s (Seq_take t (Seq_sub n (Seq_length s)))))))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_append s t) n) (Seq_append (Seq_drop s n) t)))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (> n 0) (> n (Seq_length s)))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (= (Seq_drop (Seq_append s t) n) (Seq_drop t (Seq_sub n (Seq_length s))))))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_take s n) s))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_drop s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<Int>) (x Int)) (!
  (=>
    (Seq_contains s x)
    (and
      (<= 0 (Seq_skolem s x))
      (and
        (< (Seq_skolem s x) (Seq_length s))
        (= (Seq_index s (Seq_skolem s x)) x))))
  :pattern ((Seq_contains s x))
  )))
(assert (forall ((s Seq<Int>) (x Int) (i Int)) (!
  (=>
    (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) x)))
    (Seq_contains s x))
  :pattern ((Seq_contains s x) (Seq_index s i))
  )))
(assert (forall ((s Seq<Int>) (i Int)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (Seq_contains_trigger s (Seq_index s i)))
  :pattern ((Seq_index s i))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>)) (!
  (or
    (and (= s0 s1) (Seq_equal s0 s1))
    (or
      (and
        (not (= s0 s1))
        (and (not (Seq_equal s0 s1)) (not (= (Seq_length s0) (Seq_length s1)))))
      (and
        (not (= s0 s1))
        (and
          (not (Seq_equal s0 s1))
          (and
            (= (Seq_length s0) (Seq_length s1))
            (and
              (= (Seq_skolem_diff s0 s1) (Seq_skolem_diff s1 s0))
              (and
                (<= 0 (Seq_skolem_diff s0 s1))
                (and
                  (< (Seq_skolem_diff s0 s1) (Seq_length s0))
                  (not
                    (=
                      (Seq_index s0 (Seq_skolem_diff s0 s1))
                      (Seq_index s1 (Seq_skolem_diff s0 s1))))))))))))
  :pattern ((Seq_equal s0 s1))
  )))
(assert (forall ((a Seq<Int>) (b Seq<Int>)) (!
  (=> (Seq_equal a b) (= a b))
  :pattern ((Seq_equal a b))
  )))
(assert (forall ((x Int) (y Int)) (!
  (= (Seq_contains (Seq_singleton x) y) (= x y))
  :pattern ((Seq_contains (Seq_singleton x) y))
  )))
(assert (forall ((min_ Int) (max Int)) (!
  (and
    (=> (< min_ max) (= (Seq_length (Seq_range min_ max)) (- max min_)))
    (=> (<= max min_) (= (Seq_length (Seq_range min_ max)) 0)))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (j Int)) (!
  (=>
    (and (<= 0 j) (< j (- max min_)))
    (= (Seq_index (Seq_range min_ max) j) (+ min_ j)))
  :pattern ((Seq_index (Seq_range min_ max) j))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (v Int)) (!
  (= (Seq_contains (Seq_range min_ max) v) (and (<= min_ v) (< v max)))
  :pattern ((Seq_contains (Seq_range min_ max) v))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Ref)) (!
  (not (Set_in o (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in o (as Set_empty  Set<$Ref>)))
  )))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Ref))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Ref)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Ref) (o $Ref)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Ref)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (o $Ref)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Ref)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Snap)) (!
  (not (Set_in o (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in o (as Set_empty  Set<$Snap>)))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Snap))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Snap)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Snap) (o $Snap)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Snap)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (o $Snap)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Snap)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall (($v $Struct) ($k Int)) (!
  (= ($map_get<$Struct> ($map_init<$Map<Int~_$Struct>> $v) $k) $v)
  :pattern (($map_get<$Struct> ($map_init<$Map<Int~_$Struct>> $v) $k))
  :qid |prog.$map_init_ax|)))
(assert (forall (($m $Map<Int~_$Struct>) ($n $Map<Int~_$Struct>)) (!
  (and
    (= ($map_eq<Bool> $m $n) (= $m $n))
    (=
      ($map_eq<Bool> $m $n)
      (forall (($k Int)) (!
        (= ($map_get<$Struct> $m $k) ($map_get<$Struct> $n $k))
        :pattern (($map_get<$Struct> $m $k) ($map_get<$Struct> $n $k))
        ))))
  :pattern (($map_eq<Bool> $m $n))
  :qid |prog.$map_eq_ax|)))
(assert (forall (($m $Map<Int~_$Struct>) ($k Int) ($v $Struct) ($kk Int)) (!
  (=
    ($map_get<$Struct> ($map_set<$Map<Int~_$Struct>> $m $k $v) $kk)
    (ite (= $k $kk) $v ($map_get<$Struct> $m $kk)))
  :pattern (($map_get<$Struct> ($map_set<$Map<Int~_$Struct>> $m $k $v) $kk))
  :qid |prog.$map_set_ax|)))
(assert (forall (($bb Seq<Int>)) (!
  (=>
    (<= (Seq_length $bb) 32)
    (and
      (<=
        (- 0 57896044618658097711785492504343953926634992332820282019728792003956564819968)
        ($bytes32_to_signed_int<Int> $bb))
      (<=
        ($bytes32_to_signed_int<Int> $bb)
        57896044618658097711785492504343953926634992332820282019728792003956564819967)))
  :pattern (($bytes32_to_signed_int<Int> $bb))
  :qid |prog.$bytes32_to_signed_int_ax|)))
(assert (forall (($bb Seq<Int>)) (!
  (=>
    (<= (Seq_length $bb) 32)
    (and
      (<= 0 ($bytes32_to_unsigned_int<Int> $bb))
      (<=
        ($bytes32_to_unsigned_int<Int> $bb)
        115792089237316195423570985008687907853269984665640564039457584007913129639935)))
  :pattern (($bytes32_to_unsigned_int<Int> $bb))
  :qid |prog.$bytes32_to_unsigned_int_ax|)))
(assert (forall (($i Int)) (!
  (=>
    (and
      (<=
        (- 0 57896044618658097711785492504343953926634992332820282019728792003956564819968)
        $i)
      (<=
        $i
        57896044618658097711785492504343953926634992332820282019728792003956564819967))
    (= (Seq_length ($signed_int_to_bytes32<Seq<Int>> $i)) 32))
  :pattern (($signed_int_to_bytes32<Seq<Int>> $i))
  :qid |prog.$signed_int_to_bytes32_ax|)))
(assert (forall (($i Int)) (!
  (=>
    (and
      (<=
        (- 0 57896044618658097711785492504343953926634992332820282019728792003956564819968)
        $i)
      (<=
        $i
        57896044618658097711785492504343953926634992332820282019728792003956564819967))
    (= (Seq_length ($unsigned_int_to_bytes32<Seq<Int>> $i)) 32))
  :pattern (($unsigned_int_to_bytes32<Seq<Int>> $i))
  :qid |prog.$unsigned_int_to_bytes32_ax|)))
(assert (forall (($bb Seq<Int>)) (!
  (= (Seq_length ($pad32<Seq<Int>> $bb)) 32)
  :pattern (($pad32<Seq<Int>> $bb))
  :qid |prog.$pad32_len_ax|)))
(assert (and
  (forall (($bb Seq<Int>) ($i Int)) (!
    (let ((diff (- 32 (Seq_length $bb)))) true)
    :pattern ((Seq_index ($pad32<Seq<Int>> $bb) $i))
    :qid |prog.$pad32_vals_ax|))
  (forall (($bb Seq<Int>) ($i Int)) (!
    (let ((diff (- 32 (Seq_length $bb)))) (=>
      (and (<= 0 $i) (< $i (Seq_length ($pad32<Seq<Int>> $bb))))
      (=
        (Seq_index ($pad32<Seq<Int>> $bb) $i)
        (ite (< $i diff) 0 (Seq_index $bb (- $i diff))))))
    :pattern ((Seq_index ($pad32<Seq<Int>> $bb) $i))
    :qid |prog.$pad32_vals_ax|))))
(assert (forall (($s $Struct) ($m Int) ($t Int)) (!
  (= ($struct_get<Int> ($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m)) $t)
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
  :qid |prog.$get_set_0_ax|)))
(assert (forall (($s $Struct) ($m Int) ($n Int) ($t Int)) (!
  (=>
    (not (= $m $n))
    (=
      ($struct_loc<Int> $s $m)
      ($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m)))
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m))
  :qid |prog.$get_set_1_ax|)))
(assert (forall (($s $Struct) ($m Int) ($t Bool)) (!
  (=
    ($struct_get<Bool> ($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
    $t)
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
  :qid |prog.$get_set_0_ax|)))
(assert (forall (($s $Struct) ($m Int) ($n Int) ($t Bool)) (!
  (=>
    (not (= $m $n))
    (=
      ($struct_loc<Int> $s $m)
      ($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m)))
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m))
  :qid |prog.$get_set_1_ax|)))
(assert (forall (($v $Map<Int~_Int>) ($k Int)) (!
  (= ($map_get<$Map<Int~_Int>> ($map_init<$Map<Int~_$Map<Int~_Int>>> $v) $k) $v)
  :pattern (($map_get<$Map<Int~_Int>> ($map_init<$Map<Int~_$Map<Int~_Int>>> $v) $k))
  :qid |prog.$map_init_ax|)))
(assert (forall (($m $Map<Int~_$Map<Int~_Int>>) ($n $Map<Int~_$Map<Int~_Int>>)) (!
  (and
    (= ($map_eq<Bool> $m $n) (= $m $n))
    (=
      ($map_eq<Bool> $m $n)
      (forall (($k Int)) (!
        (= ($map_get<$Map<Int~_Int>> $m $k) ($map_get<$Map<Int~_Int>> $n $k))
        :pattern (($map_get<$Map<Int~_Int>> $m $k) ($map_get<$Map<Int~_Int>> $n $k))
        ))))
  :pattern (($map_eq<Bool> $m $n))
  :qid |prog.$map_eq_ax|)))
(assert (forall (($m $Map<Int~_$Map<Int~_Int>>) ($k Int) ($v $Map<Int~_Int>) ($kk Int)) (!
  (=
    ($map_get<$Map<Int~_Int>> ($map_set<$Map<Int~_$Map<Int~_Int>>> $m $k $v) $kk)
    (ite (= $k $kk) $v ($map_get<$Map<Int~_Int>> $m $kk)))
  :pattern (($map_get<$Map<Int~_Int>> ($map_set<$Map<Int~_$Map<Int~_Int>>> $m $k $v) $kk))
  :qid |prog.$map_set_ax|)))
(assert (forall (($no Int)) (!
  (= (Seq_length ($blockhash<Seq<Int>> $no)) 32)
  :pattern (($blockhash<Seq<Int>> $no))
  :qid |prog.$blockhash_ax|)))
(assert (forall (($bb Seq<Int>) ($l Int)) (!
  (= (Seq_length ($method_id<Seq<Int>> $bb $l)) $l)
  :pattern (($method_id<Seq<Int>> $bb $l))
  :qid |prog.$method_id_ax|)))
(assert (forall (($s Seq<Int>)) (!
  (= (Seq_length ($keccak256<Seq<Int>> $s)) 32)
  :pattern (($keccak256<Seq<Int>> $s))
  :qid |prog.$keccak256_ax|)))
(assert (forall (($s Seq<Int>)) (!
  (= (Seq_length ($sha256<Seq<Int>> $s)) 32)
  :pattern (($sha256<Seq<Int>> $s))
  :qid |prog.$sha256_ax|)))
(assert (forall (($p Seq<Int>) ($q Seq<Int>)) (!
  (= (Seq_length ($ecadd<Seq<Int>> $p $q)) 2)
  :pattern (($ecadd<Seq<Int>> $p $q))
  :qid |prog.$ecadd_ax|)))
(assert (forall (($p Seq<Int>) ($s Int)) (!
  (= (Seq_length ($ecmul<Seq<Int>> $p $s)) 2)
  :pattern (($ecmul<Seq<Int>> $p $s))
  :qid |prog.$ecmul_ax|)))
(assert (forall (($arg_0 Seq<Int>) ($arg_1 Seq<Int>) ($arg_2 Int) ($arg_3 Int) ($arg_4 $Map<Int~_Int>) ($arg_5 $Map<Int~_$Map<Int~_Int>>) ($arg_6 Int) ($arg_7 Int) ($arg_8 Int) ($arg_9 Int) ($arg_10 Bool) ($arg_11 $Map<Int~_Int>) ($arg_12 $Map<Int~_Int>) ($arg_13 Bool)) (!
  (and
    (=
      ($struct_get<Int> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) (- 0 1)))
      9122519725869122497593506884710)
    (and
      (Seq_equal
        ($struct_get<Seq<Int>> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 0))
        $arg_0)
      (and
        (Seq_equal
          ($struct_get<Seq<Int>> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 1))
          $arg_1)
        (and
          (=
            ($struct_get<Int> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 2))
            $arg_2)
          (and
            (=
              ($struct_get<Int> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 3))
              $arg_3)
            (and
              (=
                ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 4))
                $arg_4)
              (and
                (=
                  ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 5))
                  $arg_5)
                (and
                  (=
                    ($struct_get<Int> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 6))
                    $arg_6)
                  (and
                    (=
                      ($struct_get<Int> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 7))
                      $arg_7)
                    (and
                      (=
                        ($struct_get<Int> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 8))
                        $arg_8)
                      (and
                        (=
                          ($struct_get<Int> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 9))
                          $arg_9)
                        (and
                          (=
                            ($struct_get<Bool> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 10))
                            $arg_10)
                          (and
                            (=
                              ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 11))
                              $arg_11)
                            (and
                              (=
                                ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 12))
                                $arg_12)
                              (=
                                ($struct_get<Bool> ($struct_loc<Int> (s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13) 13))
                                $arg_13)))))))))))))))
  :pattern ((s$struct$self$init<$Struct> $arg_0 $arg_1 $arg_2 $arg_3 $arg_4 $arg_5 $arg_6 $arg_7 $arg_8 $arg_9 $arg_10 $arg_11 $arg_12 $arg_13))
  :qid |prog.s$struct$self$init$ax|)))
(assert (forall (($l $Struct) ($r $Struct)) (!
  (and
    (= (s$struct$self$eq<Bool> $l $r) (= $l $r))
    (=
      (s$struct$self$eq<Bool> $l $r)
      (and
        (=
          ($struct_get<Int> ($struct_loc<Int> $l (- 0 1)))
          ($struct_get<Int> ($struct_loc<Int> $r (- 0 1))))
        (and
          (Seq_equal
            ($struct_get<Seq<Int>> ($struct_loc<Int> $l 0))
            ($struct_get<Seq<Int>> ($struct_loc<Int> $r 0)))
          (and
            (Seq_equal
              ($struct_get<Seq<Int>> ($struct_loc<Int> $l 1))
              ($struct_get<Seq<Int>> ($struct_loc<Int> $r 1)))
            (and
              (=
                ($struct_get<Int> ($struct_loc<Int> $l 2))
                ($struct_get<Int> ($struct_loc<Int> $r 2)))
              (and
                (=
                  ($struct_get<Int> ($struct_loc<Int> $l 3))
                  ($struct_get<Int> ($struct_loc<Int> $r 3)))
                (and
                  ($map_eq<Bool> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $l 4)) ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $r 4)))
                  (and
                    ($map_eq<Bool> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $l 5)) ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $r 5)))
                    (and
                      (=
                        ($struct_get<Int> ($struct_loc<Int> $l 6))
                        ($struct_get<Int> ($struct_loc<Int> $r 6)))
                      (and
                        (=
                          ($struct_get<Int> ($struct_loc<Int> $l 7))
                          ($struct_get<Int> ($struct_loc<Int> $r 7)))
                        (and
                          (=
                            ($struct_get<Int> ($struct_loc<Int> $l 8))
                            ($struct_get<Int> ($struct_loc<Int> $r 8)))
                          (and
                            (=
                              ($struct_get<Int> ($struct_loc<Int> $l 9))
                              ($struct_get<Int> ($struct_loc<Int> $r 9)))
                            (and
                              (=
                                ($struct_get<Bool> ($struct_loc<Int> $l 10))
                                ($struct_get<Bool> ($struct_loc<Int> $r 10)))
                              (and
                                ($map_eq<Bool> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $l 11)) ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $r 11)))
                                (and
                                  ($map_eq<Bool> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $l 12)) ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $r 12)))
                                  (=
                                    ($struct_get<Bool> ($struct_loc<Int> $l 13))
                                    ($struct_get<Bool> ($struct_loc<Int> $r 13)))))))))))))))))))
  :pattern ((s$struct$self$eq<Bool> $l $r))
  :qid |prog.s$struct$self$eq$ax|)))
(assert (forall (($e Int) ($c Int)) (!
  (= (Seq_length ($array_init<Seq<Int>> $e $c)) $c)
  :pattern (($array_init<Seq<Int>> $e $c))
  :qid |prog.$array_init_len_ax|)))
(assert (forall (($e Int) ($c Int) ($i Int)) (!
  (=>
    (and (<= 0 $i) (< $i $c))
    (= (Seq_index ($array_init<Seq<Int>> $e $c) $i) $e))
  :pattern ((Seq_index ($array_init<Seq<Int>> $e $c) $i))
  :qid |prog.$array_init_val_ax|)))
(assert (forall ((i Int)) (!
  (= ($unwrap<Int> ($wrap<$Int> i)) i)
  :pattern (($wrap<$Int> i))
  :qid |prog.$wrap_ax|)))
(assert (forall ((i $Int)) (!
  (= ($wrap<$Int> ($unwrap<Int> i)) i)
  :pattern (($wrap<$Int> ($unwrap<Int> i)))
  :qid |prog.$unwrap_ax|)))
(assert (forall ((i $Int)) (!
  (=> (< ($unwrap<Int> i) 0) (= ($w_abs<Int> i) (- 0 ($unwrap<Int> i))))
  :pattern (($w_abs<Int> i))
  :qid |prog.$w_abs_ax_1|)))
(assert (forall ((i $Int)) (!
  (=> (>= ($unwrap<Int> i) 0) (= ($w_abs<Int> i) ($unwrap<Int> i)))
  :pattern (($w_abs<Int> i))
  :qid |prog.$w_abs_ax_2|)))
(assert (forall ((i $Int) (j $Int)) (!
  (= ($w_mul<$Int> i j) ($w_mulI<$Int> i j))
  :pattern (($w_mul<$Int> i j))
  :qid |prog.$w_mul_intermediate|)))
(assert (forall ((i $Int) (j $Int)) (!
  (= ($w_mul<$Int> i j) ($w_mulL<$Int> i j))
  :pattern (($w_mul<$Int> i j))
  :qid |prog.$w_mul_limited|)))
(assert (forall ((i $Int) (j $Int)) (!
  (= ($w_mulI<$Int> i j) ($w_mulL<$Int> i j))
  :pattern (($w_mulI<$Int> i j))
  :qid |prog.$w_mul_intermediate_to_limited|)))
(assert (forall ((i $Int) (j $Int)) (!
  (= ($w_mul<$Int> i j) ($w_mulI<$Int> j i))
  :pattern (($w_mul<$Int> i j))
  :qid |prog.$w_mul_commutative|)))
(assert (forall ((i $Int) (j $Int) (k $Int)) (!
  (= ($w_mulI<$Int> i ($w_mulI<$Int> j k)) ($w_mulL<$Int> ($w_mulL<$Int> i j) k))
  :pattern (($w_mulI<$Int> i ($w_mulI<$Int> j k)))
  :qid |prog.$w_mul_associative|)))
(assert (forall ((i $Int) (j $Int) (k $Int) (l $Int)) (!
  (=>
    (= ($unwrap<Int> j) (+ ($unwrap<Int> k) ($unwrap<Int> l)))
    (=
      ($w_mulI<$Int> i j)
      ($wrap<$Int> (+
        ($unwrap<Int> ($w_mulL<$Int> i k))
        ($unwrap<Int> ($w_mulL<$Int> i l))))))
  :pattern (($w_mulI<$Int> i j) ($w_mulI<$Int> i k) ($w_mulI<$Int> i l))
  :qid |prog.$w_mul_distributive|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=
    ($w_mulI<$Int> i j)
    ($w_mulL<$Int> ($wrap<$Int> (- 0 ($unwrap<Int> i))) ($wrap<$Int> (-
      0
      ($unwrap<Int> j)))))
  :pattern (($w_mulI<$Int> i j))
  :qid |prog.$w_mul_basic_sign_1|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=
    ($w_mulI<$Int> i j)
    ($wrap<$Int> (-
      0
      ($unwrap<Int> ($w_mulL<$Int> ($wrap<$Int> (- 0 ($unwrap<Int> i))) j)))))
  :pattern (($w_mulI<$Int> i j))
  :qid |prog.$w_mul_basic_sign_2|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (or (= ($unwrap<Int> i) 0) (= ($unwrap<Int> j) 0))
    (= ($unwrap<Int> ($w_mulI<$Int> i j)) 0))
  :pattern (($w_mulI<$Int> i j))
  :qid |prog.$w_mul_basic_zero_1|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (or
      (and (> ($unwrap<Int> i) 0) (> ($unwrap<Int> j) 0))
      (and (< ($unwrap<Int> i) 0) (< ($unwrap<Int> j) 0)))
    (> ($unwrap<Int> ($w_mulI<$Int> i j)) 0))
  :pattern (($w_mulI<$Int> i j))
  :qid |prog.$w_mul_basic_zero_2|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (or (= ($unwrap<Int> i) 1) (= ($unwrap<Int> j) 0))
    (= ($w_mulI<$Int> i j) j))
  :pattern (($w_mulI<$Int> i j))
  :qid |prog.$w_mul_basic_neutral|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=
    (>= ($w_abs<Int> ($w_mulI<$Int> i j)) ($w_abs<Int> j))
    (or (>= ($w_abs<Int> i) 1) (= ($unwrap<Int> j) 0)))
  :pattern (($w_mulI<$Int> i j))
  :qid |prog.$w_mul_basic_proportional|)))
(assert (forall ((i $Int) (j $Int) (k $Int) (l $Int)) (!
  (=>
    (and
      (> ($unwrap<Int> ($w_mulI<$Int> i j)) ($unwrap<Int> k))
      (> ($unwrap<Int> l) 0))
    (>
      ($unwrap<Int> ($w_mulL<$Int> i ($w_mulL<$Int> j l)))
      ($unwrap<Int> ($w_mulI<$Int> k l))))
  :pattern (($w_mulI<$Int> i ($w_mulI<$Int> j l)) ($w_mulI<$Int> k l))
  :qid |prog.$w_mul_order_1|)))
(assert (forall ((i $Int) (j $Int) (k $Int) (l $Int)) (!
  (=>
    (and
      (>= ($unwrap<Int> ($w_mulI<$Int> i j)) ($unwrap<Int> k))
      (> ($unwrap<Int> l) 0))
    (>=
      ($unwrap<Int> ($w_mulL<$Int> i ($w_mulL<$Int> j l)))
      ($unwrap<Int> ($w_mulI<$Int> k l))))
  :pattern (($w_mulI<$Int> i ($w_mulI<$Int> j l)) ($w_mulI<$Int> k l))
  :qid |prog.$w_mul_order_2|)))
(assert (forall ((i $Int) (j $Int) (k $Int) (l $Int)) (!
  (=>
    (and
      (> ($unwrap<Int> ($w_mulI<$Int> i j)) ($unwrap<Int> k))
      (< ($unwrap<Int> l) 0))
    (>
      ($unwrap<Int> ($w_mulI<$Int> k l))
      ($unwrap<Int> ($w_mulL<$Int> i ($w_mulL<$Int> j l)))))
  :pattern (($w_mulI<$Int> i ($w_mulI<$Int> j l)) ($w_mulI<$Int> k l))
  :qid |prog.$w_mul_order_3|)))
(assert (forall ((i $Int) (j $Int) (k $Int) (l $Int)) (!
  (=>
    (and
      (>= ($unwrap<Int> ($w_mulI<$Int> i j)) ($unwrap<Int> k))
      (< ($unwrap<Int> l) 0))
    (>=
      ($unwrap<Int> ($w_mulI<$Int> k l))
      ($unwrap<Int> ($w_mulL<$Int> i ($w_mulL<$Int> j l)))))
  :pattern (($w_mulI<$Int> i ($w_mulI<$Int> j l)) ($w_mulI<$Int> k l))
  :qid |prog.$w_mul_order_4|)))
(assert (forall ((i $Int) (j $Int) (k $Int) (l $Int)) (!
  (=>
    (and
      (<= ($w_abs<Int> i) ($w_abs<Int> j))
      (<= ($w_abs<Int> k) ($w_abs<Int> l)))
    (<= ($w_abs<Int> ($w_mulI<$Int> i k)) ($w_abs<Int> ($w_mulI<$Int> j l))))
  :pattern (($w_mulI<$Int> i k) ($w_mulI<$Int> j l))
  :qid |prog.$w_mul_monotonicity_1|)))
(assert (forall ((i $Int) (j $Int) (k $Int) (l $Int)) (!
  (=>
    (and
      (< ($w_abs<Int> i) ($w_abs<Int> j))
      (and (<= ($w_abs<Int> k) ($w_abs<Int> l)) (not (= ($unwrap<Int> l) 0))))
    (< ($w_abs<Int> ($w_mulI<$Int> i k)) ($w_abs<Int> ($w_mulI<$Int> j l))))
  :pattern (($w_mulI<$Int> i k) ($w_mulI<$Int> j l))
  :qid |prog.$w_mul_monotonicity_2|)))
(assert (forall ((i $Int) (j $Int) (k $Int) (l $Int)) (!
  (=>
    (and
      (<= ($w_abs<Int> i) ($w_abs<Int> j))
      (and (< ($w_abs<Int> k) ($w_abs<Int> l)) (not (= ($unwrap<Int> j) 0))))
    (< ($w_abs<Int> ($w_mulI<$Int> i k)) ($w_abs<Int> ($w_mulI<$Int> j l))))
  :pattern (($w_mulI<$Int> i k) ($w_mulI<$Int> j l))
  :qid |prog.$w_mul_monotonicity_3|)))
(assert (forall ((i $Int) (j $Int)) (!
  (= ($w_mod<$Int> i j) ($w_modL<$Int> i j))
  :pattern (($w_mod<$Int> i j))
  :qid |prog.$w_mod_limited|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (and (not (= j ($wrap<$Int> 0))) (or (= i j) (= i ($wrap<$Int> 0))))
    (= ($w_mod<$Int> i j) ($wrap<$Int> 0)))
  :pattern (($w_mod<$Int> i j))
  :qid |prog.$w_mod_identity|)))
(assert (forall ((i $Int) (j $Int) (l $Int)) (!
  (=>
    (and
      (not (= j ($wrap<$Int> 0)))
      (and
        (= ($unwrap<Int> i) (+ ($unwrap<Int> l) ($w_abs<Int> j)))
        (or (>= ($unwrap<Int> l) 0) (< ($unwrap<Int> i) 0))))
    (= ($w_mod<$Int> i j) ($w_modL<$Int> l j)))
  :pattern (($w_mod<$Int> i j) ($w_mod<$Int> l j))
  :qid |prog.$w_mod_basic_1|)))
(assert (forall ((i $Int) (j $Int) (l $Int)) (!
  (=>
    (and
      (not (= j ($wrap<$Int> 0)))
      (and
        (= ($unwrap<Int> i) (- ($unwrap<Int> l) ($w_abs<Int> j)))
        (or (<= ($unwrap<Int> l) 0) (> ($unwrap<Int> i) 0))))
    (= ($w_mod<$Int> i j) ($w_modL<$Int> l j)))
  :pattern (($w_mod<$Int> i j) ($w_mod<$Int> l j))
  :qid |prog.$w_mod_basic_2|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (and
      (not (= j ($wrap<$Int> 0)))
      (and (<= 0 ($w_abs<Int> i)) (< ($w_abs<Int> i) ($w_abs<Int> j))))
    (= ($w_mod<$Int> i j) i))
  :pattern (($w_mod<$Int> i j))
  :qid |prog.$w_mod_basic_3|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (not (= j ($wrap<$Int> 0)))
    (< ($w_abs<Int> ($w_mod<$Int> i j)) ($w_abs<Int> j)))
  :pattern (($w_mod<$Int> i j))
  :qid |prog.$w_mod_basic_4|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (not (= j ($wrap<$Int> 0)))
    (or
      (=
        ($sign<Int> ($unwrap<Int> ($w_mod<$Int> i j)))
        ($sign<Int> ($unwrap<Int> i)))
      (= ($sign<Int> ($unwrap<Int> ($w_mod<$Int> i j))) 0)))
  :pattern (($w_mod<$Int> i j))
  :qid |prog.$w_mod_sign_1|)))
(assert (forall ((i $Int) (j $Int) (k $Int)) (!
  (=>
    (and (not (= j ($wrap<$Int> 0))) (= ($unwrap<Int> i) (- 0 ($unwrap<Int> k))))
    (= ($w_mod<$Int> i j) ($wrap<$Int> (- 0 ($unwrap<Int> ($w_modL<$Int> k j))))))
  :pattern (($w_mod<$Int> i j) ($w_mod<$Int> k j))
  :qid |prog.$w_mod_sign_2|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (not (= j ($wrap<$Int> 0)))
    (= ($w_mod<$Int> i j) ($w_mod<$Int> i ($wrap<$Int> (- 0 ($unwrap<Int> j))))))
  :pattern (($w_mod<$Int> i j))
  :qid |prog.$w_mod_sign_3|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (not (= j ($wrap<$Int> 0)))
    (= ($w_mod<$Int> i j) ($w_modL<$Int> ($w_modL<$Int> i j) j)))
  :pattern (($w_mod<$Int> i j))
  :qid |prog.$w_mod_mod|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (not (= j ($wrap<$Int> 0)))
    (<= ($w_abs<Int> ($w_mod<$Int> i j)) ($w_abs<Int> i)))
  :pattern (($w_mod<$Int> i j))
  :qid |prog.$w_mod_decrease|)))
(assert (forall ((i $Int) (j $Int) (k $Int) (l $Int)) (!
  (=>
    (and
      (not (= j ($wrap<$Int> 0)))
      (= ($unwrap<Int> i) (+ ($unwrap<Int> k) ($unwrap<Int> l))))
    (and
      (=>
        (or
          (and
            (>= ($unwrap<Int> i) 0)
            (>=
              (+
                ($unwrap<Int> ($w_modL<$Int> k j))
                ($unwrap<Int> ($w_modL<$Int> l j)))
              0))
          (and
            (<= ($unwrap<Int> i) 0)
            (<=
              (+
                ($unwrap<Int> ($w_modL<$Int> k j))
                ($unwrap<Int> ($w_modL<$Int> l j)))
              0)))
        (or
          (and
            (<=
              ($w_abs<Int> j)
              (+
                ($unwrap<Int> ($w_modL<$Int> k j))
                ($unwrap<Int> ($w_modL<$Int> l j))))
            (and
              (<
                (+
                  ($unwrap<Int> ($w_modL<$Int> k j))
                  ($unwrap<Int> ($w_modL<$Int> l j)))
                (* 2 ($w_abs<Int> j)))
              (=
                ($w_mod<$Int> i j)
                ($wrap<$Int> (-
                  (+
                    ($unwrap<Int> ($w_modL<$Int> k j))
                    ($unwrap<Int> ($w_modL<$Int> l j)))
                  ($w_abs<Int> j))))))
          (or
            (and
              (<
                (- 0 ($w_abs<Int> j))
                (+
                  ($unwrap<Int> ($w_modL<$Int> k j))
                  ($unwrap<Int> ($w_modL<$Int> l j))))
              (and
                (<
                  (+
                    ($unwrap<Int> ($w_modL<$Int> k j))
                    ($unwrap<Int> ($w_modL<$Int> l j)))
                  ($w_abs<Int> j))
                (=
                  ($w_mod<$Int> i j)
                  ($wrap<$Int> (+
                    ($unwrap<Int> ($w_modL<$Int> k j))
                    ($unwrap<Int> ($w_modL<$Int> l j)))))))
            (and
              (<
                (* (- 0 2) ($w_abs<Int> j))
                (+
                  ($unwrap<Int> ($w_modL<$Int> k j))
                  ($unwrap<Int> ($w_modL<$Int> l j))))
              (and
                (<=
                  (+
                    ($unwrap<Int> ($w_modL<$Int> k j))
                    ($unwrap<Int> ($w_modL<$Int> l j)))
                  (- 0 ($w_abs<Int> j)))
                (=
                  ($w_mod<$Int> i j)
                  ($wrap<$Int> (+
                    (+
                      ($unwrap<Int> ($w_modL<$Int> k j))
                      ($unwrap<Int> ($w_modL<$Int> l j)))
                    ($w_abs<Int> j)))))))))
      (=>
        (or
          (and
            (> ($unwrap<Int> i) 0)
            (<
              (+
                ($unwrap<Int> ($w_modL<$Int> k j))
                ($unwrap<Int> ($w_modL<$Int> l j)))
              0))
          (and
            (< ($unwrap<Int> i) 0)
            (>
              (+
                ($unwrap<Int> ($w_modL<$Int> k j))
                ($unwrap<Int> ($w_modL<$Int> l j)))
              0)))
        (or
          (and
            (<
              0
              (+
                ($unwrap<Int> ($w_modL<$Int> k j))
                ($unwrap<Int> ($w_modL<$Int> l j))))
            (and
              (<
                (+
                  ($unwrap<Int> ($w_modL<$Int> k j))
                  ($unwrap<Int> ($w_modL<$Int> l j)))
                ($w_abs<Int> j))
              (=
                ($w_mod<$Int> i j)
                ($wrap<$Int> (-
                  (+
                    ($unwrap<Int> ($w_modL<$Int> k j))
                    ($unwrap<Int> ($w_modL<$Int> l j)))
                  ($w_abs<Int> j))))))
          (and
            (<
              (- 0 ($w_abs<Int> j))
              (+
                ($unwrap<Int> ($w_modL<$Int> k j))
                ($unwrap<Int> ($w_modL<$Int> l j))))
            (and
              (<
                (+
                  ($unwrap<Int> ($w_modL<$Int> k j))
                  ($unwrap<Int> ($w_modL<$Int> l j)))
                0)
              (=
                ($w_mod<$Int> i j)
                ($wrap<$Int> (+
                  (+
                    ($unwrap<Int> ($w_modL<$Int> k j))
                    ($unwrap<Int> ($w_modL<$Int> l j)))
                  ($w_abs<Int> j))))))))))
  :pattern (($w_mod<$Int> i j) ($w_mod<$Int> k j) ($w_mod<$Int> l j))
  :qid |prog.$w_mod_add|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (not (= j ($wrap<$Int> 0)))
    (= ($w_mod<$Int> ($w_mul<$Int> i j) j) ($wrap<$Int> 0)))
  :pattern (($w_mod<$Int> ($w_mul<$Int> i j) j))
  :qid |prog.$w_mod_mul_basic|)))
(assert (forall ((i $Int) (j $Int) (k $Int)) (!
  (=>
    (not (= j ($wrap<$Int> 0)))
    (and
      (=
        ($w_mod<$Int> ($w_mulI<$Int> i k) j)
        ($w_modL<$Int> ($w_mulL<$Int> ($w_modL<$Int> i j) k) j))
      (and
        (=
          ($w_mod<$Int> ($w_mulI<$Int> i k) j)
          ($w_modL<$Int> ($w_mulL<$Int> i ($w_modL<$Int> k j)) j))
        (=
          ($w_mod<$Int> ($w_mulI<$Int> i k) j)
          ($w_modL<$Int> ($w_mulL<$Int> ($w_modL<$Int> i j) ($w_modL<$Int> k j)) j)))))
  :pattern (($w_mod<$Int> ($w_mulI<$Int> i k) j))
  :qid |prog.$w_mod_mul_mod_noop|)))
(assert (forall ((i $Int) (j $Int) (k $Int)) (!
  (=>
    (not (= j ($wrap<$Int> 0)))
    (=
      ($w_mod<$Int> i j)
      ($w_modL<$Int> ($wrap<$Int> (+
        ($unwrap<Int> ($w_mulL<$Int> k j))
        ($unwrap<Int> i))) j)))
  :pattern (($w_mod<$Int> i j) ($w_mulI<$Int> k j))
  :qid |prog.$w_mod_mul_vanish|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (not (= ($unwrap<Int> j) 0))
    (=
      ($w_div<$Int> i j)
      (ite
        (>= ($unwrap<Int> i) 0)
        ($w_div_down<$Int> i j)
        ($wrap<$Int> (-
          0
          ($unwrap<Int> ($w_div_down<$Int> ($wrap<$Int> (- 0 ($unwrap<Int> i))) j)))))))
  :pattern (($w_div<$Int> i j))
  :qid |prog.$w_div_div_down|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=
    ($w_div_down<$Int> i j)
    (ite
      (>= ($unwrap<Int> j) 0)
      ($w_div_nat<$Int> i j)
      ($wrap<$Int> (-
        0
        ($unwrap<Int> ($w_div_nat<$Int> i ($wrap<$Int> (- 0 ($unwrap<Int> j)))))))))
  :pattern (($w_div_down<$Int> i j))
  :qid |prog.$w_div_down_div_nat|)))
(assert (forall ((i $Int) (j $Int)) (!
  (= ($w_div_nat<$Int> i j) ($w_div_natL<$Int> i j))
  :pattern (($w_div_nat<$Int> i j))
  :qid |prog.$w_div_nat_limited|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (or (= ($unwrap<Int> j) 1) (= ($unwrap<Int> i) 0))
    (= ($w_div_nat<$Int> i j) i))
  :pattern (($w_div_nat<$Int> i j))
  :qid |prog.$w_div_nat_neutral|)))
(assert (forall ((i $Int)) (!
  (=> (> ($unwrap<Int> i) 0) (= ($w_div_nat<$Int> i i) ($wrap<$Int> 1)))
  :pattern (($w_div_nat<$Int> i i))
  :qid |prog.$w_div_nat_self|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (and (>= ($unwrap<Int> i) 0) (> ($unwrap<Int> j) 0))
    (=
      (< ($unwrap<Int> i) ($unwrap<Int> j))
      (= ($w_div_nat<$Int> i j) ($wrap<$Int> 0))))
  :pattern (($w_div_nat<$Int> i j))
  :qid |prog.$w_div_nat_small|)))
(assert (forall ((i $Int) (j $Int) (k $Int) (l $Int)) (!
  (=>
    (and
      (and
        (>= ($unwrap<Int> i) 0)
        (and
          (> ($unwrap<Int> j) 0)
          (and (>= ($unwrap<Int> k) 0) (>= ($unwrap<Int> l) 0))))
      (= ($unwrap<Int> i) (+ ($unwrap<Int> k) ($unwrap<Int> l))))
    (or
      (and
        (<=
          0
          (+ ($unwrap<Int> ($w_mod<$Int> k j)) ($unwrap<Int> ($w_mod<$Int> l j))))
        (and
          (<
            (+
              ($unwrap<Int> ($w_mod<$Int> k j))
              ($unwrap<Int> ($w_mod<$Int> l j)))
            ($unwrap<Int> j))
          (=
            ($w_div_nat<$Int> i j)
            ($wrap<$Int> (+
              ($unwrap<Int> ($w_div_natL<$Int> k j))
              ($unwrap<Int> ($w_div_natL<$Int> l j)))))))
      (and
        (<=
          ($unwrap<Int> j)
          (+ ($unwrap<Int> ($w_mod<$Int> k j)) ($unwrap<Int> ($w_mod<$Int> l j))))
        (and
          (<
            (+
              ($unwrap<Int> ($w_mod<$Int> k j))
              ($unwrap<Int> ($w_mod<$Int> l j)))
            (* 2 ($unwrap<Int> j)))
          (=
            ($w_div_nat<$Int> i j)
            ($wrap<$Int> (+
              (+
                ($unwrap<Int> ($w_div_natL<$Int> k j))
                ($unwrap<Int> ($w_div_natL<$Int> l j)))
              1)))))))
  :pattern (($w_div_nat<$Int> i j) ($w_div_nat<$Int> k j) ($w_div_nat<$Int> l j))
  :qid |prog.$w_div_nat_dividend_add|)))
(assert (forall ((i $Int) (j $Int) (k $Int)) (!
  (=>
    (and
      (and
        (>= ($unwrap<Int> i) 0)
        (and (> ($unwrap<Int> j) 0) (>= ($unwrap<Int> k) 0)))
      (<= ($unwrap<Int> i) ($unwrap<Int> k)))
    (<=
      ($unwrap<Int> ($w_div_nat<$Int> i j))
      ($unwrap<Int> ($w_div_natL<$Int> k j))))
  :pattern (($w_div_nat<$Int> i j) ($w_div_nat<$Int> k j))
  :qid |prog.$w_div_nat_ordered_by_dividend|)))
(assert (forall ((i $Int) (j $Int) (k $Int)) (!
  (=>
    (and
      (and
        (>= ($unwrap<Int> i) 0)
        (and (> ($unwrap<Int> j) 0) (> ($unwrap<Int> k) 0)))
      (<= ($unwrap<Int> j) ($unwrap<Int> k)))
    (>=
      ($unwrap<Int> ($w_div_nat<$Int> i j))
      ($unwrap<Int> ($w_div_natL<$Int> i k))))
  :pattern (($w_div_nat<$Int> i j) ($w_div_nat<$Int> i k))
  :qid |prog.$w_div_nat_ordered_by_divisor|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (and (> ($unwrap<Int> i) 0) (> ($unwrap<Int> j) 1))
    (< ($unwrap<Int> ($w_div_nat<$Int> i j)) ($unwrap<Int> i)))
  :pattern (($w_div_nat<$Int> i j))
  :qid |prog.$w_div_nat_decrease|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (and (>= ($unwrap<Int> i) 0) (> ($unwrap<Int> j) 0))
    (<= ($unwrap<Int> ($w_div_nat<$Int> i j)) ($unwrap<Int> i)))
  :pattern (($w_div_nat<$Int> i j))
  :qid |prog.$w_div_nat_nonincrease|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=> (not (= ($unwrap<Int> j) 0)) (= ($w_div<$Int> ($w_mulI<$Int> i j) j) i))
  :pattern (($w_div<$Int> ($w_mulI<$Int> i j) j))
  :qid |prog.$w_div_mul|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (not (= ($unwrap<Int> j) 0))
    (or
      (=
        ($sign<Int> ($unwrap<Int> ($w_div<$Int> i j)))
        (* ($sign<Int> ($unwrap<Int> i)) ($sign<Int> ($unwrap<Int> j))))
      (= ($sign<Int> ($unwrap<Int> ($w_div<$Int> i j))) 0)))
  :pattern (($w_div<$Int> i j))
  :qid |prog.$w_div_sign|)))
(assert (forall ((i $Int) (j $Int)) (!
  (=>
    (not (= ($unwrap<Int> j) 0))
    (=
      ($unwrap<Int> i)
      (+
        ($unwrap<Int> ($w_mulI<$Int> j ($w_div<$Int> i j)))
        ($unwrap<Int> ($w_mod<$Int> i j)))))
  :pattern (($w_div<$Int> i j) ($w_mod<$Int> i j))
  :qid |prog.$w_div_mod_mul|)))
(assert (forall (($arg_0 Int) ($arg_1 Int)) (!
  (and
    (=
      ($struct_get<Int> ($struct_loc<Int> (s$struct$EtherTokenPair$init<$Struct> $arg_0 $arg_1) (- 0 1)))
      11028449636546951172565373718758303580017951889227344242)
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> (s$struct$EtherTokenPair$init<$Struct> $arg_0 $arg_1) 0))
        $arg_0)
      (=
        ($struct_get<Int> ($struct_loc<Int> (s$struct$EtherTokenPair$init<$Struct> $arg_0 $arg_1) 1))
        $arg_1)))
  :pattern ((s$struct$EtherTokenPair$init<$Struct> $arg_0 $arg_1))
  :qid |prog.s$struct$EtherTokenPair$init$ax|)))
(assert (forall (($l $Struct) ($r $Struct)) (!
  (and
    (= (s$struct$EtherTokenPair$eq<Bool> $l $r) (= $l $r))
    (=
      (s$struct$EtherTokenPair$eq<Bool> $l $r)
      (and
        (=
          ($struct_get<Int> ($struct_loc<Int> $l (- 0 1)))
          ($struct_get<Int> ($struct_loc<Int> $r (- 0 1))))
        (and
          (=
            ($struct_get<Int> ($struct_loc<Int> $l 0))
            ($struct_get<Int> ($struct_loc<Int> $r 0)))
          (=
            ($struct_get<Int> ($struct_loc<Int> $l 1))
            ($struct_get<Int> ($struct_loc<Int> $r 1)))))))
  :pattern ((s$struct$EtherTokenPair$eq<Bool> $l $r))
  :qid |prog.s$struct$EtherTokenPair$eq$ax|)))
(assert (forall (($v Int) ($k Int)) (!
  (= ($map_get<Int> ($map_init<$Map<Int~_Int>> $v) $k) $v)
  :pattern (($map_get<Int> ($map_init<$Map<Int~_Int>> $v) $k))
  :qid |prog.$map_init_ax|)))
(assert (forall (($m $Map<Int~_Int>) ($n $Map<Int~_Int>)) (!
  (and
    (= ($map_eq<Bool> $m $n) (= $m $n))
    (=
      ($map_eq<Bool> $m $n)
      (forall (($k Int)) (!
        (= ($map_get<Int> $m $k) ($map_get<Int> $n $k))
        :pattern (($map_get<Int> $m $k) ($map_get<Int> $n $k))
        ))))
  :pattern (($map_eq<Bool> $m $n))
  :qid |prog.$map_eq_ax|)))
(assert (forall (($m $Map<Int~_Int>) ($k Int) ($v Int) ($kk Int)) (!
  (=
    ($map_get<Int> ($map_set<$Map<Int~_Int>> $m $k $v) $kk)
    (ite (= $k $kk) $v ($map_get<Int> $m $kk)))
  :pattern (($map_get<Int> ($map_set<$Map<Int~_Int>> $m $k $v) $kk))
  :qid |prog.$map_set_ax|)))
(assert (and
  (= ($sign<Int> 0) 0)
  (forall (($a Int)) (!
    (and
      (=> (> $a 0) (= ($sign<Int> $a) 1))
      (=> (< $a 0) (= ($sign<Int> $a) (- 0 1))))
    :pattern (($sign<Int> $a))
    ))))
(assert (forall (($a Int) ($b Int) ($r Int)) (!
  (=
    ($div<Int> $a $b $r)
    (+ (div $a $b) (ite (or (>= $a 0) (= (mod $a $b) 0)) 0 ($sign<Int> $b))))
  :pattern (($div<Int> $a $b $r))
  :qid |prog.$div_ax|)))
(assert (forall (($a Int) ($b Int) ($r Int)) (!
  (= ($mod<Int> $a $b $r) (- $a (* ($div<Int> $a $b $r) $b)))
  :pattern (($mod<Int> $a $b $r))
  :qid |prog.$mod_ax|)))
(assert (forall (($a Int)) (!
  (=> (not (= $a 0)) (= ($pow<Int> 0 $a) 0))
  :pattern (($pow<Int> 0 $a))
  :qid |prog.$pow0N_ax|)))
(assert (forall (($a Int)) (!
  (=> (not (= $a 0)) (= ($pow<Int> $a 0) 1))
  :pattern (($pow<Int> $a 0))
  :qid |prog.$powN0_ax|)))
(assert (forall (($a Int) ($b Int)) (!
  (=> (>= $a 0) (>= ($pow<Int> $a $b) 0))
  :pattern (($pow<Int> $a $b))
  :qid |prog.$pow_non_negative_ax|)))
(assert (forall (($a Int) ($b Int)) (!
  (=> (and (> $a 0) (>= $b 0)) (> ($pow<Int> $a $b) 0))
  :pattern (($pow<Int> $a $b))
  :qid |prog.$pow_non_negative_and_non_null_ax|)))
(assert (forall (($a Int) ($s Int)) (!
  (=>
    (> $s 0)
    (= ($floor<Int> $a $s) ($div<Int> (ite (< $a 0) (- $a (- $s 1)) $a) $s 0)))
  :pattern (($floor<Int> $a $s))
  :qid |prog.$floor_ax|)))
(assert (forall (($a Int) ($s Int)) (!
  (=>
    (> $s 0)
    (= ($ceil<Int> $a $s) ($div<Int> (ite (< $a 0) $a (- (+ $a $s) 1)) $s 0)))
  :pattern (($ceil<Int> $a $s))
  :qid |prog.$ceil_ax|)))
(assert (forall (($a Int) ($s Int)) (!
  (>= ($shift<Int> $a $s) 0)
  :pattern (($shift<Int> $a $s))
  :qid |prog.$shift_ax|)))
(assert (forall (($a Int)) (!
  (>= ($bitwise_not<Int> $a) 0)
  :pattern (($bitwise_not<Int> $a))
  :qid |prog.$bitwise_not_ax|)))
(assert (forall (($a Int) ($b Int)) (!
  (>= ($bitwise_and<Int> $a $b) 0)
  :pattern (($bitwise_and<Int> $a $b))
  :qid |prog.$bitwise_and_ax|)))
(assert (forall (($a Int) ($b Int)) (!
  (>= ($bitwise_or<Int> $a $b) 0)
  :pattern (($bitwise_or<Int> $a $b))
  :qid |prog.$bitwise_or_ax|)))
(assert (forall (($a Int) ($b Int)) (!
  (>= ($bitwise_xor<Int> $a $b) 0)
  :pattern (($bitwise_xor<Int> $a $b))
  :qid |prog.$bitwise_xor_ax|)))
(assert (not (= (as $self_address<Int>  Int) 0)))
(assert (forall (($s $Struct) ($m Int) ($t $Map<Int~_$Map<Int~_Int>>)) (!
  (=
    ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
    $t)
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
  :qid |prog.$get_set_0_ax|)))
(assert (forall (($s $Struct) ($m Int) ($n Int) ($t $Map<Int~_$Map<Int~_Int>>)) (!
  (=>
    (not (= $m $n))
    (=
      ($struct_loc<Int> $s $m)
      ($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m)))
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m))
  :qid |prog.$get_set_1_ax|)))
(assert (forall (($s $Struct) ($m Int) ($t $Struct)) (!
  (=
    ($struct_get<$Struct> ($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
    $t)
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
  :qid |prog.$get_set_0_ax|)))
(assert (forall (($s $Struct) ($m Int) ($n Int) ($t $Struct)) (!
  (=>
    (not (= $m $n))
    (=
      ($struct_loc<Int> $s $m)
      ($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m)))
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m))
  :qid |prog.$get_set_1_ax|)))
(assert (forall (($f Int) ($t Int)) (!
  (= (Seq_length ($range<Seq<Int>> $f $t)) (- $t $f))
  :pattern ((Seq_length ($range<Seq<Int>> $f $t)))
  :qid |prog.$range_len_ax|)))
(assert (forall (($f Int) ($t Int) ($i Int)) (!
  (=>
    (and (<= 0 $i) (< $i (Seq_length ($range<Seq<Int>> $f $t))))
    (= (Seq_index ($range<Seq<Int>> $f $t) $i) (+ $f $i)))
  :pattern ((Seq_index ($range<Seq<Int>> $f $t) $i))
  :qid |prog.$range_lookup_ax|)))
(assert (forall (($s $Struct) ($m Int) ($t $Map<Int~_Int>)) (!
  (=
    ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
    $t)
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
  :qid |prog.$get_set_0_ax|)))
(assert (forall (($s $Struct) ($m Int) ($n Int) ($t $Map<Int~_Int>)) (!
  (=>
    (not (= $m $n))
    (=
      ($struct_loc<Int> $s $m)
      ($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m)))
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m))
  :qid |prog.$get_set_1_ax|)))
(assert (forall (($s $Struct) ($m Int) ($t Seq<Int>)) (!
  (Seq_equal
    ($struct_get<Seq<Int>> ($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
    $t)
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $m $t) $m))
  :qid |prog.$get_set_0_ax|)))
(assert (forall (($s $Struct) ($m Int) ($n Int) ($t Seq<Int>)) (!
  (=>
    (not (= $m $n))
    (=
      ($struct_loc<Int> $s $m)
      ($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m)))
  :pattern (($struct_loc<Int> ($struct_set<$Struct> $s $n $t) $m))
  :qid |prog.$get_set_1_ax|)))
(assert (forall (($arg_0 $Struct)) (!
  (and
    (=
      ($struct_get<Int> ($struct_loc<Int> (s$resource$$creator$init<$Struct> $arg_0) (- 0 1)))
      2567760667165796382711201132846784524754120562)
    (=
      ($struct_get<$Struct> ($struct_loc<Int> (s$resource$$creator$init<$Struct> $arg_0) 0))
      $arg_0))
  :pattern ((s$resource$$creator$init<$Struct> $arg_0))
  :qid |prog.s$resource$$creator$init$ax|)))
(assert (forall (($l $Struct) ($r $Struct)) (!
  (and
    (= (s$resource$$creator$eq<Bool> $l $r) (= $l $r))
    (=
      (s$resource$$creator$eq<Bool> $l $r)
      (and
        (=
          ($struct_get<Int> ($struct_loc<Int> $l (- 0 1)))
          ($struct_get<Int> ($struct_loc<Int> $r (- 0 1))))
        (=
          ($struct_get<$Struct> ($struct_loc<Int> $l 0))
          ($struct_get<$Struct> ($struct_loc<Int> $r 0))))))
  :pattern ((s$resource$$creator$eq<Bool> $l $r))
  :qid |prog.s$resource$$creator$eq$ax|)))
(assert (= ($map_sum<Int> ($map_init<$Map<Int~_Int>> 0)) 0))
(assert (forall (($m $Map<Int~_Int>) ($k Int) ($v Int)) (!
  (=
    ($map_sum<Int> ($map_set<$Map<Int~_Int>> $m $k $v))
    (+ (- ($map_sum<Int> $m) ($map_get<Int> $m $k)) $v))
  :pattern (($map_sum<Int> ($map_set<$Map<Int~_Int>> $m $k $v)))
  :qid |prog.$map_sum_set_ax|)))
; /predicate_snap_functions_axioms.smt2 [e$TokenPurchase: Snap]
(assert (forall ((vs $PSF<e$TokenPurchase>) (ws $PSF<e$TokenPurchase>)) (!
    (=>
      (and
        (Set_equal ($PSF.domain_e$TokenPurchase vs) ($PSF.domain_e$TokenPurchase ws))
        (forall ((x $Snap)) (!
          (=>
            (Set_in x ($PSF.domain_e$TokenPurchase vs))
            (= ($PSF.lookup_e$TokenPurchase vs x) ($PSF.lookup_e$TokenPurchase ws x)))
          :pattern (($PSF.lookup_e$TokenPurchase vs x) ($PSF.lookup_e$TokenPurchase ws x))
          :qid |qp.$PSF<e$TokenPurchase>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$PSF<e$TokenPurchase>To$Snap vs)
              ($SortWrappers.$PSF<e$TokenPurchase>To$Snap ws)
              )
    :qid |qp.$PSF<e$TokenPurchase>-eq-outer|
    )))
(assert (forall ((s $Snap) (pm $PPM)) (!
    ($Perm.isValidVar ($PSF.perm_e$TokenPurchase pm s))
    :pattern (($PSF.perm_e$TokenPurchase pm s)))))
(assert (forall ((s $Snap) (f $Snap)) (!
    (= ($PSF.loc_e$TokenPurchase f s) true)
    :pattern (($PSF.loc_e$TokenPurchase f s)))))
; /predicate_snap_functions_axioms.smt2 [e$EthPurchase: Snap]
(assert (forall ((vs $PSF<e$EthPurchase>) (ws $PSF<e$EthPurchase>)) (!
    (=>
      (and
        (Set_equal ($PSF.domain_e$EthPurchase vs) ($PSF.domain_e$EthPurchase ws))
        (forall ((x $Snap)) (!
          (=>
            (Set_in x ($PSF.domain_e$EthPurchase vs))
            (= ($PSF.lookup_e$EthPurchase vs x) ($PSF.lookup_e$EthPurchase ws x)))
          :pattern (($PSF.lookup_e$EthPurchase vs x) ($PSF.lookup_e$EthPurchase ws x))
          :qid |qp.$PSF<e$EthPurchase>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$PSF<e$EthPurchase>To$Snap vs)
              ($SortWrappers.$PSF<e$EthPurchase>To$Snap ws)
              )
    :qid |qp.$PSF<e$EthPurchase>-eq-outer|
    )))
(assert (forall ((s $Snap) (pm $PPM)) (!
    ($Perm.isValidVar ($PSF.perm_e$EthPurchase pm s))
    :pattern (($PSF.perm_e$EthPurchase pm s)))))
(assert (forall ((s $Snap) (f $Snap)) (!
    (= ($PSF.loc_e$EthPurchase f s) true)
    :pattern (($PSF.loc_e$EthPurchase f s)))))
; /predicate_snap_functions_axioms.smt2 [e$AddLiquidity: Snap]
(assert (forall ((vs $PSF<e$AddLiquidity>) (ws $PSF<e$AddLiquidity>)) (!
    (=>
      (and
        (Set_equal ($PSF.domain_e$AddLiquidity vs) ($PSF.domain_e$AddLiquidity ws))
        (forall ((x $Snap)) (!
          (=>
            (Set_in x ($PSF.domain_e$AddLiquidity vs))
            (= ($PSF.lookup_e$AddLiquidity vs x) ($PSF.lookup_e$AddLiquidity ws x)))
          :pattern (($PSF.lookup_e$AddLiquidity vs x) ($PSF.lookup_e$AddLiquidity ws x))
          :qid |qp.$PSF<e$AddLiquidity>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$PSF<e$AddLiquidity>To$Snap vs)
              ($SortWrappers.$PSF<e$AddLiquidity>To$Snap ws)
              )
    :qid |qp.$PSF<e$AddLiquidity>-eq-outer|
    )))
(assert (forall ((s $Snap) (pm $PPM)) (!
    ($Perm.isValidVar ($PSF.perm_e$AddLiquidity pm s))
    :pattern (($PSF.perm_e$AddLiquidity pm s)))))
(assert (forall ((s $Snap) (f $Snap)) (!
    (= ($PSF.loc_e$AddLiquidity f s) true)
    :pattern (($PSF.loc_e$AddLiquidity f s)))))
; /predicate_snap_functions_axioms.smt2 [e$RemoveLiquidity: Snap]
(assert (forall ((vs $PSF<e$RemoveLiquidity>) (ws $PSF<e$RemoveLiquidity>)) (!
    (=>
      (and
        (Set_equal ($PSF.domain_e$RemoveLiquidity vs) ($PSF.domain_e$RemoveLiquidity ws))
        (forall ((x $Snap)) (!
          (=>
            (Set_in x ($PSF.domain_e$RemoveLiquidity vs))
            (= ($PSF.lookup_e$RemoveLiquidity vs x) ($PSF.lookup_e$RemoveLiquidity ws x)))
          :pattern (($PSF.lookup_e$RemoveLiquidity vs x) ($PSF.lookup_e$RemoveLiquidity ws x))
          :qid |qp.$PSF<e$RemoveLiquidity>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$PSF<e$RemoveLiquidity>To$Snap vs)
              ($SortWrappers.$PSF<e$RemoveLiquidity>To$Snap ws)
              )
    :qid |qp.$PSF<e$RemoveLiquidity>-eq-outer|
    )))
(assert (forall ((s $Snap) (pm $PPM)) (!
    ($Perm.isValidVar ($PSF.perm_e$RemoveLiquidity pm s))
    :pattern (($PSF.perm_e$RemoveLiquidity pm s)))))
(assert (forall ((s $Snap) (f $Snap)) (!
    (= ($PSF.loc_e$RemoveLiquidity f s) true)
    :pattern (($PSF.loc_e$RemoveLiquidity f s)))))
; /predicate_snap_functions_axioms.smt2 [e$Transfer: Snap]
(assert (forall ((vs $PSF<e$Transfer>) (ws $PSF<e$Transfer>)) (!
    (=>
      (and
        (Set_equal ($PSF.domain_e$Transfer vs) ($PSF.domain_e$Transfer ws))
        (forall ((x $Snap)) (!
          (=>
            (Set_in x ($PSF.domain_e$Transfer vs))
            (= ($PSF.lookup_e$Transfer vs x) ($PSF.lookup_e$Transfer ws x)))
          :pattern (($PSF.lookup_e$Transfer vs x) ($PSF.lookup_e$Transfer ws x))
          :qid |qp.$PSF<e$Transfer>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$PSF<e$Transfer>To$Snap vs)
              ($SortWrappers.$PSF<e$Transfer>To$Snap ws)
              )
    :qid |qp.$PSF<e$Transfer>-eq-outer|
    )))
(assert (forall ((s $Snap) (pm $PPM)) (!
    ($Perm.isValidVar ($PSF.perm_e$Transfer pm s))
    :pattern (($PSF.perm_e$Transfer pm s)))))
(assert (forall ((s $Snap) (f $Snap)) (!
    (= ($PSF.loc_e$Transfer f s) true)
    :pattern (($PSF.loc_e$Transfer f s)))))
; /predicate_snap_functions_axioms.smt2 [e$Approval: Snap]
(assert (forall ((vs $PSF<e$Approval>) (ws $PSF<e$Approval>)) (!
    (=>
      (and
        (Set_equal ($PSF.domain_e$Approval vs) ($PSF.domain_e$Approval ws))
        (forall ((x $Snap)) (!
          (=>
            (Set_in x ($PSF.domain_e$Approval vs))
            (= ($PSF.lookup_e$Approval vs x) ($PSF.lookup_e$Approval ws x)))
          :pattern (($PSF.lookup_e$Approval vs x) ($PSF.lookup_e$Approval ws x))
          :qid |qp.$PSF<e$Approval>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$PSF<e$Approval>To$Snap vs)
              ($SortWrappers.$PSF<e$Approval>To$Snap ws)
              )
    :qid |qp.$PSF<e$Approval>-eq-outer|
    )))
(assert (forall ((s $Snap) (pm $PPM)) (!
    ($Perm.isValidVar ($PSF.perm_e$Approval pm s))
    :pattern (($PSF.perm_e$Approval pm s)))))
(assert (forall ((s $Snap) (f $Snap)) (!
    (= ($PSF.loc_e$Approval f s) true)
    :pattern (($PSF.loc_e$Approval f s)))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun letvar@7@00 ($Snap Int Int) Bool)
(declare-fun letvar@8@00 ($Snap Int Int) Bool)
(declare-fun letvar@9@00 ($Snap Int Int) Int)
(declare-fun letvar@10@00 ($Snap Int Int) Int)
(assert (forall ((s@$ $Snap) (x@0@00 $Struct)) (!
  (= ($pure$success_get%limited s@$ x@0@00) ($pure$success_get s@$ x@0@00))
  :pattern (($pure$success_get s@$ x@0@00))
  :qid |quant-u-1568|)))
(assert (forall ((s@$ $Snap) (x@0@00 $Struct)) (!
  ($pure$success_get%stateless x@0@00)
  :pattern (($pure$success_get%limited s@$ x@0@00))
  :qid |quant-u-1569|)))
(assert (forall ((s@$ $Snap) (x@0@00 $Struct)) (!
  (=>
    ($pure$success_get%precondition s@$ x@0@00)
    (=
      ($pure$success_get s@$ x@0@00)
      ($struct_get<Bool> ($struct_loc<Int> x@0@00 0))))
  :pattern (($pure$success_get s@$ x@0@00))
  :qid |quant-u-1574|)))
(assert (forall ((s@$ $Snap) (x@0@00 $Struct)) (!
  true
  :pattern (($pure$success_get s@$ x@0@00))
  :qid |quant-u-1575|)))
(assert (forall ((s@$ $Snap) (x@2@00 $Struct)) (!
  (= ($pure$return_get%limited s@$ x@2@00) ($pure$return_get s@$ x@2@00))
  :pattern (($pure$return_get s@$ x@2@00))
  :qid |quant-u-1570|)))
(assert (forall ((s@$ $Snap) (x@2@00 $Struct)) (!
  ($pure$return_get%stateless x@2@00)
  :pattern (($pure$return_get%limited s@$ x@2@00))
  :qid |quant-u-1571|)))
(assert (forall ((s@$ $Snap) (x@2@00 $Struct)) (!
  (=>
    ($pure$return_get%precondition s@$ x@2@00)
    (= ($pure$return_get s@$ x@2@00) ($struct_loc<Int> x@2@00 1)))
  :pattern (($pure$return_get s@$ x@2@00))
  :qid |quant-u-1576|)))
(assert (forall ((s@$ $Snap) (x@2@00 $Struct)) (!
  true
  :pattern (($pure$return_get s@$ x@2@00))
  :qid |quant-u-1577|)))
(assert (forall ((s@$ $Snap) ($x@4@00 Int) ($y@5@00 Int)) (!
  (= ($range_sum%limited s@$ $x@4@00 $y@5@00) ($range_sum s@$ $x@4@00 $y@5@00))
  :pattern (($range_sum s@$ $x@4@00 $y@5@00))
  :qid |quant-u-1572|)))
(assert (forall ((s@$ $Snap) ($x@4@00 Int) ($y@5@00 Int)) (!
  ($range_sum%stateless $x@4@00 $y@5@00)
  :pattern (($range_sum%limited s@$ $x@4@00 $y@5@00))
  :qid |quant-u-1573|)))
(assert (forall ((s@$ $Snap) ($x@4@00 Int) ($y@5@00 Int)) (!
  (=>
    ($range_sum%precondition s@$ $x@4@00 $y@5@00)
    (=
      ($range_sum s@$ $x@4@00 $y@5@00)
      (let (($x_ge_0 (>= $x@4@00 0))) (let (($y_ge_0 (>= $y@5@00 0))) (let (($x_exclusive (ite
        $x_ge_0
        (div (* (- $x@4@00 1) $x@4@00) 2)
        (div (* (- (- 0 $x@4@00) 1) (- 0 $x@4@00)) 2)))) (let (($y_exclusive (ite
        $y_ge_0
        (div (* (- $y@5@00 1) $y@5@00) 2)
        (div (* (- (- 0 $y@5@00) 1) (- 0 $y@5@00)) 2)))) (ite
        (and $x_ge_0 $y_ge_0)
        (- $y_exclusive $x_exclusive)
        (ite
          (and (not $x_ge_0) $y_ge_0)
          (+ (- $y_exclusive $x_exclusive) $x@4@00)
          (+ (- (- $y_exclusive $y@5@00) $x_exclusive) $x@4@00)))))))))
  :pattern (($range_sum s@$ $x@4@00 $y@5@00))
  :qid |quant-u-1578|)))
(assert (forall ((s@$ $Snap) ($x@4@00 Int) ($y@5@00 Int)) (!
  (=>
    ($range_sum%precondition s@$ $x@4@00 $y@5@00)
    (let (($x_ge_0 (>= $x@4@00 0))) (let (($y_ge_0 (>= $y@5@00 0))) (let (($x_exclusive (ite
      $x_ge_0
      (div (* (- $x@4@00 1) $x@4@00) 2)
      (div (* (- (- 0 $x@4@00) 1) (- 0 $x@4@00)) 2)))) (let (($y_exclusive (ite
      $y_ge_0
      (div (* (- $y@5@00 1) $y@5@00) 2)
      (div (* (- (- 0 $y@5@00) 1) (- 0 $y@5@00)) 2)))) true)))))
  :pattern (($range_sum s@$ $x@4@00 $y@5@00))
  :qid |quant-u-1579|)))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- $transitivity_check ----------
(set-option :timeout 0)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var $self$0: $Struct
(declare-const $self$0@0@01 $Struct)
; [exec]
; var $$contracts$0: $Map[Int, $Struct]
(declare-const $$contracts$0@1@01 $Map<Int~_$Struct>)
; [exec]
; var $self$1: $Struct
(declare-const $self$1@2@01 $Struct)
; [exec]
; var $$contracts$1: $Map[Int, $Struct]
(declare-const $$contracts$1@3@01 $Map<Int~_$Struct>)
; [exec]
; var $self$2: $Struct
(declare-const $self$2@4@01 $Struct)
; [exec]
; var $$contracts$2: $Map[Int, $Struct]
(declare-const $$contracts$2@5@01 $Map<Int~_$Struct>)
; [exec]
; var block: $Struct
(declare-const block@6@01 $Struct)
; [exec]
; var $post: Bool
(declare-const $post@7@01 Bool)
; [exec]
; inhale |($struct_get($struct_loc($self$0, 0)): Seq[Int])| == 32
(declare-const $t@8@01 $Snap)
(assert (= $t@8@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($self$0, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($self$0, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc($self$0, 0)): Seq[Int])
; [eval] $struct_loc($self$0, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $self$0@0@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc($self$0, 1)): Seq[Int])| == 32
(declare-const $t@9@01 $Snap)
(assert (= $t@9@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($self$0, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($self$0, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc($self$0, 1)): Seq[Int])
; [eval] $struct_loc($self$0, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $self$0@0@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$0, 2)): Int) &&
;   ($struct_get($struct_loc($self$0, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@10@01 $Snap)
(assert (= $t@10@01 ($Snap.combine ($Snap.first $t@10@01) ($Snap.second $t@10@01))))
(assert (= ($Snap.first $t@10@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$0, 2)): Int)
; [eval] ($struct_get($struct_loc($self$0, 2)): Int)
; [eval] $struct_loc($self$0, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 2))))
(assert (= ($Snap.second $t@10@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$0, 2)): Int)
; [eval] $struct_loc($self$0, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$0, 3)): Int) &&
;   ($struct_get($struct_loc($self$0, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@11@01 $Snap)
(assert (= $t@11@01 ($Snap.combine ($Snap.first $t@11@01) ($Snap.second $t@11@01))))
(assert (= ($Snap.first $t@11@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$0, 3)): Int)
; [eval] ($struct_get($struct_loc($self$0, 3)): Int)
; [eval] $struct_loc($self$0, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 3))))
(assert (= ($Snap.second $t@11@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$0, 3)): Int)
; [eval] $struct_loc($self$0, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@12@01 $Snap)
(assert (= $t@12@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@13@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 4)
(push) ; 4
; [then-branch: 0 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 4)), $q2@13@01)) | live]
; [else-branch: 0 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 4)), $q2@13@01) | live]
(push) ; 5
; [then-branch: 0 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 4)), $q2@13@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@13@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 0 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 4)), $q2@13@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@13@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@13@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@13@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@13@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@13@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@13@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@13@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@797@11@797@354-aux|)))
(assert (forall (($q2@13@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@13@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@13@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@13@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@797@11@797@354|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])): Int))
(declare-const $t@14@01 $Snap)
(assert (= $t@14@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])): Int))
(declare-const $q2@15@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 4)
; [eval] ($map_sum(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@15@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@15@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 4)) $q2@15@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@798@11@798@262|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@16@01 $Snap)
(assert (= $t@16@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@17@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@18@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$0, 5)
(push) ; 5
; [then-branch: 1 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$0@0@01, 5)), $q3@17@01), $q4@18@01)) | live]
; [else-branch: 1 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$0@0@01, 5)), $q3@17@01), $q4@18@01) | live]
(push) ; 6
; [then-branch: 1 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$0@0@01, 5)), $q3@17@01), $q4@18@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 1 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$0@0@01, 5)), $q3@17@01), $q4@18@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$0, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@18@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@799@134@799@609-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@17@01 Int)) (!
  (forall (($q4@18@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@799@134@799@609-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@799@11@799@610-aux|)))
(assert (forall (($q3@17@01 Int)) (!
  (forall (($q4@18@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01) $q4@18@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@799@134@799@609|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@17@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@799@11@799@610|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@19@01 $Snap)
(assert (= $t@19@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@20@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@21@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$0, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$0, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@20@01 Int)) (!
  (forall (($q4@21@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@20@01) $q4@21@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@20@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@20@01) $q4@21@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@800@134@800@517|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@0@01 5)) $q3@20@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@800@11@800@518|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$0, 6)): Int) &&
;   ($struct_get($struct_loc($self$0, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@22@01 $Snap)
(assert (= $t@22@01 ($Snap.combine ($Snap.first $t@22@01) ($Snap.second $t@22@01))))
(assert (= ($Snap.first $t@22@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$0, 6)): Int)
; [eval] ($struct_get($struct_loc($self$0, 6)): Int)
; [eval] $struct_loc($self$0, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 6))))
(assert (= ($Snap.second $t@22@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($self$0, 6)): Int)
; [eval] $struct_loc($self$0, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$0, 7)): Int) &&
;   ($struct_get($struct_loc($self$0, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@23@01 $Snap)
(assert (= $t@23@01 ($Snap.combine ($Snap.first $t@23@01) ($Snap.second $t@23@01))))
(assert (= ($Snap.first $t@23@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$0, 7)): Int)
; [eval] ($struct_get($struct_loc($self$0, 7)): Int)
; [eval] $struct_loc($self$0, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 7))))
(assert (= ($Snap.second $t@23@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($self$0, 7)): Int)
; [eval] $struct_loc($self$0, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$0, 8)): Int) &&
;   ($struct_get($struct_loc($self$0, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@24@01 $Snap)
(assert (= $t@24@01 ($Snap.combine ($Snap.first $t@24@01) ($Snap.second $t@24@01))))
(assert (= ($Snap.first $t@24@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$0, 8)): Int)
; [eval] ($struct_get($struct_loc($self$0, 8)): Int)
; [eval] $struct_loc($self$0, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 8))))
(assert (= ($Snap.second $t@24@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$0, 8)): Int)
; [eval] $struct_loc($self$0, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc($self$0, 9)): Int) &&
;   ($struct_get($struct_loc($self$0, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@25@01 $Snap)
(assert (= $t@25@01 ($Snap.combine ($Snap.first $t@25@01) ($Snap.second $t@25@01))))
(assert (= ($Snap.first $t@25@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($self$0, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc($self$0, 9)): Int)
; [eval] $struct_loc($self$0, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 9))))
(assert (= ($Snap.second $t@25@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc($self$0, 9)): Int)
; [eval] $struct_loc($self$0, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@26@01 $Snap)
(assert (= $t@26@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@27@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
(push) ; 4
; [then-branch: 2 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 11)), $q5@27@01)) | live]
; [else-branch: 2 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 11)), $q5@27@01) | live]
(push) ; 5
; [then-branch: 2 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 11)), $q5@27@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@27@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 2 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 11)), $q5@27@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@27@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@27@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@27@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@27@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@27@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@27@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@27@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@805@11@805@357-aux|)))
(assert (forall (($q5@27@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@27@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@27@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@27@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@805@11@805@357|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])): Int))
(declare-const $t@28@01 $Snap)
(assert (= $t@28@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])): Int))
(declare-const $q5@29@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
; [eval] ($map_sum(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@29@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@29@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $q5@29@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@806@11@806@265|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@30@01 $Snap)
(assert (= $t@30@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@31@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 12)
(push) ; 4
; [then-branch: 3 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 12)), $q6@31@01)) | live]
; [else-branch: 3 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 12)), $q6@31@01) | live]
(push) ; 5
; [then-branch: 3 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 12)), $q6@31@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@31@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 3 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@0@01, 12)), $q6@31@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@31@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@31@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@31@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@31@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@31@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@31@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@31@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@807@11@807@357-aux|)))
(assert (forall (($q6@31@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@31@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@31@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@31@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@807@11@807@357|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])): Int))
(declare-const $t@32@01 $Snap)
(assert (= $t@32@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])): Int))
(declare-const $q6@33@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 12)
; [eval] ($map_sum(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@33@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@33@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 12)) $q6@33@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@808@11@808@265|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc($self$0, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@34@01 $Snap)
(assert (= $t@34@01 $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc($self$0, -1)): Int)
; [eval] $struct_loc($self$0, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> $self$0@0@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc($self$1, 0)): Seq[Int])| == 32
(declare-const $t@35@01 $Snap)
(assert (= $t@35@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($self$1, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($self$1, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc($self$1, 0)): Seq[Int])
; [eval] $struct_loc($self$1, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $self$1@2@01 0))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc($self$1, 1)): Seq[Int])| == 32
(declare-const $t@36@01 $Snap)
(assert (= $t@36@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($self$1, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($self$1, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc($self$1, 1)): Seq[Int])
; [eval] $struct_loc($self$1, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $self$1@2@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$1, 2)): Int) &&
;   ($struct_get($struct_loc($self$1, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@37@01 $Snap)
(assert (= $t@37@01 ($Snap.combine ($Snap.first $t@37@01) ($Snap.second $t@37@01))))
(assert (= ($Snap.first $t@37@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$1, 2)): Int)
; [eval] ($struct_get($struct_loc($self$1, 2)): Int)
; [eval] $struct_loc($self$1, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 2))))
(assert (= ($Snap.second $t@37@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$1, 2)): Int)
; [eval] $struct_loc($self$1, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$1, 3)): Int) &&
;   ($struct_get($struct_loc($self$1, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@38@01 $Snap)
(assert (= $t@38@01 ($Snap.combine ($Snap.first $t@38@01) ($Snap.second $t@38@01))))
(assert (= ($Snap.first $t@38@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$1, 3)): Int)
; [eval] ($struct_get($struct_loc($self$1, 3)): Int)
; [eval] $struct_loc($self$1, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 3))))
(assert (= ($Snap.second $t@38@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$1, 3)): Int)
; [eval] $struct_loc($self$1, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@39@01 $Snap)
(assert (= $t@39@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@40@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 4)
(push) ; 4
; [then-branch: 4 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 4)), $q2@40@01)) | live]
; [else-branch: 4 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 4)), $q2@40@01) | live]
(push) ; 5
; [then-branch: 4 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 4)), $q2@40@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@40@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 4 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 4)), $q2@40@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@40@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@40@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@40@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@40@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@40@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@40@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@40@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@814@11@814@354-aux|)))
(assert (forall (($q2@40@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@40@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@40@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@40@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@814@11@814@354|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])): Int))
(declare-const $t@41@01 $Snap)
(assert (= $t@41@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])): Int))
(declare-const $q2@42@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 4)
; [eval] ($map_sum(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@42@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@42@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 4)) $q2@42@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@815@11@815@262|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@43@01 $Snap)
(assert (= $t@43@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@44@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@45@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$1, 5)
(push) ; 5
; [then-branch: 5 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$1@2@01, 5)), $q3@44@01), $q4@45@01)) | live]
; [else-branch: 5 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$1@2@01, 5)), $q3@44@01), $q4@45@01) | live]
(push) ; 6
; [then-branch: 5 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$1@2@01, 5)), $q3@44@01), $q4@45@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 5 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$1@2@01, 5)), $q3@44@01), $q4@45@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$1, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@45@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@816@134@816@609-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@44@01 Int)) (!
  (forall (($q4@45@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@816@134@816@609-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@816@11@816@610-aux|)))
(assert (forall (($q3@44@01 Int)) (!
  (forall (($q4@45@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01) $q4@45@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@816@134@816@609|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@44@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@816@11@816@610|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@46@01 $Snap)
(assert (= $t@46@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@47@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@48@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$1, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$1, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@47@01 Int)) (!
  (forall (($q4@48@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@47@01) $q4@48@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@47@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@47@01) $q4@48@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@817@134@817@517|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@2@01 5)) $q3@47@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@817@11@817@518|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$1, 6)): Int) &&
;   ($struct_get($struct_loc($self$1, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@49@01 $Snap)
(assert (= $t@49@01 ($Snap.combine ($Snap.first $t@49@01) ($Snap.second $t@49@01))))
(assert (= ($Snap.first $t@49@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$1, 6)): Int)
; [eval] ($struct_get($struct_loc($self$1, 6)): Int)
; [eval] $struct_loc($self$1, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 6))))
(assert (= ($Snap.second $t@49@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($self$1, 6)): Int)
; [eval] $struct_loc($self$1, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$1, 7)): Int) &&
;   ($struct_get($struct_loc($self$1, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@50@01 $Snap)
(assert (= $t@50@01 ($Snap.combine ($Snap.first $t@50@01) ($Snap.second $t@50@01))))
(assert (= ($Snap.first $t@50@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$1, 7)): Int)
; [eval] ($struct_get($struct_loc($self$1, 7)): Int)
; [eval] $struct_loc($self$1, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 7))))
(assert (= ($Snap.second $t@50@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($self$1, 7)): Int)
; [eval] $struct_loc($self$1, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$1, 8)): Int) &&
;   ($struct_get($struct_loc($self$1, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@51@01 $Snap)
(assert (= $t@51@01 ($Snap.combine ($Snap.first $t@51@01) ($Snap.second $t@51@01))))
(assert (= ($Snap.first $t@51@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$1, 8)): Int)
; [eval] ($struct_get($struct_loc($self$1, 8)): Int)
; [eval] $struct_loc($self$1, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 8))))
(assert (= ($Snap.second $t@51@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$1, 8)): Int)
; [eval] $struct_loc($self$1, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc($self$1, 9)): Int) &&
;   ($struct_get($struct_loc($self$1, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@52@01 $Snap)
(assert (= $t@52@01 ($Snap.combine ($Snap.first $t@52@01) ($Snap.second $t@52@01))))
(assert (= ($Snap.first $t@52@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($self$1, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc($self$1, 9)): Int)
; [eval] $struct_loc($self$1, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 9))))
(assert (= ($Snap.second $t@52@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc($self$1, 9)): Int)
; [eval] $struct_loc($self$1, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@53@01 $Snap)
(assert (= $t@53@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@54@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
(push) ; 4
; [then-branch: 6 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 11)), $q5@54@01)) | live]
; [else-branch: 6 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 11)), $q5@54@01) | live]
(push) ; 5
; [then-branch: 6 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 11)), $q5@54@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@54@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 6 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 11)), $q5@54@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@54@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@54@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@54@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@54@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@54@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@54@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@54@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@822@11@822@357-aux|)))
(assert (forall (($q5@54@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@54@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@54@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@54@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@822@11@822@357|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])): Int))
(declare-const $t@55@01 $Snap)
(assert (= $t@55@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])): Int))
(declare-const $q5@56@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
; [eval] ($map_sum(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@56@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@56@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $q5@56@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@823@11@823@265|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@57@01 $Snap)
(assert (= $t@57@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@58@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 12)
(push) ; 4
; [then-branch: 7 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 12)), $q6@58@01)) | live]
; [else-branch: 7 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 12)), $q6@58@01) | live]
(push) ; 5
; [then-branch: 7 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 12)), $q6@58@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@58@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 7 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@2@01, 12)), $q6@58@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@58@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@58@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@58@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@58@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@58@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@58@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@58@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@824@11@824@357-aux|)))
(assert (forall (($q6@58@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@58@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@58@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@58@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@824@11@824@357|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])): Int))
(declare-const $t@59@01 $Snap)
(assert (= $t@59@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])): Int))
(declare-const $q6@60@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 12)
; [eval] ($map_sum(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@60@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@60@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 12)) $q6@60@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@825@11@825@265|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc($self$1, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@61@01 $Snap)
(assert (= $t@61@01 $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc($self$1, -1)): Int)
; [eval] $struct_loc($self$1, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> $self$1@2@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc($self$2, 0)): Seq[Int])| == 32
(declare-const $t@62@01 $Snap)
(assert (= $t@62@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($self$2, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($self$2, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc($self$2, 0)): Seq[Int])
; [eval] $struct_loc($self$2, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $self$2@4@01 0))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc($self$2, 1)): Seq[Int])| == 32
(declare-const $t@63@01 $Snap)
(assert (= $t@63@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($self$2, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($self$2, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc($self$2, 1)): Seq[Int])
; [eval] $struct_loc($self$2, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $self$2@4@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$2, 2)): Int) &&
;   ($struct_get($struct_loc($self$2, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@64@01 $Snap)
(assert (= $t@64@01 ($Snap.combine ($Snap.first $t@64@01) ($Snap.second $t@64@01))))
(assert (= ($Snap.first $t@64@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$2, 2)): Int)
; [eval] ($struct_get($struct_loc($self$2, 2)): Int)
; [eval] $struct_loc($self$2, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 2))))
(assert (= ($Snap.second $t@64@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$2, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$2, 2)): Int)
; [eval] $struct_loc($self$2, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$2, 3)): Int) &&
;   ($struct_get($struct_loc($self$2, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@65@01 $Snap)
(assert (= $t@65@01 ($Snap.combine ($Snap.first $t@65@01) ($Snap.second $t@65@01))))
(assert (= ($Snap.first $t@65@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$2, 3)): Int)
; [eval] ($struct_get($struct_loc($self$2, 3)): Int)
; [eval] $struct_loc($self$2, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 3))))
(assert (= ($Snap.second $t@65@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$2, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$2, 3)): Int)
; [eval] $struct_loc($self$2, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@66@01 $Snap)
(assert (= $t@66@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@67@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$2, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 4)
(push) ; 4
; [then-branch: 8 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 4)), $q2@67@01)) | live]
; [else-branch: 8 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 4)), $q2@67@01) | live]
(push) ; 5
; [then-branch: 8 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 4)), $q2@67@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@67@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 8 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 4)), $q2@67@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@67@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$2, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@67@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@67@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@67@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@67@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@67@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@67@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@831@11@831@354-aux|)))
(assert (forall (($q2@67@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@67@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@67@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@67@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@831@11@831@354|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int])): Int))
(declare-const $t@68@01 $Snap)
(assert (= $t@68@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int])): Int))
(declare-const $q2@69@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$2, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 4)
; [eval] ($map_sum(($struct_get($struct_loc($self$2, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$2, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@69@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@69@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 4)) $q2@69@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@832@11@832@262|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@70@01 $Snap)
(assert (= $t@70@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@71@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@72@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$2, 5)
(push) ; 5
; [then-branch: 9 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$2@4@01, 5)), $q3@71@01), $q4@72@01)) | live]
; [else-branch: 9 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$2@4@01, 5)), $q3@71@01), $q4@72@01) | live]
(push) ; 6
; [then-branch: 9 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$2@4@01, 5)), $q3@71@01), $q4@72@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 9 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$2@4@01, 5)), $q3@71@01), $q4@72@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$2, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@72@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@833@134@833@609-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@71@01 Int)) (!
  (forall (($q4@72@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@833@134@833@609-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@833@11@833@610-aux|)))
(assert (forall (($q3@71@01 Int)) (!
  (forall (($q4@72@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01) $q4@72@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@833@134@833@609|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@71@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@833@11@833@610|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@73@01 $Snap)
(assert (= $t@73@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@74@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@75@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$2, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$2, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$2, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@74@01 Int)) (!
  (forall (($q4@75@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@74@01) $q4@75@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@74@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@74@01) $q4@75@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@834@134@834@517|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$2@4@01 5)) $q3@74@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@834@11@834@518|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$2, 6)): Int) &&
;   ($struct_get($struct_loc($self$2, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@76@01 $Snap)
(assert (= $t@76@01 ($Snap.combine ($Snap.first $t@76@01) ($Snap.second $t@76@01))))
(assert (= ($Snap.first $t@76@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$2, 6)): Int)
; [eval] ($struct_get($struct_loc($self$2, 6)): Int)
; [eval] $struct_loc($self$2, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 6))))
(assert (= ($Snap.second $t@76@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$2, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($self$2, 6)): Int)
; [eval] $struct_loc($self$2, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$2, 7)): Int) &&
;   ($struct_get($struct_loc($self$2, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@77@01 $Snap)
(assert (= $t@77@01 ($Snap.combine ($Snap.first $t@77@01) ($Snap.second $t@77@01))))
(assert (= ($Snap.first $t@77@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$2, 7)): Int)
; [eval] ($struct_get($struct_loc($self$2, 7)): Int)
; [eval] $struct_loc($self$2, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 7))))
(assert (= ($Snap.second $t@77@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$2, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($self$2, 7)): Int)
; [eval] $struct_loc($self$2, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$2, 8)): Int) &&
;   ($struct_get($struct_loc($self$2, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@78@01 $Snap)
(assert (= $t@78@01 ($Snap.combine ($Snap.first $t@78@01) ($Snap.second $t@78@01))))
(assert (= ($Snap.first $t@78@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$2, 8)): Int)
; [eval] ($struct_get($struct_loc($self$2, 8)): Int)
; [eval] $struct_loc($self$2, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 8))))
(assert (= ($Snap.second $t@78@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$2, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$2, 8)): Int)
; [eval] $struct_loc($self$2, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc($self$2, 9)): Int) &&
;   ($struct_get($struct_loc($self$2, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@79@01 $Snap)
(assert (= $t@79@01 ($Snap.combine ($Snap.first $t@79@01) ($Snap.second $t@79@01))))
(assert (= ($Snap.first $t@79@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($self$2, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc($self$2, 9)): Int)
; [eval] $struct_loc($self$2, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 9))))
(assert (= ($Snap.second $t@79@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$2, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc($self$2, 9)): Int)
; [eval] $struct_loc($self$2, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@80@01 $Snap)
(assert (= $t@80@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@81@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$2, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 11)
(push) ; 4
; [then-branch: 10 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 11)), $q5@81@01)) | live]
; [else-branch: 10 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 11)), $q5@81@01) | live]
(push) ; 5
; [then-branch: 10 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 11)), $q5@81@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@81@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 10 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 11)), $q5@81@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@81@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$2, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@81@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@81@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@81@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@81@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@81@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@81@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@839@11@839@357-aux|)))
(assert (forall (($q5@81@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@81@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@81@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@81@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@839@11@839@357|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int])): Int))
(declare-const $t@82@01 $Snap)
(assert (= $t@82@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int])): Int))
(declare-const $q5@83@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$2, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 11)
; [eval] ($map_sum(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$2, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@83@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@83@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $q5@83@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@840@11@840@265|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@84@01 $Snap)
(assert (= $t@84@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@85@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$2, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 12)
(push) ; 4
; [then-branch: 11 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 12)), $q6@85@01)) | live]
; [else-branch: 11 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 12)), $q6@85@01) | live]
(push) ; 5
; [then-branch: 11 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 12)), $q6@85@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@85@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 11 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$2@4@01, 12)), $q6@85@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@85@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$2, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@85@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@85@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@85@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@85@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@85@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@85@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@841@11@841@357-aux|)))
(assert (forall (($q6@85@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@85@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@85@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@85@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@841@11@841@357|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int])): Int))
(declare-const $t@86@01 $Snap)
(assert (= $t@86@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int])): Int))
(declare-const $q6@87@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$2, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 12)
; [eval] ($map_sum(($struct_get($struct_loc($self$2, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$2, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@87@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@87@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 12)) $q6@87@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@842@11@842@265|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc($self$2, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@88@01 $Snap)
(assert (= $t@88@01 $Snap.unit))
; [eval] ($struct_get($struct_loc($self$2, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc($self$2, -1)): Int)
; [eval] $struct_loc($self$2, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> $self$2@4@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) &&
;   ($struct_get($struct_loc(block, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@89@01 $Snap)
(assert (= $t@89@01 ($Snap.combine ($Snap.first $t@89@01) ($Snap.second $t@89@01))))
(assert (= ($Snap.first $t@89@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 0)): Int)
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@6@01 0))))
(assert (= ($Snap.second $t@89@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@6@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) &&
;   ($struct_get($struct_loc(block, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@90@01 $Snap)
(assert (= $t@90@01 ($Snap.combine ($Snap.first $t@90@01) ($Snap.second $t@90@01))))
(assert (= ($Snap.first $t@90@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 1)): Int)
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@6@01 1))))
(assert (= ($Snap.second $t@90@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@6@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) &&
;   ($struct_get($struct_loc(block, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@91@01 $Snap)
(assert (= $t@91@01 ($Snap.combine ($Snap.first $t@91@01) ($Snap.second $t@91@01))))
(assert (= ($Snap.first $t@91@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 2)): Int)
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@6@01 2))))
(assert (= ($Snap.second $t@91@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@6@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
(declare-const $t@92@01 $Snap)
(assert (= $t@92@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])|
; [eval] ($struct_get($struct_loc(block, 3)): Seq[Int])
; [eval] $struct_loc(block, 3)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> block@6@01 3))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) &&
;   ($struct_get($struct_loc(block, 4)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@93@01 $Snap)
(assert (= $t@93@01 ($Snap.combine ($Snap.first $t@93@01) ($Snap.second $t@93@01))))
(assert (= ($Snap.first $t@93@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@6@01 4))))
(assert (= ($Snap.second $t@93@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@6@01 4))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(block, -1)): Int) ==
;   2335365049822495359383864865678187
(declare-const $t@94@01 $Snap)
(assert (= $t@94@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
; [eval] ($struct_get($struct_loc(block, -1)): Int)
; [eval] $struct_loc(block, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> block@6@01 (- 0 1)))
  2335365049822495359383864865678187))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@95@01 $Snap)
(assert (= $t@95@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@96@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@97@01 $Snap)
(assert (= $t@97@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@98@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($a@98@01 Int)) (!
  (>=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $a@98@01)
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@0@01 11)) $a@98@01))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $a@98@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@851@11@851@266|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@99@01 $Snap)
(assert (= $t@99@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@100@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$2, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($self$2, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$2, 11)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($a@100@01 Int)) (!
  (>=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $a@100@01)
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@2@01 11)) $a@100@01))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$2@4@01 11)) $a@100@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@852@11@852@266|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(pop) ; 2
(pop) ; 1
; ---------- $reflexivity_check ----------
(set-option :timeout 0)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var $self$0: $Struct
(declare-const $self$0@101@01 $Struct)
; [exec]
; var $$contracts$0: $Map[Int, $Struct]
(declare-const $$contracts$0@102@01 $Map<Int~_$Struct>)
; [exec]
; var $self$1: $Struct
(declare-const $self$1@103@01 $Struct)
; [exec]
; var $$contracts$1: $Map[Int, $Struct]
(declare-const $$contracts$1@104@01 $Map<Int~_$Struct>)
; [exec]
; var block: $Struct
(declare-const block@105@01 $Struct)
; [exec]
; var $post: Bool
(declare-const $post@106@01 Bool)
; [exec]
; inhale |($struct_get($struct_loc($self$0, 0)): Seq[Int])| == 32
(declare-const $t@107@01 $Snap)
(assert (= $t@107@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($self$0, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($self$0, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc($self$0, 0)): Seq[Int])
; [eval] $struct_loc($self$0, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $self$0@101@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc($self$0, 1)): Seq[Int])| == 32
(declare-const $t@108@01 $Snap)
(assert (= $t@108@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($self$0, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($self$0, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc($self$0, 1)): Seq[Int])
; [eval] $struct_loc($self$0, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $self$0@101@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$0, 2)): Int) &&
;   ($struct_get($struct_loc($self$0, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@109@01 $Snap)
(assert (= $t@109@01 ($Snap.combine ($Snap.first $t@109@01) ($Snap.second $t@109@01))))
(assert (= ($Snap.first $t@109@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$0, 2)): Int)
; [eval] ($struct_get($struct_loc($self$0, 2)): Int)
; [eval] $struct_loc($self$0, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 2))))
(assert (= ($Snap.second $t@109@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$0, 2)): Int)
; [eval] $struct_loc($self$0, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$0, 3)): Int) &&
;   ($struct_get($struct_loc($self$0, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@110@01 $Snap)
(assert (= $t@110@01 ($Snap.combine ($Snap.first $t@110@01) ($Snap.second $t@110@01))))
(assert (= ($Snap.first $t@110@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$0, 3)): Int)
; [eval] ($struct_get($struct_loc($self$0, 3)): Int)
; [eval] $struct_loc($self$0, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 3))))
(assert (= ($Snap.second $t@110@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$0, 3)): Int)
; [eval] $struct_loc($self$0, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@111@01 $Snap)
(assert (= $t@111@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@112@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 4)
(push) ; 4
; [then-branch: 12 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 4)), $q2@112@01)) | live]
; [else-branch: 12 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 4)), $q2@112@01) | live]
(push) ; 5
; [then-branch: 12 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 4)), $q2@112@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@112@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 12 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 4)), $q2@112@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@112@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@112@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@112@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@112@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@112@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@112@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@112@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@867@11@867@354-aux|)))
(assert (forall (($q2@112@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@112@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@112@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@112@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@867@11@867@354|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])): Int))
(declare-const $t@113@01 $Snap)
(assert (= $t@113@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])): Int))
(declare-const $q2@114@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 4)
; [eval] ($map_sum(($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$0, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@114@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@114@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 4)) $q2@114@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@868@11@868@262|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@115@01 $Snap)
(assert (= $t@115@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@116@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@117@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$0, 5)
(push) ; 5
; [then-branch: 13 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$0@101@01, 5)), $q3@116@01), $q4@117@01)) | live]
; [else-branch: 13 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$0@101@01, 5)), $q3@116@01), $q4@117@01) | live]
(push) ; 6
; [then-branch: 13 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$0@101@01, 5)), $q3@116@01), $q4@117@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 13 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$0@101@01, 5)), $q3@116@01), $q4@117@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$0, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@117@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@869@134@869@609-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@116@01 Int)) (!
  (forall (($q4@117@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@869@134@869@609-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@869@11@869@610-aux|)))
(assert (forall (($q3@116@01 Int)) (!
  (forall (($q4@117@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01) $q4@117@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@869@134@869@609|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@116@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@869@11@869@610|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@118@01 $Snap)
(assert (= $t@118@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@119@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@120@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$0, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$0, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$0, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@119@01 Int)) (!
  (forall (($q4@120@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@119@01) $q4@120@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@119@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@119@01) $q4@120@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@870@134@870@517|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$0@101@01 5)) $q3@119@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@870@11@870@518|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$0, 6)): Int) &&
;   ($struct_get($struct_loc($self$0, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@121@01 $Snap)
(assert (= $t@121@01 ($Snap.combine ($Snap.first $t@121@01) ($Snap.second $t@121@01))))
(assert (= ($Snap.first $t@121@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$0, 6)): Int)
; [eval] ($struct_get($struct_loc($self$0, 6)): Int)
; [eval] $struct_loc($self$0, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 6))))
(assert (= ($Snap.second $t@121@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($self$0, 6)): Int)
; [eval] $struct_loc($self$0, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$0, 7)): Int) &&
;   ($struct_get($struct_loc($self$0, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@122@01 $Snap)
(assert (= $t@122@01 ($Snap.combine ($Snap.first $t@122@01) ($Snap.second $t@122@01))))
(assert (= ($Snap.first $t@122@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$0, 7)): Int)
; [eval] ($struct_get($struct_loc($self$0, 7)): Int)
; [eval] $struct_loc($self$0, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 7))))
(assert (= ($Snap.second $t@122@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($self$0, 7)): Int)
; [eval] $struct_loc($self$0, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$0, 8)): Int) &&
;   ($struct_get($struct_loc($self$0, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@123@01 $Snap)
(assert (= $t@123@01 ($Snap.combine ($Snap.first $t@123@01) ($Snap.second $t@123@01))))
(assert (= ($Snap.first $t@123@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$0, 8)): Int)
; [eval] ($struct_get($struct_loc($self$0, 8)): Int)
; [eval] $struct_loc($self$0, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 8))))
(assert (= ($Snap.second $t@123@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$0, 8)): Int)
; [eval] $struct_loc($self$0, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc($self$0, 9)): Int) &&
;   ($struct_get($struct_loc($self$0, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@124@01 $Snap)
(assert (= $t@124@01 ($Snap.combine ($Snap.first $t@124@01) ($Snap.second $t@124@01))))
(assert (= ($Snap.first $t@124@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($self$0, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc($self$0, 9)): Int)
; [eval] $struct_loc($self$0, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 9))))
(assert (= ($Snap.second $t@124@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc($self$0, 9)): Int)
; [eval] $struct_loc($self$0, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@125@01 $Snap)
(assert (= $t@125@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@126@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
(push) ; 4
; [then-branch: 14 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 11)), $q5@126@01)) | live]
; [else-branch: 14 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 11)), $q5@126@01) | live]
(push) ; 5
; [then-branch: 14 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 11)), $q5@126@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@126@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 14 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 11)), $q5@126@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@126@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@126@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@126@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@126@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@126@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@126@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@126@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@875@11@875@357-aux|)))
(assert (forall (($q5@126@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@126@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@126@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@126@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@875@11@875@357|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])): Int))
(declare-const $t@127@01 $Snap)
(assert (= $t@127@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])): Int))
(declare-const $q5@128@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
; [eval] ($map_sum(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@128@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@128@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $q5@128@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@876@11@876@265|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@129@01 $Snap)
(assert (= $t@129@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@130@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 12)
(push) ; 4
; [then-branch: 15 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 12)), $q6@130@01)) | live]
; [else-branch: 15 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 12)), $q6@130@01) | live]
(push) ; 5
; [then-branch: 15 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 12)), $q6@130@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@130@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 15 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$0@101@01, 12)), $q6@130@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@130@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@130@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@130@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@130@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@130@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@130@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@130@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@877@11@877@357-aux|)))
(assert (forall (($q6@130@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@130@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@130@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@130@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@877@11@877@357|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])): Int))
(declare-const $t@131@01 $Snap)
(assert (= $t@131@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])): Int))
(declare-const $q6@132@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 12)
; [eval] ($map_sum(($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$0, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@132@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@132@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 12)) $q6@132@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@878@11@878@265|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc($self$0, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@133@01 $Snap)
(assert (= $t@133@01 $Snap.unit))
; [eval] ($struct_get($struct_loc($self$0, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc($self$0, -1)): Int)
; [eval] $struct_loc($self$0, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> $self$0@101@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc($self$1, 0)): Seq[Int])| == 32
(declare-const $t@134@01 $Snap)
(assert (= $t@134@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($self$1, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($self$1, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc($self$1, 0)): Seq[Int])
; [eval] $struct_loc($self$1, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $self$1@103@01 0))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc($self$1, 1)): Seq[Int])| == 32
(declare-const $t@135@01 $Snap)
(assert (= $t@135@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($self$1, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($self$1, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc($self$1, 1)): Seq[Int])
; [eval] $struct_loc($self$1, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $self$1@103@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$1, 2)): Int) &&
;   ($struct_get($struct_loc($self$1, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@136@01 $Snap)
(assert (= $t@136@01 ($Snap.combine ($Snap.first $t@136@01) ($Snap.second $t@136@01))))
(assert (= ($Snap.first $t@136@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$1, 2)): Int)
; [eval] ($struct_get($struct_loc($self$1, 2)): Int)
; [eval] $struct_loc($self$1, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 2))))
(assert (= ($Snap.second $t@136@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$1, 2)): Int)
; [eval] $struct_loc($self$1, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$1, 3)): Int) &&
;   ($struct_get($struct_loc($self$1, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@137@01 $Snap)
(assert (= $t@137@01 ($Snap.combine ($Snap.first $t@137@01) ($Snap.second $t@137@01))))
(assert (= ($Snap.first $t@137@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$1, 3)): Int)
; [eval] ($struct_get($struct_loc($self$1, 3)): Int)
; [eval] $struct_loc($self$1, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 3))))
(assert (= ($Snap.second $t@137@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$1, 3)): Int)
; [eval] $struct_loc($self$1, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@138@01 $Snap)
(assert (= $t@138@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@139@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 4)
(push) ; 4
; [then-branch: 16 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 4)), $q2@139@01)) | live]
; [else-branch: 16 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 4)), $q2@139@01) | live]
(push) ; 5
; [then-branch: 16 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 4)), $q2@139@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@139@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 16 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 4)), $q2@139@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@139@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@139@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@139@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@139@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@139@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@139@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@139@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@884@11@884@354-aux|)))
(assert (forall (($q2@139@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@139@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@139@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@139@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@884@11@884@354|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])): Int))
(declare-const $t@140@01 $Snap)
(assert (= $t@140@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])): Int))
(declare-const $q2@141@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 4)
; [eval] ($map_sum(($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$1, 4)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@141@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@141@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 4)) $q2@141@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@885@11@885@262|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@142@01 $Snap)
(assert (= $t@142@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@143@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@144@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$1, 5)
(push) ; 5
; [then-branch: 17 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$1@103@01, 5)), $q3@143@01), $q4@144@01)) | live]
; [else-branch: 17 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$1@103@01, 5)), $q3@143@01), $q4@144@01) | live]
(push) ; 6
; [then-branch: 17 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$1@103@01, 5)), $q3@143@01), $q4@144@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 17 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($self$1@103@01, 5)), $q3@143@01), $q4@144@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$1, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@144@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@886@134@886@609-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@143@01 Int)) (!
  (forall (($q4@144@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@886@134@886@609-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@886@11@886@610-aux|)))
(assert (forall (($q3@143@01 Int)) (!
  (forall (($q4@144@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01) $q4@144@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@886@134@886@609|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@143@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@886@11@886@610|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@145@01 $Snap)
(assert (= $t@145@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@146@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@147@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$1, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($self$1, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($self$1, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@146@01 Int)) (!
  (forall (($q4@147@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@146@01) $q4@147@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@146@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@146@01) $q4@147@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@887@134@887@517|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $self$1@103@01 5)) $q3@146@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@887@11@887@518|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$1, 6)): Int) &&
;   ($struct_get($struct_loc($self$1, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@148@01 $Snap)
(assert (= $t@148@01 ($Snap.combine ($Snap.first $t@148@01) ($Snap.second $t@148@01))))
(assert (= ($Snap.first $t@148@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$1, 6)): Int)
; [eval] ($struct_get($struct_loc($self$1, 6)): Int)
; [eval] $struct_loc($self$1, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 6))))
(assert (= ($Snap.second $t@148@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($self$1, 6)): Int)
; [eval] $struct_loc($self$1, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$1, 7)): Int) &&
;   ($struct_get($struct_loc($self$1, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@149@01 $Snap)
(assert (= $t@149@01 ($Snap.combine ($Snap.first $t@149@01) ($Snap.second $t@149@01))))
(assert (= ($Snap.first $t@149@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$1, 7)): Int)
; [eval] ($struct_get($struct_loc($self$1, 7)): Int)
; [eval] $struct_loc($self$1, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 7))))
(assert (= ($Snap.second $t@149@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($self$1, 7)): Int)
; [eval] $struct_loc($self$1, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($self$1, 8)): Int) &&
;   ($struct_get($struct_loc($self$1, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@150@01 $Snap)
(assert (= $t@150@01 ($Snap.combine ($Snap.first $t@150@01) ($Snap.second $t@150@01))))
(assert (= ($Snap.first $t@150@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($self$1, 8)): Int)
; [eval] ($struct_get($struct_loc($self$1, 8)): Int)
; [eval] $struct_loc($self$1, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 8))))
(assert (= ($Snap.second $t@150@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($self$1, 8)): Int)
; [eval] $struct_loc($self$1, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc($self$1, 9)): Int) &&
;   ($struct_get($struct_loc($self$1, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@151@01 $Snap)
(assert (= $t@151@01 ($Snap.combine ($Snap.first $t@151@01) ($Snap.second $t@151@01))))
(assert (= ($Snap.first $t@151@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($self$1, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc($self$1, 9)): Int)
; [eval] $struct_loc($self$1, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 9))))
(assert (= ($Snap.second $t@151@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc($self$1, 9)): Int)
; [eval] $struct_loc($self$1, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@152@01 $Snap)
(assert (= $t@152@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@153@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
(push) ; 4
; [then-branch: 18 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 11)), $q5@153@01)) | live]
; [else-branch: 18 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 11)), $q5@153@01) | live]
(push) ; 5
; [then-branch: 18 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 11)), $q5@153@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@153@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 18 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 11)), $q5@153@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@153@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@153@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@153@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@153@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@153@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@153@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@153@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@892@11@892@357-aux|)))
(assert (forall (($q5@153@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@153@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@153@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@153@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@892@11@892@357|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])): Int))
(declare-const $t@154@01 $Snap)
(assert (= $t@154@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])): Int))
(declare-const $q5@155@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
; [eval] ($map_sum(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@155@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@155@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $q5@155@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@893@11@893@265|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@156@01 $Snap)
(assert (= $t@156@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@157@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 12)
(push) ; 4
; [then-branch: 19 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 12)), $q6@157@01)) | live]
; [else-branch: 19 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 12)), $q6@157@01) | live]
(push) ; 5
; [then-branch: 19 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 12)), $q6@157@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@157@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 19 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($self$1@103@01, 12)), $q6@157@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@157@01)))
; [eval] ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@157@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@157@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@157@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@157@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@157@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@157@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@894@11@894@357-aux|)))
(assert (forall (($q6@157@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@157@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@157@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@157@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@894@11@894@357|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])): Int))
(declare-const $t@158@01 $Snap)
(assert (= $t@158@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])): Int))
(declare-const $q6@159@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 12)
; [eval] ($map_sum(($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($self$1, 12)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@159@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@159@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 12)) $q6@159@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@895@11@895@265|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc($self$1, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@160@01 $Snap)
(assert (= $t@160@01 $Snap.unit))
; [eval] ($struct_get($struct_loc($self$1, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc($self$1, -1)): Int)
; [eval] $struct_loc($self$1, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> $self$1@103@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) &&
;   ($struct_get($struct_loc(block, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@161@01 $Snap)
(assert (= $t@161@01 ($Snap.combine ($Snap.first $t@161@01) ($Snap.second $t@161@01))))
(assert (= ($Snap.first $t@161@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 0)): Int)
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@105@01 0))))
(assert (= ($Snap.second $t@161@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@105@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) &&
;   ($struct_get($struct_loc(block, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@162@01 $Snap)
(assert (= $t@162@01 ($Snap.combine ($Snap.first $t@162@01) ($Snap.second $t@162@01))))
(assert (= ($Snap.first $t@162@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 1)): Int)
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@105@01 1))))
(assert (= ($Snap.second $t@162@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@105@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) &&
;   ($struct_get($struct_loc(block, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@163@01 $Snap)
(assert (= $t@163@01 ($Snap.combine ($Snap.first $t@163@01) ($Snap.second $t@163@01))))
(assert (= ($Snap.first $t@163@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 2)): Int)
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@105@01 2))))
(assert (= ($Snap.second $t@163@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@105@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
(declare-const $t@164@01 $Snap)
(assert (= $t@164@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])|
; [eval] ($struct_get($struct_loc(block, 3)): Seq[Int])
; [eval] $struct_loc(block, 3)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> block@105@01 3))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) &&
;   ($struct_get($struct_loc(block, 4)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@165@01 $Snap)
(assert (= $t@165@01 ($Snap.combine ($Snap.first $t@165@01) ($Snap.second $t@165@01))))
(assert (= ($Snap.first $t@165@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@105@01 4))))
(assert (= ($Snap.second $t@165@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@105@01 4))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(block, -1)): Int) ==
;   2335365049822495359383864865678187
(declare-const $t@166@01 $Snap)
(assert (= $t@166@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
; [eval] ($struct_get($struct_loc(block, -1)): Int)
; [eval] $struct_loc(block, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> block@105@01 (- 0 1)))
  2335365049822495359383864865678187))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@167@01 $Snap)
(assert (= $t@167@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@168@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc($self$1, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($self$1, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$1, 11)
; [eval] ($map_get(($struct_get($struct_loc($self$0, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($self$0, 11)): $Map[Int, Int])
; [eval] $struct_loc($self$0, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($a@168@01 Int)) (!
  (>=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $a@168@01)
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$0@101@01 11)) $a@168@01))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $self$1@103@01 11)) $a@168@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@903@11@903@266|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(pop) ; 2
(pop) ; 1
; ---------- $forced_ether_check ----------
(set-option :timeout 0)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var self: $Struct
(declare-const self@169@01 $Struct)
; [exec]
; var $contracts: $Map[Int, $Struct]
(declare-const $contracts@170@01 $Map<Int~_$Struct>)
; [exec]
; var $pre_self: $Struct
(declare-const $pre_self@171@01 $Struct)
; [exec]
; var $pre_$contracts: $Map[Int, $Struct]
(declare-const $pre_$contracts@172@01 $Map<Int~_$Struct>)
; [exec]
; var $post: Bool
(declare-const $post@173@01 Bool)
; [exec]
; var $havoc: Int
(declare-const $havoc@174@01 Int)
; [exec]
; var block: $Struct
(declare-const block@175@01 $Struct)
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@176@01 $Snap)
(assert (= $t@176@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@169@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@177@01 $Snap)
(assert (= $t@177@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@169@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@178@01 $Snap)
(assert (= $t@178@01 ($Snap.combine ($Snap.first $t@178@01) ($Snap.second $t@178@01))))
(assert (= ($Snap.first $t@178@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@169@01 2))))
(assert (= ($Snap.second $t@178@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@169@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@179@01 $Snap)
(assert (= $t@179@01 ($Snap.combine ($Snap.first $t@179@01) ($Snap.second $t@179@01))))
(assert (= ($Snap.first $t@179@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@169@01 3))))
(assert (= ($Snap.second $t@179@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@169@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@180@01 $Snap)
(assert (= $t@180@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@181@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 4
; [then-branch: 20 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 4)), $q2@181@01)) | live]
; [else-branch: 20 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 4)), $q2@181@01) | live]
(push) ; 5
; [then-branch: 20 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 4)), $q2@181@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@181@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 20 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 4)), $q2@181@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@181@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@181@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@181@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@181@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@181@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@181@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@181@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@919@11@919@345-aux|)))
(assert (forall (($q2@181@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@181@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@181@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@181@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@919@11@919@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@182@01 $Snap)
(assert (= $t@182@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@183@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@183@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@183@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 4)) $q2@183@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@920@11@920@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@184@01 $Snap)
(assert (= $t@184@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@185@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@186@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 5
; [then-branch: 21 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@169@01, 5)), $q3@185@01), $q4@186@01)) | live]
; [else-branch: 21 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@169@01, 5)), $q3@185@01), $q4@186@01) | live]
(push) ; 6
; [then-branch: 21 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@169@01, 5)), $q3@185@01), $q4@186@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 21 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@169@01, 5)), $q3@185@01), $q4@186@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@186@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@921@131@921@597-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@185@01 Int)) (!
  (forall (($q4@186@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@921@131@921@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@921@11@921@598-aux|)))
(assert (forall (($q3@185@01 Int)) (!
  (forall (($q4@186@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01) $q4@186@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@921@131@921@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@185@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@921@11@921@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@187@01 $Snap)
(assert (= $t@187@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@188@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@189@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@188@01 Int)) (!
  (forall (($q4@189@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@188@01) $q4@189@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@188@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@188@01) $q4@189@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@922@131@922@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@169@01 5)) $q3@188@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@922@11@922@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@190@01 $Snap)
(assert (= $t@190@01 ($Snap.combine ($Snap.first $t@190@01) ($Snap.second $t@190@01))))
(assert (= ($Snap.first $t@190@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@169@01 6))))
(assert (= ($Snap.second $t@190@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@169@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@191@01 $Snap)
(assert (= $t@191@01 ($Snap.combine ($Snap.first $t@191@01) ($Snap.second $t@191@01))))
(assert (= ($Snap.first $t@191@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@169@01 7))))
(assert (= ($Snap.second $t@191@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@169@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@192@01 $Snap)
(assert (= $t@192@01 ($Snap.combine ($Snap.first $t@192@01) ($Snap.second $t@192@01))))
(assert (= ($Snap.first $t@192@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@169@01 8))))
(assert (= ($Snap.second $t@192@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@169@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@193@01 $Snap)
(assert (= $t@193@01 ($Snap.combine ($Snap.first $t@193@01) ($Snap.second $t@193@01))))
(assert (= ($Snap.first $t@193@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> self@169@01 9))))
(assert (= ($Snap.second $t@193@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@169@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@194@01 $Snap)
(assert (= $t@194@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@195@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 4
; [then-branch: 22 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 11)), $q5@195@01)) | live]
; [else-branch: 22 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 11)), $q5@195@01) | live]
(push) ; 5
; [then-branch: 22 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 11)), $q5@195@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@195@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 22 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 11)), $q5@195@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@195@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@195@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@195@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@195@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@195@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@195@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@195@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@927@11@927@348-aux|)))
(assert (forall (($q5@195@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@195@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@195@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@195@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@927@11@927@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@196@01 $Snap)
(assert (= $t@196@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@197@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@197@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@197@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 11)) $q5@197@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@928@11@928@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@198@01 $Snap)
(assert (= $t@198@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@199@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 4
; [then-branch: 23 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 12)), $q6@199@01)) | live]
; [else-branch: 23 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 12)), $q6@199@01) | live]
(push) ; 5
; [then-branch: 23 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 12)), $q6@199@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@199@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 23 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@169@01, 12)), $q6@199@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@199@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@199@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@199@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@199@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@199@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@199@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@199@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@929@11@929@348-aux|)))
(assert (forall (($q6@199@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@199@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@199@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@199@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@929@11@929@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@200@01 $Snap)
(assert (= $t@200@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@201@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@201@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@201@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@169@01 12)) $q6@201@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@930@11@930@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@202@01 $Snap)
(assert (= $t@202@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> self@169@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc($pre_self, 0)): Seq[Int])| == 32
(declare-const $t@203@01 $Snap)
(assert (= $t@203@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($pre_self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($pre_self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc($pre_self, 0)): Seq[Int])
; [eval] $struct_loc($pre_self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $pre_self@171@01 0))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc($pre_self, 1)): Seq[Int])| == 32
(declare-const $t@204@01 $Snap)
(assert (= $t@204@01 $Snap.unit))
; [eval] |($struct_get($struct_loc($pre_self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc($pre_self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc($pre_self, 1)): Seq[Int])
; [eval] $struct_loc($pre_self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> $pre_self@171@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($pre_self, 2)): Int) &&
;   ($struct_get($struct_loc($pre_self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@205@01 $Snap)
(assert (= $t@205@01 ($Snap.combine ($Snap.first $t@205@01) ($Snap.second $t@205@01))))
(assert (= ($Snap.first $t@205@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($pre_self, 2)): Int)
; [eval] ($struct_get($struct_loc($pre_self, 2)): Int)
; [eval] $struct_loc($pre_self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 2))))
(assert (= ($Snap.second $t@205@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($pre_self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($pre_self, 2)): Int)
; [eval] $struct_loc($pre_self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($pre_self, 3)): Int) &&
;   ($struct_get($struct_loc($pre_self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@206@01 $Snap)
(assert (= $t@206@01 ($Snap.combine ($Snap.first $t@206@01) ($Snap.second $t@206@01))))
(assert (= ($Snap.first $t@206@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($pre_self, 3)): Int)
; [eval] ($struct_get($struct_loc($pre_self, 3)): Int)
; [eval] $struct_loc($pre_self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 3))))
(assert (= ($Snap.second $t@206@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($pre_self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($pre_self, 3)): Int)
; [eval] $struct_loc($pre_self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@207@01 $Snap)
(assert (= $t@207@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@208@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 4)
(push) ; 4
; [then-branch: 24 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 4)), $q2@208@01)) | live]
; [else-branch: 24 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 4)), $q2@208@01) | live]
(push) ; 5
; [then-branch: 24 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 4)), $q2@208@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@208@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 24 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 4)), $q2@208@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@208@01)))
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@208@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@208@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@208@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@208@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@208@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@208@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@936@11@936@360-aux|)))
(assert (forall (($q2@208@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@208@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@208@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@208@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@936@11@936@360|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int])): Int))
(declare-const $t@209@01 $Snap)
(assert (= $t@209@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@210@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 4)
; [eval] ($map_sum(($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($pre_self, 4)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@210@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@210@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 4)) $q2@210@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@937@11@937@268|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@211@01 $Snap)
(assert (= $t@211@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@212@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@213@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($pre_self, 5)
(push) ; 5
; [then-branch: 25 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($pre_self@171@01, 5)), $q3@212@01), $q4@213@01)) | live]
; [else-branch: 25 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($pre_self@171@01, 5)), $q3@212@01), $q4@213@01) | live]
(push) ; 6
; [then-branch: 25 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($pre_self@171@01, 5)), $q3@212@01), $q4@213@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 25 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int]($pre_self@171@01, 5)), $q3@212@01), $q4@213@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($pre_self, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@213@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@938@136@938@617-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@212@01 Int)) (!
  (forall (($q4@213@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@938@136@938@617-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@938@11@938@618-aux|)))
(assert (forall (($q3@212@01 Int)) (!
  (forall (($q4@213@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01) $q4@213@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@938@136@938@617|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@212@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@938@11@938@618|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@214@01 $Snap)
(assert (= $t@214@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@215@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@216@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($pre_self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc($pre_self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc($pre_self, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@215@01 Int)) (!
  (forall (($q4@216@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@215@01) $q4@216@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@215@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@215@01) $q4@216@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@939@136@939@525|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> $pre_self@171@01 5)) $q3@215@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@939@11@939@526|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($pre_self, 6)): Int) &&
;   ($struct_get($struct_loc($pre_self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@217@01 $Snap)
(assert (= $t@217@01 ($Snap.combine ($Snap.first $t@217@01) ($Snap.second $t@217@01))))
(assert (= ($Snap.first $t@217@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($pre_self, 6)): Int)
; [eval] ($struct_get($struct_loc($pre_self, 6)): Int)
; [eval] $struct_loc($pre_self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 6))))
(assert (= ($Snap.second $t@217@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($pre_self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($pre_self, 6)): Int)
; [eval] $struct_loc($pre_self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($pre_self, 7)): Int) &&
;   ($struct_get($struct_loc($pre_self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@218@01 $Snap)
(assert (= $t@218@01 ($Snap.combine ($Snap.first $t@218@01) ($Snap.second $t@218@01))))
(assert (= ($Snap.first $t@218@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($pre_self, 7)): Int)
; [eval] ($struct_get($struct_loc($pre_self, 7)): Int)
; [eval] $struct_loc($pre_self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 7))))
(assert (= ($Snap.second $t@218@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($pre_self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc($pre_self, 7)): Int)
; [eval] $struct_loc($pre_self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc($pre_self, 8)): Int) &&
;   ($struct_get($struct_loc($pre_self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@219@01 $Snap)
(assert (= $t@219@01 ($Snap.combine ($Snap.first $t@219@01) ($Snap.second $t@219@01))))
(assert (= ($Snap.first $t@219@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc($pre_self, 8)): Int)
; [eval] ($struct_get($struct_loc($pre_self, 8)): Int)
; [eval] $struct_loc($pre_self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 8))))
(assert (= ($Snap.second $t@219@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($pre_self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc($pre_self, 8)): Int)
; [eval] $struct_loc($pre_self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc($pre_self, 9)): Int) &&
;   ($struct_get($struct_loc($pre_self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@220@01 $Snap)
(assert (= $t@220@01 ($Snap.combine ($Snap.first $t@220@01) ($Snap.second $t@220@01))))
(assert (= ($Snap.first $t@220@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc($pre_self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc($pre_self, 9)): Int)
; [eval] $struct_loc($pre_self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 9))))
(assert (= ($Snap.second $t@220@01) $Snap.unit))
; [eval] ($struct_get($struct_loc($pre_self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc($pre_self, 9)): Int)
; [eval] $struct_loc($pre_self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@221@01 $Snap)
(assert (= $t@221@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@222@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 11)
(push) ; 4
; [then-branch: 26 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 11)), $q5@222@01)) | live]
; [else-branch: 26 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 11)), $q5@222@01) | live]
(push) ; 5
; [then-branch: 26 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 11)), $q5@222@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@222@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 26 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 11)), $q5@222@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@222@01)))
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@222@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@222@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@222@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@222@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@222@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@222@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@944@11@944@363-aux|)))
(assert (forall (($q5@222@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@222@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@222@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@222@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@944@11@944@363|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int])): Int))
(declare-const $t@223@01 $Snap)
(assert (= $t@223@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@224@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 11)
; [eval] ($map_sum(($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($pre_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@224@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@224@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 11)) $q5@224@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@945@11@945@271|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@225@01 $Snap)
(assert (= $t@225@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@226@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 12)
(push) ; 4
; [then-branch: 27 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 12)), $q6@226@01)) | live]
; [else-branch: 27 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 12)), $q6@226@01) | live]
(push) ; 5
; [then-branch: 27 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 12)), $q6@226@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@226@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 27 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int]($pre_self@171@01, 12)), $q6@226@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@226@01)))
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@226@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@226@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@226@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@226@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@226@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@226@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@946@11@946@363-aux|)))
(assert (forall (($q6@226@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@226@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@226@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@226@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@946@11@946@363|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int])): Int))
(declare-const $t@227@01 $Snap)
(assert (= $t@227@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@228@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 12)
; [eval] ($map_sum(($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc($pre_self, 12)): $Map[Int, Int])
; [eval] $struct_loc($pre_self, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@228@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@228@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> $pre_self@171@01 12)) $q6@228@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@947@11@947@271|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc($pre_self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@229@01 $Snap)
(assert (= $t@229@01 $Snap.unit))
; [eval] ($struct_get($struct_loc($pre_self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc($pre_self, -1)): Int)
; [eval] $struct_loc($pre_self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> $pre_self@171@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) &&
;   ($struct_get($struct_loc(block, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@230@01 $Snap)
(assert (= $t@230@01 ($Snap.combine ($Snap.first $t@230@01) ($Snap.second $t@230@01))))
(assert (= ($Snap.first $t@230@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 0)): Int)
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@175@01 0))))
(assert (= ($Snap.second $t@230@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@175@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) &&
;   ($struct_get($struct_loc(block, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@231@01 $Snap)
(assert (= $t@231@01 ($Snap.combine ($Snap.first $t@231@01) ($Snap.second $t@231@01))))
(assert (= ($Snap.first $t@231@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 1)): Int)
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@175@01 1))))
(assert (= ($Snap.second $t@231@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@175@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) &&
;   ($struct_get($struct_loc(block, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@232@01 $Snap)
(assert (= $t@232@01 ($Snap.combine ($Snap.first $t@232@01) ($Snap.second $t@232@01))))
(assert (= ($Snap.first $t@232@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 2)): Int)
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@175@01 2))))
(assert (= ($Snap.second $t@232@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@175@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
(declare-const $t@233@01 $Snap)
(assert (= $t@233@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])|
; [eval] ($struct_get($struct_loc(block, 3)): Seq[Int])
; [eval] $struct_loc(block, 3)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> block@175@01 3))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) &&
;   ($struct_get($struct_loc(block, 4)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@234@01 $Snap)
(assert (= $t@234@01 ($Snap.combine ($Snap.first $t@234@01) ($Snap.second $t@234@01))))
(assert (= ($Snap.first $t@234@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@175@01 4))))
(assert (= ($Snap.second $t@234@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@175@01 4))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(block, -1)): Int) ==
;   2335365049822495359383864865678187
(declare-const $t@235@01 $Snap)
(assert (= $t@235@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
; [eval] ($struct_get($struct_loc(block, -1)): Int)
; [eval] $struct_loc(block, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> block@175@01 (- 0 1)))
  2335365049822495359383864865678187))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale $havoc >= 0
(declare-const $t@236@01 $Snap)
(assert (= $t@236@01 $Snap.unit))
; [eval] $havoc >= 0
(assert (>= $havoc@174@01 0))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@237@01 $Snap)
(assert (= $t@237@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@238@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; $pre_self := self
; [exec]
; $pre_$contracts := $contracts
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   $havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + $havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + $havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@239@01 $Struct)
(assert (=
  self@239@01
  ($struct_set<$Struct> self@169@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@169@01 8))
    $havoc@174@01))))
(pop) ; 2
(pop) ; 1
; ---------- f$setup ----------
(declare-const l$token_addr@240@01 Int)
(declare-const $succ@241@01 Bool)
(declare-const l$token_addr@242@01 Int)
(declare-const $succ@243@01 Bool)
(set-option :timeout 0)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var msg: $Struct
(declare-const msg@244@01 $Struct)
; [exec]
; var block: $Struct
(declare-const block@245@01 $Struct)
; [exec]
; var chain: $Struct
(declare-const chain@246@01 $Struct)
; [exec]
; var tx: $Struct
(declare-const tx@247@01 $Struct)
; [exec]
; var self: $Struct
(declare-const self@248@01 $Struct)
; [exec]
; var $contracts: $Map[Int, $Struct]
(declare-const $contracts@249@01 $Map<Int~_$Struct>)
; [exec]
; var $old_self: $Struct
(declare-const $old_self@250@01 $Struct)
; [exec]
; var $old_$contracts: $Map[Int, $Struct]
(declare-const $old_$contracts@251@01 $Map<Int~_$Struct>)
; [exec]
; var $pre_self: $Struct
(declare-const $pre_self@252@01 $Struct)
; [exec]
; var $pre_$contracts: $Map[Int, $Struct]
(declare-const $pre_$contracts@253@01 $Map<Int~_$Struct>)
; [exec]
; var $issued_self: $Struct
(declare-const $issued_self@254@01 $Struct)
; [exec]
; var $issued_$contracts: $Map[Int, $Struct]
(declare-const $issued_$contracts@255@01 $Map<Int~_$Struct>)
; [exec]
; var $overflow: Bool
(declare-const $overflow@256@01 Bool)
; [exec]
; var $out_of_gas: Bool
(declare-const $out_of_gas@257@01 Bool)
; [exec]
; var l$havoc: Int
(declare-const l$havoc@258@01 Int)
; [exec]
; var l$havoc$1: $Map[Int, $Struct]
(declare-const l$havoc$1@259@01 $Map<Int~_$Struct>)
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@260@01 $Snap)
(assert (= $t@260@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@248@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@261@01 $Snap)
(assert (= $t@261@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@248@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@262@01 $Snap)
(assert (= $t@262@01 ($Snap.combine ($Snap.first $t@262@01) ($Snap.second $t@262@01))))
(assert (= ($Snap.first $t@262@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@248@01 2))))
(assert (= ($Snap.second $t@262@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@248@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@263@01 $Snap)
(assert (= $t@263@01 ($Snap.combine ($Snap.first $t@263@01) ($Snap.second $t@263@01))))
(assert (= ($Snap.first $t@263@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@248@01 3))))
(assert (= ($Snap.second $t@263@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@248@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@264@01 $Snap)
(assert (= $t@264@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@265@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 4
; [then-branch: 28 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 4)), $q2@265@01)) | live]
; [else-branch: 28 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 4)), $q2@265@01) | live]
(push) ; 5
; [then-branch: 28 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 4)), $q2@265@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@265@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 28 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 4)), $q2@265@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@265@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@265@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@265@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@265@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@265@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@265@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@265@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@986@11@986@345-aux|)))
(assert (forall (($q2@265@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@265@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@265@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@265@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@986@11@986@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@266@01 $Snap)
(assert (= $t@266@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@267@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@267@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@267@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 4)) $q2@267@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@987@11@987@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@268@01 $Snap)
(assert (= $t@268@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@269@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@270@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 5
; [then-branch: 29 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@248@01, 5)), $q3@269@01), $q4@270@01)) | live]
; [else-branch: 29 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@248@01, 5)), $q3@269@01), $q4@270@01) | live]
(push) ; 6
; [then-branch: 29 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@248@01, 5)), $q3@269@01), $q4@270@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 29 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@248@01, 5)), $q3@269@01), $q4@270@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@270@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@988@131@988@597-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@269@01 Int)) (!
  (forall (($q4@270@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@988@131@988@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@988@11@988@598-aux|)))
(assert (forall (($q3@269@01 Int)) (!
  (forall (($q4@270@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01) $q4@270@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@988@131@988@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@269@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@988@11@988@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@271@01 $Snap)
(assert (= $t@271@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@272@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@273@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@272@01 Int)) (!
  (forall (($q4@273@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@272@01) $q4@273@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@272@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@272@01) $q4@273@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@989@131@989@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@248@01 5)) $q3@272@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@989@11@989@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@274@01 $Snap)
(assert (= $t@274@01 ($Snap.combine ($Snap.first $t@274@01) ($Snap.second $t@274@01))))
(assert (= ($Snap.first $t@274@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@248@01 6))))
(assert (= ($Snap.second $t@274@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@248@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@275@01 $Snap)
(assert (= $t@275@01 ($Snap.combine ($Snap.first $t@275@01) ($Snap.second $t@275@01))))
(assert (= ($Snap.first $t@275@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@248@01 7))))
(assert (= ($Snap.second $t@275@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@248@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@276@01 $Snap)
(assert (= $t@276@01 ($Snap.combine ($Snap.first $t@276@01) ($Snap.second $t@276@01))))
(assert (= ($Snap.first $t@276@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@248@01 8))))
(assert (= ($Snap.second $t@276@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@248@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@277@01 $Snap)
(assert (= $t@277@01 ($Snap.combine ($Snap.first $t@277@01) ($Snap.second $t@277@01))))
(assert (= ($Snap.first $t@277@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> self@248@01 9))))
(assert (= ($Snap.second $t@277@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@248@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@278@01 $Snap)
(assert (= $t@278@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@279@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 4
; [then-branch: 30 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 11)), $q5@279@01)) | live]
; [else-branch: 30 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 11)), $q5@279@01) | live]
(push) ; 5
; [then-branch: 30 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 11)), $q5@279@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@279@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 30 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 11)), $q5@279@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@279@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@279@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@279@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@279@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@279@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@279@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@279@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@994@11@994@348-aux|)))
(assert (forall (($q5@279@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@279@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@279@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@279@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@994@11@994@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@280@01 $Snap)
(assert (= $t@280@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@281@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@281@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@281@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 11)) $q5@281@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@995@11@995@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@282@01 $Snap)
(assert (= $t@282@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@283@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 4
; [then-branch: 31 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 12)), $q6@283@01)) | live]
; [else-branch: 31 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 12)), $q6@283@01) | live]
(push) ; 5
; [then-branch: 31 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 12)), $q6@283@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@283@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 31 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@248@01, 12)), $q6@283@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@283@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@283@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@283@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@283@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@283@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@283@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@283@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@996@11@996@348-aux|)))
(assert (forall (($q6@283@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@283@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@283@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@283@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@996@11@996@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@284@01 $Snap)
(assert (= $t@284@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@285@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@285@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@285@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@248@01 12)) $q6@285@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@997@11@997@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@286@01 $Snap)
(assert (= $t@286@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> self@248@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $self_address() &&
;   $self_address() <= 1461501637330902918203684832716283019655932542975
(declare-const $t@287@01 $Snap)
(assert (= $t@287@01 ($Snap.combine ($Snap.first $t@287@01) ($Snap.second $t@287@01))))
(assert (= ($Snap.first $t@287@01) $Snap.unit))
; [eval] 0 <= $self_address()
; [eval] $self_address()
(assert (<= 0 (as $self_address<Int>  Int)))
(assert (= ($Snap.second $t@287@01) $Snap.unit))
; [eval] $self_address() <= 1461501637330902918203684832716283019655932542975
; [eval] $self_address()
(assert (<=
  (as $self_address<Int>  Int)
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= l$token_addr &&
;   l$token_addr <= 1461501637330902918203684832716283019655932542975
(declare-const $t@288@01 $Snap)
(assert (= $t@288@01 ($Snap.combine ($Snap.first $t@288@01) ($Snap.second $t@288@01))))
(assert (= ($Snap.first $t@288@01) $Snap.unit))
; [eval] 0 <= l$token_addr
(assert (<= 0 l$token_addr@242@01))
(assert (= ($Snap.second $t@288@01) $Snap.unit))
; [eval] l$token_addr <= 1461501637330902918203684832716283019655932542975
(assert (<= l$token_addr@242@01 1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) &&
;   ($struct_get($struct_loc(block, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@289@01 $Snap)
(assert (= $t@289@01 ($Snap.combine ($Snap.first $t@289@01) ($Snap.second $t@289@01))))
(assert (= ($Snap.first $t@289@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 0)): Int)
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@245@01 0))))
(assert (= ($Snap.second $t@289@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@245@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) &&
;   ($struct_get($struct_loc(block, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@290@01 $Snap)
(assert (= $t@290@01 ($Snap.combine ($Snap.first $t@290@01) ($Snap.second $t@290@01))))
(assert (= ($Snap.first $t@290@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 1)): Int)
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@245@01 1))))
(assert (= ($Snap.second $t@290@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@245@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) &&
;   ($struct_get($struct_loc(block, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@291@01 $Snap)
(assert (= $t@291@01 ($Snap.combine ($Snap.first $t@291@01) ($Snap.second $t@291@01))))
(assert (= ($Snap.first $t@291@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 2)): Int)
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@245@01 2))))
(assert (= ($Snap.second $t@291@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@245@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
(declare-const $t@292@01 $Snap)
(assert (= $t@292@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])|
; [eval] ($struct_get($struct_loc(block, 3)): Seq[Int])
; [eval] $struct_loc(block, 3)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> block@245@01 3))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) &&
;   ($struct_get($struct_loc(block, 4)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@293@01 $Snap)
(assert (= $t@293@01 ($Snap.combine ($Snap.first $t@293@01) ($Snap.second $t@293@01))))
(assert (= ($Snap.first $t@293@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@245@01 4))))
(assert (= ($Snap.second $t@293@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@245@01 4))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(block, -1)): Int) ==
;   2335365049822495359383864865678187
(declare-const $t@294@01 $Snap)
(assert (= $t@294@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
; [eval] ($struct_get($struct_loc(block, -1)): Int)
; [eval] $struct_loc(block, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> block@245@01 (- 0 1)))
  2335365049822495359383864865678187))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) &&
;   ($struct_get($struct_loc(msg, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@295@01 $Snap)
(assert (= $t@295@01 ($Snap.combine ($Snap.first $t@295@01) ($Snap.second $t@295@01))))
(assert (= ($Snap.first $t@295@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@244@01 0))))
(assert (= ($Snap.second $t@295@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@244@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) &&
;   ($struct_get($struct_loc(msg, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@296@01 $Snap)
(assert (= $t@296@01 ($Snap.combine ($Snap.first $t@296@01) ($Snap.second $t@296@01))))
(assert (= ($Snap.first $t@296@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@244@01 1))))
(assert (= ($Snap.second $t@296@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@244@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) &&
;   ($struct_get($struct_loc(msg, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@297@01 $Snap)
(assert (= $t@297@01 ($Snap.combine ($Snap.first $t@297@01) ($Snap.second $t@297@01))))
(assert (= ($Snap.first $t@297@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 2)): Int)
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@244@01 2))))
(assert (= ($Snap.second $t@297@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@244@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, -1)): Int) ==
;   35634842679176259756224246631
(declare-const $t@298@01 $Snap)
(assert (= $t@298@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
; [eval] ($struct_get($struct_loc(msg, -1)): Int)
; [eval] $struct_loc(msg, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> msg@244@01 (- 0 1)))
  35634842679176259756224246631))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
(declare-const $t@299@01 $Snap)
(assert (= $t@299@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) != 0
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (not (= ($struct_get<Int> ($struct_loc<Int> msg@244@01 0)) 0)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@300@01 $Snap)
(assert (= $t@300@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@301@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; $pre_self := self
; [exec]
; $pre_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $succ := true
; [exec]
; $overflow := false
; [exec]
; inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
(declare-const $t@302@01 $Snap)
(assert (= $t@302@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) == 0
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (= ($struct_get<Int> ($struct_loc<Int> msg@244@01 1)) 0))
; State saturation: after inhale
(check-sat)
; unknown
; [eval] !(($struct_get($struct_loc(self, 7)): Int) == 0 && (($struct_get($struct_loc(self, 6)): Int) == 0 && l$token_addr != 0))
; [eval] ($struct_get($struct_loc(self, 7)): Int) == 0 && (($struct_get($struct_loc(self, 6)): Int) == 0 && l$token_addr != 0)
; [eval] ($struct_get($struct_loc(self, 7)): Int) == 0
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(set-option :timeout 0)
(push) ; 3
; [then-branch: 32 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) != 0 | live]
; [else-branch: 32 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0 | live]
(push) ; 4
; [then-branch: 32 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) != 0]
(assert (not (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)))
(pop) ; 4
(push) ; 4
; [else-branch: 32 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0]
(assert (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0))
; [eval] ($struct_get($struct_loc(self, 6)): Int) == 0
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(push) ; 5
; [then-branch: 33 | $struct_get[Int]($struct_loc[Int](self@248@01, 6)) != 0 | live]
; [else-branch: 33 | $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0 | live]
(push) ; 6
; [then-branch: 33 | $struct_get[Int]($struct_loc[Int](self@248@01, 6)) != 0]
(assert (not (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)))
(pop) ; 6
(push) ; 6
; [else-branch: 33 | $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0]
(assert (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0))
; [eval] l$token_addr != 0
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
  (not (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
  (and
    (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
    (or
      (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
      (not (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0))))))
(assert (or
  (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
  (not (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0))))
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
  (and
    (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
    (not (= l$token_addr@242@01 0))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
    (and
      (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
      (not (= l$token_addr@242@01 0)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 34 | !($struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0 && $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0 && l$token_addr@242@01 != 0) | live]
; [else-branch: 34 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0 && $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0 && l$token_addr@242@01 != 0 | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 34 | !($struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0 && $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0 && l$token_addr@242@01 != 0)]
(assert (not
  (and
    (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
    (and
      (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
      (not (= l$token_addr@242@01 0))))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 35 | True | live]
; [else-branch: 35 | False | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 35 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@303@01 $Snap)
(assert (= $t@303@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@258@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@304@01 $Struct)
(assert (=
  self@304@01
  ($struct_set<$Struct> self@248@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@248@01 8))
    l$havoc@258@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 4
; [then-branch: 36 | False | dead]
; [else-branch: 36 | True | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 36 | True]
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 34 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0 && $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0 && l$token_addr@242@01 != 0]
(assert (and
  (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
  (and
    (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
    (not (= l$token_addr@242@01 0)))))
(pop) ; 3
; [eval] !!(($struct_get($struct_loc(self, 7)): Int) == 0 && (($struct_get($struct_loc(self, 6)): Int) == 0 && l$token_addr != 0))
; [eval] !(($struct_get($struct_loc(self, 7)): Int) == 0 && (($struct_get($struct_loc(self, 6)): Int) == 0 && l$token_addr != 0))
; [eval] ($struct_get($struct_loc(self, 7)): Int) == 0 && (($struct_get($struct_loc(self, 6)): Int) == 0 && l$token_addr != 0)
; [eval] ($struct_get($struct_loc(self, 7)): Int) == 0
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(push) ; 3
; [then-branch: 37 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) != 0 | live]
; [else-branch: 37 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0 | live]
(push) ; 4
; [then-branch: 37 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) != 0]
(assert (not (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)))
(pop) ; 4
(push) ; 4
; [else-branch: 37 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0]
(assert (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0))
; [eval] ($struct_get($struct_loc(self, 6)): Int) == 0
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(push) ; 5
; [then-branch: 38 | $struct_get[Int]($struct_loc[Int](self@248@01, 6)) != 0 | live]
; [else-branch: 38 | $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0 | live]
(push) ; 6
; [then-branch: 38 | $struct_get[Int]($struct_loc[Int](self@248@01, 6)) != 0]
(assert (not (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)))
(pop) ; 6
(push) ; 6
; [else-branch: 38 | $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0]
(assert (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0))
; [eval] l$token_addr != 0
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
  (not (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
    (and
      (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
      (not (= l$token_addr@242@01 0)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
  (and
    (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
    (not (= l$token_addr@242@01 0))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 39 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0 && $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0 && l$token_addr@242@01 != 0 | live]
; [else-branch: 39 | !($struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0 && $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0 && l$token_addr@242@01 != 0) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 39 | $struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0 && $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0 && l$token_addr@242@01 != 0]
(assert (and
  (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
  (and
    (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
    (not (= l$token_addr@242@01 0)))))
; [exec]
; self := ($struct_set(self, 7, ($struct_get($struct_loc(msg, 0)): Int)): $Struct)
; [eval] ($struct_set(self, 7, ($struct_get($struct_loc(msg, 0)): Int)): $Struct)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(declare-const self@305@01 $Struct)
(assert (=
  self@305@01
  ($struct_set<$Struct> self@248@01 7 ($struct_get<Int> ($struct_loc<Int> msg@244@01 0)))))
; [exec]
; self := ($struct_set(self, 6, l$token_addr): $Struct)
; [eval] ($struct_set(self, 6, l$token_addr): $Struct)
(declare-const self@306@01 $Struct)
(assert (= self@306@01 ($struct_set<$Struct> self@305@01 6 l$token_addr@242@01)))
; [exec]
; self := ($struct_set(self, 0, Seq(85, 110, 105, 115, 119, 97, 112, 32, 86, 49,
;   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)): $Struct)
; [eval] ($struct_set(self, 0, Seq(85, 110, 105, 115, 119, 97, 112, 32, 86, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)): $Struct)
; [eval] Seq(85, 110, 105, 115, 119, 97, 112, 32, 86, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
(assert (=
  (Seq_length
    (Seq_append
      (Seq_append
        (Seq_append
          (Seq_append
            (Seq_append
              (Seq_append
                (Seq_append
                  (Seq_append
                    (Seq_append
                      (Seq_append
                        (Seq_append
                          (Seq_append
                            (Seq_append
                              (Seq_append
                                (Seq_append
                                  (Seq_append
                                    (Seq_append
                                      (Seq_append
                                        (Seq_append
                                          (Seq_append
                                            (Seq_append
                                              (Seq_append
                                                (Seq_append
                                                  (Seq_append
                                                    (Seq_append
                                                      (Seq_append
                                                        (Seq_append
                                                          (Seq_append
                                                            (Seq_append
                                                              (Seq_append
                                                                (Seq_append
                                                                  (Seq_singleton 85)
                                                                  (Seq_singleton 110))
                                                                (Seq_singleton 105))
                                                              (Seq_singleton 115))
                                                            (Seq_singleton 119))
                                                          (Seq_singleton 97))
                                                        (Seq_singleton 112))
                                                      (Seq_singleton 32))
                                                    (Seq_singleton 86))
                                                  (Seq_singleton 49))
                                                (Seq_singleton 0))
                                              (Seq_singleton 0))
                                            (Seq_singleton 0))
                                          (Seq_singleton 0))
                                        (Seq_singleton 0))
                                      (Seq_singleton 0))
                                    (Seq_singleton 0))
                                  (Seq_singleton 0))
                                (Seq_singleton 0))
                              (Seq_singleton 0))
                            (Seq_singleton 0))
                          (Seq_singleton 0))
                        (Seq_singleton 0))
                      (Seq_singleton 0))
                    (Seq_singleton 0))
                  (Seq_singleton 0))
                (Seq_singleton 0))
              (Seq_singleton 0))
            (Seq_singleton 0))
          (Seq_singleton 0))
        (Seq_singleton 0))
      (Seq_singleton 0)))
  32))
(declare-const self@307@01 $Struct)
(assert (=
  self@307@01
  ($struct_set<$Struct> self@306@01 0 (Seq_append
    (Seq_append
      (Seq_append
        (Seq_append
          (Seq_append
            (Seq_append
              (Seq_append
                (Seq_append
                  (Seq_append
                    (Seq_append
                      (Seq_append
                        (Seq_append
                          (Seq_append
                            (Seq_append
                              (Seq_append
                                (Seq_append
                                  (Seq_append
                                    (Seq_append
                                      (Seq_append
                                        (Seq_append
                                          (Seq_append
                                            (Seq_append
                                              (Seq_append
                                                (Seq_append
                                                  (Seq_append
                                                    (Seq_append
                                                      (Seq_append
                                                        (Seq_append
                                                          (Seq_append
                                                            (Seq_append
                                                              (Seq_append
                                                                (Seq_singleton 85)
                                                                (Seq_singleton 110))
                                                              (Seq_singleton 105))
                                                            (Seq_singleton 115))
                                                          (Seq_singleton 119))
                                                        (Seq_singleton 97))
                                                      (Seq_singleton 112))
                                                    (Seq_singleton 32))
                                                  (Seq_singleton 86))
                                                (Seq_singleton 49))
                                              (Seq_singleton 0))
                                            (Seq_singleton 0))
                                          (Seq_singleton 0))
                                        (Seq_singleton 0))
                                      (Seq_singleton 0))
                                    (Seq_singleton 0))
                                  (Seq_singleton 0))
                                (Seq_singleton 0))
                              (Seq_singleton 0))
                            (Seq_singleton 0))
                          (Seq_singleton 0))
                        (Seq_singleton 0))
                      (Seq_singleton 0))
                    (Seq_singleton 0))
                  (Seq_singleton 0))
                (Seq_singleton 0))
              (Seq_singleton 0))
            (Seq_singleton 0))
          (Seq_singleton 0))
        (Seq_singleton 0))
      (Seq_singleton 0))
    (Seq_singleton 0)))))
; [exec]
; self := ($struct_set(self, 1, Seq(85, 78, 73, 45, 86, 49, 0, 0, 0, 0, 0, 0,
;   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)): $Struct)
; [eval] ($struct_set(self, 1, Seq(85, 78, 73, 45, 86, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)): $Struct)
; [eval] Seq(85, 78, 73, 45, 86, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
(assert (=
  (Seq_length
    (Seq_append
      (Seq_append
        (Seq_append
          (Seq_append
            (Seq_append
              (Seq_append
                (Seq_append
                  (Seq_append
                    (Seq_append
                      (Seq_append
                        (Seq_append
                          (Seq_append
                            (Seq_append
                              (Seq_append
                                (Seq_append
                                  (Seq_append
                                    (Seq_append
                                      (Seq_append
                                        (Seq_append
                                          (Seq_append
                                            (Seq_append
                                              (Seq_append
                                                (Seq_append
                                                  (Seq_append
                                                    (Seq_append
                                                      (Seq_append
                                                        (Seq_append
                                                          (Seq_append
                                                            (Seq_append
                                                              (Seq_append
                                                                (Seq_append
                                                                  (Seq_singleton 85)
                                                                  (Seq_singleton 78))
                                                                (Seq_singleton 73))
                                                              (Seq_singleton 45))
                                                            (Seq_singleton 86))
                                                          (Seq_singleton 49))
                                                        (Seq_singleton 0))
                                                      (Seq_singleton 0))
                                                    (Seq_singleton 0))
                                                  (Seq_singleton 0))
                                                (Seq_singleton 0))
                                              (Seq_singleton 0))
                                            (Seq_singleton 0))
                                          (Seq_singleton 0))
                                        (Seq_singleton 0))
                                      (Seq_singleton 0))
                                    (Seq_singleton 0))
                                  (Seq_singleton 0))
                                (Seq_singleton 0))
                              (Seq_singleton 0))
                            (Seq_singleton 0))
                          (Seq_singleton 0))
                        (Seq_singleton 0))
                      (Seq_singleton 0))
                    (Seq_singleton 0))
                  (Seq_singleton 0))
                (Seq_singleton 0))
              (Seq_singleton 0))
            (Seq_singleton 0))
          (Seq_singleton 0))
        (Seq_singleton 0))
      (Seq_singleton 0)))
  32))
(declare-const self@308@01 $Struct)
(assert (=
  self@308@01
  ($struct_set<$Struct> self@307@01 1 (Seq_append
    (Seq_append
      (Seq_append
        (Seq_append
          (Seq_append
            (Seq_append
              (Seq_append
                (Seq_append
                  (Seq_append
                    (Seq_append
                      (Seq_append
                        (Seq_append
                          (Seq_append
                            (Seq_append
                              (Seq_append
                                (Seq_append
                                  (Seq_append
                                    (Seq_append
                                      (Seq_append
                                        (Seq_append
                                          (Seq_append
                                            (Seq_append
                                              (Seq_append
                                                (Seq_append
                                                  (Seq_append
                                                    (Seq_append
                                                      (Seq_append
                                                        (Seq_append
                                                          (Seq_append
                                                            (Seq_append
                                                              (Seq_append
                                                                (Seq_singleton 85)
                                                                (Seq_singleton 78))
                                                              (Seq_singleton 73))
                                                            (Seq_singleton 45))
                                                          (Seq_singleton 86))
                                                        (Seq_singleton 49))
                                                      (Seq_singleton 0))
                                                    (Seq_singleton 0))
                                                  (Seq_singleton 0))
                                                (Seq_singleton 0))
                                              (Seq_singleton 0))
                                            (Seq_singleton 0))
                                          (Seq_singleton 0))
                                        (Seq_singleton 0))
                                      (Seq_singleton 0))
                                    (Seq_singleton 0))
                                  (Seq_singleton 0))
                                (Seq_singleton 0))
                              (Seq_singleton 0))
                            (Seq_singleton 0))
                          (Seq_singleton 0))
                        (Seq_singleton 0))
                      (Seq_singleton 0))
                    (Seq_singleton 0))
                  (Seq_singleton 0))
                (Seq_singleton 0))
              (Seq_singleton 0))
            (Seq_singleton 0))
          (Seq_singleton 0))
        (Seq_singleton 0))
      (Seq_singleton 0))
    (Seq_singleton 0)))))
; [exec]
; self := ($struct_set(self, 2, 18): $Struct)
; [eval] ($struct_set(self, 2, 18): $Struct)
(declare-const self@309@01 $Struct)
(assert (= self@309@01 ($struct_set<$Struct> self@308@01 2 18)))
; [exec]
; label return
(push) ; 4
(set-option :timeout 10)
(assert (not (not $out_of_gas@257@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not $out_of_gas@257@01))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
; [then-branch: 40 | $out_of_gas@257@01 | live]
; [else-branch: 40 | !($out_of_gas@257@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 40 | $out_of_gas@257@01]
(assert $out_of_gas@257@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 5
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
; [then-branch: 41 | True | live]
; [else-branch: 41 | False | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 41 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@310@01 $Snap)
(assert (= $t@310@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@258@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@311@01 $Struct)
(assert (=
  self@311@01
  ($struct_set<$Struct> self@248@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@248@01 8))
    l$havoc@258@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 5
; [then-branch: 42 | False | dead]
; [else-branch: 42 | True | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 42 | True]
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 40 | !($out_of_gas@257@01)]
(assert (not $out_of_gas@257@01))
(pop) ; 4
; [eval] !$out_of_gas
(push) ; 4
(set-option :timeout 10)
(assert (not $out_of_gas@257@01))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not $out_of_gas@257@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
; [then-branch: 43 | !($out_of_gas@257@01) | live]
; [else-branch: 43 | $out_of_gas@257@01 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 43 | !($out_of_gas@257@01)]
(assert (not $out_of_gas@257@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 44 | False | dead]
; [else-branch: 44 | True | live]
(push) ; 5
; [else-branch: 44 | True]
(pop) ; 5
(push) ; 5
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
; [then-branch: 45 | True | live]
; [else-branch: 45 | False | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 45 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@312@01 $Snap)
(assert (= $t@312@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@258@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@313@01 $Struct)
(assert (=
  self@313@01
  ($struct_set<$Struct> self@309@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@309@01 8))
    l$havoc@258@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 5
(pop) ; 4
(set-option :timeout 0)
(push) ; 4
; [else-branch: 43 | $out_of_gas@257@01]
(assert $out_of_gas@257@01)
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 39 | !($struct_get[Int]($struct_loc[Int](self@248@01, 7)) == 0 && $struct_get[Int]($struct_loc[Int](self@248@01, 6)) == 0 && l$token_addr@242@01 != 0)]
(assert (not
  (and
    (= ($struct_get<Int> ($struct_loc<Int> self@248@01 7)) 0)
    (and
      (= ($struct_get<Int> ($struct_loc<Int> self@248@01 6)) 0)
      (not (= l$token_addr@242@01 0))))))
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- f$addLiquidity ----------
(declare-const l$min_liquidity@314@01 $Int)
(declare-const l$max_tokens@315@01 $Int)
(declare-const l$deadline@316@01 $Int)
(declare-const $succ@317@01 Bool)
(declare-const $res@318@01 Int)
(declare-const l$min_liquidity@319@01 $Int)
(declare-const l$max_tokens@320@01 $Int)
(declare-const l$deadline@321@01 $Int)
(declare-const $succ@322@01 Bool)
(declare-const $res@323@01 Int)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var msg: $Struct
(declare-const msg@324@01 $Struct)
; [exec]
; var block: $Struct
(declare-const block@325@01 $Struct)
; [exec]
; var chain: $Struct
(declare-const chain@326@01 $Struct)
; [exec]
; var tx: $Struct
(declare-const tx@327@01 $Struct)
; [exec]
; var self: $Struct
(declare-const self@328@01 $Struct)
; [exec]
; var $contracts: $Map[Int, $Struct]
(declare-const $contracts@329@01 $Map<Int~_$Struct>)
; [exec]
; var $old_self: $Struct
(declare-const $old_self@330@01 $Struct)
; [exec]
; var $old_$contracts: $Map[Int, $Struct]
(declare-const $old_$contracts@331@01 $Map<Int~_$Struct>)
; [exec]
; var $pre_self: $Struct
(declare-const $pre_self@332@01 $Struct)
; [exec]
; var $pre_$contracts: $Map[Int, $Struct]
(declare-const $pre_$contracts@333@01 $Map<Int~_$Struct>)
; [exec]
; var $issued_self: $Struct
(declare-const $issued_self@334@01 $Struct)
; [exec]
; var $issued_$contracts: $Map[Int, $Struct]
(declare-const $issued_$contracts@335@01 $Map<Int~_$Struct>)
; [exec]
; var $overflow: Bool
(declare-const $overflow@336@01 Bool)
; [exec]
; var l$total_liquidity: $Int
(declare-const l$total_liquidity@337@01 $Int)
; [exec]
; var l$eth_reserve: $Int
(declare-const l$eth_reserve@338@01 $Int)
; [exec]
; var l$send_fail: Bool
(declare-const l$send_fail@339@01 Bool)
; [exec]
; var l$raw_ret: Int
(declare-const l$raw_ret@340@01 Int)
; [exec]
; var l$token_reserve: $Int
(declare-const l$token_reserve@341@01 $Int)
; [exec]
; var l$token_amount: $Int
(declare-const l$token_amount@342@01 $Int)
; [exec]
; var l$liquidity_minted: $Int
(declare-const l$liquidity_minted@343@01 $Int)
; [exec]
; var l$havoc: $Map[Int, $Struct]
(declare-const l$havoc@344@01 $Map<Int~_$Struct>)
; [exec]
; var l$send_fail$1: Bool
(declare-const l$send_fail$1@345@01 Bool)
; [exec]
; var l$raw_ret$1: Bool
(declare-const l$raw_ret$1@346@01 Bool)
; [exec]
; var i1$$pre_self: $Struct
(declare-const i1$$pre_self@347@01 $Struct)
; [exec]
; var i1$$pre_$contracts: $Map[Int, $Struct]
(declare-const i1$$pre_$contracts@348@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$1: $Map[Int, $Struct]
(declare-const l$havoc$1@349@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$2: $Struct
(declare-const l$havoc$2@350@01 $Struct)
; [exec]
; var l$havoc$3: $Map[Int, $Struct]
(declare-const l$havoc$3@351@01 $Map<Int~_$Struct>)
; [exec]
; var l$no_reentrant_call: Bool
(declare-const l$no_reentrant_call@352@01 Bool)
; [exec]
; var l$havoc$4: $Map[Int, $Struct]
(declare-const l$havoc$4@353@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$5: $Map[Int, $Struct]
(declare-const l$havoc$5@354@01 $Map<Int~_$Struct>)
; [exec]
; var l$send_fail$2: Bool
(declare-const l$send_fail$2@355@01 Bool)
; [exec]
; var l$raw_ret$2: Int
(declare-const l$raw_ret$2@356@01 Int)
; [exec]
; var l$token_amount$1: $Int
(declare-const l$token_amount$1@357@01 $Int)
; [exec]
; var l$initial_liquidity: $Int
(declare-const l$initial_liquidity@358@01 $Int)
; [exec]
; var l$havoc$6: $Map[Int, $Struct]
(declare-const l$havoc$6@359@01 $Map<Int~_$Struct>)
; [exec]
; var l$send_fail$3: Bool
(declare-const l$send_fail$3@360@01 Bool)
; [exec]
; var l$raw_ret$3: Bool
(declare-const l$raw_ret$3@361@01 Bool)
; [exec]
; var i3$$pre_self: $Struct
(declare-const i3$$pre_self@362@01 $Struct)
; [exec]
; var i3$$pre_$contracts: $Map[Int, $Struct]
(declare-const i3$$pre_$contracts@363@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$7: $Map[Int, $Struct]
(declare-const l$havoc$7@364@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$8: $Struct
(declare-const l$havoc$8@365@01 $Struct)
; [exec]
; var l$havoc$9: $Map[Int, $Struct]
(declare-const l$havoc$9@366@01 $Map<Int~_$Struct>)
; [exec]
; var l$no_reentrant_call$1: Bool
(declare-const l$no_reentrant_call$1@367@01 Bool)
; [exec]
; var l$havoc$10: $Map[Int, $Struct]
(declare-const l$havoc$10@368@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$11: $Map[Int, $Struct]
(declare-const l$havoc$11@369@01 $Map<Int~_$Struct>)
; [exec]
; var $out_of_gas: Bool
(declare-const $out_of_gas@370@01 Bool)
; [exec]
; var l$havoc$12: Int
(declare-const l$havoc$12@371@01 Int)
; [exec]
; var l$havoc$13: Int
(declare-const l$havoc$13@372@01 Int)
; [exec]
; var l$havoc$14: $Map[Int, $Struct]
(declare-const l$havoc$14@373@01 $Map<Int~_$Struct>)
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@374@01 $Snap)
(assert (= $t@374@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@328@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@375@01 $Snap)
(assert (= $t@375@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@328@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@376@01 $Snap)
(assert (= $t@376@01 ($Snap.combine ($Snap.first $t@376@01) ($Snap.second $t@376@01))))
(assert (= ($Snap.first $t@376@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@328@01 2))))
(assert (= ($Snap.second $t@376@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@328@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@377@01 $Snap)
(assert (= $t@377@01 ($Snap.combine ($Snap.first $t@377@01) ($Snap.second $t@377@01))))
(assert (= ($Snap.first $t@377@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@328@01 3))))
(assert (= ($Snap.second $t@377@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@328@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@378@01 $Snap)
(assert (= $t@378@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@379@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 4
; [then-branch: 46 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 4)), $q2@379@01)) | live]
; [else-branch: 46 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 4)), $q2@379@01) | live]
(push) ; 5
; [then-branch: 46 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 4)), $q2@379@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@379@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 46 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 4)), $q2@379@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@379@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@379@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@379@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@379@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@379@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@379@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@379@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1118@11@1118@345-aux|)))
(assert (forall (($q2@379@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@379@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@379@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@379@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1118@11@1118@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@380@01 $Snap)
(assert (= $t@380@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@381@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@381@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@381@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 4)) $q2@381@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1119@11@1119@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@382@01 $Snap)
(assert (= $t@382@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@383@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@384@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 5
; [then-branch: 47 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@328@01, 5)), $q3@383@01), $q4@384@01)) | live]
; [else-branch: 47 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@328@01, 5)), $q3@383@01), $q4@384@01) | live]
(push) ; 6
; [then-branch: 47 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@328@01, 5)), $q3@383@01), $q4@384@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 47 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@328@01, 5)), $q3@383@01), $q4@384@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@384@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1120@131@1120@597-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@383@01 Int)) (!
  (forall (($q4@384@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1120@131@1120@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1120@11@1120@598-aux|)))
(assert (forall (($q3@383@01 Int)) (!
  (forall (($q4@384@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01) $q4@384@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1120@131@1120@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@383@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1120@11@1120@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@385@01 $Snap)
(assert (= $t@385@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@386@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@387@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@386@01 Int)) (!
  (forall (($q4@387@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@386@01) $q4@387@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@386@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@386@01) $q4@387@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1121@131@1121@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@328@01 5)) $q3@386@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1121@11@1121@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@388@01 $Snap)
(assert (= $t@388@01 ($Snap.combine ($Snap.first $t@388@01) ($Snap.second $t@388@01))))
(assert (= ($Snap.first $t@388@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@328@01 6))))
(assert (= ($Snap.second $t@388@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@328@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@389@01 $Snap)
(assert (= $t@389@01 ($Snap.combine ($Snap.first $t@389@01) ($Snap.second $t@389@01))))
(assert (= ($Snap.first $t@389@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@328@01 7))))
(assert (= ($Snap.second $t@389@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@328@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@390@01 $Snap)
(assert (= $t@390@01 ($Snap.combine ($Snap.first $t@390@01) ($Snap.second $t@390@01))))
(assert (= ($Snap.first $t@390@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@328@01 8))))
(assert (= ($Snap.second $t@390@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@391@01 $Snap)
(assert (= $t@391@01 ($Snap.combine ($Snap.first $t@391@01) ($Snap.second $t@391@01))))
(assert (= ($Snap.first $t@391@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> self@328@01 9))))
(assert (= ($Snap.second $t@391@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@328@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@392@01 $Snap)
(assert (= $t@392@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@393@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 4
; [then-branch: 48 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 11)), $q5@393@01)) | live]
; [else-branch: 48 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 11)), $q5@393@01) | live]
(push) ; 5
; [then-branch: 48 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 11)), $q5@393@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@393@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 48 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 11)), $q5@393@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@393@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@393@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@393@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@393@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@393@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@393@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@393@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1126@11@1126@348-aux|)))
(assert (forall (($q5@393@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@393@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@393@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@393@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1126@11@1126@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@394@01 $Snap)
(assert (= $t@394@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@395@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@395@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@395@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 11)) $q5@395@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1127@11@1127@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@396@01 $Snap)
(assert (= $t@396@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@397@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 4
; [then-branch: 49 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 12)), $q6@397@01)) | live]
; [else-branch: 49 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 12)), $q6@397@01) | live]
(push) ; 5
; [then-branch: 49 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 12)), $q6@397@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@397@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 49 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@328@01, 12)), $q6@397@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@397@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@397@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@397@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@397@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@397@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@397@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@397@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1128@11@1128@348-aux|)))
(assert (forall (($q6@397@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@397@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@397@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@397@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1128@11@1128@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@398@01 $Snap)
(assert (= $t@398@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@399@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@399@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@399@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@328@01 12)) $q6@399@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1129@11@1129@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@400@01 $Snap)
(assert (= $t@400@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> self@328@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $self_address() &&
;   $self_address() <= 1461501637330902918203684832716283019655932542975
(declare-const $t@401@01 $Snap)
(assert (= $t@401@01 ($Snap.combine ($Snap.first $t@401@01) ($Snap.second $t@401@01))))
(assert (= ($Snap.first $t@401@01) $Snap.unit))
; [eval] 0 <= $self_address()
; [eval] $self_address()
(assert (<= 0 (as $self_address<Int>  Int)))
(assert (= ($Snap.second $t@401@01) $Snap.unit))
; [eval] $self_address() <= 1461501637330902918203684832716283019655932542975
; [eval] $self_address()
(assert (<=
  (as $self_address<Int>  Int)
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$min_liquidity) &&
;   $unwrap(l$min_liquidity) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@402@01 $Snap)
(assert (= $t@402@01 ($Snap.combine ($Snap.first $t@402@01) ($Snap.second $t@402@01))))
(assert (= ($Snap.first $t@402@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$min_liquidity)
; [eval] $unwrap(l$min_liquidity)
(assert (<= 0 ($unwrap<Int> l$min_liquidity@319@01)))
(assert (= ($Snap.second $t@402@01) $Snap.unit))
; [eval] $unwrap(l$min_liquidity) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$min_liquidity)
(assert (<=
  ($unwrap<Int> l$min_liquidity@319@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$max_tokens) &&
;   $unwrap(l$max_tokens) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@403@01 $Snap)
(assert (= $t@403@01 ($Snap.combine ($Snap.first $t@403@01) ($Snap.second $t@403@01))))
(assert (= ($Snap.first $t@403@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$max_tokens)
; [eval] $unwrap(l$max_tokens)
(assert (<= 0 ($unwrap<Int> l$max_tokens@320@01)))
(assert (= ($Snap.second $t@403@01) $Snap.unit))
; [eval] $unwrap(l$max_tokens) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$max_tokens)
(assert (<=
  ($unwrap<Int> l$max_tokens@320@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$deadline) &&
;   $unwrap(l$deadline) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@404@01 $Snap)
(assert (= $t@404@01 ($Snap.combine ($Snap.first $t@404@01) ($Snap.second $t@404@01))))
(assert (= ($Snap.first $t@404@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$deadline)
; [eval] $unwrap(l$deadline)
(assert (<= 0 ($unwrap<Int> l$deadline@321@01)))
(assert (= ($Snap.second $t@404@01) $Snap.unit))
; [eval] $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$deadline)
(assert (<=
  ($unwrap<Int> l$deadline@321@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) &&
;   ($struct_get($struct_loc(block, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@405@01 $Snap)
(assert (= $t@405@01 ($Snap.combine ($Snap.first $t@405@01) ($Snap.second $t@405@01))))
(assert (= ($Snap.first $t@405@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 0)): Int)
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@325@01 0))))
(assert (= ($Snap.second $t@405@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@325@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) &&
;   ($struct_get($struct_loc(block, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@406@01 $Snap)
(assert (= $t@406@01 ($Snap.combine ($Snap.first $t@406@01) ($Snap.second $t@406@01))))
(assert (= ($Snap.first $t@406@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 1)): Int)
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@325@01 1))))
(assert (= ($Snap.second $t@406@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@325@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) &&
;   ($struct_get($struct_loc(block, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@407@01 $Snap)
(assert (= $t@407@01 ($Snap.combine ($Snap.first $t@407@01) ($Snap.second $t@407@01))))
(assert (= ($Snap.first $t@407@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 2)): Int)
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@325@01 2))))
(assert (= ($Snap.second $t@407@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@325@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
(declare-const $t@408@01 $Snap)
(assert (= $t@408@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])|
; [eval] ($struct_get($struct_loc(block, 3)): Seq[Int])
; [eval] $struct_loc(block, 3)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> block@325@01 3))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) &&
;   ($struct_get($struct_loc(block, 4)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@409@01 $Snap)
(assert (= $t@409@01 ($Snap.combine ($Snap.first $t@409@01) ($Snap.second $t@409@01))))
(assert (= ($Snap.first $t@409@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@325@01 4))))
(assert (= ($Snap.second $t@409@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@325@01 4))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(block, -1)): Int) ==
;   2335365049822495359383864865678187
(declare-const $t@410@01 $Snap)
(assert (= $t@410@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
; [eval] ($struct_get($struct_loc(block, -1)): Int)
; [eval] $struct_loc(block, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> block@325@01 (- 0 1)))
  2335365049822495359383864865678187))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) &&
;   ($struct_get($struct_loc(msg, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@411@01 $Snap)
(assert (= $t@411@01 ($Snap.combine ($Snap.first $t@411@01) ($Snap.second $t@411@01))))
(assert (= ($Snap.first $t@411@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
(assert (= ($Snap.second $t@411@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) &&
;   ($struct_get($struct_loc(msg, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@412@01 $Snap)
(assert (= $t@412@01 ($Snap.combine ($Snap.first $t@412@01) ($Snap.second $t@412@01))))
(assert (= ($Snap.first $t@412@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
(assert (= ($Snap.second $t@412@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) &&
;   ($struct_get($struct_loc(msg, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@413@01 $Snap)
(assert (= $t@413@01 ($Snap.combine ($Snap.first $t@413@01) ($Snap.second $t@413@01))))
(assert (= ($Snap.first $t@413@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 2)): Int)
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@324@01 2))))
(assert (= ($Snap.second $t@413@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@324@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, -1)): Int) ==
;   35634842679176259756224246631
(declare-const $t@414@01 $Snap)
(assert (= $t@414@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
; [eval] ($struct_get($struct_loc(msg, -1)): Int)
; [eval] $struct_loc(msg, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> msg@324@01 (- 0 1)))
  35634842679176259756224246631))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
(declare-const $t@415@01 $Snap)
(assert (= $t@415@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) != 0
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (not (= ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)) 0)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@416@01 $Snap)
(assert (= $t@416@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@417@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; $pre_self := self
; [exec]
; $pre_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $succ := true
; [exec]
; $overflow := false
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const self@418@01 $Struct)
(assert (=
  self@418@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))))
; [exec]
; self := ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]),
;   ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self,
;   12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) +
;   ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
; [eval] ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
; [eval] ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const self@419@01 $Struct)
(assert (=
  self@419@01
  ($struct_set<$Struct> self@418@01 12 ($map_set<$Map<Int~_Int>> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@418@01 12)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)) (+
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@418@01 12)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
    ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))))))
; [eval] !($unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$max_tokens) > 0 && ($struct_get($struct_loc(msg, 1)): Int) > 0))
; [eval] $unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$max_tokens) > 0 && ($struct_get($struct_loc(msg, 1)): Int) > 0)
; [eval] $unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int)
; [eval] $unwrap(l$deadline)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(set-option :timeout 0)
(push) ; 3
; [then-branch: 50 | !($unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4))) | live]
; [else-branch: 50 | $unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)) | live]
(push) ; 4
; [then-branch: 50 | !($unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)))]
(assert (not
  (>
    ($unwrap<Int> l$deadline@321@01)
    ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))))
(pop) ; 4
(push) ; 4
; [else-branch: 50 | $unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4))]
(assert (>
  ($unwrap<Int> l$deadline@321@01)
  ($struct_get<Int> ($struct_loc<Int> block@325@01 4))))
; [eval] $unwrap(l$max_tokens) > 0
; [eval] $unwrap(l$max_tokens)
(push) ; 5
; [then-branch: 51 | !($unwrap[Int](l$max_tokens@320@01) > 0) | live]
; [else-branch: 51 | $unwrap[Int](l$max_tokens@320@01) > 0 | live]
(push) ; 6
; [then-branch: 51 | !($unwrap[Int](l$max_tokens@320@01) > 0)]
(assert (not (> ($unwrap<Int> l$max_tokens@320@01) 0)))
(pop) ; 6
(push) ; 6
; [else-branch: 51 | $unwrap[Int](l$max_tokens@320@01) > 0]
(assert (> ($unwrap<Int> l$max_tokens@320@01) 0))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) > 0
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (> ($unwrap<Int> l$max_tokens@320@01) 0)
  (not (> ($unwrap<Int> l$max_tokens@320@01) 0))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  (>
    ($unwrap<Int> l$deadline@321@01)
    ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
  (and
    (>
      ($unwrap<Int> l$deadline@321@01)
      ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
    (or
      (> ($unwrap<Int> l$max_tokens@320@01) 0)
      (not (> ($unwrap<Int> l$max_tokens@320@01) 0))))))
(assert (or
  (>
    ($unwrap<Int> l$deadline@321@01)
    ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
  (not
    (>
      ($unwrap<Int> l$deadline@321@01)
      ($struct_get<Int> ($struct_loc<Int> block@325@01 4))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (>
    ($unwrap<Int> l$deadline@321@01)
    ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
  (and
    (> ($unwrap<Int> l$max_tokens@320@01) 0)
    (> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 0)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (>
      ($unwrap<Int> l$deadline@321@01)
      ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
    (and
      (> ($unwrap<Int> l$max_tokens@320@01) 0)
      (> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 0))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 52 | !($unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)) && $unwrap[Int](l$max_tokens@320@01) > 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 0) | live]
; [else-branch: 52 | $unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)) && $unwrap[Int](l$max_tokens@320@01) > 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 0 | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 52 | !($unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)) && $unwrap[Int](l$max_tokens@320@01) > 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 0)]
(assert (not
  (and
    (>
      ($unwrap<Int> l$deadline@321@01)
      ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
    (and
      (> ($unwrap<Int> l$max_tokens@320@01) 0)
      (> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 0)))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 53 | True | live]
; [else-branch: 53 | False | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 53 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@420@01 $Snap)
(assert (= $t@420@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@421@01 $Struct)
(assert (=
  self@421@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 4
; [then-branch: 54 | False | dead]
; [else-branch: 54 | True | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 54 | True]
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 52 | $unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)) && $unwrap[Int](l$max_tokens@320@01) > 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 0]
(assert (and
  (>
    ($unwrap<Int> l$deadline@321@01)
    ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
  (and
    (> ($unwrap<Int> l$max_tokens@320@01) 0)
    (> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 0))))
(pop) ; 3
; [eval] !!($unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$max_tokens) > 0 && ($struct_get($struct_loc(msg, 1)): Int) > 0))
; [eval] !($unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$max_tokens) > 0 && ($struct_get($struct_loc(msg, 1)): Int) > 0))
; [eval] $unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$max_tokens) > 0 && ($struct_get($struct_loc(msg, 1)): Int) > 0)
; [eval] $unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int)
; [eval] $unwrap(l$deadline)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(push) ; 3
; [then-branch: 55 | !($unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4))) | live]
; [else-branch: 55 | $unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)) | live]
(push) ; 4
; [then-branch: 55 | !($unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)))]
(assert (not
  (>
    ($unwrap<Int> l$deadline@321@01)
    ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))))
(pop) ; 4
(push) ; 4
; [else-branch: 55 | $unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4))]
(assert (>
  ($unwrap<Int> l$deadline@321@01)
  ($struct_get<Int> ($struct_loc<Int> block@325@01 4))))
; [eval] $unwrap(l$max_tokens) > 0
; [eval] $unwrap(l$max_tokens)
(push) ; 5
; [then-branch: 56 | !($unwrap[Int](l$max_tokens@320@01) > 0) | live]
; [else-branch: 56 | $unwrap[Int](l$max_tokens@320@01) > 0 | live]
(push) ; 6
; [then-branch: 56 | !($unwrap[Int](l$max_tokens@320@01) > 0)]
(assert (not (> ($unwrap<Int> l$max_tokens@320@01) 0)))
(pop) ; 6
(push) ; 6
; [else-branch: 56 | $unwrap[Int](l$max_tokens@320@01) > 0]
(assert (> ($unwrap<Int> l$max_tokens@320@01) 0))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) > 0
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (> ($unwrap<Int> l$max_tokens@320@01) 0)
  (not (> ($unwrap<Int> l$max_tokens@320@01) 0))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (>
      ($unwrap<Int> l$deadline@321@01)
      ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
    (and
      (> ($unwrap<Int> l$max_tokens@320@01) 0)
      (> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 0))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (>
    ($unwrap<Int> l$deadline@321@01)
    ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
  (and
    (> ($unwrap<Int> l$max_tokens@320@01) 0)
    (> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 0)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 57 | $unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)) && $unwrap[Int](l$max_tokens@320@01) > 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 0 | live]
; [else-branch: 57 | !($unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)) && $unwrap[Int](l$max_tokens@320@01) > 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 0) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 57 | $unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)) && $unwrap[Int](l$max_tokens@320@01) > 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 0]
(assert (and
  (>
    ($unwrap<Int> l$deadline@321@01)
    ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
  (and
    (> ($unwrap<Int> l$max_tokens@320@01) 0)
    (> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 0))))
; [exec]
; l$total_liquidity := $wrap(($struct_get($struct_loc(self, 3)): Int))
; [eval] $wrap(($struct_get($struct_loc(self, 3)): Int))
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(declare-const l$total_liquidity@422@01 $Int)
(assert (=
  l$total_liquidity@422@01
  ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@419@01 3)))))
; [eval] $unwrap(l$total_liquidity) > 0
; [eval] $unwrap(l$total_liquidity)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (> ($unwrap<Int> l$total_liquidity@422@01) 0))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (> ($unwrap<Int> l$total_liquidity@422@01) 0)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 58 | $unwrap[Int](l$total_liquidity@422@01) > 0 | live]
; [else-branch: 58 | !($unwrap[Int](l$total_liquidity@422@01) > 0) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 58 | $unwrap[Int](l$total_liquidity@422@01) > 0]
(assert (> ($unwrap<Int> l$total_liquidity@422@01) 0))
; [eval] !($unwrap(l$min_liquidity) > 0)
; [eval] $unwrap(l$min_liquidity) > 0
; [eval] $unwrap(l$min_liquidity)
(push) ; 5
(set-option :timeout 10)
(assert (not (> ($unwrap<Int> l$min_liquidity@319@01) 0)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not (> ($unwrap<Int> l$min_liquidity@319@01) 0))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 59 | !($unwrap[Int](l$min_liquidity@319@01) > 0) | live]
; [else-branch: 59 | $unwrap[Int](l$min_liquidity@319@01) > 0 | live]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 59 | !($unwrap[Int](l$min_liquidity@319@01) > 0)]
(assert (not (> ($unwrap<Int> l$min_liquidity@319@01) 0)))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 6
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 60 | True | live]
; [else-branch: 60 | False | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 60 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@423@01 $Snap)
(assert (= $t@423@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@424@01 $Struct)
(assert (=
  self@424@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 6
; [then-branch: 61 | False | dead]
; [else-branch: 61 | True | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 61 | True]
(pop) ; 6
(pop) ; 5
(push) ; 5
; [else-branch: 59 | $unwrap[Int](l$min_liquidity@319@01) > 0]
(assert (> ($unwrap<Int> l$min_liquidity@319@01) 0))
(pop) ; 5
; [eval] !!($unwrap(l$min_liquidity) > 0)
; [eval] !($unwrap(l$min_liquidity) > 0)
; [eval] $unwrap(l$min_liquidity) > 0
; [eval] $unwrap(l$min_liquidity)
(push) ; 5
(set-option :timeout 10)
(assert (not (not (> ($unwrap<Int> l$min_liquidity@319@01) 0))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (> ($unwrap<Int> l$min_liquidity@319@01) 0)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 62 | $unwrap[Int](l$min_liquidity@319@01) > 0 | live]
; [else-branch: 62 | !($unwrap[Int](l$min_liquidity@319@01) > 0) | live]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 62 | $unwrap[Int](l$min_liquidity@319@01) > 0]
(assert (> ($unwrap<Int> l$min_liquidity@319@01) 0))
; [eval] ($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int) < 0
; [eval] ($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
      ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
    0))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 63 | $struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) < 0 | dead]
; [else-branch: 63 | !($struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) < 0) | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 63 | !($struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) < 0)]
(assert (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
      ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
    0)))
(pop) ; 6
; [eval] !(($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int) < 0)
; [eval] ($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int) < 0
; [eval] ($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 6
(set-option :timeout 10)
(assert (not (<
  (-
    ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
    ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
  0)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
      ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
    0))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 64 | !($struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) < 0) | live]
; [else-branch: 64 | $struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) < 0 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 64 | !($struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) < 0)]
(assert (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
      ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
    0)))
; [eval] ($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
      ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 65 | $struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 65 | !($struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 65 | !($struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
      ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 7
; [eval] !(($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] ($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 7
(set-option :timeout 10)
(assert (not (>
  (-
    ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
    ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
      ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 66 | !($struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 66 | $struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 66 | !($struct_get[Int]($struct_loc[Int](self@419@01, 8)) - $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
      ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$eth_reserve := $wrap(($struct_get($struct_loc(self, 8)): Int) -
;   ($struct_get($struct_loc(msg, 1)): Int))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int) - ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const l$eth_reserve@425@01 $Int)
(assert (=
  l$eth_reserve@425@01
  ($wrap<$Int> (-
    ($struct_get<Int> ($struct_loc<Int> self@419@01 8))
    ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@426@01 Int)
(declare-const $arg1@427@01 Int)
(declare-const $arg2@428@01 Int)
(push) ; 8
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
(declare-const sm@429@01 $PSF<e$TokenPurchase>)
(declare-const s@430@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@431@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef1|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef2|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@426@01)
    ($SortWrappers.IntTo$Snap $arg1@427@01))
  ($SortWrappers.IntTo$Snap $arg2@428@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@426@01)
    ($SortWrappers.IntTo$Snap $arg1@427@01))
  ($SortWrappers.IntTo$Snap $arg2@428@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@426@01)
      ($SortWrappers.IntTo$Snap $arg1@427@01))
    ($SortWrappers.IntTo$Snap $arg2@428@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@432@01 (Int Int Int) Int)
(declare-fun img@433@01 (Int Int Int) Bool)
(declare-fun inv@434@01 (Int Int Int) Int)
(declare-fun img@435@01 (Int Int Int) Bool)
(declare-fun inv@436@01 (Int Int Int) Int)
(declare-fun img@437@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef1|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef2|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@426@01 Int) ($arg1@427@01 Int) ($arg2@428@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@426@01)
          ($SortWrappers.IntTo$Snap $arg1@427@01))
        ($SortWrappers.IntTo$Snap $arg2@428@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@426@01)
        ($SortWrappers.IntTo$Snap $arg1@427@01))
      ($SortWrappers.IntTo$Snap $arg2@428@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@426@01)
        ($SortWrappers.IntTo$Snap $arg1@427@01))
      ($SortWrappers.IntTo$Snap $arg2@428@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@426@01)
      ($SortWrappers.IntTo$Snap $arg1@427@01))
    ($SortWrappers.IntTo$Snap $arg2@428@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@426@01)
      ($SortWrappers.IntTo$Snap $arg1@427@01))
    ($SortWrappers.IntTo$Snap $arg2@428@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 8
(assert (not (forall (($arg0@426@01 Int) ($arg1@427@01 Int) ($arg2@428@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@426@01)
          ($SortWrappers.IntTo$Snap $arg1@427@01))
        ($SortWrappers.IntTo$Snap $arg2@428@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@426@01)
            ($SortWrappers.IntTo$Snap $arg1@427@01))
          ($SortWrappers.IntTo$Snap $arg2@428@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@426@01)
            ($SortWrappers.IntTo$Snap $arg1@427@01))
          ($SortWrappers.IntTo$Snap $arg2@428@01))))))
  
  :qid |quant-u-1580|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@426@01 Int) ($arg11@427@01 Int) ($arg21@428@01 Int) ($arg02@426@01 Int) ($arg12@427@01 Int) ($arg22@428@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@426@01)
                ($SortWrappers.IntTo$Snap $arg11@427@01))
              ($SortWrappers.IntTo$Snap $arg21@428@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@426@01)
              ($SortWrappers.IntTo$Snap $arg11@427@01))
            ($SortWrappers.IntTo$Snap $arg21@428@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@426@01)
              ($SortWrappers.IntTo$Snap $arg11@427@01))
            ($SortWrappers.IntTo$Snap $arg21@428@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@426@01)
              ($SortWrappers.IntTo$Snap $arg11@427@01))
            ($SortWrappers.IntTo$Snap $arg21@428@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@426@01)
                ($SortWrappers.IntTo$Snap $arg12@427@01))
              ($SortWrappers.IntTo$Snap $arg22@428@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@426@01)
              ($SortWrappers.IntTo$Snap $arg12@427@01))
            ($SortWrappers.IntTo$Snap $arg22@428@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@426@01)
              ($SortWrappers.IntTo$Snap $arg12@427@01))
            ($SortWrappers.IntTo$Snap $arg22@428@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@426@01)
              ($SortWrappers.IntTo$Snap $arg12@427@01))
            ($SortWrappers.IntTo$Snap $arg22@428@01)))))
      (and
        (and (= $arg01@426@01 $arg02@426@01) (= $arg11@427@01 $arg12@427@01))
        (= $arg21@428@01 $arg22@428@01)))
    (and
      (and (= $arg01@426@01 $arg02@426@01) (= $arg11@427@01 $arg12@427@01))
      (= $arg21@428@01 $arg22@428@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@426@01 Int) ($arg1@427@01 Int) ($arg2@428@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@426@01)
            ($SortWrappers.IntTo$Snap $arg1@427@01))
          ($SortWrappers.IntTo$Snap $arg2@428@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@426@01)
            ($SortWrappers.IntTo$Snap $arg1@427@01))
          ($SortWrappers.IntTo$Snap $arg2@428@01)))))
    (and
      (and
        (= (inv@432@01 $arg0@426@01 $arg1@427@01 $arg2@428@01) $arg0@426@01)
        (= (inv@434@01 $arg0@426@01 $arg1@427@01 $arg2@428@01) $arg1@427@01)
        (= (inv@436@01 $arg0@426@01 $arg1@427@01 $arg2@428@01) $arg2@428@01))
      (and
        (img@433@01 $arg0@426@01 $arg1@427@01 $arg2@428@01)
        (img@435@01 $arg0@426@01 $arg1@427@01 $arg2@428@01)
        (img@437@01 $arg0@426@01 $arg1@427@01 $arg2@428@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@426@01)
      ($SortWrappers.IntTo$Snap $arg1@427@01))
    ($SortWrappers.IntTo$Snap $arg2@428@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@426@01)
      ($SortWrappers.IntTo$Snap $arg1@427@01))
    ($SortWrappers.IntTo$Snap $arg2@428@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@433@01 $arg0 $arg1 $arg2)
        (img@435@01 $arg0 $arg1 $arg2)
        (img@437@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@432@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@434@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@436@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@432@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@434@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@436@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@432@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@434@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@436@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@432@01 $arg0 $arg1 $arg2))
  :pattern ((inv@434@01 $arg0 $arg1 $arg2))
  :pattern ((inv@436@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@432@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@434@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@436@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@432@01 $arg0 $arg1 $arg2) (inv@434@01 $arg0 $arg1 $arg2) (inv@436@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1581|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@432@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@434@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@436@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@433@01 $arg0 $arg1 $arg2)
        (img@435@01 $arg0 $arg1 $arg2)
        (img@437@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@432@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@434@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@436@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@431@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@432@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@434@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@436@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1582|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@438@01 Int)
(declare-const $arg1@439@01 Int)
(declare-const $arg2@440@01 Int)
(push) ; 8
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
(declare-const sm@441@01 $PSF<e$EthPurchase>)
(declare-const s@442@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@443@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef4|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef5|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@438@01)
    ($SortWrappers.IntTo$Snap $arg1@439@01))
  ($SortWrappers.IntTo$Snap $arg2@440@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@438@01)
    ($SortWrappers.IntTo$Snap $arg1@439@01))
  ($SortWrappers.IntTo$Snap $arg2@440@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@438@01)
      ($SortWrappers.IntTo$Snap $arg1@439@01))
    ($SortWrappers.IntTo$Snap $arg2@440@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@444@01 (Int Int Int) Int)
(declare-fun img@445@01 (Int Int Int) Bool)
(declare-fun inv@446@01 (Int Int Int) Int)
(declare-fun img@447@01 (Int Int Int) Bool)
(declare-fun inv@448@01 (Int Int Int) Int)
(declare-fun img@449@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef4|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef5|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@438@01 Int) ($arg1@439@01 Int) ($arg2@440@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@438@01)
          ($SortWrappers.IntTo$Snap $arg1@439@01))
        ($SortWrappers.IntTo$Snap $arg2@440@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@438@01)
        ($SortWrappers.IntTo$Snap $arg1@439@01))
      ($SortWrappers.IntTo$Snap $arg2@440@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@438@01)
        ($SortWrappers.IntTo$Snap $arg1@439@01))
      ($SortWrappers.IntTo$Snap $arg2@440@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@438@01)
      ($SortWrappers.IntTo$Snap $arg1@439@01))
    ($SortWrappers.IntTo$Snap $arg2@440@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@438@01)
      ($SortWrappers.IntTo$Snap $arg1@439@01))
    ($SortWrappers.IntTo$Snap $arg2@440@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 8
(assert (not (forall (($arg0@438@01 Int) ($arg1@439@01 Int) ($arg2@440@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@438@01)
          ($SortWrappers.IntTo$Snap $arg1@439@01))
        ($SortWrappers.IntTo$Snap $arg2@440@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@438@01)
            ($SortWrappers.IntTo$Snap $arg1@439@01))
          ($SortWrappers.IntTo$Snap $arg2@440@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@438@01)
            ($SortWrappers.IntTo$Snap $arg1@439@01))
          ($SortWrappers.IntTo$Snap $arg2@440@01))))))
  
  :qid |quant-u-1583|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@438@01 Int) ($arg11@439@01 Int) ($arg21@440@01 Int) ($arg02@438@01 Int) ($arg12@439@01 Int) ($arg22@440@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@438@01)
                ($SortWrappers.IntTo$Snap $arg11@439@01))
              ($SortWrappers.IntTo$Snap $arg21@440@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@438@01)
              ($SortWrappers.IntTo$Snap $arg11@439@01))
            ($SortWrappers.IntTo$Snap $arg21@440@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@438@01)
              ($SortWrappers.IntTo$Snap $arg11@439@01))
            ($SortWrappers.IntTo$Snap $arg21@440@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@438@01)
              ($SortWrappers.IntTo$Snap $arg11@439@01))
            ($SortWrappers.IntTo$Snap $arg21@440@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@438@01)
                ($SortWrappers.IntTo$Snap $arg12@439@01))
              ($SortWrappers.IntTo$Snap $arg22@440@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@438@01)
              ($SortWrappers.IntTo$Snap $arg12@439@01))
            ($SortWrappers.IntTo$Snap $arg22@440@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@438@01)
              ($SortWrappers.IntTo$Snap $arg12@439@01))
            ($SortWrappers.IntTo$Snap $arg22@440@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@438@01)
              ($SortWrappers.IntTo$Snap $arg12@439@01))
            ($SortWrappers.IntTo$Snap $arg22@440@01)))))
      (and
        (and (= $arg01@438@01 $arg02@438@01) (= $arg11@439@01 $arg12@439@01))
        (= $arg21@440@01 $arg22@440@01)))
    (and
      (and (= $arg01@438@01 $arg02@438@01) (= $arg11@439@01 $arg12@439@01))
      (= $arg21@440@01 $arg22@440@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@438@01 Int) ($arg1@439@01 Int) ($arg2@440@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@438@01)
            ($SortWrappers.IntTo$Snap $arg1@439@01))
          ($SortWrappers.IntTo$Snap $arg2@440@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@438@01)
            ($SortWrappers.IntTo$Snap $arg1@439@01))
          ($SortWrappers.IntTo$Snap $arg2@440@01)))))
    (and
      (and
        (= (inv@444@01 $arg0@438@01 $arg1@439@01 $arg2@440@01) $arg0@438@01)
        (= (inv@446@01 $arg0@438@01 $arg1@439@01 $arg2@440@01) $arg1@439@01)
        (= (inv@448@01 $arg0@438@01 $arg1@439@01 $arg2@440@01) $arg2@440@01))
      (and
        (img@445@01 $arg0@438@01 $arg1@439@01 $arg2@440@01)
        (img@447@01 $arg0@438@01 $arg1@439@01 $arg2@440@01)
        (img@449@01 $arg0@438@01 $arg1@439@01 $arg2@440@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@438@01)
      ($SortWrappers.IntTo$Snap $arg1@439@01))
    ($SortWrappers.IntTo$Snap $arg2@440@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@438@01)
      ($SortWrappers.IntTo$Snap $arg1@439@01))
    ($SortWrappers.IntTo$Snap $arg2@440@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@445@01 $arg0 $arg1 $arg2)
        (img@447@01 $arg0 $arg1 $arg2)
        (img@449@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@444@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@446@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@448@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@444@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@446@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@448@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@444@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@446@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@448@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@444@01 $arg0 $arg1 $arg2))
  :pattern ((inv@446@01 $arg0 $arg1 $arg2))
  :pattern ((inv@448@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@444@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@446@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@448@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@444@01 $arg0 $arg1 $arg2) (inv@446@01 $arg0 $arg1 $arg2) (inv@448@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1584|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@444@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@446@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@448@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@445@01 $arg0 $arg1 $arg2)
        (img@447@01 $arg0 $arg1 $arg2)
        (img@449@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@444@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@446@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@448@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@443@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@444@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@446@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@448@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1585|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@450@01 Int)
(declare-const $arg1@451@01 Int)
(declare-const $arg2@452@01 Int)
(push) ; 8
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
(declare-const sm@453@01 $PSF<e$AddLiquidity>)
(declare-const s@454@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@455@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef7|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef8|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@450@01)
    ($SortWrappers.IntTo$Snap $arg1@451@01))
  ($SortWrappers.IntTo$Snap $arg2@452@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@450@01)
    ($SortWrappers.IntTo$Snap $arg1@451@01))
  ($SortWrappers.IntTo$Snap $arg2@452@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@450@01)
      ($SortWrappers.IntTo$Snap $arg1@451@01))
    ($SortWrappers.IntTo$Snap $arg2@452@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@456@01 (Int Int Int) Int)
(declare-fun img@457@01 (Int Int Int) Bool)
(declare-fun inv@458@01 (Int Int Int) Int)
(declare-fun img@459@01 (Int Int Int) Bool)
(declare-fun inv@460@01 (Int Int Int) Int)
(declare-fun img@461@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef7|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef8|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@450@01 Int) ($arg1@451@01 Int) ($arg2@452@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@450@01)
          ($SortWrappers.IntTo$Snap $arg1@451@01))
        ($SortWrappers.IntTo$Snap $arg2@452@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@450@01)
        ($SortWrappers.IntTo$Snap $arg1@451@01))
      ($SortWrappers.IntTo$Snap $arg2@452@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@450@01)
        ($SortWrappers.IntTo$Snap $arg1@451@01))
      ($SortWrappers.IntTo$Snap $arg2@452@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@450@01)
      ($SortWrappers.IntTo$Snap $arg1@451@01))
    ($SortWrappers.IntTo$Snap $arg2@452@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@450@01)
      ($SortWrappers.IntTo$Snap $arg1@451@01))
    ($SortWrappers.IntTo$Snap $arg2@452@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 8
(assert (not (forall (($arg0@450@01 Int) ($arg1@451@01 Int) ($arg2@452@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@450@01)
          ($SortWrappers.IntTo$Snap $arg1@451@01))
        ($SortWrappers.IntTo$Snap $arg2@452@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@450@01)
            ($SortWrappers.IntTo$Snap $arg1@451@01))
          ($SortWrappers.IntTo$Snap $arg2@452@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@450@01)
            ($SortWrappers.IntTo$Snap $arg1@451@01))
          ($SortWrappers.IntTo$Snap $arg2@452@01))))))
  
  :qid |quant-u-1586|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@450@01 Int) ($arg11@451@01 Int) ($arg21@452@01 Int) ($arg02@450@01 Int) ($arg12@451@01 Int) ($arg22@452@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@450@01)
                ($SortWrappers.IntTo$Snap $arg11@451@01))
              ($SortWrappers.IntTo$Snap $arg21@452@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@450@01)
              ($SortWrappers.IntTo$Snap $arg11@451@01))
            ($SortWrappers.IntTo$Snap $arg21@452@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@450@01)
              ($SortWrappers.IntTo$Snap $arg11@451@01))
            ($SortWrappers.IntTo$Snap $arg21@452@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@450@01)
              ($SortWrappers.IntTo$Snap $arg11@451@01))
            ($SortWrappers.IntTo$Snap $arg21@452@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@450@01)
                ($SortWrappers.IntTo$Snap $arg12@451@01))
              ($SortWrappers.IntTo$Snap $arg22@452@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@450@01)
              ($SortWrappers.IntTo$Snap $arg12@451@01))
            ($SortWrappers.IntTo$Snap $arg22@452@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@450@01)
              ($SortWrappers.IntTo$Snap $arg12@451@01))
            ($SortWrappers.IntTo$Snap $arg22@452@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@450@01)
              ($SortWrappers.IntTo$Snap $arg12@451@01))
            ($SortWrappers.IntTo$Snap $arg22@452@01)))))
      (and
        (and (= $arg01@450@01 $arg02@450@01) (= $arg11@451@01 $arg12@451@01))
        (= $arg21@452@01 $arg22@452@01)))
    (and
      (and (= $arg01@450@01 $arg02@450@01) (= $arg11@451@01 $arg12@451@01))
      (= $arg21@452@01 $arg22@452@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@450@01 Int) ($arg1@451@01 Int) ($arg2@452@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@450@01)
            ($SortWrappers.IntTo$Snap $arg1@451@01))
          ($SortWrappers.IntTo$Snap $arg2@452@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@450@01)
            ($SortWrappers.IntTo$Snap $arg1@451@01))
          ($SortWrappers.IntTo$Snap $arg2@452@01)))))
    (and
      (and
        (= (inv@456@01 $arg0@450@01 $arg1@451@01 $arg2@452@01) $arg0@450@01)
        (= (inv@458@01 $arg0@450@01 $arg1@451@01 $arg2@452@01) $arg1@451@01)
        (= (inv@460@01 $arg0@450@01 $arg1@451@01 $arg2@452@01) $arg2@452@01))
      (and
        (img@457@01 $arg0@450@01 $arg1@451@01 $arg2@452@01)
        (img@459@01 $arg0@450@01 $arg1@451@01 $arg2@452@01)
        (img@461@01 $arg0@450@01 $arg1@451@01 $arg2@452@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@450@01)
      ($SortWrappers.IntTo$Snap $arg1@451@01))
    ($SortWrappers.IntTo$Snap $arg2@452@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@450@01)
      ($SortWrappers.IntTo$Snap $arg1@451@01))
    ($SortWrappers.IntTo$Snap $arg2@452@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@457@01 $arg0 $arg1 $arg2)
        (img@459@01 $arg0 $arg1 $arg2)
        (img@461@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@456@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@458@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@460@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@456@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@458@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@460@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@456@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@458@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@460@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@456@01 $arg0 $arg1 $arg2))
  :pattern ((inv@458@01 $arg0 $arg1 $arg2))
  :pattern ((inv@460@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@456@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@458@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@460@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@456@01 $arg0 $arg1 $arg2) (inv@458@01 $arg0 $arg1 $arg2) (inv@460@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1587|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@456@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@458@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@460@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@457@01 $arg0 $arg1 $arg2)
        (img@459@01 $arg0 $arg1 $arg2)
        (img@461@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@456@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@458@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@460@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@455@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@456@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@458@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@460@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1588|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@462@01 Int)
(declare-const $arg1@463@01 Int)
(declare-const $arg2@464@01 Int)
(push) ; 8
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
(declare-const sm@465@01 $PSF<e$RemoveLiquidity>)
(declare-const s@466@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@467@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef10|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef11|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@462@01)
    ($SortWrappers.IntTo$Snap $arg1@463@01))
  ($SortWrappers.IntTo$Snap $arg2@464@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@462@01)
    ($SortWrappers.IntTo$Snap $arg1@463@01))
  ($SortWrappers.IntTo$Snap $arg2@464@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@462@01)
      ($SortWrappers.IntTo$Snap $arg1@463@01))
    ($SortWrappers.IntTo$Snap $arg2@464@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@468@01 (Int Int Int) Int)
(declare-fun img@469@01 (Int Int Int) Bool)
(declare-fun inv@470@01 (Int Int Int) Int)
(declare-fun img@471@01 (Int Int Int) Bool)
(declare-fun inv@472@01 (Int Int Int) Int)
(declare-fun img@473@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef10|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef11|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@462@01 Int) ($arg1@463@01 Int) ($arg2@464@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@462@01)
          ($SortWrappers.IntTo$Snap $arg1@463@01))
        ($SortWrappers.IntTo$Snap $arg2@464@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@462@01)
        ($SortWrappers.IntTo$Snap $arg1@463@01))
      ($SortWrappers.IntTo$Snap $arg2@464@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@462@01)
        ($SortWrappers.IntTo$Snap $arg1@463@01))
      ($SortWrappers.IntTo$Snap $arg2@464@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@462@01)
      ($SortWrappers.IntTo$Snap $arg1@463@01))
    ($SortWrappers.IntTo$Snap $arg2@464@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@462@01)
      ($SortWrappers.IntTo$Snap $arg1@463@01))
    ($SortWrappers.IntTo$Snap $arg2@464@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 8
(assert (not (forall (($arg0@462@01 Int) ($arg1@463@01 Int) ($arg2@464@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@462@01)
          ($SortWrappers.IntTo$Snap $arg1@463@01))
        ($SortWrappers.IntTo$Snap $arg2@464@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@462@01)
            ($SortWrappers.IntTo$Snap $arg1@463@01))
          ($SortWrappers.IntTo$Snap $arg2@464@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@462@01)
            ($SortWrappers.IntTo$Snap $arg1@463@01))
          ($SortWrappers.IntTo$Snap $arg2@464@01))))))
  
  :qid |quant-u-1589|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@462@01 Int) ($arg11@463@01 Int) ($arg21@464@01 Int) ($arg02@462@01 Int) ($arg12@463@01 Int) ($arg22@464@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@462@01)
                ($SortWrappers.IntTo$Snap $arg11@463@01))
              ($SortWrappers.IntTo$Snap $arg21@464@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@462@01)
              ($SortWrappers.IntTo$Snap $arg11@463@01))
            ($SortWrappers.IntTo$Snap $arg21@464@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@462@01)
              ($SortWrappers.IntTo$Snap $arg11@463@01))
            ($SortWrappers.IntTo$Snap $arg21@464@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@462@01)
              ($SortWrappers.IntTo$Snap $arg11@463@01))
            ($SortWrappers.IntTo$Snap $arg21@464@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@462@01)
                ($SortWrappers.IntTo$Snap $arg12@463@01))
              ($SortWrappers.IntTo$Snap $arg22@464@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@462@01)
              ($SortWrappers.IntTo$Snap $arg12@463@01))
            ($SortWrappers.IntTo$Snap $arg22@464@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@462@01)
              ($SortWrappers.IntTo$Snap $arg12@463@01))
            ($SortWrappers.IntTo$Snap $arg22@464@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@462@01)
              ($SortWrappers.IntTo$Snap $arg12@463@01))
            ($SortWrappers.IntTo$Snap $arg22@464@01)))))
      (and
        (and (= $arg01@462@01 $arg02@462@01) (= $arg11@463@01 $arg12@463@01))
        (= $arg21@464@01 $arg22@464@01)))
    (and
      (and (= $arg01@462@01 $arg02@462@01) (= $arg11@463@01 $arg12@463@01))
      (= $arg21@464@01 $arg22@464@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@462@01 Int) ($arg1@463@01 Int) ($arg2@464@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@462@01)
            ($SortWrappers.IntTo$Snap $arg1@463@01))
          ($SortWrappers.IntTo$Snap $arg2@464@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@462@01)
            ($SortWrappers.IntTo$Snap $arg1@463@01))
          ($SortWrappers.IntTo$Snap $arg2@464@01)))))
    (and
      (and
        (= (inv@468@01 $arg0@462@01 $arg1@463@01 $arg2@464@01) $arg0@462@01)
        (= (inv@470@01 $arg0@462@01 $arg1@463@01 $arg2@464@01) $arg1@463@01)
        (= (inv@472@01 $arg0@462@01 $arg1@463@01 $arg2@464@01) $arg2@464@01))
      (and
        (img@469@01 $arg0@462@01 $arg1@463@01 $arg2@464@01)
        (img@471@01 $arg0@462@01 $arg1@463@01 $arg2@464@01)
        (img@473@01 $arg0@462@01 $arg1@463@01 $arg2@464@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@462@01)
      ($SortWrappers.IntTo$Snap $arg1@463@01))
    ($SortWrappers.IntTo$Snap $arg2@464@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@462@01)
      ($SortWrappers.IntTo$Snap $arg1@463@01))
    ($SortWrappers.IntTo$Snap $arg2@464@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@469@01 $arg0 $arg1 $arg2)
        (img@471@01 $arg0 $arg1 $arg2)
        (img@473@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@468@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@470@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@472@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@468@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@470@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@472@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@468@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@470@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@472@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@468@01 $arg0 $arg1 $arg2))
  :pattern ((inv@470@01 $arg0 $arg1 $arg2))
  :pattern ((inv@472@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@468@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@470@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@472@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@468@01 $arg0 $arg1 $arg2) (inv@470@01 $arg0 $arg1 $arg2) (inv@472@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1590|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@468@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@470@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@472@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@469@01 $arg0 $arg1 $arg2)
        (img@471@01 $arg0 $arg1 $arg2)
        (img@473@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@468@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@470@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@472@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@467@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@468@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@470@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@472@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1591|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@474@01 Int)
(declare-const $arg1@475@01 Int)
(declare-const $arg2@476@01 Int)
(push) ; 8
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
(declare-const sm@477@01 $PSF<e$Transfer>)
(declare-const s@478@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@479@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef13|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef14|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@474@01)
    ($SortWrappers.IntTo$Snap $arg1@475@01))
  ($SortWrappers.IntTo$Snap $arg2@476@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@474@01)
    ($SortWrappers.IntTo$Snap $arg1@475@01))
  ($SortWrappers.IntTo$Snap $arg2@476@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@474@01)
      ($SortWrappers.IntTo$Snap $arg1@475@01))
    ($SortWrappers.IntTo$Snap $arg2@476@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@480@01 (Int Int Int) Int)
(declare-fun img@481@01 (Int Int Int) Bool)
(declare-fun inv@482@01 (Int Int Int) Int)
(declare-fun img@483@01 (Int Int Int) Bool)
(declare-fun inv@484@01 (Int Int Int) Int)
(declare-fun img@485@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef13|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef14|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@474@01 Int) ($arg1@475@01 Int) ($arg2@476@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@474@01)
          ($SortWrappers.IntTo$Snap $arg1@475@01))
        ($SortWrappers.IntTo$Snap $arg2@476@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@474@01)
        ($SortWrappers.IntTo$Snap $arg1@475@01))
      ($SortWrappers.IntTo$Snap $arg2@476@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@474@01)
        ($SortWrappers.IntTo$Snap $arg1@475@01))
      ($SortWrappers.IntTo$Snap $arg2@476@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@474@01)
      ($SortWrappers.IntTo$Snap $arg1@475@01))
    ($SortWrappers.IntTo$Snap $arg2@476@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@474@01)
      ($SortWrappers.IntTo$Snap $arg1@475@01))
    ($SortWrappers.IntTo$Snap $arg2@476@01))))
  :qid |e$Transfer-aux|)))
(push) ; 8
(assert (not (forall (($arg0@474@01 Int) ($arg1@475@01 Int) ($arg2@476@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@474@01)
          ($SortWrappers.IntTo$Snap $arg1@475@01))
        ($SortWrappers.IntTo$Snap $arg2@476@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@474@01)
            ($SortWrappers.IntTo$Snap $arg1@475@01))
          ($SortWrappers.IntTo$Snap $arg2@476@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@474@01)
            ($SortWrappers.IntTo$Snap $arg1@475@01))
          ($SortWrappers.IntTo$Snap $arg2@476@01))))))
  
  :qid |quant-u-1592|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@474@01 Int) ($arg11@475@01 Int) ($arg21@476@01 Int) ($arg02@474@01 Int) ($arg12@475@01 Int) ($arg22@476@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@474@01)
                ($SortWrappers.IntTo$Snap $arg11@475@01))
              ($SortWrappers.IntTo$Snap $arg21@476@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@474@01)
              ($SortWrappers.IntTo$Snap $arg11@475@01))
            ($SortWrappers.IntTo$Snap $arg21@476@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@474@01)
              ($SortWrappers.IntTo$Snap $arg11@475@01))
            ($SortWrappers.IntTo$Snap $arg21@476@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@474@01)
              ($SortWrappers.IntTo$Snap $arg11@475@01))
            ($SortWrappers.IntTo$Snap $arg21@476@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@474@01)
                ($SortWrappers.IntTo$Snap $arg12@475@01))
              ($SortWrappers.IntTo$Snap $arg22@476@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@474@01)
              ($SortWrappers.IntTo$Snap $arg12@475@01))
            ($SortWrappers.IntTo$Snap $arg22@476@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@474@01)
              ($SortWrappers.IntTo$Snap $arg12@475@01))
            ($SortWrappers.IntTo$Snap $arg22@476@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@474@01)
              ($SortWrappers.IntTo$Snap $arg12@475@01))
            ($SortWrappers.IntTo$Snap $arg22@476@01)))))
      (and
        (and (= $arg01@474@01 $arg02@474@01) (= $arg11@475@01 $arg12@475@01))
        (= $arg21@476@01 $arg22@476@01)))
    (and
      (and (= $arg01@474@01 $arg02@474@01) (= $arg11@475@01 $arg12@475@01))
      (= $arg21@476@01 $arg22@476@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@474@01 Int) ($arg1@475@01 Int) ($arg2@476@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@474@01)
            ($SortWrappers.IntTo$Snap $arg1@475@01))
          ($SortWrappers.IntTo$Snap $arg2@476@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@474@01)
            ($SortWrappers.IntTo$Snap $arg1@475@01))
          ($SortWrappers.IntTo$Snap $arg2@476@01)))))
    (and
      (and
        (= (inv@480@01 $arg0@474@01 $arg1@475@01 $arg2@476@01) $arg0@474@01)
        (= (inv@482@01 $arg0@474@01 $arg1@475@01 $arg2@476@01) $arg1@475@01)
        (= (inv@484@01 $arg0@474@01 $arg1@475@01 $arg2@476@01) $arg2@476@01))
      (and
        (img@481@01 $arg0@474@01 $arg1@475@01 $arg2@476@01)
        (img@483@01 $arg0@474@01 $arg1@475@01 $arg2@476@01)
        (img@485@01 $arg0@474@01 $arg1@475@01 $arg2@476@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@474@01)
      ($SortWrappers.IntTo$Snap $arg1@475@01))
    ($SortWrappers.IntTo$Snap $arg2@476@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@474@01)
      ($SortWrappers.IntTo$Snap $arg1@475@01))
    ($SortWrappers.IntTo$Snap $arg2@476@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@481@01 $arg0 $arg1 $arg2)
        (img@483@01 $arg0 $arg1 $arg2)
        (img@485@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@480@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@482@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@484@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@480@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@482@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@484@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@480@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@482@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@484@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@480@01 $arg0 $arg1 $arg2))
  :pattern ((inv@482@01 $arg0 $arg1 $arg2))
  :pattern ((inv@484@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@480@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@482@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@484@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@480@01 $arg0 $arg1 $arg2) (inv@482@01 $arg0 $arg1 $arg2) (inv@484@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1593|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@480@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@482@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@484@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@481@01 $arg0 $arg1 $arg2)
        (img@483@01 $arg0 $arg1 $arg2)
        (img@485@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@480@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@482@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@484@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@479@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@480@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@482@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@484@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1594|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@486@01 Int)
(declare-const $arg1@487@01 Int)
(declare-const $arg2@488@01 Int)
(push) ; 8
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
(declare-const sm@489@01 $PSF<e$Approval>)
(declare-const s@490@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@491@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef16|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef17|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@486@01)
    ($SortWrappers.IntTo$Snap $arg1@487@01))
  ($SortWrappers.IntTo$Snap $arg2@488@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@486@01)
    ($SortWrappers.IntTo$Snap $arg1@487@01))
  ($SortWrappers.IntTo$Snap $arg2@488@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@486@01)
      ($SortWrappers.IntTo$Snap $arg1@487@01))
    ($SortWrappers.IntTo$Snap $arg2@488@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@492@01 (Int Int Int) Int)
(declare-fun img@493@01 (Int Int Int) Bool)
(declare-fun inv@494@01 (Int Int Int) Int)
(declare-fun img@495@01 (Int Int Int) Bool)
(declare-fun inv@496@01 (Int Int Int) Int)
(declare-fun img@497@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef16|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef17|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@486@01 Int) ($arg1@487@01 Int) ($arg2@488@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@486@01)
          ($SortWrappers.IntTo$Snap $arg1@487@01))
        ($SortWrappers.IntTo$Snap $arg2@488@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@486@01)
        ($SortWrappers.IntTo$Snap $arg1@487@01))
      ($SortWrappers.IntTo$Snap $arg2@488@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@486@01)
        ($SortWrappers.IntTo$Snap $arg1@487@01))
      ($SortWrappers.IntTo$Snap $arg2@488@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@486@01)
      ($SortWrappers.IntTo$Snap $arg1@487@01))
    ($SortWrappers.IntTo$Snap $arg2@488@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@486@01)
      ($SortWrappers.IntTo$Snap $arg1@487@01))
    ($SortWrappers.IntTo$Snap $arg2@488@01))))
  :qid |e$Approval-aux|)))
(push) ; 8
(assert (not (forall (($arg0@486@01 Int) ($arg1@487@01 Int) ($arg2@488@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@486@01)
          ($SortWrappers.IntTo$Snap $arg1@487@01))
        ($SortWrappers.IntTo$Snap $arg2@488@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@486@01)
            ($SortWrappers.IntTo$Snap $arg1@487@01))
          ($SortWrappers.IntTo$Snap $arg2@488@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@486@01)
            ($SortWrappers.IntTo$Snap $arg1@487@01))
          ($SortWrappers.IntTo$Snap $arg2@488@01))))))
  
  :qid |quant-u-1595|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@486@01 Int) ($arg11@487@01 Int) ($arg21@488@01 Int) ($arg02@486@01 Int) ($arg12@487@01 Int) ($arg22@488@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@486@01)
                ($SortWrappers.IntTo$Snap $arg11@487@01))
              ($SortWrappers.IntTo$Snap $arg21@488@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@486@01)
              ($SortWrappers.IntTo$Snap $arg11@487@01))
            ($SortWrappers.IntTo$Snap $arg21@488@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@486@01)
              ($SortWrappers.IntTo$Snap $arg11@487@01))
            ($SortWrappers.IntTo$Snap $arg21@488@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@486@01)
              ($SortWrappers.IntTo$Snap $arg11@487@01))
            ($SortWrappers.IntTo$Snap $arg21@488@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@486@01)
                ($SortWrappers.IntTo$Snap $arg12@487@01))
              ($SortWrappers.IntTo$Snap $arg22@488@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@486@01)
              ($SortWrappers.IntTo$Snap $arg12@487@01))
            ($SortWrappers.IntTo$Snap $arg22@488@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@486@01)
              ($SortWrappers.IntTo$Snap $arg12@487@01))
            ($SortWrappers.IntTo$Snap $arg22@488@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@486@01)
              ($SortWrappers.IntTo$Snap $arg12@487@01))
            ($SortWrappers.IntTo$Snap $arg22@488@01)))))
      (and
        (and (= $arg01@486@01 $arg02@486@01) (= $arg11@487@01 $arg12@487@01))
        (= $arg21@488@01 $arg22@488@01)))
    (and
      (and (= $arg01@486@01 $arg02@486@01) (= $arg11@487@01 $arg12@487@01))
      (= $arg21@488@01 $arg22@488@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@486@01 Int) ($arg1@487@01 Int) ($arg2@488@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@486@01)
            ($SortWrappers.IntTo$Snap $arg1@487@01))
          ($SortWrappers.IntTo$Snap $arg2@488@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@486@01)
            ($SortWrappers.IntTo$Snap $arg1@487@01))
          ($SortWrappers.IntTo$Snap $arg2@488@01)))))
    (and
      (and
        (= (inv@492@01 $arg0@486@01 $arg1@487@01 $arg2@488@01) $arg0@486@01)
        (= (inv@494@01 $arg0@486@01 $arg1@487@01 $arg2@488@01) $arg1@487@01)
        (= (inv@496@01 $arg0@486@01 $arg1@487@01 $arg2@488@01) $arg2@488@01))
      (and
        (img@493@01 $arg0@486@01 $arg1@487@01 $arg2@488@01)
        (img@495@01 $arg0@486@01 $arg1@487@01 $arg2@488@01)
        (img@497@01 $arg0@486@01 $arg1@487@01 $arg2@488@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@486@01)
      ($SortWrappers.IntTo$Snap $arg1@487@01))
    ($SortWrappers.IntTo$Snap $arg2@488@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@486@01)
      ($SortWrappers.IntTo$Snap $arg1@487@01))
    ($SortWrappers.IntTo$Snap $arg2@488@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@493@01 $arg0 $arg1 $arg2)
        (img@495@01 $arg0 $arg1 $arg2)
        (img@497@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@492@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@494@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@496@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@492@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@494@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@496@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@492@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@494@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@496@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@492@01 $arg0 $arg1 $arg2))
  :pattern ((inv@494@01 $arg0 $arg1 $arg2))
  :pattern ((inv@496@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@492@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@494@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@496@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@492@01 $arg0 $arg1 $arg2) (inv@494@01 $arg0 $arg1 $arg2) (inv@496@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1596|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@492@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@494@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@496@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@493@01 $arg0 $arg1 $arg2)
        (img@495@01 $arg0 $arg1 $arg2)
        (img@497@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@492@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@494@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@496@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@491@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@492@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@494@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@496@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1597|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; inhale 0 <= l$raw_ret &&
;   l$raw_ret <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@498@01 $Snap)
(assert (= $t@498@01 ($Snap.combine ($Snap.first $t@498@01) ($Snap.second $t@498@01))))
(assert (= ($Snap.first $t@498@01) $Snap.unit))
; [eval] 0 <= l$raw_ret
(assert (<= 0 l$raw_ret@340@01))
(assert (= ($Snap.second $t@498@01) $Snap.unit))
; [eval] l$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
(assert (<=
  l$raw_ret@340@01
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not l$send_fail@339@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not l$send_fail@339@01))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 67 | l$send_fail@339@01 | live]
; [else-branch: 67 | !(l$send_fail@339@01) | live]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 67 | l$send_fail@339@01]
(assert l$send_fail@339@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@499@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 68 | True | live]
; [else-branch: 68 | False | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 68 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@500@01 $Snap)
(assert (= $t@500@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@501@01 $Struct)
(assert (=
  self@501@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 9
; [then-branch: 69 | False | dead]
; [else-branch: 69 | True | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 69 | True]
(pop) ; 9
(pop) ; 8
(push) ; 8
; [else-branch: 67 | !(l$send_fail@339@01)]
(assert (not l$send_fail@339@01))
(pop) ; 8
; [eval] !l$send_fail
(push) ; 8
(set-option :timeout 10)
(assert (not l$send_fail@339@01))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not l$send_fail@339@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 70 | !(l$send_fail@339@01) | live]
; [else-branch: 70 | l$send_fail@339@01 | live]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 70 | !(l$send_fail@339@01)]
(assert (not l$send_fail@339@01))
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; l$token_reserve := $wrap(l$raw_ret)
; [eval] $wrap(l$raw_ret)
(declare-const l$token_reserve@502@01 $Int)
(assert (= l$token_reserve@502@01 ($wrap<$Int> l$raw_ret@340@01)))
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) < 0
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve))
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
    0))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 71 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) < 0 | dead]
; [else-branch: 71 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) < 0) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 71 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
    0)))
(pop) ; 9
; [eval] !($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) < 0)
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) < 0
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve))
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
  0)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
    0))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 72 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) < 0) | live]
; [else-branch: 72 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) < 0 | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 72 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
    0)))
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve))
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 73 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 73 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 73 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 11
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 74 | True | live]
; [else-branch: 74 | False | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 74 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@503@01 $Snap)
(assert (= $t@503@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@504@01 $Struct)
(assert (=
  self@504@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 11
; [then-branch: 75 | False | dead]
; [else-branch: 75 | True | live]
(set-option :timeout 0)
(push) ; 11
; [else-branch: 75 | True]
(pop) ; 11
(pop) ; 10
(push) ; 10
; [else-branch: 73 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 10
; [eval] !($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve))
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 10
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 76 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 76 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 76 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [eval] $unwrap(l$eth_reserve) == 0
; [eval] $unwrap(l$eth_reserve)
(push) ; 11
(set-option :timeout 10)
(assert (not (not (= ($unwrap<Int> l$eth_reserve@425@01) 0))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (= ($unwrap<Int> l$eth_reserve@425@01) 0)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 77 | $unwrap[Int](l$eth_reserve@425@01) == 0 | live]
; [else-branch: 77 | $unwrap[Int](l$eth_reserve@425@01) != 0 | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 77 | $unwrap[Int](l$eth_reserve@425@01) == 0]
(assert (= ($unwrap<Int> l$eth_reserve@425@01) 0))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 12
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 78 | True | live]
; [else-branch: 78 | False | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 78 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@505@01 $Snap)
(assert (= $t@505@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@506@01 $Struct)
(assert (=
  self@506@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 12
; [then-branch: 79 | False | dead]
; [else-branch: 79 | True | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 79 | True]
(pop) ; 12
(pop) ; 11
(push) ; 11
; [else-branch: 77 | $unwrap[Int](l$eth_reserve@425@01) != 0]
(assert (not (= ($unwrap<Int> l$eth_reserve@425@01) 0)))
(pop) ; 11
; [eval] !($unwrap(l$eth_reserve) == 0)
; [eval] $unwrap(l$eth_reserve) == 0
; [eval] $unwrap(l$eth_reserve)
(push) ; 11
(set-option :timeout 10)
(assert (not (= ($unwrap<Int> l$eth_reserve@425@01) 0)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (not (= ($unwrap<Int> l$eth_reserve@425@01) 0))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 80 | $unwrap[Int](l$eth_reserve@425@01) != 0 | live]
; [else-branch: 80 | $unwrap[Int](l$eth_reserve@425@01) == 0 | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 80 | $unwrap[Int](l$eth_reserve@425@01) != 0]
(assert (not (= ($unwrap<Int> l$eth_reserve@425@01) 0)))
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) < 0
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not (= 0 ($unwrap<Int> l$eth_reserve@425@01)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 81 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 81 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(set-option :timeout 0)
(push) ; 13
; [else-branch: 81 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
(assert (not (= 0 ($unwrap<Int> l$eth_reserve@425@01))))
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (not (= 0 ($unwrap<Int> l$eth_reserve@425@01))))
(push) ; 12
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    0))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 82 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) < 0 | dead]
; [else-branch: 82 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) < 0) | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 82 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    0)))
(pop) ; 12
; [eval] !($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) < 0)
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) < 0
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 12
; [then-branch: 83 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 83 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 13
; [else-branch: 83 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(push) ; 12
(set-option :timeout 10)
(assert (not (<
  ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
  0)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    0))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 84 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) < 0) | live]
; [else-branch: 84 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) < 0 | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 84 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    0)))
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 13
; [then-branch: 85 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 85 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 14
; [else-branch: 85 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 86 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 86 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 13
; [else-branch: 86 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 13
; [eval] !($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 13
; [then-branch: 87 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 87 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 14
; [else-branch: 87 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 88 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 88 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 88 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1 < 0
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 14
; [then-branch: 89 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 89 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 15
; [else-branch: 89 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 15
(pop) ; 14
; Joined path conditions
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (<
    (+
      ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
      1)
    0))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 90 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 < 0 | dead]
; [else-branch: 90 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 < 0) | live]
(set-option :timeout 0)
(push) ; 14
; [else-branch: 90 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 < 0)]
(assert (not
  (<
    (+
      ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
      1)
    0)))
(pop) ; 14
; [eval] !($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1 < 0)
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1 < 0
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 14
; [then-branch: 91 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 91 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 15
; [else-branch: 91 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 15
(pop) ; 14
; Joined path conditions
(push) ; 14
(set-option :timeout 10)
(assert (not (<
  (+
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    1)
  0)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (<
    (+
      ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
      1)
    0))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 92 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 < 0) | live]
; [else-branch: 92 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 < 0 | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 92 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 < 0)]
(assert (not
  (<
    (+
      ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
      1)
    0)))
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 15
; [then-branch: 93 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 93 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 16
; [else-branch: 93 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(set-option :timeout 10)
(assert (not (not
  (>
    (+
      ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
      1)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (>
  (+
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    1)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 94 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 94 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 94 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    1)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 16
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 95 | True | live]
; [else-branch: 95 | False | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 95 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@507@01 $Snap)
(assert (= $t@507@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@508@01 $Struct)
(assert (=
  self@508@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 16
; [then-branch: 96 | False | dead]
; [else-branch: 96 | True | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 96 | True]
(pop) ; 16
(pop) ; 15
(push) ; 15
; [else-branch: 94 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+
      ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
      1)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 15
; [eval] !($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 15
; [then-branch: 97 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 97 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 16
; [else-branch: 97 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(set-option :timeout 10)
(assert (not (>
  (+
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    1)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (not
  (>
    (+
      ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
      1)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 98 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 98 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 98 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+
      ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
      1)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$token_amount := $wrap($unwrap((0 == $unwrap(l$eth_reserve) ?
;     $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \
;     $unwrap(l$eth_reserve)) :
;     $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve),
;     l$eth_reserve))) +
;   1)
; [eval] $wrap($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1)
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))) + 1
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 16
; [then-branch: 99 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 99 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 17
; [else-branch: 99 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$token_reserve)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 17
(pop) ; 16
; Joined path conditions
(declare-const l$token_amount@509@01 $Int)
(assert (=
  l$token_amount@509@01
  ($wrap<$Int> (+
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    1))))
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) < 0
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity))
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 16
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
    0))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 100 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) < 0 | dead]
; [else-branch: 100 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) < 0) | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 100 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
    0)))
(pop) ; 16
; [eval] !($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) < 0)
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) < 0
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity))
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 16
(set-option :timeout 10)
(assert (not (<
  ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
  0)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
    0))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 101 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) < 0) | live]
; [else-branch: 101 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) < 0 | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 101 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
    0)))
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity))
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 17
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 102 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 102 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 102 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 18
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 103 | True | live]
; [else-branch: 103 | False | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 103 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@510@01 $Snap)
(assert (= $t@510@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@511@01 $Struct)
(assert (=
  self@511@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 18
; [then-branch: 104 | False | dead]
; [else-branch: 104 | True | live]
(set-option :timeout 0)
(push) ; 18
; [else-branch: 104 | True]
(pop) ; 18
(pop) ; 17
(push) ; 17
; [else-branch: 102 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 17
; [eval] !($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity))
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(push) ; 17
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 105 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 105 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 105 | !($unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [eval] $unwrap(l$eth_reserve) == 0
; [eval] $unwrap(l$eth_reserve)
; [then-branch: 106 | $unwrap[Int](l$eth_reserve@425@01) == 0 | dead]
; [else-branch: 106 | $unwrap[Int](l$eth_reserve@425@01) != 0 | live]
(push) ; 18
; [else-branch: 106 | $unwrap[Int](l$eth_reserve@425@01) != 0]
(pop) ; 18
; [eval] !($unwrap(l$eth_reserve) == 0)
; [eval] $unwrap(l$eth_reserve) == 0
; [eval] $unwrap(l$eth_reserve)
(push) ; 18
(set-option :timeout 10)
(assert (not (= ($unwrap<Int> l$eth_reserve@425@01) 0)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 107 | $unwrap[Int](l$eth_reserve@425@01) != 0 | live]
; [else-branch: 107 | $unwrap[Int](l$eth_reserve@425@01) == 0 | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 107 | $unwrap[Int](l$eth_reserve@425@01) != 0]
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))) < 0
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 19
; [then-branch: 108 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 108 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 20
; [else-branch: 108 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 20
(pop) ; 19
; Joined path conditions
(push) ; 19
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01))
    0))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 109 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) < 0 | dead]
; [else-branch: 109 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) < 0) | live]
(set-option :timeout 0)
(push) ; 19
; [else-branch: 109 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01))
    0)))
(pop) ; 19
; [eval] !($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))) < 0)
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))) < 0
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 19
; [then-branch: 110 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 110 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 20
; [else-branch: 110 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 20
(pop) ; 19
; Joined path conditions
(push) ; 19
(set-option :timeout 10)
(assert (not (<
  ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01))
  0)))
(check-sat)
; unknown
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01))
    0))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 111 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) < 0) | live]
; [else-branch: 111 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) < 0 | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 111 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01))
    0)))
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 20
; [then-branch: 112 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 112 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 21
; [else-branch: 112 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 21
(pop) ; 20
; Joined path conditions
(push) ; 20
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 113 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 113 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 20
; [else-branch: 113 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 20
; [eval] !($unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap((0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve)))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 20
; [then-branch: 114 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 114 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 21
; [else-branch: 114 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 21
(pop) ; 20
; Joined path conditions
(push) ; 20
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 115 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 115 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 115 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01), l$eth_reserve@425@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$liquidity_minted := (0 == $unwrap(l$eth_reserve) ?
;     $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \
;     $unwrap(l$eth_reserve)) :
;     $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity),
;     l$eth_reserve))
; [eval] (0 == $unwrap(l$eth_reserve) ? $wrap($unwrap($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)) \ $unwrap(l$eth_reserve)) : $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve))
; [eval] 0 == $unwrap(l$eth_reserve)
; [eval] $unwrap(l$eth_reserve)
(push) ; 21
; [then-branch: 116 | 0 == $unwrap[Int](l$eth_reserve@425@01) | dead]
; [else-branch: 116 | 0 != $unwrap[Int](l$eth_reserve@425@01) | live]
(push) ; 22
; [else-branch: 116 | 0 != $unwrap[Int](l$eth_reserve@425@01)]
; [eval] $w_div($w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity), l$eth_reserve)
; [eval] $w_mul($wrap(($struct_get($struct_loc(msg, 1)): Int)), l$total_liquidity)
; [eval] $wrap(($struct_get($struct_loc(msg, 1)): Int))
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 22
(pop) ; 21
; Joined path conditions
(declare-const l$liquidity_minted@512@01 $Int)
(assert (=
  l$liquidity_minted@512@01
  ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01) l$eth_reserve@425@01)))
; [eval] !($unwrap(l$max_tokens) >= $unwrap(l$token_amount) && $unwrap(l$liquidity_minted) >= $unwrap(l$min_liquidity))
; [eval] $unwrap(l$max_tokens) >= $unwrap(l$token_amount) && $unwrap(l$liquidity_minted) >= $unwrap(l$min_liquidity)
; [eval] $unwrap(l$max_tokens) >= $unwrap(l$token_amount)
; [eval] $unwrap(l$max_tokens)
; [eval] $unwrap(l$token_amount)
(push) ; 21
; [then-branch: 117 | !($unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01)) | live]
; [else-branch: 117 | $unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01) | live]
(push) ; 22
; [then-branch: 117 | !($unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01))]
(assert (not
  (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))))
(pop) ; 22
(push) ; 22
; [else-branch: 117 | $unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01)]
(assert (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01)))
; [eval] $unwrap(l$liquidity_minted) >= $unwrap(l$min_liquidity)
; [eval] $unwrap(l$liquidity_minted)
; [eval] $unwrap(l$min_liquidity)
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(assert (or
  (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))
  (not
    (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01)))))
(push) ; 21
(set-option :timeout 10)
(assert (not (and
  (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))
  (>=
    ($unwrap<Int> l$liquidity_minted@512@01)
    ($unwrap<Int> l$min_liquidity@319@01)))))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not
  (and
    (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))
    (>=
      ($unwrap<Int> l$liquidity_minted@512@01)
      ($unwrap<Int> l$min_liquidity@319@01))))))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
; [then-branch: 118 | !($unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01) && $unwrap[Int](l$liquidity_minted@512@01) >= $unwrap[Int](l$min_liquidity@319@01)) | live]
; [else-branch: 118 | $unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01) && $unwrap[Int](l$liquidity_minted@512@01) >= $unwrap[Int](l$min_liquidity@319@01) | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 118 | !($unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01) && $unwrap[Int](l$liquidity_minted@512@01) >= $unwrap[Int](l$min_liquidity@319@01))]
(assert (not
  (and
    (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))
    (>=
      ($unwrap<Int> l$liquidity_minted@512@01)
      ($unwrap<Int> l$min_liquidity@319@01)))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 22
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 119 | True | live]
; [else-branch: 119 | False | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 119 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@513@01 $Snap)
(assert (= $t@513@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@514@01 $Struct)
(assert (=
  self@514@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 22
; [then-branch: 120 | False | dead]
; [else-branch: 120 | True | live]
(set-option :timeout 0)
(push) ; 22
; [else-branch: 120 | True]
(pop) ; 22
(pop) ; 21
(push) ; 21
; [else-branch: 118 | $unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01) && $unwrap[Int](l$liquidity_minted@512@01) >= $unwrap[Int](l$min_liquidity@319@01)]
(assert (and
  (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))
  (>=
    ($unwrap<Int> l$liquidity_minted@512@01)
    ($unwrap<Int> l$min_liquidity@319@01))))
(pop) ; 21
; [eval] !!($unwrap(l$max_tokens) >= $unwrap(l$token_amount) && $unwrap(l$liquidity_minted) >= $unwrap(l$min_liquidity))
; [eval] !($unwrap(l$max_tokens) >= $unwrap(l$token_amount) && $unwrap(l$liquidity_minted) >= $unwrap(l$min_liquidity))
; [eval] $unwrap(l$max_tokens) >= $unwrap(l$token_amount) && $unwrap(l$liquidity_minted) >= $unwrap(l$min_liquidity)
; [eval] $unwrap(l$max_tokens) >= $unwrap(l$token_amount)
; [eval] $unwrap(l$max_tokens)
; [eval] $unwrap(l$token_amount)
(push) ; 21
; [then-branch: 121 | !($unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01)) | live]
; [else-branch: 121 | $unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01) | live]
(push) ; 22
; [then-branch: 121 | !($unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01))]
(assert (not
  (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))))
(pop) ; 22
(push) ; 22
; [else-branch: 121 | $unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01)]
(assert (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01)))
; [eval] $unwrap(l$liquidity_minted) >= $unwrap(l$min_liquidity)
; [eval] $unwrap(l$liquidity_minted)
; [eval] $unwrap(l$min_liquidity)
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(push) ; 21
(set-option :timeout 10)
(assert (not (not
  (and
    (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))
    (>=
      ($unwrap<Int> l$liquidity_minted@512@01)
      ($unwrap<Int> l$min_liquidity@319@01))))))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (and
  (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))
  (>=
    ($unwrap<Int> l$liquidity_minted@512@01)
    ($unwrap<Int> l$min_liquidity@319@01)))))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
; [then-branch: 122 | $unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01) && $unwrap[Int](l$liquidity_minted@512@01) >= $unwrap[Int](l$min_liquidity@319@01) | live]
; [else-branch: 122 | !($unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01) && $unwrap[Int](l$liquidity_minted@512@01) >= $unwrap[Int](l$min_liquidity@319@01)) | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 122 | $unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01) && $unwrap[Int](l$liquidity_minted@512@01) >= $unwrap[Int](l$min_liquidity@319@01)]
(assert (and
  (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))
  (>=
    ($unwrap<Int> l$liquidity_minted@512@01)
    ($unwrap<Int> l$min_liquidity@319@01))))
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted) < 0
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)))
; [eval] $wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$liquidity_minted)
(push) ; 22
(set-option :timeout 10)
(assert (not (not
  (<
    (+
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
      ($unwrap<Int> l$liquidity_minted@512@01))
    0))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 123 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) < 0 | dead]
; [else-branch: 123 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) < 0) | live]
(set-option :timeout 0)
(push) ; 22
; [else-branch: 123 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) < 0)]
(assert (not
  (<
    (+
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
      ($unwrap<Int> l$liquidity_minted@512@01))
    0)))
(pop) ; 22
; [eval] !($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted) < 0)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted) < 0
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)))
; [eval] $wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$liquidity_minted)
(push) ; 22
(set-option :timeout 10)
(assert (not (<
  (+
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
    ($unwrap<Int> l$liquidity_minted@512@01))
  0)))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not (not
  (<
    (+
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
      ($unwrap<Int> l$liquidity_minted@512@01))
    0))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 124 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) < 0) | live]
; [else-branch: 124 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) < 0 | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 124 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) < 0)]
(assert (not
  (<
    (+
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
      ($unwrap<Int> l$liquidity_minted@512@01))
    0)))
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)))
; [eval] $wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$liquidity_minted)
(push) ; 23
(set-option :timeout 10)
(assert (not (not
  (>
    (+
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
      ($unwrap<Int> l$liquidity_minted@512@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (>
  (+
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
    ($unwrap<Int> l$liquidity_minted@512@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
; [then-branch: 125 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 125 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 125 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
    ($unwrap<Int> l$liquidity_minted@512@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 24
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 24
; 0.01s
; (get-info :all-statistics)
; [then-branch: 126 | True | live]
; [else-branch: 126 | False | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 126 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@515@01 $Snap)
(assert (= $t@515@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@516@01 $Struct)
(assert (=
  self@516@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 24
; [then-branch: 127 | False | dead]
; [else-branch: 127 | True | live]
(set-option :timeout 0)
(push) ; 24
; [else-branch: 127 | True]
(pop) ; 24
(pop) ; 23
(push) ; 23
; [else-branch: 125 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
      ($unwrap<Int> l$liquidity_minted@512@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 23
; [eval] !($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)))
; [eval] $wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$liquidity_minted)
(push) ; 23
(set-option :timeout 10)
(assert (not (>
  (+
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
    ($unwrap<Int> l$liquidity_minted@512@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 23
; 0.02s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not
  (>
    (+
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
      ($unwrap<Int> l$liquidity_minted@512@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
; [then-branch: 128 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 128 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 128 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
      ($unwrap<Int> l$liquidity_minted@512@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; self := ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]),
;   ($struct_get($struct_loc(msg, 0)): Int), $unwrap($wrap(($map_get(($struct_get($struct_loc(self,
;   4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) +
;   $unwrap(l$liquidity_minted)): $Map[Int, Int])): $Struct)
; [eval] ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted)): $Map[Int, Int])): $Struct)
; [eval] ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted)): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) + $unwrap(l$liquidity_minted)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)))
; [eval] $wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$liquidity_minted)
(declare-const self@517@01 $Struct)
(assert (=
  self@517@01
  ($struct_set<$Struct> self@419@01 4 ($map_set<$Map<Int~_Int>> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)) (+
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
    ($unwrap<Int> l$liquidity_minted@512@01))))))
; [eval] $unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted) < 0
; [eval] $unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted)
; [eval] $unwrap(l$total_liquidity)
; [eval] $unwrap(l$liquidity_minted)
(push) ; 24
(set-option :timeout 10)
(assert (not (not
  (<
    (+
      ($unwrap<Int> l$total_liquidity@422@01)
      ($unwrap<Int> l$liquidity_minted@512@01))
    0))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 129 | $unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) < 0 | dead]
; [else-branch: 129 | !($unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) < 0) | live]
(set-option :timeout 0)
(push) ; 24
; [else-branch: 129 | !($unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) < 0)]
(assert (not
  (<
    (+
      ($unwrap<Int> l$total_liquidity@422@01)
      ($unwrap<Int> l$liquidity_minted@512@01))
    0)))
(pop) ; 24
; [eval] !($unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted) < 0)
; [eval] $unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted) < 0
; [eval] $unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted)
; [eval] $unwrap(l$total_liquidity)
; [eval] $unwrap(l$liquidity_minted)
(push) ; 24
(set-option :timeout 10)
(assert (not (<
  (+
    ($unwrap<Int> l$total_liquidity@422@01)
    ($unwrap<Int> l$liquidity_minted@512@01))
  0)))
(check-sat)
; unknown
(pop) ; 24
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (not
  (<
    (+
      ($unwrap<Int> l$total_liquidity@422@01)
      ($unwrap<Int> l$liquidity_minted@512@01))
    0))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 130 | !($unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) < 0) | live]
; [else-branch: 130 | $unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) < 0 | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 130 | !($unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) < 0)]
(assert (not
  (<
    (+
      ($unwrap<Int> l$total_liquidity@422@01)
      ($unwrap<Int> l$liquidity_minted@512@01))
    0)))
; [eval] $unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted)
; [eval] $unwrap(l$total_liquidity)
; [eval] $unwrap(l$liquidity_minted)
(push) ; 25
(set-option :timeout 10)
(assert (not (not
  (>
    (+
      ($unwrap<Int> l$total_liquidity@422@01)
      ($unwrap<Int> l$liquidity_minted@512@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 25
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (>
  (+
    ($unwrap<Int> l$total_liquidity@422@01)
    ($unwrap<Int> l$liquidity_minted@512@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 25
; 0.01s
; (get-info :all-statistics)
; [then-branch: 131 | $unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 131 | !($unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 131 | $unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+
    ($unwrap<Int> l$total_liquidity@422@01)
    ($unwrap<Int> l$liquidity_minted@512@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 26
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 26
; 0.01s
; (get-info :all-statistics)
; [then-branch: 132 | True | live]
; [else-branch: 132 | False | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 132 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@518@01 $Snap)
(assert (= $t@518@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@519@01 $Struct)
(assert (=
  self@519@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 26
; [then-branch: 133 | False | dead]
; [else-branch: 133 | True | live]
(set-option :timeout 0)
(push) ; 26
; [else-branch: 133 | True]
(pop) ; 26
(pop) ; 25
(push) ; 25
; [else-branch: 131 | !($unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+
      ($unwrap<Int> l$total_liquidity@422@01)
      ($unwrap<Int> l$liquidity_minted@512@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 25
; [eval] !($unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted)
; [eval] $unwrap(l$total_liquidity)
; [eval] $unwrap(l$liquidity_minted)
(push) ; 25
(set-option :timeout 10)
(assert (not (>
  (+
    ($unwrap<Int> l$total_liquidity@422@01)
    ($unwrap<Int> l$liquidity_minted@512@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 25
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (not
  (>
    (+
      ($unwrap<Int> l$total_liquidity@422@01)
      ($unwrap<Int> l$liquidity_minted@512@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 25
; 0.01s
; (get-info :all-statistics)
; [then-branch: 134 | !($unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 134 | $unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 134 | !($unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+
      ($unwrap<Int> l$total_liquidity@422@01)
      ($unwrap<Int> l$liquidity_minted@512@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; self := ($struct_set(self, 3, $unwrap($wrap($unwrap(l$total_liquidity) +
;   $unwrap(l$liquidity_minted)))): $Struct)
; [eval] ($struct_set(self, 3, $unwrap($wrap($unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted)))): $Struct)
; [eval] $unwrap($wrap($unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted)))
; [eval] $wrap($unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted))
; [eval] $unwrap(l$total_liquidity) + $unwrap(l$liquidity_minted)
; [eval] $unwrap(l$total_liquidity)
; [eval] $unwrap(l$liquidity_minted)
(declare-const self@520@01 $Struct)
(assert (=
  self@520@01
  ($struct_set<$Struct> self@517@01 3 ($unwrap<Int> ($wrap<$Int> (+
    ($unwrap<Int> l$total_liquidity@422@01)
    ($unwrap<Int> l$liquidity_minted@512@01)))))))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@521@01 Int)
(declare-const $arg1@522@01 Int)
(declare-const $arg2@523@01 Int)
(push) ; 26
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@524@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef18|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef19|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@521@01)
    ($SortWrappers.IntTo$Snap $arg1@522@01))
  ($SortWrappers.IntTo$Snap $arg2@523@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@521@01)
    ($SortWrappers.IntTo$Snap $arg1@522@01))
  ($SortWrappers.IntTo$Snap $arg2@523@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@521@01)
      ($SortWrappers.IntTo$Snap $arg1@522@01))
    ($SortWrappers.IntTo$Snap $arg2@523@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 26
(declare-fun inv@525@01 (Int Int Int) Int)
(declare-fun img@526@01 (Int Int Int) Bool)
(declare-fun inv@527@01 (Int Int Int) Int)
(declare-fun img@528@01 (Int Int Int) Bool)
(declare-fun inv@529@01 (Int Int Int) Int)
(declare-fun img@530@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef18|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef19|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@521@01 Int) ($arg1@522@01 Int) ($arg2@523@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@521@01)
          ($SortWrappers.IntTo$Snap $arg1@522@01))
        ($SortWrappers.IntTo$Snap $arg2@523@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@521@01)
        ($SortWrappers.IntTo$Snap $arg1@522@01))
      ($SortWrappers.IntTo$Snap $arg2@523@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@521@01)
        ($SortWrappers.IntTo$Snap $arg1@522@01))
      ($SortWrappers.IntTo$Snap $arg2@523@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@521@01)
      ($SortWrappers.IntTo$Snap $arg1@522@01))
    ($SortWrappers.IntTo$Snap $arg2@523@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@521@01)
      ($SortWrappers.IntTo$Snap $arg1@522@01))
    ($SortWrappers.IntTo$Snap $arg2@523@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 26
(assert (not (forall (($arg0@521@01 Int) ($arg1@522@01 Int) ($arg2@523@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@521@01)
          ($SortWrappers.IntTo$Snap $arg1@522@01))
        ($SortWrappers.IntTo$Snap $arg2@523@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@521@01)
            ($SortWrappers.IntTo$Snap $arg1@522@01))
          ($SortWrappers.IntTo$Snap $arg2@523@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@521@01)
            ($SortWrappers.IntTo$Snap $arg1@522@01))
          ($SortWrappers.IntTo$Snap $arg2@523@01))))))
  
  :qid |quant-u-1598|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 26
(assert (not (forall (($arg01@521@01 Int) ($arg11@522@01 Int) ($arg21@523@01 Int) ($arg02@521@01 Int) ($arg12@522@01 Int) ($arg22@523@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@521@01)
                ($SortWrappers.IntTo$Snap $arg11@522@01))
              ($SortWrappers.IntTo$Snap $arg21@523@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@521@01)
              ($SortWrappers.IntTo$Snap $arg11@522@01))
            ($SortWrappers.IntTo$Snap $arg21@523@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@521@01)
              ($SortWrappers.IntTo$Snap $arg11@522@01))
            ($SortWrappers.IntTo$Snap $arg21@523@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@521@01)
              ($SortWrappers.IntTo$Snap $arg11@522@01))
            ($SortWrappers.IntTo$Snap $arg21@523@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@521@01)
                ($SortWrappers.IntTo$Snap $arg12@522@01))
              ($SortWrappers.IntTo$Snap $arg22@523@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@521@01)
              ($SortWrappers.IntTo$Snap $arg12@522@01))
            ($SortWrappers.IntTo$Snap $arg22@523@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@521@01)
              ($SortWrappers.IntTo$Snap $arg12@522@01))
            ($SortWrappers.IntTo$Snap $arg22@523@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@521@01)
              ($SortWrappers.IntTo$Snap $arg12@522@01))
            ($SortWrappers.IntTo$Snap $arg22@523@01)))))
      (and
        (and (= $arg01@521@01 $arg02@521@01) (= $arg11@522@01 $arg12@522@01))
        (= $arg21@523@01 $arg22@523@01)))
    (and
      (and (= $arg01@521@01 $arg02@521@01) (= $arg11@522@01 $arg12@522@01))
      (= $arg21@523@01 $arg22@523@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@521@01 Int) ($arg1@522@01 Int) ($arg2@523@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@521@01)
            ($SortWrappers.IntTo$Snap $arg1@522@01))
          ($SortWrappers.IntTo$Snap $arg2@523@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@521@01)
            ($SortWrappers.IntTo$Snap $arg1@522@01))
          ($SortWrappers.IntTo$Snap $arg2@523@01)))))
    (and
      (and
        (= (inv@525@01 $arg0@521@01 $arg1@522@01 $arg2@523@01) $arg0@521@01)
        (= (inv@527@01 $arg0@521@01 $arg1@522@01 $arg2@523@01) $arg1@522@01)
        (= (inv@529@01 $arg0@521@01 $arg1@522@01 $arg2@523@01) $arg2@523@01))
      (and
        (img@526@01 $arg0@521@01 $arg1@522@01 $arg2@523@01)
        (img@528@01 $arg0@521@01 $arg1@522@01 $arg2@523@01)
        (img@530@01 $arg0@521@01 $arg1@522@01 $arg2@523@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@521@01)
      ($SortWrappers.IntTo$Snap $arg1@522@01))
    ($SortWrappers.IntTo$Snap $arg2@523@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@521@01)
      ($SortWrappers.IntTo$Snap $arg1@522@01))
    ($SortWrappers.IntTo$Snap $arg2@523@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@526@01 $arg0 $arg1 $arg2)
        (img@528@01 $arg0 $arg1 $arg2)
        (img@530@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@525@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@527@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@529@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@525@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@527@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@529@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@525@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@527@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@529@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@525@01 $arg0 $arg1 $arg2))
  :pattern ((inv@527@01 $arg0 $arg1 $arg2))
  :pattern ((inv@529@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@525@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@527@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@529@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@429@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@525@01 $arg0 $arg1 $arg2) (inv@527@01 $arg0 $arg1 $arg2) (inv@529@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1599|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 26
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@525@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@527@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@529@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@526@01 $arg0 $arg1 $arg2)
        (img@528@01 $arg0 $arg1 $arg2)
        (img@530@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@525@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@527@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@529@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@524@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@525@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@527@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@529@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1600|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@531@01 Int)
(declare-const $arg1@532@01 Int)
(declare-const $arg2@533@01 Int)
(push) ; 26
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@534@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef20|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef21|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@531@01)
    ($SortWrappers.IntTo$Snap $arg1@532@01))
  ($SortWrappers.IntTo$Snap $arg2@533@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@531@01)
    ($SortWrappers.IntTo$Snap $arg1@532@01))
  ($SortWrappers.IntTo$Snap $arg2@533@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@531@01)
      ($SortWrappers.IntTo$Snap $arg1@532@01))
    ($SortWrappers.IntTo$Snap $arg2@533@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 26
(declare-fun inv@535@01 (Int Int Int) Int)
(declare-fun img@536@01 (Int Int Int) Bool)
(declare-fun inv@537@01 (Int Int Int) Int)
(declare-fun img@538@01 (Int Int Int) Bool)
(declare-fun inv@539@01 (Int Int Int) Int)
(declare-fun img@540@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef20|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef21|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@531@01 Int) ($arg1@532@01 Int) ($arg2@533@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@531@01)
          ($SortWrappers.IntTo$Snap $arg1@532@01))
        ($SortWrappers.IntTo$Snap $arg2@533@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@531@01)
        ($SortWrappers.IntTo$Snap $arg1@532@01))
      ($SortWrappers.IntTo$Snap $arg2@533@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@531@01)
        ($SortWrappers.IntTo$Snap $arg1@532@01))
      ($SortWrappers.IntTo$Snap $arg2@533@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@531@01)
      ($SortWrappers.IntTo$Snap $arg1@532@01))
    ($SortWrappers.IntTo$Snap $arg2@533@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@531@01)
      ($SortWrappers.IntTo$Snap $arg1@532@01))
    ($SortWrappers.IntTo$Snap $arg2@533@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 26
(assert (not (forall (($arg0@531@01 Int) ($arg1@532@01 Int) ($arg2@533@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@531@01)
          ($SortWrappers.IntTo$Snap $arg1@532@01))
        ($SortWrappers.IntTo$Snap $arg2@533@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@531@01)
            ($SortWrappers.IntTo$Snap $arg1@532@01))
          ($SortWrappers.IntTo$Snap $arg2@533@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@531@01)
            ($SortWrappers.IntTo$Snap $arg1@532@01))
          ($SortWrappers.IntTo$Snap $arg2@533@01))))))
  
  :qid |quant-u-1601|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 26
(assert (not (forall (($arg01@531@01 Int) ($arg11@532@01 Int) ($arg21@533@01 Int) ($arg02@531@01 Int) ($arg12@532@01 Int) ($arg22@533@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@531@01)
                ($SortWrappers.IntTo$Snap $arg11@532@01))
              ($SortWrappers.IntTo$Snap $arg21@533@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@531@01)
              ($SortWrappers.IntTo$Snap $arg11@532@01))
            ($SortWrappers.IntTo$Snap $arg21@533@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@531@01)
              ($SortWrappers.IntTo$Snap $arg11@532@01))
            ($SortWrappers.IntTo$Snap $arg21@533@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@531@01)
              ($SortWrappers.IntTo$Snap $arg11@532@01))
            ($SortWrappers.IntTo$Snap $arg21@533@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@531@01)
                ($SortWrappers.IntTo$Snap $arg12@532@01))
              ($SortWrappers.IntTo$Snap $arg22@533@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@531@01)
              ($SortWrappers.IntTo$Snap $arg12@532@01))
            ($SortWrappers.IntTo$Snap $arg22@533@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@531@01)
              ($SortWrappers.IntTo$Snap $arg12@532@01))
            ($SortWrappers.IntTo$Snap $arg22@533@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@531@01)
              ($SortWrappers.IntTo$Snap $arg12@532@01))
            ($SortWrappers.IntTo$Snap $arg22@533@01)))))
      (and
        (and (= $arg01@531@01 $arg02@531@01) (= $arg11@532@01 $arg12@532@01))
        (= $arg21@533@01 $arg22@533@01)))
    (and
      (and (= $arg01@531@01 $arg02@531@01) (= $arg11@532@01 $arg12@532@01))
      (= $arg21@533@01 $arg22@533@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@531@01 Int) ($arg1@532@01 Int) ($arg2@533@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@531@01)
            ($SortWrappers.IntTo$Snap $arg1@532@01))
          ($SortWrappers.IntTo$Snap $arg2@533@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@531@01)
            ($SortWrappers.IntTo$Snap $arg1@532@01))
          ($SortWrappers.IntTo$Snap $arg2@533@01)))))
    (and
      (and
        (= (inv@535@01 $arg0@531@01 $arg1@532@01 $arg2@533@01) $arg0@531@01)
        (= (inv@537@01 $arg0@531@01 $arg1@532@01 $arg2@533@01) $arg1@532@01)
        (= (inv@539@01 $arg0@531@01 $arg1@532@01 $arg2@533@01) $arg2@533@01))
      (and
        (img@536@01 $arg0@531@01 $arg1@532@01 $arg2@533@01)
        (img@538@01 $arg0@531@01 $arg1@532@01 $arg2@533@01)
        (img@540@01 $arg0@531@01 $arg1@532@01 $arg2@533@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@531@01)
      ($SortWrappers.IntTo$Snap $arg1@532@01))
    ($SortWrappers.IntTo$Snap $arg2@533@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@531@01)
      ($SortWrappers.IntTo$Snap $arg1@532@01))
    ($SortWrappers.IntTo$Snap $arg2@533@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@536@01 $arg0 $arg1 $arg2)
        (img@538@01 $arg0 $arg1 $arg2)
        (img@540@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@535@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@537@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@539@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@535@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@537@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@539@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@535@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@537@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@539@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@535@01 $arg0 $arg1 $arg2))
  :pattern ((inv@537@01 $arg0 $arg1 $arg2))
  :pattern ((inv@539@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@535@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@537@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@539@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@441@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@535@01 $arg0 $arg1 $arg2) (inv@537@01 $arg0 $arg1 $arg2) (inv@539@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1602|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 26
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@535@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@537@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@539@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@536@01 $arg0 $arg1 $arg2)
        (img@538@01 $arg0 $arg1 $arg2)
        (img@540@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@535@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@537@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@539@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@534@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@535@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@537@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@539@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1603|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@541@01 Int)
(declare-const $arg1@542@01 Int)
(declare-const $arg2@543@01 Int)
(push) ; 26
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@544@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef22|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef23|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@541@01)
    ($SortWrappers.IntTo$Snap $arg1@542@01))
  ($SortWrappers.IntTo$Snap $arg2@543@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@541@01)
    ($SortWrappers.IntTo$Snap $arg1@542@01))
  ($SortWrappers.IntTo$Snap $arg2@543@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@541@01)
      ($SortWrappers.IntTo$Snap $arg1@542@01))
    ($SortWrappers.IntTo$Snap $arg2@543@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 26
(declare-fun inv@545@01 (Int Int Int) Int)
(declare-fun img@546@01 (Int Int Int) Bool)
(declare-fun inv@547@01 (Int Int Int) Int)
(declare-fun img@548@01 (Int Int Int) Bool)
(declare-fun inv@549@01 (Int Int Int) Int)
(declare-fun img@550@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef22|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef23|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@541@01 Int) ($arg1@542@01 Int) ($arg2@543@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@541@01)
          ($SortWrappers.IntTo$Snap $arg1@542@01))
        ($SortWrappers.IntTo$Snap $arg2@543@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@541@01)
        ($SortWrappers.IntTo$Snap $arg1@542@01))
      ($SortWrappers.IntTo$Snap $arg2@543@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@541@01)
        ($SortWrappers.IntTo$Snap $arg1@542@01))
      ($SortWrappers.IntTo$Snap $arg2@543@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@541@01)
      ($SortWrappers.IntTo$Snap $arg1@542@01))
    ($SortWrappers.IntTo$Snap $arg2@543@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@541@01)
      ($SortWrappers.IntTo$Snap $arg1@542@01))
    ($SortWrappers.IntTo$Snap $arg2@543@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 26
(assert (not (forall (($arg0@541@01 Int) ($arg1@542@01 Int) ($arg2@543@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@541@01)
          ($SortWrappers.IntTo$Snap $arg1@542@01))
        ($SortWrappers.IntTo$Snap $arg2@543@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@541@01)
            ($SortWrappers.IntTo$Snap $arg1@542@01))
          ($SortWrappers.IntTo$Snap $arg2@543@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@541@01)
            ($SortWrappers.IntTo$Snap $arg1@542@01))
          ($SortWrappers.IntTo$Snap $arg2@543@01))))))
  
  :qid |quant-u-1604|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 26
(assert (not (forall (($arg01@541@01 Int) ($arg11@542@01 Int) ($arg21@543@01 Int) ($arg02@541@01 Int) ($arg12@542@01 Int) ($arg22@543@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@541@01)
                ($SortWrappers.IntTo$Snap $arg11@542@01))
              ($SortWrappers.IntTo$Snap $arg21@543@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@541@01)
              ($SortWrappers.IntTo$Snap $arg11@542@01))
            ($SortWrappers.IntTo$Snap $arg21@543@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@541@01)
              ($SortWrappers.IntTo$Snap $arg11@542@01))
            ($SortWrappers.IntTo$Snap $arg21@543@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@541@01)
              ($SortWrappers.IntTo$Snap $arg11@542@01))
            ($SortWrappers.IntTo$Snap $arg21@543@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@541@01)
                ($SortWrappers.IntTo$Snap $arg12@542@01))
              ($SortWrappers.IntTo$Snap $arg22@543@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@541@01)
              ($SortWrappers.IntTo$Snap $arg12@542@01))
            ($SortWrappers.IntTo$Snap $arg22@543@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@541@01)
              ($SortWrappers.IntTo$Snap $arg12@542@01))
            ($SortWrappers.IntTo$Snap $arg22@543@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@541@01)
              ($SortWrappers.IntTo$Snap $arg12@542@01))
            ($SortWrappers.IntTo$Snap $arg22@543@01)))))
      (and
        (and (= $arg01@541@01 $arg02@541@01) (= $arg11@542@01 $arg12@542@01))
        (= $arg21@543@01 $arg22@543@01)))
    (and
      (and (= $arg01@541@01 $arg02@541@01) (= $arg11@542@01 $arg12@542@01))
      (= $arg21@543@01 $arg22@543@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@541@01 Int) ($arg1@542@01 Int) ($arg2@543@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@541@01)
            ($SortWrappers.IntTo$Snap $arg1@542@01))
          ($SortWrappers.IntTo$Snap $arg2@543@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@541@01)
            ($SortWrappers.IntTo$Snap $arg1@542@01))
          ($SortWrappers.IntTo$Snap $arg2@543@01)))))
    (and
      (and
        (= (inv@545@01 $arg0@541@01 $arg1@542@01 $arg2@543@01) $arg0@541@01)
        (= (inv@547@01 $arg0@541@01 $arg1@542@01 $arg2@543@01) $arg1@542@01)
        (= (inv@549@01 $arg0@541@01 $arg1@542@01 $arg2@543@01) $arg2@543@01))
      (and
        (img@546@01 $arg0@541@01 $arg1@542@01 $arg2@543@01)
        (img@548@01 $arg0@541@01 $arg1@542@01 $arg2@543@01)
        (img@550@01 $arg0@541@01 $arg1@542@01 $arg2@543@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@541@01)
      ($SortWrappers.IntTo$Snap $arg1@542@01))
    ($SortWrappers.IntTo$Snap $arg2@543@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@541@01)
      ($SortWrappers.IntTo$Snap $arg1@542@01))
    ($SortWrappers.IntTo$Snap $arg2@543@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@546@01 $arg0 $arg1 $arg2)
        (img@548@01 $arg0 $arg1 $arg2)
        (img@550@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@545@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@547@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@549@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@545@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@547@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@549@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@545@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@547@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@549@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@545@01 $arg0 $arg1 $arg2))
  :pattern ((inv@547@01 $arg0 $arg1 $arg2))
  :pattern ((inv@549@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@545@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@547@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@549@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@545@01 $arg0 $arg1 $arg2) (inv@547@01 $arg0 $arg1 $arg2) (inv@549@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1605|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 26
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@545@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@547@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@549@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@546@01 $arg0 $arg1 $arg2)
        (img@548@01 $arg0 $arg1 $arg2)
        (img@550@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@545@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@547@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@549@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@544@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@545@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@547@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@549@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1606|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@551@01 Int)
(declare-const $arg1@552@01 Int)
(declare-const $arg2@553@01 Int)
(push) ; 26
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@554@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef24|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef25|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@551@01)
    ($SortWrappers.IntTo$Snap $arg1@552@01))
  ($SortWrappers.IntTo$Snap $arg2@553@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@551@01)
    ($SortWrappers.IntTo$Snap $arg1@552@01))
  ($SortWrappers.IntTo$Snap $arg2@553@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@551@01)
      ($SortWrappers.IntTo$Snap $arg1@552@01))
    ($SortWrappers.IntTo$Snap $arg2@553@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 26
(declare-fun inv@555@01 (Int Int Int) Int)
(declare-fun img@556@01 (Int Int Int) Bool)
(declare-fun inv@557@01 (Int Int Int) Int)
(declare-fun img@558@01 (Int Int Int) Bool)
(declare-fun inv@559@01 (Int Int Int) Int)
(declare-fun img@560@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef24|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef25|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@551@01 Int) ($arg1@552@01 Int) ($arg2@553@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@551@01)
          ($SortWrappers.IntTo$Snap $arg1@552@01))
        ($SortWrappers.IntTo$Snap $arg2@553@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@551@01)
        ($SortWrappers.IntTo$Snap $arg1@552@01))
      ($SortWrappers.IntTo$Snap $arg2@553@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@551@01)
        ($SortWrappers.IntTo$Snap $arg1@552@01))
      ($SortWrappers.IntTo$Snap $arg2@553@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@551@01)
      ($SortWrappers.IntTo$Snap $arg1@552@01))
    ($SortWrappers.IntTo$Snap $arg2@553@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@551@01)
      ($SortWrappers.IntTo$Snap $arg1@552@01))
    ($SortWrappers.IntTo$Snap $arg2@553@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 26
(assert (not (forall (($arg0@551@01 Int) ($arg1@552@01 Int) ($arg2@553@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@551@01)
          ($SortWrappers.IntTo$Snap $arg1@552@01))
        ($SortWrappers.IntTo$Snap $arg2@553@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@551@01)
            ($SortWrappers.IntTo$Snap $arg1@552@01))
          ($SortWrappers.IntTo$Snap $arg2@553@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@551@01)
            ($SortWrappers.IntTo$Snap $arg1@552@01))
          ($SortWrappers.IntTo$Snap $arg2@553@01))))))
  
  :qid |quant-u-1607|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 26
(assert (not (forall (($arg01@551@01 Int) ($arg11@552@01 Int) ($arg21@553@01 Int) ($arg02@551@01 Int) ($arg12@552@01 Int) ($arg22@553@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@551@01)
                ($SortWrappers.IntTo$Snap $arg11@552@01))
              ($SortWrappers.IntTo$Snap $arg21@553@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@551@01)
              ($SortWrappers.IntTo$Snap $arg11@552@01))
            ($SortWrappers.IntTo$Snap $arg21@553@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@551@01)
              ($SortWrappers.IntTo$Snap $arg11@552@01))
            ($SortWrappers.IntTo$Snap $arg21@553@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@551@01)
              ($SortWrappers.IntTo$Snap $arg11@552@01))
            ($SortWrappers.IntTo$Snap $arg21@553@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@551@01)
                ($SortWrappers.IntTo$Snap $arg12@552@01))
              ($SortWrappers.IntTo$Snap $arg22@553@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@551@01)
              ($SortWrappers.IntTo$Snap $arg12@552@01))
            ($SortWrappers.IntTo$Snap $arg22@553@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@551@01)
              ($SortWrappers.IntTo$Snap $arg12@552@01))
            ($SortWrappers.IntTo$Snap $arg22@553@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@551@01)
              ($SortWrappers.IntTo$Snap $arg12@552@01))
            ($SortWrappers.IntTo$Snap $arg22@553@01)))))
      (and
        (and (= $arg01@551@01 $arg02@551@01) (= $arg11@552@01 $arg12@552@01))
        (= $arg21@553@01 $arg22@553@01)))
    (and
      (and (= $arg01@551@01 $arg02@551@01) (= $arg11@552@01 $arg12@552@01))
      (= $arg21@553@01 $arg22@553@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@551@01 Int) ($arg1@552@01 Int) ($arg2@553@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@551@01)
            ($SortWrappers.IntTo$Snap $arg1@552@01))
          ($SortWrappers.IntTo$Snap $arg2@553@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@551@01)
            ($SortWrappers.IntTo$Snap $arg1@552@01))
          ($SortWrappers.IntTo$Snap $arg2@553@01)))))
    (and
      (and
        (= (inv@555@01 $arg0@551@01 $arg1@552@01 $arg2@553@01) $arg0@551@01)
        (= (inv@557@01 $arg0@551@01 $arg1@552@01 $arg2@553@01) $arg1@552@01)
        (= (inv@559@01 $arg0@551@01 $arg1@552@01 $arg2@553@01) $arg2@553@01))
      (and
        (img@556@01 $arg0@551@01 $arg1@552@01 $arg2@553@01)
        (img@558@01 $arg0@551@01 $arg1@552@01 $arg2@553@01)
        (img@560@01 $arg0@551@01 $arg1@552@01 $arg2@553@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@551@01)
      ($SortWrappers.IntTo$Snap $arg1@552@01))
    ($SortWrappers.IntTo$Snap $arg2@553@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@551@01)
      ($SortWrappers.IntTo$Snap $arg1@552@01))
    ($SortWrappers.IntTo$Snap $arg2@553@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@556@01 $arg0 $arg1 $arg2)
        (img@558@01 $arg0 $arg1 $arg2)
        (img@560@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@555@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@557@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@559@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@555@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@557@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@559@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@555@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@557@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@559@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@555@01 $arg0 $arg1 $arg2))
  :pattern ((inv@557@01 $arg0 $arg1 $arg2))
  :pattern ((inv@559@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@555@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@557@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@559@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@465@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@555@01 $arg0 $arg1 $arg2) (inv@557@01 $arg0 $arg1 $arg2) (inv@559@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1608|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 26
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@555@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@557@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@559@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@556@01 $arg0 $arg1 $arg2)
        (img@558@01 $arg0 $arg1 $arg2)
        (img@560@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@555@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@557@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@559@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@554@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@555@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@557@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@559@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1609|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@561@01 Int)
(declare-const $arg1@562@01 Int)
(declare-const $arg2@563@01 Int)
(push) ; 26
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@564@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef26|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef27|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@561@01)
    ($SortWrappers.IntTo$Snap $arg1@562@01))
  ($SortWrappers.IntTo$Snap $arg2@563@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@561@01)
    ($SortWrappers.IntTo$Snap $arg1@562@01))
  ($SortWrappers.IntTo$Snap $arg2@563@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@561@01)
      ($SortWrappers.IntTo$Snap $arg1@562@01))
    ($SortWrappers.IntTo$Snap $arg2@563@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 26
(declare-fun inv@565@01 (Int Int Int) Int)
(declare-fun img@566@01 (Int Int Int) Bool)
(declare-fun inv@567@01 (Int Int Int) Int)
(declare-fun img@568@01 (Int Int Int) Bool)
(declare-fun inv@569@01 (Int Int Int) Int)
(declare-fun img@570@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef26|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef27|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@561@01 Int) ($arg1@562@01 Int) ($arg2@563@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@561@01)
          ($SortWrappers.IntTo$Snap $arg1@562@01))
        ($SortWrappers.IntTo$Snap $arg2@563@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@561@01)
        ($SortWrappers.IntTo$Snap $arg1@562@01))
      ($SortWrappers.IntTo$Snap $arg2@563@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@561@01)
        ($SortWrappers.IntTo$Snap $arg1@562@01))
      ($SortWrappers.IntTo$Snap $arg2@563@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@561@01)
      ($SortWrappers.IntTo$Snap $arg1@562@01))
    ($SortWrappers.IntTo$Snap $arg2@563@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@561@01)
      ($SortWrappers.IntTo$Snap $arg1@562@01))
    ($SortWrappers.IntTo$Snap $arg2@563@01))))
  :qid |e$Transfer-aux|)))
(push) ; 26
(assert (not (forall (($arg0@561@01 Int) ($arg1@562@01 Int) ($arg2@563@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@561@01)
          ($SortWrappers.IntTo$Snap $arg1@562@01))
        ($SortWrappers.IntTo$Snap $arg2@563@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@561@01)
            ($SortWrappers.IntTo$Snap $arg1@562@01))
          ($SortWrappers.IntTo$Snap $arg2@563@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@561@01)
            ($SortWrappers.IntTo$Snap $arg1@562@01))
          ($SortWrappers.IntTo$Snap $arg2@563@01))))))
  
  :qid |quant-u-1610|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 26
(assert (not (forall (($arg01@561@01 Int) ($arg11@562@01 Int) ($arg21@563@01 Int) ($arg02@561@01 Int) ($arg12@562@01 Int) ($arg22@563@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@561@01)
                ($SortWrappers.IntTo$Snap $arg11@562@01))
              ($SortWrappers.IntTo$Snap $arg21@563@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@561@01)
              ($SortWrappers.IntTo$Snap $arg11@562@01))
            ($SortWrappers.IntTo$Snap $arg21@563@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@561@01)
              ($SortWrappers.IntTo$Snap $arg11@562@01))
            ($SortWrappers.IntTo$Snap $arg21@563@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@561@01)
              ($SortWrappers.IntTo$Snap $arg11@562@01))
            ($SortWrappers.IntTo$Snap $arg21@563@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@561@01)
                ($SortWrappers.IntTo$Snap $arg12@562@01))
              ($SortWrappers.IntTo$Snap $arg22@563@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@561@01)
              ($SortWrappers.IntTo$Snap $arg12@562@01))
            ($SortWrappers.IntTo$Snap $arg22@563@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@561@01)
              ($SortWrappers.IntTo$Snap $arg12@562@01))
            ($SortWrappers.IntTo$Snap $arg22@563@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@561@01)
              ($SortWrappers.IntTo$Snap $arg12@562@01))
            ($SortWrappers.IntTo$Snap $arg22@563@01)))))
      (and
        (and (= $arg01@561@01 $arg02@561@01) (= $arg11@562@01 $arg12@562@01))
        (= $arg21@563@01 $arg22@563@01)))
    (and
      (and (= $arg01@561@01 $arg02@561@01) (= $arg11@562@01 $arg12@562@01))
      (= $arg21@563@01 $arg22@563@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@561@01 Int) ($arg1@562@01 Int) ($arg2@563@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@561@01)
            ($SortWrappers.IntTo$Snap $arg1@562@01))
          ($SortWrappers.IntTo$Snap $arg2@563@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@561@01)
            ($SortWrappers.IntTo$Snap $arg1@562@01))
          ($SortWrappers.IntTo$Snap $arg2@563@01)))))
    (and
      (and
        (= (inv@565@01 $arg0@561@01 $arg1@562@01 $arg2@563@01) $arg0@561@01)
        (= (inv@567@01 $arg0@561@01 $arg1@562@01 $arg2@563@01) $arg1@562@01)
        (= (inv@569@01 $arg0@561@01 $arg1@562@01 $arg2@563@01) $arg2@563@01))
      (and
        (img@566@01 $arg0@561@01 $arg1@562@01 $arg2@563@01)
        (img@568@01 $arg0@561@01 $arg1@562@01 $arg2@563@01)
        (img@570@01 $arg0@561@01 $arg1@562@01 $arg2@563@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@561@01)
      ($SortWrappers.IntTo$Snap $arg1@562@01))
    ($SortWrappers.IntTo$Snap $arg2@563@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@561@01)
      ($SortWrappers.IntTo$Snap $arg1@562@01))
    ($SortWrappers.IntTo$Snap $arg2@563@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@566@01 $arg0 $arg1 $arg2)
        (img@568@01 $arg0 $arg1 $arg2)
        (img@570@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@565@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@567@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@569@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@565@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@567@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@569@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@565@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@567@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@569@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@565@01 $arg0 $arg1 $arg2))
  :pattern ((inv@567@01 $arg0 $arg1 $arg2))
  :pattern ((inv@569@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@565@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@567@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@569@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@565@01 $arg0 $arg1 $arg2) (inv@567@01 $arg0 $arg1 $arg2) (inv@569@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1611|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 26
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@565@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@567@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@569@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@566@01 $arg0 $arg1 $arg2)
        (img@568@01 $arg0 $arg1 $arg2)
        (img@570@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@565@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@567@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@569@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@564@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@565@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@567@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@569@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1612|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@571@01 Int)
(declare-const $arg1@572@01 Int)
(declare-const $arg2@573@01 Int)
(push) ; 26
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@574@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef28|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef29|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@571@01)
    ($SortWrappers.IntTo$Snap $arg1@572@01))
  ($SortWrappers.IntTo$Snap $arg2@573@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@571@01)
    ($SortWrappers.IntTo$Snap $arg1@572@01))
  ($SortWrappers.IntTo$Snap $arg2@573@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@571@01)
      ($SortWrappers.IntTo$Snap $arg1@572@01))
    ($SortWrappers.IntTo$Snap $arg2@573@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 26
(declare-fun inv@575@01 (Int Int Int) Int)
(declare-fun img@576@01 (Int Int Int) Bool)
(declare-fun inv@577@01 (Int Int Int) Int)
(declare-fun img@578@01 (Int Int Int) Bool)
(declare-fun inv@579@01 (Int Int Int) Int)
(declare-fun img@580@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef28|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef29|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@571@01 Int) ($arg1@572@01 Int) ($arg2@573@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@571@01)
          ($SortWrappers.IntTo$Snap $arg1@572@01))
        ($SortWrappers.IntTo$Snap $arg2@573@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@571@01)
        ($SortWrappers.IntTo$Snap $arg1@572@01))
      ($SortWrappers.IntTo$Snap $arg2@573@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@571@01)
        ($SortWrappers.IntTo$Snap $arg1@572@01))
      ($SortWrappers.IntTo$Snap $arg2@573@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@571@01)
      ($SortWrappers.IntTo$Snap $arg1@572@01))
    ($SortWrappers.IntTo$Snap $arg2@573@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@571@01)
      ($SortWrappers.IntTo$Snap $arg1@572@01))
    ($SortWrappers.IntTo$Snap $arg2@573@01))))
  :qid |e$Approval-aux|)))
(push) ; 26
(assert (not (forall (($arg0@571@01 Int) ($arg1@572@01 Int) ($arg2@573@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@571@01)
          ($SortWrappers.IntTo$Snap $arg1@572@01))
        ($SortWrappers.IntTo$Snap $arg2@573@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@571@01)
            ($SortWrappers.IntTo$Snap $arg1@572@01))
          ($SortWrappers.IntTo$Snap $arg2@573@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@571@01)
            ($SortWrappers.IntTo$Snap $arg1@572@01))
          ($SortWrappers.IntTo$Snap $arg2@573@01))))))
  
  :qid |quant-u-1613|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 26
(assert (not (forall (($arg01@571@01 Int) ($arg11@572@01 Int) ($arg21@573@01 Int) ($arg02@571@01 Int) ($arg12@572@01 Int) ($arg22@573@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@571@01)
                ($SortWrappers.IntTo$Snap $arg11@572@01))
              ($SortWrappers.IntTo$Snap $arg21@573@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@571@01)
              ($SortWrappers.IntTo$Snap $arg11@572@01))
            ($SortWrappers.IntTo$Snap $arg21@573@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@571@01)
              ($SortWrappers.IntTo$Snap $arg11@572@01))
            ($SortWrappers.IntTo$Snap $arg21@573@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@571@01)
              ($SortWrappers.IntTo$Snap $arg11@572@01))
            ($SortWrappers.IntTo$Snap $arg21@573@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@571@01)
                ($SortWrappers.IntTo$Snap $arg12@572@01))
              ($SortWrappers.IntTo$Snap $arg22@573@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@571@01)
              ($SortWrappers.IntTo$Snap $arg12@572@01))
            ($SortWrappers.IntTo$Snap $arg22@573@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@571@01)
              ($SortWrappers.IntTo$Snap $arg12@572@01))
            ($SortWrappers.IntTo$Snap $arg22@573@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@571@01)
              ($SortWrappers.IntTo$Snap $arg12@572@01))
            ($SortWrappers.IntTo$Snap $arg22@573@01)))))
      (and
        (and (= $arg01@571@01 $arg02@571@01) (= $arg11@572@01 $arg12@572@01))
        (= $arg21@573@01 $arg22@573@01)))
    (and
      (and (= $arg01@571@01 $arg02@571@01) (= $arg11@572@01 $arg12@572@01))
      (= $arg21@573@01 $arg22@573@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@571@01 Int) ($arg1@572@01 Int) ($arg2@573@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@571@01)
            ($SortWrappers.IntTo$Snap $arg1@572@01))
          ($SortWrappers.IntTo$Snap $arg2@573@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@571@01)
            ($SortWrappers.IntTo$Snap $arg1@572@01))
          ($SortWrappers.IntTo$Snap $arg2@573@01)))))
    (and
      (and
        (= (inv@575@01 $arg0@571@01 $arg1@572@01 $arg2@573@01) $arg0@571@01)
        (= (inv@577@01 $arg0@571@01 $arg1@572@01 $arg2@573@01) $arg1@572@01)
        (= (inv@579@01 $arg0@571@01 $arg1@572@01 $arg2@573@01) $arg2@573@01))
      (and
        (img@576@01 $arg0@571@01 $arg1@572@01 $arg2@573@01)
        (img@578@01 $arg0@571@01 $arg1@572@01 $arg2@573@01)
        (img@580@01 $arg0@571@01 $arg1@572@01 $arg2@573@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@571@01)
      ($SortWrappers.IntTo$Snap $arg1@572@01))
    ($SortWrappers.IntTo$Snap $arg2@573@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@571@01)
      ($SortWrappers.IntTo$Snap $arg1@572@01))
    ($SortWrappers.IntTo$Snap $arg2@573@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@576@01 $arg0 $arg1 $arg2)
        (img@578@01 $arg0 $arg1 $arg2)
        (img@580@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@575@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@577@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@579@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@575@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@577@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@579@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@575@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@577@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@579@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@575@01 $arg0 $arg1 $arg2))
  :pattern ((inv@577@01 $arg0 $arg1 $arg2))
  :pattern ((inv@579@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@575@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@577@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@579@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@489@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@575@01 $arg0 $arg1 $arg2) (inv@577@01 $arg0 $arg1 $arg2) (inv@579@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1614|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 26
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@575@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@577@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@579@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@576@01 $arg0 $arg1 $arg2)
        (img@578@01 $arg0 $arg1 $arg2)
        (img@580@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@575@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@577@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@579@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@574@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@575@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@577@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@579@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1615|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc
(push) ; 26
(set-option :timeout 10)
(assert (not (not l$send_fail$1@345@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not l$send_fail$1@345@01))
(check-sat)
; unknown
(pop) ; 26
; 0.01s
; (get-info :all-statistics)
; [then-branch: 135 | l$send_fail$1@345@01 | live]
; [else-branch: 135 | !(l$send_fail$1@345@01) | live]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 135 | l$send_fail$1@345@01]
(assert l$send_fail$1@345@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@581@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 27
; 0.01s
; (get-info :all-statistics)
; [then-branch: 136 | True | live]
; [else-branch: 136 | False | dead]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 136 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@582@01 $Snap)
(assert (= $t@582@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@583@01 $Struct)
(assert (=
  self@583@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 27
; [then-branch: 137 | False | dead]
; [else-branch: 137 | True | live]
(set-option :timeout 0)
(push) ; 27
; [else-branch: 137 | True]
(pop) ; 27
(pop) ; 26
(push) ; 26
; [else-branch: 135 | !(l$send_fail$1@345@01)]
(assert (not l$send_fail$1@345@01))
(pop) ; 26
; [eval] !l$send_fail$1
(push) ; 26
(set-option :timeout 10)
(assert (not l$send_fail$1@345@01))
(check-sat)
; unknown
(pop) ; 26
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not l$send_fail$1@345@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.01s
; (get-info :all-statistics)
; [then-branch: 138 | !(l$send_fail$1@345@01) | live]
; [else-branch: 138 | l$send_fail$1@345@01 | live]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 138 | !(l$send_fail$1@345@01)]
(assert (not l$send_fail$1@345@01))
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; i1$$pre_self := self
; [exec]
; i1$$pre_$contracts := $contracts
; [exec]
; $contracts := l$havoc$1
; [exec]
; $old_$contracts := $contracts
; [exec]
; self := l$havoc$2
; [exec]
; $contracts := l$havoc$3
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@584@01 $Snap)
(assert (= $t@584@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$havoc$2@350@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@585@01 $Snap)
(assert (= $t@585@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$havoc$2@350@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@586@01 $Snap)
(assert (= $t@586@01 ($Snap.combine ($Snap.first $t@586@01) ($Snap.second $t@586@01))))
(assert (= ($Snap.first $t@586@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 2))))
(assert (= ($Snap.second $t@586@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@587@01 $Snap)
(assert (= $t@587@01 ($Snap.combine ($Snap.first $t@587@01) ($Snap.second $t@587@01))))
(assert (= ($Snap.first $t@587@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 3))))
(assert (= ($Snap.second $t@587@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@588@01 $Snap)
(assert (= $t@588@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@589@01 Int)
(set-option :timeout 0)
(push) ; 27
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 28
; [then-branch: 139 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 4)), $q2@589@01)) | live]
; [else-branch: 139 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 4)), $q2@589@01) | live]
(push) ; 29
; [then-branch: 139 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 4)), $q2@589@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@589@01))))
(pop) ; 29
(push) ; 29
; [else-branch: 139 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 4)), $q2@589@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@589@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 29
(pop) ; 28
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@589@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@589@01)))))
(pop) ; 27
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@589@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@589@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@589@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@589@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1294@13@1294@347-aux|)))
(assert (forall (($q2@589@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@589@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@589@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@589@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1294@13@1294@347|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@590@01 $Snap)
(assert (= $t@590@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@591@01 Int)
(set-option :timeout 0)
(push) ; 27
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 27
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@591@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@591@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 4)) $q2@591@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1295@13@1295@255|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@592@01 $Snap)
(assert (= $t@592@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@593@01 Int)
(set-option :timeout 0)
(push) ; 27
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@594@01 Int)
(push) ; 28
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 29
; [then-branch: 140 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$2@350@01, 5)), $q3@593@01), $q4@594@01)) | live]
; [else-branch: 140 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$2@350@01, 5)), $q3@593@01), $q4@594@01) | live]
(push) ; 30
; [then-branch: 140 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$2@350@01, 5)), $q3@593@01), $q4@594@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01))))
(pop) ; 30
(push) ; 30
; [else-branch: 140 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$2@350@01, 5)), $q3@593@01), $q4@594@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 30
(pop) ; 29
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01)))))
(pop) ; 28
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@594@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1296@133@1296@599-aux|)))
(pop) ; 27
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@593@01 Int)) (!
  (forall (($q4@594@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1296@133@1296@599-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1296@13@1296@600-aux|)))
(assert (forall (($q3@593@01 Int)) (!
  (forall (($q4@594@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01) $q4@594@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1296@133@1296@599|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@593@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1296@13@1296@600|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@595@01 $Snap)
(assert (= $t@595@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@596@01 Int)
(set-option :timeout 0)
(push) ; 27
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@597@01 Int)
(push) ; 28
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 28
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 27
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@596@01 Int)) (!
  (forall (($q4@597@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@596@01) $q4@597@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@596@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@596@01) $q4@597@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1297@133@1297@507|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@350@01 5)) $q3@596@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1297@13@1297@508|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@598@01 $Snap)
(assert (= $t@598@01 ($Snap.combine ($Snap.first $t@598@01) ($Snap.second $t@598@01))))
(assert (= ($Snap.first $t@598@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 6))))
(assert (= ($Snap.second $t@598@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@599@01 $Snap)
(assert (= $t@599@01 ($Snap.combine ($Snap.first $t@599@01) ($Snap.second $t@599@01))))
(assert (= ($Snap.first $t@599@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 7))))
(assert (= ($Snap.second $t@599@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@600@01 $Snap)
(assert (= $t@600@01 ($Snap.combine ($Snap.first $t@600@01) ($Snap.second $t@600@01))))
(assert (= ($Snap.first $t@600@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 8))))
(assert (= ($Snap.second $t@600@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@601@01 $Snap)
(assert (= $t@601@01 ($Snap.combine ($Snap.first $t@601@01) ($Snap.second $t@601@01))))
(assert (= ($Snap.first $t@601@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 9))))
(assert (= ($Snap.second $t@601@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@602@01 $Snap)
(assert (= $t@602@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@603@01 Int)
(set-option :timeout 0)
(push) ; 27
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 28
; [then-branch: 141 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 11)), $q5@603@01)) | live]
; [else-branch: 141 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 11)), $q5@603@01) | live]
(push) ; 29
; [then-branch: 141 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 11)), $q5@603@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@603@01))))
(pop) ; 29
(push) ; 29
; [else-branch: 141 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 11)), $q5@603@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@603@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 29
(pop) ; 28
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@603@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@603@01)))))
(pop) ; 27
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@603@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@603@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@603@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@603@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1302@13@1302@350-aux|)))
(assert (forall (($q5@603@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@603@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@603@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@603@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1302@13@1302@350|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@604@01 $Snap)
(assert (= $t@604@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@605@01 Int)
(set-option :timeout 0)
(push) ; 27
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 27
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@605@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@605@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $q5@605@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1303@13@1303@258|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@606@01 $Snap)
(assert (= $t@606@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@607@01 Int)
(set-option :timeout 0)
(push) ; 27
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 28
; [then-branch: 142 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 12)), $q6@607@01)) | live]
; [else-branch: 142 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 12)), $q6@607@01) | live]
(push) ; 29
; [then-branch: 142 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 12)), $q6@607@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@607@01))))
(pop) ; 29
(push) ; 29
; [else-branch: 142 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@350@01, 12)), $q6@607@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@607@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 29
(pop) ; 28
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@607@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@607@01)))))
(pop) ; 27
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@607@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@607@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@607@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@607@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1304@13@1304@350-aux|)))
(assert (forall (($q6@607@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@607@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@607@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@607@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1304@13@1304@350|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@608@01 $Snap)
(assert (= $t@608@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@609@01 Int)
(set-option :timeout 0)
(push) ; 27
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 27
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@609@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@609@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 12)) $q6@609@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1305@13@1305@258|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@610@01 $Snap)
(assert (= $t@610@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@611@01 $Snap)
(assert (= $t@611@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@612@01 Int)
(set-option :timeout 0)
(push) ; 27
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($old_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($old_self, 11)
(pop) ; 27
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($a@612@01 Int)) (!
  (>=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $a@612@01)
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@520@01 11)) $a@612@01))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@350@01 11)) $a@612@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1308@13@1308@264|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not l$no_reentrant_call@352@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not l$no_reentrant_call@352@01))
(check-sat)
; unknown
(pop) ; 27
; 0.01s
; (get-info :all-statistics)
; [then-branch: 143 | l$no_reentrant_call@352@01 | live]
; [else-branch: 143 | !(l$no_reentrant_call@352@01) | live]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 143 | l$no_reentrant_call@352@01]
(assert l$no_reentrant_call@352@01)
; [exec]
; self := $old_self
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$4
; [exec]
; $old_$contracts := i1$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$5
; [exec]
; $old_$contracts := i1$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$raw_ret$1
(push) ; 28
(set-option :timeout 10)
(assert (not l$raw_ret$1@346@01))
(check-sat)
; unknown
(pop) ; 28
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 28
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@346@01)))
(check-sat)
; unknown
(pop) ; 28
; 0.01s
; (get-info :all-statistics)
; [then-branch: 144 | !(l$raw_ret$1@346@01) | live]
; [else-branch: 144 | l$raw_ret$1@346@01 | live]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 144 | !(l$raw_ret$1@346@01)]
(assert (not l$raw_ret$1@346@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 29
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
; [then-branch: 145 | True | live]
; [else-branch: 145 | False | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 145 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@613@01 $Snap)
(assert (= $t@613@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@614@01 $Struct)
(assert (=
  self@614@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 29
; [then-branch: 146 | False | dead]
; [else-branch: 146 | True | live]
(set-option :timeout 0)
(push) ; 29
; [else-branch: 146 | True]
(pop) ; 29
(pop) ; 28
(push) ; 28
; [else-branch: 144 | l$raw_ret$1@346@01]
(assert l$raw_ret$1@346@01)
(pop) ; 28
; [eval] !!l$raw_ret$1
; [eval] !l$raw_ret$1
(push) ; 28
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@346@01)))
(check-sat)
; unknown
(pop) ; 28
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 28
(set-option :timeout 10)
(assert (not l$raw_ret$1@346@01))
(check-sat)
; unknown
(pop) ; 28
; 0.01s
; (get-info :all-statistics)
; [then-branch: 147 | l$raw_ret$1@346@01 | live]
; [else-branch: 147 | !(l$raw_ret$1@346@01) | live]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 147 | l$raw_ret$1@346@01]
(assert l$raw_ret$1@346@01)
; [exec]
; inhale acc(e$AddLiquidity(($struct_get($struct_loc(msg, 0)): Int), ($struct_get($struct_loc(msg,
;   1)): Int), $unwrap(l$token_amount)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
; [eval] $unwrap(l$token_amount)
(declare-const $t@615@01 $Snap)
(declare-const sm@616@01 $PSF<e$AddLiquidity>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$AddLiquidity (as sm@616@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@509@01))))
  $t@615@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
      (=
        ($unwrap<Int> l$token_amount@509@01)
        ($unwrap<Int> l$token_amount@509@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@509@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@509@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(e$Transfer(0, ($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$liquidity_minted)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$liquidity_minted)
(declare-const $t@617@01 $Snap)
(declare-const sm@618@01 $PSF<e$Transfer>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$Transfer (as sm@618@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap 0)
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$liquidity_minted@512@01))))
  $t@617@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (= 0 0)
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      (=
        ($unwrap<Int> l$liquidity_minted@512@01)
        ($unwrap<Int> l$liquidity_minted@512@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap 0)
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$liquidity_minted@512@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap 0)
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$liquidity_minted@512@01)))))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; $res := $unwrap(l$liquidity_minted)
; [eval] $unwrap(l$liquidity_minted)
(declare-const $res@619@01 Int)
(assert (= $res@619@01 ($unwrap<Int> l$liquidity_minted@512@01)))
; [exec]
; label return
(set-option :timeout 0)
(push) ; 29
(set-option :timeout 10)
(assert (not (not $out_of_gas@370@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 29
(set-option :timeout 10)
(assert (not $out_of_gas@370@01))
(check-sat)
; unknown
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
; [then-branch: 148 | $out_of_gas@370@01 | live]
; [else-branch: 148 | !($out_of_gas@370@01) | live]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 148 | $out_of_gas@370@01]
(assert $out_of_gas@370@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 30
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 30
; 0.01s
; (get-info :all-statistics)
; [then-branch: 149 | True | live]
; [else-branch: 149 | False | dead]
(set-option :timeout 0)
(push) ; 30
; [then-branch: 149 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@620@01 $Snap)
(assert (= $t@620@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@621@01 $Struct)
(assert (=
  self@621@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 30
; [then-branch: 150 | False | dead]
; [else-branch: 150 | True | live]
(set-option :timeout 0)
(push) ; 30
; [else-branch: 150 | True]
(pop) ; 30
(pop) ; 29
(push) ; 29
; [else-branch: 148 | !($out_of_gas@370@01)]
(assert (not $out_of_gas@370@01))
(pop) ; 29
; [eval] !$out_of_gas
(push) ; 29
(set-option :timeout 10)
(assert (not $out_of_gas@370@01))
(check-sat)
; unknown
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 29
(set-option :timeout 10)
(assert (not (not $out_of_gas@370@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
; [then-branch: 151 | !($out_of_gas@370@01) | live]
; [else-branch: 151 | $out_of_gas@370@01 | live]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 151 | !($out_of_gas@370@01)]
(assert (not $out_of_gas@370@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 152 | False | dead]
; [else-branch: 152 | True | live]
(push) ; 30
; [else-branch: 152 | True]
(pop) ; 30
(push) ; 30
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 30
; 0.01s
; (get-info :all-statistics)
; [then-branch: 153 | True | live]
; [else-branch: 153 | False | dead]
(set-option :timeout 0)
(push) ; 30
; [then-branch: 153 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@622@01 $Snap)
(assert (= $t@622@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@623@01 $Struct)
(assert (=
  self@623@01
  ($struct_set<$Struct> self@520@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@520@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 30
(pop) ; 29
(set-option :timeout 0)
(push) ; 29
; [else-branch: 151 | $out_of_gas@370@01]
(assert $out_of_gas@370@01)
(pop) ; 29
(pop) ; 28
(push) ; 28
; [else-branch: 147 | !(l$raw_ret$1@346@01)]
(assert (not l$raw_ret$1@346@01))
(pop) ; 28
(pop) ; 27
(push) ; 27
; [else-branch: 143 | !(l$no_reentrant_call@352@01)]
(assert (not l$no_reentrant_call@352@01))
(pop) ; 27
; [eval] !l$no_reentrant_call
(push) ; 27
(set-option :timeout 10)
(assert (not l$no_reentrant_call@352@01))
(check-sat)
; unknown
(pop) ; 27
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not l$no_reentrant_call@352@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.01s
; (get-info :all-statistics)
; [then-branch: 154 | !(l$no_reentrant_call@352@01) | live]
; [else-branch: 154 | l$no_reentrant_call@352@01 | live]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 154 | !(l$no_reentrant_call@352@01)]
(assert (not l$no_reentrant_call@352@01))
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$4
; [exec]
; $old_$contracts := i1$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$5
; [exec]
; $old_$contracts := i1$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$raw_ret$1
(push) ; 28
(set-option :timeout 10)
(assert (not l$raw_ret$1@346@01))
(check-sat)
; unknown
(pop) ; 28
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 28
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@346@01)))
(check-sat)
; unknown
(pop) ; 28
; 0.01s
; (get-info :all-statistics)
; [then-branch: 155 | !(l$raw_ret$1@346@01) | live]
; [else-branch: 155 | l$raw_ret$1@346@01 | live]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 155 | !(l$raw_ret$1@346@01)]
(assert (not l$raw_ret$1@346@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 29
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
; [then-branch: 156 | True | live]
; [else-branch: 156 | False | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 156 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@624@01 $Snap)
(assert (= $t@624@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@625@01 $Struct)
(assert (=
  self@625@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 29
; [then-branch: 157 | False | dead]
; [else-branch: 157 | True | live]
(set-option :timeout 0)
(push) ; 29
; [else-branch: 157 | True]
(pop) ; 29
(pop) ; 28
(push) ; 28
; [else-branch: 155 | l$raw_ret$1@346@01]
(assert l$raw_ret$1@346@01)
(pop) ; 28
; [eval] !!l$raw_ret$1
; [eval] !l$raw_ret$1
(push) ; 28
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@346@01)))
(check-sat)
; unknown
(pop) ; 28
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 28
(set-option :timeout 10)
(assert (not l$raw_ret$1@346@01))
(check-sat)
; unknown
(pop) ; 28
; 0.01s
; (get-info :all-statistics)
; [then-branch: 158 | l$raw_ret$1@346@01 | live]
; [else-branch: 158 | !(l$raw_ret$1@346@01) | live]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 158 | l$raw_ret$1@346@01]
(assert l$raw_ret$1@346@01)
; [exec]
; inhale acc(e$AddLiquidity(($struct_get($struct_loc(msg, 0)): Int), ($struct_get($struct_loc(msg,
;   1)): Int), $unwrap(l$token_amount)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
; [eval] $unwrap(l$token_amount)
(declare-const $t@626@01 $Snap)
(declare-const sm@627@01 $PSF<e$AddLiquidity>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$AddLiquidity (as sm@627@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@509@01))))
  $t@626@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
      (=
        ($unwrap<Int> l$token_amount@509@01)
        ($unwrap<Int> l$token_amount@509@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@453@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@509@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@509@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(e$Transfer(0, ($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$liquidity_minted)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$liquidity_minted)
(declare-const $t@628@01 $Snap)
(declare-const sm@629@01 $PSF<e$Transfer>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$Transfer (as sm@629@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap 0)
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$liquidity_minted@512@01))))
  $t@628@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (= 0 0)
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      (=
        ($unwrap<Int> l$liquidity_minted@512@01)
        ($unwrap<Int> l$liquidity_minted@512@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@477@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap 0)
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$liquidity_minted@512@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap 0)
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$liquidity_minted@512@01)))))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; $res := $unwrap(l$liquidity_minted)
; [eval] $unwrap(l$liquidity_minted)
(declare-const $res@630@01 Int)
(assert (= $res@630@01 ($unwrap<Int> l$liquidity_minted@512@01)))
; [exec]
; label return
(set-option :timeout 0)
(push) ; 29
(set-option :timeout 10)
(assert (not (not $out_of_gas@370@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 29
(set-option :timeout 10)
(assert (not $out_of_gas@370@01))
(check-sat)
; unknown
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
; [then-branch: 159 | $out_of_gas@370@01 | live]
; [else-branch: 159 | !($out_of_gas@370@01) | live]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 159 | $out_of_gas@370@01]
(assert $out_of_gas@370@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 30
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 30
; 0.01s
; (get-info :all-statistics)
; [then-branch: 160 | True | live]
; [else-branch: 160 | False | dead]
(set-option :timeout 0)
(push) ; 30
; [then-branch: 160 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@631@01 $Snap)
(assert (= $t@631@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@632@01 $Struct)
(assert (=
  self@632@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 30
; [then-branch: 161 | False | dead]
; [else-branch: 161 | True | live]
(set-option :timeout 0)
(push) ; 30
; [else-branch: 161 | True]
(pop) ; 30
(pop) ; 29
(push) ; 29
; [else-branch: 159 | !($out_of_gas@370@01)]
(assert (not $out_of_gas@370@01))
(pop) ; 29
; [eval] !$out_of_gas
(push) ; 29
(set-option :timeout 10)
(assert (not $out_of_gas@370@01))
(check-sat)
; unknown
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 29
(set-option :timeout 10)
(assert (not (not $out_of_gas@370@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.01s
; (get-info :all-statistics)
; [then-branch: 162 | !($out_of_gas@370@01) | live]
; [else-branch: 162 | $out_of_gas@370@01 | live]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 162 | !($out_of_gas@370@01)]
(assert (not $out_of_gas@370@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 163 | False | dead]
; [else-branch: 163 | True | live]
(push) ; 30
; [else-branch: 163 | True]
(pop) ; 30
(push) ; 30
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 30
; 0.01s
; (get-info :all-statistics)
; [then-branch: 164 | True | live]
; [else-branch: 164 | False | dead]
(set-option :timeout 0)
(push) ; 30
; [then-branch: 164 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@633@01 $Snap)
(assert (= $t@633@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@634@01 $Struct)
(assert (=
  self@634@01
  ($struct_set<$Struct> l$havoc$2@350@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> l$havoc$2@350@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 30
(pop) ; 29
(set-option :timeout 0)
(push) ; 29
; [else-branch: 162 | $out_of_gas@370@01]
(assert $out_of_gas@370@01)
(pop) ; 29
(pop) ; 28
(push) ; 28
; [else-branch: 158 | !(l$raw_ret$1@346@01)]
(assert (not l$raw_ret$1@346@01))
(pop) ; 28
(pop) ; 27
(push) ; 27
; [else-branch: 154 | l$no_reentrant_call@352@01]
(assert l$no_reentrant_call@352@01)
(pop) ; 27
(pop) ; 26
(push) ; 26
; [else-branch: 138 | l$send_fail$1@345@01]
(assert l$send_fail$1@345@01)
(pop) ; 26
(pop) ; 25
(push) ; 25
; [else-branch: 134 | $unwrap[Int](l$total_liquidity@422@01) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+
    ($unwrap<Int> l$total_liquidity@422@01)
    ($unwrap<Int> l$liquidity_minted@512@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 25
(pop) ; 24
(pop) ; 23
(push) ; 23
; [else-branch: 128 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@419@01, 4)), $struct_get[Int]($struct_loc[Int](msg@324@01, 0))))) + $unwrap[Int](l$liquidity_minted@512@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@419@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))))
    ($unwrap<Int> l$liquidity_minted@512@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 23
(pop) ; 22
(pop) ; 21
(push) ; 21
; [else-branch: 122 | !($unwrap[Int](l$max_tokens@320@01) >= $unwrap[Int](l$token_amount@509@01) && $unwrap[Int](l$liquidity_minted@512@01) >= $unwrap[Int](l$min_liquidity@319@01))]
(assert (not
  (and
    (>= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$token_amount@509@01))
    (>=
      ($unwrap<Int> l$liquidity_minted@512@01)
      ($unwrap<Int> l$min_liquidity@319@01)))))
(pop) ; 21
(pop) ; 20
(pop) ; 19
(pop) ; 18
(pop) ; 17
(push) ; 17
; [else-branch: 105 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$total_liquidity@422@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$total_liquidity@422@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 17
(pop) ; 16
(pop) ; 15
(push) ; 15
; [else-branch: 98 | $unwrap[Int]($w_div[$Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01), l$eth_reserve@425@01)) + 1 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01) l$eth_reserve@425@01))
    1)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 15
(pop) ; 14
(pop) ; 13
(pop) ; 12
(pop) ; 11
(push) ; 11
; [else-branch: 80 | $unwrap[Int](l$eth_reserve@425@01) == 0]
(assert (= ($unwrap<Int> l$eth_reserve@425@01) 0))
(pop) ; 11
(pop) ; 10
(push) ; 10
; [else-branch: 76 | $unwrap[Int]($w_mul[$Int]($wrap[$Int]($struct_get[Int]($struct_loc[Int](msg@324@01, 1))), l$token_reserve@502@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  ($unwrap<Int> ($w_mul<$Int> ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))) l$token_reserve@502@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 10
(pop) ; 9
(pop) ; 8
(push) ; 8
; [else-branch: 70 | l$send_fail@339@01]
(assert l$send_fail@339@01)
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(push) ; 5
; [else-branch: 62 | !($unwrap[Int](l$min_liquidity@319@01) > 0)]
(assert (not (> ($unwrap<Int> l$min_liquidity@319@01) 0)))
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 58 | !($unwrap[Int](l$total_liquidity@422@01) > 0)]
(assert (not (> ($unwrap<Int> l$total_liquidity@422@01) 0)))
(pop) ; 4
; [eval] !($unwrap(l$total_liquidity) > 0)
; [eval] $unwrap(l$total_liquidity) > 0
; [eval] $unwrap(l$total_liquidity)
(push) ; 4
(set-option :timeout 10)
(assert (not (> ($unwrap<Int> l$total_liquidity@422@01) 0)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (> ($unwrap<Int> l$total_liquidity@422@01) 0))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 165 | !($unwrap[Int](l$total_liquidity@422@01) > 0) | live]
; [else-branch: 165 | $unwrap[Int](l$total_liquidity@422@01) > 0 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 165 | !($unwrap[Int](l$total_liquidity@422@01) > 0)]
(assert (not (> ($unwrap<Int> l$total_liquidity@422@01) 0)))
; [eval] !(($struct_get($struct_loc(self, 7)): Int) != 0 && (($struct_get($struct_loc(self, 6)): Int) != 0 && ($struct_get($struct_loc(msg, 1)): Int) >= 1000000000))
; [eval] ($struct_get($struct_loc(self, 7)): Int) != 0 && (($struct_get($struct_loc(self, 6)): Int) != 0 && ($struct_get($struct_loc(msg, 1)): Int) >= 1000000000)
; [eval] ($struct_get($struct_loc(self, 7)): Int) != 0
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(push) ; 5
; [then-branch: 166 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) == 0 | live]
; [else-branch: 166 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0 | live]
(push) ; 6
; [then-branch: 166 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) == 0]
(assert (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
(pop) ; 6
(push) ; 6
; [else-branch: 166 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0]
(assert (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0)))
; [eval] ($struct_get($struct_loc(self, 6)): Int) != 0
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(push) ; 7
; [then-branch: 167 | $struct_get[Int]($struct_loc[Int](self@419@01, 6)) == 0 | live]
; [else-branch: 167 | $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0 | live]
(push) ; 8
; [then-branch: 167 | $struct_get[Int]($struct_loc[Int](self@419@01, 6)) == 0]
(assert (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
(pop) ; 8
(push) ; 8
; [else-branch: 167 | $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0]
(assert (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0)))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) >= 1000000000
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
  (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
  (and
    (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
    (or
      (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
      (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0)))))
(assert (or
  (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
  (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0)))
(push) ; 5
(set-option :timeout 10)
(assert (not (and
  (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
  (and
    (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
    (>= ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 1000000000)))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not
  (and
    (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
    (and
      (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
      (>= ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 1000000000))))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 168 | !($struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0 && $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) >= 1000000000) | live]
; [else-branch: 168 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0 && $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) >= 1000000000 | live]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 168 | !($struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0 && $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) >= 1000000000)]
(assert (not
  (and
    (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
    (and
      (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
      (>= ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 1000000000)))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 6
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 169 | True | live]
; [else-branch: 169 | False | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 169 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@635@01 $Snap)
(assert (= $t@635@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@636@01 $Struct)
(assert (=
  self@636@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 6
; [then-branch: 170 | False | dead]
; [else-branch: 170 | True | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 170 | True]
(pop) ; 6
(pop) ; 5
(push) ; 5
; [else-branch: 168 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0 && $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) >= 1000000000]
(assert (and
  (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
  (and
    (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
    (>= ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 1000000000))))
(pop) ; 5
; [eval] !!(($struct_get($struct_loc(self, 7)): Int) != 0 && (($struct_get($struct_loc(self, 6)): Int) != 0 && ($struct_get($struct_loc(msg, 1)): Int) >= 1000000000))
; [eval] !(($struct_get($struct_loc(self, 7)): Int) != 0 && (($struct_get($struct_loc(self, 6)): Int) != 0 && ($struct_get($struct_loc(msg, 1)): Int) >= 1000000000))
; [eval] ($struct_get($struct_loc(self, 7)): Int) != 0 && (($struct_get($struct_loc(self, 6)): Int) != 0 && ($struct_get($struct_loc(msg, 1)): Int) >= 1000000000)
; [eval] ($struct_get($struct_loc(self, 7)): Int) != 0
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(push) ; 5
; [then-branch: 171 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) == 0 | live]
; [else-branch: 171 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0 | live]
(push) ; 6
; [then-branch: 171 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) == 0]
(assert (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
(pop) ; 6
(push) ; 6
; [else-branch: 171 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0]
(assert (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0)))
; [eval] ($struct_get($struct_loc(self, 6)): Int) != 0
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(push) ; 7
; [then-branch: 172 | $struct_get[Int]($struct_loc[Int](self@419@01, 6)) == 0 | live]
; [else-branch: 172 | $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0 | live]
(push) ; 8
; [then-branch: 172 | $struct_get[Int]($struct_loc[Int](self@419@01, 6)) == 0]
(assert (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
(pop) ; 8
(push) ; 8
; [else-branch: 172 | $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0]
(assert (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0)))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) >= 1000000000
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
  (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (not
  (and
    (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
    (and
      (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
      (>= ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 1000000000))))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (and
  (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
  (and
    (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
    (>= ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 1000000000)))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 173 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0 && $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) >= 1000000000 | live]
; [else-branch: 173 | !($struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0 && $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) >= 1000000000) | live]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 173 | $struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0 && $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) >= 1000000000]
(assert (and
  (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
  (and
    (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
    (>= ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 1000000000))))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@637@01 Int)
(declare-const $arg1@638@01 Int)
(declare-const $arg2@639@01 Int)
(push) ; 6
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
(declare-const sm@640@01 $PSF<e$TokenPurchase>)
(declare-const s@641@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@642@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef31|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef32|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@637@01)
    ($SortWrappers.IntTo$Snap $arg1@638@01))
  ($SortWrappers.IntTo$Snap $arg2@639@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@637@01)
    ($SortWrappers.IntTo$Snap $arg1@638@01))
  ($SortWrappers.IntTo$Snap $arg2@639@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@637@01)
      ($SortWrappers.IntTo$Snap $arg1@638@01))
    ($SortWrappers.IntTo$Snap $arg2@639@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 6
(declare-fun inv@643@01 (Int Int Int) Int)
(declare-fun img@644@01 (Int Int Int) Bool)
(declare-fun inv@645@01 (Int Int Int) Int)
(declare-fun img@646@01 (Int Int Int) Bool)
(declare-fun inv@647@01 (Int Int Int) Int)
(declare-fun img@648@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef31|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef32|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@637@01 Int) ($arg1@638@01 Int) ($arg2@639@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@637@01)
          ($SortWrappers.IntTo$Snap $arg1@638@01))
        ($SortWrappers.IntTo$Snap $arg2@639@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@637@01)
        ($SortWrappers.IntTo$Snap $arg1@638@01))
      ($SortWrappers.IntTo$Snap $arg2@639@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@637@01)
        ($SortWrappers.IntTo$Snap $arg1@638@01))
      ($SortWrappers.IntTo$Snap $arg2@639@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@637@01)
      ($SortWrappers.IntTo$Snap $arg1@638@01))
    ($SortWrappers.IntTo$Snap $arg2@639@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@637@01)
      ($SortWrappers.IntTo$Snap $arg1@638@01))
    ($SortWrappers.IntTo$Snap $arg2@639@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 6
(assert (not (forall (($arg0@637@01 Int) ($arg1@638@01 Int) ($arg2@639@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@637@01)
          ($SortWrappers.IntTo$Snap $arg1@638@01))
        ($SortWrappers.IntTo$Snap $arg2@639@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@637@01)
            ($SortWrappers.IntTo$Snap $arg1@638@01))
          ($SortWrappers.IntTo$Snap $arg2@639@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@637@01)
            ($SortWrappers.IntTo$Snap $arg1@638@01))
          ($SortWrappers.IntTo$Snap $arg2@639@01))))))
  
  :qid |quant-u-1624|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall (($arg01@637@01 Int) ($arg11@638@01 Int) ($arg21@639@01 Int) ($arg02@637@01 Int) ($arg12@638@01 Int) ($arg22@639@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@637@01)
                ($SortWrappers.IntTo$Snap $arg11@638@01))
              ($SortWrappers.IntTo$Snap $arg21@639@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@637@01)
              ($SortWrappers.IntTo$Snap $arg11@638@01))
            ($SortWrappers.IntTo$Snap $arg21@639@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@637@01)
              ($SortWrappers.IntTo$Snap $arg11@638@01))
            ($SortWrappers.IntTo$Snap $arg21@639@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@637@01)
              ($SortWrappers.IntTo$Snap $arg11@638@01))
            ($SortWrappers.IntTo$Snap $arg21@639@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@637@01)
                ($SortWrappers.IntTo$Snap $arg12@638@01))
              ($SortWrappers.IntTo$Snap $arg22@639@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@637@01)
              ($SortWrappers.IntTo$Snap $arg12@638@01))
            ($SortWrappers.IntTo$Snap $arg22@639@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@637@01)
              ($SortWrappers.IntTo$Snap $arg12@638@01))
            ($SortWrappers.IntTo$Snap $arg22@639@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@637@01)
              ($SortWrappers.IntTo$Snap $arg12@638@01))
            ($SortWrappers.IntTo$Snap $arg22@639@01)))))
      (and
        (and (= $arg01@637@01 $arg02@637@01) (= $arg11@638@01 $arg12@638@01))
        (= $arg21@639@01 $arg22@639@01)))
    (and
      (and (= $arg01@637@01 $arg02@637@01) (= $arg11@638@01 $arg12@638@01))
      (= $arg21@639@01 $arg22@639@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@637@01 Int) ($arg1@638@01 Int) ($arg2@639@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@637@01)
            ($SortWrappers.IntTo$Snap $arg1@638@01))
          ($SortWrappers.IntTo$Snap $arg2@639@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@637@01)
            ($SortWrappers.IntTo$Snap $arg1@638@01))
          ($SortWrappers.IntTo$Snap $arg2@639@01)))))
    (and
      (and
        (= (inv@643@01 $arg0@637@01 $arg1@638@01 $arg2@639@01) $arg0@637@01)
        (= (inv@645@01 $arg0@637@01 $arg1@638@01 $arg2@639@01) $arg1@638@01)
        (= (inv@647@01 $arg0@637@01 $arg1@638@01 $arg2@639@01) $arg2@639@01))
      (and
        (img@644@01 $arg0@637@01 $arg1@638@01 $arg2@639@01)
        (img@646@01 $arg0@637@01 $arg1@638@01 $arg2@639@01)
        (img@648@01 $arg0@637@01 $arg1@638@01 $arg2@639@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@637@01)
      ($SortWrappers.IntTo$Snap $arg1@638@01))
    ($SortWrappers.IntTo$Snap $arg2@639@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@637@01)
      ($SortWrappers.IntTo$Snap $arg1@638@01))
    ($SortWrappers.IntTo$Snap $arg2@639@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@644@01 $arg0 $arg1 $arg2)
        (img@646@01 $arg0 $arg1 $arg2)
        (img@648@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@643@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@645@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@647@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@643@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@645@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@647@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@643@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@645@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@647@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@643@01 $arg0 $arg1 $arg2))
  :pattern ((inv@645@01 $arg0 $arg1 $arg2))
  :pattern ((inv@647@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@643@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@645@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@647@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@643@01 $arg0 $arg1 $arg2) (inv@645@01 $arg0 $arg1 $arg2) (inv@647@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1625|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 6
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@643@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@645@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@647@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@644@01 $arg0 $arg1 $arg2)
        (img@646@01 $arg0 $arg1 $arg2)
        (img@648@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@643@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@645@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@647@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@642@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@643@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@645@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@647@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1626|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@649@01 Int)
(declare-const $arg1@650@01 Int)
(declare-const $arg2@651@01 Int)
(push) ; 6
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
(declare-const sm@652@01 $PSF<e$EthPurchase>)
(declare-const s@653@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@654@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef34|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef35|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@649@01)
    ($SortWrappers.IntTo$Snap $arg1@650@01))
  ($SortWrappers.IntTo$Snap $arg2@651@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@649@01)
    ($SortWrappers.IntTo$Snap $arg1@650@01))
  ($SortWrappers.IntTo$Snap $arg2@651@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@649@01)
      ($SortWrappers.IntTo$Snap $arg1@650@01))
    ($SortWrappers.IntTo$Snap $arg2@651@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 6
(declare-fun inv@655@01 (Int Int Int) Int)
(declare-fun img@656@01 (Int Int Int) Bool)
(declare-fun inv@657@01 (Int Int Int) Int)
(declare-fun img@658@01 (Int Int Int) Bool)
(declare-fun inv@659@01 (Int Int Int) Int)
(declare-fun img@660@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef34|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef35|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@649@01 Int) ($arg1@650@01 Int) ($arg2@651@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@649@01)
          ($SortWrappers.IntTo$Snap $arg1@650@01))
        ($SortWrappers.IntTo$Snap $arg2@651@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@649@01)
        ($SortWrappers.IntTo$Snap $arg1@650@01))
      ($SortWrappers.IntTo$Snap $arg2@651@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@649@01)
        ($SortWrappers.IntTo$Snap $arg1@650@01))
      ($SortWrappers.IntTo$Snap $arg2@651@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@649@01)
      ($SortWrappers.IntTo$Snap $arg1@650@01))
    ($SortWrappers.IntTo$Snap $arg2@651@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@649@01)
      ($SortWrappers.IntTo$Snap $arg1@650@01))
    ($SortWrappers.IntTo$Snap $arg2@651@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 6
(assert (not (forall (($arg0@649@01 Int) ($arg1@650@01 Int) ($arg2@651@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@649@01)
          ($SortWrappers.IntTo$Snap $arg1@650@01))
        ($SortWrappers.IntTo$Snap $arg2@651@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@649@01)
            ($SortWrappers.IntTo$Snap $arg1@650@01))
          ($SortWrappers.IntTo$Snap $arg2@651@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@649@01)
            ($SortWrappers.IntTo$Snap $arg1@650@01))
          ($SortWrappers.IntTo$Snap $arg2@651@01))))))
  
  :qid |quant-u-1627|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall (($arg01@649@01 Int) ($arg11@650@01 Int) ($arg21@651@01 Int) ($arg02@649@01 Int) ($arg12@650@01 Int) ($arg22@651@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@649@01)
                ($SortWrappers.IntTo$Snap $arg11@650@01))
              ($SortWrappers.IntTo$Snap $arg21@651@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@649@01)
              ($SortWrappers.IntTo$Snap $arg11@650@01))
            ($SortWrappers.IntTo$Snap $arg21@651@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@649@01)
              ($SortWrappers.IntTo$Snap $arg11@650@01))
            ($SortWrappers.IntTo$Snap $arg21@651@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@649@01)
              ($SortWrappers.IntTo$Snap $arg11@650@01))
            ($SortWrappers.IntTo$Snap $arg21@651@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@649@01)
                ($SortWrappers.IntTo$Snap $arg12@650@01))
              ($SortWrappers.IntTo$Snap $arg22@651@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@649@01)
              ($SortWrappers.IntTo$Snap $arg12@650@01))
            ($SortWrappers.IntTo$Snap $arg22@651@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@649@01)
              ($SortWrappers.IntTo$Snap $arg12@650@01))
            ($SortWrappers.IntTo$Snap $arg22@651@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@649@01)
              ($SortWrappers.IntTo$Snap $arg12@650@01))
            ($SortWrappers.IntTo$Snap $arg22@651@01)))))
      (and
        (and (= $arg01@649@01 $arg02@649@01) (= $arg11@650@01 $arg12@650@01))
        (= $arg21@651@01 $arg22@651@01)))
    (and
      (and (= $arg01@649@01 $arg02@649@01) (= $arg11@650@01 $arg12@650@01))
      (= $arg21@651@01 $arg22@651@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@649@01 Int) ($arg1@650@01 Int) ($arg2@651@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@649@01)
            ($SortWrappers.IntTo$Snap $arg1@650@01))
          ($SortWrappers.IntTo$Snap $arg2@651@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@649@01)
            ($SortWrappers.IntTo$Snap $arg1@650@01))
          ($SortWrappers.IntTo$Snap $arg2@651@01)))))
    (and
      (and
        (= (inv@655@01 $arg0@649@01 $arg1@650@01 $arg2@651@01) $arg0@649@01)
        (= (inv@657@01 $arg0@649@01 $arg1@650@01 $arg2@651@01) $arg1@650@01)
        (= (inv@659@01 $arg0@649@01 $arg1@650@01 $arg2@651@01) $arg2@651@01))
      (and
        (img@656@01 $arg0@649@01 $arg1@650@01 $arg2@651@01)
        (img@658@01 $arg0@649@01 $arg1@650@01 $arg2@651@01)
        (img@660@01 $arg0@649@01 $arg1@650@01 $arg2@651@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@649@01)
      ($SortWrappers.IntTo$Snap $arg1@650@01))
    ($SortWrappers.IntTo$Snap $arg2@651@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@649@01)
      ($SortWrappers.IntTo$Snap $arg1@650@01))
    ($SortWrappers.IntTo$Snap $arg2@651@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@656@01 $arg0 $arg1 $arg2)
        (img@658@01 $arg0 $arg1 $arg2)
        (img@660@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@655@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@657@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@659@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@655@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@657@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@659@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@655@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@657@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@659@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@655@01 $arg0 $arg1 $arg2))
  :pattern ((inv@657@01 $arg0 $arg1 $arg2))
  :pattern ((inv@659@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@655@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@657@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@659@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@655@01 $arg0 $arg1 $arg2) (inv@657@01 $arg0 $arg1 $arg2) (inv@659@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1628|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 6
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@655@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@657@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@659@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@656@01 $arg0 $arg1 $arg2)
        (img@658@01 $arg0 $arg1 $arg2)
        (img@660@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@655@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@657@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@659@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@654@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@655@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@657@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@659@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1629|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@661@01 Int)
(declare-const $arg1@662@01 Int)
(declare-const $arg2@663@01 Int)
(push) ; 6
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
(declare-const sm@664@01 $PSF<e$AddLiquidity>)
(declare-const s@665@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@666@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef37|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef38|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@661@01)
    ($SortWrappers.IntTo$Snap $arg1@662@01))
  ($SortWrappers.IntTo$Snap $arg2@663@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@661@01)
    ($SortWrappers.IntTo$Snap $arg1@662@01))
  ($SortWrappers.IntTo$Snap $arg2@663@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@661@01)
      ($SortWrappers.IntTo$Snap $arg1@662@01))
    ($SortWrappers.IntTo$Snap $arg2@663@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 6
(declare-fun inv@667@01 (Int Int Int) Int)
(declare-fun img@668@01 (Int Int Int) Bool)
(declare-fun inv@669@01 (Int Int Int) Int)
(declare-fun img@670@01 (Int Int Int) Bool)
(declare-fun inv@671@01 (Int Int Int) Int)
(declare-fun img@672@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef37|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef38|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@661@01 Int) ($arg1@662@01 Int) ($arg2@663@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@661@01)
          ($SortWrappers.IntTo$Snap $arg1@662@01))
        ($SortWrappers.IntTo$Snap $arg2@663@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@661@01)
        ($SortWrappers.IntTo$Snap $arg1@662@01))
      ($SortWrappers.IntTo$Snap $arg2@663@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@661@01)
        ($SortWrappers.IntTo$Snap $arg1@662@01))
      ($SortWrappers.IntTo$Snap $arg2@663@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@661@01)
      ($SortWrappers.IntTo$Snap $arg1@662@01))
    ($SortWrappers.IntTo$Snap $arg2@663@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@661@01)
      ($SortWrappers.IntTo$Snap $arg1@662@01))
    ($SortWrappers.IntTo$Snap $arg2@663@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 6
(assert (not (forall (($arg0@661@01 Int) ($arg1@662@01 Int) ($arg2@663@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@661@01)
          ($SortWrappers.IntTo$Snap $arg1@662@01))
        ($SortWrappers.IntTo$Snap $arg2@663@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@661@01)
            ($SortWrappers.IntTo$Snap $arg1@662@01))
          ($SortWrappers.IntTo$Snap $arg2@663@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@661@01)
            ($SortWrappers.IntTo$Snap $arg1@662@01))
          ($SortWrappers.IntTo$Snap $arg2@663@01))))))
  
  :qid |quant-u-1630|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall (($arg01@661@01 Int) ($arg11@662@01 Int) ($arg21@663@01 Int) ($arg02@661@01 Int) ($arg12@662@01 Int) ($arg22@663@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@661@01)
                ($SortWrappers.IntTo$Snap $arg11@662@01))
              ($SortWrappers.IntTo$Snap $arg21@663@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@661@01)
              ($SortWrappers.IntTo$Snap $arg11@662@01))
            ($SortWrappers.IntTo$Snap $arg21@663@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@661@01)
              ($SortWrappers.IntTo$Snap $arg11@662@01))
            ($SortWrappers.IntTo$Snap $arg21@663@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@661@01)
              ($SortWrappers.IntTo$Snap $arg11@662@01))
            ($SortWrappers.IntTo$Snap $arg21@663@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@661@01)
                ($SortWrappers.IntTo$Snap $arg12@662@01))
              ($SortWrappers.IntTo$Snap $arg22@663@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@661@01)
              ($SortWrappers.IntTo$Snap $arg12@662@01))
            ($SortWrappers.IntTo$Snap $arg22@663@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@661@01)
              ($SortWrappers.IntTo$Snap $arg12@662@01))
            ($SortWrappers.IntTo$Snap $arg22@663@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@661@01)
              ($SortWrappers.IntTo$Snap $arg12@662@01))
            ($SortWrappers.IntTo$Snap $arg22@663@01)))))
      (and
        (and (= $arg01@661@01 $arg02@661@01) (= $arg11@662@01 $arg12@662@01))
        (= $arg21@663@01 $arg22@663@01)))
    (and
      (and (= $arg01@661@01 $arg02@661@01) (= $arg11@662@01 $arg12@662@01))
      (= $arg21@663@01 $arg22@663@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@661@01 Int) ($arg1@662@01 Int) ($arg2@663@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@661@01)
            ($SortWrappers.IntTo$Snap $arg1@662@01))
          ($SortWrappers.IntTo$Snap $arg2@663@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@661@01)
            ($SortWrappers.IntTo$Snap $arg1@662@01))
          ($SortWrappers.IntTo$Snap $arg2@663@01)))))
    (and
      (and
        (= (inv@667@01 $arg0@661@01 $arg1@662@01 $arg2@663@01) $arg0@661@01)
        (= (inv@669@01 $arg0@661@01 $arg1@662@01 $arg2@663@01) $arg1@662@01)
        (= (inv@671@01 $arg0@661@01 $arg1@662@01 $arg2@663@01) $arg2@663@01))
      (and
        (img@668@01 $arg0@661@01 $arg1@662@01 $arg2@663@01)
        (img@670@01 $arg0@661@01 $arg1@662@01 $arg2@663@01)
        (img@672@01 $arg0@661@01 $arg1@662@01 $arg2@663@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@661@01)
      ($SortWrappers.IntTo$Snap $arg1@662@01))
    ($SortWrappers.IntTo$Snap $arg2@663@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@661@01)
      ($SortWrappers.IntTo$Snap $arg1@662@01))
    ($SortWrappers.IntTo$Snap $arg2@663@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@668@01 $arg0 $arg1 $arg2)
        (img@670@01 $arg0 $arg1 $arg2)
        (img@672@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@667@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@669@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@671@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@667@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@669@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@671@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@667@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@669@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@671@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@667@01 $arg0 $arg1 $arg2))
  :pattern ((inv@669@01 $arg0 $arg1 $arg2))
  :pattern ((inv@671@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@667@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@669@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@671@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@667@01 $arg0 $arg1 $arg2) (inv@669@01 $arg0 $arg1 $arg2) (inv@671@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1631|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 6
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@667@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@669@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@671@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@668@01 $arg0 $arg1 $arg2)
        (img@670@01 $arg0 $arg1 $arg2)
        (img@672@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@667@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@669@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@671@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@666@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@667@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@669@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@671@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1632|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@673@01 Int)
(declare-const $arg1@674@01 Int)
(declare-const $arg2@675@01 Int)
(push) ; 6
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
(declare-const sm@676@01 $PSF<e$RemoveLiquidity>)
(declare-const s@677@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@678@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef40|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef41|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@673@01)
    ($SortWrappers.IntTo$Snap $arg1@674@01))
  ($SortWrappers.IntTo$Snap $arg2@675@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@673@01)
    ($SortWrappers.IntTo$Snap $arg1@674@01))
  ($SortWrappers.IntTo$Snap $arg2@675@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@673@01)
      ($SortWrappers.IntTo$Snap $arg1@674@01))
    ($SortWrappers.IntTo$Snap $arg2@675@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 6
(declare-fun inv@679@01 (Int Int Int) Int)
(declare-fun img@680@01 (Int Int Int) Bool)
(declare-fun inv@681@01 (Int Int Int) Int)
(declare-fun img@682@01 (Int Int Int) Bool)
(declare-fun inv@683@01 (Int Int Int) Int)
(declare-fun img@684@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef40|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef41|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@673@01 Int) ($arg1@674@01 Int) ($arg2@675@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@673@01)
          ($SortWrappers.IntTo$Snap $arg1@674@01))
        ($SortWrappers.IntTo$Snap $arg2@675@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@673@01)
        ($SortWrappers.IntTo$Snap $arg1@674@01))
      ($SortWrappers.IntTo$Snap $arg2@675@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@673@01)
        ($SortWrappers.IntTo$Snap $arg1@674@01))
      ($SortWrappers.IntTo$Snap $arg2@675@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@673@01)
      ($SortWrappers.IntTo$Snap $arg1@674@01))
    ($SortWrappers.IntTo$Snap $arg2@675@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@673@01)
      ($SortWrappers.IntTo$Snap $arg1@674@01))
    ($SortWrappers.IntTo$Snap $arg2@675@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 6
(assert (not (forall (($arg0@673@01 Int) ($arg1@674@01 Int) ($arg2@675@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@673@01)
          ($SortWrappers.IntTo$Snap $arg1@674@01))
        ($SortWrappers.IntTo$Snap $arg2@675@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@673@01)
            ($SortWrappers.IntTo$Snap $arg1@674@01))
          ($SortWrappers.IntTo$Snap $arg2@675@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@673@01)
            ($SortWrappers.IntTo$Snap $arg1@674@01))
          ($SortWrappers.IntTo$Snap $arg2@675@01))))))
  
  :qid |quant-u-1633|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall (($arg01@673@01 Int) ($arg11@674@01 Int) ($arg21@675@01 Int) ($arg02@673@01 Int) ($arg12@674@01 Int) ($arg22@675@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@673@01)
                ($SortWrappers.IntTo$Snap $arg11@674@01))
              ($SortWrappers.IntTo$Snap $arg21@675@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@673@01)
              ($SortWrappers.IntTo$Snap $arg11@674@01))
            ($SortWrappers.IntTo$Snap $arg21@675@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@673@01)
              ($SortWrappers.IntTo$Snap $arg11@674@01))
            ($SortWrappers.IntTo$Snap $arg21@675@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@673@01)
              ($SortWrappers.IntTo$Snap $arg11@674@01))
            ($SortWrappers.IntTo$Snap $arg21@675@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@673@01)
                ($SortWrappers.IntTo$Snap $arg12@674@01))
              ($SortWrappers.IntTo$Snap $arg22@675@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@673@01)
              ($SortWrappers.IntTo$Snap $arg12@674@01))
            ($SortWrappers.IntTo$Snap $arg22@675@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@673@01)
              ($SortWrappers.IntTo$Snap $arg12@674@01))
            ($SortWrappers.IntTo$Snap $arg22@675@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@673@01)
              ($SortWrappers.IntTo$Snap $arg12@674@01))
            ($SortWrappers.IntTo$Snap $arg22@675@01)))))
      (and
        (and (= $arg01@673@01 $arg02@673@01) (= $arg11@674@01 $arg12@674@01))
        (= $arg21@675@01 $arg22@675@01)))
    (and
      (and (= $arg01@673@01 $arg02@673@01) (= $arg11@674@01 $arg12@674@01))
      (= $arg21@675@01 $arg22@675@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@673@01 Int) ($arg1@674@01 Int) ($arg2@675@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@673@01)
            ($SortWrappers.IntTo$Snap $arg1@674@01))
          ($SortWrappers.IntTo$Snap $arg2@675@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@673@01)
            ($SortWrappers.IntTo$Snap $arg1@674@01))
          ($SortWrappers.IntTo$Snap $arg2@675@01)))))
    (and
      (and
        (= (inv@679@01 $arg0@673@01 $arg1@674@01 $arg2@675@01) $arg0@673@01)
        (= (inv@681@01 $arg0@673@01 $arg1@674@01 $arg2@675@01) $arg1@674@01)
        (= (inv@683@01 $arg0@673@01 $arg1@674@01 $arg2@675@01) $arg2@675@01))
      (and
        (img@680@01 $arg0@673@01 $arg1@674@01 $arg2@675@01)
        (img@682@01 $arg0@673@01 $arg1@674@01 $arg2@675@01)
        (img@684@01 $arg0@673@01 $arg1@674@01 $arg2@675@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@673@01)
      ($SortWrappers.IntTo$Snap $arg1@674@01))
    ($SortWrappers.IntTo$Snap $arg2@675@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@673@01)
      ($SortWrappers.IntTo$Snap $arg1@674@01))
    ($SortWrappers.IntTo$Snap $arg2@675@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@680@01 $arg0 $arg1 $arg2)
        (img@682@01 $arg0 $arg1 $arg2)
        (img@684@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@679@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@681@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@683@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@679@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@681@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@683@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@679@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@681@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@683@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@679@01 $arg0 $arg1 $arg2))
  :pattern ((inv@681@01 $arg0 $arg1 $arg2))
  :pattern ((inv@683@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@679@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@681@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@683@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@679@01 $arg0 $arg1 $arg2) (inv@681@01 $arg0 $arg1 $arg2) (inv@683@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1634|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 6
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@679@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@681@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@683@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@680@01 $arg0 $arg1 $arg2)
        (img@682@01 $arg0 $arg1 $arg2)
        (img@684@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@679@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@681@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@683@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@678@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@679@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@681@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@683@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1635|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@685@01 Int)
(declare-const $arg1@686@01 Int)
(declare-const $arg2@687@01 Int)
(push) ; 6
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
(declare-const sm@688@01 $PSF<e$Transfer>)
(declare-const s@689@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@690@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef43|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef44|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@685@01)
    ($SortWrappers.IntTo$Snap $arg1@686@01))
  ($SortWrappers.IntTo$Snap $arg2@687@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@685@01)
    ($SortWrappers.IntTo$Snap $arg1@686@01))
  ($SortWrappers.IntTo$Snap $arg2@687@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@685@01)
      ($SortWrappers.IntTo$Snap $arg1@686@01))
    ($SortWrappers.IntTo$Snap $arg2@687@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 6
(declare-fun inv@691@01 (Int Int Int) Int)
(declare-fun img@692@01 (Int Int Int) Bool)
(declare-fun inv@693@01 (Int Int Int) Int)
(declare-fun img@694@01 (Int Int Int) Bool)
(declare-fun inv@695@01 (Int Int Int) Int)
(declare-fun img@696@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef43|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef44|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@685@01 Int) ($arg1@686@01 Int) ($arg2@687@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@685@01)
          ($SortWrappers.IntTo$Snap $arg1@686@01))
        ($SortWrappers.IntTo$Snap $arg2@687@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@685@01)
        ($SortWrappers.IntTo$Snap $arg1@686@01))
      ($SortWrappers.IntTo$Snap $arg2@687@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@685@01)
        ($SortWrappers.IntTo$Snap $arg1@686@01))
      ($SortWrappers.IntTo$Snap $arg2@687@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@685@01)
      ($SortWrappers.IntTo$Snap $arg1@686@01))
    ($SortWrappers.IntTo$Snap $arg2@687@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@685@01)
      ($SortWrappers.IntTo$Snap $arg1@686@01))
    ($SortWrappers.IntTo$Snap $arg2@687@01))))
  :qid |e$Transfer-aux|)))
(push) ; 6
(assert (not (forall (($arg0@685@01 Int) ($arg1@686@01 Int) ($arg2@687@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@685@01)
          ($SortWrappers.IntTo$Snap $arg1@686@01))
        ($SortWrappers.IntTo$Snap $arg2@687@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@685@01)
            ($SortWrappers.IntTo$Snap $arg1@686@01))
          ($SortWrappers.IntTo$Snap $arg2@687@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@685@01)
            ($SortWrappers.IntTo$Snap $arg1@686@01))
          ($SortWrappers.IntTo$Snap $arg2@687@01))))))
  
  :qid |quant-u-1636|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall (($arg01@685@01 Int) ($arg11@686@01 Int) ($arg21@687@01 Int) ($arg02@685@01 Int) ($arg12@686@01 Int) ($arg22@687@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@685@01)
                ($SortWrappers.IntTo$Snap $arg11@686@01))
              ($SortWrappers.IntTo$Snap $arg21@687@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@685@01)
              ($SortWrappers.IntTo$Snap $arg11@686@01))
            ($SortWrappers.IntTo$Snap $arg21@687@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@685@01)
              ($SortWrappers.IntTo$Snap $arg11@686@01))
            ($SortWrappers.IntTo$Snap $arg21@687@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@685@01)
              ($SortWrappers.IntTo$Snap $arg11@686@01))
            ($SortWrappers.IntTo$Snap $arg21@687@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@685@01)
                ($SortWrappers.IntTo$Snap $arg12@686@01))
              ($SortWrappers.IntTo$Snap $arg22@687@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@685@01)
              ($SortWrappers.IntTo$Snap $arg12@686@01))
            ($SortWrappers.IntTo$Snap $arg22@687@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@685@01)
              ($SortWrappers.IntTo$Snap $arg12@686@01))
            ($SortWrappers.IntTo$Snap $arg22@687@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@685@01)
              ($SortWrappers.IntTo$Snap $arg12@686@01))
            ($SortWrappers.IntTo$Snap $arg22@687@01)))))
      (and
        (and (= $arg01@685@01 $arg02@685@01) (= $arg11@686@01 $arg12@686@01))
        (= $arg21@687@01 $arg22@687@01)))
    (and
      (and (= $arg01@685@01 $arg02@685@01) (= $arg11@686@01 $arg12@686@01))
      (= $arg21@687@01 $arg22@687@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@685@01 Int) ($arg1@686@01 Int) ($arg2@687@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@685@01)
            ($SortWrappers.IntTo$Snap $arg1@686@01))
          ($SortWrappers.IntTo$Snap $arg2@687@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@685@01)
            ($SortWrappers.IntTo$Snap $arg1@686@01))
          ($SortWrappers.IntTo$Snap $arg2@687@01)))))
    (and
      (and
        (= (inv@691@01 $arg0@685@01 $arg1@686@01 $arg2@687@01) $arg0@685@01)
        (= (inv@693@01 $arg0@685@01 $arg1@686@01 $arg2@687@01) $arg1@686@01)
        (= (inv@695@01 $arg0@685@01 $arg1@686@01 $arg2@687@01) $arg2@687@01))
      (and
        (img@692@01 $arg0@685@01 $arg1@686@01 $arg2@687@01)
        (img@694@01 $arg0@685@01 $arg1@686@01 $arg2@687@01)
        (img@696@01 $arg0@685@01 $arg1@686@01 $arg2@687@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@685@01)
      ($SortWrappers.IntTo$Snap $arg1@686@01))
    ($SortWrappers.IntTo$Snap $arg2@687@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@685@01)
      ($SortWrappers.IntTo$Snap $arg1@686@01))
    ($SortWrappers.IntTo$Snap $arg2@687@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@692@01 $arg0 $arg1 $arg2)
        (img@694@01 $arg0 $arg1 $arg2)
        (img@696@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@691@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@693@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@695@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@691@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@693@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@695@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@691@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@693@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@695@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@691@01 $arg0 $arg1 $arg2))
  :pattern ((inv@693@01 $arg0 $arg1 $arg2))
  :pattern ((inv@695@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@691@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@693@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@695@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@691@01 $arg0 $arg1 $arg2) (inv@693@01 $arg0 $arg1 $arg2) (inv@695@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1637|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 6
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@691@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@693@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@695@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@692@01 $arg0 $arg1 $arg2)
        (img@694@01 $arg0 $arg1 $arg2)
        (img@696@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@691@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@693@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@695@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@690@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@691@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@693@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@695@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1638|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@697@01 Int)
(declare-const $arg1@698@01 Int)
(declare-const $arg2@699@01 Int)
(push) ; 6
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
(declare-const sm@700@01 $PSF<e$Approval>)
(declare-const s@701@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@702@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef46|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef47|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@697@01)
    ($SortWrappers.IntTo$Snap $arg1@698@01))
  ($SortWrappers.IntTo$Snap $arg2@699@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@697@01)
    ($SortWrappers.IntTo$Snap $arg1@698@01))
  ($SortWrappers.IntTo$Snap $arg2@699@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@697@01)
      ($SortWrappers.IntTo$Snap $arg1@698@01))
    ($SortWrappers.IntTo$Snap $arg2@699@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 6
(declare-fun inv@703@01 (Int Int Int) Int)
(declare-fun img@704@01 (Int Int Int) Bool)
(declare-fun inv@705@01 (Int Int Int) Int)
(declare-fun img@706@01 (Int Int Int) Bool)
(declare-fun inv@707@01 (Int Int Int) Int)
(declare-fun img@708@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef46|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef47|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@697@01 Int) ($arg1@698@01 Int) ($arg2@699@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@697@01)
          ($SortWrappers.IntTo$Snap $arg1@698@01))
        ($SortWrappers.IntTo$Snap $arg2@699@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@697@01)
        ($SortWrappers.IntTo$Snap $arg1@698@01))
      ($SortWrappers.IntTo$Snap $arg2@699@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@697@01)
        ($SortWrappers.IntTo$Snap $arg1@698@01))
      ($SortWrappers.IntTo$Snap $arg2@699@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@697@01)
      ($SortWrappers.IntTo$Snap $arg1@698@01))
    ($SortWrappers.IntTo$Snap $arg2@699@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@697@01)
      ($SortWrappers.IntTo$Snap $arg1@698@01))
    ($SortWrappers.IntTo$Snap $arg2@699@01))))
  :qid |e$Approval-aux|)))
(push) ; 6
(assert (not (forall (($arg0@697@01 Int) ($arg1@698@01 Int) ($arg2@699@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@697@01)
          ($SortWrappers.IntTo$Snap $arg1@698@01))
        ($SortWrappers.IntTo$Snap $arg2@699@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@697@01)
            ($SortWrappers.IntTo$Snap $arg1@698@01))
          ($SortWrappers.IntTo$Snap $arg2@699@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@697@01)
            ($SortWrappers.IntTo$Snap $arg1@698@01))
          ($SortWrappers.IntTo$Snap $arg2@699@01))))))
  
  :qid |quant-u-1639|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall (($arg01@697@01 Int) ($arg11@698@01 Int) ($arg21@699@01 Int) ($arg02@697@01 Int) ($arg12@698@01 Int) ($arg22@699@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@697@01)
                ($SortWrappers.IntTo$Snap $arg11@698@01))
              ($SortWrappers.IntTo$Snap $arg21@699@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@697@01)
              ($SortWrappers.IntTo$Snap $arg11@698@01))
            ($SortWrappers.IntTo$Snap $arg21@699@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@697@01)
              ($SortWrappers.IntTo$Snap $arg11@698@01))
            ($SortWrappers.IntTo$Snap $arg21@699@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@697@01)
              ($SortWrappers.IntTo$Snap $arg11@698@01))
            ($SortWrappers.IntTo$Snap $arg21@699@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@697@01)
                ($SortWrappers.IntTo$Snap $arg12@698@01))
              ($SortWrappers.IntTo$Snap $arg22@699@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@697@01)
              ($SortWrappers.IntTo$Snap $arg12@698@01))
            ($SortWrappers.IntTo$Snap $arg22@699@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@697@01)
              ($SortWrappers.IntTo$Snap $arg12@698@01))
            ($SortWrappers.IntTo$Snap $arg22@699@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@697@01)
              ($SortWrappers.IntTo$Snap $arg12@698@01))
            ($SortWrappers.IntTo$Snap $arg22@699@01)))))
      (and
        (and (= $arg01@697@01 $arg02@697@01) (= $arg11@698@01 $arg12@698@01))
        (= $arg21@699@01 $arg22@699@01)))
    (and
      (and (= $arg01@697@01 $arg02@697@01) (= $arg11@698@01 $arg12@698@01))
      (= $arg21@699@01 $arg22@699@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@697@01 Int) ($arg1@698@01 Int) ($arg2@699@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@697@01)
            ($SortWrappers.IntTo$Snap $arg1@698@01))
          ($SortWrappers.IntTo$Snap $arg2@699@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@697@01)
            ($SortWrappers.IntTo$Snap $arg1@698@01))
          ($SortWrappers.IntTo$Snap $arg2@699@01)))))
    (and
      (and
        (= (inv@703@01 $arg0@697@01 $arg1@698@01 $arg2@699@01) $arg0@697@01)
        (= (inv@705@01 $arg0@697@01 $arg1@698@01 $arg2@699@01) $arg1@698@01)
        (= (inv@707@01 $arg0@697@01 $arg1@698@01 $arg2@699@01) $arg2@699@01))
      (and
        (img@704@01 $arg0@697@01 $arg1@698@01 $arg2@699@01)
        (img@706@01 $arg0@697@01 $arg1@698@01 $arg2@699@01)
        (img@708@01 $arg0@697@01 $arg1@698@01 $arg2@699@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@697@01)
      ($SortWrappers.IntTo$Snap $arg1@698@01))
    ($SortWrappers.IntTo$Snap $arg2@699@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@697@01)
      ($SortWrappers.IntTo$Snap $arg1@698@01))
    ($SortWrappers.IntTo$Snap $arg2@699@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@704@01 $arg0 $arg1 $arg2)
        (img@706@01 $arg0 $arg1 $arg2)
        (img@708@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@703@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@705@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@707@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@703@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@705@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@707@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@703@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@705@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@707@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@703@01 $arg0 $arg1 $arg2))
  :pattern ((inv@705@01 $arg0 $arg1 $arg2))
  :pattern ((inv@707@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@703@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@705@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@707@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@703@01 $arg0 $arg1 $arg2) (inv@705@01 $arg0 $arg1 $arg2) (inv@707@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1640|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 6
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@703@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@705@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@707@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@704@01 $arg0 $arg1 $arg2)
        (img@706@01 $arg0 $arg1 $arg2)
        (img@708@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@703@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@705@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@707@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@702@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@703@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@705@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@707@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1641|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; inhale 0 <= l$raw_ret$2 &&
;   l$raw_ret$2 <= 1461501637330902918203684832716283019655932542975
(declare-const $t@709@01 $Snap)
(assert (= $t@709@01 ($Snap.combine ($Snap.first $t@709@01) ($Snap.second $t@709@01))))
(assert (= ($Snap.first $t@709@01) $Snap.unit))
; [eval] 0 <= l$raw_ret$2
(assert (<= 0 l$raw_ret$2@356@01))
(assert (= ($Snap.second $t@709@01) $Snap.unit))
; [eval] l$raw_ret$2 <= 1461501637330902918203684832716283019655932542975
(assert (<= l$raw_ret$2@356@01 1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not l$send_fail$2@355@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not l$send_fail$2@355@01))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 174 | l$send_fail$2@355@01 | live]
; [else-branch: 174 | !(l$send_fail$2@355@01) | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 174 | l$send_fail$2@355@01]
(assert l$send_fail$2@355@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 7)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(declare-const $t@710@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 175 | True | live]
; [else-branch: 175 | False | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 175 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@711@01 $Snap)
(assert (= $t@711@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@712@01 $Struct)
(assert (=
  self@712@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 7
; [then-branch: 176 | False | dead]
; [else-branch: 176 | True | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 176 | True]
(pop) ; 7
(pop) ; 6
(push) ; 6
; [else-branch: 174 | !(l$send_fail$2@355@01)]
(assert (not l$send_fail$2@355@01))
(pop) ; 6
; [eval] !l$send_fail$2
(push) ; 6
(set-option :timeout 10)
(assert (not l$send_fail$2@355@01))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not l$send_fail$2@355@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 177 | !(l$send_fail$2@355@01) | live]
; [else-branch: 177 | l$send_fail$2@355@01 | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 177 | !(l$send_fail$2@355@01)]
(assert (not l$send_fail$2@355@01))
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !(l$raw_ret$2 == $self_address())
; [eval] l$raw_ret$2 == $self_address()
; [eval] $self_address()
(push) ; 7
(set-option :timeout 10)
(assert (not (= l$raw_ret$2@356@01 (as $self_address<Int>  Int))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not (= l$raw_ret$2@356@01 (as $self_address<Int>  Int)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 178 | l$raw_ret$2@356@01 != $self_address[Int] | live]
; [else-branch: 178 | l$raw_ret$2@356@01 == $self_address[Int] | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 178 | l$raw_ret$2@356@01 != $self_address[Int]]
(assert (not (= l$raw_ret$2@356@01 (as $self_address<Int>  Int))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 8
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 179 | True | live]
; [else-branch: 179 | False | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 179 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@713@01 $Snap)
(assert (= $t@713@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@714@01 $Struct)
(assert (=
  self@714@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 8
; [then-branch: 180 | False | dead]
; [else-branch: 180 | True | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 180 | True]
(pop) ; 8
(pop) ; 7
(push) ; 7
; [else-branch: 178 | l$raw_ret$2@356@01 == $self_address[Int]]
(assert (= l$raw_ret$2@356@01 (as $self_address<Int>  Int)))
(pop) ; 7
; [eval] !!(l$raw_ret$2 == $self_address())
; [eval] !(l$raw_ret$2 == $self_address())
; [eval] l$raw_ret$2 == $self_address()
; [eval] $self_address()
(push) ; 7
(set-option :timeout 10)
(assert (not (not (= l$raw_ret$2@356@01 (as $self_address<Int>  Int)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= l$raw_ret$2@356@01 (as $self_address<Int>  Int))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 181 | l$raw_ret$2@356@01 == $self_address[Int] | live]
; [else-branch: 181 | l$raw_ret$2@356@01 != $self_address[Int] | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 181 | l$raw_ret$2@356@01 == $self_address[Int]]
(assert (= l$raw_ret$2@356@01 (as $self_address<Int>  Int)))
; [exec]
; l$token_amount$1 := l$max_tokens
; [exec]
; l$initial_liquidity := $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const l$initial_liquidity@715@01 $Int)
(assert (=
  l$initial_liquidity@715@01
  ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@419@01 8)))))
; [exec]
; self := ($struct_set(self, 3, $unwrap(l$initial_liquidity)): $Struct)
; [eval] ($struct_set(self, 3, $unwrap(l$initial_liquidity)): $Struct)
; [eval] $unwrap(l$initial_liquidity)
(declare-const self@716@01 $Struct)
(assert (=
  self@716@01
  ($struct_set<$Struct> self@419@01 3 ($unwrap<Int> l$initial_liquidity@715@01))))
; [exec]
; self := ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]),
;   ($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$initial_liquidity)): $Map[Int, Int])): $Struct)
; [eval] ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$initial_liquidity)): $Map[Int, Int])): $Struct)
; [eval] ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$initial_liquidity)): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$initial_liquidity)
(declare-const self@717@01 $Struct)
(assert (=
  self@717@01
  ($struct_set<$Struct> self@716@01 4 ($map_set<$Map<Int~_Int>> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@716@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)) ($unwrap<Int> l$initial_liquidity@715@01)))))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@718@01 Int)
(declare-const $arg1@719@01 Int)
(declare-const $arg2@720@01 Int)
(push) ; 8
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@721@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef48|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef49|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@718@01)
    ($SortWrappers.IntTo$Snap $arg1@719@01))
  ($SortWrappers.IntTo$Snap $arg2@720@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@718@01)
    ($SortWrappers.IntTo$Snap $arg1@719@01))
  ($SortWrappers.IntTo$Snap $arg2@720@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@718@01)
      ($SortWrappers.IntTo$Snap $arg1@719@01))
    ($SortWrappers.IntTo$Snap $arg2@720@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@722@01 (Int Int Int) Int)
(declare-fun img@723@01 (Int Int Int) Bool)
(declare-fun inv@724@01 (Int Int Int) Int)
(declare-fun img@725@01 (Int Int Int) Bool)
(declare-fun inv@726@01 (Int Int Int) Int)
(declare-fun img@727@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef48|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef49|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@718@01 Int) ($arg1@719@01 Int) ($arg2@720@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@718@01)
          ($SortWrappers.IntTo$Snap $arg1@719@01))
        ($SortWrappers.IntTo$Snap $arg2@720@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@718@01)
        ($SortWrappers.IntTo$Snap $arg1@719@01))
      ($SortWrappers.IntTo$Snap $arg2@720@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@718@01)
        ($SortWrappers.IntTo$Snap $arg1@719@01))
      ($SortWrappers.IntTo$Snap $arg2@720@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@718@01)
      ($SortWrappers.IntTo$Snap $arg1@719@01))
    ($SortWrappers.IntTo$Snap $arg2@720@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@718@01)
      ($SortWrappers.IntTo$Snap $arg1@719@01))
    ($SortWrappers.IntTo$Snap $arg2@720@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 8
(assert (not (forall (($arg0@718@01 Int) ($arg1@719@01 Int) ($arg2@720@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@718@01)
          ($SortWrappers.IntTo$Snap $arg1@719@01))
        ($SortWrappers.IntTo$Snap $arg2@720@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@718@01)
            ($SortWrappers.IntTo$Snap $arg1@719@01))
          ($SortWrappers.IntTo$Snap $arg2@720@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@718@01)
            ($SortWrappers.IntTo$Snap $arg1@719@01))
          ($SortWrappers.IntTo$Snap $arg2@720@01))))))
  
  :qid |quant-u-1649|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@718@01 Int) ($arg11@719@01 Int) ($arg21@720@01 Int) ($arg02@718@01 Int) ($arg12@719@01 Int) ($arg22@720@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@718@01)
                ($SortWrappers.IntTo$Snap $arg11@719@01))
              ($SortWrappers.IntTo$Snap $arg21@720@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@718@01)
              ($SortWrappers.IntTo$Snap $arg11@719@01))
            ($SortWrappers.IntTo$Snap $arg21@720@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@718@01)
              ($SortWrappers.IntTo$Snap $arg11@719@01))
            ($SortWrappers.IntTo$Snap $arg21@720@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@718@01)
              ($SortWrappers.IntTo$Snap $arg11@719@01))
            ($SortWrappers.IntTo$Snap $arg21@720@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@718@01)
                ($SortWrappers.IntTo$Snap $arg12@719@01))
              ($SortWrappers.IntTo$Snap $arg22@720@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@718@01)
              ($SortWrappers.IntTo$Snap $arg12@719@01))
            ($SortWrappers.IntTo$Snap $arg22@720@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@718@01)
              ($SortWrappers.IntTo$Snap $arg12@719@01))
            ($SortWrappers.IntTo$Snap $arg22@720@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@718@01)
              ($SortWrappers.IntTo$Snap $arg12@719@01))
            ($SortWrappers.IntTo$Snap $arg22@720@01)))))
      (and
        (and (= $arg01@718@01 $arg02@718@01) (= $arg11@719@01 $arg12@719@01))
        (= $arg21@720@01 $arg22@720@01)))
    (and
      (and (= $arg01@718@01 $arg02@718@01) (= $arg11@719@01 $arg12@719@01))
      (= $arg21@720@01 $arg22@720@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@718@01 Int) ($arg1@719@01 Int) ($arg2@720@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@718@01)
            ($SortWrappers.IntTo$Snap $arg1@719@01))
          ($SortWrappers.IntTo$Snap $arg2@720@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@718@01)
            ($SortWrappers.IntTo$Snap $arg1@719@01))
          ($SortWrappers.IntTo$Snap $arg2@720@01)))))
    (and
      (and
        (= (inv@722@01 $arg0@718@01 $arg1@719@01 $arg2@720@01) $arg0@718@01)
        (= (inv@724@01 $arg0@718@01 $arg1@719@01 $arg2@720@01) $arg1@719@01)
        (= (inv@726@01 $arg0@718@01 $arg1@719@01 $arg2@720@01) $arg2@720@01))
      (and
        (img@723@01 $arg0@718@01 $arg1@719@01 $arg2@720@01)
        (img@725@01 $arg0@718@01 $arg1@719@01 $arg2@720@01)
        (img@727@01 $arg0@718@01 $arg1@719@01 $arg2@720@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@718@01)
      ($SortWrappers.IntTo$Snap $arg1@719@01))
    ($SortWrappers.IntTo$Snap $arg2@720@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@718@01)
      ($SortWrappers.IntTo$Snap $arg1@719@01))
    ($SortWrappers.IntTo$Snap $arg2@720@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@723@01 $arg0 $arg1 $arg2)
        (img@725@01 $arg0 $arg1 $arg2)
        (img@727@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@722@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@724@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@726@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@722@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@724@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@726@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@722@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@724@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@726@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@722@01 $arg0 $arg1 $arg2))
  :pattern ((inv@724@01 $arg0 $arg1 $arg2))
  :pattern ((inv@726@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@722@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@724@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@726@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@640@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@722@01 $arg0 $arg1 $arg2) (inv@724@01 $arg0 $arg1 $arg2) (inv@726@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1650|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@722@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@724@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@726@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@723@01 $arg0 $arg1 $arg2)
        (img@725@01 $arg0 $arg1 $arg2)
        (img@727@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@722@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@724@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@726@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@721@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@722@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@724@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@726@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1651|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@728@01 Int)
(declare-const $arg1@729@01 Int)
(declare-const $arg2@730@01 Int)
(push) ; 8
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@731@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef50|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef51|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@728@01)
    ($SortWrappers.IntTo$Snap $arg1@729@01))
  ($SortWrappers.IntTo$Snap $arg2@730@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@728@01)
    ($SortWrappers.IntTo$Snap $arg1@729@01))
  ($SortWrappers.IntTo$Snap $arg2@730@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@728@01)
      ($SortWrappers.IntTo$Snap $arg1@729@01))
    ($SortWrappers.IntTo$Snap $arg2@730@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@732@01 (Int Int Int) Int)
(declare-fun img@733@01 (Int Int Int) Bool)
(declare-fun inv@734@01 (Int Int Int) Int)
(declare-fun img@735@01 (Int Int Int) Bool)
(declare-fun inv@736@01 (Int Int Int) Int)
(declare-fun img@737@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef50|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef51|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@728@01 Int) ($arg1@729@01 Int) ($arg2@730@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@728@01)
          ($SortWrappers.IntTo$Snap $arg1@729@01))
        ($SortWrappers.IntTo$Snap $arg2@730@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@728@01)
        ($SortWrappers.IntTo$Snap $arg1@729@01))
      ($SortWrappers.IntTo$Snap $arg2@730@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@728@01)
        ($SortWrappers.IntTo$Snap $arg1@729@01))
      ($SortWrappers.IntTo$Snap $arg2@730@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@728@01)
      ($SortWrappers.IntTo$Snap $arg1@729@01))
    ($SortWrappers.IntTo$Snap $arg2@730@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@728@01)
      ($SortWrappers.IntTo$Snap $arg1@729@01))
    ($SortWrappers.IntTo$Snap $arg2@730@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 8
(assert (not (forall (($arg0@728@01 Int) ($arg1@729@01 Int) ($arg2@730@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@728@01)
          ($SortWrappers.IntTo$Snap $arg1@729@01))
        ($SortWrappers.IntTo$Snap $arg2@730@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@728@01)
            ($SortWrappers.IntTo$Snap $arg1@729@01))
          ($SortWrappers.IntTo$Snap $arg2@730@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@728@01)
            ($SortWrappers.IntTo$Snap $arg1@729@01))
          ($SortWrappers.IntTo$Snap $arg2@730@01))))))
  
  :qid |quant-u-1653|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@728@01 Int) ($arg11@729@01 Int) ($arg21@730@01 Int) ($arg02@728@01 Int) ($arg12@729@01 Int) ($arg22@730@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@728@01)
                ($SortWrappers.IntTo$Snap $arg11@729@01))
              ($SortWrappers.IntTo$Snap $arg21@730@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@728@01)
              ($SortWrappers.IntTo$Snap $arg11@729@01))
            ($SortWrappers.IntTo$Snap $arg21@730@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@728@01)
              ($SortWrappers.IntTo$Snap $arg11@729@01))
            ($SortWrappers.IntTo$Snap $arg21@730@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@728@01)
              ($SortWrappers.IntTo$Snap $arg11@729@01))
            ($SortWrappers.IntTo$Snap $arg21@730@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@728@01)
                ($SortWrappers.IntTo$Snap $arg12@729@01))
              ($SortWrappers.IntTo$Snap $arg22@730@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@728@01)
              ($SortWrappers.IntTo$Snap $arg12@729@01))
            ($SortWrappers.IntTo$Snap $arg22@730@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@728@01)
              ($SortWrappers.IntTo$Snap $arg12@729@01))
            ($SortWrappers.IntTo$Snap $arg22@730@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@728@01)
              ($SortWrappers.IntTo$Snap $arg12@729@01))
            ($SortWrappers.IntTo$Snap $arg22@730@01)))))
      (and
        (and (= $arg01@728@01 $arg02@728@01) (= $arg11@729@01 $arg12@729@01))
        (= $arg21@730@01 $arg22@730@01)))
    (and
      (and (= $arg01@728@01 $arg02@728@01) (= $arg11@729@01 $arg12@729@01))
      (= $arg21@730@01 $arg22@730@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@728@01 Int) ($arg1@729@01 Int) ($arg2@730@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@728@01)
            ($SortWrappers.IntTo$Snap $arg1@729@01))
          ($SortWrappers.IntTo$Snap $arg2@730@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@728@01)
            ($SortWrappers.IntTo$Snap $arg1@729@01))
          ($SortWrappers.IntTo$Snap $arg2@730@01)))))
    (and
      (and
        (= (inv@732@01 $arg0@728@01 $arg1@729@01 $arg2@730@01) $arg0@728@01)
        (= (inv@734@01 $arg0@728@01 $arg1@729@01 $arg2@730@01) $arg1@729@01)
        (= (inv@736@01 $arg0@728@01 $arg1@729@01 $arg2@730@01) $arg2@730@01))
      (and
        (img@733@01 $arg0@728@01 $arg1@729@01 $arg2@730@01)
        (img@735@01 $arg0@728@01 $arg1@729@01 $arg2@730@01)
        (img@737@01 $arg0@728@01 $arg1@729@01 $arg2@730@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@728@01)
      ($SortWrappers.IntTo$Snap $arg1@729@01))
    ($SortWrappers.IntTo$Snap $arg2@730@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@728@01)
      ($SortWrappers.IntTo$Snap $arg1@729@01))
    ($SortWrappers.IntTo$Snap $arg2@730@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@733@01 $arg0 $arg1 $arg2)
        (img@735@01 $arg0 $arg1 $arg2)
        (img@737@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@732@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@734@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@736@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@732@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@734@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@736@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@732@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@734@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@736@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@732@01 $arg0 $arg1 $arg2))
  :pattern ((inv@734@01 $arg0 $arg1 $arg2))
  :pattern ((inv@736@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@732@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@734@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@736@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@652@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@732@01 $arg0 $arg1 $arg2) (inv@734@01 $arg0 $arg1 $arg2) (inv@736@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1655|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@732@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@734@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@736@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@733@01 $arg0 $arg1 $arg2)
        (img@735@01 $arg0 $arg1 $arg2)
        (img@737@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@732@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@734@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@736@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@731@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@732@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@734@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@736@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1656|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@738@01 Int)
(declare-const $arg1@739@01 Int)
(declare-const $arg2@740@01 Int)
(push) ; 8
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@741@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef52|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef53|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@738@01)
    ($SortWrappers.IntTo$Snap $arg1@739@01))
  ($SortWrappers.IntTo$Snap $arg2@740@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@738@01)
    ($SortWrappers.IntTo$Snap $arg1@739@01))
  ($SortWrappers.IntTo$Snap $arg2@740@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@738@01)
      ($SortWrappers.IntTo$Snap $arg1@739@01))
    ($SortWrappers.IntTo$Snap $arg2@740@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@742@01 (Int Int Int) Int)
(declare-fun img@743@01 (Int Int Int) Bool)
(declare-fun inv@744@01 (Int Int Int) Int)
(declare-fun img@745@01 (Int Int Int) Bool)
(declare-fun inv@746@01 (Int Int Int) Int)
(declare-fun img@747@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef52|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef53|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@738@01 Int) ($arg1@739@01 Int) ($arg2@740@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@738@01)
          ($SortWrappers.IntTo$Snap $arg1@739@01))
        ($SortWrappers.IntTo$Snap $arg2@740@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@738@01)
        ($SortWrappers.IntTo$Snap $arg1@739@01))
      ($SortWrappers.IntTo$Snap $arg2@740@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@738@01)
        ($SortWrappers.IntTo$Snap $arg1@739@01))
      ($SortWrappers.IntTo$Snap $arg2@740@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@738@01)
      ($SortWrappers.IntTo$Snap $arg1@739@01))
    ($SortWrappers.IntTo$Snap $arg2@740@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@738@01)
      ($SortWrappers.IntTo$Snap $arg1@739@01))
    ($SortWrappers.IntTo$Snap $arg2@740@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 8
(assert (not (forall (($arg0@738@01 Int) ($arg1@739@01 Int) ($arg2@740@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@738@01)
          ($SortWrappers.IntTo$Snap $arg1@739@01))
        ($SortWrappers.IntTo$Snap $arg2@740@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@738@01)
            ($SortWrappers.IntTo$Snap $arg1@739@01))
          ($SortWrappers.IntTo$Snap $arg2@740@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@738@01)
            ($SortWrappers.IntTo$Snap $arg1@739@01))
          ($SortWrappers.IntTo$Snap $arg2@740@01))))))
  
  :qid |quant-u-1657|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@738@01 Int) ($arg11@739@01 Int) ($arg21@740@01 Int) ($arg02@738@01 Int) ($arg12@739@01 Int) ($arg22@740@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@738@01)
                ($SortWrappers.IntTo$Snap $arg11@739@01))
              ($SortWrappers.IntTo$Snap $arg21@740@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@738@01)
              ($SortWrappers.IntTo$Snap $arg11@739@01))
            ($SortWrappers.IntTo$Snap $arg21@740@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@738@01)
              ($SortWrappers.IntTo$Snap $arg11@739@01))
            ($SortWrappers.IntTo$Snap $arg21@740@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@738@01)
              ($SortWrappers.IntTo$Snap $arg11@739@01))
            ($SortWrappers.IntTo$Snap $arg21@740@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@738@01)
                ($SortWrappers.IntTo$Snap $arg12@739@01))
              ($SortWrappers.IntTo$Snap $arg22@740@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@738@01)
              ($SortWrappers.IntTo$Snap $arg12@739@01))
            ($SortWrappers.IntTo$Snap $arg22@740@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@738@01)
              ($SortWrappers.IntTo$Snap $arg12@739@01))
            ($SortWrappers.IntTo$Snap $arg22@740@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@738@01)
              ($SortWrappers.IntTo$Snap $arg12@739@01))
            ($SortWrappers.IntTo$Snap $arg22@740@01)))))
      (and
        (and (= $arg01@738@01 $arg02@738@01) (= $arg11@739@01 $arg12@739@01))
        (= $arg21@740@01 $arg22@740@01)))
    (and
      (and (= $arg01@738@01 $arg02@738@01) (= $arg11@739@01 $arg12@739@01))
      (= $arg21@740@01 $arg22@740@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@738@01 Int) ($arg1@739@01 Int) ($arg2@740@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@738@01)
            ($SortWrappers.IntTo$Snap $arg1@739@01))
          ($SortWrappers.IntTo$Snap $arg2@740@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@738@01)
            ($SortWrappers.IntTo$Snap $arg1@739@01))
          ($SortWrappers.IntTo$Snap $arg2@740@01)))))
    (and
      (and
        (= (inv@742@01 $arg0@738@01 $arg1@739@01 $arg2@740@01) $arg0@738@01)
        (= (inv@744@01 $arg0@738@01 $arg1@739@01 $arg2@740@01) $arg1@739@01)
        (= (inv@746@01 $arg0@738@01 $arg1@739@01 $arg2@740@01) $arg2@740@01))
      (and
        (img@743@01 $arg0@738@01 $arg1@739@01 $arg2@740@01)
        (img@745@01 $arg0@738@01 $arg1@739@01 $arg2@740@01)
        (img@747@01 $arg0@738@01 $arg1@739@01 $arg2@740@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@738@01)
      ($SortWrappers.IntTo$Snap $arg1@739@01))
    ($SortWrappers.IntTo$Snap $arg2@740@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@738@01)
      ($SortWrappers.IntTo$Snap $arg1@739@01))
    ($SortWrappers.IntTo$Snap $arg2@740@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@743@01 $arg0 $arg1 $arg2)
        (img@745@01 $arg0 $arg1 $arg2)
        (img@747@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@742@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@744@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@746@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@742@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@744@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@746@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@742@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@744@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@746@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@742@01 $arg0 $arg1 $arg2))
  :pattern ((inv@744@01 $arg0 $arg1 $arg2))
  :pattern ((inv@746@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@742@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@744@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@746@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@742@01 $arg0 $arg1 $arg2) (inv@744@01 $arg0 $arg1 $arg2) (inv@746@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1658|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@742@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@744@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@746@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@743@01 $arg0 $arg1 $arg2)
        (img@745@01 $arg0 $arg1 $arg2)
        (img@747@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@742@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@744@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@746@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@741@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@742@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@744@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@746@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1659|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@748@01 Int)
(declare-const $arg1@749@01 Int)
(declare-const $arg2@750@01 Int)
(push) ; 8
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@751@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef54|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef55|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@748@01)
    ($SortWrappers.IntTo$Snap $arg1@749@01))
  ($SortWrappers.IntTo$Snap $arg2@750@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@748@01)
    ($SortWrappers.IntTo$Snap $arg1@749@01))
  ($SortWrappers.IntTo$Snap $arg2@750@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@748@01)
      ($SortWrappers.IntTo$Snap $arg1@749@01))
    ($SortWrappers.IntTo$Snap $arg2@750@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@752@01 (Int Int Int) Int)
(declare-fun img@753@01 (Int Int Int) Bool)
(declare-fun inv@754@01 (Int Int Int) Int)
(declare-fun img@755@01 (Int Int Int) Bool)
(declare-fun inv@756@01 (Int Int Int) Int)
(declare-fun img@757@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef54|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef55|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@748@01 Int) ($arg1@749@01 Int) ($arg2@750@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@748@01)
          ($SortWrappers.IntTo$Snap $arg1@749@01))
        ($SortWrappers.IntTo$Snap $arg2@750@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@748@01)
        ($SortWrappers.IntTo$Snap $arg1@749@01))
      ($SortWrappers.IntTo$Snap $arg2@750@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@748@01)
        ($SortWrappers.IntTo$Snap $arg1@749@01))
      ($SortWrappers.IntTo$Snap $arg2@750@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@748@01)
      ($SortWrappers.IntTo$Snap $arg1@749@01))
    ($SortWrappers.IntTo$Snap $arg2@750@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@748@01)
      ($SortWrappers.IntTo$Snap $arg1@749@01))
    ($SortWrappers.IntTo$Snap $arg2@750@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 8
(assert (not (forall (($arg0@748@01 Int) ($arg1@749@01 Int) ($arg2@750@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@748@01)
          ($SortWrappers.IntTo$Snap $arg1@749@01))
        ($SortWrappers.IntTo$Snap $arg2@750@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@748@01)
            ($SortWrappers.IntTo$Snap $arg1@749@01))
          ($SortWrappers.IntTo$Snap $arg2@750@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@748@01)
            ($SortWrappers.IntTo$Snap $arg1@749@01))
          ($SortWrappers.IntTo$Snap $arg2@750@01))))))
  
  :qid |quant-u-1660|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@748@01 Int) ($arg11@749@01 Int) ($arg21@750@01 Int) ($arg02@748@01 Int) ($arg12@749@01 Int) ($arg22@750@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@748@01)
                ($SortWrappers.IntTo$Snap $arg11@749@01))
              ($SortWrappers.IntTo$Snap $arg21@750@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@748@01)
              ($SortWrappers.IntTo$Snap $arg11@749@01))
            ($SortWrappers.IntTo$Snap $arg21@750@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@748@01)
              ($SortWrappers.IntTo$Snap $arg11@749@01))
            ($SortWrappers.IntTo$Snap $arg21@750@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@748@01)
              ($SortWrappers.IntTo$Snap $arg11@749@01))
            ($SortWrappers.IntTo$Snap $arg21@750@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@748@01)
                ($SortWrappers.IntTo$Snap $arg12@749@01))
              ($SortWrappers.IntTo$Snap $arg22@750@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@748@01)
              ($SortWrappers.IntTo$Snap $arg12@749@01))
            ($SortWrappers.IntTo$Snap $arg22@750@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@748@01)
              ($SortWrappers.IntTo$Snap $arg12@749@01))
            ($SortWrappers.IntTo$Snap $arg22@750@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@748@01)
              ($SortWrappers.IntTo$Snap $arg12@749@01))
            ($SortWrappers.IntTo$Snap $arg22@750@01)))))
      (and
        (and (= $arg01@748@01 $arg02@748@01) (= $arg11@749@01 $arg12@749@01))
        (= $arg21@750@01 $arg22@750@01)))
    (and
      (and (= $arg01@748@01 $arg02@748@01) (= $arg11@749@01 $arg12@749@01))
      (= $arg21@750@01 $arg22@750@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@748@01 Int) ($arg1@749@01 Int) ($arg2@750@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@748@01)
            ($SortWrappers.IntTo$Snap $arg1@749@01))
          ($SortWrappers.IntTo$Snap $arg2@750@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@748@01)
            ($SortWrappers.IntTo$Snap $arg1@749@01))
          ($SortWrappers.IntTo$Snap $arg2@750@01)))))
    (and
      (and
        (= (inv@752@01 $arg0@748@01 $arg1@749@01 $arg2@750@01) $arg0@748@01)
        (= (inv@754@01 $arg0@748@01 $arg1@749@01 $arg2@750@01) $arg1@749@01)
        (= (inv@756@01 $arg0@748@01 $arg1@749@01 $arg2@750@01) $arg2@750@01))
      (and
        (img@753@01 $arg0@748@01 $arg1@749@01 $arg2@750@01)
        (img@755@01 $arg0@748@01 $arg1@749@01 $arg2@750@01)
        (img@757@01 $arg0@748@01 $arg1@749@01 $arg2@750@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@748@01)
      ($SortWrappers.IntTo$Snap $arg1@749@01))
    ($SortWrappers.IntTo$Snap $arg2@750@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@748@01)
      ($SortWrappers.IntTo$Snap $arg1@749@01))
    ($SortWrappers.IntTo$Snap $arg2@750@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@753@01 $arg0 $arg1 $arg2)
        (img@755@01 $arg0 $arg1 $arg2)
        (img@757@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@752@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@754@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@756@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@752@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@754@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@756@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@752@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@754@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@756@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@752@01 $arg0 $arg1 $arg2))
  :pattern ((inv@754@01 $arg0 $arg1 $arg2))
  :pattern ((inv@756@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@752@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@754@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@756@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@676@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@752@01 $arg0 $arg1 $arg2) (inv@754@01 $arg0 $arg1 $arg2) (inv@756@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1661|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@752@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@754@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@756@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@753@01 $arg0 $arg1 $arg2)
        (img@755@01 $arg0 $arg1 $arg2)
        (img@757@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@752@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@754@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@756@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@751@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@752@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@754@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@756@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1662|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@758@01 Int)
(declare-const $arg1@759@01 Int)
(declare-const $arg2@760@01 Int)
(push) ; 8
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@761@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef56|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef57|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@758@01)
    ($SortWrappers.IntTo$Snap $arg1@759@01))
  ($SortWrappers.IntTo$Snap $arg2@760@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@758@01)
    ($SortWrappers.IntTo$Snap $arg1@759@01))
  ($SortWrappers.IntTo$Snap $arg2@760@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@758@01)
      ($SortWrappers.IntTo$Snap $arg1@759@01))
    ($SortWrappers.IntTo$Snap $arg2@760@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@762@01 (Int Int Int) Int)
(declare-fun img@763@01 (Int Int Int) Bool)
(declare-fun inv@764@01 (Int Int Int) Int)
(declare-fun img@765@01 (Int Int Int) Bool)
(declare-fun inv@766@01 (Int Int Int) Int)
(declare-fun img@767@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef56|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef57|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@758@01 Int) ($arg1@759@01 Int) ($arg2@760@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@758@01)
          ($SortWrappers.IntTo$Snap $arg1@759@01))
        ($SortWrappers.IntTo$Snap $arg2@760@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@758@01)
        ($SortWrappers.IntTo$Snap $arg1@759@01))
      ($SortWrappers.IntTo$Snap $arg2@760@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@758@01)
        ($SortWrappers.IntTo$Snap $arg1@759@01))
      ($SortWrappers.IntTo$Snap $arg2@760@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@758@01)
      ($SortWrappers.IntTo$Snap $arg1@759@01))
    ($SortWrappers.IntTo$Snap $arg2@760@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@758@01)
      ($SortWrappers.IntTo$Snap $arg1@759@01))
    ($SortWrappers.IntTo$Snap $arg2@760@01))))
  :qid |e$Transfer-aux|)))
(push) ; 8
(assert (not (forall (($arg0@758@01 Int) ($arg1@759@01 Int) ($arg2@760@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@758@01)
          ($SortWrappers.IntTo$Snap $arg1@759@01))
        ($SortWrappers.IntTo$Snap $arg2@760@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@758@01)
            ($SortWrappers.IntTo$Snap $arg1@759@01))
          ($SortWrappers.IntTo$Snap $arg2@760@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@758@01)
            ($SortWrappers.IntTo$Snap $arg1@759@01))
          ($SortWrappers.IntTo$Snap $arg2@760@01))))))
  
  :qid |quant-u-1663|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@758@01 Int) ($arg11@759@01 Int) ($arg21@760@01 Int) ($arg02@758@01 Int) ($arg12@759@01 Int) ($arg22@760@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@758@01)
                ($SortWrappers.IntTo$Snap $arg11@759@01))
              ($SortWrappers.IntTo$Snap $arg21@760@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@758@01)
              ($SortWrappers.IntTo$Snap $arg11@759@01))
            ($SortWrappers.IntTo$Snap $arg21@760@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@758@01)
              ($SortWrappers.IntTo$Snap $arg11@759@01))
            ($SortWrappers.IntTo$Snap $arg21@760@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@758@01)
              ($SortWrappers.IntTo$Snap $arg11@759@01))
            ($SortWrappers.IntTo$Snap $arg21@760@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@758@01)
                ($SortWrappers.IntTo$Snap $arg12@759@01))
              ($SortWrappers.IntTo$Snap $arg22@760@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@758@01)
              ($SortWrappers.IntTo$Snap $arg12@759@01))
            ($SortWrappers.IntTo$Snap $arg22@760@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@758@01)
              ($SortWrappers.IntTo$Snap $arg12@759@01))
            ($SortWrappers.IntTo$Snap $arg22@760@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@758@01)
              ($SortWrappers.IntTo$Snap $arg12@759@01))
            ($SortWrappers.IntTo$Snap $arg22@760@01)))))
      (and
        (and (= $arg01@758@01 $arg02@758@01) (= $arg11@759@01 $arg12@759@01))
        (= $arg21@760@01 $arg22@760@01)))
    (and
      (and (= $arg01@758@01 $arg02@758@01) (= $arg11@759@01 $arg12@759@01))
      (= $arg21@760@01 $arg22@760@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@758@01 Int) ($arg1@759@01 Int) ($arg2@760@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@758@01)
            ($SortWrappers.IntTo$Snap $arg1@759@01))
          ($SortWrappers.IntTo$Snap $arg2@760@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@758@01)
            ($SortWrappers.IntTo$Snap $arg1@759@01))
          ($SortWrappers.IntTo$Snap $arg2@760@01)))))
    (and
      (and
        (= (inv@762@01 $arg0@758@01 $arg1@759@01 $arg2@760@01) $arg0@758@01)
        (= (inv@764@01 $arg0@758@01 $arg1@759@01 $arg2@760@01) $arg1@759@01)
        (= (inv@766@01 $arg0@758@01 $arg1@759@01 $arg2@760@01) $arg2@760@01))
      (and
        (img@763@01 $arg0@758@01 $arg1@759@01 $arg2@760@01)
        (img@765@01 $arg0@758@01 $arg1@759@01 $arg2@760@01)
        (img@767@01 $arg0@758@01 $arg1@759@01 $arg2@760@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@758@01)
      ($SortWrappers.IntTo$Snap $arg1@759@01))
    ($SortWrappers.IntTo$Snap $arg2@760@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@758@01)
      ($SortWrappers.IntTo$Snap $arg1@759@01))
    ($SortWrappers.IntTo$Snap $arg2@760@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@763@01 $arg0 $arg1 $arg2)
        (img@765@01 $arg0 $arg1 $arg2)
        (img@767@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@762@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@764@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@766@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@762@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@764@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@766@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@762@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@764@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@766@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@762@01 $arg0 $arg1 $arg2))
  :pattern ((inv@764@01 $arg0 $arg1 $arg2))
  :pattern ((inv@766@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@762@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@764@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@766@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@762@01 $arg0 $arg1 $arg2) (inv@764@01 $arg0 $arg1 $arg2) (inv@766@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1664|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@762@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@764@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@766@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@763@01 $arg0 $arg1 $arg2)
        (img@765@01 $arg0 $arg1 $arg2)
        (img@767@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@762@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@764@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@766@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@761@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@762@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@764@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@766@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1665|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@768@01 Int)
(declare-const $arg1@769@01 Int)
(declare-const $arg2@770@01 Int)
(push) ; 8
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@771@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef58|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef59|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@768@01)
    ($SortWrappers.IntTo$Snap $arg1@769@01))
  ($SortWrappers.IntTo$Snap $arg2@770@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@768@01)
    ($SortWrappers.IntTo$Snap $arg1@769@01))
  ($SortWrappers.IntTo$Snap $arg2@770@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@768@01)
      ($SortWrappers.IntTo$Snap $arg1@769@01))
    ($SortWrappers.IntTo$Snap $arg2@770@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 8
(declare-fun inv@772@01 (Int Int Int) Int)
(declare-fun img@773@01 (Int Int Int) Bool)
(declare-fun inv@774@01 (Int Int Int) Int)
(declare-fun img@775@01 (Int Int Int) Bool)
(declare-fun inv@776@01 (Int Int Int) Int)
(declare-fun img@777@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef58|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef59|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@768@01 Int) ($arg1@769@01 Int) ($arg2@770@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@768@01)
          ($SortWrappers.IntTo$Snap $arg1@769@01))
        ($SortWrappers.IntTo$Snap $arg2@770@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@768@01)
        ($SortWrappers.IntTo$Snap $arg1@769@01))
      ($SortWrappers.IntTo$Snap $arg2@770@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@768@01)
        ($SortWrappers.IntTo$Snap $arg1@769@01))
      ($SortWrappers.IntTo$Snap $arg2@770@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@768@01)
      ($SortWrappers.IntTo$Snap $arg1@769@01))
    ($SortWrappers.IntTo$Snap $arg2@770@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@768@01)
      ($SortWrappers.IntTo$Snap $arg1@769@01))
    ($SortWrappers.IntTo$Snap $arg2@770@01))))
  :qid |e$Approval-aux|)))
(push) ; 8
(assert (not (forall (($arg0@768@01 Int) ($arg1@769@01 Int) ($arg2@770@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@768@01)
          ($SortWrappers.IntTo$Snap $arg1@769@01))
        ($SortWrappers.IntTo$Snap $arg2@770@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@768@01)
            ($SortWrappers.IntTo$Snap $arg1@769@01))
          ($SortWrappers.IntTo$Snap $arg2@770@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@768@01)
            ($SortWrappers.IntTo$Snap $arg1@769@01))
          ($SortWrappers.IntTo$Snap $arg2@770@01))))))
  
  :qid |quant-u-1666|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall (($arg01@768@01 Int) ($arg11@769@01 Int) ($arg21@770@01 Int) ($arg02@768@01 Int) ($arg12@769@01 Int) ($arg22@770@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@768@01)
                ($SortWrappers.IntTo$Snap $arg11@769@01))
              ($SortWrappers.IntTo$Snap $arg21@770@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@768@01)
              ($SortWrappers.IntTo$Snap $arg11@769@01))
            ($SortWrappers.IntTo$Snap $arg21@770@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@768@01)
              ($SortWrappers.IntTo$Snap $arg11@769@01))
            ($SortWrappers.IntTo$Snap $arg21@770@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@768@01)
              ($SortWrappers.IntTo$Snap $arg11@769@01))
            ($SortWrappers.IntTo$Snap $arg21@770@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@768@01)
                ($SortWrappers.IntTo$Snap $arg12@769@01))
              ($SortWrappers.IntTo$Snap $arg22@770@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@768@01)
              ($SortWrappers.IntTo$Snap $arg12@769@01))
            ($SortWrappers.IntTo$Snap $arg22@770@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@768@01)
              ($SortWrappers.IntTo$Snap $arg12@769@01))
            ($SortWrappers.IntTo$Snap $arg22@770@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@768@01)
              ($SortWrappers.IntTo$Snap $arg12@769@01))
            ($SortWrappers.IntTo$Snap $arg22@770@01)))))
      (and
        (and (= $arg01@768@01 $arg02@768@01) (= $arg11@769@01 $arg12@769@01))
        (= $arg21@770@01 $arg22@770@01)))
    (and
      (and (= $arg01@768@01 $arg02@768@01) (= $arg11@769@01 $arg12@769@01))
      (= $arg21@770@01 $arg22@770@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@768@01 Int) ($arg1@769@01 Int) ($arg2@770@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@768@01)
            ($SortWrappers.IntTo$Snap $arg1@769@01))
          ($SortWrappers.IntTo$Snap $arg2@770@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@768@01)
            ($SortWrappers.IntTo$Snap $arg1@769@01))
          ($SortWrappers.IntTo$Snap $arg2@770@01)))))
    (and
      (and
        (= (inv@772@01 $arg0@768@01 $arg1@769@01 $arg2@770@01) $arg0@768@01)
        (= (inv@774@01 $arg0@768@01 $arg1@769@01 $arg2@770@01) $arg1@769@01)
        (= (inv@776@01 $arg0@768@01 $arg1@769@01 $arg2@770@01) $arg2@770@01))
      (and
        (img@773@01 $arg0@768@01 $arg1@769@01 $arg2@770@01)
        (img@775@01 $arg0@768@01 $arg1@769@01 $arg2@770@01)
        (img@777@01 $arg0@768@01 $arg1@769@01 $arg2@770@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@768@01)
      ($SortWrappers.IntTo$Snap $arg1@769@01))
    ($SortWrappers.IntTo$Snap $arg2@770@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@768@01)
      ($SortWrappers.IntTo$Snap $arg1@769@01))
    ($SortWrappers.IntTo$Snap $arg2@770@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@773@01 $arg0 $arg1 $arg2)
        (img@775@01 $arg0 $arg1 $arg2)
        (img@777@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@772@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@774@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@776@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@772@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@774@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@776@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@772@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@774@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@776@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@772@01 $arg0 $arg1 $arg2))
  :pattern ((inv@774@01 $arg0 $arg1 $arg2))
  :pattern ((inv@776@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@772@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@774@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@776@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@700@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@772@01 $arg0 $arg1 $arg2) (inv@774@01 $arg0 $arg1 $arg2) (inv@776@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1667|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 8
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@772@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@774@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@776@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@773@01 $arg0 $arg1 $arg2)
        (img@775@01 $arg0 $arg1 $arg2)
        (img@777@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@772@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@774@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@776@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@771@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@772@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@774@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@776@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1668|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$6
(push) ; 8
(set-option :timeout 10)
(assert (not (not l$send_fail$3@360@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not l$send_fail$3@360@01))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 182 | l$send_fail$3@360@01 | live]
; [else-branch: 182 | !(l$send_fail$3@360@01) | live]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 182 | l$send_fail$3@360@01]
(assert l$send_fail$3@360@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@778@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 183 | True | live]
; [else-branch: 183 | False | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 183 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@779@01 $Snap)
(assert (= $t@779@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@780@01 $Struct)
(assert (=
  self@780@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 9
; [then-branch: 184 | False | dead]
; [else-branch: 184 | True | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 184 | True]
(pop) ; 9
(pop) ; 8
(push) ; 8
; [else-branch: 182 | !(l$send_fail$3@360@01)]
(assert (not l$send_fail$3@360@01))
(pop) ; 8
; [eval] !l$send_fail$3
(push) ; 8
(set-option :timeout 10)
(assert (not l$send_fail$3@360@01))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not l$send_fail$3@360@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 185 | !(l$send_fail$3@360@01) | live]
; [else-branch: 185 | l$send_fail$3@360@01 | live]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 185 | !(l$send_fail$3@360@01)]
(assert (not l$send_fail$3@360@01))
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; i3$$pre_self := self
; [exec]
; i3$$pre_$contracts := $contracts
; [exec]
; $contracts := l$havoc$7
; [exec]
; $old_$contracts := $contracts
; [exec]
; self := l$havoc$8
; [exec]
; $contracts := l$havoc$9
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@781@01 $Snap)
(assert (= $t@781@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$havoc$8@365@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@782@01 $Snap)
(assert (= $t@782@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$havoc$8@365@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@783@01 $Snap)
(assert (= $t@783@01 ($Snap.combine ($Snap.first $t@783@01) ($Snap.second $t@783@01))))
(assert (= ($Snap.first $t@783@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 2))))
(assert (= ($Snap.second $t@783@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@784@01 $Snap)
(assert (= $t@784@01 ($Snap.combine ($Snap.first $t@784@01) ($Snap.second $t@784@01))))
(assert (= ($Snap.first $t@784@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 3))))
(assert (= ($Snap.second $t@784@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@785@01 $Snap)
(assert (= $t@785@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@786@01 Int)
(set-option :timeout 0)
(push) ; 9
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 10
; [then-branch: 186 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 4)), $q2@786@01)) | live]
; [else-branch: 186 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 4)), $q2@786@01) | live]
(push) ; 11
; [then-branch: 186 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 4)), $q2@786@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@786@01))))
(pop) ; 11
(push) ; 11
; [else-branch: 186 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 4)), $q2@786@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@786@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@786@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@786@01)))))
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@786@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@786@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@786@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@786@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1400@13@1400@347-aux|)))
(assert (forall (($q2@786@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@786@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@786@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@786@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1400@13@1400@347|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@787@01 $Snap)
(assert (= $t@787@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@788@01 Int)
(set-option :timeout 0)
(push) ; 9
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@788@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@788@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 4)) $q2@788@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1401@13@1401@255|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@789@01 $Snap)
(assert (= $t@789@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@790@01 Int)
(set-option :timeout 0)
(push) ; 9
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@791@01 Int)
(push) ; 10
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 11
; [then-branch: 187 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@365@01, 5)), $q3@790@01), $q4@791@01)) | live]
; [else-branch: 187 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@365@01, 5)), $q3@790@01), $q4@791@01) | live]
(push) ; 12
; [then-branch: 187 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@365@01, 5)), $q3@790@01), $q4@791@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01))))
(pop) ; 12
(push) ; 12
; [else-branch: 187 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@365@01, 5)), $q3@790@01), $q4@791@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01)))))
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@791@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1402@133@1402@599-aux|)))
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@790@01 Int)) (!
  (forall (($q4@791@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1402@133@1402@599-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1402@13@1402@600-aux|)))
(assert (forall (($q3@790@01 Int)) (!
  (forall (($q4@791@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01) $q4@791@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1402@133@1402@599|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@790@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1402@13@1402@600|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@792@01 $Snap)
(assert (= $t@792@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@793@01 Int)
(set-option :timeout 0)
(push) ; 9
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@794@01 Int)
(push) ; 10
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@793@01 Int)) (!
  (forall (($q4@794@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@793@01) $q4@794@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@793@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@793@01) $q4@794@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1403@133@1403@507|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@365@01 5)) $q3@793@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1403@13@1403@508|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@795@01 $Snap)
(assert (= $t@795@01 ($Snap.combine ($Snap.first $t@795@01) ($Snap.second $t@795@01))))
(assert (= ($Snap.first $t@795@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 6))))
(assert (= ($Snap.second $t@795@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@796@01 $Snap)
(assert (= $t@796@01 ($Snap.combine ($Snap.first $t@796@01) ($Snap.second $t@796@01))))
(assert (= ($Snap.first $t@796@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 7))))
(assert (= ($Snap.second $t@796@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@797@01 $Snap)
(assert (= $t@797@01 ($Snap.combine ($Snap.first $t@797@01) ($Snap.second $t@797@01))))
(assert (= ($Snap.first $t@797@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 8))))
(assert (= ($Snap.second $t@797@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@798@01 $Snap)
(assert (= $t@798@01 ($Snap.combine ($Snap.first $t@798@01) ($Snap.second $t@798@01))))
(assert (= ($Snap.first $t@798@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 9))))
(assert (= ($Snap.second $t@798@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@799@01 $Snap)
(assert (= $t@799@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@800@01 Int)
(set-option :timeout 0)
(push) ; 9
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 10
; [then-branch: 188 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 11)), $q5@800@01)) | live]
; [else-branch: 188 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 11)), $q5@800@01) | live]
(push) ; 11
; [then-branch: 188 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 11)), $q5@800@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@800@01))))
(pop) ; 11
(push) ; 11
; [else-branch: 188 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 11)), $q5@800@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@800@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@800@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@800@01)))))
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@800@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@800@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@800@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@800@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1408@13@1408@350-aux|)))
(assert (forall (($q5@800@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@800@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@800@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@800@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1408@13@1408@350|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@801@01 $Snap)
(assert (= $t@801@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@802@01 Int)
(set-option :timeout 0)
(push) ; 9
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@802@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@802@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $q5@802@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1409@13@1409@258|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@803@01 $Snap)
(assert (= $t@803@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@804@01 Int)
(set-option :timeout 0)
(push) ; 9
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 10
; [then-branch: 189 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 12)), $q6@804@01)) | live]
; [else-branch: 189 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 12)), $q6@804@01) | live]
(push) ; 11
; [then-branch: 189 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 12)), $q6@804@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@804@01))))
(pop) ; 11
(push) ; 11
; [else-branch: 189 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@365@01, 12)), $q6@804@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@804@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@804@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@804@01)))))
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@804@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@804@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@804@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@804@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1410@13@1410@350-aux|)))
(assert (forall (($q6@804@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@804@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@804@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@804@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1410@13@1410@350|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@805@01 $Snap)
(assert (= $t@805@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@806@01 Int)
(set-option :timeout 0)
(push) ; 9
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@806@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@806@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 12)) $q6@806@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1411@13@1411@258|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@807@01 $Snap)
(assert (= $t@807@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@808@01 $Snap)
(assert (= $t@808@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@809@01 Int)
(set-option :timeout 0)
(push) ; 9
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($old_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($old_self, 11)
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($a@809@01 Int)) (!
  (>=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $a@809@01)
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@717@01 11)) $a@809@01))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@365@01 11)) $a@809@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1414@13@1414@264|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not l$no_reentrant_call$1@367@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not l$no_reentrant_call$1@367@01))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 190 | l$no_reentrant_call$1@367@01 | live]
; [else-branch: 190 | !(l$no_reentrant_call$1@367@01) | live]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 190 | l$no_reentrant_call$1@367@01]
(assert l$no_reentrant_call$1@367@01)
; [exec]
; self := $old_self
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$10
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$11
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$raw_ret$3
(push) ; 10
(set-option :timeout 10)
(assert (not l$raw_ret$3@361@01))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not l$raw_ret$3@361@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 191 | !(l$raw_ret$3@361@01) | live]
; [else-branch: 191 | l$raw_ret$3@361@01 | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 191 | !(l$raw_ret$3@361@01)]
(assert (not l$raw_ret$3@361@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 11
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 192 | True | live]
; [else-branch: 192 | False | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 192 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@810@01 $Snap)
(assert (= $t@810@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@811@01 $Struct)
(assert (=
  self@811@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 11
; [then-branch: 193 | False | dead]
; [else-branch: 193 | True | live]
(set-option :timeout 0)
(push) ; 11
; [else-branch: 193 | True]
(pop) ; 11
(pop) ; 10
(push) ; 10
; [else-branch: 191 | l$raw_ret$3@361@01]
(assert l$raw_ret$3@361@01)
(pop) ; 10
; [eval] !!l$raw_ret$3
; [eval] !l$raw_ret$3
(push) ; 10
(set-option :timeout 10)
(assert (not (not l$raw_ret$3@361@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not l$raw_ret$3@361@01))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 194 | l$raw_ret$3@361@01 | live]
; [else-branch: 194 | !(l$raw_ret$3@361@01) | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 194 | l$raw_ret$3@361@01]
(assert l$raw_ret$3@361@01)
; [exec]
; inhale acc(e$AddLiquidity(($struct_get($struct_loc(msg, 0)): Int), ($struct_get($struct_loc(msg,
;   1)): Int), $unwrap(l$token_amount$1)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
; [eval] $unwrap(l$token_amount$1)
(declare-const $t@812@01 $Snap)
(declare-const sm@813@01 $PSF<e$AddLiquidity>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$AddLiquidity (as sm@813@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$max_tokens@320@01))))
  $t@812@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
      (= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$max_tokens@320@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$max_tokens@320@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$max_tokens@320@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(e$Transfer(0, ($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$initial_liquidity)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$initial_liquidity)
(declare-const $t@814@01 $Snap)
(declare-const sm@815@01 $PSF<e$Transfer>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$Transfer (as sm@815@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap 0)
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$initial_liquidity@715@01))))
  $t@814@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (= 0 0)
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      (=
        ($unwrap<Int> l$initial_liquidity@715@01)
        ($unwrap<Int> l$initial_liquidity@715@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap 0)
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$initial_liquidity@715@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap 0)
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$initial_liquidity@715@01)))))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; $res := $unwrap(l$initial_liquidity)
; [eval] $unwrap(l$initial_liquidity)
(declare-const $res@816@01 Int)
(assert (= $res@816@01 ($unwrap<Int> l$initial_liquidity@715@01)))
; [exec]
; label return
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (not $out_of_gas@370@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not $out_of_gas@370@01))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 195 | $out_of_gas@370@01 | live]
; [else-branch: 195 | !($out_of_gas@370@01) | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 195 | $out_of_gas@370@01]
(assert $out_of_gas@370@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 12
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 196 | True | live]
; [else-branch: 196 | False | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 196 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@817@01 $Snap)
(assert (= $t@817@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@818@01 $Struct)
(assert (=
  self@818@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 12
; [then-branch: 197 | False | dead]
; [else-branch: 197 | True | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 197 | True]
(pop) ; 12
(pop) ; 11
(push) ; 11
; [else-branch: 195 | !($out_of_gas@370@01)]
(assert (not $out_of_gas@370@01))
(pop) ; 11
; [eval] !$out_of_gas
(push) ; 11
(set-option :timeout 10)
(assert (not $out_of_gas@370@01))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (not $out_of_gas@370@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 198 | !($out_of_gas@370@01) | live]
; [else-branch: 198 | $out_of_gas@370@01 | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 198 | !($out_of_gas@370@01)]
(assert (not $out_of_gas@370@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 199 | False | dead]
; [else-branch: 199 | True | live]
(push) ; 12
; [else-branch: 199 | True]
(pop) ; 12
(push) ; 12
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 200 | True | live]
; [else-branch: 200 | False | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 200 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@819@01 $Snap)
(assert (= $t@819@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@820@01 $Struct)
(assert (=
  self@820@01
  ($struct_set<$Struct> self@717@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@717@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 12
(pop) ; 11
(set-option :timeout 0)
(push) ; 11
; [else-branch: 198 | $out_of_gas@370@01]
(assert $out_of_gas@370@01)
(pop) ; 11
(pop) ; 10
(push) ; 10
; [else-branch: 194 | !(l$raw_ret$3@361@01)]
(assert (not l$raw_ret$3@361@01))
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 190 | !(l$no_reentrant_call$1@367@01)]
(assert (not l$no_reentrant_call$1@367@01))
(pop) ; 9
; [eval] !l$no_reentrant_call$1
(push) ; 9
(set-option :timeout 10)
(assert (not l$no_reentrant_call$1@367@01))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not l$no_reentrant_call$1@367@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 201 | !(l$no_reentrant_call$1@367@01) | live]
; [else-branch: 201 | l$no_reentrant_call$1@367@01 | live]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 201 | !(l$no_reentrant_call$1@367@01)]
(assert (not l$no_reentrant_call$1@367@01))
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$10
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$11
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$raw_ret$3
(push) ; 10
(set-option :timeout 10)
(assert (not l$raw_ret$3@361@01))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not l$raw_ret$3@361@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 202 | !(l$raw_ret$3@361@01) | live]
; [else-branch: 202 | l$raw_ret$3@361@01 | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 202 | !(l$raw_ret$3@361@01)]
(assert (not l$raw_ret$3@361@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 11
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 203 | True | live]
; [else-branch: 203 | False | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 203 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@821@01 $Snap)
(assert (= $t@821@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@822@01 $Struct)
(assert (=
  self@822@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 11
; [then-branch: 204 | False | dead]
; [else-branch: 204 | True | live]
(set-option :timeout 0)
(push) ; 11
; [else-branch: 204 | True]
(pop) ; 11
(pop) ; 10
(push) ; 10
; [else-branch: 202 | l$raw_ret$3@361@01]
(assert l$raw_ret$3@361@01)
(pop) ; 10
; [eval] !!l$raw_ret$3
; [eval] !l$raw_ret$3
(push) ; 10
(set-option :timeout 10)
(assert (not (not l$raw_ret$3@361@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not l$raw_ret$3@361@01))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 205 | l$raw_ret$3@361@01 | live]
; [else-branch: 205 | !(l$raw_ret$3@361@01) | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 205 | l$raw_ret$3@361@01]
(assert l$raw_ret$3@361@01)
; [exec]
; inhale acc(e$AddLiquidity(($struct_get($struct_loc(msg, 0)): Int), ($struct_get($struct_loc(msg,
;   1)): Int), $unwrap(l$token_amount$1)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
; [eval] $unwrap(l$token_amount$1)
(declare-const $t@823@01 $Snap)
(declare-const sm@824@01 $PSF<e$AddLiquidity>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$AddLiquidity (as sm@824@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$max_tokens@320@01))))
  $t@823@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)))
      (= ($unwrap<Int> l$max_tokens@320@01) ($unwrap<Int> l$max_tokens@320@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@664@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$max_tokens@320@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 1))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$max_tokens@320@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(e$Transfer(0, ($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$initial_liquidity)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$initial_liquidity)
(declare-const $t@825@01 $Snap)
(declare-const sm@826@01 $PSF<e$Transfer>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$Transfer (as sm@826@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap 0)
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$initial_liquidity@715@01))))
  $t@825@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (= 0 0)
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@324@01 0)))
      (=
        ($unwrap<Int> l$initial_liquidity@715@01)
        ($unwrap<Int> l$initial_liquidity@715@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@688@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap 0)
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$initial_liquidity@715@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap 0)
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@324@01 0))))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$initial_liquidity@715@01)))))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; $res := $unwrap(l$initial_liquidity)
; [eval] $unwrap(l$initial_liquidity)
(declare-const $res@827@01 Int)
(assert (= $res@827@01 ($unwrap<Int> l$initial_liquidity@715@01)))
; [exec]
; label return
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (not $out_of_gas@370@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not $out_of_gas@370@01))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 206 | $out_of_gas@370@01 | live]
; [else-branch: 206 | !($out_of_gas@370@01) | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 206 | $out_of_gas@370@01]
(assert $out_of_gas@370@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 12
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 207 | True | live]
; [else-branch: 207 | False | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 207 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@828@01 $Snap)
(assert (= $t@828@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@829@01 $Struct)
(assert (=
  self@829@01
  ($struct_set<$Struct> self@328@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@328@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 12
; [then-branch: 208 | False | dead]
; [else-branch: 208 | True | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 208 | True]
(pop) ; 12
(pop) ; 11
(push) ; 11
; [else-branch: 206 | !($out_of_gas@370@01)]
(assert (not $out_of_gas@370@01))
(pop) ; 11
; [eval] !$out_of_gas
(push) ; 11
(set-option :timeout 10)
(assert (not $out_of_gas@370@01))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (not $out_of_gas@370@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 209 | !($out_of_gas@370@01) | live]
; [else-branch: 209 | $out_of_gas@370@01 | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 209 | !($out_of_gas@370@01)]
(assert (not $out_of_gas@370@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 210 | False | dead]
; [else-branch: 210 | True | live]
(push) ; 12
; [else-branch: 210 | True]
(pop) ; 12
(push) ; 12
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 211 | True | live]
; [else-branch: 211 | False | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 211 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@830@01 $Snap)
(assert (= $t@830@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@372@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@831@01 $Struct)
(assert (=
  self@831@01
  ($struct_set<$Struct> l$havoc$8@365@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> l$havoc$8@365@01 8))
    l$havoc$13@372@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 12
(pop) ; 11
(set-option :timeout 0)
(push) ; 11
; [else-branch: 209 | $out_of_gas@370@01]
(assert $out_of_gas@370@01)
(pop) ; 11
(pop) ; 10
(push) ; 10
; [else-branch: 205 | !(l$raw_ret$3@361@01)]
(assert (not l$raw_ret$3@361@01))
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 201 | l$no_reentrant_call$1@367@01]
(assert l$no_reentrant_call$1@367@01)
(pop) ; 9
(pop) ; 8
(push) ; 8
; [else-branch: 185 | l$send_fail$3@360@01]
(assert l$send_fail$3@360@01)
(pop) ; 8
(pop) ; 7
(push) ; 7
; [else-branch: 181 | l$raw_ret$2@356@01 != $self_address[Int]]
(assert (not (= l$raw_ret$2@356@01 (as $self_address<Int>  Int))))
(pop) ; 7
(pop) ; 6
(push) ; 6
; [else-branch: 177 | l$send_fail$2@355@01]
(assert l$send_fail$2@355@01)
(pop) ; 6
(pop) ; 5
(push) ; 5
; [else-branch: 173 | !($struct_get[Int]($struct_loc[Int](self@419@01, 7)) != 0 && $struct_get[Int]($struct_loc[Int](self@419@01, 6)) != 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) >= 1000000000)]
(assert (not
  (and
    (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 7)) 0))
    (and
      (not (= ($struct_get<Int> ($struct_loc<Int> self@419@01 6)) 0))
      (>= ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 1000000000)))))
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 165 | $unwrap[Int](l$total_liquidity@422@01) > 0]
(assert (> ($unwrap<Int> l$total_liquidity@422@01) 0))
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 57 | !($unwrap[Int](l$deadline@321@01) > $struct_get[Int]($struct_loc[Int](block@325@01, 4)) && $unwrap[Int](l$max_tokens@320@01) > 0 && $struct_get[Int]($struct_loc[Int](msg@324@01, 1)) > 0)]
(assert (not
  (and
    (>
      ($unwrap<Int> l$deadline@321@01)
      ($struct_get<Int> ($struct_loc<Int> block@325@01 4)))
    (and
      (> ($unwrap<Int> l$max_tokens@320@01) 0)
      (> ($struct_get<Int> ($struct_loc<Int> msg@324@01 1)) 0)))))
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- f$removeLiquidity ----------
(declare-const l$amount@832@01 $Int)
(declare-const l$min_eth@833@01 $Int)
(declare-const l$min_tokens@834@01 $Int)
(declare-const l$deadline@835@01 $Int)
(declare-const $succ@836@01 Bool)
(declare-const $res@837@01 $Struct)
(declare-const l$amount@838@01 $Int)
(declare-const l$min_eth@839@01 $Int)
(declare-const l$min_tokens@840@01 $Int)
(declare-const l$deadline@841@01 $Int)
(declare-const $succ@842@01 Bool)
(declare-const $res@843@01 $Struct)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var msg: $Struct
(declare-const msg@844@01 $Struct)
; [exec]
; var block: $Struct
(declare-const block@845@01 $Struct)
; [exec]
; var chain: $Struct
(declare-const chain@846@01 $Struct)
; [exec]
; var tx: $Struct
(declare-const tx@847@01 $Struct)
; [exec]
; var self: $Struct
(declare-const self@848@01 $Struct)
; [exec]
; var $contracts: $Map[Int, $Struct]
(declare-const $contracts@849@01 $Map<Int~_$Struct>)
; [exec]
; var $old_self: $Struct
(declare-const $old_self@850@01 $Struct)
; [exec]
; var $old_$contracts: $Map[Int, $Struct]
(declare-const $old_$contracts@851@01 $Map<Int~_$Struct>)
; [exec]
; var $pre_self: $Struct
(declare-const $pre_self@852@01 $Struct)
; [exec]
; var $pre_$contracts: $Map[Int, $Struct]
(declare-const $pre_$contracts@853@01 $Map<Int~_$Struct>)
; [exec]
; var $issued_self: $Struct
(declare-const $issued_self@854@01 $Struct)
; [exec]
; var $issued_$contracts: $Map[Int, $Struct]
(declare-const $issued_$contracts@855@01 $Map<Int~_$Struct>)
; [exec]
; var $overflow: Bool
(declare-const $overflow@856@01 Bool)
; [exec]
; var l$total_liquidity: $Int
(declare-const l$total_liquidity@857@01 $Int)
; [exec]
; var l$send_fail: Bool
(declare-const l$send_fail@858@01 Bool)
; [exec]
; var l$raw_ret: Int
(declare-const l$raw_ret@859@01 Int)
; [exec]
; var l$token_reserve: $Int
(declare-const l$token_reserve@860@01 $Int)
; [exec]
; var l$eth_amount: $Int
(declare-const l$eth_amount@861@01 $Int)
; [exec]
; var l$token_amount: $Int
(declare-const l$token_amount@862@01 $Int)
; [exec]
; var l$havoc: $Map[Int, $Struct]
(declare-const l$havoc@863@01 $Map<Int~_$Struct>)
; [exec]
; var l$send_fail$1: Bool
(declare-const l$send_fail$1@864@01 Bool)
; [exec]
; var i1$$pre_self: $Struct
(declare-const i1$$pre_self@865@01 $Struct)
; [exec]
; var i1$$pre_$contracts: $Map[Int, $Struct]
(declare-const i1$$pre_$contracts@866@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$1: $Map[Int, $Struct]
(declare-const l$havoc$1@867@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$2: $Struct
(declare-const l$havoc$2@868@01 $Struct)
; [exec]
; var l$havoc$3: $Map[Int, $Struct]
(declare-const l$havoc$3@869@01 $Map<Int~_$Struct>)
; [exec]
; var l$no_reentrant_call: Bool
(declare-const l$no_reentrant_call@870@01 Bool)
; [exec]
; var l$havoc$4: $Map[Int, $Struct]
(declare-const l$havoc$4@871@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$5: $Map[Int, $Struct]
(declare-const l$havoc$5@872@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$6: $Map[Int, $Struct]
(declare-const l$havoc$6@873@01 $Map<Int~_$Struct>)
; [exec]
; var l$send_fail$2: Bool
(declare-const l$send_fail$2@874@01 Bool)
; [exec]
; var l$raw_ret$1: Bool
(declare-const l$raw_ret$1@875@01 Bool)
; [exec]
; var i2$$pre_self: $Struct
(declare-const i2$$pre_self@876@01 $Struct)
; [exec]
; var i2$$pre_$contracts: $Map[Int, $Struct]
(declare-const i2$$pre_$contracts@877@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$7: $Map[Int, $Struct]
(declare-const l$havoc$7@878@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$8: $Struct
(declare-const l$havoc$8@879@01 $Struct)
; [exec]
; var l$havoc$9: $Map[Int, $Struct]
(declare-const l$havoc$9@880@01 $Map<Int~_$Struct>)
; [exec]
; var l$no_reentrant_call$1: Bool
(declare-const l$no_reentrant_call$1@881@01 Bool)
; [exec]
; var l$havoc$10: $Map[Int, $Struct]
(declare-const l$havoc$10@882@01 $Map<Int~_$Struct>)
; [exec]
; var l$havoc$11: $Map[Int, $Struct]
(declare-const l$havoc$11@883@01 $Map<Int~_$Struct>)
; [exec]
; var $out_of_gas: Bool
(declare-const $out_of_gas@884@01 Bool)
; [exec]
; var l$havoc$12: $Struct
(declare-const l$havoc$12@885@01 $Struct)
; [exec]
; var l$havoc$13: Int
(declare-const l$havoc$13@886@01 Int)
; [exec]
; var l$havoc$14: $Map[Int, $Struct]
(declare-const l$havoc$14@887@01 $Map<Int~_$Struct>)
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@888@01 $Snap)
(assert (= $t@888@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@848@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@889@01 $Snap)
(assert (= $t@889@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@848@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@890@01 $Snap)
(assert (= $t@890@01 ($Snap.combine ($Snap.first $t@890@01) ($Snap.second $t@890@01))))
(assert (= ($Snap.first $t@890@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@848@01 2))))
(assert (= ($Snap.second $t@890@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@848@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@891@01 $Snap)
(assert (= $t@891@01 ($Snap.combine ($Snap.first $t@891@01) ($Snap.second $t@891@01))))
(assert (= ($Snap.first $t@891@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@848@01 3))))
(assert (= ($Snap.second $t@891@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@848@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@892@01 $Snap)
(assert (= $t@892@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@893@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 4
; [then-branch: 212 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $q2@893@01)) | live]
; [else-branch: 212 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $q2@893@01) | live]
(push) ; 5
; [then-branch: 212 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $q2@893@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@893@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 212 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $q2@893@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@893@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@893@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@893@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@893@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@893@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@893@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@893@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1521@11@1521@345-aux|)))
(assert (forall (($q2@893@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@893@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@893@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@893@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1521@11@1521@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@894@01 $Snap)
(assert (= $t@894@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@895@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@895@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@895@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) $q2@895@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1522@11@1522@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@896@01 $Snap)
(assert (= $t@896@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@897@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@898@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 5
; [then-branch: 213 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@848@01, 5)), $q3@897@01), $q4@898@01)) | live]
; [else-branch: 213 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@848@01, 5)), $q3@897@01), $q4@898@01) | live]
(push) ; 6
; [then-branch: 213 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@848@01, 5)), $q3@897@01), $q4@898@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 213 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@848@01, 5)), $q3@897@01), $q4@898@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@898@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1523@131@1523@597-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@897@01 Int)) (!
  (forall (($q4@898@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1523@131@1523@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1523@11@1523@598-aux|)))
(assert (forall (($q3@897@01 Int)) (!
  (forall (($q4@898@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01) $q4@898@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1523@131@1523@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@897@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1523@11@1523@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@899@01 $Snap)
(assert (= $t@899@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@900@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@901@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@900@01 Int)) (!
  (forall (($q4@901@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@900@01) $q4@901@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@900@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@900@01) $q4@901@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1524@131@1524@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@848@01 5)) $q3@900@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1524@11@1524@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@902@01 $Snap)
(assert (= $t@902@01 ($Snap.combine ($Snap.first $t@902@01) ($Snap.second $t@902@01))))
(assert (= ($Snap.first $t@902@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@848@01 6))))
(assert (= ($Snap.second $t@902@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@848@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@903@01 $Snap)
(assert (= $t@903@01 ($Snap.combine ($Snap.first $t@903@01) ($Snap.second $t@903@01))))
(assert (= ($Snap.first $t@903@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@848@01 7))))
(assert (= ($Snap.second $t@903@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@848@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@904@01 $Snap)
(assert (= $t@904@01 ($Snap.combine ($Snap.first $t@904@01) ($Snap.second $t@904@01))))
(assert (= ($Snap.first $t@904@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@848@01 8))))
(assert (= ($Snap.second $t@904@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@905@01 $Snap)
(assert (= $t@905@01 ($Snap.combine ($Snap.first $t@905@01) ($Snap.second $t@905@01))))
(assert (= ($Snap.first $t@905@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> self@848@01 9))))
(assert (= ($Snap.second $t@905@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@848@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@906@01 $Snap)
(assert (= $t@906@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@907@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 4
; [then-branch: 214 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 11)), $q5@907@01)) | live]
; [else-branch: 214 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 11)), $q5@907@01) | live]
(push) ; 5
; [then-branch: 214 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 11)), $q5@907@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@907@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 214 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 11)), $q5@907@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@907@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@907@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@907@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@907@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@907@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@907@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@907@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1529@11@1529@348-aux|)))
(assert (forall (($q5@907@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@907@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@907@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@907@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1529@11@1529@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@908@01 $Snap)
(assert (= $t@908@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@909@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@909@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@909@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 11)) $q5@909@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1530@11@1530@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@910@01 $Snap)
(assert (= $t@910@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@911@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 4
; [then-branch: 215 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 12)), $q6@911@01)) | live]
; [else-branch: 215 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 12)), $q6@911@01) | live]
(push) ; 5
; [then-branch: 215 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 12)), $q6@911@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@911@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 215 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 12)), $q6@911@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@911@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@911@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@911@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@911@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@911@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@911@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@911@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1531@11@1531@348-aux|)))
(assert (forall (($q6@911@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@911@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@911@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@911@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1531@11@1531@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@912@01 $Snap)
(assert (= $t@912@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@913@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@913@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@913@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 12)) $q6@913@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1532@11@1532@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@914@01 $Snap)
(assert (= $t@914@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> self@848@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $self_address() &&
;   $self_address() <= 1461501637330902918203684832716283019655932542975
(declare-const $t@915@01 $Snap)
(assert (= $t@915@01 ($Snap.combine ($Snap.first $t@915@01) ($Snap.second $t@915@01))))
(assert (= ($Snap.first $t@915@01) $Snap.unit))
; [eval] 0 <= $self_address()
; [eval] $self_address()
(assert (<= 0 (as $self_address<Int>  Int)))
(assert (= ($Snap.second $t@915@01) $Snap.unit))
; [eval] $self_address() <= 1461501637330902918203684832716283019655932542975
; [eval] $self_address()
(assert (<=
  (as $self_address<Int>  Int)
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$amount) &&
;   $unwrap(l$amount) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@916@01 $Snap)
(assert (= $t@916@01 ($Snap.combine ($Snap.first $t@916@01) ($Snap.second $t@916@01))))
(assert (= ($Snap.first $t@916@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$amount)
; [eval] $unwrap(l$amount)
(assert (<= 0 ($unwrap<Int> l$amount@838@01)))
(assert (= ($Snap.second $t@916@01) $Snap.unit))
; [eval] $unwrap(l$amount) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$amount)
(assert (<=
  ($unwrap<Int> l$amount@838@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$min_eth) &&
;   $unwrap(l$min_eth) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@917@01 $Snap)
(assert (= $t@917@01 ($Snap.combine ($Snap.first $t@917@01) ($Snap.second $t@917@01))))
(assert (= ($Snap.first $t@917@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$min_eth)
; [eval] $unwrap(l$min_eth)
(assert (<= 0 ($unwrap<Int> l$min_eth@839@01)))
(assert (= ($Snap.second $t@917@01) $Snap.unit))
; [eval] $unwrap(l$min_eth) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$min_eth)
(assert (<=
  ($unwrap<Int> l$min_eth@839@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$min_tokens) &&
;   $unwrap(l$min_tokens) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@918@01 $Snap)
(assert (= $t@918@01 ($Snap.combine ($Snap.first $t@918@01) ($Snap.second $t@918@01))))
(assert (= ($Snap.first $t@918@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$min_tokens)
; [eval] $unwrap(l$min_tokens)
(assert (<= 0 ($unwrap<Int> l$min_tokens@840@01)))
(assert (= ($Snap.second $t@918@01) $Snap.unit))
; [eval] $unwrap(l$min_tokens) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$min_tokens)
(assert (<=
  ($unwrap<Int> l$min_tokens@840@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$deadline) &&
;   $unwrap(l$deadline) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@919@01 $Snap)
(assert (= $t@919@01 ($Snap.combine ($Snap.first $t@919@01) ($Snap.second $t@919@01))))
(assert (= ($Snap.first $t@919@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$deadline)
; [eval] $unwrap(l$deadline)
(assert (<= 0 ($unwrap<Int> l$deadline@841@01)))
(assert (= ($Snap.second $t@919@01) $Snap.unit))
; [eval] $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$deadline)
(assert (<=
  ($unwrap<Int> l$deadline@841@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) &&
;   ($struct_get($struct_loc(block, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@920@01 $Snap)
(assert (= $t@920@01 ($Snap.combine ($Snap.first $t@920@01) ($Snap.second $t@920@01))))
(assert (= ($Snap.first $t@920@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 0)): Int)
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@845@01 0))))
(assert (= ($Snap.second $t@920@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@845@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) &&
;   ($struct_get($struct_loc(block, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@921@01 $Snap)
(assert (= $t@921@01 ($Snap.combine ($Snap.first $t@921@01) ($Snap.second $t@921@01))))
(assert (= ($Snap.first $t@921@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 1)): Int)
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@845@01 1))))
(assert (= ($Snap.second $t@921@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@845@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) &&
;   ($struct_get($struct_loc(block, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@922@01 $Snap)
(assert (= $t@922@01 ($Snap.combine ($Snap.first $t@922@01) ($Snap.second $t@922@01))))
(assert (= ($Snap.first $t@922@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 2)): Int)
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@845@01 2))))
(assert (= ($Snap.second $t@922@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@845@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
(declare-const $t@923@01 $Snap)
(assert (= $t@923@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])|
; [eval] ($struct_get($struct_loc(block, 3)): Seq[Int])
; [eval] $struct_loc(block, 3)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> block@845@01 3))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) &&
;   ($struct_get($struct_loc(block, 4)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@924@01 $Snap)
(assert (= $t@924@01 ($Snap.combine ($Snap.first $t@924@01) ($Snap.second $t@924@01))))
(assert (= ($Snap.first $t@924@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@845@01 4))))
(assert (= ($Snap.second $t@924@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@845@01 4))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(block, -1)): Int) ==
;   2335365049822495359383864865678187
(declare-const $t@925@01 $Snap)
(assert (= $t@925@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
; [eval] ($struct_get($struct_loc(block, -1)): Int)
; [eval] $struct_loc(block, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> block@845@01 (- 0 1)))
  2335365049822495359383864865678187))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) &&
;   ($struct_get($struct_loc(msg, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@926@01 $Snap)
(assert (= $t@926@01 ($Snap.combine ($Snap.first $t@926@01) ($Snap.second $t@926@01))))
(assert (= ($Snap.first $t@926@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@844@01 0))))
(assert (= ($Snap.second $t@926@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@844@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) &&
;   ($struct_get($struct_loc(msg, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@927@01 $Snap)
(assert (= $t@927@01 ($Snap.combine ($Snap.first $t@927@01) ($Snap.second $t@927@01))))
(assert (= ($Snap.first $t@927@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@844@01 1))))
(assert (= ($Snap.second $t@927@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@844@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) &&
;   ($struct_get($struct_loc(msg, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@928@01 $Snap)
(assert (= $t@928@01 ($Snap.combine ($Snap.first $t@928@01) ($Snap.second $t@928@01))))
(assert (= ($Snap.first $t@928@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 2)): Int)
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@844@01 2))))
(assert (= ($Snap.second $t@928@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@844@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, -1)): Int) ==
;   35634842679176259756224246631
(declare-const $t@929@01 $Snap)
(assert (= $t@929@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
; [eval] ($struct_get($struct_loc(msg, -1)): Int)
; [eval] $struct_loc(msg, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> msg@844@01 (- 0 1)))
  35634842679176259756224246631))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
(declare-const $t@930@01 $Snap)
(assert (= $t@930@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) != 0
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (not (= ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)) 0)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@931@01 $Snap)
(assert (= $t@931@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@932@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; $pre_self := self
; [exec]
; $pre_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $succ := true
; [exec]
; $overflow := false
; [exec]
; inhale ($struct_get($struct_loc(msg, 1)): Int) == 0
(declare-const $t@933@01 $Snap)
(assert (= $t@933@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) == 0
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (= ($struct_get<Int> ($struct_loc<Int> msg@844@01 1)) 0))
; State saturation: after inhale
(check-sat)
; unknown
; [eval] !($unwrap(l$amount) > 0 && ($unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$min_eth) > 0 && $unwrap(l$min_tokens) > 0)))
; [eval] $unwrap(l$amount) > 0 && ($unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$min_eth) > 0 && $unwrap(l$min_tokens) > 0))
; [eval] $unwrap(l$amount) > 0
; [eval] $unwrap(l$amount)
(set-option :timeout 0)
(push) ; 3
; [then-branch: 216 | !($unwrap[Int](l$amount@838@01) > 0) | live]
; [else-branch: 216 | $unwrap[Int](l$amount@838@01) > 0 | live]
(push) ; 4
; [then-branch: 216 | !($unwrap[Int](l$amount@838@01) > 0)]
(assert (not (> ($unwrap<Int> l$amount@838@01) 0)))
(pop) ; 4
(push) ; 4
; [else-branch: 216 | $unwrap[Int](l$amount@838@01) > 0]
(assert (> ($unwrap<Int> l$amount@838@01) 0))
; [eval] $unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int)
; [eval] $unwrap(l$deadline)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(push) ; 5
; [then-branch: 217 | !($unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4))) | live]
; [else-branch: 217 | $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)) | live]
(push) ; 6
; [then-branch: 217 | !($unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)))]
(assert (not
  (>
    ($unwrap<Int> l$deadline@841@01)
    ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))))
(pop) ; 6
(push) ; 6
; [else-branch: 217 | $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4))]
(assert (>
  ($unwrap<Int> l$deadline@841@01)
  ($struct_get<Int> ($struct_loc<Int> block@845@01 4))))
; [eval] $unwrap(l$min_eth) > 0
; [eval] $unwrap(l$min_eth)
(push) ; 7
; [then-branch: 218 | !($unwrap[Int](l$min_eth@839@01) > 0) | live]
; [else-branch: 218 | $unwrap[Int](l$min_eth@839@01) > 0 | live]
(push) ; 8
; [then-branch: 218 | !($unwrap[Int](l$min_eth@839@01) > 0)]
(assert (not (> ($unwrap<Int> l$min_eth@839@01) 0)))
(pop) ; 8
(push) ; 8
; [else-branch: 218 | $unwrap[Int](l$min_eth@839@01) > 0]
(assert (> ($unwrap<Int> l$min_eth@839@01) 0))
; [eval] $unwrap(l$min_tokens) > 0
; [eval] $unwrap(l$min_tokens)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (> ($unwrap<Int> l$min_eth@839@01) 0)
  (not (> ($unwrap<Int> l$min_eth@839@01) 0))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (>
    ($unwrap<Int> l$deadline@841@01)
    ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
  (and
    (>
      ($unwrap<Int> l$deadline@841@01)
      ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
    (or
      (> ($unwrap<Int> l$min_eth@839@01) 0)
      (not (> ($unwrap<Int> l$min_eth@839@01) 0))))))
(assert (or
  (>
    ($unwrap<Int> l$deadline@841@01)
    ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
  (not
    (>
      ($unwrap<Int> l$deadline@841@01)
      ($struct_get<Int> ($struct_loc<Int> block@845@01 4))))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  (> ($unwrap<Int> l$amount@838@01) 0)
  (and
    (> ($unwrap<Int> l$amount@838@01) 0)
    (=>
      (>
        ($unwrap<Int> l$deadline@841@01)
        ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
      (and
        (>
          ($unwrap<Int> l$deadline@841@01)
          ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
        (or
          (> ($unwrap<Int> l$min_eth@839@01) 0)
          (not (> ($unwrap<Int> l$min_eth@839@01) 0)))))
    (or
      (>
        ($unwrap<Int> l$deadline@841@01)
        ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
      (not
        (>
          ($unwrap<Int> l$deadline@841@01)
          ($struct_get<Int> ($struct_loc<Int> block@845@01 4))))))))
(assert (or
  (> ($unwrap<Int> l$amount@838@01) 0)
  (not (> ($unwrap<Int> l$amount@838@01) 0))))
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (> ($unwrap<Int> l$amount@838@01) 0)
  (and
    (>
      ($unwrap<Int> l$deadline@841@01)
      ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
    (and
      (> ($unwrap<Int> l$min_eth@839@01) 0)
      (> ($unwrap<Int> l$min_tokens@840@01) 0))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (> ($unwrap<Int> l$amount@838@01) 0)
    (and
      (>
        ($unwrap<Int> l$deadline@841@01)
        ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
      (and
        (> ($unwrap<Int> l$min_eth@839@01) 0)
        (> ($unwrap<Int> l$min_tokens@840@01) 0)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 219 | !($unwrap[Int](l$amount@838@01) > 0 && $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)) && $unwrap[Int](l$min_eth@839@01) > 0 && $unwrap[Int](l$min_tokens@840@01) > 0) | live]
; [else-branch: 219 | $unwrap[Int](l$amount@838@01) > 0 && $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)) && $unwrap[Int](l$min_eth@839@01) > 0 && $unwrap[Int](l$min_tokens@840@01) > 0 | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 219 | !($unwrap[Int](l$amount@838@01) > 0 && $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)) && $unwrap[Int](l$min_eth@839@01) > 0 && $unwrap[Int](l$min_tokens@840@01) > 0)]
(assert (not
  (and
    (> ($unwrap<Int> l$amount@838@01) 0)
    (and
      (>
        ($unwrap<Int> l$deadline@841@01)
        ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
      (and
        (> ($unwrap<Int> l$min_eth@839@01) 0)
        (> ($unwrap<Int> l$min_tokens@840@01) 0))))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 220 | True | live]
; [else-branch: 220 | False | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 220 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@934@01 $Snap)
(assert (= $t@934@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@935@01 $Struct)
(assert (=
  self@935@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 4
; [then-branch: 221 | False | dead]
; [else-branch: 221 | True | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 221 | True]
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 219 | $unwrap[Int](l$amount@838@01) > 0 && $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)) && $unwrap[Int](l$min_eth@839@01) > 0 && $unwrap[Int](l$min_tokens@840@01) > 0]
(assert (and
  (> ($unwrap<Int> l$amount@838@01) 0)
  (and
    (>
      ($unwrap<Int> l$deadline@841@01)
      ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
    (and
      (> ($unwrap<Int> l$min_eth@839@01) 0)
      (> ($unwrap<Int> l$min_tokens@840@01) 0)))))
(pop) ; 3
; [eval] !!($unwrap(l$amount) > 0 && ($unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$min_eth) > 0 && $unwrap(l$min_tokens) > 0)))
; [eval] !($unwrap(l$amount) > 0 && ($unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$min_eth) > 0 && $unwrap(l$min_tokens) > 0)))
; [eval] $unwrap(l$amount) > 0 && ($unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int) && ($unwrap(l$min_eth) > 0 && $unwrap(l$min_tokens) > 0))
; [eval] $unwrap(l$amount) > 0
; [eval] $unwrap(l$amount)
(push) ; 3
; [then-branch: 222 | !($unwrap[Int](l$amount@838@01) > 0) | live]
; [else-branch: 222 | $unwrap[Int](l$amount@838@01) > 0 | live]
(push) ; 4
; [then-branch: 222 | !($unwrap[Int](l$amount@838@01) > 0)]
(assert (not (> ($unwrap<Int> l$amount@838@01) 0)))
(pop) ; 4
(push) ; 4
; [else-branch: 222 | $unwrap[Int](l$amount@838@01) > 0]
(assert (> ($unwrap<Int> l$amount@838@01) 0))
; [eval] $unwrap(l$deadline) > ($struct_get($struct_loc(block, 4)): Int)
; [eval] $unwrap(l$deadline)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(push) ; 5
; [then-branch: 223 | !($unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4))) | live]
; [else-branch: 223 | $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)) | live]
(push) ; 6
; [then-branch: 223 | !($unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)))]
(assert (not
  (>
    ($unwrap<Int> l$deadline@841@01)
    ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))))
(pop) ; 6
(push) ; 6
; [else-branch: 223 | $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4))]
(assert (>
  ($unwrap<Int> l$deadline@841@01)
  ($struct_get<Int> ($struct_loc<Int> block@845@01 4))))
; [eval] $unwrap(l$min_eth) > 0
; [eval] $unwrap(l$min_eth)
(push) ; 7
; [then-branch: 224 | !($unwrap[Int](l$min_eth@839@01) > 0) | live]
; [else-branch: 224 | $unwrap[Int](l$min_eth@839@01) > 0 | live]
(push) ; 8
; [then-branch: 224 | !($unwrap[Int](l$min_eth@839@01) > 0)]
(assert (not (> ($unwrap<Int> l$min_eth@839@01) 0)))
(pop) ; 8
(push) ; 8
; [else-branch: 224 | $unwrap[Int](l$min_eth@839@01) > 0]
(assert (> ($unwrap<Int> l$min_eth@839@01) 0))
; [eval] $unwrap(l$min_tokens) > 0
; [eval] $unwrap(l$min_tokens)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (> ($unwrap<Int> l$min_eth@839@01) 0)
  (not (> ($unwrap<Int> l$min_eth@839@01) 0))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (>
    ($unwrap<Int> l$deadline@841@01)
    ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
  (and
    (>
      ($unwrap<Int> l$deadline@841@01)
      ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
    (or
      (> ($unwrap<Int> l$min_eth@839@01) 0)
      (not (> ($unwrap<Int> l$min_eth@839@01) 0))))))
(assert (or
  (>
    ($unwrap<Int> l$deadline@841@01)
    ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
  (not
    (>
      ($unwrap<Int> l$deadline@841@01)
      ($struct_get<Int> ($struct_loc<Int> block@845@01 4))))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (> ($unwrap<Int> l$amount@838@01) 0)
    (and
      (>
        ($unwrap<Int> l$deadline@841@01)
        ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
      (and
        (> ($unwrap<Int> l$min_eth@839@01) 0)
        (> ($unwrap<Int> l$min_tokens@840@01) 0)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (> ($unwrap<Int> l$amount@838@01) 0)
  (and
    (>
      ($unwrap<Int> l$deadline@841@01)
      ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
    (and
      (> ($unwrap<Int> l$min_eth@839@01) 0)
      (> ($unwrap<Int> l$min_tokens@840@01) 0))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 225 | $unwrap[Int](l$amount@838@01) > 0 && $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)) && $unwrap[Int](l$min_eth@839@01) > 0 && $unwrap[Int](l$min_tokens@840@01) > 0 | live]
; [else-branch: 225 | !($unwrap[Int](l$amount@838@01) > 0 && $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)) && $unwrap[Int](l$min_eth@839@01) > 0 && $unwrap[Int](l$min_tokens@840@01) > 0) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 225 | $unwrap[Int](l$amount@838@01) > 0 && $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)) && $unwrap[Int](l$min_eth@839@01) > 0 && $unwrap[Int](l$min_tokens@840@01) > 0]
(assert (and
  (> ($unwrap<Int> l$amount@838@01) 0)
  (and
    (>
      ($unwrap<Int> l$deadline@841@01)
      ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
    (and
      (> ($unwrap<Int> l$min_eth@839@01) 0)
      (> ($unwrap<Int> l$min_tokens@840@01) 0)))))
; [exec]
; l$total_liquidity := $wrap(($struct_get($struct_loc(self, 3)): Int))
; [eval] $wrap(($struct_get($struct_loc(self, 3)): Int))
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(declare-const l$total_liquidity@936@01 $Int)
(assert (=
  l$total_liquidity@936@01
  ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 3)))))
; [eval] !($unwrap(l$total_liquidity) > 0)
; [eval] $unwrap(l$total_liquidity) > 0
; [eval] $unwrap(l$total_liquidity)
(push) ; 4
(set-option :timeout 10)
(assert (not (> ($unwrap<Int> l$total_liquidity@936@01) 0)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (> ($unwrap<Int> l$total_liquidity@936@01) 0))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 226 | !($unwrap[Int](l$total_liquidity@936@01) > 0) | live]
; [else-branch: 226 | $unwrap[Int](l$total_liquidity@936@01) > 0 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 226 | !($unwrap[Int](l$total_liquidity@936@01) > 0)]
(assert (not (> ($unwrap<Int> l$total_liquidity@936@01) 0)))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 5
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 227 | True | live]
; [else-branch: 227 | False | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 227 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@937@01 $Snap)
(assert (= $t@937@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@938@01 $Struct)
(assert (=
  self@938@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 5
; [then-branch: 228 | False | dead]
; [else-branch: 228 | True | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 228 | True]
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 226 | $unwrap[Int](l$total_liquidity@936@01) > 0]
(assert (> ($unwrap<Int> l$total_liquidity@936@01) 0))
(pop) ; 4
; [eval] !!($unwrap(l$total_liquidity) > 0)
; [eval] !($unwrap(l$total_liquidity) > 0)
; [eval] $unwrap(l$total_liquidity) > 0
; [eval] $unwrap(l$total_liquidity)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (> ($unwrap<Int> l$total_liquidity@936@01) 0))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (> ($unwrap<Int> l$total_liquidity@936@01) 0)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 229 | $unwrap[Int](l$total_liquidity@936@01) > 0 | live]
; [else-branch: 229 | !($unwrap[Int](l$total_liquidity@936@01) > 0) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 229 | $unwrap[Int](l$total_liquidity@936@01) > 0]
(assert (> ($unwrap<Int> l$total_liquidity@936@01) 0))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@939@01 Int)
(declare-const $arg1@940@01 Int)
(declare-const $arg2@941@01 Int)
(push) ; 5
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
(declare-const sm@942@01 $PSF<e$TokenPurchase>)
(declare-const s@943@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@944@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef61|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef62|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@939@01)
    ($SortWrappers.IntTo$Snap $arg1@940@01))
  ($SortWrappers.IntTo$Snap $arg2@941@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@939@01)
    ($SortWrappers.IntTo$Snap $arg1@940@01))
  ($SortWrappers.IntTo$Snap $arg2@941@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@939@01)
      ($SortWrappers.IntTo$Snap $arg1@940@01))
    ($SortWrappers.IntTo$Snap $arg2@941@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@945@01 (Int Int Int) Int)
(declare-fun img@946@01 (Int Int Int) Bool)
(declare-fun inv@947@01 (Int Int Int) Int)
(declare-fun img@948@01 (Int Int Int) Bool)
(declare-fun inv@949@01 (Int Int Int) Int)
(declare-fun img@950@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef61|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef62|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@939@01 Int) ($arg1@940@01 Int) ($arg2@941@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@939@01)
          ($SortWrappers.IntTo$Snap $arg1@940@01))
        ($SortWrappers.IntTo$Snap $arg2@941@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@939@01)
        ($SortWrappers.IntTo$Snap $arg1@940@01))
      ($SortWrappers.IntTo$Snap $arg2@941@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@939@01)
        ($SortWrappers.IntTo$Snap $arg1@940@01))
      ($SortWrappers.IntTo$Snap $arg2@941@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@939@01)
      ($SortWrappers.IntTo$Snap $arg1@940@01))
    ($SortWrappers.IntTo$Snap $arg2@941@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@939@01)
      ($SortWrappers.IntTo$Snap $arg1@940@01))
    ($SortWrappers.IntTo$Snap $arg2@941@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 5
(assert (not (forall (($arg0@939@01 Int) ($arg1@940@01 Int) ($arg2@941@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@939@01)
          ($SortWrappers.IntTo$Snap $arg1@940@01))
        ($SortWrappers.IntTo$Snap $arg2@941@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@939@01)
            ($SortWrappers.IntTo$Snap $arg1@940@01))
          ($SortWrappers.IntTo$Snap $arg2@941@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@939@01)
            ($SortWrappers.IntTo$Snap $arg1@940@01))
          ($SortWrappers.IntTo$Snap $arg2@941@01))))))
  
  :qid |quant-u-1669|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@939@01 Int) ($arg11@940@01 Int) ($arg21@941@01 Int) ($arg02@939@01 Int) ($arg12@940@01 Int) ($arg22@941@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@939@01)
                ($SortWrappers.IntTo$Snap $arg11@940@01))
              ($SortWrappers.IntTo$Snap $arg21@941@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@939@01)
              ($SortWrappers.IntTo$Snap $arg11@940@01))
            ($SortWrappers.IntTo$Snap $arg21@941@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@939@01)
              ($SortWrappers.IntTo$Snap $arg11@940@01))
            ($SortWrappers.IntTo$Snap $arg21@941@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@939@01)
              ($SortWrappers.IntTo$Snap $arg11@940@01))
            ($SortWrappers.IntTo$Snap $arg21@941@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@939@01)
                ($SortWrappers.IntTo$Snap $arg12@940@01))
              ($SortWrappers.IntTo$Snap $arg22@941@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@939@01)
              ($SortWrappers.IntTo$Snap $arg12@940@01))
            ($SortWrappers.IntTo$Snap $arg22@941@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@939@01)
              ($SortWrappers.IntTo$Snap $arg12@940@01))
            ($SortWrappers.IntTo$Snap $arg22@941@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@939@01)
              ($SortWrappers.IntTo$Snap $arg12@940@01))
            ($SortWrappers.IntTo$Snap $arg22@941@01)))))
      (and
        (and (= $arg01@939@01 $arg02@939@01) (= $arg11@940@01 $arg12@940@01))
        (= $arg21@941@01 $arg22@941@01)))
    (and
      (and (= $arg01@939@01 $arg02@939@01) (= $arg11@940@01 $arg12@940@01))
      (= $arg21@941@01 $arg22@941@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@939@01 Int) ($arg1@940@01 Int) ($arg2@941@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@939@01)
            ($SortWrappers.IntTo$Snap $arg1@940@01))
          ($SortWrappers.IntTo$Snap $arg2@941@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@939@01)
            ($SortWrappers.IntTo$Snap $arg1@940@01))
          ($SortWrappers.IntTo$Snap $arg2@941@01)))))
    (and
      (and
        (= (inv@945@01 $arg0@939@01 $arg1@940@01 $arg2@941@01) $arg0@939@01)
        (= (inv@947@01 $arg0@939@01 $arg1@940@01 $arg2@941@01) $arg1@940@01)
        (= (inv@949@01 $arg0@939@01 $arg1@940@01 $arg2@941@01) $arg2@941@01))
      (and
        (img@946@01 $arg0@939@01 $arg1@940@01 $arg2@941@01)
        (img@948@01 $arg0@939@01 $arg1@940@01 $arg2@941@01)
        (img@950@01 $arg0@939@01 $arg1@940@01 $arg2@941@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@939@01)
      ($SortWrappers.IntTo$Snap $arg1@940@01))
    ($SortWrappers.IntTo$Snap $arg2@941@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@939@01)
      ($SortWrappers.IntTo$Snap $arg1@940@01))
    ($SortWrappers.IntTo$Snap $arg2@941@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@946@01 $arg0 $arg1 $arg2)
        (img@948@01 $arg0 $arg1 $arg2)
        (img@950@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@945@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@947@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@949@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@945@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@947@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@949@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@945@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@947@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@949@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@945@01 $arg0 $arg1 $arg2))
  :pattern ((inv@947@01 $arg0 $arg1 $arg2))
  :pattern ((inv@949@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@945@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@947@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@949@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@945@01 $arg0 $arg1 $arg2) (inv@947@01 $arg0 $arg1 $arg2) (inv@949@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1670|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@945@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@947@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@949@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@946@01 $arg0 $arg1 $arg2)
        (img@948@01 $arg0 $arg1 $arg2)
        (img@950@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@945@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@947@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@949@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@944@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@945@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@947@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@949@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1671|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@951@01 Int)
(declare-const $arg1@952@01 Int)
(declare-const $arg2@953@01 Int)
(push) ; 5
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
(declare-const sm@954@01 $PSF<e$EthPurchase>)
(declare-const s@955@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@956@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef64|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef65|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@951@01)
    ($SortWrappers.IntTo$Snap $arg1@952@01))
  ($SortWrappers.IntTo$Snap $arg2@953@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@951@01)
    ($SortWrappers.IntTo$Snap $arg1@952@01))
  ($SortWrappers.IntTo$Snap $arg2@953@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@951@01)
      ($SortWrappers.IntTo$Snap $arg1@952@01))
    ($SortWrappers.IntTo$Snap $arg2@953@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@957@01 (Int Int Int) Int)
(declare-fun img@958@01 (Int Int Int) Bool)
(declare-fun inv@959@01 (Int Int Int) Int)
(declare-fun img@960@01 (Int Int Int) Bool)
(declare-fun inv@961@01 (Int Int Int) Int)
(declare-fun img@962@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef64|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef65|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@951@01 Int) ($arg1@952@01 Int) ($arg2@953@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@951@01)
          ($SortWrappers.IntTo$Snap $arg1@952@01))
        ($SortWrappers.IntTo$Snap $arg2@953@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@951@01)
        ($SortWrappers.IntTo$Snap $arg1@952@01))
      ($SortWrappers.IntTo$Snap $arg2@953@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@951@01)
        ($SortWrappers.IntTo$Snap $arg1@952@01))
      ($SortWrappers.IntTo$Snap $arg2@953@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@951@01)
      ($SortWrappers.IntTo$Snap $arg1@952@01))
    ($SortWrappers.IntTo$Snap $arg2@953@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@951@01)
      ($SortWrappers.IntTo$Snap $arg1@952@01))
    ($SortWrappers.IntTo$Snap $arg2@953@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 5
(assert (not (forall (($arg0@951@01 Int) ($arg1@952@01 Int) ($arg2@953@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@951@01)
          ($SortWrappers.IntTo$Snap $arg1@952@01))
        ($SortWrappers.IntTo$Snap $arg2@953@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@951@01)
            ($SortWrappers.IntTo$Snap $arg1@952@01))
          ($SortWrappers.IntTo$Snap $arg2@953@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@951@01)
            ($SortWrappers.IntTo$Snap $arg1@952@01))
          ($SortWrappers.IntTo$Snap $arg2@953@01))))))
  
  :qid |quant-u-1672|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@951@01 Int) ($arg11@952@01 Int) ($arg21@953@01 Int) ($arg02@951@01 Int) ($arg12@952@01 Int) ($arg22@953@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@951@01)
                ($SortWrappers.IntTo$Snap $arg11@952@01))
              ($SortWrappers.IntTo$Snap $arg21@953@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@951@01)
              ($SortWrappers.IntTo$Snap $arg11@952@01))
            ($SortWrappers.IntTo$Snap $arg21@953@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@951@01)
              ($SortWrappers.IntTo$Snap $arg11@952@01))
            ($SortWrappers.IntTo$Snap $arg21@953@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@951@01)
              ($SortWrappers.IntTo$Snap $arg11@952@01))
            ($SortWrappers.IntTo$Snap $arg21@953@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@951@01)
                ($SortWrappers.IntTo$Snap $arg12@952@01))
              ($SortWrappers.IntTo$Snap $arg22@953@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@951@01)
              ($SortWrappers.IntTo$Snap $arg12@952@01))
            ($SortWrappers.IntTo$Snap $arg22@953@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@951@01)
              ($SortWrappers.IntTo$Snap $arg12@952@01))
            ($SortWrappers.IntTo$Snap $arg22@953@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@951@01)
              ($SortWrappers.IntTo$Snap $arg12@952@01))
            ($SortWrappers.IntTo$Snap $arg22@953@01)))))
      (and
        (and (= $arg01@951@01 $arg02@951@01) (= $arg11@952@01 $arg12@952@01))
        (= $arg21@953@01 $arg22@953@01)))
    (and
      (and (= $arg01@951@01 $arg02@951@01) (= $arg11@952@01 $arg12@952@01))
      (= $arg21@953@01 $arg22@953@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@951@01 Int) ($arg1@952@01 Int) ($arg2@953@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@951@01)
            ($SortWrappers.IntTo$Snap $arg1@952@01))
          ($SortWrappers.IntTo$Snap $arg2@953@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@951@01)
            ($SortWrappers.IntTo$Snap $arg1@952@01))
          ($SortWrappers.IntTo$Snap $arg2@953@01)))))
    (and
      (and
        (= (inv@957@01 $arg0@951@01 $arg1@952@01 $arg2@953@01) $arg0@951@01)
        (= (inv@959@01 $arg0@951@01 $arg1@952@01 $arg2@953@01) $arg1@952@01)
        (= (inv@961@01 $arg0@951@01 $arg1@952@01 $arg2@953@01) $arg2@953@01))
      (and
        (img@958@01 $arg0@951@01 $arg1@952@01 $arg2@953@01)
        (img@960@01 $arg0@951@01 $arg1@952@01 $arg2@953@01)
        (img@962@01 $arg0@951@01 $arg1@952@01 $arg2@953@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@951@01)
      ($SortWrappers.IntTo$Snap $arg1@952@01))
    ($SortWrappers.IntTo$Snap $arg2@953@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@951@01)
      ($SortWrappers.IntTo$Snap $arg1@952@01))
    ($SortWrappers.IntTo$Snap $arg2@953@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@958@01 $arg0 $arg1 $arg2)
        (img@960@01 $arg0 $arg1 $arg2)
        (img@962@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@957@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@959@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@961@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@957@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@959@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@961@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@957@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@959@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@961@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@957@01 $arg0 $arg1 $arg2))
  :pattern ((inv@959@01 $arg0 $arg1 $arg2))
  :pattern ((inv@961@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@957@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@959@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@961@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@957@01 $arg0 $arg1 $arg2) (inv@959@01 $arg0 $arg1 $arg2) (inv@961@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1673|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@957@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@959@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@961@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@958@01 $arg0 $arg1 $arg2)
        (img@960@01 $arg0 $arg1 $arg2)
        (img@962@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@957@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@959@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@961@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@956@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@957@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@959@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@961@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1674|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@963@01 Int)
(declare-const $arg1@964@01 Int)
(declare-const $arg2@965@01 Int)
(push) ; 5
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
(declare-const sm@966@01 $PSF<e$AddLiquidity>)
(declare-const s@967@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@968@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef67|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef68|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@963@01)
    ($SortWrappers.IntTo$Snap $arg1@964@01))
  ($SortWrappers.IntTo$Snap $arg2@965@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@963@01)
    ($SortWrappers.IntTo$Snap $arg1@964@01))
  ($SortWrappers.IntTo$Snap $arg2@965@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@963@01)
      ($SortWrappers.IntTo$Snap $arg1@964@01))
    ($SortWrappers.IntTo$Snap $arg2@965@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@969@01 (Int Int Int) Int)
(declare-fun img@970@01 (Int Int Int) Bool)
(declare-fun inv@971@01 (Int Int Int) Int)
(declare-fun img@972@01 (Int Int Int) Bool)
(declare-fun inv@973@01 (Int Int Int) Int)
(declare-fun img@974@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef67|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef68|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@963@01 Int) ($arg1@964@01 Int) ($arg2@965@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@963@01)
          ($SortWrappers.IntTo$Snap $arg1@964@01))
        ($SortWrappers.IntTo$Snap $arg2@965@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@963@01)
        ($SortWrappers.IntTo$Snap $arg1@964@01))
      ($SortWrappers.IntTo$Snap $arg2@965@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@963@01)
        ($SortWrappers.IntTo$Snap $arg1@964@01))
      ($SortWrappers.IntTo$Snap $arg2@965@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@963@01)
      ($SortWrappers.IntTo$Snap $arg1@964@01))
    ($SortWrappers.IntTo$Snap $arg2@965@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@963@01)
      ($SortWrappers.IntTo$Snap $arg1@964@01))
    ($SortWrappers.IntTo$Snap $arg2@965@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 5
(assert (not (forall (($arg0@963@01 Int) ($arg1@964@01 Int) ($arg2@965@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@963@01)
          ($SortWrappers.IntTo$Snap $arg1@964@01))
        ($SortWrappers.IntTo$Snap $arg2@965@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@963@01)
            ($SortWrappers.IntTo$Snap $arg1@964@01))
          ($SortWrappers.IntTo$Snap $arg2@965@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@963@01)
            ($SortWrappers.IntTo$Snap $arg1@964@01))
          ($SortWrappers.IntTo$Snap $arg2@965@01))))))
  
  :qid |quant-u-1675|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@963@01 Int) ($arg11@964@01 Int) ($arg21@965@01 Int) ($arg02@963@01 Int) ($arg12@964@01 Int) ($arg22@965@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@963@01)
                ($SortWrappers.IntTo$Snap $arg11@964@01))
              ($SortWrappers.IntTo$Snap $arg21@965@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@963@01)
              ($SortWrappers.IntTo$Snap $arg11@964@01))
            ($SortWrappers.IntTo$Snap $arg21@965@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@963@01)
              ($SortWrappers.IntTo$Snap $arg11@964@01))
            ($SortWrappers.IntTo$Snap $arg21@965@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@963@01)
              ($SortWrappers.IntTo$Snap $arg11@964@01))
            ($SortWrappers.IntTo$Snap $arg21@965@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@963@01)
                ($SortWrappers.IntTo$Snap $arg12@964@01))
              ($SortWrappers.IntTo$Snap $arg22@965@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@963@01)
              ($SortWrappers.IntTo$Snap $arg12@964@01))
            ($SortWrappers.IntTo$Snap $arg22@965@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@963@01)
              ($SortWrappers.IntTo$Snap $arg12@964@01))
            ($SortWrappers.IntTo$Snap $arg22@965@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@963@01)
              ($SortWrappers.IntTo$Snap $arg12@964@01))
            ($SortWrappers.IntTo$Snap $arg22@965@01)))))
      (and
        (and (= $arg01@963@01 $arg02@963@01) (= $arg11@964@01 $arg12@964@01))
        (= $arg21@965@01 $arg22@965@01)))
    (and
      (and (= $arg01@963@01 $arg02@963@01) (= $arg11@964@01 $arg12@964@01))
      (= $arg21@965@01 $arg22@965@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@963@01 Int) ($arg1@964@01 Int) ($arg2@965@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@963@01)
            ($SortWrappers.IntTo$Snap $arg1@964@01))
          ($SortWrappers.IntTo$Snap $arg2@965@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@963@01)
            ($SortWrappers.IntTo$Snap $arg1@964@01))
          ($SortWrappers.IntTo$Snap $arg2@965@01)))))
    (and
      (and
        (= (inv@969@01 $arg0@963@01 $arg1@964@01 $arg2@965@01) $arg0@963@01)
        (= (inv@971@01 $arg0@963@01 $arg1@964@01 $arg2@965@01) $arg1@964@01)
        (= (inv@973@01 $arg0@963@01 $arg1@964@01 $arg2@965@01) $arg2@965@01))
      (and
        (img@970@01 $arg0@963@01 $arg1@964@01 $arg2@965@01)
        (img@972@01 $arg0@963@01 $arg1@964@01 $arg2@965@01)
        (img@974@01 $arg0@963@01 $arg1@964@01 $arg2@965@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@963@01)
      ($SortWrappers.IntTo$Snap $arg1@964@01))
    ($SortWrappers.IntTo$Snap $arg2@965@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@963@01)
      ($SortWrappers.IntTo$Snap $arg1@964@01))
    ($SortWrappers.IntTo$Snap $arg2@965@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@970@01 $arg0 $arg1 $arg2)
        (img@972@01 $arg0 $arg1 $arg2)
        (img@974@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@969@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@971@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@973@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@969@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@971@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@973@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@969@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@971@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@973@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@969@01 $arg0 $arg1 $arg2))
  :pattern ((inv@971@01 $arg0 $arg1 $arg2))
  :pattern ((inv@973@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@969@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@971@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@973@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@969@01 $arg0 $arg1 $arg2) (inv@971@01 $arg0 $arg1 $arg2) (inv@973@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1676|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@969@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@971@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@973@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@970@01 $arg0 $arg1 $arg2)
        (img@972@01 $arg0 $arg1 $arg2)
        (img@974@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@969@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@971@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@973@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@968@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@969@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@971@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@973@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1677|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@975@01 Int)
(declare-const $arg1@976@01 Int)
(declare-const $arg2@977@01 Int)
(push) ; 5
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
(declare-const sm@978@01 $PSF<e$RemoveLiquidity>)
(declare-const s@979@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@980@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef70|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef71|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@975@01)
    ($SortWrappers.IntTo$Snap $arg1@976@01))
  ($SortWrappers.IntTo$Snap $arg2@977@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@975@01)
    ($SortWrappers.IntTo$Snap $arg1@976@01))
  ($SortWrappers.IntTo$Snap $arg2@977@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@975@01)
      ($SortWrappers.IntTo$Snap $arg1@976@01))
    ($SortWrappers.IntTo$Snap $arg2@977@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@981@01 (Int Int Int) Int)
(declare-fun img@982@01 (Int Int Int) Bool)
(declare-fun inv@983@01 (Int Int Int) Int)
(declare-fun img@984@01 (Int Int Int) Bool)
(declare-fun inv@985@01 (Int Int Int) Int)
(declare-fun img@986@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef70|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef71|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@975@01 Int) ($arg1@976@01 Int) ($arg2@977@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@975@01)
          ($SortWrappers.IntTo$Snap $arg1@976@01))
        ($SortWrappers.IntTo$Snap $arg2@977@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@975@01)
        ($SortWrappers.IntTo$Snap $arg1@976@01))
      ($SortWrappers.IntTo$Snap $arg2@977@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@975@01)
        ($SortWrappers.IntTo$Snap $arg1@976@01))
      ($SortWrappers.IntTo$Snap $arg2@977@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@975@01)
      ($SortWrappers.IntTo$Snap $arg1@976@01))
    ($SortWrappers.IntTo$Snap $arg2@977@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@975@01)
      ($SortWrappers.IntTo$Snap $arg1@976@01))
    ($SortWrappers.IntTo$Snap $arg2@977@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 5
(assert (not (forall (($arg0@975@01 Int) ($arg1@976@01 Int) ($arg2@977@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@975@01)
          ($SortWrappers.IntTo$Snap $arg1@976@01))
        ($SortWrappers.IntTo$Snap $arg2@977@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@975@01)
            ($SortWrappers.IntTo$Snap $arg1@976@01))
          ($SortWrappers.IntTo$Snap $arg2@977@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@975@01)
            ($SortWrappers.IntTo$Snap $arg1@976@01))
          ($SortWrappers.IntTo$Snap $arg2@977@01))))))
  
  :qid |quant-u-1678|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@975@01 Int) ($arg11@976@01 Int) ($arg21@977@01 Int) ($arg02@975@01 Int) ($arg12@976@01 Int) ($arg22@977@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@975@01)
                ($SortWrappers.IntTo$Snap $arg11@976@01))
              ($SortWrappers.IntTo$Snap $arg21@977@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@975@01)
              ($SortWrappers.IntTo$Snap $arg11@976@01))
            ($SortWrappers.IntTo$Snap $arg21@977@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@975@01)
              ($SortWrappers.IntTo$Snap $arg11@976@01))
            ($SortWrappers.IntTo$Snap $arg21@977@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@975@01)
              ($SortWrappers.IntTo$Snap $arg11@976@01))
            ($SortWrappers.IntTo$Snap $arg21@977@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@975@01)
                ($SortWrappers.IntTo$Snap $arg12@976@01))
              ($SortWrappers.IntTo$Snap $arg22@977@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@975@01)
              ($SortWrappers.IntTo$Snap $arg12@976@01))
            ($SortWrappers.IntTo$Snap $arg22@977@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@975@01)
              ($SortWrappers.IntTo$Snap $arg12@976@01))
            ($SortWrappers.IntTo$Snap $arg22@977@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@975@01)
              ($SortWrappers.IntTo$Snap $arg12@976@01))
            ($SortWrappers.IntTo$Snap $arg22@977@01)))))
      (and
        (and (= $arg01@975@01 $arg02@975@01) (= $arg11@976@01 $arg12@976@01))
        (= $arg21@977@01 $arg22@977@01)))
    (and
      (and (= $arg01@975@01 $arg02@975@01) (= $arg11@976@01 $arg12@976@01))
      (= $arg21@977@01 $arg22@977@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@975@01 Int) ($arg1@976@01 Int) ($arg2@977@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@975@01)
            ($SortWrappers.IntTo$Snap $arg1@976@01))
          ($SortWrappers.IntTo$Snap $arg2@977@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@975@01)
            ($SortWrappers.IntTo$Snap $arg1@976@01))
          ($SortWrappers.IntTo$Snap $arg2@977@01)))))
    (and
      (and
        (= (inv@981@01 $arg0@975@01 $arg1@976@01 $arg2@977@01) $arg0@975@01)
        (= (inv@983@01 $arg0@975@01 $arg1@976@01 $arg2@977@01) $arg1@976@01)
        (= (inv@985@01 $arg0@975@01 $arg1@976@01 $arg2@977@01) $arg2@977@01))
      (and
        (img@982@01 $arg0@975@01 $arg1@976@01 $arg2@977@01)
        (img@984@01 $arg0@975@01 $arg1@976@01 $arg2@977@01)
        (img@986@01 $arg0@975@01 $arg1@976@01 $arg2@977@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@975@01)
      ($SortWrappers.IntTo$Snap $arg1@976@01))
    ($SortWrappers.IntTo$Snap $arg2@977@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@975@01)
      ($SortWrappers.IntTo$Snap $arg1@976@01))
    ($SortWrappers.IntTo$Snap $arg2@977@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@982@01 $arg0 $arg1 $arg2)
        (img@984@01 $arg0 $arg1 $arg2)
        (img@986@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@981@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@983@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@985@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@981@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@983@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@985@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@981@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@983@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@985@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@981@01 $arg0 $arg1 $arg2))
  :pattern ((inv@983@01 $arg0 $arg1 $arg2))
  :pattern ((inv@985@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@981@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@983@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@985@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@981@01 $arg0 $arg1 $arg2) (inv@983@01 $arg0 $arg1 $arg2) (inv@985@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1679|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@981@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@983@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@985@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@982@01 $arg0 $arg1 $arg2)
        (img@984@01 $arg0 $arg1 $arg2)
        (img@986@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@981@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@983@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@985@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@980@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@981@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@983@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@985@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1680|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@987@01 Int)
(declare-const $arg1@988@01 Int)
(declare-const $arg2@989@01 Int)
(push) ; 5
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
(declare-const sm@990@01 $PSF<e$Transfer>)
(declare-const s@991@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@992@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef73|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef74|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@987@01)
    ($SortWrappers.IntTo$Snap $arg1@988@01))
  ($SortWrappers.IntTo$Snap $arg2@989@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@987@01)
    ($SortWrappers.IntTo$Snap $arg1@988@01))
  ($SortWrappers.IntTo$Snap $arg2@989@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@987@01)
      ($SortWrappers.IntTo$Snap $arg1@988@01))
    ($SortWrappers.IntTo$Snap $arg2@989@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@993@01 (Int Int Int) Int)
(declare-fun img@994@01 (Int Int Int) Bool)
(declare-fun inv@995@01 (Int Int Int) Int)
(declare-fun img@996@01 (Int Int Int) Bool)
(declare-fun inv@997@01 (Int Int Int) Int)
(declare-fun img@998@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef73|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef74|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@987@01 Int) ($arg1@988@01 Int) ($arg2@989@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@987@01)
          ($SortWrappers.IntTo$Snap $arg1@988@01))
        ($SortWrappers.IntTo$Snap $arg2@989@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@987@01)
        ($SortWrappers.IntTo$Snap $arg1@988@01))
      ($SortWrappers.IntTo$Snap $arg2@989@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@987@01)
        ($SortWrappers.IntTo$Snap $arg1@988@01))
      ($SortWrappers.IntTo$Snap $arg2@989@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@987@01)
      ($SortWrappers.IntTo$Snap $arg1@988@01))
    ($SortWrappers.IntTo$Snap $arg2@989@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@987@01)
      ($SortWrappers.IntTo$Snap $arg1@988@01))
    ($SortWrappers.IntTo$Snap $arg2@989@01))))
  :qid |e$Transfer-aux|)))
(push) ; 5
(assert (not (forall (($arg0@987@01 Int) ($arg1@988@01 Int) ($arg2@989@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@987@01)
          ($SortWrappers.IntTo$Snap $arg1@988@01))
        ($SortWrappers.IntTo$Snap $arg2@989@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@987@01)
            ($SortWrappers.IntTo$Snap $arg1@988@01))
          ($SortWrappers.IntTo$Snap $arg2@989@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@987@01)
            ($SortWrappers.IntTo$Snap $arg1@988@01))
          ($SortWrappers.IntTo$Snap $arg2@989@01))))))
  
  :qid |quant-u-1681|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@987@01 Int) ($arg11@988@01 Int) ($arg21@989@01 Int) ($arg02@987@01 Int) ($arg12@988@01 Int) ($arg22@989@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@987@01)
                ($SortWrappers.IntTo$Snap $arg11@988@01))
              ($SortWrappers.IntTo$Snap $arg21@989@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@987@01)
              ($SortWrappers.IntTo$Snap $arg11@988@01))
            ($SortWrappers.IntTo$Snap $arg21@989@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@987@01)
              ($SortWrappers.IntTo$Snap $arg11@988@01))
            ($SortWrappers.IntTo$Snap $arg21@989@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@987@01)
              ($SortWrappers.IntTo$Snap $arg11@988@01))
            ($SortWrappers.IntTo$Snap $arg21@989@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@987@01)
                ($SortWrappers.IntTo$Snap $arg12@988@01))
              ($SortWrappers.IntTo$Snap $arg22@989@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@987@01)
              ($SortWrappers.IntTo$Snap $arg12@988@01))
            ($SortWrappers.IntTo$Snap $arg22@989@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@987@01)
              ($SortWrappers.IntTo$Snap $arg12@988@01))
            ($SortWrappers.IntTo$Snap $arg22@989@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@987@01)
              ($SortWrappers.IntTo$Snap $arg12@988@01))
            ($SortWrappers.IntTo$Snap $arg22@989@01)))))
      (and
        (and (= $arg01@987@01 $arg02@987@01) (= $arg11@988@01 $arg12@988@01))
        (= $arg21@989@01 $arg22@989@01)))
    (and
      (and (= $arg01@987@01 $arg02@987@01) (= $arg11@988@01 $arg12@988@01))
      (= $arg21@989@01 $arg22@989@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@987@01 Int) ($arg1@988@01 Int) ($arg2@989@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@987@01)
            ($SortWrappers.IntTo$Snap $arg1@988@01))
          ($SortWrappers.IntTo$Snap $arg2@989@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@987@01)
            ($SortWrappers.IntTo$Snap $arg1@988@01))
          ($SortWrappers.IntTo$Snap $arg2@989@01)))))
    (and
      (and
        (= (inv@993@01 $arg0@987@01 $arg1@988@01 $arg2@989@01) $arg0@987@01)
        (= (inv@995@01 $arg0@987@01 $arg1@988@01 $arg2@989@01) $arg1@988@01)
        (= (inv@997@01 $arg0@987@01 $arg1@988@01 $arg2@989@01) $arg2@989@01))
      (and
        (img@994@01 $arg0@987@01 $arg1@988@01 $arg2@989@01)
        (img@996@01 $arg0@987@01 $arg1@988@01 $arg2@989@01)
        (img@998@01 $arg0@987@01 $arg1@988@01 $arg2@989@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@987@01)
      ($SortWrappers.IntTo$Snap $arg1@988@01))
    ($SortWrappers.IntTo$Snap $arg2@989@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@987@01)
      ($SortWrappers.IntTo$Snap $arg1@988@01))
    ($SortWrappers.IntTo$Snap $arg2@989@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@994@01 $arg0 $arg1 $arg2)
        (img@996@01 $arg0 $arg1 $arg2)
        (img@998@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@993@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@995@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@997@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@993@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@995@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@997@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@993@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@995@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@997@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@993@01 $arg0 $arg1 $arg2))
  :pattern ((inv@995@01 $arg0 $arg1 $arg2))
  :pattern ((inv@997@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@993@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@995@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@997@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@993@01 $arg0 $arg1 $arg2) (inv@995@01 $arg0 $arg1 $arg2) (inv@997@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1682|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@993@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@995@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@997@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@994@01 $arg0 $arg1 $arg2)
        (img@996@01 $arg0 $arg1 $arg2)
        (img@998@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@993@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@995@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@997@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@992@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@993@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@995@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@997@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1683|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@999@01 Int)
(declare-const $arg1@1000@01 Int)
(declare-const $arg2@1001@01 Int)
(push) ; 5
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
(declare-const sm@1002@01 $PSF<e$Approval>)
(declare-const s@1003@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1004@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef76|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef77|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@999@01)
    ($SortWrappers.IntTo$Snap $arg1@1000@01))
  ($SortWrappers.IntTo$Snap $arg2@1001@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@999@01)
    ($SortWrappers.IntTo$Snap $arg1@1000@01))
  ($SortWrappers.IntTo$Snap $arg2@1001@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@999@01)
      ($SortWrappers.IntTo$Snap $arg1@1000@01))
    ($SortWrappers.IntTo$Snap $arg2@1001@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@1005@01 (Int Int Int) Int)
(declare-fun img@1006@01 (Int Int Int) Bool)
(declare-fun inv@1007@01 (Int Int Int) Int)
(declare-fun img@1008@01 (Int Int Int) Bool)
(declare-fun inv@1009@01 (Int Int Int) Int)
(declare-fun img@1010@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef76|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef77|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@999@01 Int) ($arg1@1000@01 Int) ($arg2@1001@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@999@01)
          ($SortWrappers.IntTo$Snap $arg1@1000@01))
        ($SortWrappers.IntTo$Snap $arg2@1001@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@999@01)
        ($SortWrappers.IntTo$Snap $arg1@1000@01))
      ($SortWrappers.IntTo$Snap $arg2@1001@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@999@01)
        ($SortWrappers.IntTo$Snap $arg1@1000@01))
      ($SortWrappers.IntTo$Snap $arg2@1001@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@999@01)
      ($SortWrappers.IntTo$Snap $arg1@1000@01))
    ($SortWrappers.IntTo$Snap $arg2@1001@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@999@01)
      ($SortWrappers.IntTo$Snap $arg1@1000@01))
    ($SortWrappers.IntTo$Snap $arg2@1001@01))))
  :qid |e$Approval-aux|)))
(push) ; 5
(assert (not (forall (($arg0@999@01 Int) ($arg1@1000@01 Int) ($arg2@1001@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@999@01)
          ($SortWrappers.IntTo$Snap $arg1@1000@01))
        ($SortWrappers.IntTo$Snap $arg2@1001@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@999@01)
            ($SortWrappers.IntTo$Snap $arg1@1000@01))
          ($SortWrappers.IntTo$Snap $arg2@1001@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@999@01)
            ($SortWrappers.IntTo$Snap $arg1@1000@01))
          ($SortWrappers.IntTo$Snap $arg2@1001@01))))))
  
  :qid |quant-u-1684|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@999@01 Int) ($arg11@1000@01 Int) ($arg21@1001@01 Int) ($arg02@999@01 Int) ($arg12@1000@01 Int) ($arg22@1001@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@999@01)
                ($SortWrappers.IntTo$Snap $arg11@1000@01))
              ($SortWrappers.IntTo$Snap $arg21@1001@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@999@01)
              ($SortWrappers.IntTo$Snap $arg11@1000@01))
            ($SortWrappers.IntTo$Snap $arg21@1001@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@999@01)
              ($SortWrappers.IntTo$Snap $arg11@1000@01))
            ($SortWrappers.IntTo$Snap $arg21@1001@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@999@01)
              ($SortWrappers.IntTo$Snap $arg11@1000@01))
            ($SortWrappers.IntTo$Snap $arg21@1001@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@999@01)
                ($SortWrappers.IntTo$Snap $arg12@1000@01))
              ($SortWrappers.IntTo$Snap $arg22@1001@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@999@01)
              ($SortWrappers.IntTo$Snap $arg12@1000@01))
            ($SortWrappers.IntTo$Snap $arg22@1001@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@999@01)
              ($SortWrappers.IntTo$Snap $arg12@1000@01))
            ($SortWrappers.IntTo$Snap $arg22@1001@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@999@01)
              ($SortWrappers.IntTo$Snap $arg12@1000@01))
            ($SortWrappers.IntTo$Snap $arg22@1001@01)))))
      (and
        (and (= $arg01@999@01 $arg02@999@01) (= $arg11@1000@01 $arg12@1000@01))
        (= $arg21@1001@01 $arg22@1001@01)))
    (and
      (and (= $arg01@999@01 $arg02@999@01) (= $arg11@1000@01 $arg12@1000@01))
      (= $arg21@1001@01 $arg22@1001@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@999@01 Int) ($arg1@1000@01 Int) ($arg2@1001@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@999@01)
            ($SortWrappers.IntTo$Snap $arg1@1000@01))
          ($SortWrappers.IntTo$Snap $arg2@1001@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@999@01)
            ($SortWrappers.IntTo$Snap $arg1@1000@01))
          ($SortWrappers.IntTo$Snap $arg2@1001@01)))))
    (and
      (and
        (= (inv@1005@01 $arg0@999@01 $arg1@1000@01 $arg2@1001@01) $arg0@999@01)
        (= (inv@1007@01 $arg0@999@01 $arg1@1000@01 $arg2@1001@01) $arg1@1000@01)
        (= (inv@1009@01 $arg0@999@01 $arg1@1000@01 $arg2@1001@01) $arg2@1001@01))
      (and
        (img@1006@01 $arg0@999@01 $arg1@1000@01 $arg2@1001@01)
        (img@1008@01 $arg0@999@01 $arg1@1000@01 $arg2@1001@01)
        (img@1010@01 $arg0@999@01 $arg1@1000@01 $arg2@1001@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@999@01)
      ($SortWrappers.IntTo$Snap $arg1@1000@01))
    ($SortWrappers.IntTo$Snap $arg2@1001@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@999@01)
      ($SortWrappers.IntTo$Snap $arg1@1000@01))
    ($SortWrappers.IntTo$Snap $arg2@1001@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1006@01 $arg0 $arg1 $arg2)
        (img@1008@01 $arg0 $arg1 $arg2)
        (img@1010@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1005@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1007@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1009@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1005@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1007@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1009@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1005@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1007@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1009@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1005@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1007@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1009@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1005@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1007@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1009@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1005@01 $arg0 $arg1 $arg2) (inv@1007@01 $arg0 $arg1 $arg2) (inv@1009@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1685|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1005@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1007@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1009@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1006@01 $arg0 $arg1 $arg2)
        (img@1008@01 $arg0 $arg1 $arg2)
        (img@1010@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1005@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1007@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1009@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@1004@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1005@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1007@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1009@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1686|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; inhale 0 <= l$raw_ret &&
;   l$raw_ret <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1011@01 $Snap)
(assert (= $t@1011@01 ($Snap.combine ($Snap.first $t@1011@01) ($Snap.second $t@1011@01))))
(assert (= ($Snap.first $t@1011@01) $Snap.unit))
; [eval] 0 <= l$raw_ret
(assert (<= 0 l$raw_ret@859@01))
(assert (= ($Snap.second $t@1011@01) $Snap.unit))
; [eval] l$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
(assert (<=
  l$raw_ret@859@01
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not l$send_fail@858@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not l$send_fail@858@01))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 230 | l$send_fail@858@01 | live]
; [else-branch: 230 | !(l$send_fail@858@01) | live]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 230 | l$send_fail@858@01]
(assert l$send_fail@858@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@1012@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 231 | True | live]
; [else-branch: 231 | False | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 231 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1013@01 $Snap)
(assert (= $t@1013@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1014@01 $Struct)
(assert (=
  self@1014@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 6
; [then-branch: 232 | False | dead]
; [else-branch: 232 | True | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 232 | True]
(pop) ; 6
(pop) ; 5
(push) ; 5
; [else-branch: 230 | !(l$send_fail@858@01)]
(assert (not l$send_fail@858@01))
(pop) ; 5
; [eval] !l$send_fail
(push) ; 5
(set-option :timeout 10)
(assert (not l$send_fail@858@01))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not l$send_fail@858@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 233 | !(l$send_fail@858@01) | live]
; [else-branch: 233 | l$send_fail@858@01 | live]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 233 | !(l$send_fail@858@01)]
(assert (not l$send_fail@858@01))
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; l$token_reserve := $wrap(l$raw_ret)
; [eval] $wrap(l$raw_ret)
(declare-const l$token_reserve@1015@01 $Int)
(assert (= l$token_reserve@1015@01 ($wrap<$Int> l$raw_ret@859@01)))
; [eval] $unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) < 0
; [eval] $unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))))
; [eval] $w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
    0))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 234 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) < 0 | dead]
; [else-branch: 234 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) < 0) | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 234 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
    0)))
(pop) ; 6
; [eval] !($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) < 0)
; [eval] $unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) < 0
; [eval] $unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))))
; [eval] $w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 6
(set-option :timeout 10)
(assert (not (<
  ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
  0)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
    0))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 235 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) < 0) | live]
; [else-branch: 235 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) < 0 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 235 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
    0)))
; [eval] $unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))))
; [eval] $w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 236 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 236 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 236 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 8
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 237 | True | live]
; [else-branch: 237 | False | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 237 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1016@01 $Snap)
(assert (= $t@1016@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1017@01 $Struct)
(assert (=
  self@1017@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 8
; [then-branch: 238 | False | dead]
; [else-branch: 238 | True | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 238 | True]
(pop) ; 8
(pop) ; 7
(push) ; 7
; [else-branch: 236 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 7
; [eval] !($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))))
; [eval] $w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 7
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 239 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 239 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 239 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [eval] $unwrap(l$total_liquidity) == 0
; [eval] $unwrap(l$total_liquidity)
(push) ; 8
(set-option :timeout 10)
(assert (not (not (= ($unwrap<Int> l$total_liquidity@936@01) 0))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 240 | $unwrap[Int](l$total_liquidity@936@01) == 0 | dead]
; [else-branch: 240 | $unwrap[Int](l$total_liquidity@936@01) != 0 | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 240 | $unwrap[Int](l$total_liquidity@936@01) != 0]
(assert (not (= ($unwrap<Int> l$total_liquidity@936@01) 0)))
(pop) ; 8
; [eval] !($unwrap(l$total_liquidity) == 0)
; [eval] $unwrap(l$total_liquidity) == 0
; [eval] $unwrap(l$total_liquidity)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ($unwrap<Int> l$total_liquidity@936@01) 0)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not (= ($unwrap<Int> l$total_liquidity@936@01) 0))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 241 | $unwrap[Int](l$total_liquidity@936@01) != 0 | live]
; [else-branch: 241 | $unwrap[Int](l$total_liquidity@936@01) == 0 | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 241 | $unwrap[Int](l$total_liquidity@936@01) != 0]
(assert (not (= ($unwrap<Int> l$total_liquidity@936@01) 0)))
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))) < 0
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity)))
; [eval] (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))
; [eval] 0 == $unwrap(l$total_liquidity)
; [eval] $unwrap(l$total_liquidity)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= 0 ($unwrap<Int> l$total_liquidity@936@01)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 242 | 0 == $unwrap[Int](l$total_liquidity@936@01) | dead]
; [else-branch: 242 | 0 != $unwrap[Int](l$total_liquidity@936@01) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 242 | 0 != $unwrap[Int](l$total_liquidity@936@01)]
(assert (not (= 0 ($unwrap<Int> l$total_liquidity@936@01))))
; [eval] $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity)
; [eval] $w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (not (= 0 ($unwrap<Int> l$total_liquidity@936@01))))
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01))
    0))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 243 | $unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) < 0 | dead]
; [else-branch: 243 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) < 0) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 243 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01))
    0)))
(pop) ; 9
; [eval] !($unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))) < 0)
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))) < 0
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity)))
; [eval] (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))
; [eval] 0 == $unwrap(l$total_liquidity)
; [eval] $unwrap(l$total_liquidity)
(push) ; 9
; [then-branch: 244 | 0 == $unwrap[Int](l$total_liquidity@936@01) | dead]
; [else-branch: 244 | 0 != $unwrap[Int](l$total_liquidity@936@01) | live]
(push) ; 10
; [else-branch: 244 | 0 != $unwrap[Int](l$total_liquidity@936@01)]
; [eval] $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity)
; [eval] $w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(pop) ; 10
(pop) ; 9
; Joined path conditions
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01))
  0)))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01))
    0))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 245 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) < 0) | live]
; [else-branch: 245 | $unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) < 0 | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 245 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01))
    0)))
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity)))
; [eval] (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))
; [eval] 0 == $unwrap(l$total_liquidity)
; [eval] $unwrap(l$total_liquidity)
(push) ; 10
; [then-branch: 246 | 0 == $unwrap[Int](l$total_liquidity@936@01) | dead]
; [else-branch: 246 | 0 != $unwrap[Int](l$total_liquidity@936@01) | live]
(push) ; 11
; [else-branch: 246 | 0 != $unwrap[Int](l$total_liquidity@936@01)]
; [eval] $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity)
; [eval] $w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(pop) ; 11
(pop) ; 10
; Joined path conditions
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 247 | $unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 247 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 247 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 10
; [eval] !($unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity)))
; [eval] (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))
; [eval] 0 == $unwrap(l$total_liquidity)
; [eval] $unwrap(l$total_liquidity)
(push) ; 10
; [then-branch: 248 | 0 == $unwrap[Int](l$total_liquidity@936@01) | dead]
; [else-branch: 248 | 0 != $unwrap[Int](l$total_liquidity@936@01) | live]
(push) ; 11
; [else-branch: 248 | 0 != $unwrap[Int](l$total_liquidity@936@01)]
; [eval] $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity)
; [eval] $w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(pop) ; 11
(pop) ; 10
; Joined path conditions
(push) ; 10
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 10
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 249 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 249 | $unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 249 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8)))), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$eth_amount := (0 == $unwrap(l$total_liquidity) ?
;     $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \
;     $unwrap(l$total_liquidity)) :
;     $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))),
;     l$total_liquidity))
; [eval] (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity))
; [eval] 0 == $unwrap(l$total_liquidity)
; [eval] $unwrap(l$total_liquidity)
(push) ; 11
; [then-branch: 250 | 0 == $unwrap[Int](l$total_liquidity@936@01) | dead]
; [else-branch: 250 | 0 != $unwrap[Int](l$total_liquidity@936@01) | live]
(push) ; 12
; [else-branch: 250 | 0 != $unwrap[Int](l$total_liquidity@936@01)]
; [eval] $w_div($w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int))), l$total_liquidity)
; [eval] $w_mul(l$amount, $wrap(($struct_get($struct_loc(self, 8)): Int)))
; [eval] $wrap(($struct_get($struct_loc(self, 8)): Int))
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(declare-const l$eth_amount@1018@01 $Int)
(assert (=
  l$eth_amount@1018@01
  ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))) l$total_liquidity@936@01)))
; [eval] $unwrap($w_mul(l$amount, l$token_reserve)) < 0
; [eval] $unwrap($w_mul(l$amount, l$token_reserve))
; [eval] $w_mul(l$amount, l$token_reserve)
(push) ; 11
(set-option :timeout 10)
(assert (not (not (< ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01)) 0))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 251 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) < 0 | dead]
; [else-branch: 251 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) < 0) | live]
(set-option :timeout 0)
(push) ; 11
; [else-branch: 251 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) < 0)]
(assert (not (< ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01)) 0)))
(pop) ; 11
; [eval] !($unwrap($w_mul(l$amount, l$token_reserve)) < 0)
; [eval] $unwrap($w_mul(l$amount, l$token_reserve)) < 0
; [eval] $unwrap($w_mul(l$amount, l$token_reserve))
; [eval] $w_mul(l$amount, l$token_reserve)
(push) ; 11
(set-option :timeout 10)
(assert (not (< ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01)) 0)))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (not (< ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01)) 0))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 252 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) < 0) | live]
; [else-branch: 252 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) < 0 | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 252 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) < 0)]
(assert (not (< ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01)) 0)))
; [eval] $unwrap($w_mul(l$amount, l$token_reserve)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($w_mul(l$amount, l$token_reserve))
; [eval] $w_mul(l$amount, l$token_reserve)
(push) ; 12
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
; [then-branch: 253 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 253 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 253 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 13
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
; [then-branch: 254 | True | live]
; [else-branch: 254 | False | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 254 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1019@01 $Snap)
(assert (= $t@1019@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1020@01 $Struct)
(assert (=
  self@1020@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 13
; [then-branch: 255 | False | dead]
; [else-branch: 255 | True | live]
(set-option :timeout 0)
(push) ; 13
; [else-branch: 255 | True]
(pop) ; 13
(pop) ; 12
(push) ; 12
; [else-branch: 253 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 12
; [eval] !($unwrap($w_mul(l$amount, l$token_reserve)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap($w_mul(l$amount, l$token_reserve)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($w_mul(l$amount, l$token_reserve))
; [eval] $w_mul(l$amount, l$token_reserve)
(push) ; 12
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
; [then-branch: 256 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 256 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 256 | !($unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [eval] $unwrap(l$total_liquidity) == 0
; [eval] $unwrap(l$total_liquidity)
; [then-branch: 257 | $unwrap[Int](l$total_liquidity@936@01) == 0 | dead]
; [else-branch: 257 | $unwrap[Int](l$total_liquidity@936@01) != 0 | live]
(push) ; 13
; [else-branch: 257 | $unwrap[Int](l$total_liquidity@936@01) != 0]
(pop) ; 13
; [eval] !($unwrap(l$total_liquidity) == 0)
; [eval] $unwrap(l$total_liquidity) == 0
; [eval] $unwrap(l$total_liquidity)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ($unwrap<Int> l$total_liquidity@936@01) 0)))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
; [then-branch: 258 | $unwrap[Int](l$total_liquidity@936@01) != 0 | live]
; [else-branch: 258 | $unwrap[Int](l$total_liquidity@936@01) == 0 | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 258 | $unwrap[Int](l$total_liquidity@936@01) != 0]
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))) < 0
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity)))
; [eval] (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))
; [eval] 0 == $unwrap(l$total_liquidity)
; [eval] $unwrap(l$total_liquidity)
(push) ; 14
; [then-branch: 259 | 0 == $unwrap[Int](l$total_liquidity@936@01) | dead]
; [else-branch: 259 | 0 != $unwrap[Int](l$total_liquidity@936@01) | live]
(push) ; 15
; [else-branch: 259 | 0 != $unwrap[Int](l$total_liquidity@936@01)]
; [eval] $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity)
; [eval] $w_mul(l$amount, l$token_reserve)
(pop) ; 15
(pop) ; 14
; Joined path conditions
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01))
    0))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 260 | $unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) < 0 | dead]
; [else-branch: 260 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) < 0) | live]
(set-option :timeout 0)
(push) ; 14
; [else-branch: 260 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01))
    0)))
(pop) ; 14
; [eval] !($unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))) < 0)
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))) < 0
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity)))
; [eval] (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))
; [eval] 0 == $unwrap(l$total_liquidity)
; [eval] $unwrap(l$total_liquidity)
(push) ; 14
; [then-branch: 261 | 0 == $unwrap[Int](l$total_liquidity@936@01) | dead]
; [else-branch: 261 | 0 != $unwrap[Int](l$total_liquidity@936@01) | live]
(push) ; 15
; [else-branch: 261 | 0 != $unwrap[Int](l$total_liquidity@936@01)]
; [eval] $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity)
; [eval] $w_mul(l$amount, l$token_reserve)
(pop) ; 15
(pop) ; 14
; Joined path conditions
(push) ; 14
(set-option :timeout 10)
(assert (not (<
  ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01))
  0)))
(check-sat)
; unknown
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01))
    0))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 262 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) < 0) | live]
; [else-branch: 262 | $unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) < 0 | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 262 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) < 0)]
(assert (not
  (<
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01))
    0)))
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity)))
; [eval] (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))
; [eval] 0 == $unwrap(l$total_liquidity)
; [eval] $unwrap(l$total_liquidity)
(push) ; 15
; [then-branch: 263 | 0 == $unwrap[Int](l$total_liquidity@936@01) | dead]
; [else-branch: 263 | 0 != $unwrap[Int](l$total_liquidity@936@01) | live]
(push) ; 16
; [else-branch: 263 | 0 != $unwrap[Int](l$total_liquidity@936@01)]
; [eval] $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity)
; [eval] $w_mul(l$amount, l$token_reserve)
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 264 | $unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 264 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 15
; [else-branch: 264 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 15
; [eval] !($unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap((0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity)))
; [eval] (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))
; [eval] 0 == $unwrap(l$total_liquidity)
; [eval] $unwrap(l$total_liquidity)
(push) ; 15
; [then-branch: 265 | 0 == $unwrap[Int](l$total_liquidity@936@01) | dead]
; [else-branch: 265 | 0 != $unwrap[Int](l$total_liquidity@936@01) | live]
(push) ; 16
; [else-branch: 265 | 0 != $unwrap[Int](l$total_liquidity@936@01)]
; [eval] $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity)
; [eval] $w_mul(l$amount, l$token_reserve)
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(set-option :timeout 10)
(assert (not (>
  ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 15
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 266 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 266 | $unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 266 | !($unwrap[Int]($w_div[$Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01), l$total_liquidity@936@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($unwrap<Int> ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$token_amount := (0 == $unwrap(l$total_liquidity) ?
;     $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \
;     $unwrap(l$total_liquidity)) :
;     $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))
; [eval] (0 == $unwrap(l$total_liquidity) ? $wrap($unwrap($w_mul(l$amount, l$token_reserve)) \ $unwrap(l$total_liquidity)) : $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity))
; [eval] 0 == $unwrap(l$total_liquidity)
; [eval] $unwrap(l$total_liquidity)
(push) ; 16
; [then-branch: 267 | 0 == $unwrap[Int](l$total_liquidity@936@01) | dead]
; [else-branch: 267 | 0 != $unwrap[Int](l$total_liquidity@936@01) | live]
(push) ; 17
; [else-branch: 267 | 0 != $unwrap[Int](l$total_liquidity@936@01)]
; [eval] $w_div($w_mul(l$amount, l$token_reserve), l$total_liquidity)
; [eval] $w_mul(l$amount, l$token_reserve)
(pop) ; 17
(pop) ; 16
; Joined path conditions
(declare-const l$token_amount@1021@01 $Int)
(assert (=
  l$token_amount@1021@01
  ($w_div<$Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01) l$total_liquidity@936@01)))
; [eval] !($unwrap(l$eth_amount) >= $unwrap(l$min_eth) && $unwrap(l$token_amount) >= $unwrap(l$min_tokens))
; [eval] $unwrap(l$eth_amount) >= $unwrap(l$min_eth) && $unwrap(l$token_amount) >= $unwrap(l$min_tokens)
; [eval] $unwrap(l$eth_amount) >= $unwrap(l$min_eth)
; [eval] $unwrap(l$eth_amount)
; [eval] $unwrap(l$min_eth)
(push) ; 16
; [then-branch: 268 | !($unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01)) | live]
; [else-branch: 268 | $unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01) | live]
(push) ; 17
; [then-branch: 268 | !($unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01))]
(assert (not (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))))
(pop) ; 17
(push) ; 17
; [else-branch: 268 | $unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01)]
(assert (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01)))
; [eval] $unwrap(l$token_amount) >= $unwrap(l$min_tokens)
; [eval] $unwrap(l$token_amount)
; [eval] $unwrap(l$min_tokens)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(assert (or
  (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))
  (not (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01)))))
(push) ; 16
(set-option :timeout 10)
(assert (not (and
  (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))
  (>= ($unwrap<Int> l$token_amount@1021@01) ($unwrap<Int> l$min_tokens@840@01)))))
(check-sat)
; unknown
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not
  (and
    (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))
    (>= ($unwrap<Int> l$token_amount@1021@01) ($unwrap<Int> l$min_tokens@840@01))))))
(check-sat)
; unknown
(pop) ; 16
; 0.08s
; (get-info :all-statistics)
; [then-branch: 269 | !($unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01) && $unwrap[Int](l$token_amount@1021@01) >= $unwrap[Int](l$min_tokens@840@01)) | live]
; [else-branch: 269 | $unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01) && $unwrap[Int](l$token_amount@1021@01) >= $unwrap[Int](l$min_tokens@840@01) | live]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 269 | !($unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01) && $unwrap[Int](l$token_amount@1021@01) >= $unwrap[Int](l$min_tokens@840@01))]
(assert (not
  (and
    (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))
    (>= ($unwrap<Int> l$token_amount@1021@01) ($unwrap<Int> l$min_tokens@840@01)))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 17
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
; [then-branch: 270 | True | live]
; [else-branch: 270 | False | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 270 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1022@01 $Snap)
(assert (= $t@1022@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1023@01 $Struct)
(assert (=
  self@1023@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 17
; [then-branch: 271 | False | dead]
; [else-branch: 271 | True | live]
(set-option :timeout 0)
(push) ; 17
; [else-branch: 271 | True]
(pop) ; 17
(pop) ; 16
(push) ; 16
; [else-branch: 269 | $unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01) && $unwrap[Int](l$token_amount@1021@01) >= $unwrap[Int](l$min_tokens@840@01)]
(assert (and
  (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))
  (>= ($unwrap<Int> l$token_amount@1021@01) ($unwrap<Int> l$min_tokens@840@01))))
(pop) ; 16
; [eval] !!($unwrap(l$eth_amount) >= $unwrap(l$min_eth) && $unwrap(l$token_amount) >= $unwrap(l$min_tokens))
; [eval] !($unwrap(l$eth_amount) >= $unwrap(l$min_eth) && $unwrap(l$token_amount) >= $unwrap(l$min_tokens))
; [eval] $unwrap(l$eth_amount) >= $unwrap(l$min_eth) && $unwrap(l$token_amount) >= $unwrap(l$min_tokens)
; [eval] $unwrap(l$eth_amount) >= $unwrap(l$min_eth)
; [eval] $unwrap(l$eth_amount)
; [eval] $unwrap(l$min_eth)
(push) ; 16
; [then-branch: 272 | !($unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01)) | live]
; [else-branch: 272 | $unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01) | live]
(push) ; 17
; [then-branch: 272 | !($unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01))]
(assert (not (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))))
(pop) ; 17
(push) ; 17
; [else-branch: 272 | $unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01)]
(assert (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01)))
; [eval] $unwrap(l$token_amount) >= $unwrap(l$min_tokens)
; [eval] $unwrap(l$token_amount)
; [eval] $unwrap(l$min_tokens)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(push) ; 16
(set-option :timeout 10)
(assert (not (not
  (and
    (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))
    (>= ($unwrap<Int> l$token_amount@1021@01) ($unwrap<Int> l$min_tokens@840@01))))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (and
  (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))
  (>= ($unwrap<Int> l$token_amount@1021@01) ($unwrap<Int> l$min_tokens@840@01)))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 273 | $unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01) && $unwrap[Int](l$token_amount@1021@01) >= $unwrap[Int](l$min_tokens@840@01) | live]
; [else-branch: 273 | !($unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01) && $unwrap[Int](l$token_amount@1021@01) >= $unwrap[Int](l$min_tokens@840@01)) | live]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 273 | $unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01) && $unwrap[Int](l$token_amount@1021@01) >= $unwrap[Int](l$min_tokens@840@01)]
(assert (and
  (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))
  (>= ($unwrap<Int> l$token_amount@1021@01) ($unwrap<Int> l$min_tokens@840@01))))
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount) < 0
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)))
; [eval] $wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$amount)
(push) ; 17
(set-option :timeout 10)
(assert (not (not
  (<
    (-
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
      ($unwrap<Int> l$amount@838@01))
    0))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (<
  (-
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
    ($unwrap<Int> l$amount@838@01))
  0)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 274 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) < 0 | live]
; [else-branch: 274 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) < 0) | live]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 274 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) < 0]
(assert (<
  (-
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
    ($unwrap<Int> l$amount@838@01))
  0))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 18
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 275 | True | live]
; [else-branch: 275 | False | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 275 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1024@01 $Snap)
(assert (= $t@1024@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1025@01 $Struct)
(assert (=
  self@1025@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 18
; [then-branch: 276 | False | dead]
; [else-branch: 276 | True | live]
(set-option :timeout 0)
(push) ; 18
; [else-branch: 276 | True]
(pop) ; 18
(pop) ; 17
(push) ; 17
; [else-branch: 274 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) < 0)]
(assert (not
  (<
    (-
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
      ($unwrap<Int> l$amount@838@01))
    0)))
(pop) ; 17
; [eval] !($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount) < 0)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount) < 0
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)))
; [eval] $wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$amount)
(push) ; 17
(set-option :timeout 10)
(assert (not (<
  (-
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
    ($unwrap<Int> l$amount@838@01))
  0)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (not
  (<
    (-
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
      ($unwrap<Int> l$amount@838@01))
    0))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 277 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) < 0) | live]
; [else-branch: 277 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) < 0 | live]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 277 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) < 0)]
(assert (not
  (<
    (-
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
      ($unwrap<Int> l$amount@838@01))
    0)))
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)))
; [eval] $wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$amount)
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (>
    (-
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
      ($unwrap<Int> l$amount@838@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 278 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 278 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 18
; [else-branch: 278 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (-
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
      ($unwrap<Int> l$amount@838@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 18
; [eval] !($unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)))
; [eval] $wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$amount)
(push) ; 18
(set-option :timeout 10)
(assert (not (>
  (-
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
    ($unwrap<Int> l$amount@838@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (>
    (-
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
      ($unwrap<Int> l$amount@838@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 279 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 279 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 279 | !($unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (-
      ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
      ($unwrap<Int> l$amount@838@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; self := ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]),
;   ($struct_get($struct_loc(msg, 0)): Int), $unwrap($wrap(($map_get(($struct_get($struct_loc(self,
;   4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) -
;   $unwrap(l$amount)): $Map[Int, Int])): $Struct)
; [eval] ($struct_set(self, 4, ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount)): $Map[Int, Int])): $Struct)
; [eval] ($map_set(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount)): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))) - $unwrap(l$amount)
; [eval] $unwrap($wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)))
; [eval] $wrap(($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$amount)
(declare-const self@1026@01 $Struct)
(assert (=
  self@1026@01
  ($struct_set<$Struct> self@848@01 4 ($map_set<$Map<Int~_Int>> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)) (-
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
    ($unwrap<Int> l$amount@838@01))))))
; [eval] $unwrap(l$total_liquidity) - $unwrap(l$amount) < 0
; [eval] $unwrap(l$total_liquidity) - $unwrap(l$amount)
; [eval] $unwrap(l$total_liquidity)
; [eval] $unwrap(l$amount)
(push) ; 19
(set-option :timeout 10)
(assert (not (not
  (<
    (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01))
    0))))
(check-sat)
; unknown
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (< (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01)) 0)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 280 | $unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) < 0 | live]
; [else-branch: 280 | !($unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) < 0) | live]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 280 | $unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) < 0]
(assert (< (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01)) 0))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 20
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 281 | True | live]
; [else-branch: 281 | False | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 281 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1027@01 $Snap)
(assert (= $t@1027@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1028@01 $Struct)
(assert (=
  self@1028@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 20
; [then-branch: 282 | False | dead]
; [else-branch: 282 | True | live]
(set-option :timeout 0)
(push) ; 20
; [else-branch: 282 | True]
(pop) ; 20
(pop) ; 19
(push) ; 19
; [else-branch: 280 | !($unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) < 0)]
(assert (not
  (<
    (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01))
    0)))
(pop) ; 19
; [eval] !($unwrap(l$total_liquidity) - $unwrap(l$amount) < 0)
; [eval] $unwrap(l$total_liquidity) - $unwrap(l$amount) < 0
; [eval] $unwrap(l$total_liquidity) - $unwrap(l$amount)
; [eval] $unwrap(l$total_liquidity)
; [eval] $unwrap(l$amount)
(push) ; 19
(set-option :timeout 10)
(assert (not (< (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01)) 0)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (not
  (<
    (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01))
    0))))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 283 | !($unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) < 0) | live]
; [else-branch: 283 | $unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) < 0 | live]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 283 | !($unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) < 0)]
(assert (not
  (<
    (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01))
    0)))
; [eval] $unwrap(l$total_liquidity) - $unwrap(l$amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$total_liquidity) - $unwrap(l$amount)
; [eval] $unwrap(l$total_liquidity)
; [eval] $unwrap(l$amount)
(push) ; 20
(set-option :timeout 10)
(assert (not (not
  (>
    (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 284 | $unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 284 | !($unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 20
; [else-branch: 284 | !($unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 20
; [eval] !($unwrap(l$total_liquidity) - $unwrap(l$amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $unwrap(l$total_liquidity) - $unwrap(l$amount) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$total_liquidity) - $unwrap(l$amount)
; [eval] $unwrap(l$total_liquidity)
; [eval] $unwrap(l$amount)
(push) ; 20
(set-option :timeout 10)
(assert (not (>
  (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (not
  (>
    (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 285 | !($unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 285 | $unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 285 | !($unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; self := ($struct_set(self, 3, $unwrap($wrap($unwrap(l$total_liquidity) -
;   $unwrap(l$amount)))): $Struct)
; [eval] ($struct_set(self, 3, $unwrap($wrap($unwrap(l$total_liquidity) - $unwrap(l$amount)))): $Struct)
; [eval] $unwrap($wrap($unwrap(l$total_liquidity) - $unwrap(l$amount)))
; [eval] $wrap($unwrap(l$total_liquidity) - $unwrap(l$amount))
; [eval] $unwrap(l$total_liquidity) - $unwrap(l$amount)
; [eval] $unwrap(l$total_liquidity)
; [eval] $unwrap(l$amount)
(declare-const self@1029@01 $Struct)
(assert (=
  self@1029@01
  ($struct_set<$Struct> self@1026@01 3 ($unwrap<Int> ($wrap<$Int> (-
    ($unwrap<Int> l$total_liquidity@936@01)
    ($unwrap<Int> l$amount@838@01)))))))
; [eval] ($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$eth_amount)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] $unwrap(l$eth_amount)
(push) ; 21
(set-option :timeout 10)
(assert (not (not
  (<
    ($struct_get<Int> ($struct_loc<Int> self@1029@01 8))
    ($unwrap<Int> l$eth_amount@1018@01)))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (<
  ($struct_get<Int> ($struct_loc<Int> self@1029@01 8))
  ($unwrap<Int> l$eth_amount@1018@01))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 286 | $struct_get[Int]($struct_loc[Int](self@1029@01, 8)) < $unwrap[Int](l$eth_amount@1018@01) | live]
; [else-branch: 286 | !($struct_get[Int]($struct_loc[Int](self@1029@01, 8)) < $unwrap[Int](l$eth_amount@1018@01)) | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 286 | $struct_get[Int]($struct_loc[Int](self@1029@01, 8)) < $unwrap[Int](l$eth_amount@1018@01)]
(assert (<
  ($struct_get<Int> ($struct_loc<Int> self@1029@01 8))
  ($unwrap<Int> l$eth_amount@1018@01)))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 22
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 287 | True | live]
; [else-branch: 287 | False | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 287 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1030@01 $Snap)
(assert (= $t@1030@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1031@01 $Struct)
(assert (=
  self@1031@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 22
; [then-branch: 288 | False | dead]
; [else-branch: 288 | True | live]
(set-option :timeout 0)
(push) ; 22
; [else-branch: 288 | True]
(pop) ; 22
(pop) ; 21
(push) ; 21
; [else-branch: 286 | !($struct_get[Int]($struct_loc[Int](self@1029@01, 8)) < $unwrap[Int](l$eth_amount@1018@01))]
(assert (not
  (<
    ($struct_get<Int> ($struct_loc<Int> self@1029@01 8))
    ($unwrap<Int> l$eth_amount@1018@01))))
(pop) ; 21
; [eval] !(($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$eth_amount))
; [eval] ($struct_get($struct_loc(self, 8)): Int) < $unwrap(l$eth_amount)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] $unwrap(l$eth_amount)
(push) ; 21
(set-option :timeout 10)
(assert (not (<
  ($struct_get<Int> ($struct_loc<Int> self@1029@01 8))
  ($unwrap<Int> l$eth_amount@1018@01))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not
  (<
    ($struct_get<Int> ($struct_loc<Int> self@1029@01 8))
    ($unwrap<Int> l$eth_amount@1018@01)))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 289 | !($struct_get[Int]($struct_loc[Int](self@1029@01, 8)) < $unwrap[Int](l$eth_amount@1018@01)) | live]
; [else-branch: 289 | $struct_get[Int]($struct_loc[Int](self@1029@01, 8)) < $unwrap[Int](l$eth_amount@1018@01) | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 289 | !($struct_get[Int]($struct_loc[Int](self@1029@01, 8)) < $unwrap[Int](l$eth_amount@1018@01))]
(assert (not
  (<
    ($struct_get<Int> ($struct_loc<Int> self@1029@01 8))
    ($unwrap<Int> l$eth_amount@1018@01))))
; [exec]
; self := ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]),
;   ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self,
;   11)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) +
;   $unwrap(l$eth_amount)): $Map[Int, Int])): $Struct)
; [eval] ($struct_set(self, 11, ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + $unwrap(l$eth_amount)): $Map[Int, Int])): $Struct)
; [eval] ($map_set(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + $unwrap(l$eth_amount)): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + $unwrap(l$eth_amount)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$eth_amount)
(declare-const self@1032@01 $Struct)
(assert (=
  self@1032@01
  ($struct_set<$Struct> self@1029@01 11 ($map_set<$Map<Int~_Int>> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1029@01 11)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)) (+
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1029@01 11)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($unwrap<Int> l$eth_amount@1018@01))))))
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) -
;   $unwrap(l$eth_amount)): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$eth_amount)): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) - $unwrap(l$eth_amount)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] $unwrap(l$eth_amount)
(declare-const self@1033@01 $Struct)
(assert (=
  self@1033@01
  ($struct_set<$Struct> self@1032@01 8 (-
    ($struct_get<Int> ($struct_loc<Int> self@1032@01 8))
    ($unwrap<Int> l$eth_amount@1018@01)))))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1034@01 Int)
(declare-const $arg1@1035@01 Int)
(declare-const $arg2@1036@01 Int)
(push) ; 22
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1037@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef78|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef79|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1034@01)
    ($SortWrappers.IntTo$Snap $arg1@1035@01))
  ($SortWrappers.IntTo$Snap $arg2@1036@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1034@01)
    ($SortWrappers.IntTo$Snap $arg1@1035@01))
  ($SortWrappers.IntTo$Snap $arg2@1036@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1034@01)
      ($SortWrappers.IntTo$Snap $arg1@1035@01))
    ($SortWrappers.IntTo$Snap $arg2@1036@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 22
(declare-fun inv@1038@01 (Int Int Int) Int)
(declare-fun img@1039@01 (Int Int Int) Bool)
(declare-fun inv@1040@01 (Int Int Int) Int)
(declare-fun img@1041@01 (Int Int Int) Bool)
(declare-fun inv@1042@01 (Int Int Int) Int)
(declare-fun img@1043@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef78|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef79|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1034@01 Int) ($arg1@1035@01 Int) ($arg2@1036@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1034@01)
          ($SortWrappers.IntTo$Snap $arg1@1035@01))
        ($SortWrappers.IntTo$Snap $arg2@1036@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1034@01)
        ($SortWrappers.IntTo$Snap $arg1@1035@01))
      ($SortWrappers.IntTo$Snap $arg2@1036@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1034@01)
        ($SortWrappers.IntTo$Snap $arg1@1035@01))
      ($SortWrappers.IntTo$Snap $arg2@1036@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1034@01)
      ($SortWrappers.IntTo$Snap $arg1@1035@01))
    ($SortWrappers.IntTo$Snap $arg2@1036@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1034@01)
      ($SortWrappers.IntTo$Snap $arg1@1035@01))
    ($SortWrappers.IntTo$Snap $arg2@1036@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 22
(assert (not (forall (($arg0@1034@01 Int) ($arg1@1035@01 Int) ($arg2@1036@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1034@01)
          ($SortWrappers.IntTo$Snap $arg1@1035@01))
        ($SortWrappers.IntTo$Snap $arg2@1036@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1034@01)
            ($SortWrappers.IntTo$Snap $arg1@1035@01))
          ($SortWrappers.IntTo$Snap $arg2@1036@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1034@01)
            ($SortWrappers.IntTo$Snap $arg1@1035@01))
          ($SortWrappers.IntTo$Snap $arg2@1036@01))))))
  
  :qid |quant-u-1687|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 22
(assert (not (forall (($arg01@1034@01 Int) ($arg11@1035@01 Int) ($arg21@1036@01 Int) ($arg02@1034@01 Int) ($arg12@1035@01 Int) ($arg22@1036@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1034@01)
                ($SortWrappers.IntTo$Snap $arg11@1035@01))
              ($SortWrappers.IntTo$Snap $arg21@1036@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1034@01)
              ($SortWrappers.IntTo$Snap $arg11@1035@01))
            ($SortWrappers.IntTo$Snap $arg21@1036@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1034@01)
              ($SortWrappers.IntTo$Snap $arg11@1035@01))
            ($SortWrappers.IntTo$Snap $arg21@1036@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1034@01)
              ($SortWrappers.IntTo$Snap $arg11@1035@01))
            ($SortWrappers.IntTo$Snap $arg21@1036@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1034@01)
                ($SortWrappers.IntTo$Snap $arg12@1035@01))
              ($SortWrappers.IntTo$Snap $arg22@1036@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1034@01)
              ($SortWrappers.IntTo$Snap $arg12@1035@01))
            ($SortWrappers.IntTo$Snap $arg22@1036@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1034@01)
              ($SortWrappers.IntTo$Snap $arg12@1035@01))
            ($SortWrappers.IntTo$Snap $arg22@1036@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1034@01)
              ($SortWrappers.IntTo$Snap $arg12@1035@01))
            ($SortWrappers.IntTo$Snap $arg22@1036@01)))))
      (and
        (and (= $arg01@1034@01 $arg02@1034@01) (= $arg11@1035@01 $arg12@1035@01))
        (= $arg21@1036@01 $arg22@1036@01)))
    (and
      (and (= $arg01@1034@01 $arg02@1034@01) (= $arg11@1035@01 $arg12@1035@01))
      (= $arg21@1036@01 $arg22@1036@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1034@01 Int) ($arg1@1035@01 Int) ($arg2@1036@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1034@01)
            ($SortWrappers.IntTo$Snap $arg1@1035@01))
          ($SortWrappers.IntTo$Snap $arg2@1036@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1034@01)
            ($SortWrappers.IntTo$Snap $arg1@1035@01))
          ($SortWrappers.IntTo$Snap $arg2@1036@01)))))
    (and
      (and
        (= (inv@1038@01 $arg0@1034@01 $arg1@1035@01 $arg2@1036@01) $arg0@1034@01)
        (= (inv@1040@01 $arg0@1034@01 $arg1@1035@01 $arg2@1036@01) $arg1@1035@01)
        (= (inv@1042@01 $arg0@1034@01 $arg1@1035@01 $arg2@1036@01) $arg2@1036@01))
      (and
        (img@1039@01 $arg0@1034@01 $arg1@1035@01 $arg2@1036@01)
        (img@1041@01 $arg0@1034@01 $arg1@1035@01 $arg2@1036@01)
        (img@1043@01 $arg0@1034@01 $arg1@1035@01 $arg2@1036@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1034@01)
      ($SortWrappers.IntTo$Snap $arg1@1035@01))
    ($SortWrappers.IntTo$Snap $arg2@1036@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1034@01)
      ($SortWrappers.IntTo$Snap $arg1@1035@01))
    ($SortWrappers.IntTo$Snap $arg2@1036@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1039@01 $arg0 $arg1 $arg2)
        (img@1041@01 $arg0 $arg1 $arg2)
        (img@1043@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1038@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1040@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1042@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1038@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1040@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1042@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1038@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1040@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1042@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1038@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1040@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1042@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1038@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1040@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1042@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1038@01 $arg0 $arg1 $arg2) (inv@1040@01 $arg0 $arg1 $arg2) (inv@1042@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1688|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 22
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1038@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1040@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1042@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1039@01 $arg0 $arg1 $arg2)
        (img@1041@01 $arg0 $arg1 $arg2)
        (img@1043@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1038@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1040@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1042@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@1037@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1038@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1040@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1042@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1689|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1044@01 Int)
(declare-const $arg1@1045@01 Int)
(declare-const $arg2@1046@01 Int)
(push) ; 22
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1047@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef80|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef81|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1044@01)
    ($SortWrappers.IntTo$Snap $arg1@1045@01))
  ($SortWrappers.IntTo$Snap $arg2@1046@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1044@01)
    ($SortWrappers.IntTo$Snap $arg1@1045@01))
  ($SortWrappers.IntTo$Snap $arg2@1046@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1044@01)
      ($SortWrappers.IntTo$Snap $arg1@1045@01))
    ($SortWrappers.IntTo$Snap $arg2@1046@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 22
(declare-fun inv@1048@01 (Int Int Int) Int)
(declare-fun img@1049@01 (Int Int Int) Bool)
(declare-fun inv@1050@01 (Int Int Int) Int)
(declare-fun img@1051@01 (Int Int Int) Bool)
(declare-fun inv@1052@01 (Int Int Int) Int)
(declare-fun img@1053@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef80|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef81|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1044@01 Int) ($arg1@1045@01 Int) ($arg2@1046@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1044@01)
          ($SortWrappers.IntTo$Snap $arg1@1045@01))
        ($SortWrappers.IntTo$Snap $arg2@1046@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1044@01)
        ($SortWrappers.IntTo$Snap $arg1@1045@01))
      ($SortWrappers.IntTo$Snap $arg2@1046@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1044@01)
        ($SortWrappers.IntTo$Snap $arg1@1045@01))
      ($SortWrappers.IntTo$Snap $arg2@1046@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1044@01)
      ($SortWrappers.IntTo$Snap $arg1@1045@01))
    ($SortWrappers.IntTo$Snap $arg2@1046@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1044@01)
      ($SortWrappers.IntTo$Snap $arg1@1045@01))
    ($SortWrappers.IntTo$Snap $arg2@1046@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 22
(assert (not (forall (($arg0@1044@01 Int) ($arg1@1045@01 Int) ($arg2@1046@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1044@01)
          ($SortWrappers.IntTo$Snap $arg1@1045@01))
        ($SortWrappers.IntTo$Snap $arg2@1046@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1044@01)
            ($SortWrappers.IntTo$Snap $arg1@1045@01))
          ($SortWrappers.IntTo$Snap $arg2@1046@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1044@01)
            ($SortWrappers.IntTo$Snap $arg1@1045@01))
          ($SortWrappers.IntTo$Snap $arg2@1046@01))))))
  
  :qid |quant-u-1690|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 22
(assert (not (forall (($arg01@1044@01 Int) ($arg11@1045@01 Int) ($arg21@1046@01 Int) ($arg02@1044@01 Int) ($arg12@1045@01 Int) ($arg22@1046@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1044@01)
                ($SortWrappers.IntTo$Snap $arg11@1045@01))
              ($SortWrappers.IntTo$Snap $arg21@1046@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1044@01)
              ($SortWrappers.IntTo$Snap $arg11@1045@01))
            ($SortWrappers.IntTo$Snap $arg21@1046@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1044@01)
              ($SortWrappers.IntTo$Snap $arg11@1045@01))
            ($SortWrappers.IntTo$Snap $arg21@1046@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1044@01)
              ($SortWrappers.IntTo$Snap $arg11@1045@01))
            ($SortWrappers.IntTo$Snap $arg21@1046@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1044@01)
                ($SortWrappers.IntTo$Snap $arg12@1045@01))
              ($SortWrappers.IntTo$Snap $arg22@1046@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1044@01)
              ($SortWrappers.IntTo$Snap $arg12@1045@01))
            ($SortWrappers.IntTo$Snap $arg22@1046@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1044@01)
              ($SortWrappers.IntTo$Snap $arg12@1045@01))
            ($SortWrappers.IntTo$Snap $arg22@1046@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1044@01)
              ($SortWrappers.IntTo$Snap $arg12@1045@01))
            ($SortWrappers.IntTo$Snap $arg22@1046@01)))))
      (and
        (and (= $arg01@1044@01 $arg02@1044@01) (= $arg11@1045@01 $arg12@1045@01))
        (= $arg21@1046@01 $arg22@1046@01)))
    (and
      (and (= $arg01@1044@01 $arg02@1044@01) (= $arg11@1045@01 $arg12@1045@01))
      (= $arg21@1046@01 $arg22@1046@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1044@01 Int) ($arg1@1045@01 Int) ($arg2@1046@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1044@01)
            ($SortWrappers.IntTo$Snap $arg1@1045@01))
          ($SortWrappers.IntTo$Snap $arg2@1046@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1044@01)
            ($SortWrappers.IntTo$Snap $arg1@1045@01))
          ($SortWrappers.IntTo$Snap $arg2@1046@01)))))
    (and
      (and
        (= (inv@1048@01 $arg0@1044@01 $arg1@1045@01 $arg2@1046@01) $arg0@1044@01)
        (= (inv@1050@01 $arg0@1044@01 $arg1@1045@01 $arg2@1046@01) $arg1@1045@01)
        (= (inv@1052@01 $arg0@1044@01 $arg1@1045@01 $arg2@1046@01) $arg2@1046@01))
      (and
        (img@1049@01 $arg0@1044@01 $arg1@1045@01 $arg2@1046@01)
        (img@1051@01 $arg0@1044@01 $arg1@1045@01 $arg2@1046@01)
        (img@1053@01 $arg0@1044@01 $arg1@1045@01 $arg2@1046@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1044@01)
      ($SortWrappers.IntTo$Snap $arg1@1045@01))
    ($SortWrappers.IntTo$Snap $arg2@1046@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1044@01)
      ($SortWrappers.IntTo$Snap $arg1@1045@01))
    ($SortWrappers.IntTo$Snap $arg2@1046@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1049@01 $arg0 $arg1 $arg2)
        (img@1051@01 $arg0 $arg1 $arg2)
        (img@1053@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1048@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1050@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1052@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1048@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1050@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1052@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1048@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1050@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1052@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1048@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1050@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1052@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1048@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1050@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1052@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1048@01 $arg0 $arg1 $arg2) (inv@1050@01 $arg0 $arg1 $arg2) (inv@1052@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1691|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 22
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1048@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1050@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1052@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1049@01 $arg0 $arg1 $arg2)
        (img@1051@01 $arg0 $arg1 $arg2)
        (img@1053@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1048@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1050@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1052@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@1047@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1048@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1050@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1052@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1692|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1054@01 Int)
(declare-const $arg1@1055@01 Int)
(declare-const $arg2@1056@01 Int)
(push) ; 22
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1057@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef82|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef83|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1054@01)
    ($SortWrappers.IntTo$Snap $arg1@1055@01))
  ($SortWrappers.IntTo$Snap $arg2@1056@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1054@01)
    ($SortWrappers.IntTo$Snap $arg1@1055@01))
  ($SortWrappers.IntTo$Snap $arg2@1056@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1054@01)
      ($SortWrappers.IntTo$Snap $arg1@1055@01))
    ($SortWrappers.IntTo$Snap $arg2@1056@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 22
(declare-fun inv@1058@01 (Int Int Int) Int)
(declare-fun img@1059@01 (Int Int Int) Bool)
(declare-fun inv@1060@01 (Int Int Int) Int)
(declare-fun img@1061@01 (Int Int Int) Bool)
(declare-fun inv@1062@01 (Int Int Int) Int)
(declare-fun img@1063@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef82|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef83|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1054@01 Int) ($arg1@1055@01 Int) ($arg2@1056@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1054@01)
          ($SortWrappers.IntTo$Snap $arg1@1055@01))
        ($SortWrappers.IntTo$Snap $arg2@1056@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1054@01)
        ($SortWrappers.IntTo$Snap $arg1@1055@01))
      ($SortWrappers.IntTo$Snap $arg2@1056@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1054@01)
        ($SortWrappers.IntTo$Snap $arg1@1055@01))
      ($SortWrappers.IntTo$Snap $arg2@1056@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1054@01)
      ($SortWrappers.IntTo$Snap $arg1@1055@01))
    ($SortWrappers.IntTo$Snap $arg2@1056@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1054@01)
      ($SortWrappers.IntTo$Snap $arg1@1055@01))
    ($SortWrappers.IntTo$Snap $arg2@1056@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 22
(assert (not (forall (($arg0@1054@01 Int) ($arg1@1055@01 Int) ($arg2@1056@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1054@01)
          ($SortWrappers.IntTo$Snap $arg1@1055@01))
        ($SortWrappers.IntTo$Snap $arg2@1056@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1054@01)
            ($SortWrappers.IntTo$Snap $arg1@1055@01))
          ($SortWrappers.IntTo$Snap $arg2@1056@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1054@01)
            ($SortWrappers.IntTo$Snap $arg1@1055@01))
          ($SortWrappers.IntTo$Snap $arg2@1056@01))))))
  
  :qid |quant-u-1693|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 22
(assert (not (forall (($arg01@1054@01 Int) ($arg11@1055@01 Int) ($arg21@1056@01 Int) ($arg02@1054@01 Int) ($arg12@1055@01 Int) ($arg22@1056@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1054@01)
                ($SortWrappers.IntTo$Snap $arg11@1055@01))
              ($SortWrappers.IntTo$Snap $arg21@1056@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1054@01)
              ($SortWrappers.IntTo$Snap $arg11@1055@01))
            ($SortWrappers.IntTo$Snap $arg21@1056@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1054@01)
              ($SortWrappers.IntTo$Snap $arg11@1055@01))
            ($SortWrappers.IntTo$Snap $arg21@1056@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1054@01)
              ($SortWrappers.IntTo$Snap $arg11@1055@01))
            ($SortWrappers.IntTo$Snap $arg21@1056@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1054@01)
                ($SortWrappers.IntTo$Snap $arg12@1055@01))
              ($SortWrappers.IntTo$Snap $arg22@1056@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1054@01)
              ($SortWrappers.IntTo$Snap $arg12@1055@01))
            ($SortWrappers.IntTo$Snap $arg22@1056@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1054@01)
              ($SortWrappers.IntTo$Snap $arg12@1055@01))
            ($SortWrappers.IntTo$Snap $arg22@1056@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1054@01)
              ($SortWrappers.IntTo$Snap $arg12@1055@01))
            ($SortWrappers.IntTo$Snap $arg22@1056@01)))))
      (and
        (and (= $arg01@1054@01 $arg02@1054@01) (= $arg11@1055@01 $arg12@1055@01))
        (= $arg21@1056@01 $arg22@1056@01)))
    (and
      (and (= $arg01@1054@01 $arg02@1054@01) (= $arg11@1055@01 $arg12@1055@01))
      (= $arg21@1056@01 $arg22@1056@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1054@01 Int) ($arg1@1055@01 Int) ($arg2@1056@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1054@01)
            ($SortWrappers.IntTo$Snap $arg1@1055@01))
          ($SortWrappers.IntTo$Snap $arg2@1056@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1054@01)
            ($SortWrappers.IntTo$Snap $arg1@1055@01))
          ($SortWrappers.IntTo$Snap $arg2@1056@01)))))
    (and
      (and
        (= (inv@1058@01 $arg0@1054@01 $arg1@1055@01 $arg2@1056@01) $arg0@1054@01)
        (= (inv@1060@01 $arg0@1054@01 $arg1@1055@01 $arg2@1056@01) $arg1@1055@01)
        (= (inv@1062@01 $arg0@1054@01 $arg1@1055@01 $arg2@1056@01) $arg2@1056@01))
      (and
        (img@1059@01 $arg0@1054@01 $arg1@1055@01 $arg2@1056@01)
        (img@1061@01 $arg0@1054@01 $arg1@1055@01 $arg2@1056@01)
        (img@1063@01 $arg0@1054@01 $arg1@1055@01 $arg2@1056@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1054@01)
      ($SortWrappers.IntTo$Snap $arg1@1055@01))
    ($SortWrappers.IntTo$Snap $arg2@1056@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1054@01)
      ($SortWrappers.IntTo$Snap $arg1@1055@01))
    ($SortWrappers.IntTo$Snap $arg2@1056@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1059@01 $arg0 $arg1 $arg2)
        (img@1061@01 $arg0 $arg1 $arg2)
        (img@1063@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1058@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1060@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1062@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1058@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1060@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1062@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1058@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1060@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1062@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1058@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1060@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1062@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1058@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1060@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1062@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1058@01 $arg0 $arg1 $arg2) (inv@1060@01 $arg0 $arg1 $arg2) (inv@1062@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1694|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 22
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1058@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1060@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1062@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1059@01 $arg0 $arg1 $arg2)
        (img@1061@01 $arg0 $arg1 $arg2)
        (img@1063@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1058@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1060@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1062@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@1057@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1058@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1060@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1062@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1695|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@1064@01 Int)
(declare-const $arg1@1065@01 Int)
(declare-const $arg2@1066@01 Int)
(push) ; 22
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1067@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef84|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef85|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1064@01)
    ($SortWrappers.IntTo$Snap $arg1@1065@01))
  ($SortWrappers.IntTo$Snap $arg2@1066@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1064@01)
    ($SortWrappers.IntTo$Snap $arg1@1065@01))
  ($SortWrappers.IntTo$Snap $arg2@1066@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1064@01)
      ($SortWrappers.IntTo$Snap $arg1@1065@01))
    ($SortWrappers.IntTo$Snap $arg2@1066@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 22
(declare-fun inv@1068@01 (Int Int Int) Int)
(declare-fun img@1069@01 (Int Int Int) Bool)
(declare-fun inv@1070@01 (Int Int Int) Int)
(declare-fun img@1071@01 (Int Int Int) Bool)
(declare-fun inv@1072@01 (Int Int Int) Int)
(declare-fun img@1073@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef84|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef85|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1064@01 Int) ($arg1@1065@01 Int) ($arg2@1066@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1064@01)
          ($SortWrappers.IntTo$Snap $arg1@1065@01))
        ($SortWrappers.IntTo$Snap $arg2@1066@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1064@01)
        ($SortWrappers.IntTo$Snap $arg1@1065@01))
      ($SortWrappers.IntTo$Snap $arg2@1066@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1064@01)
        ($SortWrappers.IntTo$Snap $arg1@1065@01))
      ($SortWrappers.IntTo$Snap $arg2@1066@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1064@01)
      ($SortWrappers.IntTo$Snap $arg1@1065@01))
    ($SortWrappers.IntTo$Snap $arg2@1066@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1064@01)
      ($SortWrappers.IntTo$Snap $arg1@1065@01))
    ($SortWrappers.IntTo$Snap $arg2@1066@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 22
(assert (not (forall (($arg0@1064@01 Int) ($arg1@1065@01 Int) ($arg2@1066@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1064@01)
          ($SortWrappers.IntTo$Snap $arg1@1065@01))
        ($SortWrappers.IntTo$Snap $arg2@1066@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1064@01)
            ($SortWrappers.IntTo$Snap $arg1@1065@01))
          ($SortWrappers.IntTo$Snap $arg2@1066@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1064@01)
            ($SortWrappers.IntTo$Snap $arg1@1065@01))
          ($SortWrappers.IntTo$Snap $arg2@1066@01))))))
  
  :qid |quant-u-1696|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 22
(assert (not (forall (($arg01@1064@01 Int) ($arg11@1065@01 Int) ($arg21@1066@01 Int) ($arg02@1064@01 Int) ($arg12@1065@01 Int) ($arg22@1066@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1064@01)
                ($SortWrappers.IntTo$Snap $arg11@1065@01))
              ($SortWrappers.IntTo$Snap $arg21@1066@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1064@01)
              ($SortWrappers.IntTo$Snap $arg11@1065@01))
            ($SortWrappers.IntTo$Snap $arg21@1066@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1064@01)
              ($SortWrappers.IntTo$Snap $arg11@1065@01))
            ($SortWrappers.IntTo$Snap $arg21@1066@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1064@01)
              ($SortWrappers.IntTo$Snap $arg11@1065@01))
            ($SortWrappers.IntTo$Snap $arg21@1066@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1064@01)
                ($SortWrappers.IntTo$Snap $arg12@1065@01))
              ($SortWrappers.IntTo$Snap $arg22@1066@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1064@01)
              ($SortWrappers.IntTo$Snap $arg12@1065@01))
            ($SortWrappers.IntTo$Snap $arg22@1066@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1064@01)
              ($SortWrappers.IntTo$Snap $arg12@1065@01))
            ($SortWrappers.IntTo$Snap $arg22@1066@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1064@01)
              ($SortWrappers.IntTo$Snap $arg12@1065@01))
            ($SortWrappers.IntTo$Snap $arg22@1066@01)))))
      (and
        (and (= $arg01@1064@01 $arg02@1064@01) (= $arg11@1065@01 $arg12@1065@01))
        (= $arg21@1066@01 $arg22@1066@01)))
    (and
      (and (= $arg01@1064@01 $arg02@1064@01) (= $arg11@1065@01 $arg12@1065@01))
      (= $arg21@1066@01 $arg22@1066@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1064@01 Int) ($arg1@1065@01 Int) ($arg2@1066@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1064@01)
            ($SortWrappers.IntTo$Snap $arg1@1065@01))
          ($SortWrappers.IntTo$Snap $arg2@1066@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1064@01)
            ($SortWrappers.IntTo$Snap $arg1@1065@01))
          ($SortWrappers.IntTo$Snap $arg2@1066@01)))))
    (and
      (and
        (= (inv@1068@01 $arg0@1064@01 $arg1@1065@01 $arg2@1066@01) $arg0@1064@01)
        (= (inv@1070@01 $arg0@1064@01 $arg1@1065@01 $arg2@1066@01) $arg1@1065@01)
        (= (inv@1072@01 $arg0@1064@01 $arg1@1065@01 $arg2@1066@01) $arg2@1066@01))
      (and
        (img@1069@01 $arg0@1064@01 $arg1@1065@01 $arg2@1066@01)
        (img@1071@01 $arg0@1064@01 $arg1@1065@01 $arg2@1066@01)
        (img@1073@01 $arg0@1064@01 $arg1@1065@01 $arg2@1066@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1064@01)
      ($SortWrappers.IntTo$Snap $arg1@1065@01))
    ($SortWrappers.IntTo$Snap $arg2@1066@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1064@01)
      ($SortWrappers.IntTo$Snap $arg1@1065@01))
    ($SortWrappers.IntTo$Snap $arg2@1066@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1069@01 $arg0 $arg1 $arg2)
        (img@1071@01 $arg0 $arg1 $arg2)
        (img@1073@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1068@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1070@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1072@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1068@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1070@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1072@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1068@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1070@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1072@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1068@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1070@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1072@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1068@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1070@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1072@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1068@01 $arg0 $arg1 $arg2) (inv@1070@01 $arg0 $arg1 $arg2) (inv@1072@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1697|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 22
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1068@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1070@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1072@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1069@01 $arg0 $arg1 $arg2)
        (img@1071@01 $arg0 $arg1 $arg2)
        (img@1073@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1068@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1070@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1072@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@1067@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1068@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1070@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1072@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1698|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@1074@01 Int)
(declare-const $arg1@1075@01 Int)
(declare-const $arg2@1076@01 Int)
(push) ; 22
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1077@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef86|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef87|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1074@01)
    ($SortWrappers.IntTo$Snap $arg1@1075@01))
  ($SortWrappers.IntTo$Snap $arg2@1076@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1074@01)
    ($SortWrappers.IntTo$Snap $arg1@1075@01))
  ($SortWrappers.IntTo$Snap $arg2@1076@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1074@01)
      ($SortWrappers.IntTo$Snap $arg1@1075@01))
    ($SortWrappers.IntTo$Snap $arg2@1076@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 22
(declare-fun inv@1078@01 (Int Int Int) Int)
(declare-fun img@1079@01 (Int Int Int) Bool)
(declare-fun inv@1080@01 (Int Int Int) Int)
(declare-fun img@1081@01 (Int Int Int) Bool)
(declare-fun inv@1082@01 (Int Int Int) Int)
(declare-fun img@1083@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef86|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef87|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1074@01 Int) ($arg1@1075@01 Int) ($arg2@1076@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1074@01)
          ($SortWrappers.IntTo$Snap $arg1@1075@01))
        ($SortWrappers.IntTo$Snap $arg2@1076@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1074@01)
        ($SortWrappers.IntTo$Snap $arg1@1075@01))
      ($SortWrappers.IntTo$Snap $arg2@1076@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1074@01)
        ($SortWrappers.IntTo$Snap $arg1@1075@01))
      ($SortWrappers.IntTo$Snap $arg2@1076@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1074@01)
      ($SortWrappers.IntTo$Snap $arg1@1075@01))
    ($SortWrappers.IntTo$Snap $arg2@1076@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1074@01)
      ($SortWrappers.IntTo$Snap $arg1@1075@01))
    ($SortWrappers.IntTo$Snap $arg2@1076@01))))
  :qid |e$Transfer-aux|)))
(push) ; 22
(assert (not (forall (($arg0@1074@01 Int) ($arg1@1075@01 Int) ($arg2@1076@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1074@01)
          ($SortWrappers.IntTo$Snap $arg1@1075@01))
        ($SortWrappers.IntTo$Snap $arg2@1076@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1074@01)
            ($SortWrappers.IntTo$Snap $arg1@1075@01))
          ($SortWrappers.IntTo$Snap $arg2@1076@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1074@01)
            ($SortWrappers.IntTo$Snap $arg1@1075@01))
          ($SortWrappers.IntTo$Snap $arg2@1076@01))))))
  
  :qid |quant-u-1699|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 22
(assert (not (forall (($arg01@1074@01 Int) ($arg11@1075@01 Int) ($arg21@1076@01 Int) ($arg02@1074@01 Int) ($arg12@1075@01 Int) ($arg22@1076@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1074@01)
                ($SortWrappers.IntTo$Snap $arg11@1075@01))
              ($SortWrappers.IntTo$Snap $arg21@1076@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1074@01)
              ($SortWrappers.IntTo$Snap $arg11@1075@01))
            ($SortWrappers.IntTo$Snap $arg21@1076@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1074@01)
              ($SortWrappers.IntTo$Snap $arg11@1075@01))
            ($SortWrappers.IntTo$Snap $arg21@1076@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1074@01)
              ($SortWrappers.IntTo$Snap $arg11@1075@01))
            ($SortWrappers.IntTo$Snap $arg21@1076@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1074@01)
                ($SortWrappers.IntTo$Snap $arg12@1075@01))
              ($SortWrappers.IntTo$Snap $arg22@1076@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1074@01)
              ($SortWrappers.IntTo$Snap $arg12@1075@01))
            ($SortWrappers.IntTo$Snap $arg22@1076@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1074@01)
              ($SortWrappers.IntTo$Snap $arg12@1075@01))
            ($SortWrappers.IntTo$Snap $arg22@1076@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1074@01)
              ($SortWrappers.IntTo$Snap $arg12@1075@01))
            ($SortWrappers.IntTo$Snap $arg22@1076@01)))))
      (and
        (and (= $arg01@1074@01 $arg02@1074@01) (= $arg11@1075@01 $arg12@1075@01))
        (= $arg21@1076@01 $arg22@1076@01)))
    (and
      (and (= $arg01@1074@01 $arg02@1074@01) (= $arg11@1075@01 $arg12@1075@01))
      (= $arg21@1076@01 $arg22@1076@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1074@01 Int) ($arg1@1075@01 Int) ($arg2@1076@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1074@01)
            ($SortWrappers.IntTo$Snap $arg1@1075@01))
          ($SortWrappers.IntTo$Snap $arg2@1076@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1074@01)
            ($SortWrappers.IntTo$Snap $arg1@1075@01))
          ($SortWrappers.IntTo$Snap $arg2@1076@01)))))
    (and
      (and
        (= (inv@1078@01 $arg0@1074@01 $arg1@1075@01 $arg2@1076@01) $arg0@1074@01)
        (= (inv@1080@01 $arg0@1074@01 $arg1@1075@01 $arg2@1076@01) $arg1@1075@01)
        (= (inv@1082@01 $arg0@1074@01 $arg1@1075@01 $arg2@1076@01) $arg2@1076@01))
      (and
        (img@1079@01 $arg0@1074@01 $arg1@1075@01 $arg2@1076@01)
        (img@1081@01 $arg0@1074@01 $arg1@1075@01 $arg2@1076@01)
        (img@1083@01 $arg0@1074@01 $arg1@1075@01 $arg2@1076@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1074@01)
      ($SortWrappers.IntTo$Snap $arg1@1075@01))
    ($SortWrappers.IntTo$Snap $arg2@1076@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1074@01)
      ($SortWrappers.IntTo$Snap $arg1@1075@01))
    ($SortWrappers.IntTo$Snap $arg2@1076@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1079@01 $arg0 $arg1 $arg2)
        (img@1081@01 $arg0 $arg1 $arg2)
        (img@1083@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1078@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1080@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1082@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1078@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1080@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1082@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1078@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1080@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1082@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1078@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1080@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1082@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1078@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1080@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1082@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1078@01 $arg0 $arg1 $arg2) (inv@1080@01 $arg0 $arg1 $arg2) (inv@1082@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1700|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 22
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1078@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1080@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1082@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1079@01 $arg0 $arg1 $arg2)
        (img@1081@01 $arg0 $arg1 $arg2)
        (img@1083@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1078@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1080@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1082@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@1077@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1078@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1080@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1082@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1701|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@1084@01 Int)
(declare-const $arg1@1085@01 Int)
(declare-const $arg2@1086@01 Int)
(push) ; 22
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1087@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef88|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef89|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1084@01)
    ($SortWrappers.IntTo$Snap $arg1@1085@01))
  ($SortWrappers.IntTo$Snap $arg2@1086@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1084@01)
    ($SortWrappers.IntTo$Snap $arg1@1085@01))
  ($SortWrappers.IntTo$Snap $arg2@1086@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1084@01)
      ($SortWrappers.IntTo$Snap $arg1@1085@01))
    ($SortWrappers.IntTo$Snap $arg2@1086@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 22
(declare-fun inv@1088@01 (Int Int Int) Int)
(declare-fun img@1089@01 (Int Int Int) Bool)
(declare-fun inv@1090@01 (Int Int Int) Int)
(declare-fun img@1091@01 (Int Int Int) Bool)
(declare-fun inv@1092@01 (Int Int Int) Int)
(declare-fun img@1093@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef88|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef89|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1084@01 Int) ($arg1@1085@01 Int) ($arg2@1086@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1084@01)
          ($SortWrappers.IntTo$Snap $arg1@1085@01))
        ($SortWrappers.IntTo$Snap $arg2@1086@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1084@01)
        ($SortWrappers.IntTo$Snap $arg1@1085@01))
      ($SortWrappers.IntTo$Snap $arg2@1086@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1084@01)
        ($SortWrappers.IntTo$Snap $arg1@1085@01))
      ($SortWrappers.IntTo$Snap $arg2@1086@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1084@01)
      ($SortWrappers.IntTo$Snap $arg1@1085@01))
    ($SortWrappers.IntTo$Snap $arg2@1086@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1084@01)
      ($SortWrappers.IntTo$Snap $arg1@1085@01))
    ($SortWrappers.IntTo$Snap $arg2@1086@01))))
  :qid |e$Approval-aux|)))
(push) ; 22
(assert (not (forall (($arg0@1084@01 Int) ($arg1@1085@01 Int) ($arg2@1086@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1084@01)
          ($SortWrappers.IntTo$Snap $arg1@1085@01))
        ($SortWrappers.IntTo$Snap $arg2@1086@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1084@01)
            ($SortWrappers.IntTo$Snap $arg1@1085@01))
          ($SortWrappers.IntTo$Snap $arg2@1086@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1084@01)
            ($SortWrappers.IntTo$Snap $arg1@1085@01))
          ($SortWrappers.IntTo$Snap $arg2@1086@01))))))
  
  :qid |quant-u-1702|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 22
(assert (not (forall (($arg01@1084@01 Int) ($arg11@1085@01 Int) ($arg21@1086@01 Int) ($arg02@1084@01 Int) ($arg12@1085@01 Int) ($arg22@1086@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1084@01)
                ($SortWrappers.IntTo$Snap $arg11@1085@01))
              ($SortWrappers.IntTo$Snap $arg21@1086@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1084@01)
              ($SortWrappers.IntTo$Snap $arg11@1085@01))
            ($SortWrappers.IntTo$Snap $arg21@1086@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1084@01)
              ($SortWrappers.IntTo$Snap $arg11@1085@01))
            ($SortWrappers.IntTo$Snap $arg21@1086@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1084@01)
              ($SortWrappers.IntTo$Snap $arg11@1085@01))
            ($SortWrappers.IntTo$Snap $arg21@1086@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1084@01)
                ($SortWrappers.IntTo$Snap $arg12@1085@01))
              ($SortWrappers.IntTo$Snap $arg22@1086@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1084@01)
              ($SortWrappers.IntTo$Snap $arg12@1085@01))
            ($SortWrappers.IntTo$Snap $arg22@1086@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1084@01)
              ($SortWrappers.IntTo$Snap $arg12@1085@01))
            ($SortWrappers.IntTo$Snap $arg22@1086@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1084@01)
              ($SortWrappers.IntTo$Snap $arg12@1085@01))
            ($SortWrappers.IntTo$Snap $arg22@1086@01)))))
      (and
        (and (= $arg01@1084@01 $arg02@1084@01) (= $arg11@1085@01 $arg12@1085@01))
        (= $arg21@1086@01 $arg22@1086@01)))
    (and
      (and (= $arg01@1084@01 $arg02@1084@01) (= $arg11@1085@01 $arg12@1085@01))
      (= $arg21@1086@01 $arg22@1086@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1084@01 Int) ($arg1@1085@01 Int) ($arg2@1086@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1084@01)
            ($SortWrappers.IntTo$Snap $arg1@1085@01))
          ($SortWrappers.IntTo$Snap $arg2@1086@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1084@01)
            ($SortWrappers.IntTo$Snap $arg1@1085@01))
          ($SortWrappers.IntTo$Snap $arg2@1086@01)))))
    (and
      (and
        (= (inv@1088@01 $arg0@1084@01 $arg1@1085@01 $arg2@1086@01) $arg0@1084@01)
        (= (inv@1090@01 $arg0@1084@01 $arg1@1085@01 $arg2@1086@01) $arg1@1085@01)
        (= (inv@1092@01 $arg0@1084@01 $arg1@1085@01 $arg2@1086@01) $arg2@1086@01))
      (and
        (img@1089@01 $arg0@1084@01 $arg1@1085@01 $arg2@1086@01)
        (img@1091@01 $arg0@1084@01 $arg1@1085@01 $arg2@1086@01)
        (img@1093@01 $arg0@1084@01 $arg1@1085@01 $arg2@1086@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1084@01)
      ($SortWrappers.IntTo$Snap $arg1@1085@01))
    ($SortWrappers.IntTo$Snap $arg2@1086@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1084@01)
      ($SortWrappers.IntTo$Snap $arg1@1085@01))
    ($SortWrappers.IntTo$Snap $arg2@1086@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1089@01 $arg0 $arg1 $arg2)
        (img@1091@01 $arg0 $arg1 $arg2)
        (img@1093@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1088@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1090@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1092@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1088@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1090@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1092@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1088@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1090@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1092@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1088@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1090@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1092@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1088@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1090@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1092@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1088@01 $arg0 $arg1 $arg2) (inv@1090@01 $arg0 $arg1 $arg2) (inv@1092@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1703|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 22
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1088@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1090@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1092@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1089@01 $arg0 $arg1 $arg2)
        (img@1091@01 $arg0 $arg1 $arg2)
        (img@1093@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1088@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1090@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1092@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@1087@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1088@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1090@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1092@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1704|))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc
(push) ; 22
(set-option :timeout 10)
(assert (not (not l$send_fail$1@864@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not l$send_fail$1@864@01))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 290 | l$send_fail$1@864@01 | live]
; [else-branch: 290 | !(l$send_fail$1@864@01) | live]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 290 | l$send_fail$1@864@01]
(assert l$send_fail$1@864@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(msg, 0)): Int)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(declare-const $t@1094@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 291 | True | live]
; [else-branch: 291 | False | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 291 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1095@01 $Snap)
(assert (= $t@1095@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1096@01 $Struct)
(assert (=
  self@1096@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 23
; [then-branch: 292 | False | dead]
; [else-branch: 292 | True | live]
(set-option :timeout 0)
(push) ; 23
; [else-branch: 292 | True]
(pop) ; 23
(pop) ; 22
(push) ; 22
; [else-branch: 290 | !(l$send_fail$1@864@01)]
(assert (not l$send_fail$1@864@01))
(pop) ; 22
; [eval] !l$send_fail$1
(push) ; 22
(set-option :timeout 10)
(assert (not l$send_fail$1@864@01))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not (not l$send_fail$1@864@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 293 | !(l$send_fail$1@864@01) | live]
; [else-branch: 293 | l$send_fail$1@864@01 | live]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 293 | !(l$send_fail$1@864@01)]
(assert (not l$send_fail$1@864@01))
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; i1$$pre_self := self
; [exec]
; i1$$pre_$contracts := $contracts
; [exec]
; $contracts := l$havoc$1
; [exec]
; $old_$contracts := $contracts
; [exec]
; self := l$havoc$2
; [exec]
; $contracts := l$havoc$3
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@1097@01 $Snap)
(assert (= $t@1097@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$havoc$2@868@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@1098@01 $Snap)
(assert (= $t@1098@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$havoc$2@868@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1099@01 $Snap)
(assert (= $t@1099@01 ($Snap.combine ($Snap.first $t@1099@01) ($Snap.second $t@1099@01))))
(assert (= ($Snap.first $t@1099@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 2))))
(assert (= ($Snap.second $t@1099@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1100@01 $Snap)
(assert (= $t@1100@01 ($Snap.combine ($Snap.first $t@1100@01) ($Snap.second $t@1100@01))))
(assert (= ($Snap.first $t@1100@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 3))))
(assert (= ($Snap.second $t@1100@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1101@01 $Snap)
(assert (= $t@1101@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@1102@01 Int)
(set-option :timeout 0)
(push) ; 23
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 24
; [then-branch: 294 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 4)), $q2@1102@01)) | live]
; [else-branch: 294 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 4)), $q2@1102@01) | live]
(push) ; 25
; [then-branch: 294 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 4)), $q2@1102@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1102@01))))
(pop) ; 25
(push) ; 25
; [else-branch: 294 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 4)), $q2@1102@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1102@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 25
(pop) ; 24
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1102@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1102@01)))))
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1102@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1102@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1102@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1102@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1686@11@1686@345-aux|)))
(assert (forall (($q2@1102@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1102@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1102@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1102@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1686@11@1686@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@1103@01 $Snap)
(assert (= $t@1103@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@1104@01 Int)
(set-option :timeout 0)
(push) ; 23
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1104@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1104@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 4)) $q2@1104@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1687@11@1687@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@1105@01 $Snap)
(assert (= $t@1105@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@1106@01 Int)
(set-option :timeout 0)
(push) ; 23
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@1107@01 Int)
(push) ; 24
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 25
; [then-branch: 295 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$2@868@01, 5)), $q3@1106@01), $q4@1107@01)) | live]
; [else-branch: 295 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$2@868@01, 5)), $q3@1106@01), $q4@1107@01) | live]
(push) ; 26
; [then-branch: 295 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$2@868@01, 5)), $q3@1106@01), $q4@1107@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01))))
(pop) ; 26
(push) ; 26
; [else-branch: 295 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$2@868@01, 5)), $q3@1106@01), $q4@1107@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01)))))
(pop) ; 24
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@1107@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1688@131@1688@597-aux|)))
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1106@01 Int)) (!
  (forall (($q4@1107@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1688@131@1688@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1688@11@1688@598-aux|)))
(assert (forall (($q3@1106@01 Int)) (!
  (forall (($q4@1107@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01) $q4@1107@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1688@131@1688@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1106@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1688@11@1688@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@1108@01 $Snap)
(assert (= $t@1108@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@1109@01 Int)
(set-option :timeout 0)
(push) ; 23
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@1110@01 Int)
(push) ; 24
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 24
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1109@01 Int)) (!
  (forall (($q4@1110@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1109@01) $q4@1110@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1109@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1109@01) $q4@1110@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1689@131@1689@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$2@868@01 5)) $q3@1109@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1689@11@1689@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1111@01 $Snap)
(assert (= $t@1111@01 ($Snap.combine ($Snap.first $t@1111@01) ($Snap.second $t@1111@01))))
(assert (= ($Snap.first $t@1111@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 6))))
(assert (= ($Snap.second $t@1111@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1112@01 $Snap)
(assert (= $t@1112@01 ($Snap.combine ($Snap.first $t@1112@01) ($Snap.second $t@1112@01))))
(assert (= ($Snap.first $t@1112@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 7))))
(assert (= ($Snap.second $t@1112@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1113@01 $Snap)
(assert (= $t@1113@01 ($Snap.combine ($Snap.first $t@1113@01) ($Snap.second $t@1113@01))))
(assert (= ($Snap.first $t@1113@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 8))))
(assert (= ($Snap.second $t@1113@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@1114@01 $Snap)
(assert (= $t@1114@01 ($Snap.combine ($Snap.first $t@1114@01) ($Snap.second $t@1114@01))))
(assert (= ($Snap.first $t@1114@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 9))))
(assert (= ($Snap.second $t@1114@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1115@01 $Snap)
(assert (= $t@1115@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@1116@01 Int)
(set-option :timeout 0)
(push) ; 23
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 24
; [then-branch: 296 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 11)), $q5@1116@01)) | live]
; [else-branch: 296 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 11)), $q5@1116@01) | live]
(push) ; 25
; [then-branch: 296 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 11)), $q5@1116@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1116@01))))
(pop) ; 25
(push) ; 25
; [else-branch: 296 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 11)), $q5@1116@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1116@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 25
(pop) ; 24
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1116@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1116@01)))))
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1116@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1116@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1116@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1116@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1694@11@1694@348-aux|)))
(assert (forall (($q5@1116@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1116@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1116@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1116@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1694@11@1694@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@1117@01 $Snap)
(assert (= $t@1117@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@1118@01 Int)
(set-option :timeout 0)
(push) ; 23
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1118@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1118@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $q5@1118@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1695@11@1695@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1119@01 $Snap)
(assert (= $t@1119@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@1120@01 Int)
(set-option :timeout 0)
(push) ; 23
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 24
; [then-branch: 297 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 12)), $q6@1120@01)) | live]
; [else-branch: 297 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 12)), $q6@1120@01) | live]
(push) ; 25
; [then-branch: 297 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 12)), $q6@1120@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1120@01))))
(pop) ; 25
(push) ; 25
; [else-branch: 297 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$2@868@01, 12)), $q6@1120@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1120@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 25
(pop) ; 24
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1120@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1120@01)))))
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1120@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1120@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1120@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1120@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1696@11@1696@348-aux|)))
(assert (forall (($q6@1120@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1120@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1120@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1120@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1696@11@1696@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@1121@01 $Snap)
(assert (= $t@1121@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@1122@01 Int)
(set-option :timeout 0)
(push) ; 23
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1122@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1122@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 12)) $q6@1122@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1697@11@1697@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@1123@01 $Snap)
(assert (= $t@1123@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@1124@01 $Snap)
(assert (= $t@1124@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@1125@01 Int)
(set-option :timeout 0)
(push) ; 23
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($old_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($old_self, 11)
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($a@1125@01 Int)) (!
  (>=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $a@1125@01)
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1033@01 11)) $a@1125@01))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $a@1125@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1700@11@1700@262|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not l$no_reentrant_call@870@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not l$no_reentrant_call@870@01))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 298 | l$no_reentrant_call@870@01 | live]
; [else-branch: 298 | !(l$no_reentrant_call@870@01) | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 298 | l$no_reentrant_call@870@01]
(assert l$no_reentrant_call@870@01)
; [exec]
; self := $old_self
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$4
; [exec]
; $old_$contracts := i1$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$5
; [exec]
; $old_$contracts := i1$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1126@01 Int)
(declare-const $arg1@1127@01 Int)
(declare-const $arg2@1128@01 Int)
(push) ; 24
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1129@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef90|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef91|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1126@01)
    ($SortWrappers.IntTo$Snap $arg1@1127@01))
  ($SortWrappers.IntTo$Snap $arg2@1128@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1126@01)
    ($SortWrappers.IntTo$Snap $arg1@1127@01))
  ($SortWrappers.IntTo$Snap $arg2@1128@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1126@01)
      ($SortWrappers.IntTo$Snap $arg1@1127@01))
    ($SortWrappers.IntTo$Snap $arg2@1128@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1130@01 (Int Int Int) Int)
(declare-fun img@1131@01 (Int Int Int) Bool)
(declare-fun inv@1132@01 (Int Int Int) Int)
(declare-fun img@1133@01 (Int Int Int) Bool)
(declare-fun inv@1134@01 (Int Int Int) Int)
(declare-fun img@1135@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef90|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef91|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1126@01 Int) ($arg1@1127@01 Int) ($arg2@1128@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1126@01)
          ($SortWrappers.IntTo$Snap $arg1@1127@01))
        ($SortWrappers.IntTo$Snap $arg2@1128@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1126@01)
        ($SortWrappers.IntTo$Snap $arg1@1127@01))
      ($SortWrappers.IntTo$Snap $arg2@1128@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1126@01)
        ($SortWrappers.IntTo$Snap $arg1@1127@01))
      ($SortWrappers.IntTo$Snap $arg2@1128@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1126@01)
      ($SortWrappers.IntTo$Snap $arg1@1127@01))
    ($SortWrappers.IntTo$Snap $arg2@1128@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1126@01)
      ($SortWrappers.IntTo$Snap $arg1@1127@01))
    ($SortWrappers.IntTo$Snap $arg2@1128@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1126@01 Int) ($arg1@1127@01 Int) ($arg2@1128@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1126@01)
          ($SortWrappers.IntTo$Snap $arg1@1127@01))
        ($SortWrappers.IntTo$Snap $arg2@1128@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1126@01)
            ($SortWrappers.IntTo$Snap $arg1@1127@01))
          ($SortWrappers.IntTo$Snap $arg2@1128@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1126@01)
            ($SortWrappers.IntTo$Snap $arg1@1127@01))
          ($SortWrappers.IntTo$Snap $arg2@1128@01))))))
  
  :qid |quant-u-1705|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1126@01 Int) ($arg11@1127@01 Int) ($arg21@1128@01 Int) ($arg02@1126@01 Int) ($arg12@1127@01 Int) ($arg22@1128@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1126@01)
                ($SortWrappers.IntTo$Snap $arg11@1127@01))
              ($SortWrappers.IntTo$Snap $arg21@1128@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1126@01)
              ($SortWrappers.IntTo$Snap $arg11@1127@01))
            ($SortWrappers.IntTo$Snap $arg21@1128@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1126@01)
              ($SortWrappers.IntTo$Snap $arg11@1127@01))
            ($SortWrappers.IntTo$Snap $arg21@1128@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1126@01)
              ($SortWrappers.IntTo$Snap $arg11@1127@01))
            ($SortWrappers.IntTo$Snap $arg21@1128@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1126@01)
                ($SortWrappers.IntTo$Snap $arg12@1127@01))
              ($SortWrappers.IntTo$Snap $arg22@1128@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1126@01)
              ($SortWrappers.IntTo$Snap $arg12@1127@01))
            ($SortWrappers.IntTo$Snap $arg22@1128@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1126@01)
              ($SortWrappers.IntTo$Snap $arg12@1127@01))
            ($SortWrappers.IntTo$Snap $arg22@1128@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1126@01)
              ($SortWrappers.IntTo$Snap $arg12@1127@01))
            ($SortWrappers.IntTo$Snap $arg22@1128@01)))))
      (and
        (and (= $arg01@1126@01 $arg02@1126@01) (= $arg11@1127@01 $arg12@1127@01))
        (= $arg21@1128@01 $arg22@1128@01)))
    (and
      (and (= $arg01@1126@01 $arg02@1126@01) (= $arg11@1127@01 $arg12@1127@01))
      (= $arg21@1128@01 $arg22@1128@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1126@01 Int) ($arg1@1127@01 Int) ($arg2@1128@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1126@01)
            ($SortWrappers.IntTo$Snap $arg1@1127@01))
          ($SortWrappers.IntTo$Snap $arg2@1128@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1126@01)
            ($SortWrappers.IntTo$Snap $arg1@1127@01))
          ($SortWrappers.IntTo$Snap $arg2@1128@01)))))
    (and
      (and
        (= (inv@1130@01 $arg0@1126@01 $arg1@1127@01 $arg2@1128@01) $arg0@1126@01)
        (= (inv@1132@01 $arg0@1126@01 $arg1@1127@01 $arg2@1128@01) $arg1@1127@01)
        (= (inv@1134@01 $arg0@1126@01 $arg1@1127@01 $arg2@1128@01) $arg2@1128@01))
      (and
        (img@1131@01 $arg0@1126@01 $arg1@1127@01 $arg2@1128@01)
        (img@1133@01 $arg0@1126@01 $arg1@1127@01 $arg2@1128@01)
        (img@1135@01 $arg0@1126@01 $arg1@1127@01 $arg2@1128@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1126@01)
      ($SortWrappers.IntTo$Snap $arg1@1127@01))
    ($SortWrappers.IntTo$Snap $arg2@1128@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1126@01)
      ($SortWrappers.IntTo$Snap $arg1@1127@01))
    ($SortWrappers.IntTo$Snap $arg2@1128@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1131@01 $arg0 $arg1 $arg2)
        (img@1133@01 $arg0 $arg1 $arg2)
        (img@1135@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1130@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1132@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1134@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1130@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1132@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1134@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1130@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1132@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1134@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1130@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1132@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1134@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1130@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1132@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1134@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1130@01 $arg0 $arg1 $arg2) (inv@1132@01 $arg0 $arg1 $arg2) (inv@1134@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1706|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1130@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1132@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1134@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1131@01 $arg0 $arg1 $arg2)
        (img@1133@01 $arg0 $arg1 $arg2)
        (img@1135@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1130@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1132@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1134@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@1129@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1130@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1132@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1134@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1707|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1136@01 Int)
(declare-const $arg1@1137@01 Int)
(declare-const $arg2@1138@01 Int)
(push) ; 24
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1139@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef92|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef93|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1136@01)
    ($SortWrappers.IntTo$Snap $arg1@1137@01))
  ($SortWrappers.IntTo$Snap $arg2@1138@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1136@01)
    ($SortWrappers.IntTo$Snap $arg1@1137@01))
  ($SortWrappers.IntTo$Snap $arg2@1138@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1136@01)
      ($SortWrappers.IntTo$Snap $arg1@1137@01))
    ($SortWrappers.IntTo$Snap $arg2@1138@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1140@01 (Int Int Int) Int)
(declare-fun img@1141@01 (Int Int Int) Bool)
(declare-fun inv@1142@01 (Int Int Int) Int)
(declare-fun img@1143@01 (Int Int Int) Bool)
(declare-fun inv@1144@01 (Int Int Int) Int)
(declare-fun img@1145@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef92|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef93|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1136@01 Int) ($arg1@1137@01 Int) ($arg2@1138@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1136@01)
          ($SortWrappers.IntTo$Snap $arg1@1137@01))
        ($SortWrappers.IntTo$Snap $arg2@1138@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1136@01)
        ($SortWrappers.IntTo$Snap $arg1@1137@01))
      ($SortWrappers.IntTo$Snap $arg2@1138@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1136@01)
        ($SortWrappers.IntTo$Snap $arg1@1137@01))
      ($SortWrappers.IntTo$Snap $arg2@1138@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1136@01)
      ($SortWrappers.IntTo$Snap $arg1@1137@01))
    ($SortWrappers.IntTo$Snap $arg2@1138@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1136@01)
      ($SortWrappers.IntTo$Snap $arg1@1137@01))
    ($SortWrappers.IntTo$Snap $arg2@1138@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1136@01 Int) ($arg1@1137@01 Int) ($arg2@1138@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1136@01)
          ($SortWrappers.IntTo$Snap $arg1@1137@01))
        ($SortWrappers.IntTo$Snap $arg2@1138@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1136@01)
            ($SortWrappers.IntTo$Snap $arg1@1137@01))
          ($SortWrappers.IntTo$Snap $arg2@1138@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1136@01)
            ($SortWrappers.IntTo$Snap $arg1@1137@01))
          ($SortWrappers.IntTo$Snap $arg2@1138@01))))))
  
  :qid |quant-u-1708|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1136@01 Int) ($arg11@1137@01 Int) ($arg21@1138@01 Int) ($arg02@1136@01 Int) ($arg12@1137@01 Int) ($arg22@1138@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1136@01)
                ($SortWrappers.IntTo$Snap $arg11@1137@01))
              ($SortWrappers.IntTo$Snap $arg21@1138@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1136@01)
              ($SortWrappers.IntTo$Snap $arg11@1137@01))
            ($SortWrappers.IntTo$Snap $arg21@1138@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1136@01)
              ($SortWrappers.IntTo$Snap $arg11@1137@01))
            ($SortWrappers.IntTo$Snap $arg21@1138@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1136@01)
              ($SortWrappers.IntTo$Snap $arg11@1137@01))
            ($SortWrappers.IntTo$Snap $arg21@1138@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1136@01)
                ($SortWrappers.IntTo$Snap $arg12@1137@01))
              ($SortWrappers.IntTo$Snap $arg22@1138@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1136@01)
              ($SortWrappers.IntTo$Snap $arg12@1137@01))
            ($SortWrappers.IntTo$Snap $arg22@1138@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1136@01)
              ($SortWrappers.IntTo$Snap $arg12@1137@01))
            ($SortWrappers.IntTo$Snap $arg22@1138@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1136@01)
              ($SortWrappers.IntTo$Snap $arg12@1137@01))
            ($SortWrappers.IntTo$Snap $arg22@1138@01)))))
      (and
        (and (= $arg01@1136@01 $arg02@1136@01) (= $arg11@1137@01 $arg12@1137@01))
        (= $arg21@1138@01 $arg22@1138@01)))
    (and
      (and (= $arg01@1136@01 $arg02@1136@01) (= $arg11@1137@01 $arg12@1137@01))
      (= $arg21@1138@01 $arg22@1138@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1136@01 Int) ($arg1@1137@01 Int) ($arg2@1138@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1136@01)
            ($SortWrappers.IntTo$Snap $arg1@1137@01))
          ($SortWrappers.IntTo$Snap $arg2@1138@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1136@01)
            ($SortWrappers.IntTo$Snap $arg1@1137@01))
          ($SortWrappers.IntTo$Snap $arg2@1138@01)))))
    (and
      (and
        (= (inv@1140@01 $arg0@1136@01 $arg1@1137@01 $arg2@1138@01) $arg0@1136@01)
        (= (inv@1142@01 $arg0@1136@01 $arg1@1137@01 $arg2@1138@01) $arg1@1137@01)
        (= (inv@1144@01 $arg0@1136@01 $arg1@1137@01 $arg2@1138@01) $arg2@1138@01))
      (and
        (img@1141@01 $arg0@1136@01 $arg1@1137@01 $arg2@1138@01)
        (img@1143@01 $arg0@1136@01 $arg1@1137@01 $arg2@1138@01)
        (img@1145@01 $arg0@1136@01 $arg1@1137@01 $arg2@1138@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1136@01)
      ($SortWrappers.IntTo$Snap $arg1@1137@01))
    ($SortWrappers.IntTo$Snap $arg2@1138@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1136@01)
      ($SortWrappers.IntTo$Snap $arg1@1137@01))
    ($SortWrappers.IntTo$Snap $arg2@1138@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1141@01 $arg0 $arg1 $arg2)
        (img@1143@01 $arg0 $arg1 $arg2)
        (img@1145@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1140@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1142@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1144@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1140@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1142@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1144@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1140@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1142@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1144@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1140@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1142@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1144@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1140@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1142@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1144@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1140@01 $arg0 $arg1 $arg2) (inv@1142@01 $arg0 $arg1 $arg2) (inv@1144@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1709|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1140@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1142@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1144@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1141@01 $arg0 $arg1 $arg2)
        (img@1143@01 $arg0 $arg1 $arg2)
        (img@1145@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1140@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1142@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1144@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@1139@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1140@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1142@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1144@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1710|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1146@01 Int)
(declare-const $arg1@1147@01 Int)
(declare-const $arg2@1148@01 Int)
(push) ; 24
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1149@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef94|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef95|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1146@01)
    ($SortWrappers.IntTo$Snap $arg1@1147@01))
  ($SortWrappers.IntTo$Snap $arg2@1148@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1146@01)
    ($SortWrappers.IntTo$Snap $arg1@1147@01))
  ($SortWrappers.IntTo$Snap $arg2@1148@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1146@01)
      ($SortWrappers.IntTo$Snap $arg1@1147@01))
    ($SortWrappers.IntTo$Snap $arg2@1148@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1150@01 (Int Int Int) Int)
(declare-fun img@1151@01 (Int Int Int) Bool)
(declare-fun inv@1152@01 (Int Int Int) Int)
(declare-fun img@1153@01 (Int Int Int) Bool)
(declare-fun inv@1154@01 (Int Int Int) Int)
(declare-fun img@1155@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef94|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef95|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1146@01 Int) ($arg1@1147@01 Int) ($arg2@1148@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1146@01)
          ($SortWrappers.IntTo$Snap $arg1@1147@01))
        ($SortWrappers.IntTo$Snap $arg2@1148@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1146@01)
        ($SortWrappers.IntTo$Snap $arg1@1147@01))
      ($SortWrappers.IntTo$Snap $arg2@1148@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1146@01)
        ($SortWrappers.IntTo$Snap $arg1@1147@01))
      ($SortWrappers.IntTo$Snap $arg2@1148@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1146@01)
      ($SortWrappers.IntTo$Snap $arg1@1147@01))
    ($SortWrappers.IntTo$Snap $arg2@1148@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1146@01)
      ($SortWrappers.IntTo$Snap $arg1@1147@01))
    ($SortWrappers.IntTo$Snap $arg2@1148@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1146@01 Int) ($arg1@1147@01 Int) ($arg2@1148@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1146@01)
          ($SortWrappers.IntTo$Snap $arg1@1147@01))
        ($SortWrappers.IntTo$Snap $arg2@1148@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1146@01)
            ($SortWrappers.IntTo$Snap $arg1@1147@01))
          ($SortWrappers.IntTo$Snap $arg2@1148@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1146@01)
            ($SortWrappers.IntTo$Snap $arg1@1147@01))
          ($SortWrappers.IntTo$Snap $arg2@1148@01))))))
  
  :qid |quant-u-1711|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1146@01 Int) ($arg11@1147@01 Int) ($arg21@1148@01 Int) ($arg02@1146@01 Int) ($arg12@1147@01 Int) ($arg22@1148@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1146@01)
                ($SortWrappers.IntTo$Snap $arg11@1147@01))
              ($SortWrappers.IntTo$Snap $arg21@1148@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1146@01)
              ($SortWrappers.IntTo$Snap $arg11@1147@01))
            ($SortWrappers.IntTo$Snap $arg21@1148@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1146@01)
              ($SortWrappers.IntTo$Snap $arg11@1147@01))
            ($SortWrappers.IntTo$Snap $arg21@1148@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1146@01)
              ($SortWrappers.IntTo$Snap $arg11@1147@01))
            ($SortWrappers.IntTo$Snap $arg21@1148@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1146@01)
                ($SortWrappers.IntTo$Snap $arg12@1147@01))
              ($SortWrappers.IntTo$Snap $arg22@1148@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1146@01)
              ($SortWrappers.IntTo$Snap $arg12@1147@01))
            ($SortWrappers.IntTo$Snap $arg22@1148@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1146@01)
              ($SortWrappers.IntTo$Snap $arg12@1147@01))
            ($SortWrappers.IntTo$Snap $arg22@1148@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1146@01)
              ($SortWrappers.IntTo$Snap $arg12@1147@01))
            ($SortWrappers.IntTo$Snap $arg22@1148@01)))))
      (and
        (and (= $arg01@1146@01 $arg02@1146@01) (= $arg11@1147@01 $arg12@1147@01))
        (= $arg21@1148@01 $arg22@1148@01)))
    (and
      (and (= $arg01@1146@01 $arg02@1146@01) (= $arg11@1147@01 $arg12@1147@01))
      (= $arg21@1148@01 $arg22@1148@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1146@01 Int) ($arg1@1147@01 Int) ($arg2@1148@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1146@01)
            ($SortWrappers.IntTo$Snap $arg1@1147@01))
          ($SortWrappers.IntTo$Snap $arg2@1148@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1146@01)
            ($SortWrappers.IntTo$Snap $arg1@1147@01))
          ($SortWrappers.IntTo$Snap $arg2@1148@01)))))
    (and
      (and
        (= (inv@1150@01 $arg0@1146@01 $arg1@1147@01 $arg2@1148@01) $arg0@1146@01)
        (= (inv@1152@01 $arg0@1146@01 $arg1@1147@01 $arg2@1148@01) $arg1@1147@01)
        (= (inv@1154@01 $arg0@1146@01 $arg1@1147@01 $arg2@1148@01) $arg2@1148@01))
      (and
        (img@1151@01 $arg0@1146@01 $arg1@1147@01 $arg2@1148@01)
        (img@1153@01 $arg0@1146@01 $arg1@1147@01 $arg2@1148@01)
        (img@1155@01 $arg0@1146@01 $arg1@1147@01 $arg2@1148@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1146@01)
      ($SortWrappers.IntTo$Snap $arg1@1147@01))
    ($SortWrappers.IntTo$Snap $arg2@1148@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1146@01)
      ($SortWrappers.IntTo$Snap $arg1@1147@01))
    ($SortWrappers.IntTo$Snap $arg2@1148@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1151@01 $arg0 $arg1 $arg2)
        (img@1153@01 $arg0 $arg1 $arg2)
        (img@1155@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1150@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1152@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1154@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1150@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1152@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1154@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1150@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1152@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1154@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1150@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1152@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1154@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1150@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1152@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1154@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1150@01 $arg0 $arg1 $arg2) (inv@1152@01 $arg0 $arg1 $arg2) (inv@1154@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1712|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1150@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1152@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1154@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1151@01 $arg0 $arg1 $arg2)
        (img@1153@01 $arg0 $arg1 $arg2)
        (img@1155@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1150@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1152@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1154@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@1149@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1150@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1152@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1154@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1713|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@1156@01 Int)
(declare-const $arg1@1157@01 Int)
(declare-const $arg2@1158@01 Int)
(push) ; 24
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1159@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef96|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef97|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1156@01)
    ($SortWrappers.IntTo$Snap $arg1@1157@01))
  ($SortWrappers.IntTo$Snap $arg2@1158@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1156@01)
    ($SortWrappers.IntTo$Snap $arg1@1157@01))
  ($SortWrappers.IntTo$Snap $arg2@1158@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1156@01)
      ($SortWrappers.IntTo$Snap $arg1@1157@01))
    ($SortWrappers.IntTo$Snap $arg2@1158@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1160@01 (Int Int Int) Int)
(declare-fun img@1161@01 (Int Int Int) Bool)
(declare-fun inv@1162@01 (Int Int Int) Int)
(declare-fun img@1163@01 (Int Int Int) Bool)
(declare-fun inv@1164@01 (Int Int Int) Int)
(declare-fun img@1165@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef96|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef97|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1156@01 Int) ($arg1@1157@01 Int) ($arg2@1158@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1156@01)
          ($SortWrappers.IntTo$Snap $arg1@1157@01))
        ($SortWrappers.IntTo$Snap $arg2@1158@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1156@01)
        ($SortWrappers.IntTo$Snap $arg1@1157@01))
      ($SortWrappers.IntTo$Snap $arg2@1158@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1156@01)
        ($SortWrappers.IntTo$Snap $arg1@1157@01))
      ($SortWrappers.IntTo$Snap $arg2@1158@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1156@01)
      ($SortWrappers.IntTo$Snap $arg1@1157@01))
    ($SortWrappers.IntTo$Snap $arg2@1158@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1156@01)
      ($SortWrappers.IntTo$Snap $arg1@1157@01))
    ($SortWrappers.IntTo$Snap $arg2@1158@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1156@01 Int) ($arg1@1157@01 Int) ($arg2@1158@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1156@01)
          ($SortWrappers.IntTo$Snap $arg1@1157@01))
        ($SortWrappers.IntTo$Snap $arg2@1158@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1156@01)
            ($SortWrappers.IntTo$Snap $arg1@1157@01))
          ($SortWrappers.IntTo$Snap $arg2@1158@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1156@01)
            ($SortWrappers.IntTo$Snap $arg1@1157@01))
          ($SortWrappers.IntTo$Snap $arg2@1158@01))))))
  
  :qid |quant-u-1714|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1156@01 Int) ($arg11@1157@01 Int) ($arg21@1158@01 Int) ($arg02@1156@01 Int) ($arg12@1157@01 Int) ($arg22@1158@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1156@01)
                ($SortWrappers.IntTo$Snap $arg11@1157@01))
              ($SortWrappers.IntTo$Snap $arg21@1158@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1156@01)
              ($SortWrappers.IntTo$Snap $arg11@1157@01))
            ($SortWrappers.IntTo$Snap $arg21@1158@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1156@01)
              ($SortWrappers.IntTo$Snap $arg11@1157@01))
            ($SortWrappers.IntTo$Snap $arg21@1158@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1156@01)
              ($SortWrappers.IntTo$Snap $arg11@1157@01))
            ($SortWrappers.IntTo$Snap $arg21@1158@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1156@01)
                ($SortWrappers.IntTo$Snap $arg12@1157@01))
              ($SortWrappers.IntTo$Snap $arg22@1158@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1156@01)
              ($SortWrappers.IntTo$Snap $arg12@1157@01))
            ($SortWrappers.IntTo$Snap $arg22@1158@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1156@01)
              ($SortWrappers.IntTo$Snap $arg12@1157@01))
            ($SortWrappers.IntTo$Snap $arg22@1158@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1156@01)
              ($SortWrappers.IntTo$Snap $arg12@1157@01))
            ($SortWrappers.IntTo$Snap $arg22@1158@01)))))
      (and
        (and (= $arg01@1156@01 $arg02@1156@01) (= $arg11@1157@01 $arg12@1157@01))
        (= $arg21@1158@01 $arg22@1158@01)))
    (and
      (and (= $arg01@1156@01 $arg02@1156@01) (= $arg11@1157@01 $arg12@1157@01))
      (= $arg21@1158@01 $arg22@1158@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1156@01 Int) ($arg1@1157@01 Int) ($arg2@1158@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1156@01)
            ($SortWrappers.IntTo$Snap $arg1@1157@01))
          ($SortWrappers.IntTo$Snap $arg2@1158@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1156@01)
            ($SortWrappers.IntTo$Snap $arg1@1157@01))
          ($SortWrappers.IntTo$Snap $arg2@1158@01)))))
    (and
      (and
        (= (inv@1160@01 $arg0@1156@01 $arg1@1157@01 $arg2@1158@01) $arg0@1156@01)
        (= (inv@1162@01 $arg0@1156@01 $arg1@1157@01 $arg2@1158@01) $arg1@1157@01)
        (= (inv@1164@01 $arg0@1156@01 $arg1@1157@01 $arg2@1158@01) $arg2@1158@01))
      (and
        (img@1161@01 $arg0@1156@01 $arg1@1157@01 $arg2@1158@01)
        (img@1163@01 $arg0@1156@01 $arg1@1157@01 $arg2@1158@01)
        (img@1165@01 $arg0@1156@01 $arg1@1157@01 $arg2@1158@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1156@01)
      ($SortWrappers.IntTo$Snap $arg1@1157@01))
    ($SortWrappers.IntTo$Snap $arg2@1158@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1156@01)
      ($SortWrappers.IntTo$Snap $arg1@1157@01))
    ($SortWrappers.IntTo$Snap $arg2@1158@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1161@01 $arg0 $arg1 $arg2)
        (img@1163@01 $arg0 $arg1 $arg2)
        (img@1165@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1160@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1162@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1164@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1160@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1162@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1164@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1160@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1162@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1164@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1160@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1162@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1164@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1160@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1162@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1164@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1160@01 $arg0 $arg1 $arg2) (inv@1162@01 $arg0 $arg1 $arg2) (inv@1164@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1715|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1160@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1162@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1164@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1161@01 $arg0 $arg1 $arg2)
        (img@1163@01 $arg0 $arg1 $arg2)
        (img@1165@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1160@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1162@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1164@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@1159@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1160@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1162@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1164@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1716|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@1166@01 Int)
(declare-const $arg1@1167@01 Int)
(declare-const $arg2@1168@01 Int)
(push) ; 24
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1169@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef98|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef99|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1166@01)
    ($SortWrappers.IntTo$Snap $arg1@1167@01))
  ($SortWrappers.IntTo$Snap $arg2@1168@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1166@01)
    ($SortWrappers.IntTo$Snap $arg1@1167@01))
  ($SortWrappers.IntTo$Snap $arg2@1168@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1166@01)
      ($SortWrappers.IntTo$Snap $arg1@1167@01))
    ($SortWrappers.IntTo$Snap $arg2@1168@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1170@01 (Int Int Int) Int)
(declare-fun img@1171@01 (Int Int Int) Bool)
(declare-fun inv@1172@01 (Int Int Int) Int)
(declare-fun img@1173@01 (Int Int Int) Bool)
(declare-fun inv@1174@01 (Int Int Int) Int)
(declare-fun img@1175@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef98|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef99|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1166@01 Int) ($arg1@1167@01 Int) ($arg2@1168@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1166@01)
          ($SortWrappers.IntTo$Snap $arg1@1167@01))
        ($SortWrappers.IntTo$Snap $arg2@1168@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1166@01)
        ($SortWrappers.IntTo$Snap $arg1@1167@01))
      ($SortWrappers.IntTo$Snap $arg2@1168@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1166@01)
        ($SortWrappers.IntTo$Snap $arg1@1167@01))
      ($SortWrappers.IntTo$Snap $arg2@1168@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1166@01)
      ($SortWrappers.IntTo$Snap $arg1@1167@01))
    ($SortWrappers.IntTo$Snap $arg2@1168@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1166@01)
      ($SortWrappers.IntTo$Snap $arg1@1167@01))
    ($SortWrappers.IntTo$Snap $arg2@1168@01))))
  :qid |e$Transfer-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1166@01 Int) ($arg1@1167@01 Int) ($arg2@1168@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1166@01)
          ($SortWrappers.IntTo$Snap $arg1@1167@01))
        ($SortWrappers.IntTo$Snap $arg2@1168@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1166@01)
            ($SortWrappers.IntTo$Snap $arg1@1167@01))
          ($SortWrappers.IntTo$Snap $arg2@1168@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1166@01)
            ($SortWrappers.IntTo$Snap $arg1@1167@01))
          ($SortWrappers.IntTo$Snap $arg2@1168@01))))))
  
  :qid |quant-u-1717|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1166@01 Int) ($arg11@1167@01 Int) ($arg21@1168@01 Int) ($arg02@1166@01 Int) ($arg12@1167@01 Int) ($arg22@1168@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1166@01)
                ($SortWrappers.IntTo$Snap $arg11@1167@01))
              ($SortWrappers.IntTo$Snap $arg21@1168@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1166@01)
              ($SortWrappers.IntTo$Snap $arg11@1167@01))
            ($SortWrappers.IntTo$Snap $arg21@1168@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1166@01)
              ($SortWrappers.IntTo$Snap $arg11@1167@01))
            ($SortWrappers.IntTo$Snap $arg21@1168@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1166@01)
              ($SortWrappers.IntTo$Snap $arg11@1167@01))
            ($SortWrappers.IntTo$Snap $arg21@1168@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1166@01)
                ($SortWrappers.IntTo$Snap $arg12@1167@01))
              ($SortWrappers.IntTo$Snap $arg22@1168@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1166@01)
              ($SortWrappers.IntTo$Snap $arg12@1167@01))
            ($SortWrappers.IntTo$Snap $arg22@1168@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1166@01)
              ($SortWrappers.IntTo$Snap $arg12@1167@01))
            ($SortWrappers.IntTo$Snap $arg22@1168@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1166@01)
              ($SortWrappers.IntTo$Snap $arg12@1167@01))
            ($SortWrappers.IntTo$Snap $arg22@1168@01)))))
      (and
        (and (= $arg01@1166@01 $arg02@1166@01) (= $arg11@1167@01 $arg12@1167@01))
        (= $arg21@1168@01 $arg22@1168@01)))
    (and
      (and (= $arg01@1166@01 $arg02@1166@01) (= $arg11@1167@01 $arg12@1167@01))
      (= $arg21@1168@01 $arg22@1168@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1166@01 Int) ($arg1@1167@01 Int) ($arg2@1168@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1166@01)
            ($SortWrappers.IntTo$Snap $arg1@1167@01))
          ($SortWrappers.IntTo$Snap $arg2@1168@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1166@01)
            ($SortWrappers.IntTo$Snap $arg1@1167@01))
          ($SortWrappers.IntTo$Snap $arg2@1168@01)))))
    (and
      (and
        (= (inv@1170@01 $arg0@1166@01 $arg1@1167@01 $arg2@1168@01) $arg0@1166@01)
        (= (inv@1172@01 $arg0@1166@01 $arg1@1167@01 $arg2@1168@01) $arg1@1167@01)
        (= (inv@1174@01 $arg0@1166@01 $arg1@1167@01 $arg2@1168@01) $arg2@1168@01))
      (and
        (img@1171@01 $arg0@1166@01 $arg1@1167@01 $arg2@1168@01)
        (img@1173@01 $arg0@1166@01 $arg1@1167@01 $arg2@1168@01)
        (img@1175@01 $arg0@1166@01 $arg1@1167@01 $arg2@1168@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1166@01)
      ($SortWrappers.IntTo$Snap $arg1@1167@01))
    ($SortWrappers.IntTo$Snap $arg2@1168@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1166@01)
      ($SortWrappers.IntTo$Snap $arg1@1167@01))
    ($SortWrappers.IntTo$Snap $arg2@1168@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1171@01 $arg0 $arg1 $arg2)
        (img@1173@01 $arg0 $arg1 $arg2)
        (img@1175@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1170@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1172@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1174@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1170@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1172@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1174@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1170@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1172@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1174@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1170@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1172@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1174@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1170@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1172@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1174@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1170@01 $arg0 $arg1 $arg2) (inv@1172@01 $arg0 $arg1 $arg2) (inv@1174@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1718|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1170@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1172@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1174@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1171@01 $arg0 $arg1 $arg2)
        (img@1173@01 $arg0 $arg1 $arg2)
        (img@1175@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1170@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1172@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1174@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@1169@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1170@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1172@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1174@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1719|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@1176@01 Int)
(declare-const $arg1@1177@01 Int)
(declare-const $arg2@1178@01 Int)
(push) ; 24
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1179@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef100|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef101|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1176@01)
    ($SortWrappers.IntTo$Snap $arg1@1177@01))
  ($SortWrappers.IntTo$Snap $arg2@1178@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1176@01)
    ($SortWrappers.IntTo$Snap $arg1@1177@01))
  ($SortWrappers.IntTo$Snap $arg2@1178@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1176@01)
      ($SortWrappers.IntTo$Snap $arg1@1177@01))
    ($SortWrappers.IntTo$Snap $arg2@1178@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1180@01 (Int Int Int) Int)
(declare-fun img@1181@01 (Int Int Int) Bool)
(declare-fun inv@1182@01 (Int Int Int) Int)
(declare-fun img@1183@01 (Int Int Int) Bool)
(declare-fun inv@1184@01 (Int Int Int) Int)
(declare-fun img@1185@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef100|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef101|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1176@01 Int) ($arg1@1177@01 Int) ($arg2@1178@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1176@01)
          ($SortWrappers.IntTo$Snap $arg1@1177@01))
        ($SortWrappers.IntTo$Snap $arg2@1178@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1176@01)
        ($SortWrappers.IntTo$Snap $arg1@1177@01))
      ($SortWrappers.IntTo$Snap $arg2@1178@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1176@01)
        ($SortWrappers.IntTo$Snap $arg1@1177@01))
      ($SortWrappers.IntTo$Snap $arg2@1178@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1176@01)
      ($SortWrappers.IntTo$Snap $arg1@1177@01))
    ($SortWrappers.IntTo$Snap $arg2@1178@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1176@01)
      ($SortWrappers.IntTo$Snap $arg1@1177@01))
    ($SortWrappers.IntTo$Snap $arg2@1178@01))))
  :qid |e$Approval-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1176@01 Int) ($arg1@1177@01 Int) ($arg2@1178@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1176@01)
          ($SortWrappers.IntTo$Snap $arg1@1177@01))
        ($SortWrappers.IntTo$Snap $arg2@1178@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1176@01)
            ($SortWrappers.IntTo$Snap $arg1@1177@01))
          ($SortWrappers.IntTo$Snap $arg2@1178@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1176@01)
            ($SortWrappers.IntTo$Snap $arg1@1177@01))
          ($SortWrappers.IntTo$Snap $arg2@1178@01))))))
  
  :qid |quant-u-1720|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1176@01 Int) ($arg11@1177@01 Int) ($arg21@1178@01 Int) ($arg02@1176@01 Int) ($arg12@1177@01 Int) ($arg22@1178@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1176@01)
                ($SortWrappers.IntTo$Snap $arg11@1177@01))
              ($SortWrappers.IntTo$Snap $arg21@1178@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1176@01)
              ($SortWrappers.IntTo$Snap $arg11@1177@01))
            ($SortWrappers.IntTo$Snap $arg21@1178@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1176@01)
              ($SortWrappers.IntTo$Snap $arg11@1177@01))
            ($SortWrappers.IntTo$Snap $arg21@1178@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1176@01)
              ($SortWrappers.IntTo$Snap $arg11@1177@01))
            ($SortWrappers.IntTo$Snap $arg21@1178@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1176@01)
                ($SortWrappers.IntTo$Snap $arg12@1177@01))
              ($SortWrappers.IntTo$Snap $arg22@1178@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1176@01)
              ($SortWrappers.IntTo$Snap $arg12@1177@01))
            ($SortWrappers.IntTo$Snap $arg22@1178@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1176@01)
              ($SortWrappers.IntTo$Snap $arg12@1177@01))
            ($SortWrappers.IntTo$Snap $arg22@1178@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1176@01)
              ($SortWrappers.IntTo$Snap $arg12@1177@01))
            ($SortWrappers.IntTo$Snap $arg22@1178@01)))))
      (and
        (and (= $arg01@1176@01 $arg02@1176@01) (= $arg11@1177@01 $arg12@1177@01))
        (= $arg21@1178@01 $arg22@1178@01)))
    (and
      (and (= $arg01@1176@01 $arg02@1176@01) (= $arg11@1177@01 $arg12@1177@01))
      (= $arg21@1178@01 $arg22@1178@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1176@01 Int) ($arg1@1177@01 Int) ($arg2@1178@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1176@01)
            ($SortWrappers.IntTo$Snap $arg1@1177@01))
          ($SortWrappers.IntTo$Snap $arg2@1178@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1176@01)
            ($SortWrappers.IntTo$Snap $arg1@1177@01))
          ($SortWrappers.IntTo$Snap $arg2@1178@01)))))
    (and
      (and
        (= (inv@1180@01 $arg0@1176@01 $arg1@1177@01 $arg2@1178@01) $arg0@1176@01)
        (= (inv@1182@01 $arg0@1176@01 $arg1@1177@01 $arg2@1178@01) $arg1@1177@01)
        (= (inv@1184@01 $arg0@1176@01 $arg1@1177@01 $arg2@1178@01) $arg2@1178@01))
      (and
        (img@1181@01 $arg0@1176@01 $arg1@1177@01 $arg2@1178@01)
        (img@1183@01 $arg0@1176@01 $arg1@1177@01 $arg2@1178@01)
        (img@1185@01 $arg0@1176@01 $arg1@1177@01 $arg2@1178@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1176@01)
      ($SortWrappers.IntTo$Snap $arg1@1177@01))
    ($SortWrappers.IntTo$Snap $arg2@1178@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1176@01)
      ($SortWrappers.IntTo$Snap $arg1@1177@01))
    ($SortWrappers.IntTo$Snap $arg2@1178@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1181@01 $arg0 $arg1 $arg2)
        (img@1183@01 $arg0 $arg1 $arg2)
        (img@1185@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1180@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1182@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1184@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1180@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1182@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1184@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1180@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1182@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1184@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1180@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1182@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1184@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1180@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1182@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1184@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1180@01 $arg0 $arg1 $arg2) (inv@1182@01 $arg0 $arg1 $arg2) (inv@1184@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1721|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1180@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1182@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1184@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1181@01 $arg0 $arg1 $arg2)
        (img@1183@01 $arg0 $arg1 $arg2)
        (img@1185@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1180@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1182@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1184@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@1179@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1180@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1182@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1184@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1722|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$6
(push) ; 24
(set-option :timeout 10)
(assert (not (not l$send_fail$2@874@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not l$send_fail$2@874@01))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 299 | l$send_fail$2@874@01 | live]
; [else-branch: 299 | !(l$send_fail$2@874@01) | live]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 299 | l$send_fail$2@874@01]
(assert l$send_fail$2@874@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@1186@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 300 | True | live]
; [else-branch: 300 | False | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 300 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1187@01 $Snap)
(assert (= $t@1187@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1188@01 $Struct)
(assert (=
  self@1188@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 25
; [then-branch: 301 | False | dead]
; [else-branch: 301 | True | live]
(set-option :timeout 0)
(push) ; 25
; [else-branch: 301 | True]
(pop) ; 25
(pop) ; 24
(push) ; 24
; [else-branch: 299 | !(l$send_fail$2@874@01)]
(assert (not l$send_fail$2@874@01))
(pop) ; 24
; [eval] !l$send_fail$2
(push) ; 24
(set-option :timeout 10)
(assert (not l$send_fail$2@874@01))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (not l$send_fail$2@874@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 302 | !(l$send_fail$2@874@01) | live]
; [else-branch: 302 | l$send_fail$2@874@01 | live]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 302 | !(l$send_fail$2@874@01)]
(assert (not l$send_fail$2@874@01))
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; i2$$pre_self := self
; [exec]
; i2$$pre_$contracts := $contracts
; [exec]
; $contracts := l$havoc$7
; [exec]
; $old_$contracts := $contracts
; [exec]
; self := l$havoc$8
; [exec]
; $contracts := l$havoc$9
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@1189@01 $Snap)
(assert (= $t@1189@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$havoc$8@879@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@1190@01 $Snap)
(assert (= $t@1190@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$havoc$8@879@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1191@01 $Snap)
(assert (= $t@1191@01 ($Snap.combine ($Snap.first $t@1191@01) ($Snap.second $t@1191@01))))
(assert (= ($Snap.first $t@1191@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 2))))
(assert (= ($Snap.second $t@1191@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1192@01 $Snap)
(assert (= $t@1192@01 ($Snap.combine ($Snap.first $t@1192@01) ($Snap.second $t@1192@01))))
(assert (= ($Snap.first $t@1192@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 3))))
(assert (= ($Snap.second $t@1192@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1193@01 $Snap)
(assert (= $t@1193@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@1194@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 26
; [then-branch: 303 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 4)), $q2@1194@01)) | live]
; [else-branch: 303 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 4)), $q2@1194@01) | live]
(push) ; 27
; [then-branch: 303 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 4)), $q2@1194@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1194@01))))
(pop) ; 27
(push) ; 27
; [else-branch: 303 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 4)), $q2@1194@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1194@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 27
(pop) ; 26
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1194@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1194@01)))))
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1194@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1194@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1194@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1194@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1755@11@1755@345-aux|)))
(assert (forall (($q2@1194@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1194@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1194@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1194@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1755@11@1755@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@1195@01 $Snap)
(assert (= $t@1195@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@1196@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1196@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1196@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1196@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1756@11@1756@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@1197@01 $Snap)
(assert (= $t@1197@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@1198@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@1199@01 Int)
(push) ; 26
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 27
; [then-branch: 304 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@879@01, 5)), $q3@1198@01), $q4@1199@01)) | live]
; [else-branch: 304 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@879@01, 5)), $q3@1198@01), $q4@1199@01) | live]
(push) ; 28
; [then-branch: 304 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@879@01, 5)), $q3@1198@01), $q4@1199@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01))))
(pop) ; 28
(push) ; 28
; [else-branch: 304 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@879@01, 5)), $q3@1198@01), $q4@1199@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01)))))
(pop) ; 26
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@1199@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1757@131@1757@597-aux|)))
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1198@01 Int)) (!
  (forall (($q4@1199@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1757@131@1757@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1757@11@1757@598-aux|)))
(assert (forall (($q3@1198@01 Int)) (!
  (forall (($q4@1199@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01) $q4@1199@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1757@131@1757@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1198@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1757@11@1757@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@1200@01 $Snap)
(assert (= $t@1200@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@1201@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@1202@01 Int)
(push) ; 26
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 26
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1201@01 Int)) (!
  (forall (($q4@1202@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1201@01) $q4@1202@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1201@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1201@01) $q4@1202@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1758@131@1758@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1201@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1758@11@1758@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1203@01 $Snap)
(assert (= $t@1203@01 ($Snap.combine ($Snap.first $t@1203@01) ($Snap.second $t@1203@01))))
(assert (= ($Snap.first $t@1203@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 6))))
(assert (= ($Snap.second $t@1203@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1204@01 $Snap)
(assert (= $t@1204@01 ($Snap.combine ($Snap.first $t@1204@01) ($Snap.second $t@1204@01))))
(assert (= ($Snap.first $t@1204@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 7))))
(assert (= ($Snap.second $t@1204@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1205@01 $Snap)
(assert (= $t@1205@01 ($Snap.combine ($Snap.first $t@1205@01) ($Snap.second $t@1205@01))))
(assert (= ($Snap.first $t@1205@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 8))))
(assert (= ($Snap.second $t@1205@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@1206@01 $Snap)
(assert (= $t@1206@01 ($Snap.combine ($Snap.first $t@1206@01) ($Snap.second $t@1206@01))))
(assert (= ($Snap.first $t@1206@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 9))))
(assert (= ($Snap.second $t@1206@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1207@01 $Snap)
(assert (= $t@1207@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@1208@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 26
; [then-branch: 305 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 11)), $q5@1208@01)) | live]
; [else-branch: 305 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 11)), $q5@1208@01) | live]
(push) ; 27
; [then-branch: 305 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 11)), $q5@1208@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1208@01))))
(pop) ; 27
(push) ; 27
; [else-branch: 305 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 11)), $q5@1208@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1208@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 27
(pop) ; 26
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1208@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1208@01)))))
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1208@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1208@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1208@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1208@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1763@11@1763@348-aux|)))
(assert (forall (($q5@1208@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1208@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1208@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1208@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1763@11@1763@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@1209@01 $Snap)
(assert (= $t@1209@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@1210@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1210@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1210@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1210@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1764@11@1764@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1211@01 $Snap)
(assert (= $t@1211@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@1212@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 26
; [then-branch: 306 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 12)), $q6@1212@01)) | live]
; [else-branch: 306 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 12)), $q6@1212@01) | live]
(push) ; 27
; [then-branch: 306 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 12)), $q6@1212@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1212@01))))
(pop) ; 27
(push) ; 27
; [else-branch: 306 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 12)), $q6@1212@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1212@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 27
(pop) ; 26
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1212@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1212@01)))))
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1212@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1212@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1212@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1212@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1765@11@1765@348-aux|)))
(assert (forall (($q6@1212@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1212@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1212@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1212@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1765@11@1765@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@1213@01 $Snap)
(assert (= $t@1213@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@1214@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1214@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1214@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1214@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1766@11@1766@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@1215@01 $Snap)
(assert (= $t@1215@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@1216@01 $Snap)
(assert (= $t@1216@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@1217@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($old_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($old_self, 11)
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($a@1217@01 Int)) (!
  (>=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $a@1217@01)
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1033@01 11)) $a@1217@01))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $a@1217@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1769@11@1769@262|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (not l$no_reentrant_call$1@881@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not l$no_reentrant_call$1@881@01))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 307 | l$no_reentrant_call$1@881@01 | live]
; [else-branch: 307 | !(l$no_reentrant_call$1@881@01) | live]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 307 | l$no_reentrant_call$1@881@01]
(assert l$no_reentrant_call$1@881@01)
; [exec]
; self := $old_self
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$10
; [exec]
; $old_$contracts := i2$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$11
; [exec]
; $old_$contracts := i2$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$raw_ret$1
(push) ; 26
(set-option :timeout 10)
(assert (not l$raw_ret$1@875@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@875@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 308 | !(l$raw_ret$1@875@01) | live]
; [else-branch: 308 | l$raw_ret$1@875@01 | live]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 308 | !(l$raw_ret$1@875@01)]
(assert (not l$raw_ret$1@875@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 27
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 309 | True | live]
; [else-branch: 309 | False | dead]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 309 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1218@01 $Snap)
(assert (= $t@1218@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1219@01 $Struct)
(assert (=
  self@1219@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 27
; [then-branch: 310 | False | dead]
; [else-branch: 310 | True | live]
(set-option :timeout 0)
(push) ; 27
; [else-branch: 310 | True]
(pop) ; 27
(pop) ; 26
(push) ; 26
; [else-branch: 308 | l$raw_ret$1@875@01]
(assert l$raw_ret$1@875@01)
(pop) ; 26
; [eval] !!l$raw_ret$1
; [eval] !l$raw_ret$1
(push) ; 26
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@875@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not l$raw_ret$1@875@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 311 | l$raw_ret$1@875@01 | live]
; [else-branch: 311 | !(l$raw_ret$1@875@01) | live]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 311 | l$raw_ret$1@875@01]
(assert l$raw_ret$1@875@01)
; [exec]
; inhale acc(e$RemoveLiquidity(($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$eth_amount),
;   $unwrap(l$token_amount)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$eth_amount)
; [eval] $unwrap(l$token_amount)
(declare-const $t@1220@01 $Snap)
(declare-const sm@1221@01 $PSF<e$RemoveLiquidity>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$RemoveLiquidity (as sm@1221@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01))))
  $t@1220@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      (= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$eth_amount@1018@01))
      (=
        ($unwrap<Int> l$token_amount@1021@01)
        ($unwrap<Int> l$token_amount@1021@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(e$Transfer(($struct_get($struct_loc(msg, 0)): Int), 0, $unwrap(l$amount)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$amount)
(declare-const $t@1222@01 $Snap)
(declare-const sm@1223@01 $PSF<e$Transfer>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$Transfer (as sm@1223@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      ($SortWrappers.IntTo$Snap 0))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01))))
  $t@1222@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      (= 0 0)
      (= ($unwrap<Int> l$amount@838@01) ($unwrap<Int> l$amount@838@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap 0))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap 0))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01)))))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; $res := s$struct$EtherTokenPair$init($unwrap(l$eth_amount), $unwrap(l$token_amount))
; [eval] s$struct$EtherTokenPair$init($unwrap(l$eth_amount), $unwrap(l$token_amount))
; [eval] $unwrap(l$eth_amount)
; [eval] $unwrap(l$token_amount)
(declare-const $res@1224@01 $Struct)
(assert (=
  $res@1224@01
  (s$struct$EtherTokenPair$init<$Struct> ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$token_amount@1021@01))))
; [exec]
; label return
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not $out_of_gas@884@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not $out_of_gas@884@01))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 312 | $out_of_gas@884@01 | live]
; [else-branch: 312 | !($out_of_gas@884@01) | live]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 312 | $out_of_gas@884@01]
(assert $out_of_gas@884@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 313 | True | live]
; [else-branch: 313 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 313 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1225@01 $Snap)
(assert (= $t@1225@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1226@01 $Struct)
(assert (=
  self@1226@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 28
; [then-branch: 314 | False | dead]
; [else-branch: 314 | True | live]
(set-option :timeout 0)
(push) ; 28
; [else-branch: 314 | True]
(pop) ; 28
(pop) ; 27
(push) ; 27
; [else-branch: 312 | !($out_of_gas@884@01)]
(assert (not $out_of_gas@884@01))
(pop) ; 27
; [eval] !$out_of_gas
(push) ; 27
(set-option :timeout 10)
(assert (not $out_of_gas@884@01))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not $out_of_gas@884@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 315 | !($out_of_gas@884@01) | live]
; [else-branch: 315 | $out_of_gas@884@01 | live]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 315 | !($out_of_gas@884@01)]
(assert (not $out_of_gas@884@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 316 | False | dead]
; [else-branch: 316 | True | live]
(push) ; 28
; [else-branch: 316 | True]
(pop) ; 28
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 317 | True | live]
; [else-branch: 317 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 317 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1227@01 $Snap)
(assert (= $t@1227@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1228@01 $Struct)
(assert (=
  self@1228@01
  ($struct_set<$Struct> self@1033@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1033@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 28
(pop) ; 27
(set-option :timeout 0)
(push) ; 27
; [else-branch: 315 | $out_of_gas@884@01]
(assert $out_of_gas@884@01)
(pop) ; 27
(pop) ; 26
(push) ; 26
; [else-branch: 311 | !(l$raw_ret$1@875@01)]
(assert (not l$raw_ret$1@875@01))
(pop) ; 26
(pop) ; 25
(push) ; 25
; [else-branch: 307 | !(l$no_reentrant_call$1@881@01)]
(assert (not l$no_reentrant_call$1@881@01))
(pop) ; 25
; [eval] !l$no_reentrant_call$1
(push) ; 25
(set-option :timeout 10)
(assert (not l$no_reentrant_call$1@881@01))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (not l$no_reentrant_call$1@881@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 318 | !(l$no_reentrant_call$1@881@01) | live]
; [else-branch: 318 | l$no_reentrant_call$1@881@01 | live]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 318 | !(l$no_reentrant_call$1@881@01)]
(assert (not l$no_reentrant_call$1@881@01))
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$10
; [exec]
; $old_$contracts := i2$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$11
; [exec]
; $old_$contracts := i2$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$raw_ret$1
(push) ; 26
(set-option :timeout 10)
(assert (not l$raw_ret$1@875@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@875@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 319 | !(l$raw_ret$1@875@01) | live]
; [else-branch: 319 | l$raw_ret$1@875@01 | live]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 319 | !(l$raw_ret$1@875@01)]
(assert (not l$raw_ret$1@875@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 27
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 320 | True | live]
; [else-branch: 320 | False | dead]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 320 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1229@01 $Snap)
(assert (= $t@1229@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1230@01 $Struct)
(assert (=
  self@1230@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 27
; [then-branch: 321 | False | dead]
; [else-branch: 321 | True | live]
(set-option :timeout 0)
(push) ; 27
; [else-branch: 321 | True]
(pop) ; 27
(pop) ; 26
(push) ; 26
; [else-branch: 319 | l$raw_ret$1@875@01]
(assert l$raw_ret$1@875@01)
(pop) ; 26
; [eval] !!l$raw_ret$1
; [eval] !l$raw_ret$1
(push) ; 26
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@875@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not l$raw_ret$1@875@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 322 | l$raw_ret$1@875@01 | live]
; [else-branch: 322 | !(l$raw_ret$1@875@01) | live]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 322 | l$raw_ret$1@875@01]
(assert l$raw_ret$1@875@01)
; [exec]
; inhale acc(e$RemoveLiquidity(($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$eth_amount),
;   $unwrap(l$token_amount)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$eth_amount)
; [eval] $unwrap(l$token_amount)
(declare-const $t@1231@01 $Snap)
(declare-const sm@1232@01 $PSF<e$RemoveLiquidity>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$RemoveLiquidity (as sm@1232@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01))))
  $t@1231@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      (= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$eth_amount@1018@01))
      (=
        ($unwrap<Int> l$token_amount@1021@01)
        ($unwrap<Int> l$token_amount@1021@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(e$Transfer(($struct_get($struct_loc(msg, 0)): Int), 0, $unwrap(l$amount)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$amount)
(declare-const $t@1233@01 $Snap)
(declare-const sm@1234@01 $PSF<e$Transfer>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$Transfer (as sm@1234@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      ($SortWrappers.IntTo$Snap 0))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01))))
  $t@1233@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      (= 0 0)
      (= ($unwrap<Int> l$amount@838@01) ($unwrap<Int> l$amount@838@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap 0))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap 0))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01)))))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; $res := s$struct$EtherTokenPair$init($unwrap(l$eth_amount), $unwrap(l$token_amount))
; [eval] s$struct$EtherTokenPair$init($unwrap(l$eth_amount), $unwrap(l$token_amount))
; [eval] $unwrap(l$eth_amount)
; [eval] $unwrap(l$token_amount)
(declare-const $res@1235@01 $Struct)
(assert (=
  $res@1235@01
  (s$struct$EtherTokenPair$init<$Struct> ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$token_amount@1021@01))))
; [exec]
; label return
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not $out_of_gas@884@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not $out_of_gas@884@01))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 323 | $out_of_gas@884@01 | live]
; [else-branch: 323 | !($out_of_gas@884@01) | live]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 323 | $out_of_gas@884@01]
(assert $out_of_gas@884@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 324 | True | live]
; [else-branch: 324 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 324 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1236@01 $Snap)
(assert (= $t@1236@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1237@01 $Struct)
(assert (=
  self@1237@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 28
; [then-branch: 325 | False | dead]
; [else-branch: 325 | True | live]
(set-option :timeout 0)
(push) ; 28
; [else-branch: 325 | True]
(pop) ; 28
(pop) ; 27
(push) ; 27
; [else-branch: 323 | !($out_of_gas@884@01)]
(assert (not $out_of_gas@884@01))
(pop) ; 27
; [eval] !$out_of_gas
(push) ; 27
(set-option :timeout 10)
(assert (not $out_of_gas@884@01))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not $out_of_gas@884@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 326 | !($out_of_gas@884@01) | live]
; [else-branch: 326 | $out_of_gas@884@01 | live]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 326 | !($out_of_gas@884@01)]
(assert (not $out_of_gas@884@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 327 | False | dead]
; [else-branch: 327 | True | live]
(push) ; 28
; [else-branch: 327 | True]
(pop) ; 28
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 328 | True | live]
; [else-branch: 328 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 328 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1238@01 $Snap)
(assert (= $t@1238@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1239@01 $Struct)
(assert (=
  self@1239@01
  ($struct_set<$Struct> l$havoc$8@879@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 28
(pop) ; 27
(set-option :timeout 0)
(push) ; 27
; [else-branch: 326 | $out_of_gas@884@01]
(assert $out_of_gas@884@01)
(pop) ; 27
(pop) ; 26
(push) ; 26
; [else-branch: 322 | !(l$raw_ret$1@875@01)]
(assert (not l$raw_ret$1@875@01))
(pop) ; 26
(pop) ; 25
(push) ; 25
; [else-branch: 318 | l$no_reentrant_call$1@881@01]
(assert l$no_reentrant_call$1@881@01)
(pop) ; 25
(pop) ; 24
(push) ; 24
; [else-branch: 302 | l$send_fail$2@874@01]
(assert l$send_fail$2@874@01)
(pop) ; 24
(pop) ; 23
(push) ; 23
; [else-branch: 298 | !(l$no_reentrant_call@870@01)]
(assert (not l$no_reentrant_call@870@01))
(pop) ; 23
; [eval] !l$no_reentrant_call
(push) ; 23
(set-option :timeout 10)
(assert (not l$no_reentrant_call@870@01))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not l$no_reentrant_call@870@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 329 | !(l$no_reentrant_call@870@01) | live]
; [else-branch: 329 | l$no_reentrant_call@870@01 | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 329 | !(l$no_reentrant_call@870@01)]
(assert (not l$no_reentrant_call@870@01))
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$4
; [exec]
; $old_$contracts := i1$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$5
; [exec]
; $old_$contracts := i1$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1240@01 Int)
(declare-const $arg1@1241@01 Int)
(declare-const $arg2@1242@01 Int)
(push) ; 24
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1243@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef102|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef103|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1240@01)
    ($SortWrappers.IntTo$Snap $arg1@1241@01))
  ($SortWrappers.IntTo$Snap $arg2@1242@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1240@01)
    ($SortWrappers.IntTo$Snap $arg1@1241@01))
  ($SortWrappers.IntTo$Snap $arg2@1242@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1240@01)
      ($SortWrappers.IntTo$Snap $arg1@1241@01))
    ($SortWrappers.IntTo$Snap $arg2@1242@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1244@01 (Int Int Int) Int)
(declare-fun img@1245@01 (Int Int Int) Bool)
(declare-fun inv@1246@01 (Int Int Int) Int)
(declare-fun img@1247@01 (Int Int Int) Bool)
(declare-fun inv@1248@01 (Int Int Int) Int)
(declare-fun img@1249@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef102|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef103|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1240@01 Int) ($arg1@1241@01 Int) ($arg2@1242@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1240@01)
          ($SortWrappers.IntTo$Snap $arg1@1241@01))
        ($SortWrappers.IntTo$Snap $arg2@1242@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1240@01)
        ($SortWrappers.IntTo$Snap $arg1@1241@01))
      ($SortWrappers.IntTo$Snap $arg2@1242@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1240@01)
        ($SortWrappers.IntTo$Snap $arg1@1241@01))
      ($SortWrappers.IntTo$Snap $arg2@1242@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1240@01)
      ($SortWrappers.IntTo$Snap $arg1@1241@01))
    ($SortWrappers.IntTo$Snap $arg2@1242@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1240@01)
      ($SortWrappers.IntTo$Snap $arg1@1241@01))
    ($SortWrappers.IntTo$Snap $arg2@1242@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1240@01 Int) ($arg1@1241@01 Int) ($arg2@1242@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1240@01)
          ($SortWrappers.IntTo$Snap $arg1@1241@01))
        ($SortWrappers.IntTo$Snap $arg2@1242@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1240@01)
            ($SortWrappers.IntTo$Snap $arg1@1241@01))
          ($SortWrappers.IntTo$Snap $arg2@1242@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1240@01)
            ($SortWrappers.IntTo$Snap $arg1@1241@01))
          ($SortWrappers.IntTo$Snap $arg2@1242@01))))))
  
  :qid |quant-u-1723|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1240@01 Int) ($arg11@1241@01 Int) ($arg21@1242@01 Int) ($arg02@1240@01 Int) ($arg12@1241@01 Int) ($arg22@1242@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1240@01)
                ($SortWrappers.IntTo$Snap $arg11@1241@01))
              ($SortWrappers.IntTo$Snap $arg21@1242@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1240@01)
              ($SortWrappers.IntTo$Snap $arg11@1241@01))
            ($SortWrappers.IntTo$Snap $arg21@1242@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1240@01)
              ($SortWrappers.IntTo$Snap $arg11@1241@01))
            ($SortWrappers.IntTo$Snap $arg21@1242@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1240@01)
              ($SortWrappers.IntTo$Snap $arg11@1241@01))
            ($SortWrappers.IntTo$Snap $arg21@1242@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1240@01)
                ($SortWrappers.IntTo$Snap $arg12@1241@01))
              ($SortWrappers.IntTo$Snap $arg22@1242@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1240@01)
              ($SortWrappers.IntTo$Snap $arg12@1241@01))
            ($SortWrappers.IntTo$Snap $arg22@1242@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1240@01)
              ($SortWrappers.IntTo$Snap $arg12@1241@01))
            ($SortWrappers.IntTo$Snap $arg22@1242@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1240@01)
              ($SortWrappers.IntTo$Snap $arg12@1241@01))
            ($SortWrappers.IntTo$Snap $arg22@1242@01)))))
      (and
        (and (= $arg01@1240@01 $arg02@1240@01) (= $arg11@1241@01 $arg12@1241@01))
        (= $arg21@1242@01 $arg22@1242@01)))
    (and
      (and (= $arg01@1240@01 $arg02@1240@01) (= $arg11@1241@01 $arg12@1241@01))
      (= $arg21@1242@01 $arg22@1242@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1240@01 Int) ($arg1@1241@01 Int) ($arg2@1242@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1240@01)
            ($SortWrappers.IntTo$Snap $arg1@1241@01))
          ($SortWrappers.IntTo$Snap $arg2@1242@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1240@01)
            ($SortWrappers.IntTo$Snap $arg1@1241@01))
          ($SortWrappers.IntTo$Snap $arg2@1242@01)))))
    (and
      (and
        (= (inv@1244@01 $arg0@1240@01 $arg1@1241@01 $arg2@1242@01) $arg0@1240@01)
        (= (inv@1246@01 $arg0@1240@01 $arg1@1241@01 $arg2@1242@01) $arg1@1241@01)
        (= (inv@1248@01 $arg0@1240@01 $arg1@1241@01 $arg2@1242@01) $arg2@1242@01))
      (and
        (img@1245@01 $arg0@1240@01 $arg1@1241@01 $arg2@1242@01)
        (img@1247@01 $arg0@1240@01 $arg1@1241@01 $arg2@1242@01)
        (img@1249@01 $arg0@1240@01 $arg1@1241@01 $arg2@1242@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1240@01)
      ($SortWrappers.IntTo$Snap $arg1@1241@01))
    ($SortWrappers.IntTo$Snap $arg2@1242@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1240@01)
      ($SortWrappers.IntTo$Snap $arg1@1241@01))
    ($SortWrappers.IntTo$Snap $arg2@1242@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1245@01 $arg0 $arg1 $arg2)
        (img@1247@01 $arg0 $arg1 $arg2)
        (img@1249@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1244@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1246@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1248@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1244@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1246@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1248@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1244@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1246@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1248@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1244@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1246@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1248@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1244@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1246@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1248@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@942@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1244@01 $arg0 $arg1 $arg2) (inv@1246@01 $arg0 $arg1 $arg2) (inv@1248@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1724|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1244@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1246@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1248@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1245@01 $arg0 $arg1 $arg2)
        (img@1247@01 $arg0 $arg1 $arg2)
        (img@1249@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1244@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1246@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1248@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@1243@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1244@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1246@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1248@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1725|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1250@01 Int)
(declare-const $arg1@1251@01 Int)
(declare-const $arg2@1252@01 Int)
(push) ; 24
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1253@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef104|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef105|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1250@01)
    ($SortWrappers.IntTo$Snap $arg1@1251@01))
  ($SortWrappers.IntTo$Snap $arg2@1252@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1250@01)
    ($SortWrappers.IntTo$Snap $arg1@1251@01))
  ($SortWrappers.IntTo$Snap $arg2@1252@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1250@01)
      ($SortWrappers.IntTo$Snap $arg1@1251@01))
    ($SortWrappers.IntTo$Snap $arg2@1252@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1254@01 (Int Int Int) Int)
(declare-fun img@1255@01 (Int Int Int) Bool)
(declare-fun inv@1256@01 (Int Int Int) Int)
(declare-fun img@1257@01 (Int Int Int) Bool)
(declare-fun inv@1258@01 (Int Int Int) Int)
(declare-fun img@1259@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef104|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef105|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1250@01 Int) ($arg1@1251@01 Int) ($arg2@1252@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1250@01)
          ($SortWrappers.IntTo$Snap $arg1@1251@01))
        ($SortWrappers.IntTo$Snap $arg2@1252@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1250@01)
        ($SortWrappers.IntTo$Snap $arg1@1251@01))
      ($SortWrappers.IntTo$Snap $arg2@1252@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1250@01)
        ($SortWrappers.IntTo$Snap $arg1@1251@01))
      ($SortWrappers.IntTo$Snap $arg2@1252@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1250@01)
      ($SortWrappers.IntTo$Snap $arg1@1251@01))
    ($SortWrappers.IntTo$Snap $arg2@1252@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1250@01)
      ($SortWrappers.IntTo$Snap $arg1@1251@01))
    ($SortWrappers.IntTo$Snap $arg2@1252@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1250@01 Int) ($arg1@1251@01 Int) ($arg2@1252@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1250@01)
          ($SortWrappers.IntTo$Snap $arg1@1251@01))
        ($SortWrappers.IntTo$Snap $arg2@1252@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1250@01)
            ($SortWrappers.IntTo$Snap $arg1@1251@01))
          ($SortWrappers.IntTo$Snap $arg2@1252@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1250@01)
            ($SortWrappers.IntTo$Snap $arg1@1251@01))
          ($SortWrappers.IntTo$Snap $arg2@1252@01))))))
  
  :qid |quant-u-1726|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1250@01 Int) ($arg11@1251@01 Int) ($arg21@1252@01 Int) ($arg02@1250@01 Int) ($arg12@1251@01 Int) ($arg22@1252@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1250@01)
                ($SortWrappers.IntTo$Snap $arg11@1251@01))
              ($SortWrappers.IntTo$Snap $arg21@1252@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1250@01)
              ($SortWrappers.IntTo$Snap $arg11@1251@01))
            ($SortWrappers.IntTo$Snap $arg21@1252@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1250@01)
              ($SortWrappers.IntTo$Snap $arg11@1251@01))
            ($SortWrappers.IntTo$Snap $arg21@1252@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1250@01)
              ($SortWrappers.IntTo$Snap $arg11@1251@01))
            ($SortWrappers.IntTo$Snap $arg21@1252@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1250@01)
                ($SortWrappers.IntTo$Snap $arg12@1251@01))
              ($SortWrappers.IntTo$Snap $arg22@1252@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1250@01)
              ($SortWrappers.IntTo$Snap $arg12@1251@01))
            ($SortWrappers.IntTo$Snap $arg22@1252@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1250@01)
              ($SortWrappers.IntTo$Snap $arg12@1251@01))
            ($SortWrappers.IntTo$Snap $arg22@1252@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1250@01)
              ($SortWrappers.IntTo$Snap $arg12@1251@01))
            ($SortWrappers.IntTo$Snap $arg22@1252@01)))))
      (and
        (and (= $arg01@1250@01 $arg02@1250@01) (= $arg11@1251@01 $arg12@1251@01))
        (= $arg21@1252@01 $arg22@1252@01)))
    (and
      (and (= $arg01@1250@01 $arg02@1250@01) (= $arg11@1251@01 $arg12@1251@01))
      (= $arg21@1252@01 $arg22@1252@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1250@01 Int) ($arg1@1251@01 Int) ($arg2@1252@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1250@01)
            ($SortWrappers.IntTo$Snap $arg1@1251@01))
          ($SortWrappers.IntTo$Snap $arg2@1252@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1250@01)
            ($SortWrappers.IntTo$Snap $arg1@1251@01))
          ($SortWrappers.IntTo$Snap $arg2@1252@01)))))
    (and
      (and
        (= (inv@1254@01 $arg0@1250@01 $arg1@1251@01 $arg2@1252@01) $arg0@1250@01)
        (= (inv@1256@01 $arg0@1250@01 $arg1@1251@01 $arg2@1252@01) $arg1@1251@01)
        (= (inv@1258@01 $arg0@1250@01 $arg1@1251@01 $arg2@1252@01) $arg2@1252@01))
      (and
        (img@1255@01 $arg0@1250@01 $arg1@1251@01 $arg2@1252@01)
        (img@1257@01 $arg0@1250@01 $arg1@1251@01 $arg2@1252@01)
        (img@1259@01 $arg0@1250@01 $arg1@1251@01 $arg2@1252@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1250@01)
      ($SortWrappers.IntTo$Snap $arg1@1251@01))
    ($SortWrappers.IntTo$Snap $arg2@1252@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1250@01)
      ($SortWrappers.IntTo$Snap $arg1@1251@01))
    ($SortWrappers.IntTo$Snap $arg2@1252@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1255@01 $arg0 $arg1 $arg2)
        (img@1257@01 $arg0 $arg1 $arg2)
        (img@1259@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1254@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1256@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1258@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1254@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1256@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1258@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1254@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1256@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1258@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1254@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1256@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1258@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1254@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1256@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1258@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@954@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1254@01 $arg0 $arg1 $arg2) (inv@1256@01 $arg0 $arg1 $arg2) (inv@1258@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1727|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1254@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1256@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1258@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1255@01 $arg0 $arg1 $arg2)
        (img@1257@01 $arg0 $arg1 $arg2)
        (img@1259@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1254@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1256@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1258@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@1253@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1254@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1256@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1258@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1728|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1260@01 Int)
(declare-const $arg1@1261@01 Int)
(declare-const $arg2@1262@01 Int)
(push) ; 24
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1263@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef106|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef107|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1260@01)
    ($SortWrappers.IntTo$Snap $arg1@1261@01))
  ($SortWrappers.IntTo$Snap $arg2@1262@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1260@01)
    ($SortWrappers.IntTo$Snap $arg1@1261@01))
  ($SortWrappers.IntTo$Snap $arg2@1262@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1260@01)
      ($SortWrappers.IntTo$Snap $arg1@1261@01))
    ($SortWrappers.IntTo$Snap $arg2@1262@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1264@01 (Int Int Int) Int)
(declare-fun img@1265@01 (Int Int Int) Bool)
(declare-fun inv@1266@01 (Int Int Int) Int)
(declare-fun img@1267@01 (Int Int Int) Bool)
(declare-fun inv@1268@01 (Int Int Int) Int)
(declare-fun img@1269@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef106|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef107|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1260@01 Int) ($arg1@1261@01 Int) ($arg2@1262@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1260@01)
          ($SortWrappers.IntTo$Snap $arg1@1261@01))
        ($SortWrappers.IntTo$Snap $arg2@1262@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1260@01)
        ($SortWrappers.IntTo$Snap $arg1@1261@01))
      ($SortWrappers.IntTo$Snap $arg2@1262@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1260@01)
        ($SortWrappers.IntTo$Snap $arg1@1261@01))
      ($SortWrappers.IntTo$Snap $arg2@1262@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1260@01)
      ($SortWrappers.IntTo$Snap $arg1@1261@01))
    ($SortWrappers.IntTo$Snap $arg2@1262@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1260@01)
      ($SortWrappers.IntTo$Snap $arg1@1261@01))
    ($SortWrappers.IntTo$Snap $arg2@1262@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1260@01 Int) ($arg1@1261@01 Int) ($arg2@1262@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1260@01)
          ($SortWrappers.IntTo$Snap $arg1@1261@01))
        ($SortWrappers.IntTo$Snap $arg2@1262@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1260@01)
            ($SortWrappers.IntTo$Snap $arg1@1261@01))
          ($SortWrappers.IntTo$Snap $arg2@1262@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1260@01)
            ($SortWrappers.IntTo$Snap $arg1@1261@01))
          ($SortWrappers.IntTo$Snap $arg2@1262@01))))))
  
  :qid |quant-u-1729|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1260@01 Int) ($arg11@1261@01 Int) ($arg21@1262@01 Int) ($arg02@1260@01 Int) ($arg12@1261@01 Int) ($arg22@1262@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1260@01)
                ($SortWrappers.IntTo$Snap $arg11@1261@01))
              ($SortWrappers.IntTo$Snap $arg21@1262@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1260@01)
              ($SortWrappers.IntTo$Snap $arg11@1261@01))
            ($SortWrappers.IntTo$Snap $arg21@1262@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1260@01)
              ($SortWrappers.IntTo$Snap $arg11@1261@01))
            ($SortWrappers.IntTo$Snap $arg21@1262@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1260@01)
              ($SortWrappers.IntTo$Snap $arg11@1261@01))
            ($SortWrappers.IntTo$Snap $arg21@1262@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1260@01)
                ($SortWrappers.IntTo$Snap $arg12@1261@01))
              ($SortWrappers.IntTo$Snap $arg22@1262@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1260@01)
              ($SortWrappers.IntTo$Snap $arg12@1261@01))
            ($SortWrappers.IntTo$Snap $arg22@1262@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1260@01)
              ($SortWrappers.IntTo$Snap $arg12@1261@01))
            ($SortWrappers.IntTo$Snap $arg22@1262@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1260@01)
              ($SortWrappers.IntTo$Snap $arg12@1261@01))
            ($SortWrappers.IntTo$Snap $arg22@1262@01)))))
      (and
        (and (= $arg01@1260@01 $arg02@1260@01) (= $arg11@1261@01 $arg12@1261@01))
        (= $arg21@1262@01 $arg22@1262@01)))
    (and
      (and (= $arg01@1260@01 $arg02@1260@01) (= $arg11@1261@01 $arg12@1261@01))
      (= $arg21@1262@01 $arg22@1262@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1260@01 Int) ($arg1@1261@01 Int) ($arg2@1262@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1260@01)
            ($SortWrappers.IntTo$Snap $arg1@1261@01))
          ($SortWrappers.IntTo$Snap $arg2@1262@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1260@01)
            ($SortWrappers.IntTo$Snap $arg1@1261@01))
          ($SortWrappers.IntTo$Snap $arg2@1262@01)))))
    (and
      (and
        (= (inv@1264@01 $arg0@1260@01 $arg1@1261@01 $arg2@1262@01) $arg0@1260@01)
        (= (inv@1266@01 $arg0@1260@01 $arg1@1261@01 $arg2@1262@01) $arg1@1261@01)
        (= (inv@1268@01 $arg0@1260@01 $arg1@1261@01 $arg2@1262@01) $arg2@1262@01))
      (and
        (img@1265@01 $arg0@1260@01 $arg1@1261@01 $arg2@1262@01)
        (img@1267@01 $arg0@1260@01 $arg1@1261@01 $arg2@1262@01)
        (img@1269@01 $arg0@1260@01 $arg1@1261@01 $arg2@1262@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1260@01)
      ($SortWrappers.IntTo$Snap $arg1@1261@01))
    ($SortWrappers.IntTo$Snap $arg2@1262@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1260@01)
      ($SortWrappers.IntTo$Snap $arg1@1261@01))
    ($SortWrappers.IntTo$Snap $arg2@1262@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1265@01 $arg0 $arg1 $arg2)
        (img@1267@01 $arg0 $arg1 $arg2)
        (img@1269@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1264@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1266@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1268@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1264@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1266@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1268@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1264@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1266@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1268@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1264@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1266@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1268@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1264@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1266@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1268@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@966@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1264@01 $arg0 $arg1 $arg2) (inv@1266@01 $arg0 $arg1 $arg2) (inv@1268@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1730|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1264@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1266@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1268@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1265@01 $arg0 $arg1 $arg2)
        (img@1267@01 $arg0 $arg1 $arg2)
        (img@1269@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1264@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1266@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1268@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@1263@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1264@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1266@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1268@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1731|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@1270@01 Int)
(declare-const $arg1@1271@01 Int)
(declare-const $arg2@1272@01 Int)
(push) ; 24
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1273@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef108|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef109|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1270@01)
    ($SortWrappers.IntTo$Snap $arg1@1271@01))
  ($SortWrappers.IntTo$Snap $arg2@1272@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1270@01)
    ($SortWrappers.IntTo$Snap $arg1@1271@01))
  ($SortWrappers.IntTo$Snap $arg2@1272@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1270@01)
      ($SortWrappers.IntTo$Snap $arg1@1271@01))
    ($SortWrappers.IntTo$Snap $arg2@1272@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1274@01 (Int Int Int) Int)
(declare-fun img@1275@01 (Int Int Int) Bool)
(declare-fun inv@1276@01 (Int Int Int) Int)
(declare-fun img@1277@01 (Int Int Int) Bool)
(declare-fun inv@1278@01 (Int Int Int) Int)
(declare-fun img@1279@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef108|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef109|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1270@01 Int) ($arg1@1271@01 Int) ($arg2@1272@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1270@01)
          ($SortWrappers.IntTo$Snap $arg1@1271@01))
        ($SortWrappers.IntTo$Snap $arg2@1272@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1270@01)
        ($SortWrappers.IntTo$Snap $arg1@1271@01))
      ($SortWrappers.IntTo$Snap $arg2@1272@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1270@01)
        ($SortWrappers.IntTo$Snap $arg1@1271@01))
      ($SortWrappers.IntTo$Snap $arg2@1272@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1270@01)
      ($SortWrappers.IntTo$Snap $arg1@1271@01))
    ($SortWrappers.IntTo$Snap $arg2@1272@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1270@01)
      ($SortWrappers.IntTo$Snap $arg1@1271@01))
    ($SortWrappers.IntTo$Snap $arg2@1272@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1270@01 Int) ($arg1@1271@01 Int) ($arg2@1272@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1270@01)
          ($SortWrappers.IntTo$Snap $arg1@1271@01))
        ($SortWrappers.IntTo$Snap $arg2@1272@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1270@01)
            ($SortWrappers.IntTo$Snap $arg1@1271@01))
          ($SortWrappers.IntTo$Snap $arg2@1272@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1270@01)
            ($SortWrappers.IntTo$Snap $arg1@1271@01))
          ($SortWrappers.IntTo$Snap $arg2@1272@01))))))
  
  :qid |quant-u-1732|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1270@01 Int) ($arg11@1271@01 Int) ($arg21@1272@01 Int) ($arg02@1270@01 Int) ($arg12@1271@01 Int) ($arg22@1272@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1270@01)
                ($SortWrappers.IntTo$Snap $arg11@1271@01))
              ($SortWrappers.IntTo$Snap $arg21@1272@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1270@01)
              ($SortWrappers.IntTo$Snap $arg11@1271@01))
            ($SortWrappers.IntTo$Snap $arg21@1272@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1270@01)
              ($SortWrappers.IntTo$Snap $arg11@1271@01))
            ($SortWrappers.IntTo$Snap $arg21@1272@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1270@01)
              ($SortWrappers.IntTo$Snap $arg11@1271@01))
            ($SortWrappers.IntTo$Snap $arg21@1272@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1270@01)
                ($SortWrappers.IntTo$Snap $arg12@1271@01))
              ($SortWrappers.IntTo$Snap $arg22@1272@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1270@01)
              ($SortWrappers.IntTo$Snap $arg12@1271@01))
            ($SortWrappers.IntTo$Snap $arg22@1272@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1270@01)
              ($SortWrappers.IntTo$Snap $arg12@1271@01))
            ($SortWrappers.IntTo$Snap $arg22@1272@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1270@01)
              ($SortWrappers.IntTo$Snap $arg12@1271@01))
            ($SortWrappers.IntTo$Snap $arg22@1272@01)))))
      (and
        (and (= $arg01@1270@01 $arg02@1270@01) (= $arg11@1271@01 $arg12@1271@01))
        (= $arg21@1272@01 $arg22@1272@01)))
    (and
      (and (= $arg01@1270@01 $arg02@1270@01) (= $arg11@1271@01 $arg12@1271@01))
      (= $arg21@1272@01 $arg22@1272@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1270@01 Int) ($arg1@1271@01 Int) ($arg2@1272@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1270@01)
            ($SortWrappers.IntTo$Snap $arg1@1271@01))
          ($SortWrappers.IntTo$Snap $arg2@1272@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1270@01)
            ($SortWrappers.IntTo$Snap $arg1@1271@01))
          ($SortWrappers.IntTo$Snap $arg2@1272@01)))))
    (and
      (and
        (= (inv@1274@01 $arg0@1270@01 $arg1@1271@01 $arg2@1272@01) $arg0@1270@01)
        (= (inv@1276@01 $arg0@1270@01 $arg1@1271@01 $arg2@1272@01) $arg1@1271@01)
        (= (inv@1278@01 $arg0@1270@01 $arg1@1271@01 $arg2@1272@01) $arg2@1272@01))
      (and
        (img@1275@01 $arg0@1270@01 $arg1@1271@01 $arg2@1272@01)
        (img@1277@01 $arg0@1270@01 $arg1@1271@01 $arg2@1272@01)
        (img@1279@01 $arg0@1270@01 $arg1@1271@01 $arg2@1272@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1270@01)
      ($SortWrappers.IntTo$Snap $arg1@1271@01))
    ($SortWrappers.IntTo$Snap $arg2@1272@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1270@01)
      ($SortWrappers.IntTo$Snap $arg1@1271@01))
    ($SortWrappers.IntTo$Snap $arg2@1272@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1275@01 $arg0 $arg1 $arg2)
        (img@1277@01 $arg0 $arg1 $arg2)
        (img@1279@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1274@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1276@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1278@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1274@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1276@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1278@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1274@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1276@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1278@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1274@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1276@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1278@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1274@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1276@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1278@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1274@01 $arg0 $arg1 $arg2) (inv@1276@01 $arg0 $arg1 $arg2) (inv@1278@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1733|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1274@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1276@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1278@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1275@01 $arg0 $arg1 $arg2)
        (img@1277@01 $arg0 $arg1 $arg2)
        (img@1279@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1274@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1276@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1278@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@1273@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1274@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1276@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1278@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1734|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@1280@01 Int)
(declare-const $arg1@1281@01 Int)
(declare-const $arg2@1282@01 Int)
(push) ; 24
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1283@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef110|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef111|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1280@01)
    ($SortWrappers.IntTo$Snap $arg1@1281@01))
  ($SortWrappers.IntTo$Snap $arg2@1282@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1280@01)
    ($SortWrappers.IntTo$Snap $arg1@1281@01))
  ($SortWrappers.IntTo$Snap $arg2@1282@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1280@01)
      ($SortWrappers.IntTo$Snap $arg1@1281@01))
    ($SortWrappers.IntTo$Snap $arg2@1282@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1284@01 (Int Int Int) Int)
(declare-fun img@1285@01 (Int Int Int) Bool)
(declare-fun inv@1286@01 (Int Int Int) Int)
(declare-fun img@1287@01 (Int Int Int) Bool)
(declare-fun inv@1288@01 (Int Int Int) Int)
(declare-fun img@1289@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef110|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef111|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1280@01 Int) ($arg1@1281@01 Int) ($arg2@1282@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1280@01)
          ($SortWrappers.IntTo$Snap $arg1@1281@01))
        ($SortWrappers.IntTo$Snap $arg2@1282@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1280@01)
        ($SortWrappers.IntTo$Snap $arg1@1281@01))
      ($SortWrappers.IntTo$Snap $arg2@1282@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1280@01)
        ($SortWrappers.IntTo$Snap $arg1@1281@01))
      ($SortWrappers.IntTo$Snap $arg2@1282@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1280@01)
      ($SortWrappers.IntTo$Snap $arg1@1281@01))
    ($SortWrappers.IntTo$Snap $arg2@1282@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1280@01)
      ($SortWrappers.IntTo$Snap $arg1@1281@01))
    ($SortWrappers.IntTo$Snap $arg2@1282@01))))
  :qid |e$Transfer-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1280@01 Int) ($arg1@1281@01 Int) ($arg2@1282@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1280@01)
          ($SortWrappers.IntTo$Snap $arg1@1281@01))
        ($SortWrappers.IntTo$Snap $arg2@1282@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1280@01)
            ($SortWrappers.IntTo$Snap $arg1@1281@01))
          ($SortWrappers.IntTo$Snap $arg2@1282@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1280@01)
            ($SortWrappers.IntTo$Snap $arg1@1281@01))
          ($SortWrappers.IntTo$Snap $arg2@1282@01))))))
  
  :qid |quant-u-1735|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1280@01 Int) ($arg11@1281@01 Int) ($arg21@1282@01 Int) ($arg02@1280@01 Int) ($arg12@1281@01 Int) ($arg22@1282@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1280@01)
                ($SortWrappers.IntTo$Snap $arg11@1281@01))
              ($SortWrappers.IntTo$Snap $arg21@1282@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1280@01)
              ($SortWrappers.IntTo$Snap $arg11@1281@01))
            ($SortWrappers.IntTo$Snap $arg21@1282@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1280@01)
              ($SortWrappers.IntTo$Snap $arg11@1281@01))
            ($SortWrappers.IntTo$Snap $arg21@1282@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1280@01)
              ($SortWrappers.IntTo$Snap $arg11@1281@01))
            ($SortWrappers.IntTo$Snap $arg21@1282@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1280@01)
                ($SortWrappers.IntTo$Snap $arg12@1281@01))
              ($SortWrappers.IntTo$Snap $arg22@1282@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1280@01)
              ($SortWrappers.IntTo$Snap $arg12@1281@01))
            ($SortWrappers.IntTo$Snap $arg22@1282@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1280@01)
              ($SortWrappers.IntTo$Snap $arg12@1281@01))
            ($SortWrappers.IntTo$Snap $arg22@1282@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1280@01)
              ($SortWrappers.IntTo$Snap $arg12@1281@01))
            ($SortWrappers.IntTo$Snap $arg22@1282@01)))))
      (and
        (and (= $arg01@1280@01 $arg02@1280@01) (= $arg11@1281@01 $arg12@1281@01))
        (= $arg21@1282@01 $arg22@1282@01)))
    (and
      (and (= $arg01@1280@01 $arg02@1280@01) (= $arg11@1281@01 $arg12@1281@01))
      (= $arg21@1282@01 $arg22@1282@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1280@01 Int) ($arg1@1281@01 Int) ($arg2@1282@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1280@01)
            ($SortWrappers.IntTo$Snap $arg1@1281@01))
          ($SortWrappers.IntTo$Snap $arg2@1282@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1280@01)
            ($SortWrappers.IntTo$Snap $arg1@1281@01))
          ($SortWrappers.IntTo$Snap $arg2@1282@01)))))
    (and
      (and
        (= (inv@1284@01 $arg0@1280@01 $arg1@1281@01 $arg2@1282@01) $arg0@1280@01)
        (= (inv@1286@01 $arg0@1280@01 $arg1@1281@01 $arg2@1282@01) $arg1@1281@01)
        (= (inv@1288@01 $arg0@1280@01 $arg1@1281@01 $arg2@1282@01) $arg2@1282@01))
      (and
        (img@1285@01 $arg0@1280@01 $arg1@1281@01 $arg2@1282@01)
        (img@1287@01 $arg0@1280@01 $arg1@1281@01 $arg2@1282@01)
        (img@1289@01 $arg0@1280@01 $arg1@1281@01 $arg2@1282@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1280@01)
      ($SortWrappers.IntTo$Snap $arg1@1281@01))
    ($SortWrappers.IntTo$Snap $arg2@1282@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1280@01)
      ($SortWrappers.IntTo$Snap $arg1@1281@01))
    ($SortWrappers.IntTo$Snap $arg2@1282@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1285@01 $arg0 $arg1 $arg2)
        (img@1287@01 $arg0 $arg1 $arg2)
        (img@1289@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1284@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1286@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1288@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1284@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1286@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1288@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1284@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1286@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1288@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1284@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1286@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1288@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1284@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1286@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1288@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1284@01 $arg0 $arg1 $arg2) (inv@1286@01 $arg0 $arg1 $arg2) (inv@1288@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1736|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1284@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1286@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1288@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1285@01 $arg0 $arg1 $arg2)
        (img@1287@01 $arg0 $arg1 $arg2)
        (img@1289@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1284@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1286@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1288@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@1283@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1284@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1286@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1288@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1737|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@1290@01 Int)
(declare-const $arg1@1291@01 Int)
(declare-const $arg2@1292@01 Int)
(push) ; 24
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1293@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef112|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef113|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1290@01)
    ($SortWrappers.IntTo$Snap $arg1@1291@01))
  ($SortWrappers.IntTo$Snap $arg2@1292@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1290@01)
    ($SortWrappers.IntTo$Snap $arg1@1291@01))
  ($SortWrappers.IntTo$Snap $arg2@1292@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1290@01)
      ($SortWrappers.IntTo$Snap $arg1@1291@01))
    ($SortWrappers.IntTo$Snap $arg2@1292@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 24
(declare-fun inv@1294@01 (Int Int Int) Int)
(declare-fun img@1295@01 (Int Int Int) Bool)
(declare-fun inv@1296@01 (Int Int Int) Int)
(declare-fun img@1297@01 (Int Int Int) Bool)
(declare-fun inv@1298@01 (Int Int Int) Int)
(declare-fun img@1299@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef112|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef113|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1290@01 Int) ($arg1@1291@01 Int) ($arg2@1292@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1290@01)
          ($SortWrappers.IntTo$Snap $arg1@1291@01))
        ($SortWrappers.IntTo$Snap $arg2@1292@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1290@01)
        ($SortWrappers.IntTo$Snap $arg1@1291@01))
      ($SortWrappers.IntTo$Snap $arg2@1292@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1290@01)
        ($SortWrappers.IntTo$Snap $arg1@1291@01))
      ($SortWrappers.IntTo$Snap $arg2@1292@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1290@01)
      ($SortWrappers.IntTo$Snap $arg1@1291@01))
    ($SortWrappers.IntTo$Snap $arg2@1292@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1290@01)
      ($SortWrappers.IntTo$Snap $arg1@1291@01))
    ($SortWrappers.IntTo$Snap $arg2@1292@01))))
  :qid |e$Approval-aux|)))
(push) ; 24
(assert (not (forall (($arg0@1290@01 Int) ($arg1@1291@01 Int) ($arg2@1292@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1290@01)
          ($SortWrappers.IntTo$Snap $arg1@1291@01))
        ($SortWrappers.IntTo$Snap $arg2@1292@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1290@01)
            ($SortWrappers.IntTo$Snap $arg1@1291@01))
          ($SortWrappers.IntTo$Snap $arg2@1292@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1290@01)
            ($SortWrappers.IntTo$Snap $arg1@1291@01))
          ($SortWrappers.IntTo$Snap $arg2@1292@01))))))
  
  :qid |quant-u-1738|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 24
(assert (not (forall (($arg01@1290@01 Int) ($arg11@1291@01 Int) ($arg21@1292@01 Int) ($arg02@1290@01 Int) ($arg12@1291@01 Int) ($arg22@1292@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1290@01)
                ($SortWrappers.IntTo$Snap $arg11@1291@01))
              ($SortWrappers.IntTo$Snap $arg21@1292@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1290@01)
              ($SortWrappers.IntTo$Snap $arg11@1291@01))
            ($SortWrappers.IntTo$Snap $arg21@1292@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1290@01)
              ($SortWrappers.IntTo$Snap $arg11@1291@01))
            ($SortWrappers.IntTo$Snap $arg21@1292@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1290@01)
              ($SortWrappers.IntTo$Snap $arg11@1291@01))
            ($SortWrappers.IntTo$Snap $arg21@1292@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1290@01)
                ($SortWrappers.IntTo$Snap $arg12@1291@01))
              ($SortWrappers.IntTo$Snap $arg22@1292@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1290@01)
              ($SortWrappers.IntTo$Snap $arg12@1291@01))
            ($SortWrappers.IntTo$Snap $arg22@1292@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1290@01)
              ($SortWrappers.IntTo$Snap $arg12@1291@01))
            ($SortWrappers.IntTo$Snap $arg22@1292@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1290@01)
              ($SortWrappers.IntTo$Snap $arg12@1291@01))
            ($SortWrappers.IntTo$Snap $arg22@1292@01)))))
      (and
        (and (= $arg01@1290@01 $arg02@1290@01) (= $arg11@1291@01 $arg12@1291@01))
        (= $arg21@1292@01 $arg22@1292@01)))
    (and
      (and (= $arg01@1290@01 $arg02@1290@01) (= $arg11@1291@01 $arg12@1291@01))
      (= $arg21@1292@01 $arg22@1292@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1290@01 Int) ($arg1@1291@01 Int) ($arg2@1292@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1290@01)
            ($SortWrappers.IntTo$Snap $arg1@1291@01))
          ($SortWrappers.IntTo$Snap $arg2@1292@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1290@01)
            ($SortWrappers.IntTo$Snap $arg1@1291@01))
          ($SortWrappers.IntTo$Snap $arg2@1292@01)))))
    (and
      (and
        (= (inv@1294@01 $arg0@1290@01 $arg1@1291@01 $arg2@1292@01) $arg0@1290@01)
        (= (inv@1296@01 $arg0@1290@01 $arg1@1291@01 $arg2@1292@01) $arg1@1291@01)
        (= (inv@1298@01 $arg0@1290@01 $arg1@1291@01 $arg2@1292@01) $arg2@1292@01))
      (and
        (img@1295@01 $arg0@1290@01 $arg1@1291@01 $arg2@1292@01)
        (img@1297@01 $arg0@1290@01 $arg1@1291@01 $arg2@1292@01)
        (img@1299@01 $arg0@1290@01 $arg1@1291@01 $arg2@1292@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1290@01)
      ($SortWrappers.IntTo$Snap $arg1@1291@01))
    ($SortWrappers.IntTo$Snap $arg2@1292@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1290@01)
      ($SortWrappers.IntTo$Snap $arg1@1291@01))
    ($SortWrappers.IntTo$Snap $arg2@1292@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1295@01 $arg0 $arg1 $arg2)
        (img@1297@01 $arg0 $arg1 $arg2)
        (img@1299@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1294@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1296@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1298@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1294@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1296@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1298@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1294@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1296@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1298@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1294@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1296@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1298@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1294@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1296@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1298@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1002@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1294@01 $arg0 $arg1 $arg2) (inv@1296@01 $arg0 $arg1 $arg2) (inv@1298@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1739|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 24
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1294@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1296@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1298@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1295@01 $arg0 $arg1 $arg2)
        (img@1297@01 $arg0 $arg1 $arg2)
        (img@1299@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1294@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1296@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1298@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@1293@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1294@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1296@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1298@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1740|))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$6
(push) ; 24
(set-option :timeout 10)
(assert (not (not l$send_fail$2@874@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not l$send_fail$2@874@01))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 330 | l$send_fail$2@874@01 | live]
; [else-branch: 330 | !(l$send_fail$2@874@01) | live]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 330 | l$send_fail$2@874@01]
(assert l$send_fail$2@874@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@1300@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 331 | True | live]
; [else-branch: 331 | False | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 331 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1301@01 $Snap)
(assert (= $t@1301@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1302@01 $Struct)
(assert (=
  self@1302@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 25
; [then-branch: 332 | False | dead]
; [else-branch: 332 | True | live]
(set-option :timeout 0)
(push) ; 25
; [else-branch: 332 | True]
(pop) ; 25
(pop) ; 24
(push) ; 24
; [else-branch: 330 | !(l$send_fail$2@874@01)]
(assert (not l$send_fail$2@874@01))
(pop) ; 24
; [eval] !l$send_fail$2
(push) ; 24
(set-option :timeout 10)
(assert (not l$send_fail$2@874@01))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (not l$send_fail$2@874@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 333 | !(l$send_fail$2@874@01) | live]
; [else-branch: 333 | l$send_fail$2@874@01 | live]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 333 | !(l$send_fail$2@874@01)]
(assert (not l$send_fail$2@874@01))
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; i2$$pre_self := self
; [exec]
; i2$$pre_$contracts := $contracts
; [exec]
; $contracts := l$havoc$7
; [exec]
; $old_$contracts := $contracts
; [exec]
; self := l$havoc$8
; [exec]
; $contracts := l$havoc$9
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@1303@01 $Snap)
(assert (= $t@1303@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$havoc$8@879@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@1304@01 $Snap)
(assert (= $t@1304@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$havoc$8@879@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1305@01 $Snap)
(assert (= $t@1305@01 ($Snap.combine ($Snap.first $t@1305@01) ($Snap.second $t@1305@01))))
(assert (= ($Snap.first $t@1305@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 2))))
(assert (= ($Snap.second $t@1305@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1306@01 $Snap)
(assert (= $t@1306@01 ($Snap.combine ($Snap.first $t@1306@01) ($Snap.second $t@1306@01))))
(assert (= ($Snap.first $t@1306@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 3))))
(assert (= ($Snap.second $t@1306@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1307@01 $Snap)
(assert (= $t@1307@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@1308@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 26
; [then-branch: 334 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 4)), $q2@1308@01)) | live]
; [else-branch: 334 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 4)), $q2@1308@01) | live]
(push) ; 27
; [then-branch: 334 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 4)), $q2@1308@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1308@01))))
(pop) ; 27
(push) ; 27
; [else-branch: 334 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 4)), $q2@1308@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1308@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 27
(pop) ; 26
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1308@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1308@01)))))
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1308@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1308@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1308@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1308@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1755@11@1755@345-aux|)))
(assert (forall (($q2@1308@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1308@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1308@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1308@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1755@11@1755@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@1309@01 $Snap)
(assert (= $t@1309@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@1310@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1310@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1310@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 4)) $q2@1310@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1756@11@1756@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@1311@01 $Snap)
(assert (= $t@1311@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@1312@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@1313@01 Int)
(push) ; 26
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 27
; [then-branch: 335 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@879@01, 5)), $q3@1312@01), $q4@1313@01)) | live]
; [else-branch: 335 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@879@01, 5)), $q3@1312@01), $q4@1313@01) | live]
(push) ; 28
; [then-branch: 335 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@879@01, 5)), $q3@1312@01), $q4@1313@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01))))
(pop) ; 28
(push) ; 28
; [else-branch: 335 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$havoc$8@879@01, 5)), $q3@1312@01), $q4@1313@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01)))))
(pop) ; 26
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@1313@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1757@131@1757@597-aux|)))
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1312@01 Int)) (!
  (forall (($q4@1313@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1757@131@1757@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1757@11@1757@598-aux|)))
(assert (forall (($q3@1312@01 Int)) (!
  (forall (($q4@1313@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01) $q4@1313@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1757@131@1757@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1312@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1757@11@1757@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@1314@01 $Snap)
(assert (= $t@1314@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@1315@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@1316@01 Int)
(push) ; 26
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 26
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1315@01 Int)) (!
  (forall (($q4@1316@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1315@01) $q4@1316@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1315@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1315@01) $q4@1316@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1758@131@1758@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$havoc$8@879@01 5)) $q3@1315@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1758@11@1758@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1317@01 $Snap)
(assert (= $t@1317@01 ($Snap.combine ($Snap.first $t@1317@01) ($Snap.second $t@1317@01))))
(assert (= ($Snap.first $t@1317@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 6))))
(assert (= ($Snap.second $t@1317@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1318@01 $Snap)
(assert (= $t@1318@01 ($Snap.combine ($Snap.first $t@1318@01) ($Snap.second $t@1318@01))))
(assert (= ($Snap.first $t@1318@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 7))))
(assert (= ($Snap.second $t@1318@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1319@01 $Snap)
(assert (= $t@1319@01 ($Snap.combine ($Snap.first $t@1319@01) ($Snap.second $t@1319@01))))
(assert (= ($Snap.first $t@1319@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 8))))
(assert (= ($Snap.second $t@1319@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@1320@01 $Snap)
(assert (= $t@1320@01 ($Snap.combine ($Snap.first $t@1320@01) ($Snap.second $t@1320@01))))
(assert (= ($Snap.first $t@1320@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 9))))
(assert (= ($Snap.second $t@1320@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1321@01 $Snap)
(assert (= $t@1321@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@1322@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 26
; [then-branch: 336 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 11)), $q5@1322@01)) | live]
; [else-branch: 336 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 11)), $q5@1322@01) | live]
(push) ; 27
; [then-branch: 336 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 11)), $q5@1322@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1322@01))))
(pop) ; 27
(push) ; 27
; [else-branch: 336 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 11)), $q5@1322@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1322@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 27
(pop) ; 26
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1322@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1322@01)))))
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1322@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1322@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1322@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1322@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1763@11@1763@348-aux|)))
(assert (forall (($q5@1322@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1322@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1322@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1322@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1763@11@1763@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@1323@01 $Snap)
(assert (= $t@1323@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@1324@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1324@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1324@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $q5@1324@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1764@11@1764@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1325@01 $Snap)
(assert (= $t@1325@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@1326@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 26
; [then-branch: 337 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 12)), $q6@1326@01)) | live]
; [else-branch: 337 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 12)), $q6@1326@01) | live]
(push) ; 27
; [then-branch: 337 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 12)), $q6@1326@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1326@01))))
(pop) ; 27
(push) ; 27
; [else-branch: 337 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$havoc$8@879@01, 12)), $q6@1326@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1326@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 27
(pop) ; 26
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1326@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1326@01)))))
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1326@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1326@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1326@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1326@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1765@11@1765@348-aux|)))
(assert (forall (($q6@1326@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1326@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1326@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1326@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1765@11@1765@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@1327@01 $Snap)
(assert (= $t@1327@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@1328@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1328@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1328@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 12)) $q6@1328@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1766@11@1766@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@1329@01 $Snap)
(assert (= $t@1329@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@1330@01 $Snap)
(assert (= $t@1330@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@1331@01 Int)
(set-option :timeout 0)
(push) ; 25
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($old_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($old_self, 11)
(pop) ; 25
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($a@1331@01 Int)) (!
  (>=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $a@1331@01)
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$2@868@01 11)) $a@1331@01))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$havoc$8@879@01 11)) $a@1331@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1769@11@1769@262|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (not l$no_reentrant_call$1@881@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not l$no_reentrant_call$1@881@01))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 338 | l$no_reentrant_call$1@881@01 | live]
; [else-branch: 338 | !(l$no_reentrant_call$1@881@01) | live]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 338 | l$no_reentrant_call$1@881@01]
(assert l$no_reentrant_call$1@881@01)
; [exec]
; self := $old_self
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$10
; [exec]
; $old_$contracts := i2$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$11
; [exec]
; $old_$contracts := i2$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$raw_ret$1
(push) ; 26
(set-option :timeout 10)
(assert (not l$raw_ret$1@875@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@875@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 339 | !(l$raw_ret$1@875@01) | live]
; [else-branch: 339 | l$raw_ret$1@875@01 | live]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 339 | !(l$raw_ret$1@875@01)]
(assert (not l$raw_ret$1@875@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 27
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 340 | True | live]
; [else-branch: 340 | False | dead]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 340 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1332@01 $Snap)
(assert (= $t@1332@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1333@01 $Struct)
(assert (=
  self@1333@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 27
; [then-branch: 341 | False | dead]
; [else-branch: 341 | True | live]
(set-option :timeout 0)
(push) ; 27
; [else-branch: 341 | True]
(pop) ; 27
(pop) ; 26
(push) ; 26
; [else-branch: 339 | l$raw_ret$1@875@01]
(assert l$raw_ret$1@875@01)
(pop) ; 26
; [eval] !!l$raw_ret$1
; [eval] !l$raw_ret$1
(push) ; 26
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@875@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not l$raw_ret$1@875@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 342 | l$raw_ret$1@875@01 | live]
; [else-branch: 342 | !(l$raw_ret$1@875@01) | live]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 342 | l$raw_ret$1@875@01]
(assert l$raw_ret$1@875@01)
; [exec]
; inhale acc(e$RemoveLiquidity(($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$eth_amount),
;   $unwrap(l$token_amount)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$eth_amount)
; [eval] $unwrap(l$token_amount)
(declare-const $t@1334@01 $Snap)
(declare-const sm@1335@01 $PSF<e$RemoveLiquidity>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$RemoveLiquidity (as sm@1335@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01))))
  $t@1334@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      (= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$eth_amount@1018@01))
      (=
        ($unwrap<Int> l$token_amount@1021@01)
        ($unwrap<Int> l$token_amount@1021@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(e$Transfer(($struct_get($struct_loc(msg, 0)): Int), 0, $unwrap(l$amount)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$amount)
(declare-const $t@1336@01 $Snap)
(declare-const sm@1337@01 $PSF<e$Transfer>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$Transfer (as sm@1337@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      ($SortWrappers.IntTo$Snap 0))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01))))
  $t@1336@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      (= 0 0)
      (= ($unwrap<Int> l$amount@838@01) ($unwrap<Int> l$amount@838@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap 0))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap 0))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01)))))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; $res := s$struct$EtherTokenPair$init($unwrap(l$eth_amount), $unwrap(l$token_amount))
; [eval] s$struct$EtherTokenPair$init($unwrap(l$eth_amount), $unwrap(l$token_amount))
; [eval] $unwrap(l$eth_amount)
; [eval] $unwrap(l$token_amount)
(declare-const $res@1338@01 $Struct)
(assert (=
  $res@1338@01
  (s$struct$EtherTokenPair$init<$Struct> ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$token_amount@1021@01))))
; [exec]
; label return
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not $out_of_gas@884@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not $out_of_gas@884@01))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 343 | $out_of_gas@884@01 | live]
; [else-branch: 343 | !($out_of_gas@884@01) | live]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 343 | $out_of_gas@884@01]
(assert $out_of_gas@884@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 344 | True | live]
; [else-branch: 344 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 344 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1339@01 $Snap)
(assert (= $t@1339@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1340@01 $Struct)
(assert (=
  self@1340@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 28
; [then-branch: 345 | False | dead]
; [else-branch: 345 | True | live]
(set-option :timeout 0)
(push) ; 28
; [else-branch: 345 | True]
(pop) ; 28
(pop) ; 27
(push) ; 27
; [else-branch: 343 | !($out_of_gas@884@01)]
(assert (not $out_of_gas@884@01))
(pop) ; 27
; [eval] !$out_of_gas
(push) ; 27
(set-option :timeout 10)
(assert (not $out_of_gas@884@01))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not $out_of_gas@884@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 346 | !($out_of_gas@884@01) | live]
; [else-branch: 346 | $out_of_gas@884@01 | live]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 346 | !($out_of_gas@884@01)]
(assert (not $out_of_gas@884@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 347 | False | dead]
; [else-branch: 347 | True | live]
(push) ; 28
; [else-branch: 347 | True]
(pop) ; 28
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 348 | True | live]
; [else-branch: 348 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 348 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1341@01 $Snap)
(assert (= $t@1341@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1342@01 $Struct)
(assert (=
  self@1342@01
  ($struct_set<$Struct> l$havoc$2@868@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> l$havoc$2@868@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 28
(pop) ; 27
(set-option :timeout 0)
(push) ; 27
; [else-branch: 346 | $out_of_gas@884@01]
(assert $out_of_gas@884@01)
(pop) ; 27
(pop) ; 26
(push) ; 26
; [else-branch: 342 | !(l$raw_ret$1@875@01)]
(assert (not l$raw_ret$1@875@01))
(pop) ; 26
(pop) ; 25
(push) ; 25
; [else-branch: 338 | !(l$no_reentrant_call$1@881@01)]
(assert (not l$no_reentrant_call$1@881@01))
(pop) ; 25
; [eval] !l$no_reentrant_call$1
(push) ; 25
(set-option :timeout 10)
(assert (not l$no_reentrant_call$1@881@01))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (not l$no_reentrant_call$1@881@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 349 | !(l$no_reentrant_call$1@881@01) | live]
; [else-branch: 349 | l$no_reentrant_call$1@881@01 | live]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 349 | !(l$no_reentrant_call$1@881@01)]
(assert (not l$no_reentrant_call$1@881@01))
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$10
; [exec]
; $old_$contracts := i2$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$havoc$11
; [exec]
; $old_$contracts := i2$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$raw_ret$1
(push) ; 26
(set-option :timeout 10)
(assert (not l$raw_ret$1@875@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@875@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 350 | !(l$raw_ret$1@875@01) | live]
; [else-branch: 350 | l$raw_ret$1@875@01 | live]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 350 | !(l$raw_ret$1@875@01)]
(assert (not l$raw_ret$1@875@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 27
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 351 | True | live]
; [else-branch: 351 | False | dead]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 351 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1343@01 $Snap)
(assert (= $t@1343@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1344@01 $Struct)
(assert (=
  self@1344@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 27
; [then-branch: 352 | False | dead]
; [else-branch: 352 | True | live]
(set-option :timeout 0)
(push) ; 27
; [else-branch: 352 | True]
(pop) ; 27
(pop) ; 26
(push) ; 26
; [else-branch: 350 | l$raw_ret$1@875@01]
(assert l$raw_ret$1@875@01)
(pop) ; 26
; [eval] !!l$raw_ret$1
; [eval] !l$raw_ret$1
(push) ; 26
(set-option :timeout 10)
(assert (not (not l$raw_ret$1@875@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not l$raw_ret$1@875@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 353 | l$raw_ret$1@875@01 | live]
; [else-branch: 353 | !(l$raw_ret$1@875@01) | live]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 353 | l$raw_ret$1@875@01]
(assert l$raw_ret$1@875@01)
; [exec]
; inhale acc(e$RemoveLiquidity(($struct_get($struct_loc(msg, 0)): Int), $unwrap(l$eth_amount),
;   $unwrap(l$token_amount)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$eth_amount)
; [eval] $unwrap(l$token_amount)
(declare-const $t@1345@01 $Snap)
(declare-const sm@1346@01 $PSF<e$RemoveLiquidity>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$RemoveLiquidity (as sm@1346@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01))))
  $t@1345@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      (= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$eth_amount@1018@01))
      (=
        ($unwrap<Int> l$token_amount@1021@01)
        ($unwrap<Int> l$token_amount@1021@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@978@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$eth_amount@1018@01)))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$token_amount@1021@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(e$Transfer(($struct_get($struct_loc(msg, 0)): Int), 0, $unwrap(l$amount)), write)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] $unwrap(l$amount)
(declare-const $t@1347@01 $Snap)
(declare-const sm@1348@01 $PSF<e$Transfer>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$Transfer (as sm@1348@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      ($SortWrappers.IntTo$Snap 0))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01))))
  $t@1347@01))
(assert (<=
  $Perm.No
  (ite
    (and
      (=
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0))
        ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
      (= 0 0)
      (= ($unwrap<Int> l$amount@838@01) ($unwrap<Int> l$amount@838@01)))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@990@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap 0))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))
    ($SortWrappers.IntTo$Snap 0))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$amount@838@01)))))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; $res := s$struct$EtherTokenPair$init($unwrap(l$eth_amount), $unwrap(l$token_amount))
; [eval] s$struct$EtherTokenPair$init($unwrap(l$eth_amount), $unwrap(l$token_amount))
; [eval] $unwrap(l$eth_amount)
; [eval] $unwrap(l$token_amount)
(declare-const $res@1349@01 $Struct)
(assert (=
  $res@1349@01
  (s$struct$EtherTokenPair$init<$Struct> ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$token_amount@1021@01))))
; [exec]
; label return
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not $out_of_gas@884@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not $out_of_gas@884@01))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 354 | $out_of_gas@884@01 | live]
; [else-branch: 354 | !($out_of_gas@884@01) | live]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 354 | $out_of_gas@884@01]
(assert $out_of_gas@884@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc$12
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 355 | True | live]
; [else-branch: 355 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 355 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1350@01 $Snap)
(assert (= $t@1350@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1351@01 $Struct)
(assert (=
  self@1351@01
  ($struct_set<$Struct> self@848@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@848@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 28
; [then-branch: 356 | False | dead]
; [else-branch: 356 | True | live]
(set-option :timeout 0)
(push) ; 28
; [else-branch: 356 | True]
(pop) ; 28
(pop) ; 27
(push) ; 27
; [else-branch: 354 | !($out_of_gas@884@01)]
(assert (not $out_of_gas@884@01))
(pop) ; 27
; [eval] !$out_of_gas
(push) ; 27
(set-option :timeout 10)
(assert (not $out_of_gas@884@01))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not $out_of_gas@884@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 357 | !($out_of_gas@884@01) | live]
; [else-branch: 357 | $out_of_gas@884@01 | live]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 357 | !($out_of_gas@884@01)]
(assert (not $out_of_gas@884@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 358 | False | dead]
; [else-branch: 358 | True | live]
(push) ; 28
; [else-branch: 358 | True]
(pop) ; 28
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 359 | True | live]
; [else-branch: 359 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 359 | True]
; [exec]
; inhale l$havoc$13 >= 0
(declare-const $t@1352@01 $Snap)
(assert (= $t@1352@01 $Snap.unit))
; [eval] l$havoc$13 >= 0
(assert (>= l$havoc$13@886@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$13): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$13
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1353@01 $Struct)
(assert (=
  self@1353@01
  ($struct_set<$Struct> l$havoc$8@879@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> l$havoc$8@879@01 8))
    l$havoc$13@886@01))))
; [exec]
; $contracts := l$havoc$14
(pop) ; 28
(pop) ; 27
(set-option :timeout 0)
(push) ; 27
; [else-branch: 357 | $out_of_gas@884@01]
(assert $out_of_gas@884@01)
(pop) ; 27
(pop) ; 26
(push) ; 26
; [else-branch: 353 | !(l$raw_ret$1@875@01)]
(assert (not l$raw_ret$1@875@01))
(pop) ; 26
(pop) ; 25
(push) ; 25
; [else-branch: 349 | l$no_reentrant_call$1@881@01]
(assert l$no_reentrant_call$1@881@01)
(pop) ; 25
(pop) ; 24
(push) ; 24
; [else-branch: 333 | l$send_fail$2@874@01]
(assert l$send_fail$2@874@01)
(pop) ; 24
(pop) ; 23
(push) ; 23
; [else-branch: 329 | l$no_reentrant_call@870@01]
(assert l$no_reentrant_call@870@01)
(pop) ; 23
(pop) ; 22
(push) ; 22
; [else-branch: 293 | l$send_fail$1@864@01]
(assert l$send_fail$1@864@01)
(pop) ; 22
(pop) ; 21
(push) ; 21
; [else-branch: 289 | $struct_get[Int]($struct_loc[Int](self@1029@01, 8)) < $unwrap[Int](l$eth_amount@1018@01)]
(assert (<
  ($struct_get<Int> ($struct_loc<Int> self@1029@01 8))
  ($unwrap<Int> l$eth_amount@1018@01)))
(pop) ; 21
(pop) ; 20
(pop) ; 19
(push) ; 19
; [else-branch: 283 | $unwrap[Int](l$total_liquidity@936@01) - $unwrap[Int](l$amount@838@01) < 0]
(assert (< (- ($unwrap<Int> l$total_liquidity@936@01) ($unwrap<Int> l$amount@838@01)) 0))
(pop) ; 19
(pop) ; 18
(pop) ; 17
(push) ; 17
; [else-branch: 277 | $unwrap[Int]($wrap[$Int]($map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@848@01, 4)), $struct_get[Int]($struct_loc[Int](msg@844@01, 0))))) - $unwrap[Int](l$amount@838@01) < 0]
(assert (<
  (-
    ($unwrap<Int> ($wrap<$Int> ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@848@01 4)) ($struct_get<Int> ($struct_loc<Int> msg@844@01 0)))))
    ($unwrap<Int> l$amount@838@01))
  0))
(pop) ; 17
(pop) ; 16
(push) ; 16
; [else-branch: 273 | !($unwrap[Int](l$eth_amount@1018@01) >= $unwrap[Int](l$min_eth@839@01) && $unwrap[Int](l$token_amount@1021@01) >= $unwrap[Int](l$min_tokens@840@01))]
(assert (not
  (and
    (>= ($unwrap<Int> l$eth_amount@1018@01) ($unwrap<Int> l$min_eth@839@01))
    (>= ($unwrap<Int> l$token_amount@1021@01) ($unwrap<Int> l$min_tokens@840@01)))))
(pop) ; 16
(pop) ; 15
(pop) ; 14
(pop) ; 13
(pop) ; 12
(push) ; 12
; [else-branch: 256 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, l$token_reserve@1015@01)) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 l$token_reserve@1015@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
(push) ; 7
; [else-branch: 239 | $unwrap[Int]($w_mul[$Int](l$amount@838@01, $wrap[$Int]($struct_get[Int]($struct_loc[Int](self@848@01, 8))))) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  ($unwrap<Int> ($w_mul<$Int> l$amount@838@01 ($wrap<$Int> ($struct_get<Int> ($struct_loc<Int> self@848@01 8)))))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 7
(pop) ; 6
(pop) ; 5
(push) ; 5
; [else-branch: 233 | l$send_fail@858@01]
(assert l$send_fail@858@01)
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 229 | !($unwrap[Int](l$total_liquidity@936@01) > 0)]
(assert (not (> ($unwrap<Int> l$total_liquidity@936@01) 0)))
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 225 | !($unwrap[Int](l$amount@838@01) > 0 && $unwrap[Int](l$deadline@841@01) > $struct_get[Int]($struct_loc[Int](block@845@01, 4)) && $unwrap[Int](l$min_eth@839@01) > 0 && $unwrap[Int](l$min_tokens@840@01) > 0)]
(assert (not
  (and
    (> ($unwrap<Int> l$amount@838@01) 0)
    (and
      (>
        ($unwrap<Int> l$deadline@841@01)
        ($struct_get<Int> ($struct_loc<Int> block@845@01 4)))
      (and
        (> ($unwrap<Int> l$min_eth@839@01) 0)
        (> ($unwrap<Int> l$min_tokens@840@01) 0))))))
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- f$__default__ ----------
(declare-const $succ@1354@01 Bool)
(declare-const $succ@1355@01 Bool)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var msg: $Struct
(declare-const msg@1356@01 $Struct)
; [exec]
; var block: $Struct
(declare-const block@1357@01 $Struct)
; [exec]
; var chain: $Struct
(declare-const chain@1358@01 $Struct)
; [exec]
; var tx: $Struct
(declare-const tx@1359@01 $Struct)
; [exec]
; var self: $Struct
(declare-const self@1360@01 $Struct)
; [exec]
; var $contracts: $Map[Int, $Struct]
(declare-const $contracts@1361@01 $Map<Int~_$Struct>)
; [exec]
; var $old_self: $Struct
(declare-const $old_self@1362@01 $Struct)
; [exec]
; var $old_$contracts: $Map[Int, $Struct]
(declare-const $old_$contracts@1363@01 $Map<Int~_$Struct>)
; [exec]
; var $pre_self: $Struct
(declare-const $pre_self@1364@01 $Struct)
; [exec]
; var $pre_$contracts: $Map[Int, $Struct]
(declare-const $pre_$contracts@1365@01 $Map<Int~_$Struct>)
; [exec]
; var $issued_self: $Struct
(declare-const $issued_self@1366@01 $Struct)
; [exec]
; var $issued_$contracts: $Map[Int, $Struct]
(declare-const $issued_$contracts@1367@01 $Map<Int~_$Struct>)
; [exec]
; var $overflow: Bool
(declare-const $overflow@1368@01 Bool)
; [exec]
; var l$i0$eth_sold: Int
(declare-const l$i0$eth_sold@1369@01 Int)
; [exec]
; var l$i0$min_tokens: Int
(declare-const l$i0$min_tokens@1370@01 Int)
; [exec]
; var l$i0$deadline: Int
(declare-const l$i0$deadline@1371@01 Int)
; [exec]
; var l$i0$buyer: Int
(declare-const l$i0$buyer@1372@01 Int)
; [exec]
; var l$i0$recipient: Int
(declare-const l$i0$recipient@1373@01 Int)
; [exec]
; var i0$$res: Int
(declare-const i0$$res@1374@01 Int)
; [exec]
; var i0$$pre_self: $Struct
(declare-const i0$$pre_self@1375@01 $Struct)
; [exec]
; var i0$$pre_$contracts: $Map[Int, $Struct]
(declare-const i0$$pre_$contracts@1376@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$send_fail: Bool
(declare-const l$i0$send_fail@1377@01 Bool)
; [exec]
; var l$i0$raw_ret: Int
(declare-const l$i0$raw_ret@1378@01 Int)
; [exec]
; var l$i0$token_reserve: $Int
(declare-const l$i0$token_reserve@1379@01 $Int)
; [exec]
; var l$i2$input_amount: Int
(declare-const l$i2$input_amount@1380@01 Int)
; [exec]
; var l$i2$input_reserve: Int
(declare-const l$i2$input_reserve@1381@01 Int)
; [exec]
; var l$i2$output_reserve: $Int
(declare-const l$i2$output_reserve@1382@01 $Int)
; [exec]
; var i2$$res: Int
(declare-const i2$$res@1383@01 Int)
; [exec]
; var l$i2$input_amount_with_fee: Int
(declare-const l$i2$input_amount_with_fee@1384@01 Int)
; [exec]
; var l$i2$numerator: $Int
(declare-const l$i2$numerator@1385@01 $Int)
; [exec]
; var l$i2$denominator: Int
(declare-const l$i2$denominator@1386@01 Int)
; [exec]
; var l$i0$tokens_bought: $Int
(declare-const l$i0$tokens_bought@1387@01 $Int)
; [exec]
; var l$i0$havoc: $Map[Int, $Struct]
(declare-const l$i0$havoc@1388@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$send_fail$1: Bool
(declare-const l$i0$send_fail$1@1389@01 Bool)
; [exec]
; var l$i0$raw_ret$1: Bool
(declare-const l$i0$raw_ret$1@1390@01 Bool)
; [exec]
; var i3$$pre_self: $Struct
(declare-const i3$$pre_self@1391@01 $Struct)
; [exec]
; var i3$$pre_$contracts: $Map[Int, $Struct]
(declare-const i3$$pre_$contracts@1392@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$havoc$1: $Map[Int, $Struct]
(declare-const l$i0$havoc$1@1393@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$havoc$2: $Struct
(declare-const l$i0$havoc$2@1394@01 $Struct)
; [exec]
; var l$i0$havoc$3: $Map[Int, $Struct]
(declare-const l$i0$havoc$3@1395@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$no_reentrant_call: Bool
(declare-const l$i0$no_reentrant_call@1396@01 Bool)
; [exec]
; var l$i0$havoc$4: $Map[Int, $Struct]
(declare-const l$i0$havoc$4@1397@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$havoc$5: $Map[Int, $Struct]
(declare-const l$i0$havoc$5@1398@01 $Map<Int~_$Struct>)
; [exec]
; var $out_of_gas: Bool
(declare-const $out_of_gas@1399@01 Bool)
; [exec]
; var l$havoc: Int
(declare-const l$havoc@1400@01 Int)
; [exec]
; var l$havoc$1: $Map[Int, $Struct]
(declare-const l$havoc$1@1401@01 $Map<Int~_$Struct>)
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@1402@01 $Snap)
(assert (= $t@1402@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@1360@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@1403@01 $Snap)
(assert (= $t@1403@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@1360@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1404@01 $Snap)
(assert (= $t@1404@01 ($Snap.combine ($Snap.first $t@1404@01) ($Snap.second $t@1404@01))))
(assert (= ($Snap.first $t@1404@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1360@01 2))))
(assert (= ($Snap.second $t@1404@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1360@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1405@01 $Snap)
(assert (= $t@1405@01 ($Snap.combine ($Snap.first $t@1405@01) ($Snap.second $t@1405@01))))
(assert (= ($Snap.first $t@1405@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1360@01 3))))
(assert (= ($Snap.second $t@1405@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1360@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1406@01 $Snap)
(assert (= $t@1406@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@1407@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 4
; [then-branch: 360 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 4)), $q2@1407@01)) | live]
; [else-branch: 360 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 4)), $q2@1407@01) | live]
(push) ; 5
; [then-branch: 360 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 4)), $q2@1407@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1407@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 360 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 4)), $q2@1407@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1407@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1407@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1407@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1407@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1407@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1407@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1407@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1877@11@1877@345-aux|)))
(assert (forall (($q2@1407@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1407@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1407@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1407@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1877@11@1877@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@1408@01 $Snap)
(assert (= $t@1408@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@1409@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1409@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1409@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 4)) $q2@1409@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1878@11@1878@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@1410@01 $Snap)
(assert (= $t@1410@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@1411@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@1412@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 5
; [then-branch: 361 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1360@01, 5)), $q3@1411@01), $q4@1412@01)) | live]
; [else-branch: 361 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1360@01, 5)), $q3@1411@01), $q4@1412@01) | live]
(push) ; 6
; [then-branch: 361 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1360@01, 5)), $q3@1411@01), $q4@1412@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 361 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1360@01, 5)), $q3@1411@01), $q4@1412@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@1412@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1879@131@1879@597-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1411@01 Int)) (!
  (forall (($q4@1412@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1879@131@1879@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1879@11@1879@598-aux|)))
(assert (forall (($q3@1411@01 Int)) (!
  (forall (($q4@1412@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01) $q4@1412@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1879@131@1879@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1411@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1879@11@1879@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@1413@01 $Snap)
(assert (= $t@1413@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@1414@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@1415@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1414@01 Int)) (!
  (forall (($q4@1415@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1414@01) $q4@1415@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1414@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1414@01) $q4@1415@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1880@131@1880@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1360@01 5)) $q3@1414@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1880@11@1880@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1416@01 $Snap)
(assert (= $t@1416@01 ($Snap.combine ($Snap.first $t@1416@01) ($Snap.second $t@1416@01))))
(assert (= ($Snap.first $t@1416@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1360@01 6))))
(assert (= ($Snap.second $t@1416@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1360@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1417@01 $Snap)
(assert (= $t@1417@01 ($Snap.combine ($Snap.first $t@1417@01) ($Snap.second $t@1417@01))))
(assert (= ($Snap.first $t@1417@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1360@01 7))))
(assert (= ($Snap.second $t@1417@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1360@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1418@01 $Snap)
(assert (= $t@1418@01 ($Snap.combine ($Snap.first $t@1418@01) ($Snap.second $t@1418@01))))
(assert (= ($Snap.first $t@1418@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))))
(assert (= ($Snap.second $t@1418@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@1419@01 $Snap)
(assert (= $t@1419@01 ($Snap.combine ($Snap.first $t@1419@01) ($Snap.second $t@1419@01))))
(assert (= ($Snap.first $t@1419@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> self@1360@01 9))))
(assert (= ($Snap.second $t@1419@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1360@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1420@01 $Snap)
(assert (= $t@1420@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@1421@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 4
; [then-branch: 362 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 11)), $q5@1421@01)) | live]
; [else-branch: 362 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 11)), $q5@1421@01) | live]
(push) ; 5
; [then-branch: 362 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 11)), $q5@1421@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1421@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 362 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 11)), $q5@1421@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1421@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1421@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1421@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1421@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1421@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1421@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1421@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1885@11@1885@348-aux|)))
(assert (forall (($q5@1421@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1421@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1421@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1421@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1885@11@1885@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@1422@01 $Snap)
(assert (= $t@1422@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@1423@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1423@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1423@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 11)) $q5@1423@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1886@11@1886@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1424@01 $Snap)
(assert (= $t@1424@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@1425@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 4
; [then-branch: 363 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 12)), $q6@1425@01)) | live]
; [else-branch: 363 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 12)), $q6@1425@01) | live]
(push) ; 5
; [then-branch: 363 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 12)), $q6@1425@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1425@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 363 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1360@01, 12)), $q6@1425@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1425@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1425@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1425@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1425@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1425@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1425@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1425@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1887@11@1887@348-aux|)))
(assert (forall (($q6@1425@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1425@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1425@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1425@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1887@11@1887@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@1426@01 $Snap)
(assert (= $t@1426@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@1427@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1427@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1427@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1360@01 12)) $q6@1427@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@1888@11@1888@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@1428@01 $Snap)
(assert (= $t@1428@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> self@1360@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $self_address() &&
;   $self_address() <= 1461501637330902918203684832716283019655932542975
(declare-const $t@1429@01 $Snap)
(assert (= $t@1429@01 ($Snap.combine ($Snap.first $t@1429@01) ($Snap.second $t@1429@01))))
(assert (= ($Snap.first $t@1429@01) $Snap.unit))
; [eval] 0 <= $self_address()
; [eval] $self_address()
(assert (<= 0 (as $self_address<Int>  Int)))
(assert (= ($Snap.second $t@1429@01) $Snap.unit))
; [eval] $self_address() <= 1461501637330902918203684832716283019655932542975
; [eval] $self_address()
(assert (<=
  (as $self_address<Int>  Int)
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) &&
;   ($struct_get($struct_loc(block, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1430@01 $Snap)
(assert (= $t@1430@01 ($Snap.combine ($Snap.first $t@1430@01) ($Snap.second $t@1430@01))))
(assert (= ($Snap.first $t@1430@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 0)): Int)
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1357@01 0))))
(assert (= ($Snap.second $t@1430@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1357@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) &&
;   ($struct_get($struct_loc(block, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1431@01 $Snap)
(assert (= $t@1431@01 ($Snap.combine ($Snap.first $t@1431@01) ($Snap.second $t@1431@01))))
(assert (= ($Snap.first $t@1431@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 1)): Int)
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1357@01 1))))
(assert (= ($Snap.second $t@1431@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1357@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) &&
;   ($struct_get($struct_loc(block, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1432@01 $Snap)
(assert (= $t@1432@01 ($Snap.combine ($Snap.first $t@1432@01) ($Snap.second $t@1432@01))))
(assert (= ($Snap.first $t@1432@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 2)): Int)
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1357@01 2))))
(assert (= ($Snap.second $t@1432@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1357@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
(declare-const $t@1433@01 $Snap)
(assert (= $t@1433@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])|
; [eval] ($struct_get($struct_loc(block, 3)): Seq[Int])
; [eval] $struct_loc(block, 3)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> block@1357@01 3))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) &&
;   ($struct_get($struct_loc(block, 4)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1434@01 $Snap)
(assert (= $t@1434@01 ($Snap.combine ($Snap.first $t@1434@01) ($Snap.second $t@1434@01))))
(assert (= ($Snap.first $t@1434@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1357@01 4))))
(assert (= ($Snap.second $t@1434@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1357@01 4))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(block, -1)): Int) ==
;   2335365049822495359383864865678187
(declare-const $t@1435@01 $Snap)
(assert (= $t@1435@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
; [eval] ($struct_get($struct_loc(block, -1)): Int)
; [eval] $struct_loc(block, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> block@1357@01 (- 0 1)))
  2335365049822495359383864865678187))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) &&
;   ($struct_get($struct_loc(msg, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1436@01 $Snap)
(assert (= $t@1436@01 ($Snap.combine ($Snap.first $t@1436@01) ($Snap.second $t@1436@01))))
(assert (= ($Snap.first $t@1436@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@1356@01 0))))
(assert (= ($Snap.second $t@1436@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@1356@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) &&
;   ($struct_get($struct_loc(msg, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1437@01 $Snap)
(assert (= $t@1437@01 ($Snap.combine ($Snap.first $t@1437@01) ($Snap.second $t@1437@01))))
(assert (= ($Snap.first $t@1437@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@1356@01 1))))
(assert (= ($Snap.second $t@1437@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@1356@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) &&
;   ($struct_get($struct_loc(msg, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1438@01 $Snap)
(assert (= $t@1438@01 ($Snap.combine ($Snap.first $t@1438@01) ($Snap.second $t@1438@01))))
(assert (= ($Snap.first $t@1438@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 2)): Int)
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@1356@01 2))))
(assert (= ($Snap.second $t@1438@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@1356@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, -1)): Int) ==
;   35634842679176259756224246631
(declare-const $t@1439@01 $Snap)
(assert (= $t@1439@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
; [eval] ($struct_get($struct_loc(msg, -1)): Int)
; [eval] $struct_loc(msg, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> msg@1356@01 (- 0 1)))
  35634842679176259756224246631))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
(declare-const $t@1440@01 $Snap)
(assert (= $t@1440@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) != 0
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (not (= ($struct_get<Int> ($struct_loc<Int> msg@1356@01 0)) 0)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@1441@01 $Snap)
(assert (= $t@1441@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@1442@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; $pre_self := self
; [exec]
; $pre_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $succ := true
; [exec]
; $overflow := false
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const self@1443@01 $Struct)
(assert (=
  self@1443@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    ($struct_get<Int> ($struct_loc<Int> msg@1356@01 1))))))
; [exec]
; self := ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]),
;   ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self,
;   12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) +
;   ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
; [eval] ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
; [eval] ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const self@1444@01 $Struct)
(assert (=
  self@1444@01
  ($struct_set<$Struct> self@1443@01 12 ($map_set<$Map<Int~_Int>> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1443@01 12)) ($struct_get<Int> ($struct_loc<Int> msg@1356@01 0)) (+
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1443@01 12)) ($struct_get<Int> ($struct_loc<Int> msg@1356@01 0)))
    ($struct_get<Int> ($struct_loc<Int> msg@1356@01 1)))))))
; [exec]
; i0$$pre_self := self
; [exec]
; i0$$pre_$contracts := $contracts
; [exec]
; l$i0$eth_sold := ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const l$i0$eth_sold@1445@01 Int)
(assert (= l$i0$eth_sold@1445@01 ($struct_get<Int> ($struct_loc<Int> msg@1356@01 1))))
; [exec]
; l$i0$min_tokens := 1
; [exec]
; l$i0$deadline := ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(declare-const l$i0$deadline@1446@01 Int)
(assert (= l$i0$deadline@1446@01 ($struct_get<Int> ($struct_loc<Int> block@1357@01 4))))
; [exec]
; l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(declare-const l$i0$buyer@1447@01 Int)
(assert (= l$i0$buyer@1447@01 ($struct_get<Int> ($struct_loc<Int> msg@1356@01 0))))
; [exec]
; l$i0$recipient := ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(declare-const l$i0$recipient@1448@01 Int)
(assert (= l$i0$recipient@1448@01 ($struct_get<Int> ($struct_loc<Int> msg@1356@01 0))))
; [eval] !(l$i0$deadline >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && l$i0$min_tokens > 0))
; [eval] l$i0$deadline >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && l$i0$min_tokens > 0)
; [eval] l$i0$deadline >= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(set-option :timeout 0)
(push) ; 3
; [then-branch: 364 | !(l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4))) | live]
; [else-branch: 364 | l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)) | live]
(push) ; 4
; [then-branch: 364 | !(l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)))]
(assert (not
  (>=
    l$i0$deadline@1446@01
    ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))))
(pop) ; 4
(push) ; 4
; [else-branch: 364 | l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4))]
(assert (>= l$i0$deadline@1446@01 ($struct_get<Int> ($struct_loc<Int> block@1357@01 4))))
; [eval] l$i0$eth_sold > 0
(push) ; 5
; [then-branch: 365 | !(l$i0$eth_sold@1445@01 > 0) | live]
; [else-branch: 365 | l$i0$eth_sold@1445@01 > 0 | live]
(push) ; 6
; [then-branch: 365 | !(l$i0$eth_sold@1445@01 > 0)]
(assert (not (> l$i0$eth_sold@1445@01 0)))
(pop) ; 6
(push) ; 6
; [else-branch: 365 | l$i0$eth_sold@1445@01 > 0]
(assert (> l$i0$eth_sold@1445@01 0))
; [eval] l$i0$min_tokens > 0
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (> l$i0$eth_sold@1445@01 0) (not (> l$i0$eth_sold@1445@01 0))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  (>=
    l$i0$deadline@1446@01
    ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
  (and
    (>=
      l$i0$deadline@1446@01
      ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
    (or (> l$i0$eth_sold@1445@01 0) (not (> l$i0$eth_sold@1445@01 0))))))
(assert (or
  (>=
    l$i0$deadline@1446@01
    ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
  (not
    (>=
      l$i0$deadline@1446@01
      ($struct_get<Int> ($struct_loc<Int> block@1357@01 4))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (>=
    l$i0$deadline@1446@01
    ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
  (> l$i0$eth_sold@1445@01 0))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (>=
      l$i0$deadline@1446@01
      ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
    (> l$i0$eth_sold@1445@01 0)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 366 | !(l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)) && l$i0$eth_sold@1445@01 > 0) | live]
; [else-branch: 366 | l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)) && l$i0$eth_sold@1445@01 > 0 | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 366 | !(l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)) && l$i0$eth_sold@1445@01 > 0)]
(assert (not
  (and
    (>=
      l$i0$deadline@1446@01
      ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
    (> l$i0$eth_sold@1445@01 0))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 367 | True | live]
; [else-branch: 367 | False | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 367 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1449@01 $Snap)
(assert (= $t@1449@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1450@01 $Struct)
(assert (=
  self@1450@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 4
; [then-branch: 368 | False | dead]
; [else-branch: 368 | True | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 368 | True]
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 366 | l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)) && l$i0$eth_sold@1445@01 > 0]
(assert (and
  (>=
    l$i0$deadline@1446@01
    ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
  (> l$i0$eth_sold@1445@01 0)))
(pop) ; 3
; [eval] !!(l$i0$deadline >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && l$i0$min_tokens > 0))
; [eval] !(l$i0$deadline >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && l$i0$min_tokens > 0))
; [eval] l$i0$deadline >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && l$i0$min_tokens > 0)
; [eval] l$i0$deadline >= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(push) ; 3
; [then-branch: 369 | !(l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4))) | live]
; [else-branch: 369 | l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)) | live]
(push) ; 4
; [then-branch: 369 | !(l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)))]
(assert (not
  (>=
    l$i0$deadline@1446@01
    ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))))
(pop) ; 4
(push) ; 4
; [else-branch: 369 | l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4))]
(assert (>= l$i0$deadline@1446@01 ($struct_get<Int> ($struct_loc<Int> block@1357@01 4))))
; [eval] l$i0$eth_sold > 0
(push) ; 5
; [then-branch: 370 | !(l$i0$eth_sold@1445@01 > 0) | live]
; [else-branch: 370 | l$i0$eth_sold@1445@01 > 0 | live]
(push) ; 6
; [then-branch: 370 | !(l$i0$eth_sold@1445@01 > 0)]
(assert (not (> l$i0$eth_sold@1445@01 0)))
(pop) ; 6
(push) ; 6
; [else-branch: 370 | l$i0$eth_sold@1445@01 > 0]
(assert (> l$i0$eth_sold@1445@01 0))
; [eval] l$i0$min_tokens > 0
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (> l$i0$eth_sold@1445@01 0) (not (> l$i0$eth_sold@1445@01 0))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (>=
      l$i0$deadline@1446@01
      ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
    (> l$i0$eth_sold@1445@01 0)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (>=
    l$i0$deadline@1446@01
    ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
  (> l$i0$eth_sold@1445@01 0))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 371 | l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)) && l$i0$eth_sold@1445@01 > 0 | live]
; [else-branch: 371 | !(l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)) && l$i0$eth_sold@1445@01 > 0) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 371 | l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)) && l$i0$eth_sold@1445@01 > 0]
(assert (and
  (>=
    l$i0$deadline@1446@01
    ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
  (> l$i0$eth_sold@1445@01 0)))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1451@01 Int)
(declare-const $arg1@1452@01 Int)
(declare-const $arg2@1453@01 Int)
(push) ; 4
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
(declare-const sm@1454@01 $PSF<e$TokenPurchase>)
(declare-const s@1455@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1456@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef115|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef116|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1451@01)
    ($SortWrappers.IntTo$Snap $arg1@1452@01))
  ($SortWrappers.IntTo$Snap $arg2@1453@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1451@01)
    ($SortWrappers.IntTo$Snap $arg1@1452@01))
  ($SortWrappers.IntTo$Snap $arg2@1453@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1451@01)
      ($SortWrappers.IntTo$Snap $arg1@1452@01))
    ($SortWrappers.IntTo$Snap $arg2@1453@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1457@01 (Int Int Int) Int)
(declare-fun img@1458@01 (Int Int Int) Bool)
(declare-fun inv@1459@01 (Int Int Int) Int)
(declare-fun img@1460@01 (Int Int Int) Bool)
(declare-fun inv@1461@01 (Int Int Int) Int)
(declare-fun img@1462@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef115|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef116|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1451@01 Int) ($arg1@1452@01 Int) ($arg2@1453@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1451@01)
          ($SortWrappers.IntTo$Snap $arg1@1452@01))
        ($SortWrappers.IntTo$Snap $arg2@1453@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1451@01)
        ($SortWrappers.IntTo$Snap $arg1@1452@01))
      ($SortWrappers.IntTo$Snap $arg2@1453@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1451@01)
        ($SortWrappers.IntTo$Snap $arg1@1452@01))
      ($SortWrappers.IntTo$Snap $arg2@1453@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1451@01)
      ($SortWrappers.IntTo$Snap $arg1@1452@01))
    ($SortWrappers.IntTo$Snap $arg2@1453@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1451@01)
      ($SortWrappers.IntTo$Snap $arg1@1452@01))
    ($SortWrappers.IntTo$Snap $arg2@1453@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1451@01 Int) ($arg1@1452@01 Int) ($arg2@1453@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1451@01)
          ($SortWrappers.IntTo$Snap $arg1@1452@01))
        ($SortWrappers.IntTo$Snap $arg2@1453@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1451@01)
            ($SortWrappers.IntTo$Snap $arg1@1452@01))
          ($SortWrappers.IntTo$Snap $arg2@1453@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1451@01)
            ($SortWrappers.IntTo$Snap $arg1@1452@01))
          ($SortWrappers.IntTo$Snap $arg2@1453@01))))))
  
  :qid |quant-u-1753|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1451@01 Int) ($arg11@1452@01 Int) ($arg21@1453@01 Int) ($arg02@1451@01 Int) ($arg12@1452@01 Int) ($arg22@1453@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1451@01)
                ($SortWrappers.IntTo$Snap $arg11@1452@01))
              ($SortWrappers.IntTo$Snap $arg21@1453@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1451@01)
              ($SortWrappers.IntTo$Snap $arg11@1452@01))
            ($SortWrappers.IntTo$Snap $arg21@1453@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1451@01)
              ($SortWrappers.IntTo$Snap $arg11@1452@01))
            ($SortWrappers.IntTo$Snap $arg21@1453@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1451@01)
              ($SortWrappers.IntTo$Snap $arg11@1452@01))
            ($SortWrappers.IntTo$Snap $arg21@1453@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1451@01)
                ($SortWrappers.IntTo$Snap $arg12@1452@01))
              ($SortWrappers.IntTo$Snap $arg22@1453@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1451@01)
              ($SortWrappers.IntTo$Snap $arg12@1452@01))
            ($SortWrappers.IntTo$Snap $arg22@1453@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1451@01)
              ($SortWrappers.IntTo$Snap $arg12@1452@01))
            ($SortWrappers.IntTo$Snap $arg22@1453@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1451@01)
              ($SortWrappers.IntTo$Snap $arg12@1452@01))
            ($SortWrappers.IntTo$Snap $arg22@1453@01)))))
      (and
        (and (= $arg01@1451@01 $arg02@1451@01) (= $arg11@1452@01 $arg12@1452@01))
        (= $arg21@1453@01 $arg22@1453@01)))
    (and
      (and (= $arg01@1451@01 $arg02@1451@01) (= $arg11@1452@01 $arg12@1452@01))
      (= $arg21@1453@01 $arg22@1453@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1451@01 Int) ($arg1@1452@01 Int) ($arg2@1453@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1451@01)
            ($SortWrappers.IntTo$Snap $arg1@1452@01))
          ($SortWrappers.IntTo$Snap $arg2@1453@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1451@01)
            ($SortWrappers.IntTo$Snap $arg1@1452@01))
          ($SortWrappers.IntTo$Snap $arg2@1453@01)))))
    (and
      (and
        (= (inv@1457@01 $arg0@1451@01 $arg1@1452@01 $arg2@1453@01) $arg0@1451@01)
        (= (inv@1459@01 $arg0@1451@01 $arg1@1452@01 $arg2@1453@01) $arg1@1452@01)
        (= (inv@1461@01 $arg0@1451@01 $arg1@1452@01 $arg2@1453@01) $arg2@1453@01))
      (and
        (img@1458@01 $arg0@1451@01 $arg1@1452@01 $arg2@1453@01)
        (img@1460@01 $arg0@1451@01 $arg1@1452@01 $arg2@1453@01)
        (img@1462@01 $arg0@1451@01 $arg1@1452@01 $arg2@1453@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1451@01)
      ($SortWrappers.IntTo$Snap $arg1@1452@01))
    ($SortWrappers.IntTo$Snap $arg2@1453@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1451@01)
      ($SortWrappers.IntTo$Snap $arg1@1452@01))
    ($SortWrappers.IntTo$Snap $arg2@1453@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1458@01 $arg0 $arg1 $arg2)
        (img@1460@01 $arg0 $arg1 $arg2)
        (img@1462@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1457@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1459@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1461@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1457@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1459@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1461@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1457@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1459@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1461@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1457@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1459@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1461@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1457@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1459@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1461@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1457@01 $arg0 $arg1 $arg2) (inv@1459@01 $arg0 $arg1 $arg2) (inv@1461@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1754|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1457@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1459@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1461@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1458@01 $arg0 $arg1 $arg2)
        (img@1460@01 $arg0 $arg1 $arg2)
        (img@1462@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1457@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1459@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1461@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@1456@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1457@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1459@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1461@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1755|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1463@01 Int)
(declare-const $arg1@1464@01 Int)
(declare-const $arg2@1465@01 Int)
(push) ; 4
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
(declare-const sm@1466@01 $PSF<e$EthPurchase>)
(declare-const s@1467@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1468@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef118|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef119|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1463@01)
    ($SortWrappers.IntTo$Snap $arg1@1464@01))
  ($SortWrappers.IntTo$Snap $arg2@1465@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1463@01)
    ($SortWrappers.IntTo$Snap $arg1@1464@01))
  ($SortWrappers.IntTo$Snap $arg2@1465@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1463@01)
      ($SortWrappers.IntTo$Snap $arg1@1464@01))
    ($SortWrappers.IntTo$Snap $arg2@1465@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1469@01 (Int Int Int) Int)
(declare-fun img@1470@01 (Int Int Int) Bool)
(declare-fun inv@1471@01 (Int Int Int) Int)
(declare-fun img@1472@01 (Int Int Int) Bool)
(declare-fun inv@1473@01 (Int Int Int) Int)
(declare-fun img@1474@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef118|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef119|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1463@01 Int) ($arg1@1464@01 Int) ($arg2@1465@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1463@01)
          ($SortWrappers.IntTo$Snap $arg1@1464@01))
        ($SortWrappers.IntTo$Snap $arg2@1465@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1463@01)
        ($SortWrappers.IntTo$Snap $arg1@1464@01))
      ($SortWrappers.IntTo$Snap $arg2@1465@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1463@01)
        ($SortWrappers.IntTo$Snap $arg1@1464@01))
      ($SortWrappers.IntTo$Snap $arg2@1465@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1463@01)
      ($SortWrappers.IntTo$Snap $arg1@1464@01))
    ($SortWrappers.IntTo$Snap $arg2@1465@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1463@01)
      ($SortWrappers.IntTo$Snap $arg1@1464@01))
    ($SortWrappers.IntTo$Snap $arg2@1465@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1463@01 Int) ($arg1@1464@01 Int) ($arg2@1465@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1463@01)
          ($SortWrappers.IntTo$Snap $arg1@1464@01))
        ($SortWrappers.IntTo$Snap $arg2@1465@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1463@01)
            ($SortWrappers.IntTo$Snap $arg1@1464@01))
          ($SortWrappers.IntTo$Snap $arg2@1465@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1463@01)
            ($SortWrappers.IntTo$Snap $arg1@1464@01))
          ($SortWrappers.IntTo$Snap $arg2@1465@01))))))
  
  :qid |quant-u-1756|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1463@01 Int) ($arg11@1464@01 Int) ($arg21@1465@01 Int) ($arg02@1463@01 Int) ($arg12@1464@01 Int) ($arg22@1465@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1463@01)
                ($SortWrappers.IntTo$Snap $arg11@1464@01))
              ($SortWrappers.IntTo$Snap $arg21@1465@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1463@01)
              ($SortWrappers.IntTo$Snap $arg11@1464@01))
            ($SortWrappers.IntTo$Snap $arg21@1465@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1463@01)
              ($SortWrappers.IntTo$Snap $arg11@1464@01))
            ($SortWrappers.IntTo$Snap $arg21@1465@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1463@01)
              ($SortWrappers.IntTo$Snap $arg11@1464@01))
            ($SortWrappers.IntTo$Snap $arg21@1465@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1463@01)
                ($SortWrappers.IntTo$Snap $arg12@1464@01))
              ($SortWrappers.IntTo$Snap $arg22@1465@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1463@01)
              ($SortWrappers.IntTo$Snap $arg12@1464@01))
            ($SortWrappers.IntTo$Snap $arg22@1465@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1463@01)
              ($SortWrappers.IntTo$Snap $arg12@1464@01))
            ($SortWrappers.IntTo$Snap $arg22@1465@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1463@01)
              ($SortWrappers.IntTo$Snap $arg12@1464@01))
            ($SortWrappers.IntTo$Snap $arg22@1465@01)))))
      (and
        (and (= $arg01@1463@01 $arg02@1463@01) (= $arg11@1464@01 $arg12@1464@01))
        (= $arg21@1465@01 $arg22@1465@01)))
    (and
      (and (= $arg01@1463@01 $arg02@1463@01) (= $arg11@1464@01 $arg12@1464@01))
      (= $arg21@1465@01 $arg22@1465@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1463@01 Int) ($arg1@1464@01 Int) ($arg2@1465@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1463@01)
            ($SortWrappers.IntTo$Snap $arg1@1464@01))
          ($SortWrappers.IntTo$Snap $arg2@1465@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1463@01)
            ($SortWrappers.IntTo$Snap $arg1@1464@01))
          ($SortWrappers.IntTo$Snap $arg2@1465@01)))))
    (and
      (and
        (= (inv@1469@01 $arg0@1463@01 $arg1@1464@01 $arg2@1465@01) $arg0@1463@01)
        (= (inv@1471@01 $arg0@1463@01 $arg1@1464@01 $arg2@1465@01) $arg1@1464@01)
        (= (inv@1473@01 $arg0@1463@01 $arg1@1464@01 $arg2@1465@01) $arg2@1465@01))
      (and
        (img@1470@01 $arg0@1463@01 $arg1@1464@01 $arg2@1465@01)
        (img@1472@01 $arg0@1463@01 $arg1@1464@01 $arg2@1465@01)
        (img@1474@01 $arg0@1463@01 $arg1@1464@01 $arg2@1465@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1463@01)
      ($SortWrappers.IntTo$Snap $arg1@1464@01))
    ($SortWrappers.IntTo$Snap $arg2@1465@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1463@01)
      ($SortWrappers.IntTo$Snap $arg1@1464@01))
    ($SortWrappers.IntTo$Snap $arg2@1465@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1470@01 $arg0 $arg1 $arg2)
        (img@1472@01 $arg0 $arg1 $arg2)
        (img@1474@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1469@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1471@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1473@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1469@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1471@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1473@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1469@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1471@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1473@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1469@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1471@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1473@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1469@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1471@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1473@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1469@01 $arg0 $arg1 $arg2) (inv@1471@01 $arg0 $arg1 $arg2) (inv@1473@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1757|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1469@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1471@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1473@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1470@01 $arg0 $arg1 $arg2)
        (img@1472@01 $arg0 $arg1 $arg2)
        (img@1474@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1469@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1471@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1473@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@1468@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1469@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1471@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1473@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1758|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1475@01 Int)
(declare-const $arg1@1476@01 Int)
(declare-const $arg2@1477@01 Int)
(push) ; 4
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
(declare-const sm@1478@01 $PSF<e$AddLiquidity>)
(declare-const s@1479@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1480@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef121|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef122|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1475@01)
    ($SortWrappers.IntTo$Snap $arg1@1476@01))
  ($SortWrappers.IntTo$Snap $arg2@1477@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1475@01)
    ($SortWrappers.IntTo$Snap $arg1@1476@01))
  ($SortWrappers.IntTo$Snap $arg2@1477@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1475@01)
      ($SortWrappers.IntTo$Snap $arg1@1476@01))
    ($SortWrappers.IntTo$Snap $arg2@1477@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1481@01 (Int Int Int) Int)
(declare-fun img@1482@01 (Int Int Int) Bool)
(declare-fun inv@1483@01 (Int Int Int) Int)
(declare-fun img@1484@01 (Int Int Int) Bool)
(declare-fun inv@1485@01 (Int Int Int) Int)
(declare-fun img@1486@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef121|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef122|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1475@01 Int) ($arg1@1476@01 Int) ($arg2@1477@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1475@01)
          ($SortWrappers.IntTo$Snap $arg1@1476@01))
        ($SortWrappers.IntTo$Snap $arg2@1477@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1475@01)
        ($SortWrappers.IntTo$Snap $arg1@1476@01))
      ($SortWrappers.IntTo$Snap $arg2@1477@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1475@01)
        ($SortWrappers.IntTo$Snap $arg1@1476@01))
      ($SortWrappers.IntTo$Snap $arg2@1477@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1475@01)
      ($SortWrappers.IntTo$Snap $arg1@1476@01))
    ($SortWrappers.IntTo$Snap $arg2@1477@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1475@01)
      ($SortWrappers.IntTo$Snap $arg1@1476@01))
    ($SortWrappers.IntTo$Snap $arg2@1477@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1475@01 Int) ($arg1@1476@01 Int) ($arg2@1477@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1475@01)
          ($SortWrappers.IntTo$Snap $arg1@1476@01))
        ($SortWrappers.IntTo$Snap $arg2@1477@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1475@01)
            ($SortWrappers.IntTo$Snap $arg1@1476@01))
          ($SortWrappers.IntTo$Snap $arg2@1477@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1475@01)
            ($SortWrappers.IntTo$Snap $arg1@1476@01))
          ($SortWrappers.IntTo$Snap $arg2@1477@01))))))
  
  :qid |quant-u-1759|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1475@01 Int) ($arg11@1476@01 Int) ($arg21@1477@01 Int) ($arg02@1475@01 Int) ($arg12@1476@01 Int) ($arg22@1477@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1475@01)
                ($SortWrappers.IntTo$Snap $arg11@1476@01))
              ($SortWrappers.IntTo$Snap $arg21@1477@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1475@01)
              ($SortWrappers.IntTo$Snap $arg11@1476@01))
            ($SortWrappers.IntTo$Snap $arg21@1477@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1475@01)
              ($SortWrappers.IntTo$Snap $arg11@1476@01))
            ($SortWrappers.IntTo$Snap $arg21@1477@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1475@01)
              ($SortWrappers.IntTo$Snap $arg11@1476@01))
            ($SortWrappers.IntTo$Snap $arg21@1477@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1475@01)
                ($SortWrappers.IntTo$Snap $arg12@1476@01))
              ($SortWrappers.IntTo$Snap $arg22@1477@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1475@01)
              ($SortWrappers.IntTo$Snap $arg12@1476@01))
            ($SortWrappers.IntTo$Snap $arg22@1477@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1475@01)
              ($SortWrappers.IntTo$Snap $arg12@1476@01))
            ($SortWrappers.IntTo$Snap $arg22@1477@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1475@01)
              ($SortWrappers.IntTo$Snap $arg12@1476@01))
            ($SortWrappers.IntTo$Snap $arg22@1477@01)))))
      (and
        (and (= $arg01@1475@01 $arg02@1475@01) (= $arg11@1476@01 $arg12@1476@01))
        (= $arg21@1477@01 $arg22@1477@01)))
    (and
      (and (= $arg01@1475@01 $arg02@1475@01) (= $arg11@1476@01 $arg12@1476@01))
      (= $arg21@1477@01 $arg22@1477@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1475@01 Int) ($arg1@1476@01 Int) ($arg2@1477@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1475@01)
            ($SortWrappers.IntTo$Snap $arg1@1476@01))
          ($SortWrappers.IntTo$Snap $arg2@1477@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1475@01)
            ($SortWrappers.IntTo$Snap $arg1@1476@01))
          ($SortWrappers.IntTo$Snap $arg2@1477@01)))))
    (and
      (and
        (= (inv@1481@01 $arg0@1475@01 $arg1@1476@01 $arg2@1477@01) $arg0@1475@01)
        (= (inv@1483@01 $arg0@1475@01 $arg1@1476@01 $arg2@1477@01) $arg1@1476@01)
        (= (inv@1485@01 $arg0@1475@01 $arg1@1476@01 $arg2@1477@01) $arg2@1477@01))
      (and
        (img@1482@01 $arg0@1475@01 $arg1@1476@01 $arg2@1477@01)
        (img@1484@01 $arg0@1475@01 $arg1@1476@01 $arg2@1477@01)
        (img@1486@01 $arg0@1475@01 $arg1@1476@01 $arg2@1477@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1475@01)
      ($SortWrappers.IntTo$Snap $arg1@1476@01))
    ($SortWrappers.IntTo$Snap $arg2@1477@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1475@01)
      ($SortWrappers.IntTo$Snap $arg1@1476@01))
    ($SortWrappers.IntTo$Snap $arg2@1477@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1482@01 $arg0 $arg1 $arg2)
        (img@1484@01 $arg0 $arg1 $arg2)
        (img@1486@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1481@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1483@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1485@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1481@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1483@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1485@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1481@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1483@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1485@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1481@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1483@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1485@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1481@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1483@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1485@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1481@01 $arg0 $arg1 $arg2) (inv@1483@01 $arg0 $arg1 $arg2) (inv@1485@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1760|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1481@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1483@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1485@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1482@01 $arg0 $arg1 $arg2)
        (img@1484@01 $arg0 $arg1 $arg2)
        (img@1486@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1481@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1483@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1485@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@1480@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1481@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1483@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1485@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1761|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@1487@01 Int)
(declare-const $arg1@1488@01 Int)
(declare-const $arg2@1489@01 Int)
(push) ; 4
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
(declare-const sm@1490@01 $PSF<e$RemoveLiquidity>)
(declare-const s@1491@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1492@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef124|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef125|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1487@01)
    ($SortWrappers.IntTo$Snap $arg1@1488@01))
  ($SortWrappers.IntTo$Snap $arg2@1489@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1487@01)
    ($SortWrappers.IntTo$Snap $arg1@1488@01))
  ($SortWrappers.IntTo$Snap $arg2@1489@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1487@01)
      ($SortWrappers.IntTo$Snap $arg1@1488@01))
    ($SortWrappers.IntTo$Snap $arg2@1489@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1493@01 (Int Int Int) Int)
(declare-fun img@1494@01 (Int Int Int) Bool)
(declare-fun inv@1495@01 (Int Int Int) Int)
(declare-fun img@1496@01 (Int Int Int) Bool)
(declare-fun inv@1497@01 (Int Int Int) Int)
(declare-fun img@1498@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef124|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef125|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1487@01 Int) ($arg1@1488@01 Int) ($arg2@1489@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1487@01)
          ($SortWrappers.IntTo$Snap $arg1@1488@01))
        ($SortWrappers.IntTo$Snap $arg2@1489@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1487@01)
        ($SortWrappers.IntTo$Snap $arg1@1488@01))
      ($SortWrappers.IntTo$Snap $arg2@1489@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1487@01)
        ($SortWrappers.IntTo$Snap $arg1@1488@01))
      ($SortWrappers.IntTo$Snap $arg2@1489@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1487@01)
      ($SortWrappers.IntTo$Snap $arg1@1488@01))
    ($SortWrappers.IntTo$Snap $arg2@1489@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1487@01)
      ($SortWrappers.IntTo$Snap $arg1@1488@01))
    ($SortWrappers.IntTo$Snap $arg2@1489@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1487@01 Int) ($arg1@1488@01 Int) ($arg2@1489@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1487@01)
          ($SortWrappers.IntTo$Snap $arg1@1488@01))
        ($SortWrappers.IntTo$Snap $arg2@1489@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1487@01)
            ($SortWrappers.IntTo$Snap $arg1@1488@01))
          ($SortWrappers.IntTo$Snap $arg2@1489@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1487@01)
            ($SortWrappers.IntTo$Snap $arg1@1488@01))
          ($SortWrappers.IntTo$Snap $arg2@1489@01))))))
  
  :qid |quant-u-1762|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1487@01 Int) ($arg11@1488@01 Int) ($arg21@1489@01 Int) ($arg02@1487@01 Int) ($arg12@1488@01 Int) ($arg22@1489@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1487@01)
                ($SortWrappers.IntTo$Snap $arg11@1488@01))
              ($SortWrappers.IntTo$Snap $arg21@1489@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1487@01)
              ($SortWrappers.IntTo$Snap $arg11@1488@01))
            ($SortWrappers.IntTo$Snap $arg21@1489@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1487@01)
              ($SortWrappers.IntTo$Snap $arg11@1488@01))
            ($SortWrappers.IntTo$Snap $arg21@1489@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1487@01)
              ($SortWrappers.IntTo$Snap $arg11@1488@01))
            ($SortWrappers.IntTo$Snap $arg21@1489@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1487@01)
                ($SortWrappers.IntTo$Snap $arg12@1488@01))
              ($SortWrappers.IntTo$Snap $arg22@1489@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1487@01)
              ($SortWrappers.IntTo$Snap $arg12@1488@01))
            ($SortWrappers.IntTo$Snap $arg22@1489@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1487@01)
              ($SortWrappers.IntTo$Snap $arg12@1488@01))
            ($SortWrappers.IntTo$Snap $arg22@1489@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1487@01)
              ($SortWrappers.IntTo$Snap $arg12@1488@01))
            ($SortWrappers.IntTo$Snap $arg22@1489@01)))))
      (and
        (and (= $arg01@1487@01 $arg02@1487@01) (= $arg11@1488@01 $arg12@1488@01))
        (= $arg21@1489@01 $arg22@1489@01)))
    (and
      (and (= $arg01@1487@01 $arg02@1487@01) (= $arg11@1488@01 $arg12@1488@01))
      (= $arg21@1489@01 $arg22@1489@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1487@01 Int) ($arg1@1488@01 Int) ($arg2@1489@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1487@01)
            ($SortWrappers.IntTo$Snap $arg1@1488@01))
          ($SortWrappers.IntTo$Snap $arg2@1489@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1487@01)
            ($SortWrappers.IntTo$Snap $arg1@1488@01))
          ($SortWrappers.IntTo$Snap $arg2@1489@01)))))
    (and
      (and
        (= (inv@1493@01 $arg0@1487@01 $arg1@1488@01 $arg2@1489@01) $arg0@1487@01)
        (= (inv@1495@01 $arg0@1487@01 $arg1@1488@01 $arg2@1489@01) $arg1@1488@01)
        (= (inv@1497@01 $arg0@1487@01 $arg1@1488@01 $arg2@1489@01) $arg2@1489@01))
      (and
        (img@1494@01 $arg0@1487@01 $arg1@1488@01 $arg2@1489@01)
        (img@1496@01 $arg0@1487@01 $arg1@1488@01 $arg2@1489@01)
        (img@1498@01 $arg0@1487@01 $arg1@1488@01 $arg2@1489@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1487@01)
      ($SortWrappers.IntTo$Snap $arg1@1488@01))
    ($SortWrappers.IntTo$Snap $arg2@1489@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1487@01)
      ($SortWrappers.IntTo$Snap $arg1@1488@01))
    ($SortWrappers.IntTo$Snap $arg2@1489@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1494@01 $arg0 $arg1 $arg2)
        (img@1496@01 $arg0 $arg1 $arg2)
        (img@1498@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1493@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1495@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1497@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1493@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1495@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1497@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1493@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1495@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1497@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1493@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1495@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1497@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1493@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1495@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1497@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1493@01 $arg0 $arg1 $arg2) (inv@1495@01 $arg0 $arg1 $arg2) (inv@1497@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1763|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1493@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1495@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1497@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1494@01 $arg0 $arg1 $arg2)
        (img@1496@01 $arg0 $arg1 $arg2)
        (img@1498@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1493@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1495@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1497@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@1492@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1493@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1495@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1497@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1764|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@1499@01 Int)
(declare-const $arg1@1500@01 Int)
(declare-const $arg2@1501@01 Int)
(push) ; 4
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
(declare-const sm@1502@01 $PSF<e$Transfer>)
(declare-const s@1503@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1504@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef127|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef128|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1499@01)
    ($SortWrappers.IntTo$Snap $arg1@1500@01))
  ($SortWrappers.IntTo$Snap $arg2@1501@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1499@01)
    ($SortWrappers.IntTo$Snap $arg1@1500@01))
  ($SortWrappers.IntTo$Snap $arg2@1501@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1499@01)
      ($SortWrappers.IntTo$Snap $arg1@1500@01))
    ($SortWrappers.IntTo$Snap $arg2@1501@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1505@01 (Int Int Int) Int)
(declare-fun img@1506@01 (Int Int Int) Bool)
(declare-fun inv@1507@01 (Int Int Int) Int)
(declare-fun img@1508@01 (Int Int Int) Bool)
(declare-fun inv@1509@01 (Int Int Int) Int)
(declare-fun img@1510@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef127|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef128|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1499@01 Int) ($arg1@1500@01 Int) ($arg2@1501@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1499@01)
          ($SortWrappers.IntTo$Snap $arg1@1500@01))
        ($SortWrappers.IntTo$Snap $arg2@1501@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1499@01)
        ($SortWrappers.IntTo$Snap $arg1@1500@01))
      ($SortWrappers.IntTo$Snap $arg2@1501@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1499@01)
        ($SortWrappers.IntTo$Snap $arg1@1500@01))
      ($SortWrappers.IntTo$Snap $arg2@1501@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1499@01)
      ($SortWrappers.IntTo$Snap $arg1@1500@01))
    ($SortWrappers.IntTo$Snap $arg2@1501@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1499@01)
      ($SortWrappers.IntTo$Snap $arg1@1500@01))
    ($SortWrappers.IntTo$Snap $arg2@1501@01))))
  :qid |e$Transfer-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1499@01 Int) ($arg1@1500@01 Int) ($arg2@1501@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1499@01)
          ($SortWrappers.IntTo$Snap $arg1@1500@01))
        ($SortWrappers.IntTo$Snap $arg2@1501@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1499@01)
            ($SortWrappers.IntTo$Snap $arg1@1500@01))
          ($SortWrappers.IntTo$Snap $arg2@1501@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1499@01)
            ($SortWrappers.IntTo$Snap $arg1@1500@01))
          ($SortWrappers.IntTo$Snap $arg2@1501@01))))))
  
  :qid |quant-u-1765|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1499@01 Int) ($arg11@1500@01 Int) ($arg21@1501@01 Int) ($arg02@1499@01 Int) ($arg12@1500@01 Int) ($arg22@1501@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1499@01)
                ($SortWrappers.IntTo$Snap $arg11@1500@01))
              ($SortWrappers.IntTo$Snap $arg21@1501@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1499@01)
              ($SortWrappers.IntTo$Snap $arg11@1500@01))
            ($SortWrappers.IntTo$Snap $arg21@1501@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1499@01)
              ($SortWrappers.IntTo$Snap $arg11@1500@01))
            ($SortWrappers.IntTo$Snap $arg21@1501@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1499@01)
              ($SortWrappers.IntTo$Snap $arg11@1500@01))
            ($SortWrappers.IntTo$Snap $arg21@1501@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1499@01)
                ($SortWrappers.IntTo$Snap $arg12@1500@01))
              ($SortWrappers.IntTo$Snap $arg22@1501@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1499@01)
              ($SortWrappers.IntTo$Snap $arg12@1500@01))
            ($SortWrappers.IntTo$Snap $arg22@1501@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1499@01)
              ($SortWrappers.IntTo$Snap $arg12@1500@01))
            ($SortWrappers.IntTo$Snap $arg22@1501@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1499@01)
              ($SortWrappers.IntTo$Snap $arg12@1500@01))
            ($SortWrappers.IntTo$Snap $arg22@1501@01)))))
      (and
        (and (= $arg01@1499@01 $arg02@1499@01) (= $arg11@1500@01 $arg12@1500@01))
        (= $arg21@1501@01 $arg22@1501@01)))
    (and
      (and (= $arg01@1499@01 $arg02@1499@01) (= $arg11@1500@01 $arg12@1500@01))
      (= $arg21@1501@01 $arg22@1501@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1499@01 Int) ($arg1@1500@01 Int) ($arg2@1501@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1499@01)
            ($SortWrappers.IntTo$Snap $arg1@1500@01))
          ($SortWrappers.IntTo$Snap $arg2@1501@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1499@01)
            ($SortWrappers.IntTo$Snap $arg1@1500@01))
          ($SortWrappers.IntTo$Snap $arg2@1501@01)))))
    (and
      (and
        (= (inv@1505@01 $arg0@1499@01 $arg1@1500@01 $arg2@1501@01) $arg0@1499@01)
        (= (inv@1507@01 $arg0@1499@01 $arg1@1500@01 $arg2@1501@01) $arg1@1500@01)
        (= (inv@1509@01 $arg0@1499@01 $arg1@1500@01 $arg2@1501@01) $arg2@1501@01))
      (and
        (img@1506@01 $arg0@1499@01 $arg1@1500@01 $arg2@1501@01)
        (img@1508@01 $arg0@1499@01 $arg1@1500@01 $arg2@1501@01)
        (img@1510@01 $arg0@1499@01 $arg1@1500@01 $arg2@1501@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1499@01)
      ($SortWrappers.IntTo$Snap $arg1@1500@01))
    ($SortWrappers.IntTo$Snap $arg2@1501@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1499@01)
      ($SortWrappers.IntTo$Snap $arg1@1500@01))
    ($SortWrappers.IntTo$Snap $arg2@1501@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1506@01 $arg0 $arg1 $arg2)
        (img@1508@01 $arg0 $arg1 $arg2)
        (img@1510@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1505@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1507@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1509@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1505@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1507@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1509@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1505@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1507@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1509@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1505@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1507@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1509@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1505@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1507@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1509@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1505@01 $arg0 $arg1 $arg2) (inv@1507@01 $arg0 $arg1 $arg2) (inv@1509@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1766|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1505@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1507@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1509@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1506@01 $arg0 $arg1 $arg2)
        (img@1508@01 $arg0 $arg1 $arg2)
        (img@1510@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1505@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1507@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1509@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@1504@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1505@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1507@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1509@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1767|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@1511@01 Int)
(declare-const $arg1@1512@01 Int)
(declare-const $arg2@1513@01 Int)
(push) ; 4
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
(declare-const sm@1514@01 $PSF<e$Approval>)
(declare-const s@1515@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1516@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef130|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef131|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1511@01)
    ($SortWrappers.IntTo$Snap $arg1@1512@01))
  ($SortWrappers.IntTo$Snap $arg2@1513@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1511@01)
    ($SortWrappers.IntTo$Snap $arg1@1512@01))
  ($SortWrappers.IntTo$Snap $arg2@1513@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1511@01)
      ($SortWrappers.IntTo$Snap $arg1@1512@01))
    ($SortWrappers.IntTo$Snap $arg2@1513@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1517@01 (Int Int Int) Int)
(declare-fun img@1518@01 (Int Int Int) Bool)
(declare-fun inv@1519@01 (Int Int Int) Int)
(declare-fun img@1520@01 (Int Int Int) Bool)
(declare-fun inv@1521@01 (Int Int Int) Int)
(declare-fun img@1522@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef130|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef131|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1511@01 Int) ($arg1@1512@01 Int) ($arg2@1513@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1511@01)
          ($SortWrappers.IntTo$Snap $arg1@1512@01))
        ($SortWrappers.IntTo$Snap $arg2@1513@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1511@01)
        ($SortWrappers.IntTo$Snap $arg1@1512@01))
      ($SortWrappers.IntTo$Snap $arg2@1513@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1511@01)
        ($SortWrappers.IntTo$Snap $arg1@1512@01))
      ($SortWrappers.IntTo$Snap $arg2@1513@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1511@01)
      ($SortWrappers.IntTo$Snap $arg1@1512@01))
    ($SortWrappers.IntTo$Snap $arg2@1513@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1511@01)
      ($SortWrappers.IntTo$Snap $arg1@1512@01))
    ($SortWrappers.IntTo$Snap $arg2@1513@01))))
  :qid |e$Approval-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1511@01 Int) ($arg1@1512@01 Int) ($arg2@1513@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1511@01)
          ($SortWrappers.IntTo$Snap $arg1@1512@01))
        ($SortWrappers.IntTo$Snap $arg2@1513@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1511@01)
            ($SortWrappers.IntTo$Snap $arg1@1512@01))
          ($SortWrappers.IntTo$Snap $arg2@1513@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1511@01)
            ($SortWrappers.IntTo$Snap $arg1@1512@01))
          ($SortWrappers.IntTo$Snap $arg2@1513@01))))))
  
  :qid |quant-u-1768|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1511@01 Int) ($arg11@1512@01 Int) ($arg21@1513@01 Int) ($arg02@1511@01 Int) ($arg12@1512@01 Int) ($arg22@1513@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1511@01)
                ($SortWrappers.IntTo$Snap $arg11@1512@01))
              ($SortWrappers.IntTo$Snap $arg21@1513@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1511@01)
              ($SortWrappers.IntTo$Snap $arg11@1512@01))
            ($SortWrappers.IntTo$Snap $arg21@1513@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1511@01)
              ($SortWrappers.IntTo$Snap $arg11@1512@01))
            ($SortWrappers.IntTo$Snap $arg21@1513@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1511@01)
              ($SortWrappers.IntTo$Snap $arg11@1512@01))
            ($SortWrappers.IntTo$Snap $arg21@1513@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1511@01)
                ($SortWrappers.IntTo$Snap $arg12@1512@01))
              ($SortWrappers.IntTo$Snap $arg22@1513@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1511@01)
              ($SortWrappers.IntTo$Snap $arg12@1512@01))
            ($SortWrappers.IntTo$Snap $arg22@1513@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1511@01)
              ($SortWrappers.IntTo$Snap $arg12@1512@01))
            ($SortWrappers.IntTo$Snap $arg22@1513@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1511@01)
              ($SortWrappers.IntTo$Snap $arg12@1512@01))
            ($SortWrappers.IntTo$Snap $arg22@1513@01)))))
      (and
        (and (= $arg01@1511@01 $arg02@1511@01) (= $arg11@1512@01 $arg12@1512@01))
        (= $arg21@1513@01 $arg22@1513@01)))
    (and
      (and (= $arg01@1511@01 $arg02@1511@01) (= $arg11@1512@01 $arg12@1512@01))
      (= $arg21@1513@01 $arg22@1513@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1511@01 Int) ($arg1@1512@01 Int) ($arg2@1513@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1511@01)
            ($SortWrappers.IntTo$Snap $arg1@1512@01))
          ($SortWrappers.IntTo$Snap $arg2@1513@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1511@01)
            ($SortWrappers.IntTo$Snap $arg1@1512@01))
          ($SortWrappers.IntTo$Snap $arg2@1513@01)))))
    (and
      (and
        (= (inv@1517@01 $arg0@1511@01 $arg1@1512@01 $arg2@1513@01) $arg0@1511@01)
        (= (inv@1519@01 $arg0@1511@01 $arg1@1512@01 $arg2@1513@01) $arg1@1512@01)
        (= (inv@1521@01 $arg0@1511@01 $arg1@1512@01 $arg2@1513@01) $arg2@1513@01))
      (and
        (img@1518@01 $arg0@1511@01 $arg1@1512@01 $arg2@1513@01)
        (img@1520@01 $arg0@1511@01 $arg1@1512@01 $arg2@1513@01)
        (img@1522@01 $arg0@1511@01 $arg1@1512@01 $arg2@1513@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1511@01)
      ($SortWrappers.IntTo$Snap $arg1@1512@01))
    ($SortWrappers.IntTo$Snap $arg2@1513@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1511@01)
      ($SortWrappers.IntTo$Snap $arg1@1512@01))
    ($SortWrappers.IntTo$Snap $arg2@1513@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1518@01 $arg0 $arg1 $arg2)
        (img@1520@01 $arg0 $arg1 $arg2)
        (img@1522@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1517@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1519@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1521@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1517@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1519@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1521@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1517@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1519@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1521@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1517@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1519@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1521@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1517@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1519@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1521@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1517@01 $arg0 $arg1 $arg2) (inv@1519@01 $arg0 $arg1 $arg2) (inv@1521@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1769|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1517@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1519@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1521@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1518@01 $arg0 $arg1 $arg2)
        (img@1520@01 $arg0 $arg1 $arg2)
        (img@1522@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1517@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1519@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1521@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@1516@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1517@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1519@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1521@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1770|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; inhale 0 <= l$i0$raw_ret &&
;   l$i0$raw_ret <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1523@01 $Snap)
(assert (= $t@1523@01 ($Snap.combine ($Snap.first $t@1523@01) ($Snap.second $t@1523@01))))
(assert (= ($Snap.first $t@1523@01) $Snap.unit))
; [eval] 0 <= l$i0$raw_ret
(assert (<= 0 l$i0$raw_ret@1378@01))
(assert (= ($Snap.second $t@1523@01) $Snap.unit))
; [eval] l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
(assert (<=
  l$i0$raw_ret@1378@01
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not l$i0$send_fail@1377@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not l$i0$send_fail@1377@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 372 | l$i0$send_fail@1377@01 | live]
; [else-branch: 372 | !(l$i0$send_fail@1377@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 372 | l$i0$send_fail@1377@01]
(assert l$i0$send_fail@1377@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@1524@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 373 | True | live]
; [else-branch: 373 | False | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 373 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1525@01 $Snap)
(assert (= $t@1525@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1526@01 $Struct)
(assert (=
  self@1526@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 5
; [then-branch: 374 | False | dead]
; [else-branch: 374 | True | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 374 | True]
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 372 | !(l$i0$send_fail@1377@01)]
(assert (not l$i0$send_fail@1377@01))
(pop) ; 4
; [eval] !l$i0$send_fail
(push) ; 4
(set-option :timeout 10)
(assert (not l$i0$send_fail@1377@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not l$i0$send_fail@1377@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 375 | !(l$i0$send_fail@1377@01) | live]
; [else-branch: 375 | l$i0$send_fail@1377@01 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 375 | !(l$i0$send_fail@1377@01)]
(assert (not l$i0$send_fail@1377@01))
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; l$i0$token_reserve := $wrap(l$i0$raw_ret)
; [eval] $wrap(l$i0$raw_ret)
(declare-const l$i0$token_reserve@1527@01 $Int)
(assert (= l$i0$token_reserve@1527@01 ($wrap<$Int> l$i0$raw_ret@1378@01)))
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 5
(set-option :timeout 10)
(assert (not (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1444@01 8))
      l$i0$eth_sold@1445@01)
    0))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 376 | $struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 < 0 | dead]
; [else-branch: 376 | !($struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 < 0) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 376 | !($struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 < 0)]
(assert (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1444@01 8))
      l$i0$eth_sold@1445@01)
    0)))
(pop) ; 5
; [eval] !(($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0)
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 5
(set-option :timeout 10)
(assert (not (<
  (- ($struct_get<Int> ($struct_loc<Int> self@1444@01 8)) l$i0$eth_sold@1445@01)
  0)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1444@01 8))
      l$i0$eth_sold@1445@01)
    0))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 377 | !($struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 < 0) | live]
; [else-branch: 377 | $struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 < 0 | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 377 | !($struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 < 0)]
(assert (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1444@01 8))
      l$i0$eth_sold@1445@01)
    0)))
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1444@01 8))
      l$i0$eth_sold@1445@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 378 | $struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 378 | !($struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 378 | !($struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1444@01 8))
      l$i0$eth_sold@1445@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 6
; [eval] !(($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 6
(set-option :timeout 10)
(assert (not (>
  (- ($struct_get<Int> ($struct_loc<Int> self@1444@01 8)) l$i0$eth_sold@1445@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1444@01 8))
      l$i0$eth_sold@1445@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 379 | !($struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 379 | $struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 379 | !($struct_get[Int]($struct_loc[Int](self@1444@01, 8)) - l$i0$eth_sold@1445@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1444@01 8))
      l$i0$eth_sold@1445@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$input_amount := l$i0$eth_sold
; [exec]
; l$i2$input_reserve := ($struct_get($struct_loc(self, 8)): Int) -
;   l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const l$i2$input_reserve@1528@01 Int)
(assert (=
  l$i2$input_reserve@1528@01
  (- ($struct_get<Int> ($struct_loc<Int> self@1444@01 8)) l$i0$eth_sold@1445@01)))
; [exec]
; l$i2$output_reserve := l$i0$token_reserve
; [eval] !(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)
; [eval] l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0
; [eval] l$i2$input_reserve > 0
(push) ; 7
; [then-branch: 380 | !(l$i2$input_reserve@1528@01 > 0) | live]
; [else-branch: 380 | l$i2$input_reserve@1528@01 > 0 | live]
(push) ; 8
; [then-branch: 380 | !(l$i2$input_reserve@1528@01 > 0)]
(assert (not (> l$i2$input_reserve@1528@01 0)))
(pop) ; 8
(push) ; 8
; [else-branch: 380 | l$i2$input_reserve@1528@01 > 0]
(assert (> l$i2$input_reserve@1528@01 0))
; [eval] $unwrap(l$i2$output_reserve) > 0
; [eval] $unwrap(l$i2$output_reserve)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or (> l$i2$input_reserve@1528@01 0) (not (> l$i2$input_reserve@1528@01 0))))
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (> l$i2$input_reserve@1528@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@1527@01) 0))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (and
    (> l$i2$input_reserve@1528@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@1527@01) 0)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 381 | !(l$i2$input_reserve@1528@01 > 0 && $unwrap[Int](l$i0$token_reserve@1527@01) > 0) | live]
; [else-branch: 381 | l$i2$input_reserve@1528@01 > 0 && $unwrap[Int](l$i0$token_reserve@1527@01) > 0 | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 381 | !(l$i2$input_reserve@1528@01 > 0 && $unwrap[Int](l$i0$token_reserve@1527@01) > 0)]
(assert (not
  (and
    (> l$i2$input_reserve@1528@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@1527@01) 0))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 8
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 382 | True | live]
; [else-branch: 382 | False | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 382 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1529@01 $Snap)
(assert (= $t@1529@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1530@01 $Struct)
(assert (=
  self@1530@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 8
; [then-branch: 383 | False | dead]
; [else-branch: 383 | True | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 383 | True]
(pop) ; 8
(pop) ; 7
(push) ; 7
; [else-branch: 381 | l$i2$input_reserve@1528@01 > 0 && $unwrap[Int](l$i0$token_reserve@1527@01) > 0]
(assert (and
  (> l$i2$input_reserve@1528@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@1527@01) 0)))
(pop) ; 7
; [eval] !!(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)
; [eval] !(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)
; [eval] l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0
; [eval] l$i2$input_reserve > 0
(push) ; 7
; [then-branch: 384 | !(l$i2$input_reserve@1528@01 > 0) | live]
; [else-branch: 384 | l$i2$input_reserve@1528@01 > 0 | live]
(push) ; 8
; [then-branch: 384 | !(l$i2$input_reserve@1528@01 > 0)]
(assert (not (> l$i2$input_reserve@1528@01 0)))
(pop) ; 8
(push) ; 8
; [else-branch: 384 | l$i2$input_reserve@1528@01 > 0]
(assert (> l$i2$input_reserve@1528@01 0))
; [eval] $unwrap(l$i2$output_reserve) > 0
; [eval] $unwrap(l$i2$output_reserve)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (and
    (> l$i2$input_reserve@1528@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@1527@01) 0)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (> l$i2$input_reserve@1528@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@1527@01) 0))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 385 | l$i2$input_reserve@1528@01 > 0 && $unwrap[Int](l$i0$token_reserve@1527@01) > 0 | live]
; [else-branch: 385 | !(l$i2$input_reserve@1528@01 > 0 && $unwrap[Int](l$i0$token_reserve@1527@01) > 0) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 385 | l$i2$input_reserve@1528@01 > 0 && $unwrap[Int](l$i0$token_reserve@1527@01) > 0]
(assert (and
  (> l$i2$input_reserve@1528@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@1527@01) 0)))
; [eval] l$i2$input_amount * 997 < 0
; [eval] l$i2$input_amount * 997
(push) ; 8
(set-option :timeout 10)
(assert (not (not (< (* l$i0$eth_sold@1445@01 997) 0))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 386 | l$i0$eth_sold@1445@01 * 997 < 0 | dead]
; [else-branch: 386 | !(l$i0$eth_sold@1445@01 * 997 < 0) | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 386 | !(l$i0$eth_sold@1445@01 * 997 < 0)]
(assert (not (< (* l$i0$eth_sold@1445@01 997) 0)))
(pop) ; 8
; [eval] !(l$i2$input_amount * 997 < 0)
; [eval] l$i2$input_amount * 997 < 0
; [eval] l$i2$input_amount * 997
(push) ; 8
(set-option :timeout 10)
(assert (not (< (* l$i0$eth_sold@1445@01 997) 0)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not (< (* l$i0$eth_sold@1445@01 997) 0))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 387 | !(l$i0$eth_sold@1445@01 * 997 < 0) | live]
; [else-branch: 387 | l$i0$eth_sold@1445@01 * 997 < 0 | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 387 | !(l$i0$eth_sold@1445@01 * 997 < 0)]
(assert (not (< (* l$i0$eth_sold@1445@01 997) 0)))
; [eval] l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount * 997
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i0$eth_sold@1445@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (>
  (* l$i0$eth_sold@1445@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 388 | l$i0$eth_sold@1445@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 388 | !(l$i0$eth_sold@1445@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 388 | l$i0$eth_sold@1445@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (* l$i0$eth_sold@1445@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 10
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 389 | True | live]
; [else-branch: 389 | False | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 389 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1531@01 $Snap)
(assert (= $t@1531@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1532@01 $Struct)
(assert (=
  self@1532@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 10
; [then-branch: 390 | False | dead]
; [else-branch: 390 | True | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 390 | True]
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 388 | !(l$i0$eth_sold@1445@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i0$eth_sold@1445@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 9
; [eval] !(l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount * 997
(push) ; 9
(set-option :timeout 10)
(assert (not (>
  (* l$i0$eth_sold@1445@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i0$eth_sold@1445@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 391 | !(l$i0$eth_sold@1445@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 391 | l$i0$eth_sold@1445@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 391 | !(l$i0$eth_sold@1445@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i0$eth_sold@1445@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$input_amount_with_fee := l$i2$input_amount * 997
; [eval] l$i2$input_amount * 997
(declare-const l$i2$input_amount_with_fee@1533@01 Int)
(assert (= l$i2$input_amount_with_fee@1533@01 (* l$i0$eth_sold@1445@01 997)))
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (<
    (*
      l$i2$input_amount_with_fee@1533@01
      ($unwrap<Int> l$i0$token_reserve@1527@01))
    0))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 392 | l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) < 0 | dead]
; [else-branch: 392 | !(l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) < 0) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 392 | !(l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) < 0)]
(assert (not
  (<
    (*
      l$i2$input_amount_with_fee@1533@01
      ($unwrap<Int> l$i0$token_reserve@1527@01))
    0)))
(pop) ; 10
; [eval] !(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0)
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 10
(set-option :timeout 10)
(assert (not (<
  (*
    l$i2$input_amount_with_fee@1533@01
    ($unwrap<Int> l$i0$token_reserve@1527@01))
  0)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (<
    (*
      l$i2$input_amount_with_fee@1533@01
      ($unwrap<Int> l$i0$token_reserve@1527@01))
    0))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 393 | !(l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) < 0) | live]
; [else-branch: 393 | l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) < 0 | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 393 | !(l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) < 0)]
(assert (not
  (<
    (*
      l$i2$input_amount_with_fee@1533@01
      ($unwrap<Int> l$i0$token_reserve@1527@01))
    0)))
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 11
(set-option :timeout 10)
(assert (not (not
  (>
    (*
      l$i2$input_amount_with_fee@1533@01
      ($unwrap<Int> l$i0$token_reserve@1527@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (>
  (*
    l$i2$input_amount_with_fee@1533@01
    ($unwrap<Int> l$i0$token_reserve@1527@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 394 | l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 394 | !(l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 394 | l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (*
    l$i2$input_amount_with_fee@1533@01
    ($unwrap<Int> l$i0$token_reserve@1527@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 12
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 395 | True | live]
; [else-branch: 395 | False | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 395 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1534@01 $Snap)
(assert (= $t@1534@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1535@01 $Struct)
(assert (=
  self@1535@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 12
; [then-branch: 396 | False | dead]
; [else-branch: 396 | True | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 396 | True]
(pop) ; 12
(pop) ; 11
(push) ; 11
; [else-branch: 394 | !(l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (*
      l$i2$input_amount_with_fee@1533@01
      ($unwrap<Int> l$i0$token_reserve@1527@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 11
; [eval] !(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 11
(set-option :timeout 10)
(assert (not (>
  (*
    l$i2$input_amount_with_fee@1533@01
    ($unwrap<Int> l$i0$token_reserve@1527@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (not
  (>
    (*
      l$i2$input_amount_with_fee@1533@01
      ($unwrap<Int> l$i0$token_reserve@1527@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 397 | !(l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 397 | l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 397 | !(l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (*
      l$i2$input_amount_with_fee@1533@01
      ($unwrap<Int> l$i0$token_reserve@1527@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$numerator := $wrap(l$i2$input_amount_with_fee *
;   $unwrap(l$i2$output_reserve))
; [eval] $wrap(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve))
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(declare-const l$i2$numerator@1536@01 $Int)
(assert (=
  l$i2$numerator@1536@01
  ($wrap<$Int> (*
    l$i2$input_amount_with_fee@1533@01
    ($unwrap<Int> l$i0$token_reserve@1527@01)))))
; [eval] l$i2$input_reserve * 1000 < 0
; [eval] l$i2$input_reserve * 1000
(push) ; 12
(set-option :timeout 10)
(assert (not (not (< (* l$i2$input_reserve@1528@01 1000) 0))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 398 | l$i2$input_reserve@1528@01 * 1000 < 0 | dead]
; [else-branch: 398 | !(l$i2$input_reserve@1528@01 * 1000 < 0) | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 398 | !(l$i2$input_reserve@1528@01 * 1000 < 0)]
(assert (not (< (* l$i2$input_reserve@1528@01 1000) 0)))
(pop) ; 12
; [eval] !(l$i2$input_reserve * 1000 < 0)
; [eval] l$i2$input_reserve * 1000 < 0
; [eval] l$i2$input_reserve * 1000
(push) ; 12
(set-option :timeout 10)
(assert (not (< (* l$i2$input_reserve@1528@01 1000) 0)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (not (< (* l$i2$input_reserve@1528@01 1000) 0))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 399 | !(l$i2$input_reserve@1528@01 * 1000 < 0) | live]
; [else-branch: 399 | l$i2$input_reserve@1528@01 * 1000 < 0 | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 399 | !(l$i2$input_reserve@1528@01 * 1000 < 0)]
(assert (not (< (* l$i2$input_reserve@1528@01 1000) 0)))
; [eval] l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000
(push) ; 13
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i2$input_reserve@1528@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (>
  (* l$i2$input_reserve@1528@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 400 | l$i2$input_reserve@1528@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 400 | !(l$i2$input_reserve@1528@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 400 | l$i2$input_reserve@1528@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (* l$i2$input_reserve@1528@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 14
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 401 | True | live]
; [else-branch: 401 | False | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 401 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1537@01 $Snap)
(assert (= $t@1537@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1538@01 $Struct)
(assert (=
  self@1538@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 14
; [then-branch: 402 | False | dead]
; [else-branch: 402 | True | live]
(set-option :timeout 0)
(push) ; 14
; [else-branch: 402 | True]
(pop) ; 14
(pop) ; 13
(push) ; 13
; [else-branch: 400 | !(l$i2$input_reserve@1528@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i2$input_reserve@1528@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 13
; [eval] !(l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000
(push) ; 13
(set-option :timeout 10)
(assert (not (>
  (* l$i2$input_reserve@1528@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i2$input_reserve@1528@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 403 | !(l$i2$input_reserve@1528@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 403 | l$i2$input_reserve@1528@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 403 | !(l$i2$input_reserve@1528@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i2$input_reserve@1528@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (<
    (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
    0))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 404 | l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 < 0 | dead]
; [else-branch: 404 | !(l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 < 0) | live]
(set-option :timeout 0)
(push) ; 14
; [else-branch: 404 | !(l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 < 0)]
(assert (not
  (<
    (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
    0)))
(pop) ; 14
; [eval] !(l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0)
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 14
(set-option :timeout 10)
(assert (not (< (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01) 0)))
(check-sat)
; unknown
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (<
    (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
    0))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 405 | !(l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 < 0) | live]
; [else-branch: 405 | l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 < 0 | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 405 | !(l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 < 0)]
(assert (not
  (<
    (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
    0)))
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 15
(set-option :timeout 10)
(assert (not (not
  (>
    (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (>
  (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 406 | l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 406 | !(l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 406 | l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 16
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 407 | True | live]
; [else-branch: 407 | False | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 407 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1539@01 $Snap)
(assert (= $t@1539@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1540@01 $Struct)
(assert (=
  self@1540@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 16
; [then-branch: 408 | False | dead]
; [else-branch: 408 | True | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 408 | True]
(pop) ; 16
(pop) ; 15
(push) ; 15
; [else-branch: 406 | !(l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 15
; [eval] !(l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 15
(set-option :timeout 10)
(assert (not (>
  (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (not
  (>
    (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 409 | !(l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 409 | l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 409 | !(l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$denominator := l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(declare-const l$i2$denominator@1541@01 Int)
(assert (=
  l$i2$denominator@1541@01
  (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)))
; [eval] l$i2$denominator == 0
(push) ; 16
(set-option :timeout 10)
(assert (not (not (= l$i2$denominator@1541@01 0))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 410 | l$i2$denominator@1541@01 == 0 | dead]
; [else-branch: 410 | l$i2$denominator@1541@01 != 0 | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 410 | l$i2$denominator@1541@01 != 0]
(assert (not (= l$i2$denominator@1541@01 0)))
(pop) ; 16
; [eval] !(l$i2$denominator == 0)
; [eval] l$i2$denominator == 0
(push) ; 16
(set-option :timeout 10)
(assert (not (= l$i2$denominator@1541@01 0)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not (= l$i2$denominator@1541@01 0))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 411 | l$i2$denominator@1541@01 != 0 | live]
; [else-branch: 411 | l$i2$denominator@1541@01 == 0 | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 411 | l$i2$denominator@1541@01 != 0]
(assert (not (= l$i2$denominator@1541@01 0)))
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) < 0
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 17
(set-option :timeout 10)
(assert (not (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
      ($unwrap<Int> l$i2$numerator@1536@01)
      l$i2$denominator@1541@01))
    0))))
(check-sat)
; unsat
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
; [then-branch: 412 | $div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) < 0 | dead]
; [else-branch: 412 | !($div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) < 0) | live]
(set-option :timeout 0)
(push) ; 17
; [else-branch: 412 | !($div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) < 0)]
(assert (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
      ($unwrap<Int> l$i2$numerator@1536@01)
      l$i2$denominator@1541@01))
    0)))
(pop) ; 17
; [eval] !($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) < 0)
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) < 0
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 17
(set-option :timeout 10)
(assert (not (<
  ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
    ($unwrap<Int> l$i2$numerator@1536@01)
    l$i2$denominator@1541@01))
  0)))
(check-sat)
; unknown
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
      ($unwrap<Int> l$i2$numerator@1536@01)
      l$i2$denominator@1541@01))
    0))))
(check-sat)
; unknown
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
; [then-branch: 413 | !($div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) < 0) | live]
; [else-branch: 413 | $div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) < 0 | live]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 413 | !($div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) < 0)]
(assert (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
      ($unwrap<Int> l$i2$numerator@1536@01)
      l$i2$denominator@1541@01))
    0)))
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
      ($unwrap<Int> l$i2$numerator@1536@01)
      l$i2$denominator@1541@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 414 | $div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 414 | !($div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 18
; [else-branch: 414 | !($div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
      ($unwrap<Int> l$i2$numerator@1536@01)
      l$i2$denominator@1541@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 18
; [eval] !($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 18
(set-option :timeout 10)
(assert (not (>
  ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
    ($unwrap<Int> l$i2$numerator@1536@01)
    l$i2$denominator@1541@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
      ($unwrap<Int> l$i2$numerator@1536@01)
      l$i2$denominator@1541@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 415 | !($div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 415 | $div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 415 | !($div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
      ($unwrap<Int> l$i2$numerator@1536@01)
      l$i2$denominator@1541@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; i2$$res := $unwrap($wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \
;   l$i2$denominator)))
; [eval] $unwrap($wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)))
; [eval] $wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator))
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(declare-const i2$$res@1542@01 Int)
(assert (=
  i2$$res@1542@01
  ($unwrap<Int> ($wrap<$Int> ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
    ($unwrap<Int> l$i2$numerator@1536@01)
    l$i2$denominator@1541@01))))))
; [exec]
; label i2$return
; [exec]
; l$i0$tokens_bought := $wrap(i2$$res)
; [eval] $wrap(i2$$res)
(declare-const l$i0$tokens_bought@1543@01 $Int)
(assert (= l$i0$tokens_bought@1543@01 ($wrap<$Int> i2$$res@1542@01)))
; [eval] !($unwrap(l$i0$tokens_bought) >= l$i0$min_tokens)
; [eval] $unwrap(l$i0$tokens_bought) >= l$i0$min_tokens
; [eval] $unwrap(l$i0$tokens_bought)
(push) ; 19
(set-option :timeout 10)
(assert (not (>= ($unwrap<Int> l$i0$tokens_bought@1543@01) 1)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (not (>= ($unwrap<Int> l$i0$tokens_bought@1543@01) 1))))
(check-sat)
; unknown
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
; [then-branch: 416 | !($unwrap[Int](l$i0$tokens_bought@1543@01) >= 1) | live]
; [else-branch: 416 | $unwrap[Int](l$i0$tokens_bought@1543@01) >= 1 | live]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 416 | !($unwrap[Int](l$i0$tokens_bought@1543@01) >= 1)]
(assert (not (>= ($unwrap<Int> l$i0$tokens_bought@1543@01) 1)))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 20
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 417 | True | live]
; [else-branch: 417 | False | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 417 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1544@01 $Snap)
(assert (= $t@1544@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1545@01 $Struct)
(assert (=
  self@1545@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 20
; [then-branch: 418 | False | dead]
; [else-branch: 418 | True | live]
(set-option :timeout 0)
(push) ; 20
; [else-branch: 418 | True]
(pop) ; 20
(pop) ; 19
(push) ; 19
; [else-branch: 416 | $unwrap[Int](l$i0$tokens_bought@1543@01) >= 1]
(assert (>= ($unwrap<Int> l$i0$tokens_bought@1543@01) 1))
(pop) ; 19
; [eval] !!($unwrap(l$i0$tokens_bought) >= l$i0$min_tokens)
; [eval] !($unwrap(l$i0$tokens_bought) >= l$i0$min_tokens)
; [eval] $unwrap(l$i0$tokens_bought) >= l$i0$min_tokens
; [eval] $unwrap(l$i0$tokens_bought)
(push) ; 19
(set-option :timeout 10)
(assert (not (not (>= ($unwrap<Int> l$i0$tokens_bought@1543@01) 1))))
(check-sat)
; unknown
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (>= ($unwrap<Int> l$i0$tokens_bought@1543@01) 1)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 419 | $unwrap[Int](l$i0$tokens_bought@1543@01) >= 1 | live]
; [else-branch: 419 | !($unwrap[Int](l$i0$tokens_bought@1543@01) >= 1) | live]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 419 | $unwrap[Int](l$i0$tokens_bought@1543@01) >= 1]
(assert (>= ($unwrap<Int> l$i0$tokens_bought@1543@01) 1))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1546@01 Int)
(declare-const $arg1@1547@01 Int)
(declare-const $arg2@1548@01 Int)
(push) ; 20
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1549@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef132|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef133|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1546@01)
    ($SortWrappers.IntTo$Snap $arg1@1547@01))
  ($SortWrappers.IntTo$Snap $arg2@1548@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1546@01)
    ($SortWrappers.IntTo$Snap $arg1@1547@01))
  ($SortWrappers.IntTo$Snap $arg2@1548@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1546@01)
      ($SortWrappers.IntTo$Snap $arg1@1547@01))
    ($SortWrappers.IntTo$Snap $arg2@1548@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1550@01 (Int Int Int) Int)
(declare-fun img@1551@01 (Int Int Int) Bool)
(declare-fun inv@1552@01 (Int Int Int) Int)
(declare-fun img@1553@01 (Int Int Int) Bool)
(declare-fun inv@1554@01 (Int Int Int) Int)
(declare-fun img@1555@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef132|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef133|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1546@01 Int) ($arg1@1547@01 Int) ($arg2@1548@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1546@01)
          ($SortWrappers.IntTo$Snap $arg1@1547@01))
        ($SortWrappers.IntTo$Snap $arg2@1548@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1546@01)
        ($SortWrappers.IntTo$Snap $arg1@1547@01))
      ($SortWrappers.IntTo$Snap $arg2@1548@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1546@01)
        ($SortWrappers.IntTo$Snap $arg1@1547@01))
      ($SortWrappers.IntTo$Snap $arg2@1548@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1546@01)
      ($SortWrappers.IntTo$Snap $arg1@1547@01))
    ($SortWrappers.IntTo$Snap $arg2@1548@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1546@01)
      ($SortWrappers.IntTo$Snap $arg1@1547@01))
    ($SortWrappers.IntTo$Snap $arg2@1548@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1546@01 Int) ($arg1@1547@01 Int) ($arg2@1548@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1546@01)
          ($SortWrappers.IntTo$Snap $arg1@1547@01))
        ($SortWrappers.IntTo$Snap $arg2@1548@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1546@01)
            ($SortWrappers.IntTo$Snap $arg1@1547@01))
          ($SortWrappers.IntTo$Snap $arg2@1548@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1546@01)
            ($SortWrappers.IntTo$Snap $arg1@1547@01))
          ($SortWrappers.IntTo$Snap $arg2@1548@01))))))
  
  :qid |quant-u-1771|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1546@01 Int) ($arg11@1547@01 Int) ($arg21@1548@01 Int) ($arg02@1546@01 Int) ($arg12@1547@01 Int) ($arg22@1548@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1546@01)
                ($SortWrappers.IntTo$Snap $arg11@1547@01))
              ($SortWrappers.IntTo$Snap $arg21@1548@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1546@01)
              ($SortWrappers.IntTo$Snap $arg11@1547@01))
            ($SortWrappers.IntTo$Snap $arg21@1548@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1546@01)
              ($SortWrappers.IntTo$Snap $arg11@1547@01))
            ($SortWrappers.IntTo$Snap $arg21@1548@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1546@01)
              ($SortWrappers.IntTo$Snap $arg11@1547@01))
            ($SortWrappers.IntTo$Snap $arg21@1548@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1546@01)
                ($SortWrappers.IntTo$Snap $arg12@1547@01))
              ($SortWrappers.IntTo$Snap $arg22@1548@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1546@01)
              ($SortWrappers.IntTo$Snap $arg12@1547@01))
            ($SortWrappers.IntTo$Snap $arg22@1548@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1546@01)
              ($SortWrappers.IntTo$Snap $arg12@1547@01))
            ($SortWrappers.IntTo$Snap $arg22@1548@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1546@01)
              ($SortWrappers.IntTo$Snap $arg12@1547@01))
            ($SortWrappers.IntTo$Snap $arg22@1548@01)))))
      (and
        (and (= $arg01@1546@01 $arg02@1546@01) (= $arg11@1547@01 $arg12@1547@01))
        (= $arg21@1548@01 $arg22@1548@01)))
    (and
      (and (= $arg01@1546@01 $arg02@1546@01) (= $arg11@1547@01 $arg12@1547@01))
      (= $arg21@1548@01 $arg22@1548@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1546@01 Int) ($arg1@1547@01 Int) ($arg2@1548@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1546@01)
            ($SortWrappers.IntTo$Snap $arg1@1547@01))
          ($SortWrappers.IntTo$Snap $arg2@1548@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1546@01)
            ($SortWrappers.IntTo$Snap $arg1@1547@01))
          ($SortWrappers.IntTo$Snap $arg2@1548@01)))))
    (and
      (and
        (= (inv@1550@01 $arg0@1546@01 $arg1@1547@01 $arg2@1548@01) $arg0@1546@01)
        (= (inv@1552@01 $arg0@1546@01 $arg1@1547@01 $arg2@1548@01) $arg1@1547@01)
        (= (inv@1554@01 $arg0@1546@01 $arg1@1547@01 $arg2@1548@01) $arg2@1548@01))
      (and
        (img@1551@01 $arg0@1546@01 $arg1@1547@01 $arg2@1548@01)
        (img@1553@01 $arg0@1546@01 $arg1@1547@01 $arg2@1548@01)
        (img@1555@01 $arg0@1546@01 $arg1@1547@01 $arg2@1548@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1546@01)
      ($SortWrappers.IntTo$Snap $arg1@1547@01))
    ($SortWrappers.IntTo$Snap $arg2@1548@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1546@01)
      ($SortWrappers.IntTo$Snap $arg1@1547@01))
    ($SortWrappers.IntTo$Snap $arg2@1548@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1551@01 $arg0 $arg1 $arg2)
        (img@1553@01 $arg0 $arg1 $arg2)
        (img@1555@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1550@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1552@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1554@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1550@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1552@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1554@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1550@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1552@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1554@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1550@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1552@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1554@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1550@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1552@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1554@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1550@01 $arg0 $arg1 $arg2) (inv@1552@01 $arg0 $arg1 $arg2) (inv@1554@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1772|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1550@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1552@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1554@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1551@01 $arg0 $arg1 $arg2)
        (img@1553@01 $arg0 $arg1 $arg2)
        (img@1555@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1550@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1552@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1554@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@1549@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1550@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1552@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1554@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1773|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1556@01 Int)
(declare-const $arg1@1557@01 Int)
(declare-const $arg2@1558@01 Int)
(push) ; 20
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1559@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef134|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef135|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1556@01)
    ($SortWrappers.IntTo$Snap $arg1@1557@01))
  ($SortWrappers.IntTo$Snap $arg2@1558@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1556@01)
    ($SortWrappers.IntTo$Snap $arg1@1557@01))
  ($SortWrappers.IntTo$Snap $arg2@1558@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1556@01)
      ($SortWrappers.IntTo$Snap $arg1@1557@01))
    ($SortWrappers.IntTo$Snap $arg2@1558@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1560@01 (Int Int Int) Int)
(declare-fun img@1561@01 (Int Int Int) Bool)
(declare-fun inv@1562@01 (Int Int Int) Int)
(declare-fun img@1563@01 (Int Int Int) Bool)
(declare-fun inv@1564@01 (Int Int Int) Int)
(declare-fun img@1565@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef134|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef135|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1556@01 Int) ($arg1@1557@01 Int) ($arg2@1558@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1556@01)
          ($SortWrappers.IntTo$Snap $arg1@1557@01))
        ($SortWrappers.IntTo$Snap $arg2@1558@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1556@01)
        ($SortWrappers.IntTo$Snap $arg1@1557@01))
      ($SortWrappers.IntTo$Snap $arg2@1558@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1556@01)
        ($SortWrappers.IntTo$Snap $arg1@1557@01))
      ($SortWrappers.IntTo$Snap $arg2@1558@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1556@01)
      ($SortWrappers.IntTo$Snap $arg1@1557@01))
    ($SortWrappers.IntTo$Snap $arg2@1558@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1556@01)
      ($SortWrappers.IntTo$Snap $arg1@1557@01))
    ($SortWrappers.IntTo$Snap $arg2@1558@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1556@01 Int) ($arg1@1557@01 Int) ($arg2@1558@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1556@01)
          ($SortWrappers.IntTo$Snap $arg1@1557@01))
        ($SortWrappers.IntTo$Snap $arg2@1558@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1556@01)
            ($SortWrappers.IntTo$Snap $arg1@1557@01))
          ($SortWrappers.IntTo$Snap $arg2@1558@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1556@01)
            ($SortWrappers.IntTo$Snap $arg1@1557@01))
          ($SortWrappers.IntTo$Snap $arg2@1558@01))))))
  
  :qid |quant-u-1774|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1556@01 Int) ($arg11@1557@01 Int) ($arg21@1558@01 Int) ($arg02@1556@01 Int) ($arg12@1557@01 Int) ($arg22@1558@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1556@01)
                ($SortWrappers.IntTo$Snap $arg11@1557@01))
              ($SortWrappers.IntTo$Snap $arg21@1558@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1556@01)
              ($SortWrappers.IntTo$Snap $arg11@1557@01))
            ($SortWrappers.IntTo$Snap $arg21@1558@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1556@01)
              ($SortWrappers.IntTo$Snap $arg11@1557@01))
            ($SortWrappers.IntTo$Snap $arg21@1558@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1556@01)
              ($SortWrappers.IntTo$Snap $arg11@1557@01))
            ($SortWrappers.IntTo$Snap $arg21@1558@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1556@01)
                ($SortWrappers.IntTo$Snap $arg12@1557@01))
              ($SortWrappers.IntTo$Snap $arg22@1558@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1556@01)
              ($SortWrappers.IntTo$Snap $arg12@1557@01))
            ($SortWrappers.IntTo$Snap $arg22@1558@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1556@01)
              ($SortWrappers.IntTo$Snap $arg12@1557@01))
            ($SortWrappers.IntTo$Snap $arg22@1558@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1556@01)
              ($SortWrappers.IntTo$Snap $arg12@1557@01))
            ($SortWrappers.IntTo$Snap $arg22@1558@01)))))
      (and
        (and (= $arg01@1556@01 $arg02@1556@01) (= $arg11@1557@01 $arg12@1557@01))
        (= $arg21@1558@01 $arg22@1558@01)))
    (and
      (and (= $arg01@1556@01 $arg02@1556@01) (= $arg11@1557@01 $arg12@1557@01))
      (= $arg21@1558@01 $arg22@1558@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1556@01 Int) ($arg1@1557@01 Int) ($arg2@1558@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1556@01)
            ($SortWrappers.IntTo$Snap $arg1@1557@01))
          ($SortWrappers.IntTo$Snap $arg2@1558@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1556@01)
            ($SortWrappers.IntTo$Snap $arg1@1557@01))
          ($SortWrappers.IntTo$Snap $arg2@1558@01)))))
    (and
      (and
        (= (inv@1560@01 $arg0@1556@01 $arg1@1557@01 $arg2@1558@01) $arg0@1556@01)
        (= (inv@1562@01 $arg0@1556@01 $arg1@1557@01 $arg2@1558@01) $arg1@1557@01)
        (= (inv@1564@01 $arg0@1556@01 $arg1@1557@01 $arg2@1558@01) $arg2@1558@01))
      (and
        (img@1561@01 $arg0@1556@01 $arg1@1557@01 $arg2@1558@01)
        (img@1563@01 $arg0@1556@01 $arg1@1557@01 $arg2@1558@01)
        (img@1565@01 $arg0@1556@01 $arg1@1557@01 $arg2@1558@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1556@01)
      ($SortWrappers.IntTo$Snap $arg1@1557@01))
    ($SortWrappers.IntTo$Snap $arg2@1558@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1556@01)
      ($SortWrappers.IntTo$Snap $arg1@1557@01))
    ($SortWrappers.IntTo$Snap $arg2@1558@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1561@01 $arg0 $arg1 $arg2)
        (img@1563@01 $arg0 $arg1 $arg2)
        (img@1565@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1560@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1562@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1564@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1560@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1562@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1564@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1560@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1562@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1564@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1560@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1562@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1564@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1560@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1562@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1564@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1466@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1560@01 $arg0 $arg1 $arg2) (inv@1562@01 $arg0 $arg1 $arg2) (inv@1564@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1775|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1560@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1562@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1564@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1561@01 $arg0 $arg1 $arg2)
        (img@1563@01 $arg0 $arg1 $arg2)
        (img@1565@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1560@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1562@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1564@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@1559@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1560@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1562@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1564@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1776|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1566@01 Int)
(declare-const $arg1@1567@01 Int)
(declare-const $arg2@1568@01 Int)
(push) ; 20
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1569@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef136|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef137|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1566@01)
    ($SortWrappers.IntTo$Snap $arg1@1567@01))
  ($SortWrappers.IntTo$Snap $arg2@1568@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1566@01)
    ($SortWrappers.IntTo$Snap $arg1@1567@01))
  ($SortWrappers.IntTo$Snap $arg2@1568@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1566@01)
      ($SortWrappers.IntTo$Snap $arg1@1567@01))
    ($SortWrappers.IntTo$Snap $arg2@1568@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1570@01 (Int Int Int) Int)
(declare-fun img@1571@01 (Int Int Int) Bool)
(declare-fun inv@1572@01 (Int Int Int) Int)
(declare-fun img@1573@01 (Int Int Int) Bool)
(declare-fun inv@1574@01 (Int Int Int) Int)
(declare-fun img@1575@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef136|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef137|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1566@01 Int) ($arg1@1567@01 Int) ($arg2@1568@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1566@01)
          ($SortWrappers.IntTo$Snap $arg1@1567@01))
        ($SortWrappers.IntTo$Snap $arg2@1568@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1566@01)
        ($SortWrappers.IntTo$Snap $arg1@1567@01))
      ($SortWrappers.IntTo$Snap $arg2@1568@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1566@01)
        ($SortWrappers.IntTo$Snap $arg1@1567@01))
      ($SortWrappers.IntTo$Snap $arg2@1568@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1566@01)
      ($SortWrappers.IntTo$Snap $arg1@1567@01))
    ($SortWrappers.IntTo$Snap $arg2@1568@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1566@01)
      ($SortWrappers.IntTo$Snap $arg1@1567@01))
    ($SortWrappers.IntTo$Snap $arg2@1568@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1566@01 Int) ($arg1@1567@01 Int) ($arg2@1568@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1566@01)
          ($SortWrappers.IntTo$Snap $arg1@1567@01))
        ($SortWrappers.IntTo$Snap $arg2@1568@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1566@01)
            ($SortWrappers.IntTo$Snap $arg1@1567@01))
          ($SortWrappers.IntTo$Snap $arg2@1568@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1566@01)
            ($SortWrappers.IntTo$Snap $arg1@1567@01))
          ($SortWrappers.IntTo$Snap $arg2@1568@01))))))
  
  :qid |quant-u-1777|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1566@01 Int) ($arg11@1567@01 Int) ($arg21@1568@01 Int) ($arg02@1566@01 Int) ($arg12@1567@01 Int) ($arg22@1568@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1566@01)
                ($SortWrappers.IntTo$Snap $arg11@1567@01))
              ($SortWrappers.IntTo$Snap $arg21@1568@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1566@01)
              ($SortWrappers.IntTo$Snap $arg11@1567@01))
            ($SortWrappers.IntTo$Snap $arg21@1568@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1566@01)
              ($SortWrappers.IntTo$Snap $arg11@1567@01))
            ($SortWrappers.IntTo$Snap $arg21@1568@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1566@01)
              ($SortWrappers.IntTo$Snap $arg11@1567@01))
            ($SortWrappers.IntTo$Snap $arg21@1568@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1566@01)
                ($SortWrappers.IntTo$Snap $arg12@1567@01))
              ($SortWrappers.IntTo$Snap $arg22@1568@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1566@01)
              ($SortWrappers.IntTo$Snap $arg12@1567@01))
            ($SortWrappers.IntTo$Snap $arg22@1568@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1566@01)
              ($SortWrappers.IntTo$Snap $arg12@1567@01))
            ($SortWrappers.IntTo$Snap $arg22@1568@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1566@01)
              ($SortWrappers.IntTo$Snap $arg12@1567@01))
            ($SortWrappers.IntTo$Snap $arg22@1568@01)))))
      (and
        (and (= $arg01@1566@01 $arg02@1566@01) (= $arg11@1567@01 $arg12@1567@01))
        (= $arg21@1568@01 $arg22@1568@01)))
    (and
      (and (= $arg01@1566@01 $arg02@1566@01) (= $arg11@1567@01 $arg12@1567@01))
      (= $arg21@1568@01 $arg22@1568@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1566@01 Int) ($arg1@1567@01 Int) ($arg2@1568@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1566@01)
            ($SortWrappers.IntTo$Snap $arg1@1567@01))
          ($SortWrappers.IntTo$Snap $arg2@1568@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1566@01)
            ($SortWrappers.IntTo$Snap $arg1@1567@01))
          ($SortWrappers.IntTo$Snap $arg2@1568@01)))))
    (and
      (and
        (= (inv@1570@01 $arg0@1566@01 $arg1@1567@01 $arg2@1568@01) $arg0@1566@01)
        (= (inv@1572@01 $arg0@1566@01 $arg1@1567@01 $arg2@1568@01) $arg1@1567@01)
        (= (inv@1574@01 $arg0@1566@01 $arg1@1567@01 $arg2@1568@01) $arg2@1568@01))
      (and
        (img@1571@01 $arg0@1566@01 $arg1@1567@01 $arg2@1568@01)
        (img@1573@01 $arg0@1566@01 $arg1@1567@01 $arg2@1568@01)
        (img@1575@01 $arg0@1566@01 $arg1@1567@01 $arg2@1568@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1566@01)
      ($SortWrappers.IntTo$Snap $arg1@1567@01))
    ($SortWrappers.IntTo$Snap $arg2@1568@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1566@01)
      ($SortWrappers.IntTo$Snap $arg1@1567@01))
    ($SortWrappers.IntTo$Snap $arg2@1568@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1571@01 $arg0 $arg1 $arg2)
        (img@1573@01 $arg0 $arg1 $arg2)
        (img@1575@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1570@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1572@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1574@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1570@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1572@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1574@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1570@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1572@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1574@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1570@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1572@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1574@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1570@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1572@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1574@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1478@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1570@01 $arg0 $arg1 $arg2) (inv@1572@01 $arg0 $arg1 $arg2) (inv@1574@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1778|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1570@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1572@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1574@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1571@01 $arg0 $arg1 $arg2)
        (img@1573@01 $arg0 $arg1 $arg2)
        (img@1575@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1570@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1572@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1574@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@1569@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1570@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1572@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1574@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1779|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@1576@01 Int)
(declare-const $arg1@1577@01 Int)
(declare-const $arg2@1578@01 Int)
(push) ; 20
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1579@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef138|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef139|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1576@01)
    ($SortWrappers.IntTo$Snap $arg1@1577@01))
  ($SortWrappers.IntTo$Snap $arg2@1578@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1576@01)
    ($SortWrappers.IntTo$Snap $arg1@1577@01))
  ($SortWrappers.IntTo$Snap $arg2@1578@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1576@01)
      ($SortWrappers.IntTo$Snap $arg1@1577@01))
    ($SortWrappers.IntTo$Snap $arg2@1578@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1580@01 (Int Int Int) Int)
(declare-fun img@1581@01 (Int Int Int) Bool)
(declare-fun inv@1582@01 (Int Int Int) Int)
(declare-fun img@1583@01 (Int Int Int) Bool)
(declare-fun inv@1584@01 (Int Int Int) Int)
(declare-fun img@1585@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef138|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef139|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1576@01 Int) ($arg1@1577@01 Int) ($arg2@1578@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1576@01)
          ($SortWrappers.IntTo$Snap $arg1@1577@01))
        ($SortWrappers.IntTo$Snap $arg2@1578@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1576@01)
        ($SortWrappers.IntTo$Snap $arg1@1577@01))
      ($SortWrappers.IntTo$Snap $arg2@1578@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1576@01)
        ($SortWrappers.IntTo$Snap $arg1@1577@01))
      ($SortWrappers.IntTo$Snap $arg2@1578@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1576@01)
      ($SortWrappers.IntTo$Snap $arg1@1577@01))
    ($SortWrappers.IntTo$Snap $arg2@1578@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1576@01)
      ($SortWrappers.IntTo$Snap $arg1@1577@01))
    ($SortWrappers.IntTo$Snap $arg2@1578@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1576@01 Int) ($arg1@1577@01 Int) ($arg2@1578@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1576@01)
          ($SortWrappers.IntTo$Snap $arg1@1577@01))
        ($SortWrappers.IntTo$Snap $arg2@1578@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1576@01)
            ($SortWrappers.IntTo$Snap $arg1@1577@01))
          ($SortWrappers.IntTo$Snap $arg2@1578@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1576@01)
            ($SortWrappers.IntTo$Snap $arg1@1577@01))
          ($SortWrappers.IntTo$Snap $arg2@1578@01))))))
  
  :qid |quant-u-1780|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1576@01 Int) ($arg11@1577@01 Int) ($arg21@1578@01 Int) ($arg02@1576@01 Int) ($arg12@1577@01 Int) ($arg22@1578@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1576@01)
                ($SortWrappers.IntTo$Snap $arg11@1577@01))
              ($SortWrappers.IntTo$Snap $arg21@1578@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1576@01)
              ($SortWrappers.IntTo$Snap $arg11@1577@01))
            ($SortWrappers.IntTo$Snap $arg21@1578@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1576@01)
              ($SortWrappers.IntTo$Snap $arg11@1577@01))
            ($SortWrappers.IntTo$Snap $arg21@1578@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1576@01)
              ($SortWrappers.IntTo$Snap $arg11@1577@01))
            ($SortWrappers.IntTo$Snap $arg21@1578@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1576@01)
                ($SortWrappers.IntTo$Snap $arg12@1577@01))
              ($SortWrappers.IntTo$Snap $arg22@1578@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1576@01)
              ($SortWrappers.IntTo$Snap $arg12@1577@01))
            ($SortWrappers.IntTo$Snap $arg22@1578@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1576@01)
              ($SortWrappers.IntTo$Snap $arg12@1577@01))
            ($SortWrappers.IntTo$Snap $arg22@1578@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1576@01)
              ($SortWrappers.IntTo$Snap $arg12@1577@01))
            ($SortWrappers.IntTo$Snap $arg22@1578@01)))))
      (and
        (and (= $arg01@1576@01 $arg02@1576@01) (= $arg11@1577@01 $arg12@1577@01))
        (= $arg21@1578@01 $arg22@1578@01)))
    (and
      (and (= $arg01@1576@01 $arg02@1576@01) (= $arg11@1577@01 $arg12@1577@01))
      (= $arg21@1578@01 $arg22@1578@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1576@01 Int) ($arg1@1577@01 Int) ($arg2@1578@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1576@01)
            ($SortWrappers.IntTo$Snap $arg1@1577@01))
          ($SortWrappers.IntTo$Snap $arg2@1578@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1576@01)
            ($SortWrappers.IntTo$Snap $arg1@1577@01))
          ($SortWrappers.IntTo$Snap $arg2@1578@01)))))
    (and
      (and
        (= (inv@1580@01 $arg0@1576@01 $arg1@1577@01 $arg2@1578@01) $arg0@1576@01)
        (= (inv@1582@01 $arg0@1576@01 $arg1@1577@01 $arg2@1578@01) $arg1@1577@01)
        (= (inv@1584@01 $arg0@1576@01 $arg1@1577@01 $arg2@1578@01) $arg2@1578@01))
      (and
        (img@1581@01 $arg0@1576@01 $arg1@1577@01 $arg2@1578@01)
        (img@1583@01 $arg0@1576@01 $arg1@1577@01 $arg2@1578@01)
        (img@1585@01 $arg0@1576@01 $arg1@1577@01 $arg2@1578@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1576@01)
      ($SortWrappers.IntTo$Snap $arg1@1577@01))
    ($SortWrappers.IntTo$Snap $arg2@1578@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1576@01)
      ($SortWrappers.IntTo$Snap $arg1@1577@01))
    ($SortWrappers.IntTo$Snap $arg2@1578@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1581@01 $arg0 $arg1 $arg2)
        (img@1583@01 $arg0 $arg1 $arg2)
        (img@1585@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1580@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1582@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1584@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1580@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1582@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1584@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1580@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1582@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1584@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1580@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1582@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1584@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1580@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1582@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1584@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1490@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1580@01 $arg0 $arg1 $arg2) (inv@1582@01 $arg0 $arg1 $arg2) (inv@1584@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1781|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1580@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1582@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1584@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1581@01 $arg0 $arg1 $arg2)
        (img@1583@01 $arg0 $arg1 $arg2)
        (img@1585@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1580@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1582@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1584@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@1579@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1580@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1582@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1584@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1782|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@1586@01 Int)
(declare-const $arg1@1587@01 Int)
(declare-const $arg2@1588@01 Int)
(push) ; 20
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1589@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef140|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef141|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1586@01)
    ($SortWrappers.IntTo$Snap $arg1@1587@01))
  ($SortWrappers.IntTo$Snap $arg2@1588@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1586@01)
    ($SortWrappers.IntTo$Snap $arg1@1587@01))
  ($SortWrappers.IntTo$Snap $arg2@1588@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1586@01)
      ($SortWrappers.IntTo$Snap $arg1@1587@01))
    ($SortWrappers.IntTo$Snap $arg2@1588@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1590@01 (Int Int Int) Int)
(declare-fun img@1591@01 (Int Int Int) Bool)
(declare-fun inv@1592@01 (Int Int Int) Int)
(declare-fun img@1593@01 (Int Int Int) Bool)
(declare-fun inv@1594@01 (Int Int Int) Int)
(declare-fun img@1595@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef140|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef141|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1586@01 Int) ($arg1@1587@01 Int) ($arg2@1588@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1586@01)
          ($SortWrappers.IntTo$Snap $arg1@1587@01))
        ($SortWrappers.IntTo$Snap $arg2@1588@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1586@01)
        ($SortWrappers.IntTo$Snap $arg1@1587@01))
      ($SortWrappers.IntTo$Snap $arg2@1588@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1586@01)
        ($SortWrappers.IntTo$Snap $arg1@1587@01))
      ($SortWrappers.IntTo$Snap $arg2@1588@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1586@01)
      ($SortWrappers.IntTo$Snap $arg1@1587@01))
    ($SortWrappers.IntTo$Snap $arg2@1588@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1586@01)
      ($SortWrappers.IntTo$Snap $arg1@1587@01))
    ($SortWrappers.IntTo$Snap $arg2@1588@01))))
  :qid |e$Transfer-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1586@01 Int) ($arg1@1587@01 Int) ($arg2@1588@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1586@01)
          ($SortWrappers.IntTo$Snap $arg1@1587@01))
        ($SortWrappers.IntTo$Snap $arg2@1588@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1586@01)
            ($SortWrappers.IntTo$Snap $arg1@1587@01))
          ($SortWrappers.IntTo$Snap $arg2@1588@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1586@01)
            ($SortWrappers.IntTo$Snap $arg1@1587@01))
          ($SortWrappers.IntTo$Snap $arg2@1588@01))))))
  
  :qid |quant-u-1783|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1586@01 Int) ($arg11@1587@01 Int) ($arg21@1588@01 Int) ($arg02@1586@01 Int) ($arg12@1587@01 Int) ($arg22@1588@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1586@01)
                ($SortWrappers.IntTo$Snap $arg11@1587@01))
              ($SortWrappers.IntTo$Snap $arg21@1588@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1586@01)
              ($SortWrappers.IntTo$Snap $arg11@1587@01))
            ($SortWrappers.IntTo$Snap $arg21@1588@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1586@01)
              ($SortWrappers.IntTo$Snap $arg11@1587@01))
            ($SortWrappers.IntTo$Snap $arg21@1588@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1586@01)
              ($SortWrappers.IntTo$Snap $arg11@1587@01))
            ($SortWrappers.IntTo$Snap $arg21@1588@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1586@01)
                ($SortWrappers.IntTo$Snap $arg12@1587@01))
              ($SortWrappers.IntTo$Snap $arg22@1588@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1586@01)
              ($SortWrappers.IntTo$Snap $arg12@1587@01))
            ($SortWrappers.IntTo$Snap $arg22@1588@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1586@01)
              ($SortWrappers.IntTo$Snap $arg12@1587@01))
            ($SortWrappers.IntTo$Snap $arg22@1588@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1586@01)
              ($SortWrappers.IntTo$Snap $arg12@1587@01))
            ($SortWrappers.IntTo$Snap $arg22@1588@01)))))
      (and
        (and (= $arg01@1586@01 $arg02@1586@01) (= $arg11@1587@01 $arg12@1587@01))
        (= $arg21@1588@01 $arg22@1588@01)))
    (and
      (and (= $arg01@1586@01 $arg02@1586@01) (= $arg11@1587@01 $arg12@1587@01))
      (= $arg21@1588@01 $arg22@1588@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1586@01 Int) ($arg1@1587@01 Int) ($arg2@1588@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1586@01)
            ($SortWrappers.IntTo$Snap $arg1@1587@01))
          ($SortWrappers.IntTo$Snap $arg2@1588@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1586@01)
            ($SortWrappers.IntTo$Snap $arg1@1587@01))
          ($SortWrappers.IntTo$Snap $arg2@1588@01)))))
    (and
      (and
        (= (inv@1590@01 $arg0@1586@01 $arg1@1587@01 $arg2@1588@01) $arg0@1586@01)
        (= (inv@1592@01 $arg0@1586@01 $arg1@1587@01 $arg2@1588@01) $arg1@1587@01)
        (= (inv@1594@01 $arg0@1586@01 $arg1@1587@01 $arg2@1588@01) $arg2@1588@01))
      (and
        (img@1591@01 $arg0@1586@01 $arg1@1587@01 $arg2@1588@01)
        (img@1593@01 $arg0@1586@01 $arg1@1587@01 $arg2@1588@01)
        (img@1595@01 $arg0@1586@01 $arg1@1587@01 $arg2@1588@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1586@01)
      ($SortWrappers.IntTo$Snap $arg1@1587@01))
    ($SortWrappers.IntTo$Snap $arg2@1588@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1586@01)
      ($SortWrappers.IntTo$Snap $arg1@1587@01))
    ($SortWrappers.IntTo$Snap $arg2@1588@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1591@01 $arg0 $arg1 $arg2)
        (img@1593@01 $arg0 $arg1 $arg2)
        (img@1595@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1590@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1592@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1594@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1590@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1592@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1594@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1590@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1592@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1594@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1590@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1592@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1594@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1590@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1592@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1594@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1502@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1590@01 $arg0 $arg1 $arg2) (inv@1592@01 $arg0 $arg1 $arg2) (inv@1594@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1784|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1590@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1592@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1594@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1591@01 $arg0 $arg1 $arg2)
        (img@1593@01 $arg0 $arg1 $arg2)
        (img@1595@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1590@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1592@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1594@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@1589@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1590@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1592@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1594@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1785|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@1596@01 Int)
(declare-const $arg1@1597@01 Int)
(declare-const $arg2@1598@01 Int)
(push) ; 20
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1599@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef142|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef143|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1596@01)
    ($SortWrappers.IntTo$Snap $arg1@1597@01))
  ($SortWrappers.IntTo$Snap $arg2@1598@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1596@01)
    ($SortWrappers.IntTo$Snap $arg1@1597@01))
  ($SortWrappers.IntTo$Snap $arg2@1598@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1596@01)
      ($SortWrappers.IntTo$Snap $arg1@1597@01))
    ($SortWrappers.IntTo$Snap $arg2@1598@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1600@01 (Int Int Int) Int)
(declare-fun img@1601@01 (Int Int Int) Bool)
(declare-fun inv@1602@01 (Int Int Int) Int)
(declare-fun img@1603@01 (Int Int Int) Bool)
(declare-fun inv@1604@01 (Int Int Int) Int)
(declare-fun img@1605@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef142|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef143|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1596@01 Int) ($arg1@1597@01 Int) ($arg2@1598@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1596@01)
          ($SortWrappers.IntTo$Snap $arg1@1597@01))
        ($SortWrappers.IntTo$Snap $arg2@1598@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1596@01)
        ($SortWrappers.IntTo$Snap $arg1@1597@01))
      ($SortWrappers.IntTo$Snap $arg2@1598@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1596@01)
        ($SortWrappers.IntTo$Snap $arg1@1597@01))
      ($SortWrappers.IntTo$Snap $arg2@1598@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1596@01)
      ($SortWrappers.IntTo$Snap $arg1@1597@01))
    ($SortWrappers.IntTo$Snap $arg2@1598@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1596@01)
      ($SortWrappers.IntTo$Snap $arg1@1597@01))
    ($SortWrappers.IntTo$Snap $arg2@1598@01))))
  :qid |e$Approval-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1596@01 Int) ($arg1@1597@01 Int) ($arg2@1598@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1596@01)
          ($SortWrappers.IntTo$Snap $arg1@1597@01))
        ($SortWrappers.IntTo$Snap $arg2@1598@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1596@01)
            ($SortWrappers.IntTo$Snap $arg1@1597@01))
          ($SortWrappers.IntTo$Snap $arg2@1598@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1596@01)
            ($SortWrappers.IntTo$Snap $arg1@1597@01))
          ($SortWrappers.IntTo$Snap $arg2@1598@01))))))
  
  :qid |quant-u-1786|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1596@01 Int) ($arg11@1597@01 Int) ($arg21@1598@01 Int) ($arg02@1596@01 Int) ($arg12@1597@01 Int) ($arg22@1598@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1596@01)
                ($SortWrappers.IntTo$Snap $arg11@1597@01))
              ($SortWrappers.IntTo$Snap $arg21@1598@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1596@01)
              ($SortWrappers.IntTo$Snap $arg11@1597@01))
            ($SortWrappers.IntTo$Snap $arg21@1598@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1596@01)
              ($SortWrappers.IntTo$Snap $arg11@1597@01))
            ($SortWrappers.IntTo$Snap $arg21@1598@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1596@01)
              ($SortWrappers.IntTo$Snap $arg11@1597@01))
            ($SortWrappers.IntTo$Snap $arg21@1598@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1596@01)
                ($SortWrappers.IntTo$Snap $arg12@1597@01))
              ($SortWrappers.IntTo$Snap $arg22@1598@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1596@01)
              ($SortWrappers.IntTo$Snap $arg12@1597@01))
            ($SortWrappers.IntTo$Snap $arg22@1598@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1596@01)
              ($SortWrappers.IntTo$Snap $arg12@1597@01))
            ($SortWrappers.IntTo$Snap $arg22@1598@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1596@01)
              ($SortWrappers.IntTo$Snap $arg12@1597@01))
            ($SortWrappers.IntTo$Snap $arg22@1598@01)))))
      (and
        (and (= $arg01@1596@01 $arg02@1596@01) (= $arg11@1597@01 $arg12@1597@01))
        (= $arg21@1598@01 $arg22@1598@01)))
    (and
      (and (= $arg01@1596@01 $arg02@1596@01) (= $arg11@1597@01 $arg12@1597@01))
      (= $arg21@1598@01 $arg22@1598@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1596@01 Int) ($arg1@1597@01 Int) ($arg2@1598@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1596@01)
            ($SortWrappers.IntTo$Snap $arg1@1597@01))
          ($SortWrappers.IntTo$Snap $arg2@1598@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1596@01)
            ($SortWrappers.IntTo$Snap $arg1@1597@01))
          ($SortWrappers.IntTo$Snap $arg2@1598@01)))))
    (and
      (and
        (= (inv@1600@01 $arg0@1596@01 $arg1@1597@01 $arg2@1598@01) $arg0@1596@01)
        (= (inv@1602@01 $arg0@1596@01 $arg1@1597@01 $arg2@1598@01) $arg1@1597@01)
        (= (inv@1604@01 $arg0@1596@01 $arg1@1597@01 $arg2@1598@01) $arg2@1598@01))
      (and
        (img@1601@01 $arg0@1596@01 $arg1@1597@01 $arg2@1598@01)
        (img@1603@01 $arg0@1596@01 $arg1@1597@01 $arg2@1598@01)
        (img@1605@01 $arg0@1596@01 $arg1@1597@01 $arg2@1598@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1596@01)
      ($SortWrappers.IntTo$Snap $arg1@1597@01))
    ($SortWrappers.IntTo$Snap $arg2@1598@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1596@01)
      ($SortWrappers.IntTo$Snap $arg1@1597@01))
    ($SortWrappers.IntTo$Snap $arg2@1598@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1601@01 $arg0 $arg1 $arg2)
        (img@1603@01 $arg0 $arg1 $arg2)
        (img@1605@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1600@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1602@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1604@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1600@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1602@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1604@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1600@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1602@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1604@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1600@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1602@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1604@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1600@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1602@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1604@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1514@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1600@01 $arg0 $arg1 $arg2) (inv@1602@01 $arg0 $arg1 $arg2) (inv@1604@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1787|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1600@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1602@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1604@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1601@01 $arg0 $arg1 $arg2)
        (img@1603@01 $arg0 $arg1 $arg2)
        (img@1605@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1600@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1602@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1604@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@1599@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1600@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1602@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1604@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1788|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc
(push) ; 20
(set-option :timeout 10)
(assert (not (not l$i0$send_fail$1@1389@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not l$i0$send_fail$1@1389@01))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
; [then-branch: 420 | l$i0$send_fail$1@1389@01 | live]
; [else-branch: 420 | !(l$i0$send_fail$1@1389@01) | live]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 420 | l$i0$send_fail$1@1389@01]
(assert l$i0$send_fail$1@1389@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@1606@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
; [then-branch: 421 | True | live]
; [else-branch: 421 | False | dead]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 421 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1607@01 $Snap)
(assert (= $t@1607@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1608@01 $Struct)
(assert (=
  self@1608@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 21
; [then-branch: 422 | False | dead]
; [else-branch: 422 | True | live]
(set-option :timeout 0)
(push) ; 21
; [else-branch: 422 | True]
(pop) ; 21
(pop) ; 20
(push) ; 20
; [else-branch: 420 | !(l$i0$send_fail$1@1389@01)]
(assert (not l$i0$send_fail$1@1389@01))
(pop) ; 20
; [eval] !l$i0$send_fail$1
(push) ; 20
(set-option :timeout 10)
(assert (not l$i0$send_fail$1@1389@01))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (not l$i0$send_fail$1@1389@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
; [then-branch: 423 | !(l$i0$send_fail$1@1389@01) | live]
; [else-branch: 423 | l$i0$send_fail$1@1389@01 | live]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 423 | !(l$i0$send_fail$1@1389@01)]
(assert (not l$i0$send_fail$1@1389@01))
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; i3$$pre_self := self
; [exec]
; i3$$pre_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$1
; [exec]
; $old_$contracts := $contracts
; [exec]
; self := l$i0$havoc$2
; [exec]
; $contracts := l$i0$havoc$3
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@1609@01 $Snap)
(assert (= $t@1609@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (=
  (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 0)))
  32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@1610@01 $Snap)
(assert (= $t@1610@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (=
  (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 1)))
  32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1611@01 $Snap)
(assert (= $t@1611@01 ($Snap.combine ($Snap.first $t@1611@01) ($Snap.second $t@1611@01))))
(assert (= ($Snap.first $t@1611@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 2))))
(assert (= ($Snap.second $t@1611@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1612@01 $Snap)
(assert (= $t@1612@01 ($Snap.combine ($Snap.first $t@1612@01) ($Snap.second $t@1612@01))))
(assert (= ($Snap.first $t@1612@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 3))))
(assert (= ($Snap.second $t@1612@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1613@01 $Snap)
(assert (= $t@1613@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@1614@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 22
; [then-branch: 424 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 4)), $q2@1614@01)) | live]
; [else-branch: 424 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 4)), $q2@1614@01) | live]
(push) ; 23
; [then-branch: 424 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 4)), $q2@1614@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1614@01))))
(pop) ; 23
(push) ; 23
; [else-branch: 424 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 4)), $q2@1614@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1614@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1614@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1614@01)))))
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1614@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1614@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1614@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1614@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2045@11@2045@345-aux|)))
(assert (forall (($q2@1614@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1614@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1614@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1614@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2045@11@2045@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@1615@01 $Snap)
(assert (= $t@1615@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@1616@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1616@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1616@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 4)) $q2@1616@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2046@11@2046@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@1617@01 $Snap)
(assert (= $t@1617@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@1618@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@1619@01 Int)
(push) ; 22
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 23
; [then-branch: 425 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@1394@01, 5)), $q3@1618@01), $q4@1619@01)) | live]
; [else-branch: 425 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@1394@01, 5)), $q3@1618@01), $q4@1619@01) | live]
(push) ; 24
; [then-branch: 425 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@1394@01, 5)), $q3@1618@01), $q4@1619@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01))))
(pop) ; 24
(push) ; 24
; [else-branch: 425 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@1394@01, 5)), $q3@1618@01), $q4@1619@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01)))))
(pop) ; 22
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@1619@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2047@131@2047@597-aux|)))
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1618@01 Int)) (!
  (forall (($q4@1619@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2047@131@2047@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2047@11@2047@598-aux|)))
(assert (forall (($q3@1618@01 Int)) (!
  (forall (($q4@1619@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01) $q4@1619@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2047@131@2047@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1618@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2047@11@2047@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@1620@01 $Snap)
(assert (= $t@1620@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@1621@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@1622@01 Int)
(push) ; 22
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 22
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1621@01 Int)) (!
  (forall (($q4@1622@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1621@01) $q4@1622@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1621@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1621@01) $q4@1622@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2048@131@2048@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1394@01 5)) $q3@1621@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2048@11@2048@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1623@01 $Snap)
(assert (= $t@1623@01 ($Snap.combine ($Snap.first $t@1623@01) ($Snap.second $t@1623@01))))
(assert (= ($Snap.first $t@1623@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 6))))
(assert (= ($Snap.second $t@1623@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1624@01 $Snap)
(assert (= $t@1624@01 ($Snap.combine ($Snap.first $t@1624@01) ($Snap.second $t@1624@01))))
(assert (= ($Snap.first $t@1624@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 7))))
(assert (= ($Snap.second $t@1624@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1625@01 $Snap)
(assert (= $t@1625@01 ($Snap.combine ($Snap.first $t@1625@01) ($Snap.second $t@1625@01))))
(assert (= ($Snap.first $t@1625@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 8))))
(assert (= ($Snap.second $t@1625@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@1626@01 $Snap)
(assert (= $t@1626@01 ($Snap.combine ($Snap.first $t@1626@01) ($Snap.second $t@1626@01))))
(assert (= ($Snap.first $t@1626@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 9))))
(assert (= ($Snap.second $t@1626@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1627@01 $Snap)
(assert (= $t@1627@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@1628@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 22
; [then-branch: 426 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 11)), $q5@1628@01)) | live]
; [else-branch: 426 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 11)), $q5@1628@01) | live]
(push) ; 23
; [then-branch: 426 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 11)), $q5@1628@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1628@01))))
(pop) ; 23
(push) ; 23
; [else-branch: 426 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 11)), $q5@1628@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1628@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1628@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1628@01)))))
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1628@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1628@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1628@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1628@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2053@11@2053@348-aux|)))
(assert (forall (($q5@1628@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1628@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1628@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1628@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2053@11@2053@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@1629@01 $Snap)
(assert (= $t@1629@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@1630@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1630@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1630@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $q5@1630@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2054@11@2054@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1631@01 $Snap)
(assert (= $t@1631@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@1632@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 22
; [then-branch: 427 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 12)), $q6@1632@01)) | live]
; [else-branch: 427 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 12)), $q6@1632@01) | live]
(push) ; 23
; [then-branch: 427 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 12)), $q6@1632@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1632@01))))
(pop) ; 23
(push) ; 23
; [else-branch: 427 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1394@01, 12)), $q6@1632@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1632@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1632@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1632@01)))))
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1632@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1632@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1632@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1632@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2055@11@2055@348-aux|)))
(assert (forall (($q6@1632@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1632@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1632@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1632@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2055@11@2055@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@1633@01 $Snap)
(assert (= $t@1633@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@1634@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1634@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1634@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 12)) $q6@1634@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2056@11@2056@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@1635@01 $Snap)
(assert (= $t@1635@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@1636@01 $Snap)
(assert (= $t@1636@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@1637@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($old_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($old_self, 11)
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($a@1637@01 Int)) (!
  (>=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $a@1637@01)
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1444@01 11)) $a@1637@01))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1394@01 11)) $a@1637@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2059@11@2059@262|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not l$i0$no_reentrant_call@1396@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not l$i0$no_reentrant_call@1396@01))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
; [then-branch: 428 | l$i0$no_reentrant_call@1396@01 | live]
; [else-branch: 428 | !(l$i0$no_reentrant_call@1396@01) | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 428 | l$i0$no_reentrant_call@1396@01]
(assert l$i0$no_reentrant_call@1396@01)
; [exec]
; self := $old_self
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$4
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$5
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$i0$raw_ret$1
(push) ; 22
(set-option :timeout 10)
(assert (not l$i0$raw_ret$1@1390@01))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not (not l$i0$raw_ret$1@1390@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 429 | !(l$i0$raw_ret$1@1390@01) | live]
; [else-branch: 429 | l$i0$raw_ret$1@1390@01 | live]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 429 | !(l$i0$raw_ret$1@1390@01)]
(assert (not l$i0$raw_ret$1@1390@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 23
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
; [then-branch: 430 | True | live]
; [else-branch: 430 | False | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 430 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1638@01 $Snap)
(assert (= $t@1638@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1639@01 $Struct)
(assert (=
  self@1639@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 23
; [then-branch: 431 | False | dead]
; [else-branch: 431 | True | live]
(set-option :timeout 0)
(push) ; 23
; [else-branch: 431 | True]
(pop) ; 23
(pop) ; 22
(push) ; 22
; [else-branch: 429 | l$i0$raw_ret$1@1390@01]
(assert l$i0$raw_ret$1@1390@01)
(pop) ; 22
; [eval] !!l$i0$raw_ret$1
; [eval] !l$i0$raw_ret$1
(push) ; 22
(set-option :timeout 10)
(assert (not (not l$i0$raw_ret$1@1390@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not l$i0$raw_ret$1@1390@01))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 432 | l$i0$raw_ret$1@1390@01 | live]
; [else-branch: 432 | !(l$i0$raw_ret$1@1390@01) | live]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 432 | l$i0$raw_ret$1@1390@01]
(assert l$i0$raw_ret$1@1390@01)
; [exec]
; inhale acc(e$TokenPurchase(l$i0$buyer, l$i0$eth_sold, $unwrap(l$i0$tokens_bought)), write)
; [eval] $unwrap(l$i0$tokens_bought)
(declare-const $t@1640@01 $Snap)
(declare-const sm@1641@01 $PSF<e$TokenPurchase>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$TokenPurchase (as sm@1641@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap l$i0$buyer@1447@01)
      ($SortWrappers.IntTo$Snap l$i0$eth_sold@1445@01))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1543@01))))
  $t@1640@01))
(assert (<=
  $Perm.No
  (ite
    (=
      ($unwrap<Int> l$i0$tokens_bought@1543@01)
      ($unwrap<Int> l$i0$tokens_bought@1543@01))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap l$i0$buyer@1447@01)
    ($SortWrappers.IntTo$Snap l$i0$eth_sold@1445@01))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1543@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap l$i0$buyer@1447@01)
    ($SortWrappers.IntTo$Snap l$i0$eth_sold@1445@01))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1543@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; i0$$res := $unwrap(l$i0$tokens_bought)
; [eval] $unwrap(l$i0$tokens_bought)
(declare-const i0$$res@1642@01 Int)
(assert (= i0$$res@1642@01 ($unwrap<Int> l$i0$tokens_bought@1543@01)))
; [exec]
; label i0$return
; [exec]
; label return
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not $out_of_gas@1399@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not $out_of_gas@1399@01))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 433 | $out_of_gas@1399@01 | live]
; [else-branch: 433 | !($out_of_gas@1399@01) | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 433 | $out_of_gas@1399@01]
(assert $out_of_gas@1399@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 24
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 434 | True | live]
; [else-branch: 434 | False | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 434 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1643@01 $Snap)
(assert (= $t@1643@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1644@01 $Struct)
(assert (=
  self@1644@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 24
; [then-branch: 435 | False | dead]
; [else-branch: 435 | True | live]
(set-option :timeout 0)
(push) ; 24
; [else-branch: 435 | True]
(pop) ; 24
(pop) ; 23
(push) ; 23
; [else-branch: 433 | !($out_of_gas@1399@01)]
(assert (not $out_of_gas@1399@01))
(pop) ; 23
; [eval] !$out_of_gas
(push) ; 23
(set-option :timeout 10)
(assert (not $out_of_gas@1399@01))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not $out_of_gas@1399@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 436 | !($out_of_gas@1399@01) | live]
; [else-branch: 436 | $out_of_gas@1399@01 | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 436 | !($out_of_gas@1399@01)]
(assert (not $out_of_gas@1399@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 437 | False | dead]
; [else-branch: 437 | True | live]
(push) ; 24
; [else-branch: 437 | True]
(pop) ; 24
(push) ; 24
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 438 | True | live]
; [else-branch: 438 | False | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 438 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1645@01 $Snap)
(assert (= $t@1645@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1646@01 $Struct)
(assert (=
  self@1646@01
  ($struct_set<$Struct> self@1444@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1444@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 24
(pop) ; 23
(set-option :timeout 0)
(push) ; 23
; [else-branch: 436 | $out_of_gas@1399@01]
(assert $out_of_gas@1399@01)
(pop) ; 23
(pop) ; 22
(push) ; 22
; [else-branch: 432 | !(l$i0$raw_ret$1@1390@01)]
(assert (not l$i0$raw_ret$1@1390@01))
(pop) ; 22
(pop) ; 21
(push) ; 21
; [else-branch: 428 | !(l$i0$no_reentrant_call@1396@01)]
(assert (not l$i0$no_reentrant_call@1396@01))
(pop) ; 21
; [eval] !l$i0$no_reentrant_call
(push) ; 21
(set-option :timeout 10)
(assert (not l$i0$no_reentrant_call@1396@01))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not l$i0$no_reentrant_call@1396@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 439 | !(l$i0$no_reentrant_call@1396@01) | live]
; [else-branch: 439 | l$i0$no_reentrant_call@1396@01 | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 439 | !(l$i0$no_reentrant_call@1396@01)]
(assert (not l$i0$no_reentrant_call@1396@01))
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$4
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$5
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$i0$raw_ret$1
(push) ; 22
(set-option :timeout 10)
(assert (not l$i0$raw_ret$1@1390@01))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not (not l$i0$raw_ret$1@1390@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 440 | !(l$i0$raw_ret$1@1390@01) | live]
; [else-branch: 440 | l$i0$raw_ret$1@1390@01 | live]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 440 | !(l$i0$raw_ret$1@1390@01)]
(assert (not l$i0$raw_ret$1@1390@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 23
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
; [then-branch: 441 | True | live]
; [else-branch: 441 | False | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 441 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1647@01 $Snap)
(assert (= $t@1647@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1648@01 $Struct)
(assert (=
  self@1648@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 23
; [then-branch: 442 | False | dead]
; [else-branch: 442 | True | live]
(set-option :timeout 0)
(push) ; 23
; [else-branch: 442 | True]
(pop) ; 23
(pop) ; 22
(push) ; 22
; [else-branch: 440 | l$i0$raw_ret$1@1390@01]
(assert l$i0$raw_ret$1@1390@01)
(pop) ; 22
; [eval] !!l$i0$raw_ret$1
; [eval] !l$i0$raw_ret$1
(push) ; 22
(set-option :timeout 10)
(assert (not (not l$i0$raw_ret$1@1390@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not l$i0$raw_ret$1@1390@01))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 443 | l$i0$raw_ret$1@1390@01 | live]
; [else-branch: 443 | !(l$i0$raw_ret$1@1390@01) | live]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 443 | l$i0$raw_ret$1@1390@01]
(assert l$i0$raw_ret$1@1390@01)
; [exec]
; inhale acc(e$TokenPurchase(l$i0$buyer, l$i0$eth_sold, $unwrap(l$i0$tokens_bought)), write)
; [eval] $unwrap(l$i0$tokens_bought)
(declare-const $t@1649@01 $Snap)
(declare-const sm@1650@01 $PSF<e$TokenPurchase>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$TokenPurchase (as sm@1650@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap l$i0$buyer@1447@01)
      ($SortWrappers.IntTo$Snap l$i0$eth_sold@1445@01))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1543@01))))
  $t@1649@01))
(assert (<=
  $Perm.No
  (ite
    (=
      ($unwrap<Int> l$i0$tokens_bought@1543@01)
      ($unwrap<Int> l$i0$tokens_bought@1543@01))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1454@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap l$i0$buyer@1447@01)
    ($SortWrappers.IntTo$Snap l$i0$eth_sold@1445@01))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1543@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap l$i0$buyer@1447@01)
    ($SortWrappers.IntTo$Snap l$i0$eth_sold@1445@01))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1543@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; i0$$res := $unwrap(l$i0$tokens_bought)
; [eval] $unwrap(l$i0$tokens_bought)
(declare-const i0$$res@1651@01 Int)
(assert (= i0$$res@1651@01 ($unwrap<Int> l$i0$tokens_bought@1543@01)))
; [exec]
; label i0$return
; [exec]
; label return
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not $out_of_gas@1399@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not $out_of_gas@1399@01))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 444 | $out_of_gas@1399@01 | live]
; [else-branch: 444 | !($out_of_gas@1399@01) | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 444 | $out_of_gas@1399@01]
(assert $out_of_gas@1399@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 24
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 445 | True | live]
; [else-branch: 445 | False | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 445 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1652@01 $Snap)
(assert (= $t@1652@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1653@01 $Struct)
(assert (=
  self@1653@01
  ($struct_set<$Struct> self@1360@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1360@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 24
; [then-branch: 446 | False | dead]
; [else-branch: 446 | True | live]
(set-option :timeout 0)
(push) ; 24
; [else-branch: 446 | True]
(pop) ; 24
(pop) ; 23
(push) ; 23
; [else-branch: 444 | !($out_of_gas@1399@01)]
(assert (not $out_of_gas@1399@01))
(pop) ; 23
; [eval] !$out_of_gas
(push) ; 23
(set-option :timeout 10)
(assert (not $out_of_gas@1399@01))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not $out_of_gas@1399@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 447 | !($out_of_gas@1399@01) | live]
; [else-branch: 447 | $out_of_gas@1399@01 | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 447 | !($out_of_gas@1399@01)]
(assert (not $out_of_gas@1399@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 448 | False | dead]
; [else-branch: 448 | True | live]
(push) ; 24
; [else-branch: 448 | True]
(pop) ; 24
(push) ; 24
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 449 | True | live]
; [else-branch: 449 | False | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 449 | True]
; [exec]
; inhale l$havoc >= 0
(declare-const $t@1654@01 $Snap)
(assert (= $t@1654@01 $Snap.unit))
; [eval] l$havoc >= 0
(assert (>= l$havoc@1400@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1655@01 $Struct)
(assert (=
  self@1655@01
  ($struct_set<$Struct> l$i0$havoc$2@1394@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1394@01 8))
    l$havoc@1400@01))))
; [exec]
; $contracts := l$havoc$1
(pop) ; 24
(pop) ; 23
(set-option :timeout 0)
(push) ; 23
; [else-branch: 447 | $out_of_gas@1399@01]
(assert $out_of_gas@1399@01)
(pop) ; 23
(pop) ; 22
(push) ; 22
; [else-branch: 443 | !(l$i0$raw_ret$1@1390@01)]
(assert (not l$i0$raw_ret$1@1390@01))
(pop) ; 22
(pop) ; 21
(push) ; 21
; [else-branch: 439 | l$i0$no_reentrant_call@1396@01]
(assert l$i0$no_reentrant_call@1396@01)
(pop) ; 21
(pop) ; 20
(push) ; 20
; [else-branch: 423 | l$i0$send_fail$1@1389@01]
(assert l$i0$send_fail$1@1389@01)
(pop) ; 20
(pop) ; 19
(push) ; 19
; [else-branch: 419 | !($unwrap[Int](l$i0$tokens_bought@1543@01) >= 1)]
(assert (not (>= ($unwrap<Int> l$i0$tokens_bought@1543@01) 1)))
(pop) ; 19
(pop) ; 18
(pop) ; 17
(push) ; 17
; [else-branch: 413 | $div[Int]($unwrap[Int](l$i2$numerator@1536@01), l$i2$denominator@1541@01, $unwrap[Int](l$i2$numerator@1536@01) / l$i2$denominator@1541@01) < 0]
(assert (<
  ($div<Int> ($unwrap<Int> l$i2$numerator@1536@01) l$i2$denominator@1541@01 (div
    ($unwrap<Int> l$i2$numerator@1536@01)
    l$i2$denominator@1541@01))
  0))
(pop) ; 17
(pop) ; 16
(pop) ; 15
(push) ; 15
; [else-branch: 409 | l$i2$input_reserve@1528@01 * 1000 + l$i2$input_amount_with_fee@1533@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+ (* l$i2$input_reserve@1528@01 1000) l$i2$input_amount_with_fee@1533@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 15
(pop) ; 14
(pop) ; 13
(push) ; 13
; [else-branch: 403 | l$i2$input_reserve@1528@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (* l$i2$input_reserve@1528@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 13
(pop) ; 12
(pop) ; 11
(push) ; 11
; [else-branch: 397 | l$i2$input_amount_with_fee@1533@01 * $unwrap[Int](l$i0$token_reserve@1527@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (*
    l$i2$input_amount_with_fee@1533@01
    ($unwrap<Int> l$i0$token_reserve@1527@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 11
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 391 | l$i0$eth_sold@1445@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (* l$i0$eth_sold@1445@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 9
(pop) ; 8
(pop) ; 7
(push) ; 7
; [else-branch: 385 | !(l$i2$input_reserve@1528@01 > 0 && $unwrap[Int](l$i0$token_reserve@1527@01) > 0)]
(assert (not
  (and
    (> l$i2$input_reserve@1528@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@1527@01) 0))))
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 375 | l$i0$send_fail@1377@01]
(assert l$i0$send_fail@1377@01)
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 371 | !(l$i0$deadline@1446@01 >= $struct_get[Int]($struct_loc[Int](block@1357@01, 4)) && l$i0$eth_sold@1445@01 > 0)]
(assert (not
  (and
    (>=
      l$i0$deadline@1446@01
      ($struct_get<Int> ($struct_loc<Int> block@1357@01 4)))
    (> l$i0$eth_sold@1445@01 0))))
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- f$ethToTokenSwapInput ----------
(declare-const l$min_tokens@1656@01 $Int)
(declare-const l$deadline@1657@01 $Int)
(declare-const $succ@1658@01 Bool)
(declare-const $res@1659@01 Int)
(declare-const l$min_tokens@1660@01 $Int)
(declare-const l$deadline@1661@01 $Int)
(declare-const $succ@1662@01 Bool)
(declare-const $res@1663@01 Int)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var msg: $Struct
(declare-const msg@1664@01 $Struct)
; [exec]
; var block: $Struct
(declare-const block@1665@01 $Struct)
; [exec]
; var chain: $Struct
(declare-const chain@1666@01 $Struct)
; [exec]
; var tx: $Struct
(declare-const tx@1667@01 $Struct)
; [exec]
; var self: $Struct
(declare-const self@1668@01 $Struct)
; [exec]
; var $contracts: $Map[Int, $Struct]
(declare-const $contracts@1669@01 $Map<Int~_$Struct>)
; [exec]
; var $old_self: $Struct
(declare-const $old_self@1670@01 $Struct)
; [exec]
; var $old_$contracts: $Map[Int, $Struct]
(declare-const $old_$contracts@1671@01 $Map<Int~_$Struct>)
; [exec]
; var $pre_self: $Struct
(declare-const $pre_self@1672@01 $Struct)
; [exec]
; var $pre_$contracts: $Map[Int, $Struct]
(declare-const $pre_$contracts@1673@01 $Map<Int~_$Struct>)
; [exec]
; var $issued_self: $Struct
(declare-const $issued_self@1674@01 $Struct)
; [exec]
; var $issued_$contracts: $Map[Int, $Struct]
(declare-const $issued_$contracts@1675@01 $Map<Int~_$Struct>)
; [exec]
; var $overflow: Bool
(declare-const $overflow@1676@01 Bool)
; [exec]
; var l$i0$eth_sold: Int
(declare-const l$i0$eth_sold@1677@01 Int)
; [exec]
; var l$i0$min_tokens: $Int
(declare-const l$i0$min_tokens@1678@01 $Int)
; [exec]
; var l$i0$deadline: $Int
(declare-const l$i0$deadline@1679@01 $Int)
; [exec]
; var l$i0$buyer: Int
(declare-const l$i0$buyer@1680@01 Int)
; [exec]
; var l$i0$recipient: Int
(declare-const l$i0$recipient@1681@01 Int)
; [exec]
; var i0$$res: Int
(declare-const i0$$res@1682@01 Int)
; [exec]
; var i0$$pre_self: $Struct
(declare-const i0$$pre_self@1683@01 $Struct)
; [exec]
; var i0$$pre_$contracts: $Map[Int, $Struct]
(declare-const i0$$pre_$contracts@1684@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$send_fail: Bool
(declare-const l$i0$send_fail@1685@01 Bool)
; [exec]
; var l$i0$raw_ret: Int
(declare-const l$i0$raw_ret@1686@01 Int)
; [exec]
; var l$i0$token_reserve: $Int
(declare-const l$i0$token_reserve@1687@01 $Int)
; [exec]
; var l$i2$input_amount: Int
(declare-const l$i2$input_amount@1688@01 Int)
; [exec]
; var l$i2$input_reserve: Int
(declare-const l$i2$input_reserve@1689@01 Int)
; [exec]
; var l$i2$output_reserve: $Int
(declare-const l$i2$output_reserve@1690@01 $Int)
; [exec]
; var i2$$res: Int
(declare-const i2$$res@1691@01 Int)
; [exec]
; var l$i2$input_amount_with_fee: Int
(declare-const l$i2$input_amount_with_fee@1692@01 Int)
; [exec]
; var l$i2$numerator: $Int
(declare-const l$i2$numerator@1693@01 $Int)
; [exec]
; var l$i2$denominator: Int
(declare-const l$i2$denominator@1694@01 Int)
; [exec]
; var l$i0$tokens_bought: $Int
(declare-const l$i0$tokens_bought@1695@01 $Int)
; [exec]
; var l$i0$havoc: $Map[Int, $Struct]
(declare-const l$i0$havoc@1696@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$send_fail$1: Bool
(declare-const l$i0$send_fail$1@1697@01 Bool)
; [exec]
; var l$i0$raw_ret$1: Bool
(declare-const l$i0$raw_ret$1@1698@01 Bool)
; [exec]
; var i3$$pre_self: $Struct
(declare-const i3$$pre_self@1699@01 $Struct)
; [exec]
; var i3$$pre_$contracts: $Map[Int, $Struct]
(declare-const i3$$pre_$contracts@1700@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$havoc$1: $Map[Int, $Struct]
(declare-const l$i0$havoc$1@1701@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$havoc$2: $Struct
(declare-const l$i0$havoc$2@1702@01 $Struct)
; [exec]
; var l$i0$havoc$3: $Map[Int, $Struct]
(declare-const l$i0$havoc$3@1703@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$no_reentrant_call: Bool
(declare-const l$i0$no_reentrant_call@1704@01 Bool)
; [exec]
; var l$i0$havoc$4: $Map[Int, $Struct]
(declare-const l$i0$havoc$4@1705@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$havoc$5: $Map[Int, $Struct]
(declare-const l$i0$havoc$5@1706@01 $Map<Int~_$Struct>)
; [exec]
; var $out_of_gas: Bool
(declare-const $out_of_gas@1707@01 Bool)
; [exec]
; var l$havoc: Int
(declare-const l$havoc@1708@01 Int)
; [exec]
; var l$havoc$1: Int
(declare-const l$havoc$1@1709@01 Int)
; [exec]
; var l$havoc$2: $Map[Int, $Struct]
(declare-const l$havoc$2@1710@01 $Map<Int~_$Struct>)
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@1711@01 $Snap)
(assert (= $t@1711@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@1668@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@1712@01 $Snap)
(assert (= $t@1712@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@1668@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1713@01 $Snap)
(assert (= $t@1713@01 ($Snap.combine ($Snap.first $t@1713@01) ($Snap.second $t@1713@01))))
(assert (= ($Snap.first $t@1713@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1668@01 2))))
(assert (= ($Snap.second $t@1713@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1668@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1714@01 $Snap)
(assert (= $t@1714@01 ($Snap.combine ($Snap.first $t@1714@01) ($Snap.second $t@1714@01))))
(assert (= ($Snap.first $t@1714@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1668@01 3))))
(assert (= ($Snap.second $t@1714@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1668@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1715@01 $Snap)
(assert (= $t@1715@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@1716@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 4
; [then-branch: 450 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 4)), $q2@1716@01)) | live]
; [else-branch: 450 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 4)), $q2@1716@01) | live]
(push) ; 5
; [then-branch: 450 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 4)), $q2@1716@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1716@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 450 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 4)), $q2@1716@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1716@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1716@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1716@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1716@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1716@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1716@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1716@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2166@11@2166@345-aux|)))
(assert (forall (($q2@1716@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1716@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1716@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1716@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2166@11@2166@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@1717@01 $Snap)
(assert (= $t@1717@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@1718@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1718@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1718@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 4)) $q2@1718@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2167@11@2167@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@1719@01 $Snap)
(assert (= $t@1719@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@1720@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@1721@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 5
; [then-branch: 451 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1668@01, 5)), $q3@1720@01), $q4@1721@01)) | live]
; [else-branch: 451 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1668@01, 5)), $q3@1720@01), $q4@1721@01) | live]
(push) ; 6
; [then-branch: 451 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1668@01, 5)), $q3@1720@01), $q4@1721@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 451 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1668@01, 5)), $q3@1720@01), $q4@1721@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@1721@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2168@131@2168@597-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1720@01 Int)) (!
  (forall (($q4@1721@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2168@131@2168@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2168@11@2168@598-aux|)))
(assert (forall (($q3@1720@01 Int)) (!
  (forall (($q4@1721@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01) $q4@1721@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2168@131@2168@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1720@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2168@11@2168@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@1722@01 $Snap)
(assert (= $t@1722@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@1723@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@1724@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1723@01 Int)) (!
  (forall (($q4@1724@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1723@01) $q4@1724@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1723@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1723@01) $q4@1724@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2169@131@2169@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1668@01 5)) $q3@1723@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2169@11@2169@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1725@01 $Snap)
(assert (= $t@1725@01 ($Snap.combine ($Snap.first $t@1725@01) ($Snap.second $t@1725@01))))
(assert (= ($Snap.first $t@1725@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1668@01 6))))
(assert (= ($Snap.second $t@1725@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1668@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1726@01 $Snap)
(assert (= $t@1726@01 ($Snap.combine ($Snap.first $t@1726@01) ($Snap.second $t@1726@01))))
(assert (= ($Snap.first $t@1726@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1668@01 7))))
(assert (= ($Snap.second $t@1726@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1668@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1727@01 $Snap)
(assert (= $t@1727@01 ($Snap.combine ($Snap.first $t@1727@01) ($Snap.second $t@1727@01))))
(assert (= ($Snap.first $t@1727@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))))
(assert (= ($Snap.second $t@1727@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@1728@01 $Snap)
(assert (= $t@1728@01 ($Snap.combine ($Snap.first $t@1728@01) ($Snap.second $t@1728@01))))
(assert (= ($Snap.first $t@1728@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> self@1668@01 9))))
(assert (= ($Snap.second $t@1728@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1668@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1729@01 $Snap)
(assert (= $t@1729@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@1730@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 4
; [then-branch: 452 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 11)), $q5@1730@01)) | live]
; [else-branch: 452 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 11)), $q5@1730@01) | live]
(push) ; 5
; [then-branch: 452 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 11)), $q5@1730@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1730@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 452 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 11)), $q5@1730@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1730@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1730@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1730@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1730@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1730@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1730@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1730@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2174@11@2174@348-aux|)))
(assert (forall (($q5@1730@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1730@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1730@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1730@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2174@11@2174@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@1731@01 $Snap)
(assert (= $t@1731@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@1732@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1732@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1732@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 11)) $q5@1732@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2175@11@2175@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1733@01 $Snap)
(assert (= $t@1733@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@1734@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 4
; [then-branch: 453 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 12)), $q6@1734@01)) | live]
; [else-branch: 453 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 12)), $q6@1734@01) | live]
(push) ; 5
; [then-branch: 453 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 12)), $q6@1734@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1734@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 453 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1668@01, 12)), $q6@1734@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1734@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1734@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1734@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1734@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1734@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1734@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1734@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2176@11@2176@348-aux|)))
(assert (forall (($q6@1734@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1734@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1734@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1734@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2176@11@2176@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@1735@01 $Snap)
(assert (= $t@1735@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@1736@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1736@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1736@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1668@01 12)) $q6@1736@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2177@11@2177@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@1737@01 $Snap)
(assert (= $t@1737@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> self@1668@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $self_address() &&
;   $self_address() <= 1461501637330902918203684832716283019655932542975
(declare-const $t@1738@01 $Snap)
(assert (= $t@1738@01 ($Snap.combine ($Snap.first $t@1738@01) ($Snap.second $t@1738@01))))
(assert (= ($Snap.first $t@1738@01) $Snap.unit))
; [eval] 0 <= $self_address()
; [eval] $self_address()
(assert (<= 0 (as $self_address<Int>  Int)))
(assert (= ($Snap.second $t@1738@01) $Snap.unit))
; [eval] $self_address() <= 1461501637330902918203684832716283019655932542975
; [eval] $self_address()
(assert (<=
  (as $self_address<Int>  Int)
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$min_tokens) &&
;   $unwrap(l$min_tokens) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1739@01 $Snap)
(assert (= $t@1739@01 ($Snap.combine ($Snap.first $t@1739@01) ($Snap.second $t@1739@01))))
(assert (= ($Snap.first $t@1739@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$min_tokens)
; [eval] $unwrap(l$min_tokens)
(assert (<= 0 ($unwrap<Int> l$min_tokens@1660@01)))
(assert (= ($Snap.second $t@1739@01) $Snap.unit))
; [eval] $unwrap(l$min_tokens) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$min_tokens)
(assert (<=
  ($unwrap<Int> l$min_tokens@1660@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$deadline) &&
;   $unwrap(l$deadline) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1740@01 $Snap)
(assert (= $t@1740@01 ($Snap.combine ($Snap.first $t@1740@01) ($Snap.second $t@1740@01))))
(assert (= ($Snap.first $t@1740@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$deadline)
; [eval] $unwrap(l$deadline)
(assert (<= 0 ($unwrap<Int> l$deadline@1661@01)))
(assert (= ($Snap.second $t@1740@01) $Snap.unit))
; [eval] $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$deadline)
(assert (<=
  ($unwrap<Int> l$deadline@1661@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) &&
;   ($struct_get($struct_loc(block, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1741@01 $Snap)
(assert (= $t@1741@01 ($Snap.combine ($Snap.first $t@1741@01) ($Snap.second $t@1741@01))))
(assert (= ($Snap.first $t@1741@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 0)): Int)
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1665@01 0))))
(assert (= ($Snap.second $t@1741@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1665@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) &&
;   ($struct_get($struct_loc(block, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1742@01 $Snap)
(assert (= $t@1742@01 ($Snap.combine ($Snap.first $t@1742@01) ($Snap.second $t@1742@01))))
(assert (= ($Snap.first $t@1742@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 1)): Int)
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1665@01 1))))
(assert (= ($Snap.second $t@1742@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1665@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) &&
;   ($struct_get($struct_loc(block, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1743@01 $Snap)
(assert (= $t@1743@01 ($Snap.combine ($Snap.first $t@1743@01) ($Snap.second $t@1743@01))))
(assert (= ($Snap.first $t@1743@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 2)): Int)
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1665@01 2))))
(assert (= ($Snap.second $t@1743@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1665@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
(declare-const $t@1744@01 $Snap)
(assert (= $t@1744@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])|
; [eval] ($struct_get($struct_loc(block, 3)): Seq[Int])
; [eval] $struct_loc(block, 3)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> block@1665@01 3))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) &&
;   ($struct_get($struct_loc(block, 4)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1745@01 $Snap)
(assert (= $t@1745@01 ($Snap.combine ($Snap.first $t@1745@01) ($Snap.second $t@1745@01))))
(assert (= ($Snap.first $t@1745@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1665@01 4))))
(assert (= ($Snap.second $t@1745@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1665@01 4))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(block, -1)): Int) ==
;   2335365049822495359383864865678187
(declare-const $t@1746@01 $Snap)
(assert (= $t@1746@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
; [eval] ($struct_get($struct_loc(block, -1)): Int)
; [eval] $struct_loc(block, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> block@1665@01 (- 0 1)))
  2335365049822495359383864865678187))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) &&
;   ($struct_get($struct_loc(msg, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1747@01 $Snap)
(assert (= $t@1747@01 ($Snap.combine ($Snap.first $t@1747@01) ($Snap.second $t@1747@01))))
(assert (= ($Snap.first $t@1747@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@1664@01 0))))
(assert (= ($Snap.second $t@1747@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@1664@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) &&
;   ($struct_get($struct_loc(msg, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1748@01 $Snap)
(assert (= $t@1748@01 ($Snap.combine ($Snap.first $t@1748@01) ($Snap.second $t@1748@01))))
(assert (= ($Snap.first $t@1748@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@1664@01 1))))
(assert (= ($Snap.second $t@1748@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@1664@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) &&
;   ($struct_get($struct_loc(msg, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1749@01 $Snap)
(assert (= $t@1749@01 ($Snap.combine ($Snap.first $t@1749@01) ($Snap.second $t@1749@01))))
(assert (= ($Snap.first $t@1749@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 2)): Int)
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@1664@01 2))))
(assert (= ($Snap.second $t@1749@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@1664@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, -1)): Int) ==
;   35634842679176259756224246631
(declare-const $t@1750@01 $Snap)
(assert (= $t@1750@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
; [eval] ($struct_get($struct_loc(msg, -1)): Int)
; [eval] $struct_loc(msg, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> msg@1664@01 (- 0 1)))
  35634842679176259756224246631))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
(declare-const $t@1751@01 $Snap)
(assert (= $t@1751@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) != 0
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (not (= ($struct_get<Int> ($struct_loc<Int> msg@1664@01 0)) 0)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@1752@01 $Snap)
(assert (= $t@1752@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@1753@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; $pre_self := self
; [exec]
; $pre_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $succ := true
; [exec]
; $overflow := false
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const self@1754@01 $Struct)
(assert (=
  self@1754@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    ($struct_get<Int> ($struct_loc<Int> msg@1664@01 1))))))
; [exec]
; self := ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]),
;   ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self,
;   12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) +
;   ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
; [eval] ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
; [eval] ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const self@1755@01 $Struct)
(assert (=
  self@1755@01
  ($struct_set<$Struct> self@1754@01 12 ($map_set<$Map<Int~_Int>> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1754@01 12)) ($struct_get<Int> ($struct_loc<Int> msg@1664@01 0)) (+
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1754@01 12)) ($struct_get<Int> ($struct_loc<Int> msg@1664@01 0)))
    ($struct_get<Int> ($struct_loc<Int> msg@1664@01 1)))))))
; [exec]
; i0$$pre_self := self
; [exec]
; i0$$pre_$contracts := $contracts
; [exec]
; l$i0$eth_sold := ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const l$i0$eth_sold@1756@01 Int)
(assert (= l$i0$eth_sold@1756@01 ($struct_get<Int> ($struct_loc<Int> msg@1664@01 1))))
; [exec]
; l$i0$min_tokens := l$min_tokens
; [exec]
; l$i0$deadline := l$deadline
; [exec]
; l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(declare-const l$i0$buyer@1757@01 Int)
(assert (= l$i0$buyer@1757@01 ($struct_get<Int> ($struct_loc<Int> msg@1664@01 0))))
; [exec]
; l$i0$recipient := ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(declare-const l$i0$recipient@1758@01 Int)
(assert (= l$i0$recipient@1758@01 ($struct_get<Int> ($struct_loc<Int> msg@1664@01 0))))
; [eval] !($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0))
; [eval] $unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0)
; [eval] $unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int)
; [eval] $unwrap(l$i0$deadline)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(set-option :timeout 0)
(push) ; 3
; [then-branch: 454 | !($unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4))) | live]
; [else-branch: 454 | $unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)) | live]
(push) ; 4
; [then-branch: 454 | !($unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)))]
(assert (not
  (>=
    ($unwrap<Int> l$deadline@1661@01)
    ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))))
(pop) ; 4
(push) ; 4
; [else-branch: 454 | $unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4))]
(assert (>=
  ($unwrap<Int> l$deadline@1661@01)
  ($struct_get<Int> ($struct_loc<Int> block@1665@01 4))))
; [eval] l$i0$eth_sold > 0
(push) ; 5
; [then-branch: 455 | !(l$i0$eth_sold@1756@01 > 0) | live]
; [else-branch: 455 | l$i0$eth_sold@1756@01 > 0 | live]
(push) ; 6
; [then-branch: 455 | !(l$i0$eth_sold@1756@01 > 0)]
(assert (not (> l$i0$eth_sold@1756@01 0)))
(pop) ; 6
(push) ; 6
; [else-branch: 455 | l$i0$eth_sold@1756@01 > 0]
(assert (> l$i0$eth_sold@1756@01 0))
; [eval] $unwrap(l$i0$min_tokens) > 0
; [eval] $unwrap(l$i0$min_tokens)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (> l$i0$eth_sold@1756@01 0) (not (> l$i0$eth_sold@1756@01 0))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  (>=
    ($unwrap<Int> l$deadline@1661@01)
    ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
  (and
    (>=
      ($unwrap<Int> l$deadline@1661@01)
      ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
    (or (> l$i0$eth_sold@1756@01 0) (not (> l$i0$eth_sold@1756@01 0))))))
(assert (or
  (>=
    ($unwrap<Int> l$deadline@1661@01)
    ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
  (not
    (>=
      ($unwrap<Int> l$deadline@1661@01)
      ($struct_get<Int> ($struct_loc<Int> block@1665@01 4))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (>=
    ($unwrap<Int> l$deadline@1661@01)
    ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
  (and (> l$i0$eth_sold@1756@01 0) (> ($unwrap<Int> l$min_tokens@1660@01) 0)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (>=
      ($unwrap<Int> l$deadline@1661@01)
      ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
    (and (> l$i0$eth_sold@1756@01 0) (> ($unwrap<Int> l$min_tokens@1660@01) 0))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 456 | !($unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)) && l$i0$eth_sold@1756@01 > 0 && $unwrap[Int](l$min_tokens@1660@01) > 0) | live]
; [else-branch: 456 | $unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)) && l$i0$eth_sold@1756@01 > 0 && $unwrap[Int](l$min_tokens@1660@01) > 0 | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 456 | !($unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)) && l$i0$eth_sold@1756@01 > 0 && $unwrap[Int](l$min_tokens@1660@01) > 0)]
(assert (not
  (and
    (>=
      ($unwrap<Int> l$deadline@1661@01)
      ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
    (and (> l$i0$eth_sold@1756@01 0) (> ($unwrap<Int> l$min_tokens@1660@01) 0)))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 457 | True | live]
; [else-branch: 457 | False | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 457 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1759@01 $Snap)
(assert (= $t@1759@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1760@01 $Struct)
(assert (=
  self@1760@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 4
; [then-branch: 458 | False | dead]
; [else-branch: 458 | True | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 458 | True]
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 456 | $unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)) && l$i0$eth_sold@1756@01 > 0 && $unwrap[Int](l$min_tokens@1660@01) > 0]
(assert (and
  (>=
    ($unwrap<Int> l$deadline@1661@01)
    ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
  (and (> l$i0$eth_sold@1756@01 0) (> ($unwrap<Int> l$min_tokens@1660@01) 0))))
(pop) ; 3
; [eval] !!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0))
; [eval] !($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0))
; [eval] $unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0)
; [eval] $unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int)
; [eval] $unwrap(l$i0$deadline)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(push) ; 3
; [then-branch: 459 | !($unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4))) | live]
; [else-branch: 459 | $unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)) | live]
(push) ; 4
; [then-branch: 459 | !($unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)))]
(assert (not
  (>=
    ($unwrap<Int> l$deadline@1661@01)
    ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))))
(pop) ; 4
(push) ; 4
; [else-branch: 459 | $unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4))]
(assert (>=
  ($unwrap<Int> l$deadline@1661@01)
  ($struct_get<Int> ($struct_loc<Int> block@1665@01 4))))
; [eval] l$i0$eth_sold > 0
(push) ; 5
; [then-branch: 460 | !(l$i0$eth_sold@1756@01 > 0) | live]
; [else-branch: 460 | l$i0$eth_sold@1756@01 > 0 | live]
(push) ; 6
; [then-branch: 460 | !(l$i0$eth_sold@1756@01 > 0)]
(assert (not (> l$i0$eth_sold@1756@01 0)))
(pop) ; 6
(push) ; 6
; [else-branch: 460 | l$i0$eth_sold@1756@01 > 0]
(assert (> l$i0$eth_sold@1756@01 0))
; [eval] $unwrap(l$i0$min_tokens) > 0
; [eval] $unwrap(l$i0$min_tokens)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (> l$i0$eth_sold@1756@01 0) (not (> l$i0$eth_sold@1756@01 0))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (>=
      ($unwrap<Int> l$deadline@1661@01)
      ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
    (and (> l$i0$eth_sold@1756@01 0) (> ($unwrap<Int> l$min_tokens@1660@01) 0))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (>=
    ($unwrap<Int> l$deadline@1661@01)
    ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
  (and (> l$i0$eth_sold@1756@01 0) (> ($unwrap<Int> l$min_tokens@1660@01) 0)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 461 | $unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)) && l$i0$eth_sold@1756@01 > 0 && $unwrap[Int](l$min_tokens@1660@01) > 0 | live]
; [else-branch: 461 | !($unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)) && l$i0$eth_sold@1756@01 > 0 && $unwrap[Int](l$min_tokens@1660@01) > 0) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 461 | $unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)) && l$i0$eth_sold@1756@01 > 0 && $unwrap[Int](l$min_tokens@1660@01) > 0]
(assert (and
  (>=
    ($unwrap<Int> l$deadline@1661@01)
    ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
  (and (> l$i0$eth_sold@1756@01 0) (> ($unwrap<Int> l$min_tokens@1660@01) 0))))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1761@01 Int)
(declare-const $arg1@1762@01 Int)
(declare-const $arg2@1763@01 Int)
(push) ; 4
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
(declare-const sm@1764@01 $PSF<e$TokenPurchase>)
(declare-const s@1765@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1766@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef145|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef146|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1761@01)
    ($SortWrappers.IntTo$Snap $arg1@1762@01))
  ($SortWrappers.IntTo$Snap $arg2@1763@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1761@01)
    ($SortWrappers.IntTo$Snap $arg1@1762@01))
  ($SortWrappers.IntTo$Snap $arg2@1763@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1761@01)
      ($SortWrappers.IntTo$Snap $arg1@1762@01))
    ($SortWrappers.IntTo$Snap $arg2@1763@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1767@01 (Int Int Int) Int)
(declare-fun img@1768@01 (Int Int Int) Bool)
(declare-fun inv@1769@01 (Int Int Int) Int)
(declare-fun img@1770@01 (Int Int Int) Bool)
(declare-fun inv@1771@01 (Int Int Int) Int)
(declare-fun img@1772@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef145|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef146|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1761@01 Int) ($arg1@1762@01 Int) ($arg2@1763@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1761@01)
          ($SortWrappers.IntTo$Snap $arg1@1762@01))
        ($SortWrappers.IntTo$Snap $arg2@1763@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1761@01)
        ($SortWrappers.IntTo$Snap $arg1@1762@01))
      ($SortWrappers.IntTo$Snap $arg2@1763@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1761@01)
        ($SortWrappers.IntTo$Snap $arg1@1762@01))
      ($SortWrappers.IntTo$Snap $arg2@1763@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1761@01)
      ($SortWrappers.IntTo$Snap $arg1@1762@01))
    ($SortWrappers.IntTo$Snap $arg2@1763@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1761@01)
      ($SortWrappers.IntTo$Snap $arg1@1762@01))
    ($SortWrappers.IntTo$Snap $arg2@1763@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1761@01 Int) ($arg1@1762@01 Int) ($arg2@1763@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1761@01)
          ($SortWrappers.IntTo$Snap $arg1@1762@01))
        ($SortWrappers.IntTo$Snap $arg2@1763@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1761@01)
            ($SortWrappers.IntTo$Snap $arg1@1762@01))
          ($SortWrappers.IntTo$Snap $arg2@1763@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1761@01)
            ($SortWrappers.IntTo$Snap $arg1@1762@01))
          ($SortWrappers.IntTo$Snap $arg2@1763@01))))))
  
  :qid |quant-u-1789|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1761@01 Int) ($arg11@1762@01 Int) ($arg21@1763@01 Int) ($arg02@1761@01 Int) ($arg12@1762@01 Int) ($arg22@1763@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1761@01)
                ($SortWrappers.IntTo$Snap $arg11@1762@01))
              ($SortWrappers.IntTo$Snap $arg21@1763@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1761@01)
              ($SortWrappers.IntTo$Snap $arg11@1762@01))
            ($SortWrappers.IntTo$Snap $arg21@1763@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1761@01)
              ($SortWrappers.IntTo$Snap $arg11@1762@01))
            ($SortWrappers.IntTo$Snap $arg21@1763@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1761@01)
              ($SortWrappers.IntTo$Snap $arg11@1762@01))
            ($SortWrappers.IntTo$Snap $arg21@1763@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1761@01)
                ($SortWrappers.IntTo$Snap $arg12@1762@01))
              ($SortWrappers.IntTo$Snap $arg22@1763@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1761@01)
              ($SortWrappers.IntTo$Snap $arg12@1762@01))
            ($SortWrappers.IntTo$Snap $arg22@1763@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1761@01)
              ($SortWrappers.IntTo$Snap $arg12@1762@01))
            ($SortWrappers.IntTo$Snap $arg22@1763@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1761@01)
              ($SortWrappers.IntTo$Snap $arg12@1762@01))
            ($SortWrappers.IntTo$Snap $arg22@1763@01)))))
      (and
        (and (= $arg01@1761@01 $arg02@1761@01) (= $arg11@1762@01 $arg12@1762@01))
        (= $arg21@1763@01 $arg22@1763@01)))
    (and
      (and (= $arg01@1761@01 $arg02@1761@01) (= $arg11@1762@01 $arg12@1762@01))
      (= $arg21@1763@01 $arg22@1763@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1761@01 Int) ($arg1@1762@01 Int) ($arg2@1763@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1761@01)
            ($SortWrappers.IntTo$Snap $arg1@1762@01))
          ($SortWrappers.IntTo$Snap $arg2@1763@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1761@01)
            ($SortWrappers.IntTo$Snap $arg1@1762@01))
          ($SortWrappers.IntTo$Snap $arg2@1763@01)))))
    (and
      (and
        (= (inv@1767@01 $arg0@1761@01 $arg1@1762@01 $arg2@1763@01) $arg0@1761@01)
        (= (inv@1769@01 $arg0@1761@01 $arg1@1762@01 $arg2@1763@01) $arg1@1762@01)
        (= (inv@1771@01 $arg0@1761@01 $arg1@1762@01 $arg2@1763@01) $arg2@1763@01))
      (and
        (img@1768@01 $arg0@1761@01 $arg1@1762@01 $arg2@1763@01)
        (img@1770@01 $arg0@1761@01 $arg1@1762@01 $arg2@1763@01)
        (img@1772@01 $arg0@1761@01 $arg1@1762@01 $arg2@1763@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1761@01)
      ($SortWrappers.IntTo$Snap $arg1@1762@01))
    ($SortWrappers.IntTo$Snap $arg2@1763@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1761@01)
      ($SortWrappers.IntTo$Snap $arg1@1762@01))
    ($SortWrappers.IntTo$Snap $arg2@1763@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1768@01 $arg0 $arg1 $arg2)
        (img@1770@01 $arg0 $arg1 $arg2)
        (img@1772@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1767@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1769@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1771@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1767@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1769@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1771@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1767@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1769@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1771@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1767@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1769@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1771@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1767@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1769@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1771@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1767@01 $arg0 $arg1 $arg2) (inv@1769@01 $arg0 $arg1 $arg2) (inv@1771@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1790|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1767@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1769@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1771@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1768@01 $arg0 $arg1 $arg2)
        (img@1770@01 $arg0 $arg1 $arg2)
        (img@1772@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1767@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1769@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1771@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@1766@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1767@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1769@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1771@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1791|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1773@01 Int)
(declare-const $arg1@1774@01 Int)
(declare-const $arg2@1775@01 Int)
(push) ; 4
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
(declare-const sm@1776@01 $PSF<e$EthPurchase>)
(declare-const s@1777@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1778@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef148|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef149|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1773@01)
    ($SortWrappers.IntTo$Snap $arg1@1774@01))
  ($SortWrappers.IntTo$Snap $arg2@1775@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1773@01)
    ($SortWrappers.IntTo$Snap $arg1@1774@01))
  ($SortWrappers.IntTo$Snap $arg2@1775@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1773@01)
      ($SortWrappers.IntTo$Snap $arg1@1774@01))
    ($SortWrappers.IntTo$Snap $arg2@1775@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1779@01 (Int Int Int) Int)
(declare-fun img@1780@01 (Int Int Int) Bool)
(declare-fun inv@1781@01 (Int Int Int) Int)
(declare-fun img@1782@01 (Int Int Int) Bool)
(declare-fun inv@1783@01 (Int Int Int) Int)
(declare-fun img@1784@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef148|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef149|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1773@01 Int) ($arg1@1774@01 Int) ($arg2@1775@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1773@01)
          ($SortWrappers.IntTo$Snap $arg1@1774@01))
        ($SortWrappers.IntTo$Snap $arg2@1775@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1773@01)
        ($SortWrappers.IntTo$Snap $arg1@1774@01))
      ($SortWrappers.IntTo$Snap $arg2@1775@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1773@01)
        ($SortWrappers.IntTo$Snap $arg1@1774@01))
      ($SortWrappers.IntTo$Snap $arg2@1775@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1773@01)
      ($SortWrappers.IntTo$Snap $arg1@1774@01))
    ($SortWrappers.IntTo$Snap $arg2@1775@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1773@01)
      ($SortWrappers.IntTo$Snap $arg1@1774@01))
    ($SortWrappers.IntTo$Snap $arg2@1775@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1773@01 Int) ($arg1@1774@01 Int) ($arg2@1775@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1773@01)
          ($SortWrappers.IntTo$Snap $arg1@1774@01))
        ($SortWrappers.IntTo$Snap $arg2@1775@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1773@01)
            ($SortWrappers.IntTo$Snap $arg1@1774@01))
          ($SortWrappers.IntTo$Snap $arg2@1775@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1773@01)
            ($SortWrappers.IntTo$Snap $arg1@1774@01))
          ($SortWrappers.IntTo$Snap $arg2@1775@01))))))
  
  :qid |quant-u-1792|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1773@01 Int) ($arg11@1774@01 Int) ($arg21@1775@01 Int) ($arg02@1773@01 Int) ($arg12@1774@01 Int) ($arg22@1775@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1773@01)
                ($SortWrappers.IntTo$Snap $arg11@1774@01))
              ($SortWrappers.IntTo$Snap $arg21@1775@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1773@01)
              ($SortWrappers.IntTo$Snap $arg11@1774@01))
            ($SortWrappers.IntTo$Snap $arg21@1775@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1773@01)
              ($SortWrappers.IntTo$Snap $arg11@1774@01))
            ($SortWrappers.IntTo$Snap $arg21@1775@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1773@01)
              ($SortWrappers.IntTo$Snap $arg11@1774@01))
            ($SortWrappers.IntTo$Snap $arg21@1775@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1773@01)
                ($SortWrappers.IntTo$Snap $arg12@1774@01))
              ($SortWrappers.IntTo$Snap $arg22@1775@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1773@01)
              ($SortWrappers.IntTo$Snap $arg12@1774@01))
            ($SortWrappers.IntTo$Snap $arg22@1775@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1773@01)
              ($SortWrappers.IntTo$Snap $arg12@1774@01))
            ($SortWrappers.IntTo$Snap $arg22@1775@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1773@01)
              ($SortWrappers.IntTo$Snap $arg12@1774@01))
            ($SortWrappers.IntTo$Snap $arg22@1775@01)))))
      (and
        (and (= $arg01@1773@01 $arg02@1773@01) (= $arg11@1774@01 $arg12@1774@01))
        (= $arg21@1775@01 $arg22@1775@01)))
    (and
      (and (= $arg01@1773@01 $arg02@1773@01) (= $arg11@1774@01 $arg12@1774@01))
      (= $arg21@1775@01 $arg22@1775@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1773@01 Int) ($arg1@1774@01 Int) ($arg2@1775@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1773@01)
            ($SortWrappers.IntTo$Snap $arg1@1774@01))
          ($SortWrappers.IntTo$Snap $arg2@1775@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1773@01)
            ($SortWrappers.IntTo$Snap $arg1@1774@01))
          ($SortWrappers.IntTo$Snap $arg2@1775@01)))))
    (and
      (and
        (= (inv@1779@01 $arg0@1773@01 $arg1@1774@01 $arg2@1775@01) $arg0@1773@01)
        (= (inv@1781@01 $arg0@1773@01 $arg1@1774@01 $arg2@1775@01) $arg1@1774@01)
        (= (inv@1783@01 $arg0@1773@01 $arg1@1774@01 $arg2@1775@01) $arg2@1775@01))
      (and
        (img@1780@01 $arg0@1773@01 $arg1@1774@01 $arg2@1775@01)
        (img@1782@01 $arg0@1773@01 $arg1@1774@01 $arg2@1775@01)
        (img@1784@01 $arg0@1773@01 $arg1@1774@01 $arg2@1775@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1773@01)
      ($SortWrappers.IntTo$Snap $arg1@1774@01))
    ($SortWrappers.IntTo$Snap $arg2@1775@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1773@01)
      ($SortWrappers.IntTo$Snap $arg1@1774@01))
    ($SortWrappers.IntTo$Snap $arg2@1775@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1780@01 $arg0 $arg1 $arg2)
        (img@1782@01 $arg0 $arg1 $arg2)
        (img@1784@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1779@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1781@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1783@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1779@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1781@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1783@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1779@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1781@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1783@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1779@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1781@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1783@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1779@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1781@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1783@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1779@01 $arg0 $arg1 $arg2) (inv@1781@01 $arg0 $arg1 $arg2) (inv@1783@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1793|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1779@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1781@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1783@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1780@01 $arg0 $arg1 $arg2)
        (img@1782@01 $arg0 $arg1 $arg2)
        (img@1784@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1779@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1781@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1783@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@1778@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1779@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1781@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1783@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1794|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1785@01 Int)
(declare-const $arg1@1786@01 Int)
(declare-const $arg2@1787@01 Int)
(push) ; 4
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
(declare-const sm@1788@01 $PSF<e$AddLiquidity>)
(declare-const s@1789@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1790@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef151|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef152|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1785@01)
    ($SortWrappers.IntTo$Snap $arg1@1786@01))
  ($SortWrappers.IntTo$Snap $arg2@1787@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1785@01)
    ($SortWrappers.IntTo$Snap $arg1@1786@01))
  ($SortWrappers.IntTo$Snap $arg2@1787@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1785@01)
      ($SortWrappers.IntTo$Snap $arg1@1786@01))
    ($SortWrappers.IntTo$Snap $arg2@1787@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1791@01 (Int Int Int) Int)
(declare-fun img@1792@01 (Int Int Int) Bool)
(declare-fun inv@1793@01 (Int Int Int) Int)
(declare-fun img@1794@01 (Int Int Int) Bool)
(declare-fun inv@1795@01 (Int Int Int) Int)
(declare-fun img@1796@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef151|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef152|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1785@01 Int) ($arg1@1786@01 Int) ($arg2@1787@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1785@01)
          ($SortWrappers.IntTo$Snap $arg1@1786@01))
        ($SortWrappers.IntTo$Snap $arg2@1787@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1785@01)
        ($SortWrappers.IntTo$Snap $arg1@1786@01))
      ($SortWrappers.IntTo$Snap $arg2@1787@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1785@01)
        ($SortWrappers.IntTo$Snap $arg1@1786@01))
      ($SortWrappers.IntTo$Snap $arg2@1787@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1785@01)
      ($SortWrappers.IntTo$Snap $arg1@1786@01))
    ($SortWrappers.IntTo$Snap $arg2@1787@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1785@01)
      ($SortWrappers.IntTo$Snap $arg1@1786@01))
    ($SortWrappers.IntTo$Snap $arg2@1787@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1785@01 Int) ($arg1@1786@01 Int) ($arg2@1787@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1785@01)
          ($SortWrappers.IntTo$Snap $arg1@1786@01))
        ($SortWrappers.IntTo$Snap $arg2@1787@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1785@01)
            ($SortWrappers.IntTo$Snap $arg1@1786@01))
          ($SortWrappers.IntTo$Snap $arg2@1787@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1785@01)
            ($SortWrappers.IntTo$Snap $arg1@1786@01))
          ($SortWrappers.IntTo$Snap $arg2@1787@01))))))
  
  :qid |quant-u-1795|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1785@01 Int) ($arg11@1786@01 Int) ($arg21@1787@01 Int) ($arg02@1785@01 Int) ($arg12@1786@01 Int) ($arg22@1787@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1785@01)
                ($SortWrappers.IntTo$Snap $arg11@1786@01))
              ($SortWrappers.IntTo$Snap $arg21@1787@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1785@01)
              ($SortWrappers.IntTo$Snap $arg11@1786@01))
            ($SortWrappers.IntTo$Snap $arg21@1787@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1785@01)
              ($SortWrappers.IntTo$Snap $arg11@1786@01))
            ($SortWrappers.IntTo$Snap $arg21@1787@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1785@01)
              ($SortWrappers.IntTo$Snap $arg11@1786@01))
            ($SortWrappers.IntTo$Snap $arg21@1787@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1785@01)
                ($SortWrappers.IntTo$Snap $arg12@1786@01))
              ($SortWrappers.IntTo$Snap $arg22@1787@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1785@01)
              ($SortWrappers.IntTo$Snap $arg12@1786@01))
            ($SortWrappers.IntTo$Snap $arg22@1787@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1785@01)
              ($SortWrappers.IntTo$Snap $arg12@1786@01))
            ($SortWrappers.IntTo$Snap $arg22@1787@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1785@01)
              ($SortWrappers.IntTo$Snap $arg12@1786@01))
            ($SortWrappers.IntTo$Snap $arg22@1787@01)))))
      (and
        (and (= $arg01@1785@01 $arg02@1785@01) (= $arg11@1786@01 $arg12@1786@01))
        (= $arg21@1787@01 $arg22@1787@01)))
    (and
      (and (= $arg01@1785@01 $arg02@1785@01) (= $arg11@1786@01 $arg12@1786@01))
      (= $arg21@1787@01 $arg22@1787@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1785@01 Int) ($arg1@1786@01 Int) ($arg2@1787@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1785@01)
            ($SortWrappers.IntTo$Snap $arg1@1786@01))
          ($SortWrappers.IntTo$Snap $arg2@1787@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1785@01)
            ($SortWrappers.IntTo$Snap $arg1@1786@01))
          ($SortWrappers.IntTo$Snap $arg2@1787@01)))))
    (and
      (and
        (= (inv@1791@01 $arg0@1785@01 $arg1@1786@01 $arg2@1787@01) $arg0@1785@01)
        (= (inv@1793@01 $arg0@1785@01 $arg1@1786@01 $arg2@1787@01) $arg1@1786@01)
        (= (inv@1795@01 $arg0@1785@01 $arg1@1786@01 $arg2@1787@01) $arg2@1787@01))
      (and
        (img@1792@01 $arg0@1785@01 $arg1@1786@01 $arg2@1787@01)
        (img@1794@01 $arg0@1785@01 $arg1@1786@01 $arg2@1787@01)
        (img@1796@01 $arg0@1785@01 $arg1@1786@01 $arg2@1787@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1785@01)
      ($SortWrappers.IntTo$Snap $arg1@1786@01))
    ($SortWrappers.IntTo$Snap $arg2@1787@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1785@01)
      ($SortWrappers.IntTo$Snap $arg1@1786@01))
    ($SortWrappers.IntTo$Snap $arg2@1787@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1792@01 $arg0 $arg1 $arg2)
        (img@1794@01 $arg0 $arg1 $arg2)
        (img@1796@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1791@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1793@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1795@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1791@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1793@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1795@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1791@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1793@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1795@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1791@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1793@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1795@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1791@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1793@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1795@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1791@01 $arg0 $arg1 $arg2) (inv@1793@01 $arg0 $arg1 $arg2) (inv@1795@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1796|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1791@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1793@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1795@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1792@01 $arg0 $arg1 $arg2)
        (img@1794@01 $arg0 $arg1 $arg2)
        (img@1796@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1791@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1793@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1795@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@1790@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1791@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1793@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1795@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1797|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@1797@01 Int)
(declare-const $arg1@1798@01 Int)
(declare-const $arg2@1799@01 Int)
(push) ; 4
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
(declare-const sm@1800@01 $PSF<e$RemoveLiquidity>)
(declare-const s@1801@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1802@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef154|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef155|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1797@01)
    ($SortWrappers.IntTo$Snap $arg1@1798@01))
  ($SortWrappers.IntTo$Snap $arg2@1799@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1797@01)
    ($SortWrappers.IntTo$Snap $arg1@1798@01))
  ($SortWrappers.IntTo$Snap $arg2@1799@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1797@01)
      ($SortWrappers.IntTo$Snap $arg1@1798@01))
    ($SortWrappers.IntTo$Snap $arg2@1799@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1803@01 (Int Int Int) Int)
(declare-fun img@1804@01 (Int Int Int) Bool)
(declare-fun inv@1805@01 (Int Int Int) Int)
(declare-fun img@1806@01 (Int Int Int) Bool)
(declare-fun inv@1807@01 (Int Int Int) Int)
(declare-fun img@1808@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef154|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef155|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1797@01 Int) ($arg1@1798@01 Int) ($arg2@1799@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1797@01)
          ($SortWrappers.IntTo$Snap $arg1@1798@01))
        ($SortWrappers.IntTo$Snap $arg2@1799@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1797@01)
        ($SortWrappers.IntTo$Snap $arg1@1798@01))
      ($SortWrappers.IntTo$Snap $arg2@1799@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1797@01)
        ($SortWrappers.IntTo$Snap $arg1@1798@01))
      ($SortWrappers.IntTo$Snap $arg2@1799@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1797@01)
      ($SortWrappers.IntTo$Snap $arg1@1798@01))
    ($SortWrappers.IntTo$Snap $arg2@1799@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1797@01)
      ($SortWrappers.IntTo$Snap $arg1@1798@01))
    ($SortWrappers.IntTo$Snap $arg2@1799@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1797@01 Int) ($arg1@1798@01 Int) ($arg2@1799@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1797@01)
          ($SortWrappers.IntTo$Snap $arg1@1798@01))
        ($SortWrappers.IntTo$Snap $arg2@1799@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1797@01)
            ($SortWrappers.IntTo$Snap $arg1@1798@01))
          ($SortWrappers.IntTo$Snap $arg2@1799@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1797@01)
            ($SortWrappers.IntTo$Snap $arg1@1798@01))
          ($SortWrappers.IntTo$Snap $arg2@1799@01))))))
  
  :qid |quant-u-1798|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1797@01 Int) ($arg11@1798@01 Int) ($arg21@1799@01 Int) ($arg02@1797@01 Int) ($arg12@1798@01 Int) ($arg22@1799@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1797@01)
                ($SortWrappers.IntTo$Snap $arg11@1798@01))
              ($SortWrappers.IntTo$Snap $arg21@1799@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1797@01)
              ($SortWrappers.IntTo$Snap $arg11@1798@01))
            ($SortWrappers.IntTo$Snap $arg21@1799@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1797@01)
              ($SortWrappers.IntTo$Snap $arg11@1798@01))
            ($SortWrappers.IntTo$Snap $arg21@1799@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1797@01)
              ($SortWrappers.IntTo$Snap $arg11@1798@01))
            ($SortWrappers.IntTo$Snap $arg21@1799@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1797@01)
                ($SortWrappers.IntTo$Snap $arg12@1798@01))
              ($SortWrappers.IntTo$Snap $arg22@1799@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1797@01)
              ($SortWrappers.IntTo$Snap $arg12@1798@01))
            ($SortWrappers.IntTo$Snap $arg22@1799@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1797@01)
              ($SortWrappers.IntTo$Snap $arg12@1798@01))
            ($SortWrappers.IntTo$Snap $arg22@1799@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1797@01)
              ($SortWrappers.IntTo$Snap $arg12@1798@01))
            ($SortWrappers.IntTo$Snap $arg22@1799@01)))))
      (and
        (and (= $arg01@1797@01 $arg02@1797@01) (= $arg11@1798@01 $arg12@1798@01))
        (= $arg21@1799@01 $arg22@1799@01)))
    (and
      (and (= $arg01@1797@01 $arg02@1797@01) (= $arg11@1798@01 $arg12@1798@01))
      (= $arg21@1799@01 $arg22@1799@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1797@01 Int) ($arg1@1798@01 Int) ($arg2@1799@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1797@01)
            ($SortWrappers.IntTo$Snap $arg1@1798@01))
          ($SortWrappers.IntTo$Snap $arg2@1799@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1797@01)
            ($SortWrappers.IntTo$Snap $arg1@1798@01))
          ($SortWrappers.IntTo$Snap $arg2@1799@01)))))
    (and
      (and
        (= (inv@1803@01 $arg0@1797@01 $arg1@1798@01 $arg2@1799@01) $arg0@1797@01)
        (= (inv@1805@01 $arg0@1797@01 $arg1@1798@01 $arg2@1799@01) $arg1@1798@01)
        (= (inv@1807@01 $arg0@1797@01 $arg1@1798@01 $arg2@1799@01) $arg2@1799@01))
      (and
        (img@1804@01 $arg0@1797@01 $arg1@1798@01 $arg2@1799@01)
        (img@1806@01 $arg0@1797@01 $arg1@1798@01 $arg2@1799@01)
        (img@1808@01 $arg0@1797@01 $arg1@1798@01 $arg2@1799@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1797@01)
      ($SortWrappers.IntTo$Snap $arg1@1798@01))
    ($SortWrappers.IntTo$Snap $arg2@1799@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1797@01)
      ($SortWrappers.IntTo$Snap $arg1@1798@01))
    ($SortWrappers.IntTo$Snap $arg2@1799@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1804@01 $arg0 $arg1 $arg2)
        (img@1806@01 $arg0 $arg1 $arg2)
        (img@1808@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1803@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1805@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1807@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1803@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1805@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1807@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1803@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1805@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1807@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1803@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1805@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1807@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1803@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1805@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1807@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1803@01 $arg0 $arg1 $arg2) (inv@1805@01 $arg0 $arg1 $arg2) (inv@1807@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1805|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1803@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1805@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1807@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1804@01 $arg0 $arg1 $arg2)
        (img@1806@01 $arg0 $arg1 $arg2)
        (img@1808@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1803@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1805@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1807@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@1802@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1803@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1805@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1807@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1806|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@1809@01 Int)
(declare-const $arg1@1810@01 Int)
(declare-const $arg2@1811@01 Int)
(push) ; 4
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
(declare-const sm@1812@01 $PSF<e$Transfer>)
(declare-const s@1813@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1814@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef157|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef158|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1809@01)
    ($SortWrappers.IntTo$Snap $arg1@1810@01))
  ($SortWrappers.IntTo$Snap $arg2@1811@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1809@01)
    ($SortWrappers.IntTo$Snap $arg1@1810@01))
  ($SortWrappers.IntTo$Snap $arg2@1811@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1809@01)
      ($SortWrappers.IntTo$Snap $arg1@1810@01))
    ($SortWrappers.IntTo$Snap $arg2@1811@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1815@01 (Int Int Int) Int)
(declare-fun img@1816@01 (Int Int Int) Bool)
(declare-fun inv@1817@01 (Int Int Int) Int)
(declare-fun img@1818@01 (Int Int Int) Bool)
(declare-fun inv@1819@01 (Int Int Int) Int)
(declare-fun img@1820@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef157|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef158|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1809@01 Int) ($arg1@1810@01 Int) ($arg2@1811@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1809@01)
          ($SortWrappers.IntTo$Snap $arg1@1810@01))
        ($SortWrappers.IntTo$Snap $arg2@1811@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1809@01)
        ($SortWrappers.IntTo$Snap $arg1@1810@01))
      ($SortWrappers.IntTo$Snap $arg2@1811@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1809@01)
        ($SortWrappers.IntTo$Snap $arg1@1810@01))
      ($SortWrappers.IntTo$Snap $arg2@1811@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1809@01)
      ($SortWrappers.IntTo$Snap $arg1@1810@01))
    ($SortWrappers.IntTo$Snap $arg2@1811@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1809@01)
      ($SortWrappers.IntTo$Snap $arg1@1810@01))
    ($SortWrappers.IntTo$Snap $arg2@1811@01))))
  :qid |e$Transfer-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1809@01 Int) ($arg1@1810@01 Int) ($arg2@1811@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1809@01)
          ($SortWrappers.IntTo$Snap $arg1@1810@01))
        ($SortWrappers.IntTo$Snap $arg2@1811@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1809@01)
            ($SortWrappers.IntTo$Snap $arg1@1810@01))
          ($SortWrappers.IntTo$Snap $arg2@1811@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1809@01)
            ($SortWrappers.IntTo$Snap $arg1@1810@01))
          ($SortWrappers.IntTo$Snap $arg2@1811@01))))))
  
  :qid |quant-u-1807|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1809@01 Int) ($arg11@1810@01 Int) ($arg21@1811@01 Int) ($arg02@1809@01 Int) ($arg12@1810@01 Int) ($arg22@1811@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1809@01)
                ($SortWrappers.IntTo$Snap $arg11@1810@01))
              ($SortWrappers.IntTo$Snap $arg21@1811@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1809@01)
              ($SortWrappers.IntTo$Snap $arg11@1810@01))
            ($SortWrappers.IntTo$Snap $arg21@1811@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1809@01)
              ($SortWrappers.IntTo$Snap $arg11@1810@01))
            ($SortWrappers.IntTo$Snap $arg21@1811@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1809@01)
              ($SortWrappers.IntTo$Snap $arg11@1810@01))
            ($SortWrappers.IntTo$Snap $arg21@1811@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1809@01)
                ($SortWrappers.IntTo$Snap $arg12@1810@01))
              ($SortWrappers.IntTo$Snap $arg22@1811@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1809@01)
              ($SortWrappers.IntTo$Snap $arg12@1810@01))
            ($SortWrappers.IntTo$Snap $arg22@1811@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1809@01)
              ($SortWrappers.IntTo$Snap $arg12@1810@01))
            ($SortWrappers.IntTo$Snap $arg22@1811@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1809@01)
              ($SortWrappers.IntTo$Snap $arg12@1810@01))
            ($SortWrappers.IntTo$Snap $arg22@1811@01)))))
      (and
        (and (= $arg01@1809@01 $arg02@1809@01) (= $arg11@1810@01 $arg12@1810@01))
        (= $arg21@1811@01 $arg22@1811@01)))
    (and
      (and (= $arg01@1809@01 $arg02@1809@01) (= $arg11@1810@01 $arg12@1810@01))
      (= $arg21@1811@01 $arg22@1811@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1809@01 Int) ($arg1@1810@01 Int) ($arg2@1811@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1809@01)
            ($SortWrappers.IntTo$Snap $arg1@1810@01))
          ($SortWrappers.IntTo$Snap $arg2@1811@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1809@01)
            ($SortWrappers.IntTo$Snap $arg1@1810@01))
          ($SortWrappers.IntTo$Snap $arg2@1811@01)))))
    (and
      (and
        (= (inv@1815@01 $arg0@1809@01 $arg1@1810@01 $arg2@1811@01) $arg0@1809@01)
        (= (inv@1817@01 $arg0@1809@01 $arg1@1810@01 $arg2@1811@01) $arg1@1810@01)
        (= (inv@1819@01 $arg0@1809@01 $arg1@1810@01 $arg2@1811@01) $arg2@1811@01))
      (and
        (img@1816@01 $arg0@1809@01 $arg1@1810@01 $arg2@1811@01)
        (img@1818@01 $arg0@1809@01 $arg1@1810@01 $arg2@1811@01)
        (img@1820@01 $arg0@1809@01 $arg1@1810@01 $arg2@1811@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1809@01)
      ($SortWrappers.IntTo$Snap $arg1@1810@01))
    ($SortWrappers.IntTo$Snap $arg2@1811@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1809@01)
      ($SortWrappers.IntTo$Snap $arg1@1810@01))
    ($SortWrappers.IntTo$Snap $arg2@1811@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1816@01 $arg0 $arg1 $arg2)
        (img@1818@01 $arg0 $arg1 $arg2)
        (img@1820@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1815@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1817@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1819@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1815@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1817@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1819@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1815@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1817@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1819@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1815@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1817@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1819@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1815@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1817@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1819@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1815@01 $arg0 $arg1 $arg2) (inv@1817@01 $arg0 $arg1 $arg2) (inv@1819@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1808|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1815@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1817@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1819@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1816@01 $arg0 $arg1 $arg2)
        (img@1818@01 $arg0 $arg1 $arg2)
        (img@1820@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1815@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1817@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1819@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@1814@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1815@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1817@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1819@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1809|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@1821@01 Int)
(declare-const $arg1@1822@01 Int)
(declare-const $arg2@1823@01 Int)
(push) ; 4
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
(declare-const sm@1824@01 $PSF<e$Approval>)
(declare-const s@1825@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@1826@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef160|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef161|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1821@01)
    ($SortWrappers.IntTo$Snap $arg1@1822@01))
  ($SortWrappers.IntTo$Snap $arg2@1823@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1821@01)
    ($SortWrappers.IntTo$Snap $arg1@1822@01))
  ($SortWrappers.IntTo$Snap $arg2@1823@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1821@01)
      ($SortWrappers.IntTo$Snap $arg1@1822@01))
    ($SortWrappers.IntTo$Snap $arg2@1823@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 4
(declare-fun inv@1827@01 (Int Int Int) Int)
(declare-fun img@1828@01 (Int Int Int) Bool)
(declare-fun inv@1829@01 (Int Int Int) Int)
(declare-fun img@1830@01 (Int Int Int) Bool)
(declare-fun inv@1831@01 (Int Int Int) Int)
(declare-fun img@1832@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef160|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef161|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1821@01 Int) ($arg1@1822@01 Int) ($arg2@1823@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1821@01)
          ($SortWrappers.IntTo$Snap $arg1@1822@01))
        ($SortWrappers.IntTo$Snap $arg2@1823@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1821@01)
        ($SortWrappers.IntTo$Snap $arg1@1822@01))
      ($SortWrappers.IntTo$Snap $arg2@1823@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1821@01)
        ($SortWrappers.IntTo$Snap $arg1@1822@01))
      ($SortWrappers.IntTo$Snap $arg2@1823@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1821@01)
      ($SortWrappers.IntTo$Snap $arg1@1822@01))
    ($SortWrappers.IntTo$Snap $arg2@1823@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1821@01)
      ($SortWrappers.IntTo$Snap $arg1@1822@01))
    ($SortWrappers.IntTo$Snap $arg2@1823@01))))
  :qid |e$Approval-aux|)))
(push) ; 4
(assert (not (forall (($arg0@1821@01 Int) ($arg1@1822@01 Int) ($arg2@1823@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1821@01)
          ($SortWrappers.IntTo$Snap $arg1@1822@01))
        ($SortWrappers.IntTo$Snap $arg2@1823@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1821@01)
            ($SortWrappers.IntTo$Snap $arg1@1822@01))
          ($SortWrappers.IntTo$Snap $arg2@1823@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1821@01)
            ($SortWrappers.IntTo$Snap $arg1@1822@01))
          ($SortWrappers.IntTo$Snap $arg2@1823@01))))))
  
  :qid |quant-u-1810|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall (($arg01@1821@01 Int) ($arg11@1822@01 Int) ($arg21@1823@01 Int) ($arg02@1821@01 Int) ($arg12@1822@01 Int) ($arg22@1823@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1821@01)
                ($SortWrappers.IntTo$Snap $arg11@1822@01))
              ($SortWrappers.IntTo$Snap $arg21@1823@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1821@01)
              ($SortWrappers.IntTo$Snap $arg11@1822@01))
            ($SortWrappers.IntTo$Snap $arg21@1823@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1821@01)
              ($SortWrappers.IntTo$Snap $arg11@1822@01))
            ($SortWrappers.IntTo$Snap $arg21@1823@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1821@01)
              ($SortWrappers.IntTo$Snap $arg11@1822@01))
            ($SortWrappers.IntTo$Snap $arg21@1823@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1821@01)
                ($SortWrappers.IntTo$Snap $arg12@1822@01))
              ($SortWrappers.IntTo$Snap $arg22@1823@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1821@01)
              ($SortWrappers.IntTo$Snap $arg12@1822@01))
            ($SortWrappers.IntTo$Snap $arg22@1823@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1821@01)
              ($SortWrappers.IntTo$Snap $arg12@1822@01))
            ($SortWrappers.IntTo$Snap $arg22@1823@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1821@01)
              ($SortWrappers.IntTo$Snap $arg12@1822@01))
            ($SortWrappers.IntTo$Snap $arg22@1823@01)))))
      (and
        (and (= $arg01@1821@01 $arg02@1821@01) (= $arg11@1822@01 $arg12@1822@01))
        (= $arg21@1823@01 $arg22@1823@01)))
    (and
      (and (= $arg01@1821@01 $arg02@1821@01) (= $arg11@1822@01 $arg12@1822@01))
      (= $arg21@1823@01 $arg22@1823@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1821@01 Int) ($arg1@1822@01 Int) ($arg2@1823@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1821@01)
            ($SortWrappers.IntTo$Snap $arg1@1822@01))
          ($SortWrappers.IntTo$Snap $arg2@1823@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1821@01)
            ($SortWrappers.IntTo$Snap $arg1@1822@01))
          ($SortWrappers.IntTo$Snap $arg2@1823@01)))))
    (and
      (and
        (= (inv@1827@01 $arg0@1821@01 $arg1@1822@01 $arg2@1823@01) $arg0@1821@01)
        (= (inv@1829@01 $arg0@1821@01 $arg1@1822@01 $arg2@1823@01) $arg1@1822@01)
        (= (inv@1831@01 $arg0@1821@01 $arg1@1822@01 $arg2@1823@01) $arg2@1823@01))
      (and
        (img@1828@01 $arg0@1821@01 $arg1@1822@01 $arg2@1823@01)
        (img@1830@01 $arg0@1821@01 $arg1@1822@01 $arg2@1823@01)
        (img@1832@01 $arg0@1821@01 $arg1@1822@01 $arg2@1823@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1821@01)
      ($SortWrappers.IntTo$Snap $arg1@1822@01))
    ($SortWrappers.IntTo$Snap $arg2@1823@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1821@01)
      ($SortWrappers.IntTo$Snap $arg1@1822@01))
    ($SortWrappers.IntTo$Snap $arg2@1823@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1828@01 $arg0 $arg1 $arg2)
        (img@1830@01 $arg0 $arg1 $arg2)
        (img@1832@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1827@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1829@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1831@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1827@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1829@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1831@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1827@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1829@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1831@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1827@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1829@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1831@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1827@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1829@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1831@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1827@01 $arg0 $arg1 $arg2) (inv@1829@01 $arg0 $arg1 $arg2) (inv@1831@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1811|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 4
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1827@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1829@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1831@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1828@01 $arg0 $arg1 $arg2)
        (img@1830@01 $arg0 $arg1 $arg2)
        (img@1832@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1827@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1829@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1831@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@1826@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1827@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1829@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1831@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1812|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; inhale 0 <= l$i0$raw_ret &&
;   l$i0$raw_ret <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1833@01 $Snap)
(assert (= $t@1833@01 ($Snap.combine ($Snap.first $t@1833@01) ($Snap.second $t@1833@01))))
(assert (= ($Snap.first $t@1833@01) $Snap.unit))
; [eval] 0 <= l$i0$raw_ret
(assert (<= 0 l$i0$raw_ret@1686@01))
(assert (= ($Snap.second $t@1833@01) $Snap.unit))
; [eval] l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
(assert (<=
  l$i0$raw_ret@1686@01
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not l$i0$send_fail@1685@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not l$i0$send_fail@1685@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 462 | l$i0$send_fail@1685@01 | live]
; [else-branch: 462 | !(l$i0$send_fail@1685@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 462 | l$i0$send_fail@1685@01]
(assert l$i0$send_fail@1685@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@1834@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 463 | True | live]
; [else-branch: 463 | False | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 463 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1835@01 $Snap)
(assert (= $t@1835@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1836@01 $Struct)
(assert (=
  self@1836@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 5
; [then-branch: 464 | False | dead]
; [else-branch: 464 | True | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 464 | True]
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 462 | !(l$i0$send_fail@1685@01)]
(assert (not l$i0$send_fail@1685@01))
(pop) ; 4
; [eval] !l$i0$send_fail
(push) ; 4
(set-option :timeout 10)
(assert (not l$i0$send_fail@1685@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not l$i0$send_fail@1685@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 465 | !(l$i0$send_fail@1685@01) | live]
; [else-branch: 465 | l$i0$send_fail@1685@01 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 465 | !(l$i0$send_fail@1685@01)]
(assert (not l$i0$send_fail@1685@01))
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; l$i0$token_reserve := $wrap(l$i0$raw_ret)
; [eval] $wrap(l$i0$raw_ret)
(declare-const l$i0$token_reserve@1837@01 $Int)
(assert (= l$i0$token_reserve@1837@01 ($wrap<$Int> l$i0$raw_ret@1686@01)))
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 5
(set-option :timeout 10)
(assert (not (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1755@01 8))
      l$i0$eth_sold@1756@01)
    0))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 466 | $struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 < 0 | dead]
; [else-branch: 466 | !($struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 < 0) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 466 | !($struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 < 0)]
(assert (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1755@01 8))
      l$i0$eth_sold@1756@01)
    0)))
(pop) ; 5
; [eval] !(($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0)
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 5
(set-option :timeout 10)
(assert (not (<
  (- ($struct_get<Int> ($struct_loc<Int> self@1755@01 8)) l$i0$eth_sold@1756@01)
  0)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1755@01 8))
      l$i0$eth_sold@1756@01)
    0))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 467 | !($struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 < 0) | live]
; [else-branch: 467 | $struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 < 0 | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 467 | !($struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 < 0)]
(assert (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1755@01 8))
      l$i0$eth_sold@1756@01)
    0)))
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1755@01 8))
      l$i0$eth_sold@1756@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 468 | $struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 468 | !($struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 468 | !($struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1755@01 8))
      l$i0$eth_sold@1756@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 6
; [eval] !(($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 6
(set-option :timeout 10)
(assert (not (>
  (- ($struct_get<Int> ($struct_loc<Int> self@1755@01 8)) l$i0$eth_sold@1756@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1755@01 8))
      l$i0$eth_sold@1756@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 469 | !($struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 469 | $struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 469 | !($struct_get[Int]($struct_loc[Int](self@1755@01, 8)) - l$i0$eth_sold@1756@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@1755@01 8))
      l$i0$eth_sold@1756@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$input_amount := l$i0$eth_sold
; [exec]
; l$i2$input_reserve := ($struct_get($struct_loc(self, 8)): Int) -
;   l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const l$i2$input_reserve@1838@01 Int)
(assert (=
  l$i2$input_reserve@1838@01
  (- ($struct_get<Int> ($struct_loc<Int> self@1755@01 8)) l$i0$eth_sold@1756@01)))
; [exec]
; l$i2$output_reserve := l$i0$token_reserve
; [eval] !(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)
; [eval] l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0
; [eval] l$i2$input_reserve > 0
(push) ; 7
; [then-branch: 470 | !(l$i2$input_reserve@1838@01 > 0) | live]
; [else-branch: 470 | l$i2$input_reserve@1838@01 > 0 | live]
(push) ; 8
; [then-branch: 470 | !(l$i2$input_reserve@1838@01 > 0)]
(assert (not (> l$i2$input_reserve@1838@01 0)))
(pop) ; 8
(push) ; 8
; [else-branch: 470 | l$i2$input_reserve@1838@01 > 0]
(assert (> l$i2$input_reserve@1838@01 0))
; [eval] $unwrap(l$i2$output_reserve) > 0
; [eval] $unwrap(l$i2$output_reserve)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or (> l$i2$input_reserve@1838@01 0) (not (> l$i2$input_reserve@1838@01 0))))
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (> l$i2$input_reserve@1838@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@1837@01) 0))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (and
    (> l$i2$input_reserve@1838@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@1837@01) 0)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 471 | !(l$i2$input_reserve@1838@01 > 0 && $unwrap[Int](l$i0$token_reserve@1837@01) > 0) | live]
; [else-branch: 471 | l$i2$input_reserve@1838@01 > 0 && $unwrap[Int](l$i0$token_reserve@1837@01) > 0 | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 471 | !(l$i2$input_reserve@1838@01 > 0 && $unwrap[Int](l$i0$token_reserve@1837@01) > 0)]
(assert (not
  (and
    (> l$i2$input_reserve@1838@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@1837@01) 0))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 8
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 472 | True | live]
; [else-branch: 472 | False | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 472 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1839@01 $Snap)
(assert (= $t@1839@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1840@01 $Struct)
(assert (=
  self@1840@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 8
; [then-branch: 473 | False | dead]
; [else-branch: 473 | True | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 473 | True]
(pop) ; 8
(pop) ; 7
(push) ; 7
; [else-branch: 471 | l$i2$input_reserve@1838@01 > 0 && $unwrap[Int](l$i0$token_reserve@1837@01) > 0]
(assert (and
  (> l$i2$input_reserve@1838@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@1837@01) 0)))
(pop) ; 7
; [eval] !!(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)
; [eval] !(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)
; [eval] l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0
; [eval] l$i2$input_reserve > 0
(push) ; 7
; [then-branch: 474 | !(l$i2$input_reserve@1838@01 > 0) | live]
; [else-branch: 474 | l$i2$input_reserve@1838@01 > 0 | live]
(push) ; 8
; [then-branch: 474 | !(l$i2$input_reserve@1838@01 > 0)]
(assert (not (> l$i2$input_reserve@1838@01 0)))
(pop) ; 8
(push) ; 8
; [else-branch: 474 | l$i2$input_reserve@1838@01 > 0]
(assert (> l$i2$input_reserve@1838@01 0))
; [eval] $unwrap(l$i2$output_reserve) > 0
; [eval] $unwrap(l$i2$output_reserve)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (and
    (> l$i2$input_reserve@1838@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@1837@01) 0)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (> l$i2$input_reserve@1838@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@1837@01) 0))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 475 | l$i2$input_reserve@1838@01 > 0 && $unwrap[Int](l$i0$token_reserve@1837@01) > 0 | live]
; [else-branch: 475 | !(l$i2$input_reserve@1838@01 > 0 && $unwrap[Int](l$i0$token_reserve@1837@01) > 0) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 475 | l$i2$input_reserve@1838@01 > 0 && $unwrap[Int](l$i0$token_reserve@1837@01) > 0]
(assert (and
  (> l$i2$input_reserve@1838@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@1837@01) 0)))
; [eval] l$i2$input_amount * 997 < 0
; [eval] l$i2$input_amount * 997
(push) ; 8
(set-option :timeout 10)
(assert (not (not (< (* l$i0$eth_sold@1756@01 997) 0))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 476 | l$i0$eth_sold@1756@01 * 997 < 0 | dead]
; [else-branch: 476 | !(l$i0$eth_sold@1756@01 * 997 < 0) | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 476 | !(l$i0$eth_sold@1756@01 * 997 < 0)]
(assert (not (< (* l$i0$eth_sold@1756@01 997) 0)))
(pop) ; 8
; [eval] !(l$i2$input_amount * 997 < 0)
; [eval] l$i2$input_amount * 997 < 0
; [eval] l$i2$input_amount * 997
(push) ; 8
(set-option :timeout 10)
(assert (not (< (* l$i0$eth_sold@1756@01 997) 0)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not (< (* l$i0$eth_sold@1756@01 997) 0))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 477 | !(l$i0$eth_sold@1756@01 * 997 < 0) | live]
; [else-branch: 477 | l$i0$eth_sold@1756@01 * 997 < 0 | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 477 | !(l$i0$eth_sold@1756@01 * 997 < 0)]
(assert (not (< (* l$i0$eth_sold@1756@01 997) 0)))
; [eval] l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount * 997
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i0$eth_sold@1756@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (>
  (* l$i0$eth_sold@1756@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 478 | l$i0$eth_sold@1756@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 478 | !(l$i0$eth_sold@1756@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 478 | l$i0$eth_sold@1756@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (* l$i0$eth_sold@1756@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 10
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 479 | True | live]
; [else-branch: 479 | False | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 479 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1841@01 $Snap)
(assert (= $t@1841@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1842@01 $Struct)
(assert (=
  self@1842@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 10
; [then-branch: 480 | False | dead]
; [else-branch: 480 | True | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 480 | True]
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 478 | !(l$i0$eth_sold@1756@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i0$eth_sold@1756@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 9
; [eval] !(l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount * 997
(push) ; 9
(set-option :timeout 10)
(assert (not (>
  (* l$i0$eth_sold@1756@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i0$eth_sold@1756@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 481 | !(l$i0$eth_sold@1756@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 481 | l$i0$eth_sold@1756@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 481 | !(l$i0$eth_sold@1756@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i0$eth_sold@1756@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$input_amount_with_fee := l$i2$input_amount * 997
; [eval] l$i2$input_amount * 997
(declare-const l$i2$input_amount_with_fee@1843@01 Int)
(assert (= l$i2$input_amount_with_fee@1843@01 (* l$i0$eth_sold@1756@01 997)))
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (<
    (*
      l$i2$input_amount_with_fee@1843@01
      ($unwrap<Int> l$i0$token_reserve@1837@01))
    0))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 482 | l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) < 0 | dead]
; [else-branch: 482 | !(l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) < 0) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 482 | !(l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) < 0)]
(assert (not
  (<
    (*
      l$i2$input_amount_with_fee@1843@01
      ($unwrap<Int> l$i0$token_reserve@1837@01))
    0)))
(pop) ; 10
; [eval] !(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0)
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 10
(set-option :timeout 10)
(assert (not (<
  (*
    l$i2$input_amount_with_fee@1843@01
    ($unwrap<Int> l$i0$token_reserve@1837@01))
  0)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (<
    (*
      l$i2$input_amount_with_fee@1843@01
      ($unwrap<Int> l$i0$token_reserve@1837@01))
    0))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 483 | !(l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) < 0) | live]
; [else-branch: 483 | l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) < 0 | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 483 | !(l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) < 0)]
(assert (not
  (<
    (*
      l$i2$input_amount_with_fee@1843@01
      ($unwrap<Int> l$i0$token_reserve@1837@01))
    0)))
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 11
(set-option :timeout 10)
(assert (not (not
  (>
    (*
      l$i2$input_amount_with_fee@1843@01
      ($unwrap<Int> l$i0$token_reserve@1837@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (>
  (*
    l$i2$input_amount_with_fee@1843@01
    ($unwrap<Int> l$i0$token_reserve@1837@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 484 | l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 484 | !(l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 484 | l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (*
    l$i2$input_amount_with_fee@1843@01
    ($unwrap<Int> l$i0$token_reserve@1837@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 12
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 485 | True | live]
; [else-branch: 485 | False | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 485 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1844@01 $Snap)
(assert (= $t@1844@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1845@01 $Struct)
(assert (=
  self@1845@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 12
; [then-branch: 486 | False | dead]
; [else-branch: 486 | True | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 486 | True]
(pop) ; 12
(pop) ; 11
(push) ; 11
; [else-branch: 484 | !(l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (*
      l$i2$input_amount_with_fee@1843@01
      ($unwrap<Int> l$i0$token_reserve@1837@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 11
; [eval] !(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 11
(set-option :timeout 10)
(assert (not (>
  (*
    l$i2$input_amount_with_fee@1843@01
    ($unwrap<Int> l$i0$token_reserve@1837@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (not
  (>
    (*
      l$i2$input_amount_with_fee@1843@01
      ($unwrap<Int> l$i0$token_reserve@1837@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 487 | !(l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 487 | l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 487 | !(l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (*
      l$i2$input_amount_with_fee@1843@01
      ($unwrap<Int> l$i0$token_reserve@1837@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$numerator := $wrap(l$i2$input_amount_with_fee *
;   $unwrap(l$i2$output_reserve))
; [eval] $wrap(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve))
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(declare-const l$i2$numerator@1846@01 $Int)
(assert (=
  l$i2$numerator@1846@01
  ($wrap<$Int> (*
    l$i2$input_amount_with_fee@1843@01
    ($unwrap<Int> l$i0$token_reserve@1837@01)))))
; [eval] l$i2$input_reserve * 1000 < 0
; [eval] l$i2$input_reserve * 1000
(push) ; 12
(set-option :timeout 10)
(assert (not (not (< (* l$i2$input_reserve@1838@01 1000) 0))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 488 | l$i2$input_reserve@1838@01 * 1000 < 0 | dead]
; [else-branch: 488 | !(l$i2$input_reserve@1838@01 * 1000 < 0) | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 488 | !(l$i2$input_reserve@1838@01 * 1000 < 0)]
(assert (not (< (* l$i2$input_reserve@1838@01 1000) 0)))
(pop) ; 12
; [eval] !(l$i2$input_reserve * 1000 < 0)
; [eval] l$i2$input_reserve * 1000 < 0
; [eval] l$i2$input_reserve * 1000
(push) ; 12
(set-option :timeout 10)
(assert (not (< (* l$i2$input_reserve@1838@01 1000) 0)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (not (< (* l$i2$input_reserve@1838@01 1000) 0))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 489 | !(l$i2$input_reserve@1838@01 * 1000 < 0) | live]
; [else-branch: 489 | l$i2$input_reserve@1838@01 * 1000 < 0 | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 489 | !(l$i2$input_reserve@1838@01 * 1000 < 0)]
(assert (not (< (* l$i2$input_reserve@1838@01 1000) 0)))
; [eval] l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000
(push) ; 13
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i2$input_reserve@1838@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (>
  (* l$i2$input_reserve@1838@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 490 | l$i2$input_reserve@1838@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 490 | !(l$i2$input_reserve@1838@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 490 | l$i2$input_reserve@1838@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (* l$i2$input_reserve@1838@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 14
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 491 | True | live]
; [else-branch: 491 | False | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 491 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1847@01 $Snap)
(assert (= $t@1847@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1848@01 $Struct)
(assert (=
  self@1848@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 14
; [then-branch: 492 | False | dead]
; [else-branch: 492 | True | live]
(set-option :timeout 0)
(push) ; 14
; [else-branch: 492 | True]
(pop) ; 14
(pop) ; 13
(push) ; 13
; [else-branch: 490 | !(l$i2$input_reserve@1838@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i2$input_reserve@1838@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 13
; [eval] !(l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000
(push) ; 13
(set-option :timeout 10)
(assert (not (>
  (* l$i2$input_reserve@1838@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i2$input_reserve@1838@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 493 | !(l$i2$input_reserve@1838@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 493 | l$i2$input_reserve@1838@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 493 | !(l$i2$input_reserve@1838@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i2$input_reserve@1838@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (<
    (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
    0))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 494 | l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 < 0 | dead]
; [else-branch: 494 | !(l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 < 0) | live]
(set-option :timeout 0)
(push) ; 14
; [else-branch: 494 | !(l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 < 0)]
(assert (not
  (<
    (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
    0)))
(pop) ; 14
; [eval] !(l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0)
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 14
(set-option :timeout 10)
(assert (not (< (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01) 0)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (<
    (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
    0))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 495 | !(l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 < 0) | live]
; [else-branch: 495 | l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 < 0 | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 495 | !(l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 < 0)]
(assert (not
  (<
    (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
    0)))
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 15
(set-option :timeout 10)
(assert (not (not
  (>
    (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (>
  (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 496 | l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 496 | !(l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 496 | l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 16
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 497 | True | live]
; [else-branch: 497 | False | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 497 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1849@01 $Snap)
(assert (= $t@1849@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1850@01 $Struct)
(assert (=
  self@1850@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 16
; [then-branch: 498 | False | dead]
; [else-branch: 498 | True | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 498 | True]
(pop) ; 16
(pop) ; 15
(push) ; 15
; [else-branch: 496 | !(l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 15
; [eval] !(l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 15
(set-option :timeout 10)
(assert (not (>
  (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (not
  (>
    (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 499 | !(l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 499 | l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 499 | !(l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$denominator := l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(declare-const l$i2$denominator@1851@01 Int)
(assert (=
  l$i2$denominator@1851@01
  (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)))
; [eval] l$i2$denominator == 0
(push) ; 16
(set-option :timeout 10)
(assert (not (not (= l$i2$denominator@1851@01 0))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 500 | l$i2$denominator@1851@01 == 0 | dead]
; [else-branch: 500 | l$i2$denominator@1851@01 != 0 | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 500 | l$i2$denominator@1851@01 != 0]
(assert (not (= l$i2$denominator@1851@01 0)))
(pop) ; 16
; [eval] !(l$i2$denominator == 0)
; [eval] l$i2$denominator == 0
(push) ; 16
(set-option :timeout 10)
(assert (not (= l$i2$denominator@1851@01 0)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not (= l$i2$denominator@1851@01 0))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 501 | l$i2$denominator@1851@01 != 0 | live]
; [else-branch: 501 | l$i2$denominator@1851@01 == 0 | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 501 | l$i2$denominator@1851@01 != 0]
(assert (not (= l$i2$denominator@1851@01 0)))
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) < 0
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 17
(set-option :timeout 10)
(assert (not (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
      ($unwrap<Int> l$i2$numerator@1846@01)
      l$i2$denominator@1851@01))
    0))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 502 | $div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) < 0 | dead]
; [else-branch: 502 | !($div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) < 0) | live]
(set-option :timeout 0)
(push) ; 17
; [else-branch: 502 | !($div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) < 0)]
(assert (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
      ($unwrap<Int> l$i2$numerator@1846@01)
      l$i2$denominator@1851@01))
    0)))
(pop) ; 17
; [eval] !($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) < 0)
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) < 0
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 17
(set-option :timeout 10)
(assert (not (<
  ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
    ($unwrap<Int> l$i2$numerator@1846@01)
    l$i2$denominator@1851@01))
  0)))
(check-sat)
; unknown
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
      ($unwrap<Int> l$i2$numerator@1846@01)
      l$i2$denominator@1851@01))
    0))))
(check-sat)
; unknown
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
; [then-branch: 503 | !($div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) < 0) | live]
; [else-branch: 503 | $div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) < 0 | live]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 503 | !($div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) < 0)]
(assert (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
      ($unwrap<Int> l$i2$numerator@1846@01)
      l$i2$denominator@1851@01))
    0)))
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
      ($unwrap<Int> l$i2$numerator@1846@01)
      l$i2$denominator@1851@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 504 | $div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 504 | !($div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 18
; [else-branch: 504 | !($div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
      ($unwrap<Int> l$i2$numerator@1846@01)
      l$i2$denominator@1851@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 18
; [eval] !($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 18
(set-option :timeout 10)
(assert (not (>
  ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
    ($unwrap<Int> l$i2$numerator@1846@01)
    l$i2$denominator@1851@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
      ($unwrap<Int> l$i2$numerator@1846@01)
      l$i2$denominator@1851@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 505 | !($div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 505 | $div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 505 | !($div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
      ($unwrap<Int> l$i2$numerator@1846@01)
      l$i2$denominator@1851@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; i2$$res := $unwrap($wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \
;   l$i2$denominator)))
; [eval] $unwrap($wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)))
; [eval] $wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator))
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(declare-const i2$$res@1852@01 Int)
(assert (=
  i2$$res@1852@01
  ($unwrap<Int> ($wrap<$Int> ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
    ($unwrap<Int> l$i2$numerator@1846@01)
    l$i2$denominator@1851@01))))))
; [exec]
; label i2$return
; [exec]
; l$i0$tokens_bought := $wrap(i2$$res)
; [eval] $wrap(i2$$res)
(declare-const l$i0$tokens_bought@1853@01 $Int)
(assert (= l$i0$tokens_bought@1853@01 ($wrap<$Int> i2$$res@1852@01)))
; [eval] !($unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens))
; [eval] $unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens)
; [eval] $unwrap(l$i0$tokens_bought)
; [eval] $unwrap(l$i0$min_tokens)
(push) ; 19
(set-option :timeout 10)
(assert (not (>=
  ($unwrap<Int> l$i0$tokens_bought@1853@01)
  ($unwrap<Int> l$min_tokens@1660@01))))
(check-sat)
; unknown
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (not
  (>=
    ($unwrap<Int> l$i0$tokens_bought@1853@01)
    ($unwrap<Int> l$min_tokens@1660@01)))))
(check-sat)
; unknown
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
; [then-branch: 506 | !($unwrap[Int](l$i0$tokens_bought@1853@01) >= $unwrap[Int](l$min_tokens@1660@01)) | live]
; [else-branch: 506 | $unwrap[Int](l$i0$tokens_bought@1853@01) >= $unwrap[Int](l$min_tokens@1660@01) | live]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 506 | !($unwrap[Int](l$i0$tokens_bought@1853@01) >= $unwrap[Int](l$min_tokens@1660@01))]
(assert (not
  (>=
    ($unwrap<Int> l$i0$tokens_bought@1853@01)
    ($unwrap<Int> l$min_tokens@1660@01))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 20
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
; [then-branch: 507 | True | live]
; [else-branch: 507 | False | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 507 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1854@01 $Snap)
(assert (= $t@1854@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1855@01 $Struct)
(assert (=
  self@1855@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 20
; [then-branch: 508 | False | dead]
; [else-branch: 508 | True | live]
(set-option :timeout 0)
(push) ; 20
; [else-branch: 508 | True]
(pop) ; 20
(pop) ; 19
(push) ; 19
; [else-branch: 506 | $unwrap[Int](l$i0$tokens_bought@1853@01) >= $unwrap[Int](l$min_tokens@1660@01)]
(assert (>=
  ($unwrap<Int> l$i0$tokens_bought@1853@01)
  ($unwrap<Int> l$min_tokens@1660@01)))
(pop) ; 19
; [eval] !!($unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens))
; [eval] !($unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens))
; [eval] $unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens)
; [eval] $unwrap(l$i0$tokens_bought)
; [eval] $unwrap(l$i0$min_tokens)
(push) ; 19
(set-option :timeout 10)
(assert (not (not
  (>=
    ($unwrap<Int> l$i0$tokens_bought@1853@01)
    ($unwrap<Int> l$min_tokens@1660@01)))))
(check-sat)
; unknown
(pop) ; 19
; 0.02s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (>=
  ($unwrap<Int> l$i0$tokens_bought@1853@01)
  ($unwrap<Int> l$min_tokens@1660@01))))
(check-sat)
; unknown
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
; [then-branch: 509 | $unwrap[Int](l$i0$tokens_bought@1853@01) >= $unwrap[Int](l$min_tokens@1660@01) | live]
; [else-branch: 509 | !($unwrap[Int](l$i0$tokens_bought@1853@01) >= $unwrap[Int](l$min_tokens@1660@01)) | live]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 509 | $unwrap[Int](l$i0$tokens_bought@1853@01) >= $unwrap[Int](l$min_tokens@1660@01)]
(assert (>=
  ($unwrap<Int> l$i0$tokens_bought@1853@01)
  ($unwrap<Int> l$min_tokens@1660@01)))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1856@01 Int)
(declare-const $arg1@1857@01 Int)
(declare-const $arg2@1858@01 Int)
(push) ; 20
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1859@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef162|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef163|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1856@01)
    ($SortWrappers.IntTo$Snap $arg1@1857@01))
  ($SortWrappers.IntTo$Snap $arg2@1858@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1856@01)
    ($SortWrappers.IntTo$Snap $arg1@1857@01))
  ($SortWrappers.IntTo$Snap $arg2@1858@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1856@01)
      ($SortWrappers.IntTo$Snap $arg1@1857@01))
    ($SortWrappers.IntTo$Snap $arg2@1858@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1860@01 (Int Int Int) Int)
(declare-fun img@1861@01 (Int Int Int) Bool)
(declare-fun inv@1862@01 (Int Int Int) Int)
(declare-fun img@1863@01 (Int Int Int) Bool)
(declare-fun inv@1864@01 (Int Int Int) Int)
(declare-fun img@1865@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef162|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef163|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1856@01 Int) ($arg1@1857@01 Int) ($arg2@1858@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1856@01)
          ($SortWrappers.IntTo$Snap $arg1@1857@01))
        ($SortWrappers.IntTo$Snap $arg2@1858@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1856@01)
        ($SortWrappers.IntTo$Snap $arg1@1857@01))
      ($SortWrappers.IntTo$Snap $arg2@1858@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1856@01)
        ($SortWrappers.IntTo$Snap $arg1@1857@01))
      ($SortWrappers.IntTo$Snap $arg2@1858@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1856@01)
      ($SortWrappers.IntTo$Snap $arg1@1857@01))
    ($SortWrappers.IntTo$Snap $arg2@1858@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1856@01)
      ($SortWrappers.IntTo$Snap $arg1@1857@01))
    ($SortWrappers.IntTo$Snap $arg2@1858@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1856@01 Int) ($arg1@1857@01 Int) ($arg2@1858@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1856@01)
          ($SortWrappers.IntTo$Snap $arg1@1857@01))
        ($SortWrappers.IntTo$Snap $arg2@1858@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1856@01)
            ($SortWrappers.IntTo$Snap $arg1@1857@01))
          ($SortWrappers.IntTo$Snap $arg2@1858@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1856@01)
            ($SortWrappers.IntTo$Snap $arg1@1857@01))
          ($SortWrappers.IntTo$Snap $arg2@1858@01))))))
  
  :qid |quant-u-1827|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1856@01 Int) ($arg11@1857@01 Int) ($arg21@1858@01 Int) ($arg02@1856@01 Int) ($arg12@1857@01 Int) ($arg22@1858@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1856@01)
                ($SortWrappers.IntTo$Snap $arg11@1857@01))
              ($SortWrappers.IntTo$Snap $arg21@1858@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1856@01)
              ($SortWrappers.IntTo$Snap $arg11@1857@01))
            ($SortWrappers.IntTo$Snap $arg21@1858@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1856@01)
              ($SortWrappers.IntTo$Snap $arg11@1857@01))
            ($SortWrappers.IntTo$Snap $arg21@1858@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1856@01)
              ($SortWrappers.IntTo$Snap $arg11@1857@01))
            ($SortWrappers.IntTo$Snap $arg21@1858@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1856@01)
                ($SortWrappers.IntTo$Snap $arg12@1857@01))
              ($SortWrappers.IntTo$Snap $arg22@1858@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1856@01)
              ($SortWrappers.IntTo$Snap $arg12@1857@01))
            ($SortWrappers.IntTo$Snap $arg22@1858@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1856@01)
              ($SortWrappers.IntTo$Snap $arg12@1857@01))
            ($SortWrappers.IntTo$Snap $arg22@1858@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1856@01)
              ($SortWrappers.IntTo$Snap $arg12@1857@01))
            ($SortWrappers.IntTo$Snap $arg22@1858@01)))))
      (and
        (and (= $arg01@1856@01 $arg02@1856@01) (= $arg11@1857@01 $arg12@1857@01))
        (= $arg21@1858@01 $arg22@1858@01)))
    (and
      (and (= $arg01@1856@01 $arg02@1856@01) (= $arg11@1857@01 $arg12@1857@01))
      (= $arg21@1858@01 $arg22@1858@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1856@01 Int) ($arg1@1857@01 Int) ($arg2@1858@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1856@01)
            ($SortWrappers.IntTo$Snap $arg1@1857@01))
          ($SortWrappers.IntTo$Snap $arg2@1858@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1856@01)
            ($SortWrappers.IntTo$Snap $arg1@1857@01))
          ($SortWrappers.IntTo$Snap $arg2@1858@01)))))
    (and
      (and
        (= (inv@1860@01 $arg0@1856@01 $arg1@1857@01 $arg2@1858@01) $arg0@1856@01)
        (= (inv@1862@01 $arg0@1856@01 $arg1@1857@01 $arg2@1858@01) $arg1@1857@01)
        (= (inv@1864@01 $arg0@1856@01 $arg1@1857@01 $arg2@1858@01) $arg2@1858@01))
      (and
        (img@1861@01 $arg0@1856@01 $arg1@1857@01 $arg2@1858@01)
        (img@1863@01 $arg0@1856@01 $arg1@1857@01 $arg2@1858@01)
        (img@1865@01 $arg0@1856@01 $arg1@1857@01 $arg2@1858@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1856@01)
      ($SortWrappers.IntTo$Snap $arg1@1857@01))
    ($SortWrappers.IntTo$Snap $arg2@1858@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1856@01)
      ($SortWrappers.IntTo$Snap $arg1@1857@01))
    ($SortWrappers.IntTo$Snap $arg2@1858@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1861@01 $arg0 $arg1 $arg2)
        (img@1863@01 $arg0 $arg1 $arg2)
        (img@1865@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1860@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1862@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1864@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1860@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1862@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1864@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1860@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1862@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1864@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1860@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1862@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1864@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1860@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1862@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1864@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1860@01 $arg0 $arg1 $arg2) (inv@1862@01 $arg0 $arg1 $arg2) (inv@1864@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1828|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1860@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1862@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1864@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1861@01 $arg0 $arg1 $arg2)
        (img@1863@01 $arg0 $arg1 $arg2)
        (img@1865@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1860@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1862@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1864@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@1859@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1860@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1862@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1864@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1829|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1866@01 Int)
(declare-const $arg1@1867@01 Int)
(declare-const $arg2@1868@01 Int)
(push) ; 20
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1869@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef164|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef165|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1866@01)
    ($SortWrappers.IntTo$Snap $arg1@1867@01))
  ($SortWrappers.IntTo$Snap $arg2@1868@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1866@01)
    ($SortWrappers.IntTo$Snap $arg1@1867@01))
  ($SortWrappers.IntTo$Snap $arg2@1868@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1866@01)
      ($SortWrappers.IntTo$Snap $arg1@1867@01))
    ($SortWrappers.IntTo$Snap $arg2@1868@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1870@01 (Int Int Int) Int)
(declare-fun img@1871@01 (Int Int Int) Bool)
(declare-fun inv@1872@01 (Int Int Int) Int)
(declare-fun img@1873@01 (Int Int Int) Bool)
(declare-fun inv@1874@01 (Int Int Int) Int)
(declare-fun img@1875@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef164|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef165|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1866@01 Int) ($arg1@1867@01 Int) ($arg2@1868@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1866@01)
          ($SortWrappers.IntTo$Snap $arg1@1867@01))
        ($SortWrappers.IntTo$Snap $arg2@1868@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1866@01)
        ($SortWrappers.IntTo$Snap $arg1@1867@01))
      ($SortWrappers.IntTo$Snap $arg2@1868@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1866@01)
        ($SortWrappers.IntTo$Snap $arg1@1867@01))
      ($SortWrappers.IntTo$Snap $arg2@1868@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1866@01)
      ($SortWrappers.IntTo$Snap $arg1@1867@01))
    ($SortWrappers.IntTo$Snap $arg2@1868@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1866@01)
      ($SortWrappers.IntTo$Snap $arg1@1867@01))
    ($SortWrappers.IntTo$Snap $arg2@1868@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1866@01 Int) ($arg1@1867@01 Int) ($arg2@1868@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1866@01)
          ($SortWrappers.IntTo$Snap $arg1@1867@01))
        ($SortWrappers.IntTo$Snap $arg2@1868@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1866@01)
            ($SortWrappers.IntTo$Snap $arg1@1867@01))
          ($SortWrappers.IntTo$Snap $arg2@1868@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1866@01)
            ($SortWrappers.IntTo$Snap $arg1@1867@01))
          ($SortWrappers.IntTo$Snap $arg2@1868@01))))))
  
  :qid |quant-u-1830|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1866@01 Int) ($arg11@1867@01 Int) ($arg21@1868@01 Int) ($arg02@1866@01 Int) ($arg12@1867@01 Int) ($arg22@1868@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1866@01)
                ($SortWrappers.IntTo$Snap $arg11@1867@01))
              ($SortWrappers.IntTo$Snap $arg21@1868@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1866@01)
              ($SortWrappers.IntTo$Snap $arg11@1867@01))
            ($SortWrappers.IntTo$Snap $arg21@1868@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1866@01)
              ($SortWrappers.IntTo$Snap $arg11@1867@01))
            ($SortWrappers.IntTo$Snap $arg21@1868@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1866@01)
              ($SortWrappers.IntTo$Snap $arg11@1867@01))
            ($SortWrappers.IntTo$Snap $arg21@1868@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1866@01)
                ($SortWrappers.IntTo$Snap $arg12@1867@01))
              ($SortWrappers.IntTo$Snap $arg22@1868@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1866@01)
              ($SortWrappers.IntTo$Snap $arg12@1867@01))
            ($SortWrappers.IntTo$Snap $arg22@1868@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1866@01)
              ($SortWrappers.IntTo$Snap $arg12@1867@01))
            ($SortWrappers.IntTo$Snap $arg22@1868@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1866@01)
              ($SortWrappers.IntTo$Snap $arg12@1867@01))
            ($SortWrappers.IntTo$Snap $arg22@1868@01)))))
      (and
        (and (= $arg01@1866@01 $arg02@1866@01) (= $arg11@1867@01 $arg12@1867@01))
        (= $arg21@1868@01 $arg22@1868@01)))
    (and
      (and (= $arg01@1866@01 $arg02@1866@01) (= $arg11@1867@01 $arg12@1867@01))
      (= $arg21@1868@01 $arg22@1868@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1866@01 Int) ($arg1@1867@01 Int) ($arg2@1868@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1866@01)
            ($SortWrappers.IntTo$Snap $arg1@1867@01))
          ($SortWrappers.IntTo$Snap $arg2@1868@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1866@01)
            ($SortWrappers.IntTo$Snap $arg1@1867@01))
          ($SortWrappers.IntTo$Snap $arg2@1868@01)))))
    (and
      (and
        (= (inv@1870@01 $arg0@1866@01 $arg1@1867@01 $arg2@1868@01) $arg0@1866@01)
        (= (inv@1872@01 $arg0@1866@01 $arg1@1867@01 $arg2@1868@01) $arg1@1867@01)
        (= (inv@1874@01 $arg0@1866@01 $arg1@1867@01 $arg2@1868@01) $arg2@1868@01))
      (and
        (img@1871@01 $arg0@1866@01 $arg1@1867@01 $arg2@1868@01)
        (img@1873@01 $arg0@1866@01 $arg1@1867@01 $arg2@1868@01)
        (img@1875@01 $arg0@1866@01 $arg1@1867@01 $arg2@1868@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1866@01)
      ($SortWrappers.IntTo$Snap $arg1@1867@01))
    ($SortWrappers.IntTo$Snap $arg2@1868@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1866@01)
      ($SortWrappers.IntTo$Snap $arg1@1867@01))
    ($SortWrappers.IntTo$Snap $arg2@1868@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1871@01 $arg0 $arg1 $arg2)
        (img@1873@01 $arg0 $arg1 $arg2)
        (img@1875@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1870@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1872@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1874@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1870@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1872@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1874@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1870@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1872@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1874@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1870@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1872@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1874@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1870@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1872@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1874@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@1776@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1870@01 $arg0 $arg1 $arg2) (inv@1872@01 $arg0 $arg1 $arg2) (inv@1874@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1831|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1870@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1872@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1874@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1871@01 $arg0 $arg1 $arg2)
        (img@1873@01 $arg0 $arg1 $arg2)
        (img@1875@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1870@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1872@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1874@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@1869@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1870@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1872@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1874@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1832|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@1876@01 Int)
(declare-const $arg1@1877@01 Int)
(declare-const $arg2@1878@01 Int)
(push) ; 20
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1879@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef166|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef167|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1876@01)
    ($SortWrappers.IntTo$Snap $arg1@1877@01))
  ($SortWrappers.IntTo$Snap $arg2@1878@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1876@01)
    ($SortWrappers.IntTo$Snap $arg1@1877@01))
  ($SortWrappers.IntTo$Snap $arg2@1878@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1876@01)
      ($SortWrappers.IntTo$Snap $arg1@1877@01))
    ($SortWrappers.IntTo$Snap $arg2@1878@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1880@01 (Int Int Int) Int)
(declare-fun img@1881@01 (Int Int Int) Bool)
(declare-fun inv@1882@01 (Int Int Int) Int)
(declare-fun img@1883@01 (Int Int Int) Bool)
(declare-fun inv@1884@01 (Int Int Int) Int)
(declare-fun img@1885@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef166|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef167|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1876@01 Int) ($arg1@1877@01 Int) ($arg2@1878@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1876@01)
          ($SortWrappers.IntTo$Snap $arg1@1877@01))
        ($SortWrappers.IntTo$Snap $arg2@1878@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1876@01)
        ($SortWrappers.IntTo$Snap $arg1@1877@01))
      ($SortWrappers.IntTo$Snap $arg2@1878@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1876@01)
        ($SortWrappers.IntTo$Snap $arg1@1877@01))
      ($SortWrappers.IntTo$Snap $arg2@1878@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1876@01)
      ($SortWrappers.IntTo$Snap $arg1@1877@01))
    ($SortWrappers.IntTo$Snap $arg2@1878@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1876@01)
      ($SortWrappers.IntTo$Snap $arg1@1877@01))
    ($SortWrappers.IntTo$Snap $arg2@1878@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1876@01 Int) ($arg1@1877@01 Int) ($arg2@1878@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1876@01)
          ($SortWrappers.IntTo$Snap $arg1@1877@01))
        ($SortWrappers.IntTo$Snap $arg2@1878@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1876@01)
            ($SortWrappers.IntTo$Snap $arg1@1877@01))
          ($SortWrappers.IntTo$Snap $arg2@1878@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1876@01)
            ($SortWrappers.IntTo$Snap $arg1@1877@01))
          ($SortWrappers.IntTo$Snap $arg2@1878@01))))))
  
  :qid |quant-u-1833|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1876@01 Int) ($arg11@1877@01 Int) ($arg21@1878@01 Int) ($arg02@1876@01 Int) ($arg12@1877@01 Int) ($arg22@1878@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1876@01)
                ($SortWrappers.IntTo$Snap $arg11@1877@01))
              ($SortWrappers.IntTo$Snap $arg21@1878@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1876@01)
              ($SortWrappers.IntTo$Snap $arg11@1877@01))
            ($SortWrappers.IntTo$Snap $arg21@1878@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1876@01)
              ($SortWrappers.IntTo$Snap $arg11@1877@01))
            ($SortWrappers.IntTo$Snap $arg21@1878@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1876@01)
              ($SortWrappers.IntTo$Snap $arg11@1877@01))
            ($SortWrappers.IntTo$Snap $arg21@1878@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1876@01)
                ($SortWrappers.IntTo$Snap $arg12@1877@01))
              ($SortWrappers.IntTo$Snap $arg22@1878@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1876@01)
              ($SortWrappers.IntTo$Snap $arg12@1877@01))
            ($SortWrappers.IntTo$Snap $arg22@1878@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1876@01)
              ($SortWrappers.IntTo$Snap $arg12@1877@01))
            ($SortWrappers.IntTo$Snap $arg22@1878@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1876@01)
              ($SortWrappers.IntTo$Snap $arg12@1877@01))
            ($SortWrappers.IntTo$Snap $arg22@1878@01)))))
      (and
        (and (= $arg01@1876@01 $arg02@1876@01) (= $arg11@1877@01 $arg12@1877@01))
        (= $arg21@1878@01 $arg22@1878@01)))
    (and
      (and (= $arg01@1876@01 $arg02@1876@01) (= $arg11@1877@01 $arg12@1877@01))
      (= $arg21@1878@01 $arg22@1878@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1876@01 Int) ($arg1@1877@01 Int) ($arg2@1878@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1876@01)
            ($SortWrappers.IntTo$Snap $arg1@1877@01))
          ($SortWrappers.IntTo$Snap $arg2@1878@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1876@01)
            ($SortWrappers.IntTo$Snap $arg1@1877@01))
          ($SortWrappers.IntTo$Snap $arg2@1878@01)))))
    (and
      (and
        (= (inv@1880@01 $arg0@1876@01 $arg1@1877@01 $arg2@1878@01) $arg0@1876@01)
        (= (inv@1882@01 $arg0@1876@01 $arg1@1877@01 $arg2@1878@01) $arg1@1877@01)
        (= (inv@1884@01 $arg0@1876@01 $arg1@1877@01 $arg2@1878@01) $arg2@1878@01))
      (and
        (img@1881@01 $arg0@1876@01 $arg1@1877@01 $arg2@1878@01)
        (img@1883@01 $arg0@1876@01 $arg1@1877@01 $arg2@1878@01)
        (img@1885@01 $arg0@1876@01 $arg1@1877@01 $arg2@1878@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1876@01)
      ($SortWrappers.IntTo$Snap $arg1@1877@01))
    ($SortWrappers.IntTo$Snap $arg2@1878@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1876@01)
      ($SortWrappers.IntTo$Snap $arg1@1877@01))
    ($SortWrappers.IntTo$Snap $arg2@1878@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1881@01 $arg0 $arg1 $arg2)
        (img@1883@01 $arg0 $arg1 $arg2)
        (img@1885@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1880@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1882@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1884@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1880@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1882@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1884@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1880@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1882@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1884@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1880@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1882@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1884@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1880@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1882@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1884@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@1788@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1880@01 $arg0 $arg1 $arg2) (inv@1882@01 $arg0 $arg1 $arg2) (inv@1884@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1834|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1880@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1882@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1884@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1881@01 $arg0 $arg1 $arg2)
        (img@1883@01 $arg0 $arg1 $arg2)
        (img@1885@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1880@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1882@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1884@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@1879@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1880@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1882@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1884@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1835|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@1886@01 Int)
(declare-const $arg1@1887@01 Int)
(declare-const $arg2@1888@01 Int)
(push) ; 20
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1889@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef168|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef169|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1886@01)
    ($SortWrappers.IntTo$Snap $arg1@1887@01))
  ($SortWrappers.IntTo$Snap $arg2@1888@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1886@01)
    ($SortWrappers.IntTo$Snap $arg1@1887@01))
  ($SortWrappers.IntTo$Snap $arg2@1888@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1886@01)
      ($SortWrappers.IntTo$Snap $arg1@1887@01))
    ($SortWrappers.IntTo$Snap $arg2@1888@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1890@01 (Int Int Int) Int)
(declare-fun img@1891@01 (Int Int Int) Bool)
(declare-fun inv@1892@01 (Int Int Int) Int)
(declare-fun img@1893@01 (Int Int Int) Bool)
(declare-fun inv@1894@01 (Int Int Int) Int)
(declare-fun img@1895@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef168|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef169|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1886@01 Int) ($arg1@1887@01 Int) ($arg2@1888@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1886@01)
          ($SortWrappers.IntTo$Snap $arg1@1887@01))
        ($SortWrappers.IntTo$Snap $arg2@1888@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1886@01)
        ($SortWrappers.IntTo$Snap $arg1@1887@01))
      ($SortWrappers.IntTo$Snap $arg2@1888@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1886@01)
        ($SortWrappers.IntTo$Snap $arg1@1887@01))
      ($SortWrappers.IntTo$Snap $arg2@1888@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1886@01)
      ($SortWrappers.IntTo$Snap $arg1@1887@01))
    ($SortWrappers.IntTo$Snap $arg2@1888@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1886@01)
      ($SortWrappers.IntTo$Snap $arg1@1887@01))
    ($SortWrappers.IntTo$Snap $arg2@1888@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1886@01 Int) ($arg1@1887@01 Int) ($arg2@1888@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1886@01)
          ($SortWrappers.IntTo$Snap $arg1@1887@01))
        ($SortWrappers.IntTo$Snap $arg2@1888@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1886@01)
            ($SortWrappers.IntTo$Snap $arg1@1887@01))
          ($SortWrappers.IntTo$Snap $arg2@1888@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1886@01)
            ($SortWrappers.IntTo$Snap $arg1@1887@01))
          ($SortWrappers.IntTo$Snap $arg2@1888@01))))))
  
  :qid |quant-u-1836|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1886@01 Int) ($arg11@1887@01 Int) ($arg21@1888@01 Int) ($arg02@1886@01 Int) ($arg12@1887@01 Int) ($arg22@1888@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1886@01)
                ($SortWrappers.IntTo$Snap $arg11@1887@01))
              ($SortWrappers.IntTo$Snap $arg21@1888@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1886@01)
              ($SortWrappers.IntTo$Snap $arg11@1887@01))
            ($SortWrappers.IntTo$Snap $arg21@1888@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1886@01)
              ($SortWrappers.IntTo$Snap $arg11@1887@01))
            ($SortWrappers.IntTo$Snap $arg21@1888@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1886@01)
              ($SortWrappers.IntTo$Snap $arg11@1887@01))
            ($SortWrappers.IntTo$Snap $arg21@1888@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1886@01)
                ($SortWrappers.IntTo$Snap $arg12@1887@01))
              ($SortWrappers.IntTo$Snap $arg22@1888@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1886@01)
              ($SortWrappers.IntTo$Snap $arg12@1887@01))
            ($SortWrappers.IntTo$Snap $arg22@1888@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1886@01)
              ($SortWrappers.IntTo$Snap $arg12@1887@01))
            ($SortWrappers.IntTo$Snap $arg22@1888@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1886@01)
              ($SortWrappers.IntTo$Snap $arg12@1887@01))
            ($SortWrappers.IntTo$Snap $arg22@1888@01)))))
      (and
        (and (= $arg01@1886@01 $arg02@1886@01) (= $arg11@1887@01 $arg12@1887@01))
        (= $arg21@1888@01 $arg22@1888@01)))
    (and
      (and (= $arg01@1886@01 $arg02@1886@01) (= $arg11@1887@01 $arg12@1887@01))
      (= $arg21@1888@01 $arg22@1888@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1886@01 Int) ($arg1@1887@01 Int) ($arg2@1888@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1886@01)
            ($SortWrappers.IntTo$Snap $arg1@1887@01))
          ($SortWrappers.IntTo$Snap $arg2@1888@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1886@01)
            ($SortWrappers.IntTo$Snap $arg1@1887@01))
          ($SortWrappers.IntTo$Snap $arg2@1888@01)))))
    (and
      (and
        (= (inv@1890@01 $arg0@1886@01 $arg1@1887@01 $arg2@1888@01) $arg0@1886@01)
        (= (inv@1892@01 $arg0@1886@01 $arg1@1887@01 $arg2@1888@01) $arg1@1887@01)
        (= (inv@1894@01 $arg0@1886@01 $arg1@1887@01 $arg2@1888@01) $arg2@1888@01))
      (and
        (img@1891@01 $arg0@1886@01 $arg1@1887@01 $arg2@1888@01)
        (img@1893@01 $arg0@1886@01 $arg1@1887@01 $arg2@1888@01)
        (img@1895@01 $arg0@1886@01 $arg1@1887@01 $arg2@1888@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1886@01)
      ($SortWrappers.IntTo$Snap $arg1@1887@01))
    ($SortWrappers.IntTo$Snap $arg2@1888@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1886@01)
      ($SortWrappers.IntTo$Snap $arg1@1887@01))
    ($SortWrappers.IntTo$Snap $arg2@1888@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1891@01 $arg0 $arg1 $arg2)
        (img@1893@01 $arg0 $arg1 $arg2)
        (img@1895@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1890@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1892@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1894@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1890@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1892@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1894@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1890@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1892@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1894@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1890@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1892@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1894@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1890@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1892@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1894@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@1800@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1890@01 $arg0 $arg1 $arg2) (inv@1892@01 $arg0 $arg1 $arg2) (inv@1894@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1837|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1890@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1892@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1894@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1891@01 $arg0 $arg1 $arg2)
        (img@1893@01 $arg0 $arg1 $arg2)
        (img@1895@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1890@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1892@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1894@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@1889@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1890@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1892@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1894@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1838|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@1896@01 Int)
(declare-const $arg1@1897@01 Int)
(declare-const $arg2@1898@01 Int)
(push) ; 20
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1899@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef170|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef171|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1896@01)
    ($SortWrappers.IntTo$Snap $arg1@1897@01))
  ($SortWrappers.IntTo$Snap $arg2@1898@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1896@01)
    ($SortWrappers.IntTo$Snap $arg1@1897@01))
  ($SortWrappers.IntTo$Snap $arg2@1898@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1896@01)
      ($SortWrappers.IntTo$Snap $arg1@1897@01))
    ($SortWrappers.IntTo$Snap $arg2@1898@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1900@01 (Int Int Int) Int)
(declare-fun img@1901@01 (Int Int Int) Bool)
(declare-fun inv@1902@01 (Int Int Int) Int)
(declare-fun img@1903@01 (Int Int Int) Bool)
(declare-fun inv@1904@01 (Int Int Int) Int)
(declare-fun img@1905@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef170|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef171|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1896@01 Int) ($arg1@1897@01 Int) ($arg2@1898@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1896@01)
          ($SortWrappers.IntTo$Snap $arg1@1897@01))
        ($SortWrappers.IntTo$Snap $arg2@1898@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1896@01)
        ($SortWrappers.IntTo$Snap $arg1@1897@01))
      ($SortWrappers.IntTo$Snap $arg2@1898@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1896@01)
        ($SortWrappers.IntTo$Snap $arg1@1897@01))
      ($SortWrappers.IntTo$Snap $arg2@1898@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1896@01)
      ($SortWrappers.IntTo$Snap $arg1@1897@01))
    ($SortWrappers.IntTo$Snap $arg2@1898@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1896@01)
      ($SortWrappers.IntTo$Snap $arg1@1897@01))
    ($SortWrappers.IntTo$Snap $arg2@1898@01))))
  :qid |e$Transfer-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1896@01 Int) ($arg1@1897@01 Int) ($arg2@1898@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1896@01)
          ($SortWrappers.IntTo$Snap $arg1@1897@01))
        ($SortWrappers.IntTo$Snap $arg2@1898@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1896@01)
            ($SortWrappers.IntTo$Snap $arg1@1897@01))
          ($SortWrappers.IntTo$Snap $arg2@1898@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1896@01)
            ($SortWrappers.IntTo$Snap $arg1@1897@01))
          ($SortWrappers.IntTo$Snap $arg2@1898@01))))))
  
  :qid |quant-u-1839|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1896@01 Int) ($arg11@1897@01 Int) ($arg21@1898@01 Int) ($arg02@1896@01 Int) ($arg12@1897@01 Int) ($arg22@1898@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1896@01)
                ($SortWrappers.IntTo$Snap $arg11@1897@01))
              ($SortWrappers.IntTo$Snap $arg21@1898@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1896@01)
              ($SortWrappers.IntTo$Snap $arg11@1897@01))
            ($SortWrappers.IntTo$Snap $arg21@1898@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1896@01)
              ($SortWrappers.IntTo$Snap $arg11@1897@01))
            ($SortWrappers.IntTo$Snap $arg21@1898@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1896@01)
              ($SortWrappers.IntTo$Snap $arg11@1897@01))
            ($SortWrappers.IntTo$Snap $arg21@1898@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1896@01)
                ($SortWrappers.IntTo$Snap $arg12@1897@01))
              ($SortWrappers.IntTo$Snap $arg22@1898@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1896@01)
              ($SortWrappers.IntTo$Snap $arg12@1897@01))
            ($SortWrappers.IntTo$Snap $arg22@1898@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1896@01)
              ($SortWrappers.IntTo$Snap $arg12@1897@01))
            ($SortWrappers.IntTo$Snap $arg22@1898@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1896@01)
              ($SortWrappers.IntTo$Snap $arg12@1897@01))
            ($SortWrappers.IntTo$Snap $arg22@1898@01)))))
      (and
        (and (= $arg01@1896@01 $arg02@1896@01) (= $arg11@1897@01 $arg12@1897@01))
        (= $arg21@1898@01 $arg22@1898@01)))
    (and
      (and (= $arg01@1896@01 $arg02@1896@01) (= $arg11@1897@01 $arg12@1897@01))
      (= $arg21@1898@01 $arg22@1898@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1896@01 Int) ($arg1@1897@01 Int) ($arg2@1898@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1896@01)
            ($SortWrappers.IntTo$Snap $arg1@1897@01))
          ($SortWrappers.IntTo$Snap $arg2@1898@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1896@01)
            ($SortWrappers.IntTo$Snap $arg1@1897@01))
          ($SortWrappers.IntTo$Snap $arg2@1898@01)))))
    (and
      (and
        (= (inv@1900@01 $arg0@1896@01 $arg1@1897@01 $arg2@1898@01) $arg0@1896@01)
        (= (inv@1902@01 $arg0@1896@01 $arg1@1897@01 $arg2@1898@01) $arg1@1897@01)
        (= (inv@1904@01 $arg0@1896@01 $arg1@1897@01 $arg2@1898@01) $arg2@1898@01))
      (and
        (img@1901@01 $arg0@1896@01 $arg1@1897@01 $arg2@1898@01)
        (img@1903@01 $arg0@1896@01 $arg1@1897@01 $arg2@1898@01)
        (img@1905@01 $arg0@1896@01 $arg1@1897@01 $arg2@1898@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1896@01)
      ($SortWrappers.IntTo$Snap $arg1@1897@01))
    ($SortWrappers.IntTo$Snap $arg2@1898@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1896@01)
      ($SortWrappers.IntTo$Snap $arg1@1897@01))
    ($SortWrappers.IntTo$Snap $arg2@1898@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1901@01 $arg0 $arg1 $arg2)
        (img@1903@01 $arg0 $arg1 $arg2)
        (img@1905@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1900@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1902@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1904@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1900@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1902@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1904@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1900@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1902@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1904@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1900@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1902@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1904@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1900@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1902@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1904@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@1812@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1900@01 $arg0 $arg1 $arg2) (inv@1902@01 $arg0 $arg1 $arg2) (inv@1904@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1840|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1900@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1902@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1904@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1901@01 $arg0 $arg1 $arg2)
        (img@1903@01 $arg0 $arg1 $arg2)
        (img@1905@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1900@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1902@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1904@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@1899@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1900@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1902@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1904@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1841|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@1906@01 Int)
(declare-const $arg1@1907@01 Int)
(declare-const $arg2@1908@01 Int)
(push) ; 20
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@1909@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef172|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef173|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1906@01)
    ($SortWrappers.IntTo$Snap $arg1@1907@01))
  ($SortWrappers.IntTo$Snap $arg2@1908@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@1906@01)
    ($SortWrappers.IntTo$Snap $arg1@1907@01))
  ($SortWrappers.IntTo$Snap $arg2@1908@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1906@01)
      ($SortWrappers.IntTo$Snap $arg1@1907@01))
    ($SortWrappers.IntTo$Snap $arg2@1908@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 20
(declare-fun inv@1910@01 (Int Int Int) Int)
(declare-fun img@1911@01 (Int Int Int) Bool)
(declare-fun inv@1912@01 (Int Int Int) Int)
(declare-fun img@1913@01 (Int Int Int) Bool)
(declare-fun inv@1914@01 (Int Int Int) Int)
(declare-fun img@1915@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef172|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef173|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@1906@01 Int) ($arg1@1907@01 Int) ($arg2@1908@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1906@01)
          ($SortWrappers.IntTo$Snap $arg1@1907@01))
        ($SortWrappers.IntTo$Snap $arg2@1908@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1906@01)
        ($SortWrappers.IntTo$Snap $arg1@1907@01))
      ($SortWrappers.IntTo$Snap $arg2@1908@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@1906@01)
        ($SortWrappers.IntTo$Snap $arg1@1907@01))
      ($SortWrappers.IntTo$Snap $arg2@1908@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1906@01)
      ($SortWrappers.IntTo$Snap $arg1@1907@01))
    ($SortWrappers.IntTo$Snap $arg2@1908@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1906@01)
      ($SortWrappers.IntTo$Snap $arg1@1907@01))
    ($SortWrappers.IntTo$Snap $arg2@1908@01))))
  :qid |e$Approval-aux|)))
(push) ; 20
(assert (not (forall (($arg0@1906@01 Int) ($arg1@1907@01 Int) ($arg2@1908@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@1906@01)
          ($SortWrappers.IntTo$Snap $arg1@1907@01))
        ($SortWrappers.IntTo$Snap $arg2@1908@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1906@01)
            ($SortWrappers.IntTo$Snap $arg1@1907@01))
          ($SortWrappers.IntTo$Snap $arg2@1908@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1906@01)
            ($SortWrappers.IntTo$Snap $arg1@1907@01))
          ($SortWrappers.IntTo$Snap $arg2@1908@01))))))
  
  :qid |quant-u-1842|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 20
(assert (not (forall (($arg01@1906@01 Int) ($arg11@1907@01 Int) ($arg21@1908@01 Int) ($arg02@1906@01 Int) ($arg12@1907@01 Int) ($arg22@1908@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@1906@01)
                ($SortWrappers.IntTo$Snap $arg11@1907@01))
              ($SortWrappers.IntTo$Snap $arg21@1908@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1906@01)
              ($SortWrappers.IntTo$Snap $arg11@1907@01))
            ($SortWrappers.IntTo$Snap $arg21@1908@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1906@01)
              ($SortWrappers.IntTo$Snap $arg11@1907@01))
            ($SortWrappers.IntTo$Snap $arg21@1908@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@1906@01)
              ($SortWrappers.IntTo$Snap $arg11@1907@01))
            ($SortWrappers.IntTo$Snap $arg21@1908@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@1906@01)
                ($SortWrappers.IntTo$Snap $arg12@1907@01))
              ($SortWrappers.IntTo$Snap $arg22@1908@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1906@01)
              ($SortWrappers.IntTo$Snap $arg12@1907@01))
            ($SortWrappers.IntTo$Snap $arg22@1908@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1906@01)
              ($SortWrappers.IntTo$Snap $arg12@1907@01))
            ($SortWrappers.IntTo$Snap $arg22@1908@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@1906@01)
              ($SortWrappers.IntTo$Snap $arg12@1907@01))
            ($SortWrappers.IntTo$Snap $arg22@1908@01)))))
      (and
        (and (= $arg01@1906@01 $arg02@1906@01) (= $arg11@1907@01 $arg12@1907@01))
        (= $arg21@1908@01 $arg22@1908@01)))
    (and
      (and (= $arg01@1906@01 $arg02@1906@01) (= $arg11@1907@01 $arg12@1907@01))
      (= $arg21@1908@01 $arg22@1908@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@1906@01 Int) ($arg1@1907@01 Int) ($arg2@1908@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1906@01)
            ($SortWrappers.IntTo$Snap $arg1@1907@01))
          ($SortWrappers.IntTo$Snap $arg2@1908@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@1906@01)
            ($SortWrappers.IntTo$Snap $arg1@1907@01))
          ($SortWrappers.IntTo$Snap $arg2@1908@01)))))
    (and
      (and
        (= (inv@1910@01 $arg0@1906@01 $arg1@1907@01 $arg2@1908@01) $arg0@1906@01)
        (= (inv@1912@01 $arg0@1906@01 $arg1@1907@01 $arg2@1908@01) $arg1@1907@01)
        (= (inv@1914@01 $arg0@1906@01 $arg1@1907@01 $arg2@1908@01) $arg2@1908@01))
      (and
        (img@1911@01 $arg0@1906@01 $arg1@1907@01 $arg2@1908@01)
        (img@1913@01 $arg0@1906@01 $arg1@1907@01 $arg2@1908@01)
        (img@1915@01 $arg0@1906@01 $arg1@1907@01 $arg2@1908@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1906@01)
      ($SortWrappers.IntTo$Snap $arg1@1907@01))
    ($SortWrappers.IntTo$Snap $arg2@1908@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@1906@01)
      ($SortWrappers.IntTo$Snap $arg1@1907@01))
    ($SortWrappers.IntTo$Snap $arg2@1908@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@1911@01 $arg0 $arg1 $arg2)
        (img@1913@01 $arg0 $arg1 $arg2)
        (img@1915@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1910@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1912@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1914@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@1910@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@1912@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@1914@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@1910@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@1912@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@1914@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@1910@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1912@01 $arg0 $arg1 $arg2))
  :pattern ((inv@1914@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1910@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1912@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1914@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@1824@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@1910@01 $arg0 $arg1 $arg2) (inv@1912@01 $arg0 $arg1 $arg2) (inv@1914@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1843|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 20
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@1910@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@1912@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@1914@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@1911@01 $arg0 $arg1 $arg2)
        (img@1913@01 $arg0 $arg1 $arg2)
        (img@1915@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@1910@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@1912@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@1914@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@1909@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@1910@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@1912@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@1914@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1844|))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc
(push) ; 20
(set-option :timeout 10)
(assert (not (not l$i0$send_fail$1@1697@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not l$i0$send_fail$1@1697@01))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
; [then-branch: 510 | l$i0$send_fail$1@1697@01 | live]
; [else-branch: 510 | !(l$i0$send_fail$1@1697@01) | live]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 510 | l$i0$send_fail$1@1697@01]
(assert l$i0$send_fail$1@1697@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@1916@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
; [then-branch: 511 | True | live]
; [else-branch: 511 | False | dead]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 511 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1917@01 $Snap)
(assert (= $t@1917@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1918@01 $Struct)
(assert (=
  self@1918@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 21
; [then-branch: 512 | False | dead]
; [else-branch: 512 | True | live]
(set-option :timeout 0)
(push) ; 21
; [else-branch: 512 | True]
(pop) ; 21
(pop) ; 20
(push) ; 20
; [else-branch: 510 | !(l$i0$send_fail$1@1697@01)]
(assert (not l$i0$send_fail$1@1697@01))
(pop) ; 20
; [eval] !l$i0$send_fail$1
(push) ; 20
(set-option :timeout 10)
(assert (not l$i0$send_fail$1@1697@01))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (not l$i0$send_fail$1@1697@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
; [then-branch: 513 | !(l$i0$send_fail$1@1697@01) | live]
; [else-branch: 513 | l$i0$send_fail$1@1697@01 | live]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 513 | !(l$i0$send_fail$1@1697@01)]
(assert (not l$i0$send_fail$1@1697@01))
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; i3$$pre_self := self
; [exec]
; i3$$pre_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$1
; [exec]
; $old_$contracts := $contracts
; [exec]
; self := l$i0$havoc$2
; [exec]
; $contracts := l$i0$havoc$3
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@1919@01 $Snap)
(assert (= $t@1919@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (=
  (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 0)))
  32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@1920@01 $Snap)
(assert (= $t@1920@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (=
  (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 1)))
  32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1921@01 $Snap)
(assert (= $t@1921@01 ($Snap.combine ($Snap.first $t@1921@01) ($Snap.second $t@1921@01))))
(assert (= ($Snap.first $t@1921@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 2))))
(assert (= ($Snap.second $t@1921@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1922@01 $Snap)
(assert (= $t@1922@01 ($Snap.combine ($Snap.first $t@1922@01) ($Snap.second $t@1922@01))))
(assert (= ($Snap.first $t@1922@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 3))))
(assert (= ($Snap.second $t@1922@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1923@01 $Snap)
(assert (= $t@1923@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@1924@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 22
; [then-branch: 514 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 4)), $q2@1924@01)) | live]
; [else-branch: 514 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 4)), $q2@1924@01) | live]
(push) ; 23
; [then-branch: 514 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 4)), $q2@1924@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1924@01))))
(pop) ; 23
(push) ; 23
; [else-branch: 514 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 4)), $q2@1924@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1924@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1924@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1924@01)))))
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1924@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1924@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1924@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1924@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2337@11@2337@345-aux|)))
(assert (forall (($q2@1924@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1924@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1924@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1924@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2337@11@2337@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@1925@01 $Snap)
(assert (= $t@1925@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@1926@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@1926@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1926@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 4)) $q2@1926@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2338@11@2338@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@1927@01 $Snap)
(assert (= $t@1927@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@1928@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@1929@01 Int)
(push) ; 22
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 23
; [then-branch: 515 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@1702@01, 5)), $q3@1928@01), $q4@1929@01)) | live]
; [else-branch: 515 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@1702@01, 5)), $q3@1928@01), $q4@1929@01) | live]
(push) ; 24
; [then-branch: 515 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@1702@01, 5)), $q3@1928@01), $q4@1929@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01))))
(pop) ; 24
(push) ; 24
; [else-branch: 515 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@1702@01, 5)), $q3@1928@01), $q4@1929@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01)))))
(pop) ; 22
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@1929@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2339@131@2339@597-aux|)))
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1928@01 Int)) (!
  (forall (($q4@1929@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2339@131@2339@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2339@11@2339@598-aux|)))
(assert (forall (($q3@1928@01 Int)) (!
  (forall (($q4@1929@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01) $q4@1929@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2339@131@2339@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1928@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2339@11@2339@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@1930@01 $Snap)
(assert (= $t@1930@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@1931@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@1932@01 Int)
(push) ; 22
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 22
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@1931@01 Int)) (!
  (forall (($q4@1932@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1931@01) $q4@1932@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1931@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1931@01) $q4@1932@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2340@131@2340@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@1702@01 5)) $q3@1931@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2340@11@2340@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1933@01 $Snap)
(assert (= $t@1933@01 ($Snap.combine ($Snap.first $t@1933@01) ($Snap.second $t@1933@01))))
(assert (= ($Snap.first $t@1933@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 6))))
(assert (= ($Snap.second $t@1933@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@1934@01 $Snap)
(assert (= $t@1934@01 ($Snap.combine ($Snap.first $t@1934@01) ($Snap.second $t@1934@01))))
(assert (= ($Snap.first $t@1934@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 7))))
(assert (= ($Snap.second $t@1934@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@1935@01 $Snap)
(assert (= $t@1935@01 ($Snap.combine ($Snap.first $t@1935@01) ($Snap.second $t@1935@01))))
(assert (= ($Snap.first $t@1935@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 8))))
(assert (= ($Snap.second $t@1935@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@1936@01 $Snap)
(assert (= $t@1936@01 ($Snap.combine ($Snap.first $t@1936@01) ($Snap.second $t@1936@01))))
(assert (= ($Snap.first $t@1936@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 9))))
(assert (= ($Snap.second $t@1936@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1937@01 $Snap)
(assert (= $t@1937@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@1938@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 22
; [then-branch: 516 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 11)), $q5@1938@01)) | live]
; [else-branch: 516 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 11)), $q5@1938@01) | live]
(push) ; 23
; [then-branch: 516 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 11)), $q5@1938@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1938@01))))
(pop) ; 23
(push) ; 23
; [else-branch: 516 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 11)), $q5@1938@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1938@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1938@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1938@01)))))
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1938@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1938@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1938@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1938@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2345@11@2345@348-aux|)))
(assert (forall (($q5@1938@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1938@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1938@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1938@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2345@11@2345@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@1939@01 $Snap)
(assert (= $t@1939@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@1940@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@1940@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1940@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $q5@1940@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2346@11@2346@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@1941@01 $Snap)
(assert (= $t@1941@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@1942@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 22
; [then-branch: 517 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 12)), $q6@1942@01)) | live]
; [else-branch: 517 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 12)), $q6@1942@01) | live]
(push) ; 23
; [then-branch: 517 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 12)), $q6@1942@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1942@01))))
(pop) ; 23
(push) ; 23
; [else-branch: 517 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@1702@01, 12)), $q6@1942@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1942@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1942@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1942@01)))))
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1942@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1942@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1942@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1942@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2347@11@2347@348-aux|)))
(assert (forall (($q6@1942@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1942@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1942@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1942@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2347@11@2347@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@1943@01 $Snap)
(assert (= $t@1943@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@1944@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@1944@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1944@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 12)) $q6@1944@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2348@11@2348@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@1945@01 $Snap)
(assert (= $t@1945@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@1946@01 $Snap)
(assert (= $t@1946@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@1947@01 Int)
(set-option :timeout 0)
(push) ; 21
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc($old_self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc($old_self, 11)): $Map[Int, Int])
; [eval] $struct_loc($old_self, 11)
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($a@1947@01 Int)) (!
  (>=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $a@1947@01)
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1755@01 11)) $a@1947@01))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@1702@01 11)) $a@1947@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2351@11@2351@262|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not l$i0$no_reentrant_call@1704@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not l$i0$no_reentrant_call@1704@01))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
; [then-branch: 518 | l$i0$no_reentrant_call@1704@01 | live]
; [else-branch: 518 | !(l$i0$no_reentrant_call@1704@01) | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 518 | l$i0$no_reentrant_call@1704@01]
(assert l$i0$no_reentrant_call@1704@01)
; [exec]
; self := $old_self
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$4
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$5
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$i0$raw_ret$1
(push) ; 22
(set-option :timeout 10)
(assert (not l$i0$raw_ret$1@1698@01))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not (not l$i0$raw_ret$1@1698@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 519 | !(l$i0$raw_ret$1@1698@01) | live]
; [else-branch: 519 | l$i0$raw_ret$1@1698@01 | live]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 519 | !(l$i0$raw_ret$1@1698@01)]
(assert (not l$i0$raw_ret$1@1698@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 23
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
; [then-branch: 520 | True | live]
; [else-branch: 520 | False | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 520 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1948@01 $Snap)
(assert (= $t@1948@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1949@01 $Struct)
(assert (=
  self@1949@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 23
; [then-branch: 521 | False | dead]
; [else-branch: 521 | True | live]
(set-option :timeout 0)
(push) ; 23
; [else-branch: 521 | True]
(pop) ; 23
(pop) ; 22
(push) ; 22
; [else-branch: 519 | l$i0$raw_ret$1@1698@01]
(assert l$i0$raw_ret$1@1698@01)
(pop) ; 22
; [eval] !!l$i0$raw_ret$1
; [eval] !l$i0$raw_ret$1
(push) ; 22
(set-option :timeout 10)
(assert (not (not l$i0$raw_ret$1@1698@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not l$i0$raw_ret$1@1698@01))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 522 | l$i0$raw_ret$1@1698@01 | live]
; [else-branch: 522 | !(l$i0$raw_ret$1@1698@01) | live]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 522 | l$i0$raw_ret$1@1698@01]
(assert l$i0$raw_ret$1@1698@01)
; [exec]
; inhale acc(e$TokenPurchase(l$i0$buyer, l$i0$eth_sold, $unwrap(l$i0$tokens_bought)), write)
; [eval] $unwrap(l$i0$tokens_bought)
(declare-const $t@1950@01 $Snap)
(declare-const sm@1951@01 $PSF<e$TokenPurchase>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$TokenPurchase (as sm@1951@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap l$i0$buyer@1757@01)
      ($SortWrappers.IntTo$Snap l$i0$eth_sold@1756@01))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1853@01))))
  $t@1950@01))
(assert (<=
  $Perm.No
  (ite
    (=
      ($unwrap<Int> l$i0$tokens_bought@1853@01)
      ($unwrap<Int> l$i0$tokens_bought@1853@01))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap l$i0$buyer@1757@01)
    ($SortWrappers.IntTo$Snap l$i0$eth_sold@1756@01))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1853@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap l$i0$buyer@1757@01)
    ($SortWrappers.IntTo$Snap l$i0$eth_sold@1756@01))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1853@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; i0$$res := $unwrap(l$i0$tokens_bought)
; [eval] $unwrap(l$i0$tokens_bought)
(declare-const i0$$res@1952@01 Int)
(assert (= i0$$res@1952@01 ($unwrap<Int> l$i0$tokens_bought@1853@01)))
; [exec]
; label i0$return
; [exec]
; $res := i0$$res
; [exec]
; label return
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not $out_of_gas@1707@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not $out_of_gas@1707@01))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
; [then-branch: 523 | $out_of_gas@1707@01 | live]
; [else-branch: 523 | !($out_of_gas@1707@01) | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 523 | $out_of_gas@1707@01]
(assert $out_of_gas@1707@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 24
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 24
; 0.01s
; (get-info :all-statistics)
; [then-branch: 524 | True | live]
; [else-branch: 524 | False | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 524 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1953@01 $Snap)
(assert (= $t@1953@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1954@01 $Struct)
(assert (=
  self@1954@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 24
; [then-branch: 525 | False | dead]
; [else-branch: 525 | True | live]
(set-option :timeout 0)
(push) ; 24
; [else-branch: 525 | True]
(pop) ; 24
(pop) ; 23
(push) ; 23
; [else-branch: 523 | !($out_of_gas@1707@01)]
(assert (not $out_of_gas@1707@01))
(pop) ; 23
; [eval] !$out_of_gas
(push) ; 23
(set-option :timeout 10)
(assert (not $out_of_gas@1707@01))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not $out_of_gas@1707@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 526 | !($out_of_gas@1707@01) | live]
; [else-branch: 526 | $out_of_gas@1707@01 | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 526 | !($out_of_gas@1707@01)]
(assert (not $out_of_gas@1707@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 527 | False | dead]
; [else-branch: 527 | True | live]
(push) ; 24
; [else-branch: 527 | True]
(pop) ; 24
(push) ; 24
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 24
; 0.01s
; (get-info :all-statistics)
; [then-branch: 528 | True | live]
; [else-branch: 528 | False | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 528 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1955@01 $Snap)
(assert (= $t@1955@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1956@01 $Struct)
(assert (=
  self@1956@01
  ($struct_set<$Struct> self@1755@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1755@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 24
(pop) ; 23
(set-option :timeout 0)
(push) ; 23
; [else-branch: 526 | $out_of_gas@1707@01]
(assert $out_of_gas@1707@01)
(pop) ; 23
(pop) ; 22
(push) ; 22
; [else-branch: 522 | !(l$i0$raw_ret$1@1698@01)]
(assert (not l$i0$raw_ret$1@1698@01))
(pop) ; 22
(pop) ; 21
(push) ; 21
; [else-branch: 518 | !(l$i0$no_reentrant_call@1704@01)]
(assert (not l$i0$no_reentrant_call@1704@01))
(pop) ; 21
; [eval] !l$i0$no_reentrant_call
(push) ; 21
(set-option :timeout 10)
(assert (not l$i0$no_reentrant_call@1704@01))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not l$i0$no_reentrant_call@1704@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
; [then-branch: 529 | !(l$i0$no_reentrant_call@1704@01) | live]
; [else-branch: 529 | l$i0$no_reentrant_call@1704@01 | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 529 | !(l$i0$no_reentrant_call@1704@01)]
(assert (not l$i0$no_reentrant_call@1704@01))
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$4
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$5
; [exec]
; $old_$contracts := i3$$pre_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [eval] !l$i0$raw_ret$1
(push) ; 22
(set-option :timeout 10)
(assert (not l$i0$raw_ret$1@1698@01))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not (not l$i0$raw_ret$1@1698@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 530 | !(l$i0$raw_ret$1@1698@01) | live]
; [else-branch: 530 | l$i0$raw_ret$1@1698@01 | live]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 530 | !(l$i0$raw_ret$1@1698@01)]
(assert (not l$i0$raw_ret$1@1698@01))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 23
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
; [then-branch: 531 | True | live]
; [else-branch: 531 | False | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 531 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1957@01 $Snap)
(assert (= $t@1957@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1958@01 $Struct)
(assert (=
  self@1958@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 23
; [then-branch: 532 | False | dead]
; [else-branch: 532 | True | live]
(set-option :timeout 0)
(push) ; 23
; [else-branch: 532 | True]
(pop) ; 23
(pop) ; 22
(push) ; 22
; [else-branch: 530 | l$i0$raw_ret$1@1698@01]
(assert l$i0$raw_ret$1@1698@01)
(pop) ; 22
; [eval] !!l$i0$raw_ret$1
; [eval] !l$i0$raw_ret$1
(push) ; 22
(set-option :timeout 10)
(assert (not (not l$i0$raw_ret$1@1698@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not l$i0$raw_ret$1@1698@01))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 533 | l$i0$raw_ret$1@1698@01 | live]
; [else-branch: 533 | !(l$i0$raw_ret$1@1698@01) | live]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 533 | l$i0$raw_ret$1@1698@01]
(assert l$i0$raw_ret$1@1698@01)
; [exec]
; inhale acc(e$TokenPurchase(l$i0$buyer, l$i0$eth_sold, $unwrap(l$i0$tokens_bought)), write)
; [eval] $unwrap(l$i0$tokens_bought)
(declare-const $t@1959@01 $Snap)
(declare-const sm@1960@01 $PSF<e$TokenPurchase>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_e$TokenPurchase (as sm@1960@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap l$i0$buyer@1757@01)
      ($SortWrappers.IntTo$Snap l$i0$eth_sold@1756@01))
    ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1853@01))))
  $t@1959@01))
(assert (<=
  $Perm.No
  (ite
    (=
      ($unwrap<Int> l$i0$tokens_bought@1853@01)
      ($unwrap<Int> l$i0$tokens_bought@1853@01))
    $Perm.Write
    $Perm.No)))
; Definitional axioms for snapshot map values
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@1764@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap l$i0$buyer@1757@01)
    ($SortWrappers.IntTo$Snap l$i0$eth_sold@1756@01))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1853@01)))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap l$i0$buyer@1757@01)
    ($SortWrappers.IntTo$Snap l$i0$eth_sold@1756@01))
  ($SortWrappers.IntTo$Snap ($unwrap<Int> l$i0$tokens_bought@1853@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; i0$$res := $unwrap(l$i0$tokens_bought)
; [eval] $unwrap(l$i0$tokens_bought)
(declare-const i0$$res@1961@01 Int)
(assert (= i0$$res@1961@01 ($unwrap<Int> l$i0$tokens_bought@1853@01)))
; [exec]
; label i0$return
; [exec]
; $res := i0$$res
; [exec]
; label return
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not $out_of_gas@1707@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not $out_of_gas@1707@01))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
; [then-branch: 534 | $out_of_gas@1707@01 | live]
; [else-branch: 534 | !($out_of_gas@1707@01) | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 534 | $out_of_gas@1707@01]
(assert $out_of_gas@1707@01)
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 24
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 24
; 0.01s
; (get-info :all-statistics)
; [then-branch: 535 | True | live]
; [else-branch: 535 | False | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 535 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1962@01 $Snap)
(assert (= $t@1962@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1963@01 $Struct)
(assert (=
  self@1963@01
  ($struct_set<$Struct> self@1668@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1668@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 24
; [then-branch: 536 | False | dead]
; [else-branch: 536 | True | live]
(set-option :timeout 0)
(push) ; 24
; [else-branch: 536 | True]
(pop) ; 24
(pop) ; 23
(push) ; 23
; [else-branch: 534 | !($out_of_gas@1707@01)]
(assert (not $out_of_gas@1707@01))
(pop) ; 23
; [eval] !$out_of_gas
(push) ; 23
(set-option :timeout 10)
(assert (not $out_of_gas@1707@01))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not $out_of_gas@1707@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
; [then-branch: 537 | !($out_of_gas@1707@01) | live]
; [else-branch: 537 | $out_of_gas@1707@01 | live]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 537 | !($out_of_gas@1707@01)]
(assert (not $out_of_gas@1707@01))
; [exec]
; label end
; [eval] !$succ
; [then-branch: 538 | False | dead]
; [else-branch: 538 | True | live]
(push) ; 24
; [else-branch: 538 | True]
(pop) ; 24
(push) ; 24
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 24
; 0.01s
; (get-info :all-statistics)
; [then-branch: 539 | True | live]
; [else-branch: 539 | False | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 539 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@1964@01 $Snap)
(assert (= $t@1964@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@1709@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@1965@01 $Struct)
(assert (=
  self@1965@01
  ($struct_set<$Struct> l$i0$havoc$2@1702@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@1702@01 8))
    l$havoc$1@1709@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 24
(pop) ; 23
(set-option :timeout 0)
(push) ; 23
; [else-branch: 537 | $out_of_gas@1707@01]
(assert $out_of_gas@1707@01)
(pop) ; 23
(pop) ; 22
(push) ; 22
; [else-branch: 533 | !(l$i0$raw_ret$1@1698@01)]
(assert (not l$i0$raw_ret$1@1698@01))
(pop) ; 22
(pop) ; 21
(push) ; 21
; [else-branch: 529 | l$i0$no_reentrant_call@1704@01]
(assert l$i0$no_reentrant_call@1704@01)
(pop) ; 21
(pop) ; 20
(push) ; 20
; [else-branch: 513 | l$i0$send_fail$1@1697@01]
(assert l$i0$send_fail$1@1697@01)
(pop) ; 20
(pop) ; 19
(push) ; 19
; [else-branch: 509 | !($unwrap[Int](l$i0$tokens_bought@1853@01) >= $unwrap[Int](l$min_tokens@1660@01))]
(assert (not
  (>=
    ($unwrap<Int> l$i0$tokens_bought@1853@01)
    ($unwrap<Int> l$min_tokens@1660@01))))
(pop) ; 19
(pop) ; 18
(pop) ; 17
(push) ; 17
; [else-branch: 503 | $div[Int]($unwrap[Int](l$i2$numerator@1846@01), l$i2$denominator@1851@01, $unwrap[Int](l$i2$numerator@1846@01) / l$i2$denominator@1851@01) < 0]
(assert (<
  ($div<Int> ($unwrap<Int> l$i2$numerator@1846@01) l$i2$denominator@1851@01 (div
    ($unwrap<Int> l$i2$numerator@1846@01)
    l$i2$denominator@1851@01))
  0))
(pop) ; 17
(pop) ; 16
(pop) ; 15
(push) ; 15
; [else-branch: 499 | l$i2$input_reserve@1838@01 * 1000 + l$i2$input_amount_with_fee@1843@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+ (* l$i2$input_reserve@1838@01 1000) l$i2$input_amount_with_fee@1843@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 15
(pop) ; 14
(pop) ; 13
(push) ; 13
; [else-branch: 493 | l$i2$input_reserve@1838@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (* l$i2$input_reserve@1838@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 13
(pop) ; 12
(pop) ; 11
(push) ; 11
; [else-branch: 487 | l$i2$input_amount_with_fee@1843@01 * $unwrap[Int](l$i0$token_reserve@1837@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (*
    l$i2$input_amount_with_fee@1843@01
    ($unwrap<Int> l$i0$token_reserve@1837@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 11
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 481 | l$i0$eth_sold@1756@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (* l$i0$eth_sold@1756@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
(pop) ; 9
(pop) ; 8
(pop) ; 7
(push) ; 7
; [else-branch: 475 | !(l$i2$input_reserve@1838@01 > 0 && $unwrap[Int](l$i0$token_reserve@1837@01) > 0)]
(assert (not
  (and
    (> l$i2$input_reserve@1838@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@1837@01) 0))))
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 465 | l$i0$send_fail@1685@01]
(assert l$i0$send_fail@1685@01)
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 461 | !($unwrap[Int](l$deadline@1661@01) >= $struct_get[Int]($struct_loc[Int](block@1665@01, 4)) && l$i0$eth_sold@1756@01 > 0 && $unwrap[Int](l$min_tokens@1660@01) > 0)]
(assert (not
  (and
    (>=
      ($unwrap<Int> l$deadline@1661@01)
      ($struct_get<Int> ($struct_loc<Int> block@1665@01 4)))
    (and (> l$i0$eth_sold@1756@01 0) (> ($unwrap<Int> l$min_tokens@1660@01) 0)))))
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- f$ethToTokenTransferInput ----------
(declare-const l$min_tokens@1966@01 $Int)
(declare-const l$deadline@1967@01 $Int)
(declare-const l$recipient@1968@01 Int)
(declare-const $succ@1969@01 Bool)
(declare-const $res@1970@01 Int)
(declare-const l$min_tokens@1971@01 $Int)
(declare-const l$deadline@1972@01 $Int)
(declare-const l$recipient@1973@01 Int)
(declare-const $succ@1974@01 Bool)
(declare-const $res@1975@01 Int)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var msg: $Struct
(declare-const msg@1976@01 $Struct)
; [exec]
; var block: $Struct
(declare-const block@1977@01 $Struct)
; [exec]
; var chain: $Struct
(declare-const chain@1978@01 $Struct)
; [exec]
; var tx: $Struct
(declare-const tx@1979@01 $Struct)
; [exec]
; var self: $Struct
(declare-const self@1980@01 $Struct)
; [exec]
; var $contracts: $Map[Int, $Struct]
(declare-const $contracts@1981@01 $Map<Int~_$Struct>)
; [exec]
; var $old_self: $Struct
(declare-const $old_self@1982@01 $Struct)
; [exec]
; var $old_$contracts: $Map[Int, $Struct]
(declare-const $old_$contracts@1983@01 $Map<Int~_$Struct>)
; [exec]
; var $pre_self: $Struct
(declare-const $pre_self@1984@01 $Struct)
; [exec]
; var $pre_$contracts: $Map[Int, $Struct]
(declare-const $pre_$contracts@1985@01 $Map<Int~_$Struct>)
; [exec]
; var $issued_self: $Struct
(declare-const $issued_self@1986@01 $Struct)
; [exec]
; var $issued_$contracts: $Map[Int, $Struct]
(declare-const $issued_$contracts@1987@01 $Map<Int~_$Struct>)
; [exec]
; var $overflow: Bool
(declare-const $overflow@1988@01 Bool)
; [exec]
; var l$i0$eth_sold: Int
(declare-const l$i0$eth_sold@1989@01 Int)
; [exec]
; var l$i0$min_tokens: $Int
(declare-const l$i0$min_tokens@1990@01 $Int)
; [exec]
; var l$i0$deadline: $Int
(declare-const l$i0$deadline@1991@01 $Int)
; [exec]
; var l$i0$buyer: Int
(declare-const l$i0$buyer@1992@01 Int)
; [exec]
; var l$i0$recipient: Int
(declare-const l$i0$recipient@1993@01 Int)
; [exec]
; var i0$$res: Int
(declare-const i0$$res@1994@01 Int)
; [exec]
; var i0$$pre_self: $Struct
(declare-const i0$$pre_self@1995@01 $Struct)
; [exec]
; var i0$$pre_$contracts: $Map[Int, $Struct]
(declare-const i0$$pre_$contracts@1996@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$send_fail: Bool
(declare-const l$i0$send_fail@1997@01 Bool)
; [exec]
; var l$i0$raw_ret: Int
(declare-const l$i0$raw_ret@1998@01 Int)
; [exec]
; var l$i0$token_reserve: $Int
(declare-const l$i0$token_reserve@1999@01 $Int)
; [exec]
; var l$i2$input_amount: Int
(declare-const l$i2$input_amount@2000@01 Int)
; [exec]
; var l$i2$input_reserve: Int
(declare-const l$i2$input_reserve@2001@01 Int)
; [exec]
; var l$i2$output_reserve: $Int
(declare-const l$i2$output_reserve@2002@01 $Int)
; [exec]
; var i2$$res: Int
(declare-const i2$$res@2003@01 Int)
; [exec]
; var l$i2$input_amount_with_fee: Int
(declare-const l$i2$input_amount_with_fee@2004@01 Int)
; [exec]
; var l$i2$numerator: $Int
(declare-const l$i2$numerator@2005@01 $Int)
; [exec]
; var l$i2$denominator: Int
(declare-const l$i2$denominator@2006@01 Int)
; [exec]
; var l$i0$tokens_bought: $Int
(declare-const l$i0$tokens_bought@2007@01 $Int)
; [exec]
; var l$i0$havoc: $Map[Int, $Struct]
(declare-const l$i0$havoc@2008@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$send_fail$1: Bool
(declare-const l$i0$send_fail$1@2009@01 Bool)
; [exec]
; var l$i0$raw_ret$1: Bool
(declare-const l$i0$raw_ret$1@2010@01 Bool)
; [exec]
; var i3$$pre_self: $Struct
(declare-const i3$$pre_self@2011@01 $Struct)
; [exec]
; var i3$$pre_$contracts: $Map[Int, $Struct]
(declare-const i3$$pre_$contracts@2012@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$havoc$1: $Map[Int, $Struct]
(declare-const l$i0$havoc$1@2013@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$havoc$2: $Struct
(declare-const l$i0$havoc$2@2014@01 $Struct)
; [exec]
; var l$i0$havoc$3: $Map[Int, $Struct]
(declare-const l$i0$havoc$3@2015@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$no_reentrant_call: Bool
(declare-const l$i0$no_reentrant_call@2016@01 Bool)
; [exec]
; var l$i0$havoc$4: $Map[Int, $Struct]
(declare-const l$i0$havoc$4@2017@01 $Map<Int~_$Struct>)
; [exec]
; var l$i0$havoc$5: $Map[Int, $Struct]
(declare-const l$i0$havoc$5@2018@01 $Map<Int~_$Struct>)
; [exec]
; var $out_of_gas: Bool
(declare-const $out_of_gas@2019@01 Bool)
; [exec]
; var l$havoc: Int
(declare-const l$havoc@2020@01 Int)
; [exec]
; var l$havoc$1: Int
(declare-const l$havoc$1@2021@01 Int)
; [exec]
; var l$havoc$2: $Map[Int, $Struct]
(declare-const l$havoc$2@2022@01 $Map<Int~_$Struct>)
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@2023@01 $Snap)
(assert (= $t@2023@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@1980@01 0))) 32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@2024@01 $Snap)
(assert (= $t@2024@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> self@1980@01 1))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2025@01 $Snap)
(assert (= $t@2025@01 ($Snap.combine ($Snap.first $t@2025@01) ($Snap.second $t@2025@01))))
(assert (= ($Snap.first $t@2025@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1980@01 2))))
(assert (= ($Snap.second $t@2025@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1980@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2026@01 $Snap)
(assert (= $t@2026@01 ($Snap.combine ($Snap.first $t@2026@01) ($Snap.second $t@2026@01))))
(assert (= ($Snap.first $t@2026@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1980@01 3))))
(assert (= ($Snap.second $t@2026@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1980@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@2027@01 $Snap)
(assert (= $t@2027@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@2028@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 4
; [then-branch: 540 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 4)), $q2@2028@01)) | live]
; [else-branch: 540 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 4)), $q2@2028@01) | live]
(push) ; 5
; [then-branch: 540 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 4)), $q2@2028@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2028@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 540 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 4)), $q2@2028@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2028@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2028@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2028@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@2028@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2028@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2028@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2028@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2461@11@2461@345-aux|)))
(assert (forall (($q2@2028@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2028@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2028@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2028@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2461@11@2461@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@2029@01 $Snap)
(assert (= $t@2029@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@2030@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@2030@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2030@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 4)) $q2@2030@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2462@11@2462@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@2031@01 $Snap)
(assert (= $t@2031@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@2032@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@2033@01 Int)
(push) ; 4
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 5
; [then-branch: 541 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1980@01, 5)), $q3@2032@01), $q4@2033@01)) | live]
; [else-branch: 541 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1980@01, 5)), $q3@2032@01), $q4@2033@01) | live]
(push) ; 6
; [then-branch: 541 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1980@01, 5)), $q3@2032@01), $q4@2033@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01))))
(pop) ; 6
(push) ; 6
; [else-branch: 541 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](self@1980@01, 5)), $q3@2032@01), $q4@2033@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@2033@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2463@131@2463@597-aux|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@2032@01 Int)) (!
  (forall (($q4@2033@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2463@131@2463@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2463@11@2463@598-aux|)))
(assert (forall (($q3@2032@01 Int)) (!
  (forall (($q4@2033@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01) $q4@2033@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2463@131@2463@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2032@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2463@11@2463@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@2034@01 $Snap)
(assert (= $t@2034@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@2035@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@2036@01 Int)
(push) ; 4
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@2035@01 Int)) (!
  (forall (($q4@2036@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2035@01) $q4@2036@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2035@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2035@01) $q4@2036@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2464@131@2464@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> self@1980@01 5)) $q3@2035@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2464@11@2464@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@2037@01 $Snap)
(assert (= $t@2037@01 ($Snap.combine ($Snap.first $t@2037@01) ($Snap.second $t@2037@01))))
(assert (= ($Snap.first $t@2037@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1980@01 6))))
(assert (= ($Snap.second $t@2037@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1980@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@2038@01 $Snap)
(assert (= $t@2038@01 ($Snap.combine ($Snap.first $t@2038@01) ($Snap.second $t@2038@01))))
(assert (= ($Snap.first $t@2038@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1980@01 7))))
(assert (= ($Snap.second $t@2038@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1980@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2039@01 $Snap)
(assert (= $t@2039@01 ($Snap.combine ($Snap.first $t@2039@01) ($Snap.second $t@2039@01))))
(assert (= ($Snap.first $t@2039@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))))
(assert (= ($Snap.second $t@2039@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@2040@01 $Snap)
(assert (= $t@2040@01 ($Snap.combine ($Snap.first $t@2040@01) ($Snap.second $t@2040@01))))
(assert (= ($Snap.first $t@2040@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> self@1980@01 9))))
(assert (= ($Snap.second $t@2040@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> self@1980@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@2041@01 $Snap)
(assert (= $t@2041@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@2042@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 4
; [then-branch: 542 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 11)), $q5@2042@01)) | live]
; [else-branch: 542 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 11)), $q5@2042@01) | live]
(push) ; 5
; [then-branch: 542 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 11)), $q5@2042@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2042@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 542 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 11)), $q5@2042@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2042@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2042@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2042@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@2042@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2042@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2042@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2042@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2469@11@2469@348-aux|)))
(assert (forall (($q5@2042@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2042@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2042@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2042@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2469@11@2469@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@2043@01 $Snap)
(assert (= $t@2043@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@2044@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@2044@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2044@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 11)) $q5@2044@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2470@11@2470@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@2045@01 $Snap)
(assert (= $t@2045@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q6@2046@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) && ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(push) ; 4
; [then-branch: 543 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 12)), $q6@2046@01)) | live]
; [else-branch: 543 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 12)), $q6@2046@01) | live]
(push) ; 5
; [then-branch: 543 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 12)), $q6@2046@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2046@01))))
(pop) ; 5
(push) ; 5
; [else-branch: 543 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](self@1980@01, 12)), $q6@2046@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2046@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2046@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2046@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@2046@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2046@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2046@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2046@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2471@11@2471@348-aux|)))
(assert (forall (($q6@2046@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2046@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2046@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2046@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2471@11@2471@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q6: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) }
;     ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $t@2047@01 $Snap)
(assert (= $t@2047@01 $Snap.unit))
; [eval] (forall $q6: Int :: { ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) } ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int))
(declare-const $q6@2048@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int) <= ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), $q6): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($map_sum(($struct_get($struct_loc(self, 12)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q6@2048@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2048@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@1980@01 12)) $q6@2048@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2472@11@2472@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(self, -1)): Int) ==
;   9122519725869122497593506884710
(declare-const $t@2049@01 $Snap)
(assert (= $t@2049@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(self, -1)): Int) == 9122519725869122497593506884710
; [eval] ($struct_get($struct_loc(self, -1)): Int)
; [eval] $struct_loc(self, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> self@1980@01 (- 0 1)))
  9122519725869122497593506884710))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $self_address() &&
;   $self_address() <= 1461501637330902918203684832716283019655932542975
(declare-const $t@2050@01 $Snap)
(assert (= $t@2050@01 ($Snap.combine ($Snap.first $t@2050@01) ($Snap.second $t@2050@01))))
(assert (= ($Snap.first $t@2050@01) $Snap.unit))
; [eval] 0 <= $self_address()
; [eval] $self_address()
(assert (<= 0 (as $self_address<Int>  Int)))
(assert (= ($Snap.second $t@2050@01) $Snap.unit))
; [eval] $self_address() <= 1461501637330902918203684832716283019655932542975
; [eval] $self_address()
(assert (<=
  (as $self_address<Int>  Int)
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$min_tokens) &&
;   $unwrap(l$min_tokens) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2051@01 $Snap)
(assert (= $t@2051@01 ($Snap.combine ($Snap.first $t@2051@01) ($Snap.second $t@2051@01))))
(assert (= ($Snap.first $t@2051@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$min_tokens)
; [eval] $unwrap(l$min_tokens)
(assert (<= 0 ($unwrap<Int> l$min_tokens@1971@01)))
(assert (= ($Snap.second $t@2051@01) $Snap.unit))
; [eval] $unwrap(l$min_tokens) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$min_tokens)
(assert (<=
  ($unwrap<Int> l$min_tokens@1971@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= $unwrap(l$deadline) &&
;   $unwrap(l$deadline) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2052@01 $Snap)
(assert (= $t@2052@01 ($Snap.combine ($Snap.first $t@2052@01) ($Snap.second $t@2052@01))))
(assert (= ($Snap.first $t@2052@01) $Snap.unit))
; [eval] 0 <= $unwrap(l$deadline)
; [eval] $unwrap(l$deadline)
(assert (<= 0 ($unwrap<Int> l$deadline@1972@01)))
(assert (= ($Snap.second $t@2052@01) $Snap.unit))
; [eval] $unwrap(l$deadline) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $unwrap(l$deadline)
(assert (<=
  ($unwrap<Int> l$deadline@1972@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= l$recipient &&
;   l$recipient <= 1461501637330902918203684832716283019655932542975
(declare-const $t@2053@01 $Snap)
(assert (= $t@2053@01 ($Snap.combine ($Snap.first $t@2053@01) ($Snap.second $t@2053@01))))
(assert (= ($Snap.first $t@2053@01) $Snap.unit))
; [eval] 0 <= l$recipient
(assert (<= 0 l$recipient@1973@01))
(assert (= ($Snap.second $t@2053@01) $Snap.unit))
; [eval] l$recipient <= 1461501637330902918203684832716283019655932542975
(assert (<= l$recipient@1973@01 1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 0)): Int) &&
;   ($struct_get($struct_loc(block, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@2054@01 $Snap)
(assert (= $t@2054@01 ($Snap.combine ($Snap.first $t@2054@01) ($Snap.second $t@2054@01))))
(assert (= ($Snap.first $t@2054@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 0)): Int)
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1977@01 0))))
(assert (= ($Snap.second $t@2054@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(block, 0)): Int)
; [eval] $struct_loc(block, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1977@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 1)): Int) &&
;   ($struct_get($struct_loc(block, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2055@01 $Snap)
(assert (= $t@2055@01 ($Snap.combine ($Snap.first $t@2055@01) ($Snap.second $t@2055@01))))
(assert (= ($Snap.first $t@2055@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 1)): Int)
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1977@01 1))))
(assert (= ($Snap.second $t@2055@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 1)): Int)
; [eval] $struct_loc(block, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1977@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 2)): Int) &&
;   ($struct_get($struct_loc(block, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2056@01 $Snap)
(assert (= $t@2056@01 ($Snap.combine ($Snap.first $t@2056@01) ($Snap.second $t@2056@01))))
(assert (= ($Snap.first $t@2056@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 2)): Int)
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1977@01 2))))
(assert (= ($Snap.second $t@2056@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 2)): Int)
; [eval] $struct_loc(block, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1977@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
(declare-const $t@2057@01 $Snap)
(assert (= $t@2057@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(block, 3)): Seq[Int])|
; [eval] ($struct_get($struct_loc(block, 3)): Seq[Int])
; [eval] $struct_loc(block, 3)
(assert (= (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> block@1977@01 3))) 32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(block, 4)): Int) &&
;   ($struct_get($struct_loc(block, 4)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2058@01 $Snap)
(assert (= $t@2058@01 ($Snap.combine ($Snap.first $t@2058@01) ($Snap.second $t@2058@01))))
(assert (= ($Snap.first $t@2058@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(block, 4)): Int)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> block@1977@01 4))))
(assert (= ($Snap.second $t@2058@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(block, 4)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> block@1977@01 4))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(block, -1)): Int) ==
;   2335365049822495359383864865678187
(declare-const $t@2059@01 $Snap)
(assert (= $t@2059@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(block, -1)): Int) == 2335365049822495359383864865678187
; [eval] ($struct_get($struct_loc(block, -1)): Int)
; [eval] $struct_loc(block, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> block@1977@01 (- 0 1)))
  2335365049822495359383864865678187))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 0)): Int) &&
;   ($struct_get($struct_loc(msg, 0)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@2060@01 $Snap)
(assert (= $t@2060@01 ($Snap.combine ($Snap.first $t@2060@01) ($Snap.second $t@2060@01))))
(assert (= ($Snap.first $t@2060@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@1976@01 0))))
(assert (= ($Snap.second $t@2060@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@1976@01 0))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 1)): Int) &&
;   ($struct_get($struct_loc(msg, 1)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2061@01 $Snap)
(assert (= $t@2061@01 ($Snap.combine ($Snap.first $t@2061@01) ($Snap.second $t@2061@01))))
(assert (= ($Snap.first $t@2061@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@1976@01 1))))
(assert (= ($Snap.second $t@2061@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 1)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@1976@01 1))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(msg, 2)): Int) &&
;   ($struct_get($struct_loc(msg, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2062@01 $Snap)
(assert (= $t@2062@01 ($Snap.combine ($Snap.first $t@2062@01) ($Snap.second $t@2062@01))))
(assert (= ($Snap.first $t@2062@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(msg, 2)): Int)
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> msg@1976@01 2))))
(assert (= ($Snap.second $t@2062@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(msg, 2)): Int)
; [eval] $struct_loc(msg, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> msg@1976@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, -1)): Int) ==
;   35634842679176259756224246631
(declare-const $t@2063@01 $Snap)
(assert (= $t@2063@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, -1)): Int) == 35634842679176259756224246631
; [eval] ($struct_get($struct_loc(msg, -1)): Int)
; [eval] $struct_loc(msg, -1)
; [eval] -1
(assert (=
  ($struct_get<Int> ($struct_loc<Int> msg@1976@01 (- 0 1)))
  35634842679176259756224246631))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale ($struct_get($struct_loc(msg, 0)): Int) != 0
(declare-const $t@2064@01 $Snap)
(assert (= $t@2064@01 $Snap.unit))
; [eval] ($struct_get($struct_loc(msg, 0)): Int) != 0
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(assert (not (= ($struct_get<Int> ($struct_loc<Int> msg@1976@01 0)) 0)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $a: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $t@2065@01 $Snap)
(assert (= $t@2065@01 $Snap.unit))
; [eval] (forall $a: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int))
(declare-const $a@2066@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int) >= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $a): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; $pre_self := self
; [exec]
; $pre_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $succ := true
; [exec]
; $overflow := false
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const self@2067@01 $Struct)
(assert (=
  self@2067@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    ($struct_get<Int> ($struct_loc<Int> msg@1976@01 1))))))
; [exec]
; self := ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]),
;   ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self,
;   12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) +
;   ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
; [eval] ($struct_set(self, 12, ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])): $Struct)
; [eval] ($map_set(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int), ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int) + ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 12)): $Map[Int, Int]), ($struct_get($struct_loc(msg, 0)): Int)): Int)
; [eval] ($struct_get($struct_loc(self, 12)): $Map[Int, Int])
; [eval] $struct_loc(self, 12)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const self@2068@01 $Struct)
(assert (=
  self@2068@01
  ($struct_set<$Struct> self@2067@01 12 ($map_set<$Map<Int~_Int>> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@2067@01 12)) ($struct_get<Int> ($struct_loc<Int> msg@1976@01 0)) (+
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> self@2067@01 12)) ($struct_get<Int> ($struct_loc<Int> msg@1976@01 0)))
    ($struct_get<Int> ($struct_loc<Int> msg@1976@01 1)))))))
; [eval] !(l$recipient != $self_address() && l$recipient != 0)
; [eval] l$recipient != $self_address() && l$recipient != 0
; [eval] l$recipient != $self_address()
; [eval] $self_address()
(set-option :timeout 0)
(push) ; 3
; [then-branch: 544 | l$recipient@1973@01 == $self_address[Int] | live]
; [else-branch: 544 | l$recipient@1973@01 != $self_address[Int] | live]
(push) ; 4
; [then-branch: 544 | l$recipient@1973@01 == $self_address[Int]]
(assert (= l$recipient@1973@01 (as $self_address<Int>  Int)))
(pop) ; 4
(push) ; 4
; [else-branch: 544 | l$recipient@1973@01 != $self_address[Int]]
(assert (not (= l$recipient@1973@01 (as $self_address<Int>  Int))))
; [eval] l$recipient != 0
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or
  (not (= l$recipient@1973@01 (as $self_address<Int>  Int)))
  (= l$recipient@1973@01 (as $self_address<Int>  Int))))
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (not (= l$recipient@1973@01 (as $self_address<Int>  Int)))
  (not (= l$recipient@1973@01 0)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (not (= l$recipient@1973@01 (as $self_address<Int>  Int)))
    (not (= l$recipient@1973@01 0))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 545 | !(l$recipient@1973@01 != $self_address[Int] && l$recipient@1973@01 != 0) | live]
; [else-branch: 545 | l$recipient@1973@01 != $self_address[Int] && l$recipient@1973@01 != 0 | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 545 | !(l$recipient@1973@01 != $self_address[Int] && l$recipient@1973@01 != 0)]
(assert (not
  (and
    (not (= l$recipient@1973@01 (as $self_address<Int>  Int)))
    (not (= l$recipient@1973@01 0)))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 546 | True | live]
; [else-branch: 546 | False | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 546 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@2069@01 $Snap)
(assert (= $t@2069@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@2021@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@2070@01 $Struct)
(assert (=
  self@2070@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    l$havoc$1@2021@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 4
; [then-branch: 547 | False | dead]
; [else-branch: 547 | True | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 547 | True]
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 545 | l$recipient@1973@01 != $self_address[Int] && l$recipient@1973@01 != 0]
(assert (and
  (not (= l$recipient@1973@01 (as $self_address<Int>  Int)))
  (not (= l$recipient@1973@01 0))))
(pop) ; 3
; [eval] !!(l$recipient != $self_address() && l$recipient != 0)
; [eval] !(l$recipient != $self_address() && l$recipient != 0)
; [eval] l$recipient != $self_address() && l$recipient != 0
; [eval] l$recipient != $self_address()
; [eval] $self_address()
(push) ; 3
; [then-branch: 548 | l$recipient@1973@01 == $self_address[Int] | live]
; [else-branch: 548 | l$recipient@1973@01 != $self_address[Int] | live]
(push) ; 4
; [then-branch: 548 | l$recipient@1973@01 == $self_address[Int]]
(assert (= l$recipient@1973@01 (as $self_address<Int>  Int)))
(pop) ; 4
(push) ; 4
; [else-branch: 548 | l$recipient@1973@01 != $self_address[Int]]
(assert (not (= l$recipient@1973@01 (as $self_address<Int>  Int))))
; [eval] l$recipient != 0
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(assert (not (not
  (and
    (not (= l$recipient@1973@01 (as $self_address<Int>  Int)))
    (not (= l$recipient@1973@01 0))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (not (= l$recipient@1973@01 (as $self_address<Int>  Int)))
  (not (= l$recipient@1973@01 0)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 549 | l$recipient@1973@01 != $self_address[Int] && l$recipient@1973@01 != 0 | live]
; [else-branch: 549 | !(l$recipient@1973@01 != $self_address[Int] && l$recipient@1973@01 != 0) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 549 | l$recipient@1973@01 != $self_address[Int] && l$recipient@1973@01 != 0]
(assert (and
  (not (= l$recipient@1973@01 (as $self_address<Int>  Int)))
  (not (= l$recipient@1973@01 0))))
; [exec]
; i0$$pre_self := self
; [exec]
; i0$$pre_$contracts := $contracts
; [exec]
; l$i0$eth_sold := ($struct_get($struct_loc(msg, 1)): Int)
; [eval] ($struct_get($struct_loc(msg, 1)): Int)
; [eval] $struct_loc(msg, 1)
(declare-const l$i0$eth_sold@2071@01 Int)
(assert (= l$i0$eth_sold@2071@01 ($struct_get<Int> ($struct_loc<Int> msg@1976@01 1))))
; [exec]
; l$i0$min_tokens := l$min_tokens
; [exec]
; l$i0$deadline := l$deadline
; [exec]
; l$i0$buyer := ($struct_get($struct_loc(msg, 0)): Int)
; [eval] ($struct_get($struct_loc(msg, 0)): Int)
; [eval] $struct_loc(msg, 0)
(declare-const l$i0$buyer@2072@01 Int)
(assert (= l$i0$buyer@2072@01 ($struct_get<Int> ($struct_loc<Int> msg@1976@01 0))))
; [exec]
; l$i0$recipient := l$recipient
; [eval] !($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0))
; [eval] $unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0)
; [eval] $unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int)
; [eval] $unwrap(l$i0$deadline)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(push) ; 4
; [then-branch: 550 | !($unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4))) | live]
; [else-branch: 550 | $unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)) | live]
(push) ; 5
; [then-branch: 550 | !($unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)))]
(assert (not
  (>=
    ($unwrap<Int> l$deadline@1972@01)
    ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))))
(pop) ; 5
(push) ; 5
; [else-branch: 550 | $unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4))]
(assert (>=
  ($unwrap<Int> l$deadline@1972@01)
  ($struct_get<Int> ($struct_loc<Int> block@1977@01 4))))
; [eval] l$i0$eth_sold > 0
(push) ; 6
; [then-branch: 551 | !(l$i0$eth_sold@2071@01 > 0) | live]
; [else-branch: 551 | l$i0$eth_sold@2071@01 > 0 | live]
(push) ; 7
; [then-branch: 551 | !(l$i0$eth_sold@2071@01 > 0)]
(assert (not (> l$i0$eth_sold@2071@01 0)))
(pop) ; 7
(push) ; 7
; [else-branch: 551 | l$i0$eth_sold@2071@01 > 0]
(assert (> l$i0$eth_sold@2071@01 0))
; [eval] $unwrap(l$i0$min_tokens) > 0
; [eval] $unwrap(l$i0$min_tokens)
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (> l$i0$eth_sold@2071@01 0) (not (> l$i0$eth_sold@2071@01 0))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (=>
  (>=
    ($unwrap<Int> l$deadline@1972@01)
    ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))
  (and
    (>=
      ($unwrap<Int> l$deadline@1972@01)
      ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))
    (or (> l$i0$eth_sold@2071@01 0) (not (> l$i0$eth_sold@2071@01 0))))))
(assert (or
  (>=
    ($unwrap<Int> l$deadline@1972@01)
    ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))
  (not
    (>=
      ($unwrap<Int> l$deadline@1972@01)
      ($struct_get<Int> ($struct_loc<Int> block@1977@01 4))))))
(push) ; 4
(set-option :timeout 10)
(assert (not (and
  (>=
    ($unwrap<Int> l$deadline@1972@01)
    ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))
  (and (> l$i0$eth_sold@2071@01 0) (> ($unwrap<Int> l$min_tokens@1971@01) 0)))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not
  (and
    (>=
      ($unwrap<Int> l$deadline@1972@01)
      ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))
    (and (> l$i0$eth_sold@2071@01 0) (> ($unwrap<Int> l$min_tokens@1971@01) 0))))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 552 | !($unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)) && l$i0$eth_sold@2071@01 > 0 && $unwrap[Int](l$min_tokens@1971@01) > 0) | live]
; [else-branch: 552 | $unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)) && l$i0$eth_sold@2071@01 > 0 && $unwrap[Int](l$min_tokens@1971@01) > 0 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 552 | !($unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)) && l$i0$eth_sold@2071@01 > 0 && $unwrap[Int](l$min_tokens@1971@01) > 0)]
(assert (not
  (and
    (>=
      ($unwrap<Int> l$deadline@1972@01)
      ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))
    (and (> l$i0$eth_sold@2071@01 0) (> ($unwrap<Int> l$min_tokens@1971@01) 0)))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 5
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 553 | True | live]
; [else-branch: 553 | False | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 553 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@2073@01 $Snap)
(assert (= $t@2073@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@2021@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@2074@01 $Struct)
(assert (=
  self@2074@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    l$havoc$1@2021@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 5
; [then-branch: 554 | False | dead]
; [else-branch: 554 | True | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 554 | True]
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 552 | $unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)) && l$i0$eth_sold@2071@01 > 0 && $unwrap[Int](l$min_tokens@1971@01) > 0]
(assert (and
  (>=
    ($unwrap<Int> l$deadline@1972@01)
    ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))
  (and (> l$i0$eth_sold@2071@01 0) (> ($unwrap<Int> l$min_tokens@1971@01) 0))))
(pop) ; 4
; [eval] !!($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0))
; [eval] !($unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0))
; [eval] $unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int) && (l$i0$eth_sold > 0 && $unwrap(l$i0$min_tokens) > 0)
; [eval] $unwrap(l$i0$deadline) >= ($struct_get($struct_loc(block, 4)): Int)
; [eval] $unwrap(l$i0$deadline)
; [eval] ($struct_get($struct_loc(block, 4)): Int)
; [eval] $struct_loc(block, 4)
(push) ; 4
; [then-branch: 555 | !($unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4))) | live]
; [else-branch: 555 | $unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)) | live]
(push) ; 5
; [then-branch: 555 | !($unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)))]
(assert (not
  (>=
    ($unwrap<Int> l$deadline@1972@01)
    ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))))
(pop) ; 5
(push) ; 5
; [else-branch: 555 | $unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4))]
(assert (>=
  ($unwrap<Int> l$deadline@1972@01)
  ($struct_get<Int> ($struct_loc<Int> block@1977@01 4))))
; [eval] l$i0$eth_sold > 0
(push) ; 6
; [then-branch: 556 | !(l$i0$eth_sold@2071@01 > 0) | live]
; [else-branch: 556 | l$i0$eth_sold@2071@01 > 0 | live]
(push) ; 7
; [then-branch: 556 | !(l$i0$eth_sold@2071@01 > 0)]
(assert (not (> l$i0$eth_sold@2071@01 0)))
(pop) ; 7
(push) ; 7
; [else-branch: 556 | l$i0$eth_sold@2071@01 > 0]
(assert (> l$i0$eth_sold@2071@01 0))
; [eval] $unwrap(l$i0$min_tokens) > 0
; [eval] $unwrap(l$i0$min_tokens)
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (> l$i0$eth_sold@2071@01 0) (not (> l$i0$eth_sold@2071@01 0))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(push) ; 4
(set-option :timeout 10)
(assert (not (not
  (and
    (>=
      ($unwrap<Int> l$deadline@1972@01)
      ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))
    (and (> l$i0$eth_sold@2071@01 0) (> ($unwrap<Int> l$min_tokens@1971@01) 0))))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (and
  (>=
    ($unwrap<Int> l$deadline@1972@01)
    ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))
  (and (> l$i0$eth_sold@2071@01 0) (> ($unwrap<Int> l$min_tokens@1971@01) 0)))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 557 | $unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)) && l$i0$eth_sold@2071@01 > 0 && $unwrap[Int](l$min_tokens@1971@01) > 0 | live]
; [else-branch: 557 | !($unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)) && l$i0$eth_sold@2071@01 > 0 && $unwrap[Int](l$min_tokens@1971@01) > 0) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 557 | $unwrap[Int](l$deadline@1972@01) >= $struct_get[Int]($struct_loc[Int](block@1977@01, 4)) && l$i0$eth_sold@2071@01 > 0 && $unwrap[Int](l$min_tokens@1971@01) > 0]
(assert (and
  (>=
    ($unwrap<Int> l$deadline@1972@01)
    ($struct_get<Int> ($struct_loc<Int> block@1977@01 4)))
  (and (> l$i0$eth_sold@2071@01 0) (> ($unwrap<Int> l$min_tokens@1971@01) 0))))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@2075@01 Int)
(declare-const $arg1@2076@01 Int)
(declare-const $arg2@2077@01 Int)
(push) ; 5
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
(declare-const sm@2078@01 $PSF<e$TokenPurchase>)
(declare-const s@2079@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@2080@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef175|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef176|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2075@01)
    ($SortWrappers.IntTo$Snap $arg1@2076@01))
  ($SortWrappers.IntTo$Snap $arg2@2077@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2075@01)
    ($SortWrappers.IntTo$Snap $arg1@2076@01))
  ($SortWrappers.IntTo$Snap $arg2@2077@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2075@01)
      ($SortWrappers.IntTo$Snap $arg1@2076@01))
    ($SortWrappers.IntTo$Snap $arg2@2077@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@2081@01 (Int Int Int) Int)
(declare-fun img@2082@01 (Int Int Int) Bool)
(declare-fun inv@2083@01 (Int Int Int) Int)
(declare-fun img@2084@01 (Int Int Int) Bool)
(declare-fun inv@2085@01 (Int Int Int) Int)
(declare-fun img@2086@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef175|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef176|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2075@01 Int) ($arg1@2076@01 Int) ($arg2@2077@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2075@01)
          ($SortWrappers.IntTo$Snap $arg1@2076@01))
        ($SortWrappers.IntTo$Snap $arg2@2077@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2075@01)
        ($SortWrappers.IntTo$Snap $arg1@2076@01))
      ($SortWrappers.IntTo$Snap $arg2@2077@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2075@01)
        ($SortWrappers.IntTo$Snap $arg1@2076@01))
      ($SortWrappers.IntTo$Snap $arg2@2077@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2075@01)
      ($SortWrappers.IntTo$Snap $arg1@2076@01))
    ($SortWrappers.IntTo$Snap $arg2@2077@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2075@01)
      ($SortWrappers.IntTo$Snap $arg1@2076@01))
    ($SortWrappers.IntTo$Snap $arg2@2077@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 5
(assert (not (forall (($arg0@2075@01 Int) ($arg1@2076@01 Int) ($arg2@2077@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2075@01)
          ($SortWrappers.IntTo$Snap $arg1@2076@01))
        ($SortWrappers.IntTo$Snap $arg2@2077@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2075@01)
            ($SortWrappers.IntTo$Snap $arg1@2076@01))
          ($SortWrappers.IntTo$Snap $arg2@2077@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2075@01)
            ($SortWrappers.IntTo$Snap $arg1@2076@01))
          ($SortWrappers.IntTo$Snap $arg2@2077@01))))))
  
  :qid |quant-u-1845|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@2075@01 Int) ($arg11@2076@01 Int) ($arg21@2077@01 Int) ($arg02@2075@01 Int) ($arg12@2076@01 Int) ($arg22@2077@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2075@01)
                ($SortWrappers.IntTo$Snap $arg11@2076@01))
              ($SortWrappers.IntTo$Snap $arg21@2077@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2075@01)
              ($SortWrappers.IntTo$Snap $arg11@2076@01))
            ($SortWrappers.IntTo$Snap $arg21@2077@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2075@01)
              ($SortWrappers.IntTo$Snap $arg11@2076@01))
            ($SortWrappers.IntTo$Snap $arg21@2077@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2075@01)
              ($SortWrappers.IntTo$Snap $arg11@2076@01))
            ($SortWrappers.IntTo$Snap $arg21@2077@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2075@01)
                ($SortWrappers.IntTo$Snap $arg12@2076@01))
              ($SortWrappers.IntTo$Snap $arg22@2077@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2075@01)
              ($SortWrappers.IntTo$Snap $arg12@2076@01))
            ($SortWrappers.IntTo$Snap $arg22@2077@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2075@01)
              ($SortWrappers.IntTo$Snap $arg12@2076@01))
            ($SortWrappers.IntTo$Snap $arg22@2077@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2075@01)
              ($SortWrappers.IntTo$Snap $arg12@2076@01))
            ($SortWrappers.IntTo$Snap $arg22@2077@01)))))
      (and
        (and (= $arg01@2075@01 $arg02@2075@01) (= $arg11@2076@01 $arg12@2076@01))
        (= $arg21@2077@01 $arg22@2077@01)))
    (and
      (and (= $arg01@2075@01 $arg02@2075@01) (= $arg11@2076@01 $arg12@2076@01))
      (= $arg21@2077@01 $arg22@2077@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2075@01 Int) ($arg1@2076@01 Int) ($arg2@2077@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2075@01)
            ($SortWrappers.IntTo$Snap $arg1@2076@01))
          ($SortWrappers.IntTo$Snap $arg2@2077@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2075@01)
            ($SortWrappers.IntTo$Snap $arg1@2076@01))
          ($SortWrappers.IntTo$Snap $arg2@2077@01)))))
    (and
      (and
        (= (inv@2081@01 $arg0@2075@01 $arg1@2076@01 $arg2@2077@01) $arg0@2075@01)
        (= (inv@2083@01 $arg0@2075@01 $arg1@2076@01 $arg2@2077@01) $arg1@2076@01)
        (= (inv@2085@01 $arg0@2075@01 $arg1@2076@01 $arg2@2077@01) $arg2@2077@01))
      (and
        (img@2082@01 $arg0@2075@01 $arg1@2076@01 $arg2@2077@01)
        (img@2084@01 $arg0@2075@01 $arg1@2076@01 $arg2@2077@01)
        (img@2086@01 $arg0@2075@01 $arg1@2076@01 $arg2@2077@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2075@01)
      ($SortWrappers.IntTo$Snap $arg1@2076@01))
    ($SortWrappers.IntTo$Snap $arg2@2077@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2075@01)
      ($SortWrappers.IntTo$Snap $arg1@2076@01))
    ($SortWrappers.IntTo$Snap $arg2@2077@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2082@01 $arg0 $arg1 $arg2)
        (img@2084@01 $arg0 $arg1 $arg2)
        (img@2086@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2081@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2083@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2085@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2081@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2083@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2085@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2081@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2083@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2085@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2081@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2083@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2085@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2081@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2083@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2085@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2081@01 $arg0 $arg1 $arg2) (inv@2083@01 $arg0 $arg1 $arg2) (inv@2085@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1846|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2081@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2083@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2085@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2082@01 $arg0 $arg1 $arg2)
        (img@2084@01 $arg0 $arg1 $arg2)
        (img@2086@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2081@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2083@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2085@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@2080@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2081@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2083@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2085@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1847|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@2087@01 Int)
(declare-const $arg1@2088@01 Int)
(declare-const $arg2@2089@01 Int)
(push) ; 5
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
(declare-const sm@2090@01 $PSF<e$EthPurchase>)
(declare-const s@2091@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@2092@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef178|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef179|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2087@01)
    ($SortWrappers.IntTo$Snap $arg1@2088@01))
  ($SortWrappers.IntTo$Snap $arg2@2089@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2087@01)
    ($SortWrappers.IntTo$Snap $arg1@2088@01))
  ($SortWrappers.IntTo$Snap $arg2@2089@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2087@01)
      ($SortWrappers.IntTo$Snap $arg1@2088@01))
    ($SortWrappers.IntTo$Snap $arg2@2089@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@2093@01 (Int Int Int) Int)
(declare-fun img@2094@01 (Int Int Int) Bool)
(declare-fun inv@2095@01 (Int Int Int) Int)
(declare-fun img@2096@01 (Int Int Int) Bool)
(declare-fun inv@2097@01 (Int Int Int) Int)
(declare-fun img@2098@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef178|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef179|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2087@01 Int) ($arg1@2088@01 Int) ($arg2@2089@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2087@01)
          ($SortWrappers.IntTo$Snap $arg1@2088@01))
        ($SortWrappers.IntTo$Snap $arg2@2089@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2087@01)
        ($SortWrappers.IntTo$Snap $arg1@2088@01))
      ($SortWrappers.IntTo$Snap $arg2@2089@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2087@01)
        ($SortWrappers.IntTo$Snap $arg1@2088@01))
      ($SortWrappers.IntTo$Snap $arg2@2089@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2087@01)
      ($SortWrappers.IntTo$Snap $arg1@2088@01))
    ($SortWrappers.IntTo$Snap $arg2@2089@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2087@01)
      ($SortWrappers.IntTo$Snap $arg1@2088@01))
    ($SortWrappers.IntTo$Snap $arg2@2089@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 5
(assert (not (forall (($arg0@2087@01 Int) ($arg1@2088@01 Int) ($arg2@2089@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2087@01)
          ($SortWrappers.IntTo$Snap $arg1@2088@01))
        ($SortWrappers.IntTo$Snap $arg2@2089@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2087@01)
            ($SortWrappers.IntTo$Snap $arg1@2088@01))
          ($SortWrappers.IntTo$Snap $arg2@2089@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2087@01)
            ($SortWrappers.IntTo$Snap $arg1@2088@01))
          ($SortWrappers.IntTo$Snap $arg2@2089@01))))))
  
  :qid |quant-u-1848|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@2087@01 Int) ($arg11@2088@01 Int) ($arg21@2089@01 Int) ($arg02@2087@01 Int) ($arg12@2088@01 Int) ($arg22@2089@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2087@01)
                ($SortWrappers.IntTo$Snap $arg11@2088@01))
              ($SortWrappers.IntTo$Snap $arg21@2089@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2087@01)
              ($SortWrappers.IntTo$Snap $arg11@2088@01))
            ($SortWrappers.IntTo$Snap $arg21@2089@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2087@01)
              ($SortWrappers.IntTo$Snap $arg11@2088@01))
            ($SortWrappers.IntTo$Snap $arg21@2089@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2087@01)
              ($SortWrappers.IntTo$Snap $arg11@2088@01))
            ($SortWrappers.IntTo$Snap $arg21@2089@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2087@01)
                ($SortWrappers.IntTo$Snap $arg12@2088@01))
              ($SortWrappers.IntTo$Snap $arg22@2089@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2087@01)
              ($SortWrappers.IntTo$Snap $arg12@2088@01))
            ($SortWrappers.IntTo$Snap $arg22@2089@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2087@01)
              ($SortWrappers.IntTo$Snap $arg12@2088@01))
            ($SortWrappers.IntTo$Snap $arg22@2089@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2087@01)
              ($SortWrappers.IntTo$Snap $arg12@2088@01))
            ($SortWrappers.IntTo$Snap $arg22@2089@01)))))
      (and
        (and (= $arg01@2087@01 $arg02@2087@01) (= $arg11@2088@01 $arg12@2088@01))
        (= $arg21@2089@01 $arg22@2089@01)))
    (and
      (and (= $arg01@2087@01 $arg02@2087@01) (= $arg11@2088@01 $arg12@2088@01))
      (= $arg21@2089@01 $arg22@2089@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2087@01 Int) ($arg1@2088@01 Int) ($arg2@2089@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2087@01)
            ($SortWrappers.IntTo$Snap $arg1@2088@01))
          ($SortWrappers.IntTo$Snap $arg2@2089@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2087@01)
            ($SortWrappers.IntTo$Snap $arg1@2088@01))
          ($SortWrappers.IntTo$Snap $arg2@2089@01)))))
    (and
      (and
        (= (inv@2093@01 $arg0@2087@01 $arg1@2088@01 $arg2@2089@01) $arg0@2087@01)
        (= (inv@2095@01 $arg0@2087@01 $arg1@2088@01 $arg2@2089@01) $arg1@2088@01)
        (= (inv@2097@01 $arg0@2087@01 $arg1@2088@01 $arg2@2089@01) $arg2@2089@01))
      (and
        (img@2094@01 $arg0@2087@01 $arg1@2088@01 $arg2@2089@01)
        (img@2096@01 $arg0@2087@01 $arg1@2088@01 $arg2@2089@01)
        (img@2098@01 $arg0@2087@01 $arg1@2088@01 $arg2@2089@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2087@01)
      ($SortWrappers.IntTo$Snap $arg1@2088@01))
    ($SortWrappers.IntTo$Snap $arg2@2089@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2087@01)
      ($SortWrappers.IntTo$Snap $arg1@2088@01))
    ($SortWrappers.IntTo$Snap $arg2@2089@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2094@01 $arg0 $arg1 $arg2)
        (img@2096@01 $arg0 $arg1 $arg2)
        (img@2098@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2093@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2095@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2097@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2093@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2095@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2097@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2093@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2095@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2097@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2093@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2095@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2097@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2093@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2095@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2097@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2093@01 $arg0 $arg1 $arg2) (inv@2095@01 $arg0 $arg1 $arg2) (inv@2097@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1849|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2093@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2095@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2097@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2094@01 $arg0 $arg1 $arg2)
        (img@2096@01 $arg0 $arg1 $arg2)
        (img@2098@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2093@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2095@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2097@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@2092@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2093@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2095@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2097@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1850|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@2099@01 Int)
(declare-const $arg1@2100@01 Int)
(declare-const $arg2@2101@01 Int)
(push) ; 5
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
(declare-const sm@2102@01 $PSF<e$AddLiquidity>)
(declare-const s@2103@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@2104@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef181|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef182|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2099@01)
    ($SortWrappers.IntTo$Snap $arg1@2100@01))
  ($SortWrappers.IntTo$Snap $arg2@2101@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2099@01)
    ($SortWrappers.IntTo$Snap $arg1@2100@01))
  ($SortWrappers.IntTo$Snap $arg2@2101@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2099@01)
      ($SortWrappers.IntTo$Snap $arg1@2100@01))
    ($SortWrappers.IntTo$Snap $arg2@2101@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@2105@01 (Int Int Int) Int)
(declare-fun img@2106@01 (Int Int Int) Bool)
(declare-fun inv@2107@01 (Int Int Int) Int)
(declare-fun img@2108@01 (Int Int Int) Bool)
(declare-fun inv@2109@01 (Int Int Int) Int)
(declare-fun img@2110@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef181|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef182|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2099@01 Int) ($arg1@2100@01 Int) ($arg2@2101@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2099@01)
          ($SortWrappers.IntTo$Snap $arg1@2100@01))
        ($SortWrappers.IntTo$Snap $arg2@2101@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2099@01)
        ($SortWrappers.IntTo$Snap $arg1@2100@01))
      ($SortWrappers.IntTo$Snap $arg2@2101@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2099@01)
        ($SortWrappers.IntTo$Snap $arg1@2100@01))
      ($SortWrappers.IntTo$Snap $arg2@2101@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2099@01)
      ($SortWrappers.IntTo$Snap $arg1@2100@01))
    ($SortWrappers.IntTo$Snap $arg2@2101@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2099@01)
      ($SortWrappers.IntTo$Snap $arg1@2100@01))
    ($SortWrappers.IntTo$Snap $arg2@2101@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 5
(assert (not (forall (($arg0@2099@01 Int) ($arg1@2100@01 Int) ($arg2@2101@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2099@01)
          ($SortWrappers.IntTo$Snap $arg1@2100@01))
        ($SortWrappers.IntTo$Snap $arg2@2101@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2099@01)
            ($SortWrappers.IntTo$Snap $arg1@2100@01))
          ($SortWrappers.IntTo$Snap $arg2@2101@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2099@01)
            ($SortWrappers.IntTo$Snap $arg1@2100@01))
          ($SortWrappers.IntTo$Snap $arg2@2101@01))))))
  
  :qid |quant-u-1851|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@2099@01 Int) ($arg11@2100@01 Int) ($arg21@2101@01 Int) ($arg02@2099@01 Int) ($arg12@2100@01 Int) ($arg22@2101@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2099@01)
                ($SortWrappers.IntTo$Snap $arg11@2100@01))
              ($SortWrappers.IntTo$Snap $arg21@2101@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2099@01)
              ($SortWrappers.IntTo$Snap $arg11@2100@01))
            ($SortWrappers.IntTo$Snap $arg21@2101@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2099@01)
              ($SortWrappers.IntTo$Snap $arg11@2100@01))
            ($SortWrappers.IntTo$Snap $arg21@2101@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2099@01)
              ($SortWrappers.IntTo$Snap $arg11@2100@01))
            ($SortWrappers.IntTo$Snap $arg21@2101@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2099@01)
                ($SortWrappers.IntTo$Snap $arg12@2100@01))
              ($SortWrappers.IntTo$Snap $arg22@2101@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2099@01)
              ($SortWrappers.IntTo$Snap $arg12@2100@01))
            ($SortWrappers.IntTo$Snap $arg22@2101@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2099@01)
              ($SortWrappers.IntTo$Snap $arg12@2100@01))
            ($SortWrappers.IntTo$Snap $arg22@2101@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2099@01)
              ($SortWrappers.IntTo$Snap $arg12@2100@01))
            ($SortWrappers.IntTo$Snap $arg22@2101@01)))))
      (and
        (and (= $arg01@2099@01 $arg02@2099@01) (= $arg11@2100@01 $arg12@2100@01))
        (= $arg21@2101@01 $arg22@2101@01)))
    (and
      (and (= $arg01@2099@01 $arg02@2099@01) (= $arg11@2100@01 $arg12@2100@01))
      (= $arg21@2101@01 $arg22@2101@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2099@01 Int) ($arg1@2100@01 Int) ($arg2@2101@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2099@01)
            ($SortWrappers.IntTo$Snap $arg1@2100@01))
          ($SortWrappers.IntTo$Snap $arg2@2101@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2099@01)
            ($SortWrappers.IntTo$Snap $arg1@2100@01))
          ($SortWrappers.IntTo$Snap $arg2@2101@01)))))
    (and
      (and
        (= (inv@2105@01 $arg0@2099@01 $arg1@2100@01 $arg2@2101@01) $arg0@2099@01)
        (= (inv@2107@01 $arg0@2099@01 $arg1@2100@01 $arg2@2101@01) $arg1@2100@01)
        (= (inv@2109@01 $arg0@2099@01 $arg1@2100@01 $arg2@2101@01) $arg2@2101@01))
      (and
        (img@2106@01 $arg0@2099@01 $arg1@2100@01 $arg2@2101@01)
        (img@2108@01 $arg0@2099@01 $arg1@2100@01 $arg2@2101@01)
        (img@2110@01 $arg0@2099@01 $arg1@2100@01 $arg2@2101@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2099@01)
      ($SortWrappers.IntTo$Snap $arg1@2100@01))
    ($SortWrappers.IntTo$Snap $arg2@2101@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2099@01)
      ($SortWrappers.IntTo$Snap $arg1@2100@01))
    ($SortWrappers.IntTo$Snap $arg2@2101@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2106@01 $arg0 $arg1 $arg2)
        (img@2108@01 $arg0 $arg1 $arg2)
        (img@2110@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2105@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2107@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2109@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2105@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2107@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2109@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2105@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2107@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2109@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2105@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2107@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2109@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2105@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2107@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2109@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2105@01 $arg0 $arg1 $arg2) (inv@2107@01 $arg0 $arg1 $arg2) (inv@2109@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1852|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2105@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2107@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2109@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2106@01 $arg0 $arg1 $arg2)
        (img@2108@01 $arg0 $arg1 $arg2)
        (img@2110@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2105@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2107@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2109@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@2104@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2105@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2107@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2109@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1853|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@2111@01 Int)
(declare-const $arg1@2112@01 Int)
(declare-const $arg2@2113@01 Int)
(push) ; 5
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
(declare-const sm@2114@01 $PSF<e$RemoveLiquidity>)
(declare-const s@2115@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@2116@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef184|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef185|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2111@01)
    ($SortWrappers.IntTo$Snap $arg1@2112@01))
  ($SortWrappers.IntTo$Snap $arg2@2113@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2111@01)
    ($SortWrappers.IntTo$Snap $arg1@2112@01))
  ($SortWrappers.IntTo$Snap $arg2@2113@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2111@01)
      ($SortWrappers.IntTo$Snap $arg1@2112@01))
    ($SortWrappers.IntTo$Snap $arg2@2113@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@2117@01 (Int Int Int) Int)
(declare-fun img@2118@01 (Int Int Int) Bool)
(declare-fun inv@2119@01 (Int Int Int) Int)
(declare-fun img@2120@01 (Int Int Int) Bool)
(declare-fun inv@2121@01 (Int Int Int) Int)
(declare-fun img@2122@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef184|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef185|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2111@01 Int) ($arg1@2112@01 Int) ($arg2@2113@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2111@01)
          ($SortWrappers.IntTo$Snap $arg1@2112@01))
        ($SortWrappers.IntTo$Snap $arg2@2113@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2111@01)
        ($SortWrappers.IntTo$Snap $arg1@2112@01))
      ($SortWrappers.IntTo$Snap $arg2@2113@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2111@01)
        ($SortWrappers.IntTo$Snap $arg1@2112@01))
      ($SortWrappers.IntTo$Snap $arg2@2113@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2111@01)
      ($SortWrappers.IntTo$Snap $arg1@2112@01))
    ($SortWrappers.IntTo$Snap $arg2@2113@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2111@01)
      ($SortWrappers.IntTo$Snap $arg1@2112@01))
    ($SortWrappers.IntTo$Snap $arg2@2113@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 5
(assert (not (forall (($arg0@2111@01 Int) ($arg1@2112@01 Int) ($arg2@2113@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2111@01)
          ($SortWrappers.IntTo$Snap $arg1@2112@01))
        ($SortWrappers.IntTo$Snap $arg2@2113@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2111@01)
            ($SortWrappers.IntTo$Snap $arg1@2112@01))
          ($SortWrappers.IntTo$Snap $arg2@2113@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2111@01)
            ($SortWrappers.IntTo$Snap $arg1@2112@01))
          ($SortWrappers.IntTo$Snap $arg2@2113@01))))))
  
  :qid |quant-u-1854|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@2111@01 Int) ($arg11@2112@01 Int) ($arg21@2113@01 Int) ($arg02@2111@01 Int) ($arg12@2112@01 Int) ($arg22@2113@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2111@01)
                ($SortWrappers.IntTo$Snap $arg11@2112@01))
              ($SortWrappers.IntTo$Snap $arg21@2113@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2111@01)
              ($SortWrappers.IntTo$Snap $arg11@2112@01))
            ($SortWrappers.IntTo$Snap $arg21@2113@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2111@01)
              ($SortWrappers.IntTo$Snap $arg11@2112@01))
            ($SortWrappers.IntTo$Snap $arg21@2113@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2111@01)
              ($SortWrappers.IntTo$Snap $arg11@2112@01))
            ($SortWrappers.IntTo$Snap $arg21@2113@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2111@01)
                ($SortWrappers.IntTo$Snap $arg12@2112@01))
              ($SortWrappers.IntTo$Snap $arg22@2113@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2111@01)
              ($SortWrappers.IntTo$Snap $arg12@2112@01))
            ($SortWrappers.IntTo$Snap $arg22@2113@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2111@01)
              ($SortWrappers.IntTo$Snap $arg12@2112@01))
            ($SortWrappers.IntTo$Snap $arg22@2113@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2111@01)
              ($SortWrappers.IntTo$Snap $arg12@2112@01))
            ($SortWrappers.IntTo$Snap $arg22@2113@01)))))
      (and
        (and (= $arg01@2111@01 $arg02@2111@01) (= $arg11@2112@01 $arg12@2112@01))
        (= $arg21@2113@01 $arg22@2113@01)))
    (and
      (and (= $arg01@2111@01 $arg02@2111@01) (= $arg11@2112@01 $arg12@2112@01))
      (= $arg21@2113@01 $arg22@2113@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2111@01 Int) ($arg1@2112@01 Int) ($arg2@2113@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2111@01)
            ($SortWrappers.IntTo$Snap $arg1@2112@01))
          ($SortWrappers.IntTo$Snap $arg2@2113@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2111@01)
            ($SortWrappers.IntTo$Snap $arg1@2112@01))
          ($SortWrappers.IntTo$Snap $arg2@2113@01)))))
    (and
      (and
        (= (inv@2117@01 $arg0@2111@01 $arg1@2112@01 $arg2@2113@01) $arg0@2111@01)
        (= (inv@2119@01 $arg0@2111@01 $arg1@2112@01 $arg2@2113@01) $arg1@2112@01)
        (= (inv@2121@01 $arg0@2111@01 $arg1@2112@01 $arg2@2113@01) $arg2@2113@01))
      (and
        (img@2118@01 $arg0@2111@01 $arg1@2112@01 $arg2@2113@01)
        (img@2120@01 $arg0@2111@01 $arg1@2112@01 $arg2@2113@01)
        (img@2122@01 $arg0@2111@01 $arg1@2112@01 $arg2@2113@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2111@01)
      ($SortWrappers.IntTo$Snap $arg1@2112@01))
    ($SortWrappers.IntTo$Snap $arg2@2113@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2111@01)
      ($SortWrappers.IntTo$Snap $arg1@2112@01))
    ($SortWrappers.IntTo$Snap $arg2@2113@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2118@01 $arg0 $arg1 $arg2)
        (img@2120@01 $arg0 $arg1 $arg2)
        (img@2122@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2117@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2119@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2121@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2117@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2119@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2121@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2117@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2119@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2121@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2117@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2119@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2121@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2117@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2119@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2121@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2117@01 $arg0 $arg1 $arg2) (inv@2119@01 $arg0 $arg1 $arg2) (inv@2121@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1855|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2117@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2119@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2121@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2118@01 $arg0 $arg1 $arg2)
        (img@2120@01 $arg0 $arg1 $arg2)
        (img@2122@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2117@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2119@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2121@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@2116@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2117@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2119@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2121@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1856|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@2123@01 Int)
(declare-const $arg1@2124@01 Int)
(declare-const $arg2@2125@01 Int)
(push) ; 5
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
(declare-const sm@2126@01 $PSF<e$Transfer>)
(declare-const s@2127@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@2128@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef187|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef188|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2123@01)
    ($SortWrappers.IntTo$Snap $arg1@2124@01))
  ($SortWrappers.IntTo$Snap $arg2@2125@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2123@01)
    ($SortWrappers.IntTo$Snap $arg1@2124@01))
  ($SortWrappers.IntTo$Snap $arg2@2125@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2123@01)
      ($SortWrappers.IntTo$Snap $arg1@2124@01))
    ($SortWrappers.IntTo$Snap $arg2@2125@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@2129@01 (Int Int Int) Int)
(declare-fun img@2130@01 (Int Int Int) Bool)
(declare-fun inv@2131@01 (Int Int Int) Int)
(declare-fun img@2132@01 (Int Int Int) Bool)
(declare-fun inv@2133@01 (Int Int Int) Int)
(declare-fun img@2134@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef187|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef188|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2123@01 Int) ($arg1@2124@01 Int) ($arg2@2125@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2123@01)
          ($SortWrappers.IntTo$Snap $arg1@2124@01))
        ($SortWrappers.IntTo$Snap $arg2@2125@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2123@01)
        ($SortWrappers.IntTo$Snap $arg1@2124@01))
      ($SortWrappers.IntTo$Snap $arg2@2125@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2123@01)
        ($SortWrappers.IntTo$Snap $arg1@2124@01))
      ($SortWrappers.IntTo$Snap $arg2@2125@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2123@01)
      ($SortWrappers.IntTo$Snap $arg1@2124@01))
    ($SortWrappers.IntTo$Snap $arg2@2125@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2123@01)
      ($SortWrappers.IntTo$Snap $arg1@2124@01))
    ($SortWrappers.IntTo$Snap $arg2@2125@01))))
  :qid |e$Transfer-aux|)))
(push) ; 5
(assert (not (forall (($arg0@2123@01 Int) ($arg1@2124@01 Int) ($arg2@2125@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2123@01)
          ($SortWrappers.IntTo$Snap $arg1@2124@01))
        ($SortWrappers.IntTo$Snap $arg2@2125@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2123@01)
            ($SortWrappers.IntTo$Snap $arg1@2124@01))
          ($SortWrappers.IntTo$Snap $arg2@2125@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2123@01)
            ($SortWrappers.IntTo$Snap $arg1@2124@01))
          ($SortWrappers.IntTo$Snap $arg2@2125@01))))))
  
  :qid |quant-u-1857|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@2123@01 Int) ($arg11@2124@01 Int) ($arg21@2125@01 Int) ($arg02@2123@01 Int) ($arg12@2124@01 Int) ($arg22@2125@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2123@01)
                ($SortWrappers.IntTo$Snap $arg11@2124@01))
              ($SortWrappers.IntTo$Snap $arg21@2125@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2123@01)
              ($SortWrappers.IntTo$Snap $arg11@2124@01))
            ($SortWrappers.IntTo$Snap $arg21@2125@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2123@01)
              ($SortWrappers.IntTo$Snap $arg11@2124@01))
            ($SortWrappers.IntTo$Snap $arg21@2125@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2123@01)
              ($SortWrappers.IntTo$Snap $arg11@2124@01))
            ($SortWrappers.IntTo$Snap $arg21@2125@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2123@01)
                ($SortWrappers.IntTo$Snap $arg12@2124@01))
              ($SortWrappers.IntTo$Snap $arg22@2125@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2123@01)
              ($SortWrappers.IntTo$Snap $arg12@2124@01))
            ($SortWrappers.IntTo$Snap $arg22@2125@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2123@01)
              ($SortWrappers.IntTo$Snap $arg12@2124@01))
            ($SortWrappers.IntTo$Snap $arg22@2125@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2123@01)
              ($SortWrappers.IntTo$Snap $arg12@2124@01))
            ($SortWrappers.IntTo$Snap $arg22@2125@01)))))
      (and
        (and (= $arg01@2123@01 $arg02@2123@01) (= $arg11@2124@01 $arg12@2124@01))
        (= $arg21@2125@01 $arg22@2125@01)))
    (and
      (and (= $arg01@2123@01 $arg02@2123@01) (= $arg11@2124@01 $arg12@2124@01))
      (= $arg21@2125@01 $arg22@2125@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2123@01 Int) ($arg1@2124@01 Int) ($arg2@2125@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2123@01)
            ($SortWrappers.IntTo$Snap $arg1@2124@01))
          ($SortWrappers.IntTo$Snap $arg2@2125@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2123@01)
            ($SortWrappers.IntTo$Snap $arg1@2124@01))
          ($SortWrappers.IntTo$Snap $arg2@2125@01)))))
    (and
      (and
        (= (inv@2129@01 $arg0@2123@01 $arg1@2124@01 $arg2@2125@01) $arg0@2123@01)
        (= (inv@2131@01 $arg0@2123@01 $arg1@2124@01 $arg2@2125@01) $arg1@2124@01)
        (= (inv@2133@01 $arg0@2123@01 $arg1@2124@01 $arg2@2125@01) $arg2@2125@01))
      (and
        (img@2130@01 $arg0@2123@01 $arg1@2124@01 $arg2@2125@01)
        (img@2132@01 $arg0@2123@01 $arg1@2124@01 $arg2@2125@01)
        (img@2134@01 $arg0@2123@01 $arg1@2124@01 $arg2@2125@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2123@01)
      ($SortWrappers.IntTo$Snap $arg1@2124@01))
    ($SortWrappers.IntTo$Snap $arg2@2125@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2123@01)
      ($SortWrappers.IntTo$Snap $arg1@2124@01))
    ($SortWrappers.IntTo$Snap $arg2@2125@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2130@01 $arg0 $arg1 $arg2)
        (img@2132@01 $arg0 $arg1 $arg2)
        (img@2134@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2129@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2131@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2133@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2129@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2131@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2133@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2129@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2131@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2133@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2129@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2131@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2133@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2129@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2131@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2133@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2129@01 $arg0 $arg1 $arg2) (inv@2131@01 $arg0 $arg1 $arg2) (inv@2133@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1858|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2129@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2131@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2133@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2130@01 $arg0 $arg1 $arg2)
        (img@2132@01 $arg0 $arg1 $arg2)
        (img@2134@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2129@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2131@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2133@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@2128@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2129@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2131@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2133@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1859|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@2135@01 Int)
(declare-const $arg1@2136@01 Int)
(declare-const $arg2@2137@01 Int)
(push) ; 5
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
(declare-const sm@2138@01 $PSF<e$Approval>)
(declare-const s@2139@01 $Snap)
; Definitional axioms for snapshot map values
(declare-const pm@2140@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef190|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef191|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2135@01)
    ($SortWrappers.IntTo$Snap $arg1@2136@01))
  ($SortWrappers.IntTo$Snap $arg2@2137@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2135@01)
    ($SortWrappers.IntTo$Snap $arg1@2136@01))
  ($SortWrappers.IntTo$Snap $arg2@2137@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2135@01)
      ($SortWrappers.IntTo$Snap $arg1@2136@01))
    ($SortWrappers.IntTo$Snap $arg2@2137@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 5
(declare-fun inv@2141@01 (Int Int Int) Int)
(declare-fun img@2142@01 (Int Int Int) Bool)
(declare-fun inv@2143@01 (Int Int Int) Int)
(declare-fun img@2144@01 (Int Int Int) Bool)
(declare-fun inv@2145@01 (Int Int Int) Int)
(declare-fun img@2146@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef190|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef191|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2135@01 Int) ($arg1@2136@01 Int) ($arg2@2137@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2135@01)
          ($SortWrappers.IntTo$Snap $arg1@2136@01))
        ($SortWrappers.IntTo$Snap $arg2@2137@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2135@01)
        ($SortWrappers.IntTo$Snap $arg1@2136@01))
      ($SortWrappers.IntTo$Snap $arg2@2137@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2135@01)
        ($SortWrappers.IntTo$Snap $arg1@2136@01))
      ($SortWrappers.IntTo$Snap $arg2@2137@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2135@01)
      ($SortWrappers.IntTo$Snap $arg1@2136@01))
    ($SortWrappers.IntTo$Snap $arg2@2137@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2135@01)
      ($SortWrappers.IntTo$Snap $arg1@2136@01))
    ($SortWrappers.IntTo$Snap $arg2@2137@01))))
  :qid |e$Approval-aux|)))
(push) ; 5
(assert (not (forall (($arg0@2135@01 Int) ($arg1@2136@01 Int) ($arg2@2137@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2135@01)
          ($SortWrappers.IntTo$Snap $arg1@2136@01))
        ($SortWrappers.IntTo$Snap $arg2@2137@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2135@01)
            ($SortWrappers.IntTo$Snap $arg1@2136@01))
          ($SortWrappers.IntTo$Snap $arg2@2137@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2135@01)
            ($SortWrappers.IntTo$Snap $arg1@2136@01))
          ($SortWrappers.IntTo$Snap $arg2@2137@01))))))
  
  :qid |quant-u-1860|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall (($arg01@2135@01 Int) ($arg11@2136@01 Int) ($arg21@2137@01 Int) ($arg02@2135@01 Int) ($arg12@2136@01 Int) ($arg22@2137@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2135@01)
                ($SortWrappers.IntTo$Snap $arg11@2136@01))
              ($SortWrappers.IntTo$Snap $arg21@2137@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2135@01)
              ($SortWrappers.IntTo$Snap $arg11@2136@01))
            ($SortWrappers.IntTo$Snap $arg21@2137@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2135@01)
              ($SortWrappers.IntTo$Snap $arg11@2136@01))
            ($SortWrappers.IntTo$Snap $arg21@2137@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2135@01)
              ($SortWrappers.IntTo$Snap $arg11@2136@01))
            ($SortWrappers.IntTo$Snap $arg21@2137@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2135@01)
                ($SortWrappers.IntTo$Snap $arg12@2136@01))
              ($SortWrappers.IntTo$Snap $arg22@2137@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2135@01)
              ($SortWrappers.IntTo$Snap $arg12@2136@01))
            ($SortWrappers.IntTo$Snap $arg22@2137@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2135@01)
              ($SortWrappers.IntTo$Snap $arg12@2136@01))
            ($SortWrappers.IntTo$Snap $arg22@2137@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2135@01)
              ($SortWrappers.IntTo$Snap $arg12@2136@01))
            ($SortWrappers.IntTo$Snap $arg22@2137@01)))))
      (and
        (and (= $arg01@2135@01 $arg02@2135@01) (= $arg11@2136@01 $arg12@2136@01))
        (= $arg21@2137@01 $arg22@2137@01)))
    (and
      (and (= $arg01@2135@01 $arg02@2135@01) (= $arg11@2136@01 $arg12@2136@01))
      (= $arg21@2137@01 $arg22@2137@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2135@01 Int) ($arg1@2136@01 Int) ($arg2@2137@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2135@01)
            ($SortWrappers.IntTo$Snap $arg1@2136@01))
          ($SortWrappers.IntTo$Snap $arg2@2137@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2135@01)
            ($SortWrappers.IntTo$Snap $arg1@2136@01))
          ($SortWrappers.IntTo$Snap $arg2@2137@01)))))
    (and
      (and
        (= (inv@2141@01 $arg0@2135@01 $arg1@2136@01 $arg2@2137@01) $arg0@2135@01)
        (= (inv@2143@01 $arg0@2135@01 $arg1@2136@01 $arg2@2137@01) $arg1@2136@01)
        (= (inv@2145@01 $arg0@2135@01 $arg1@2136@01 $arg2@2137@01) $arg2@2137@01))
      (and
        (img@2142@01 $arg0@2135@01 $arg1@2136@01 $arg2@2137@01)
        (img@2144@01 $arg0@2135@01 $arg1@2136@01 $arg2@2137@01)
        (img@2146@01 $arg0@2135@01 $arg1@2136@01 $arg2@2137@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2135@01)
      ($SortWrappers.IntTo$Snap $arg1@2136@01))
    ($SortWrappers.IntTo$Snap $arg2@2137@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2135@01)
      ($SortWrappers.IntTo$Snap $arg1@2136@01))
    ($SortWrappers.IntTo$Snap $arg2@2137@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2142@01 $arg0 $arg1 $arg2)
        (img@2144@01 $arg0 $arg1 $arg2)
        (img@2146@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2141@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2143@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2145@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2141@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2143@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2145@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2141@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2143@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2145@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2141@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2143@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2145@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2141@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2143@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2145@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2141@01 $arg0 $arg1 $arg2) (inv@2143@01 $arg0 $arg1 $arg2) (inv@2145@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1861|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 5
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2141@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2143@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2145@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2142@01 $arg0 $arg1 $arg2)
        (img@2144@01 $arg0 $arg1 $arg2)
        (img@2146@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2141@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2143@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2145@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@2140@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2141@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2143@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2145@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1862|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; inhale 0 <= l$i0$raw_ret &&
;   l$i0$raw_ret <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2147@01 $Snap)
(assert (= $t@2147@01 ($Snap.combine ($Snap.first $t@2147@01) ($Snap.second $t@2147@01))))
(assert (= ($Snap.first $t@2147@01) $Snap.unit))
; [eval] 0 <= l$i0$raw_ret
(assert (<= 0 l$i0$raw_ret@1998@01))
(assert (= ($Snap.second $t@2147@01) $Snap.unit))
; [eval] l$i0$raw_ret <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
(assert (<=
  l$i0$raw_ret@1998@01
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not l$i0$send_fail@1997@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not l$i0$send_fail@1997@01))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 558 | l$i0$send_fail@1997@01 | live]
; [else-branch: 558 | !(l$i0$send_fail@1997@01) | live]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 558 | l$i0$send_fail@1997@01]
(assert l$i0$send_fail@1997@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@2148@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 559 | True | live]
; [else-branch: 559 | False | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 559 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@2149@01 $Snap)
(assert (= $t@2149@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@2021@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@2150@01 $Struct)
(assert (=
  self@2150@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    l$havoc$1@2021@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 6
; [then-branch: 560 | False | dead]
; [else-branch: 560 | True | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 560 | True]
(pop) ; 6
(pop) ; 5
(push) ; 5
; [else-branch: 558 | !(l$i0$send_fail@1997@01)]
(assert (not l$i0$send_fail@1997@01))
(pop) ; 5
; [eval] !l$i0$send_fail
(push) ; 5
(set-option :timeout 10)
(assert (not l$i0$send_fail@1997@01))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not l$i0$send_fail@1997@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 561 | !(l$i0$send_fail@1997@01) | live]
; [else-branch: 561 | l$i0$send_fail@1997@01 | live]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 561 | !(l$i0$send_fail@1997@01)]
(assert (not l$i0$send_fail@1997@01))
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; l$i0$token_reserve := $wrap(l$i0$raw_ret)
; [eval] $wrap(l$i0$raw_ret)
(declare-const l$i0$token_reserve@2151@01 $Int)
(assert (= l$i0$token_reserve@2151@01 ($wrap<$Int> l$i0$raw_ret@1998@01)))
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@2068@01 8))
      l$i0$eth_sold@2071@01)
    0))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 562 | $struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 < 0 | dead]
; [else-branch: 562 | !($struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 < 0) | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 562 | !($struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 < 0)]
(assert (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@2068@01 8))
      l$i0$eth_sold@2071@01)
    0)))
(pop) ; 6
; [eval] !(($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0)
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold < 0
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 6
(set-option :timeout 10)
(assert (not (<
  (- ($struct_get<Int> ($struct_loc<Int> self@2068@01 8)) l$i0$eth_sold@2071@01)
  0)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@2068@01 8))
      l$i0$eth_sold@2071@01)
    0))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 563 | !($struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 < 0) | live]
; [else-branch: 563 | $struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 < 0 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 563 | !($struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 < 0)]
(assert (not
  (<
    (-
      ($struct_get<Int> ($struct_loc<Int> self@2068@01 8))
      l$i0$eth_sold@2071@01)
    0)))
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@2068@01 8))
      l$i0$eth_sold@2071@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 564 | $struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 564 | !($struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 564 | !($struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@2068@01 8))
      l$i0$eth_sold@2071@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 7
; [eval] !(($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(push) ; 7
(set-option :timeout 10)
(assert (not (>
  (- ($struct_get<Int> ($struct_loc<Int> self@2068@01 8)) l$i0$eth_sold@2071@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@2068@01 8))
      l$i0$eth_sold@2071@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 565 | !($struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 565 | $struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 565 | !($struct_get[Int]($struct_loc[Int](self@2068@01, 8)) - l$i0$eth_sold@2071@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (-
      ($struct_get<Int> ($struct_loc<Int> self@2068@01 8))
      l$i0$eth_sold@2071@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$input_amount := l$i0$eth_sold
; [exec]
; l$i2$input_reserve := ($struct_get($struct_loc(self, 8)): Int) -
;   l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int) - l$i0$eth_sold
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const l$i2$input_reserve@2152@01 Int)
(assert (=
  l$i2$input_reserve@2152@01
  (- ($struct_get<Int> ($struct_loc<Int> self@2068@01 8)) l$i0$eth_sold@2071@01)))
; [exec]
; l$i2$output_reserve := l$i0$token_reserve
; [eval] !(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)
; [eval] l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0
; [eval] l$i2$input_reserve > 0
(push) ; 8
; [then-branch: 566 | !(l$i2$input_reserve@2152@01 > 0) | live]
; [else-branch: 566 | l$i2$input_reserve@2152@01 > 0 | live]
(push) ; 9
; [then-branch: 566 | !(l$i2$input_reserve@2152@01 > 0)]
(assert (not (> l$i2$input_reserve@2152@01 0)))
(pop) ; 9
(push) ; 9
; [else-branch: 566 | l$i2$input_reserve@2152@01 > 0]
(assert (> l$i2$input_reserve@2152@01 0))
; [eval] $unwrap(l$i2$output_reserve) > 0
; [eval] $unwrap(l$i2$output_reserve)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or (> l$i2$input_reserve@2152@01 0) (not (> l$i2$input_reserve@2152@01 0))))
(push) ; 8
(set-option :timeout 10)
(assert (not (and
  (> l$i2$input_reserve@2152@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@2151@01) 0))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not
  (and
    (> l$i2$input_reserve@2152@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@2151@01) 0)))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 567 | !(l$i2$input_reserve@2152@01 > 0 && $unwrap[Int](l$i0$token_reserve@2151@01) > 0) | live]
; [else-branch: 567 | l$i2$input_reserve@2152@01 > 0 && $unwrap[Int](l$i0$token_reserve@2151@01) > 0 | live]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 567 | !(l$i2$input_reserve@2152@01 > 0 && $unwrap[Int](l$i0$token_reserve@2151@01) > 0)]
(assert (not
  (and
    (> l$i2$input_reserve@2152@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@2151@01) 0))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 9
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 568 | True | live]
; [else-branch: 568 | False | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 568 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@2153@01 $Snap)
(assert (= $t@2153@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@2021@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@2154@01 $Struct)
(assert (=
  self@2154@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    l$havoc$1@2021@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 9
; [then-branch: 569 | False | dead]
; [else-branch: 569 | True | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 569 | True]
(pop) ; 9
(pop) ; 8
(push) ; 8
; [else-branch: 567 | l$i2$input_reserve@2152@01 > 0 && $unwrap[Int](l$i0$token_reserve@2151@01) > 0]
(assert (and
  (> l$i2$input_reserve@2152@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@2151@01) 0)))
(pop) ; 8
; [eval] !!(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)
; [eval] !(l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0)
; [eval] l$i2$input_reserve > 0 && $unwrap(l$i2$output_reserve) > 0
; [eval] l$i2$input_reserve > 0
(push) ; 8
; [then-branch: 570 | !(l$i2$input_reserve@2152@01 > 0) | live]
; [else-branch: 570 | l$i2$input_reserve@2152@01 > 0 | live]
(push) ; 9
; [then-branch: 570 | !(l$i2$input_reserve@2152@01 > 0)]
(assert (not (> l$i2$input_reserve@2152@01 0)))
(pop) ; 9
(push) ; 9
; [else-branch: 570 | l$i2$input_reserve@2152@01 > 0]
(assert (> l$i2$input_reserve@2152@01 0))
; [eval] $unwrap(l$i2$output_reserve) > 0
; [eval] $unwrap(l$i2$output_reserve)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
(set-option :timeout 10)
(assert (not (not
  (and
    (> l$i2$input_reserve@2152@01 0)
    (> ($unwrap<Int> l$i0$token_reserve@2151@01) 0)))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (and
  (> l$i2$input_reserve@2152@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@2151@01) 0))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 571 | l$i2$input_reserve@2152@01 > 0 && $unwrap[Int](l$i0$token_reserve@2151@01) > 0 | live]
; [else-branch: 571 | !(l$i2$input_reserve@2152@01 > 0 && $unwrap[Int](l$i0$token_reserve@2151@01) > 0) | live]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 571 | l$i2$input_reserve@2152@01 > 0 && $unwrap[Int](l$i0$token_reserve@2151@01) > 0]
(assert (and
  (> l$i2$input_reserve@2152@01 0)
  (> ($unwrap<Int> l$i0$token_reserve@2151@01) 0)))
; [eval] l$i2$input_amount * 997 < 0
; [eval] l$i2$input_amount * 997
(push) ; 9
(set-option :timeout 10)
(assert (not (not (< (* l$i0$eth_sold@2071@01 997) 0))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 572 | l$i0$eth_sold@2071@01 * 997 < 0 | dead]
; [else-branch: 572 | !(l$i0$eth_sold@2071@01 * 997 < 0) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 572 | !(l$i0$eth_sold@2071@01 * 997 < 0)]
(assert (not (< (* l$i0$eth_sold@2071@01 997) 0)))
(pop) ; 9
; [eval] !(l$i2$input_amount * 997 < 0)
; [eval] l$i2$input_amount * 997 < 0
; [eval] l$i2$input_amount * 997
(push) ; 9
(set-option :timeout 10)
(assert (not (< (* l$i0$eth_sold@2071@01 997) 0)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not (< (* l$i0$eth_sold@2071@01 997) 0))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 573 | !(l$i0$eth_sold@2071@01 * 997 < 0) | live]
; [else-branch: 573 | l$i0$eth_sold@2071@01 * 997 < 0 | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 573 | !(l$i0$eth_sold@2071@01 * 997 < 0)]
(assert (not (< (* l$i0$eth_sold@2071@01 997) 0)))
; [eval] l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount * 997
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i0$eth_sold@2071@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (>
  (* l$i0$eth_sold@2071@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 574 | l$i0$eth_sold@2071@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 574 | !(l$i0$eth_sold@2071@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 574 | l$i0$eth_sold@2071@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (* l$i0$eth_sold@2071@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 11
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 575 | True | live]
; [else-branch: 575 | False | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 575 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@2155@01 $Snap)
(assert (= $t@2155@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@2021@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@2156@01 $Struct)
(assert (=
  self@2156@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    l$havoc$1@2021@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 11
; [then-branch: 576 | False | dead]
; [else-branch: 576 | True | live]
(set-option :timeout 0)
(push) ; 11
; [else-branch: 576 | True]
(pop) ; 11
(pop) ; 10
(push) ; 10
; [else-branch: 574 | !(l$i0$eth_sold@2071@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i0$eth_sold@2071@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 10
; [eval] !(l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_amount * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount * 997
(push) ; 10
(set-option :timeout 10)
(assert (not (>
  (* l$i0$eth_sold@2071@01 997)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i0$eth_sold@2071@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 577 | !(l$i0$eth_sold@2071@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 577 | l$i0$eth_sold@2071@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 577 | !(l$i0$eth_sold@2071@01 * 997 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i0$eth_sold@2071@01 997)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$input_amount_with_fee := l$i2$input_amount * 997
; [eval] l$i2$input_amount * 997
(declare-const l$i2$input_amount_with_fee@2157@01 Int)
(assert (= l$i2$input_amount_with_fee@2157@01 (* l$i0$eth_sold@2071@01 997)))
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 11
(set-option :timeout 10)
(assert (not (not
  (<
    (*
      l$i2$input_amount_with_fee@2157@01
      ($unwrap<Int> l$i0$token_reserve@2151@01))
    0))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 578 | l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) < 0 | dead]
; [else-branch: 578 | !(l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) < 0) | live]
(set-option :timeout 0)
(push) ; 11
; [else-branch: 578 | !(l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) < 0)]
(assert (not
  (<
    (*
      l$i2$input_amount_with_fee@2157@01
      ($unwrap<Int> l$i0$token_reserve@2151@01))
    0)))
(pop) ; 11
; [eval] !(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0)
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) < 0
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 11
(set-option :timeout 10)
(assert (not (<
  (*
    l$i2$input_amount_with_fee@2157@01
    ($unwrap<Int> l$i0$token_reserve@2151@01))
  0)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (not
  (<
    (*
      l$i2$input_amount_with_fee@2157@01
      ($unwrap<Int> l$i0$token_reserve@2151@01))
    0))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 579 | !(l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) < 0) | live]
; [else-branch: 579 | l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) < 0 | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 579 | !(l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) < 0)]
(assert (not
  (<
    (*
      l$i2$input_amount_with_fee@2157@01
      ($unwrap<Int> l$i0$token_reserve@2151@01))
    0)))
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 12
(set-option :timeout 10)
(assert (not (not
  (>
    (*
      l$i2$input_amount_with_fee@2157@01
      ($unwrap<Int> l$i0$token_reserve@2151@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (>
  (*
    l$i2$input_amount_with_fee@2157@01
    ($unwrap<Int> l$i0$token_reserve@2151@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 580 | l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 580 | !(l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 580 | l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (*
    l$i2$input_amount_with_fee@2157@01
    ($unwrap<Int> l$i0$token_reserve@2151@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 13
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 581 | True | live]
; [else-branch: 581 | False | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 581 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@2158@01 $Snap)
(assert (= $t@2158@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@2021@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@2159@01 $Struct)
(assert (=
  self@2159@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    l$havoc$1@2021@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 13
; [then-branch: 582 | False | dead]
; [else-branch: 582 | True | live]
(set-option :timeout 0)
(push) ; 13
; [else-branch: 582 | True]
(pop) ; 13
(pop) ; 12
(push) ; 12
; [else-branch: 580 | !(l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (*
      l$i2$input_amount_with_fee@2157@01
      ($unwrap<Int> l$i0$token_reserve@2151@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 12
; [eval] !(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(push) ; 12
(set-option :timeout 10)
(assert (not (>
  (*
    l$i2$input_amount_with_fee@2157@01
    ($unwrap<Int> l$i0$token_reserve@2151@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (not
  (>
    (*
      l$i2$input_amount_with_fee@2157@01
      ($unwrap<Int> l$i0$token_reserve@2151@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 583 | !(l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 583 | l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 583 | !(l$i2$input_amount_with_fee@2157@01 * $unwrap[Int](l$i0$token_reserve@2151@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (*
      l$i2$input_amount_with_fee@2157@01
      ($unwrap<Int> l$i0$token_reserve@2151@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$numerator := $wrap(l$i2$input_amount_with_fee *
;   $unwrap(l$i2$output_reserve))
; [eval] $wrap(l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve))
; [eval] l$i2$input_amount_with_fee * $unwrap(l$i2$output_reserve)
; [eval] $unwrap(l$i2$output_reserve)
(declare-const l$i2$numerator@2160@01 $Int)
(assert (=
  l$i2$numerator@2160@01
  ($wrap<$Int> (*
    l$i2$input_amount_with_fee@2157@01
    ($unwrap<Int> l$i0$token_reserve@2151@01)))))
; [eval] l$i2$input_reserve * 1000 < 0
; [eval] l$i2$input_reserve * 1000
(push) ; 13
(set-option :timeout 10)
(assert (not (not (< (* l$i2$input_reserve@2152@01 1000) 0))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 584 | l$i2$input_reserve@2152@01 * 1000 < 0 | dead]
; [else-branch: 584 | !(l$i2$input_reserve@2152@01 * 1000 < 0) | live]
(set-option :timeout 0)
(push) ; 13
; [else-branch: 584 | !(l$i2$input_reserve@2152@01 * 1000 < 0)]
(assert (not (< (* l$i2$input_reserve@2152@01 1000) 0)))
(pop) ; 13
; [eval] !(l$i2$input_reserve * 1000 < 0)
; [eval] l$i2$input_reserve * 1000 < 0
; [eval] l$i2$input_reserve * 1000
(push) ; 13
(set-option :timeout 10)
(assert (not (< (* l$i2$input_reserve@2152@01 1000) 0)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (not (< (* l$i2$input_reserve@2152@01 1000) 0))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 585 | !(l$i2$input_reserve@2152@01 * 1000 < 0) | live]
; [else-branch: 585 | l$i2$input_reserve@2152@01 * 1000 < 0 | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 585 | !(l$i2$input_reserve@2152@01 * 1000 < 0)]
(assert (not (< (* l$i2$input_reserve@2152@01 1000) 0)))
; [eval] l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i2$input_reserve@2152@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (>
  (* l$i2$input_reserve@2152@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 586 | l$i2$input_reserve@2152@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 586 | !(l$i2$input_reserve@2152@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 586 | l$i2$input_reserve@2152@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (* l$i2$input_reserve@2152@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 15
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 587 | True | live]
; [else-branch: 587 | False | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 587 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@2161@01 $Snap)
(assert (= $t@2161@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@2021@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@2162@01 $Struct)
(assert (=
  self@2162@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    l$havoc$1@2021@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 15
; [then-branch: 588 | False | dead]
; [else-branch: 588 | True | live]
(set-option :timeout 0)
(push) ; 15
; [else-branch: 588 | True]
(pop) ; 15
(pop) ; 14
(push) ; 14
; [else-branch: 586 | !(l$i2$input_reserve@2152@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i2$input_reserve@2152@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 14
; [eval] !(l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_reserve * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000
(push) ; 14
(set-option :timeout 10)
(assert (not (>
  (* l$i2$input_reserve@2152@01 1000)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (>
    (* l$i2$input_reserve@2152@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 589 | !(l$i2$input_reserve@2152@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 589 | l$i2$input_reserve@2152@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 589 | !(l$i2$input_reserve@2152@01 * 1000 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (* l$i2$input_reserve@2152@01 1000)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 15
(set-option :timeout 10)
(assert (not (not
  (<
    (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
    0))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 590 | l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 < 0 | dead]
; [else-branch: 590 | !(l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 < 0) | live]
(set-option :timeout 0)
(push) ; 15
; [else-branch: 590 | !(l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 < 0)]
(assert (not
  (<
    (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
    0)))
(pop) ; 15
; [eval] !(l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0)
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee < 0
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 15
(set-option :timeout 10)
(assert (not (< (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01) 0)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (not
  (<
    (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
    0))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 591 | !(l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 < 0) | live]
; [else-branch: 591 | l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 < 0 | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 591 | !(l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 < 0)]
(assert (not
  (<
    (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
    0)))
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 16
(set-option :timeout 10)
(assert (not (not
  (>
    (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (>
  (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 592 | l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
; [else-branch: 592 | !(l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 592 | l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935]
(assert (>
  (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; [exec]
; $overflow := true
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 17
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 593 | True | live]
; [else-branch: 593 | False | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 593 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@2163@01 $Snap)
(assert (= $t@2163@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@2021@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@2164@01 $Struct)
(assert (=
  self@2164@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    l$havoc$1@2021@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 17
; [then-branch: 594 | False | dead]
; [else-branch: 594 | True | live]
(set-option :timeout 0)
(push) ; 17
; [else-branch: 594 | True]
(pop) ; 17
(pop) ; 16
(push) ; 16
; [else-branch: 592 | !(l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 16
; [eval] !(l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(push) ; 16
(set-option :timeout 10)
(assert (not (>
  (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not
  (>
    (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 595 | !(l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 595 | l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | live]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 595 | !(l$i2$input_reserve@2152@01 * 1000 + l$i2$input_amount_with_fee@2157@01 > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; l$i2$denominator := l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000 + l$i2$input_amount_with_fee
; [eval] l$i2$input_reserve * 1000
(declare-const l$i2$denominator@2165@01 Int)
(assert (=
  l$i2$denominator@2165@01
  (+ (* l$i2$input_reserve@2152@01 1000) l$i2$input_amount_with_fee@2157@01)))
; [eval] l$i2$denominator == 0
(push) ; 17
(set-option :timeout 10)
(assert (not (not (= l$i2$denominator@2165@01 0))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 596 | l$i2$denominator@2165@01 == 0 | dead]
; [else-branch: 596 | l$i2$denominator@2165@01 != 0 | live]
(set-option :timeout 0)
(push) ; 17
; [else-branch: 596 | l$i2$denominator@2165@01 != 0]
(assert (not (= l$i2$denominator@2165@01 0)))
(pop) ; 17
; [eval] !(l$i2$denominator == 0)
; [eval] l$i2$denominator == 0
(push) ; 17
(set-option :timeout 10)
(assert (not (= l$i2$denominator@2165@01 0)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (not (= l$i2$denominator@2165@01 0))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 597 | l$i2$denominator@2165@01 != 0 | live]
; [else-branch: 597 | l$i2$denominator@2165@01 == 0 | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 597 | l$i2$denominator@2165@01 != 0]
(assert (not (= l$i2$denominator@2165@01 0)))
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) < 0
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
      ($unwrap<Int> l$i2$numerator@2160@01)
      l$i2$denominator@2165@01))
    0))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 598 | $div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) < 0 | dead]
; [else-branch: 598 | !($div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) < 0) | live]
(set-option :timeout 0)
(push) ; 18
; [else-branch: 598 | !($div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) < 0)]
(assert (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
      ($unwrap<Int> l$i2$numerator@2160@01)
      l$i2$denominator@2165@01))
    0)))
(pop) ; 18
; [eval] !($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) < 0)
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) < 0
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 18
(set-option :timeout 10)
(assert (not (<
  ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
    ($unwrap<Int> l$i2$numerator@2160@01)
    l$i2$denominator@2165@01))
  0)))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
      ($unwrap<Int> l$i2$numerator@2160@01)
      l$i2$denominator@2165@01))
    0))))
(check-sat)
; unsat
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
; [then-branch: 599 | !($div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) < 0) | live]
; [else-branch: 599 | $div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) < 0 | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 599 | !($div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) < 0)]
(assert (not
  (<
    ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
      ($unwrap<Int> l$i2$numerator@2160@01)
      l$i2$denominator@2165@01))
    0)))
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 19
(set-option :timeout 10)
(assert (not (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
      ($unwrap<Int> l$i2$numerator@2160@01)
      l$i2$denominator@2165@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 600 | $div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
; [else-branch: 600 | !($div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
(set-option :timeout 0)
(push) ; 19
; [else-branch: 600 | !($div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
      ($unwrap<Int> l$i2$numerator@2160@01)
      l$i2$denominator@2165@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(pop) ; 19
; [eval] !($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator) > 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(push) ; 19
(set-option :timeout 10)
(assert (not (>
  ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
    ($unwrap<Int> l$i2$numerator@2160@01)
    l$i2$denominator@2165@01))
  115792089237316195423570985008687907853269984665640564039457584007913129639935)))
(check-sat)
; unknown
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
      ($unwrap<Int> l$i2$numerator@2160@01)
      l$i2$denominator@2165@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 601 | !($div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935) | live]
; [else-branch: 601 | $div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935 | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 601 | !($div[Int]($unwrap[Int](l$i2$numerator@2160@01), l$i2$denominator@2165@01, $unwrap[Int](l$i2$numerator@2160@01) / l$i2$denominator@2165@01) > 115792089237316195423570985008687907853269984665640564039457584007913129639935)]
(assert (not
  (>
    ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
      ($unwrap<Int> l$i2$numerator@2160@01)
      l$i2$denominator@2165@01))
    115792089237316195423570985008687907853269984665640564039457584007913129639935)))
; [exec]
; i2$$res := $unwrap($wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \
;   l$i2$denominator)))
; [eval] $unwrap($wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)))
; [eval] $wrap($div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator))
; [eval] $div($unwrap(l$i2$numerator), l$i2$denominator, $unwrap(l$i2$numerator) \ l$i2$denominator)
; [eval] $unwrap(l$i2$numerator)
; [eval] $unwrap(l$i2$numerator) \ l$i2$denominator
; [eval] $unwrap(l$i2$numerator)
(declare-const i2$$res@2166@01 Int)
(assert (=
  i2$$res@2166@01
  ($unwrap<Int> ($wrap<$Int> ($div<Int> ($unwrap<Int> l$i2$numerator@2160@01) l$i2$denominator@2165@01 (div
    ($unwrap<Int> l$i2$numerator@2160@01)
    l$i2$denominator@2165@01))))))
; [exec]
; label i2$return
; [exec]
; l$i0$tokens_bought := $wrap(i2$$res)
; [eval] $wrap(i2$$res)
(declare-const l$i0$tokens_bought@2167@01 $Int)
(assert (= l$i0$tokens_bought@2167@01 ($wrap<$Int> i2$$res@2166@01)))
; [eval] !($unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens))
; [eval] $unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens)
; [eval] $unwrap(l$i0$tokens_bought)
; [eval] $unwrap(l$i0$min_tokens)
(push) ; 20
(set-option :timeout 10)
(assert (not (>=
  ($unwrap<Int> l$i0$tokens_bought@2167@01)
  ($unwrap<Int> l$min_tokens@1971@01))))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (not
  (>=
    ($unwrap<Int> l$i0$tokens_bought@2167@01)
    ($unwrap<Int> l$min_tokens@1971@01)))))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
; [then-branch: 602 | !($unwrap[Int](l$i0$tokens_bought@2167@01) >= $unwrap[Int](l$min_tokens@1971@01)) | live]
; [else-branch: 602 | $unwrap[Int](l$i0$tokens_bought@2167@01) >= $unwrap[Int](l$min_tokens@1971@01) | live]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 602 | !($unwrap[Int](l$i0$tokens_bought@2167@01) >= $unwrap[Int](l$min_tokens@1971@01))]
(assert (not
  (>=
    ($unwrap<Int> l$i0$tokens_bought@2167@01)
    ($unwrap<Int> l$min_tokens@1971@01))))
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(push) ; 21
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
; [then-branch: 603 | True | live]
; [else-branch: 603 | False | dead]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 603 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@2168@01 $Snap)
(assert (= $t@2168@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@2021@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@2169@01 $Struct)
(assert (=
  self@2169@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    l$havoc$1@2021@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 21
; [then-branch: 604 | False | dead]
; [else-branch: 604 | True | live]
(set-option :timeout 0)
(push) ; 21
; [else-branch: 604 | True]
(pop) ; 21
(pop) ; 20
(push) ; 20
; [else-branch: 602 | $unwrap[Int](l$i0$tokens_bought@2167@01) >= $unwrap[Int](l$min_tokens@1971@01)]
(assert (>=
  ($unwrap<Int> l$i0$tokens_bought@2167@01)
  ($unwrap<Int> l$min_tokens@1971@01)))
(pop) ; 20
; [eval] !!($unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens))
; [eval] !($unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens))
; [eval] $unwrap(l$i0$tokens_bought) >= $unwrap(l$i0$min_tokens)
; [eval] $unwrap(l$i0$tokens_bought)
; [eval] $unwrap(l$i0$min_tokens)
(push) ; 20
(set-option :timeout 10)
(assert (not (not
  (>=
    ($unwrap<Int> l$i0$tokens_bought@2167@01)
    ($unwrap<Int> l$min_tokens@1971@01)))))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (>=
  ($unwrap<Int> l$i0$tokens_bought@2167@01)
  ($unwrap<Int> l$min_tokens@1971@01))))
(check-sat)
; unknown
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
; [then-branch: 605 | $unwrap[Int](l$i0$tokens_bought@2167@01) >= $unwrap[Int](l$min_tokens@1971@01) | live]
; [else-branch: 605 | !($unwrap[Int](l$i0$tokens_bought@2167@01) >= $unwrap[Int](l$min_tokens@1971@01)) | live]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 605 | $unwrap[Int](l$i0$tokens_bought@2167@01) >= $unwrap[Int](l$min_tokens@1971@01)]
(assert (>=
  ($unwrap<Int> l$i0$tokens_bought@2167@01)
  ($unwrap<Int> l$min_tokens@1971@01)))
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$TokenPurchase($arg0, $arg1, $arg2) }
;     perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$TokenPurchase($arg0, $arg1, $arg2), perm(e$TokenPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@2170@01 Int)
(declare-const $arg1@2171@01 Int)
(declare-const $arg2@2172@01 Int)
(push) ; 21
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@2173@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef192|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef193|)))
(assert ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2170@01)
    ($SortWrappers.IntTo$Snap $arg1@2171@01))
  ($SortWrappers.IntTo$Snap $arg2@2172@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2170@01)
    ($SortWrappers.IntTo$Snap $arg1@2171@01))
  ($SortWrappers.IntTo$Snap $arg2@2172@01))))
(assert (>
  ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2170@01)
      ($SortWrappers.IntTo$Snap $arg1@2171@01))
    ($SortWrappers.IntTo$Snap $arg2@2172@01)))
  $Perm.No))
; [eval] perm(e$TokenPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 21
(declare-fun inv@2174@01 (Int Int Int) Int)
(declare-fun img@2175@01 (Int Int Int) Bool)
(declare-fun inv@2176@01 (Int Int Int) Int)
(declare-fun img@2177@01 (Int Int Int) Bool)
(declare-fun inv@2178@01 (Int Int Int) Int)
(declare-fun img@2179@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef192|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef193|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2170@01 Int) ($arg1@2171@01 Int) ($arg2@2172@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2170@01)
          ($SortWrappers.IntTo$Snap $arg1@2171@01))
        ($SortWrappers.IntTo$Snap $arg2@2172@01)))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2170@01)
        ($SortWrappers.IntTo$Snap $arg1@2171@01))
      ($SortWrappers.IntTo$Snap $arg2@2172@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2170@01)
        ($SortWrappers.IntTo$Snap $arg1@2171@01))
      ($SortWrappers.IntTo$Snap $arg2@2172@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2170@01)
      ($SortWrappers.IntTo$Snap $arg1@2171@01))
    ($SortWrappers.IntTo$Snap $arg2@2172@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2170@01)
      ($SortWrappers.IntTo$Snap $arg1@2171@01))
    ($SortWrappers.IntTo$Snap $arg2@2172@01))))
  :qid |e$TokenPurchase-aux|)))
(push) ; 21
(assert (not (forall (($arg0@2170@01 Int) ($arg1@2171@01 Int) ($arg2@2172@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2170@01)
          ($SortWrappers.IntTo$Snap $arg1@2171@01))
        ($SortWrappers.IntTo$Snap $arg2@2172@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2170@01)
            ($SortWrappers.IntTo$Snap $arg1@2171@01))
          ($SortWrappers.IntTo$Snap $arg2@2172@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2170@01)
            ($SortWrappers.IntTo$Snap $arg1@2171@01))
          ($SortWrappers.IntTo$Snap $arg2@2172@01))))))
  
  :qid |quant-u-1863|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 21
(assert (not (forall (($arg01@2170@01 Int) ($arg11@2171@01 Int) ($arg21@2172@01 Int) ($arg02@2170@01 Int) ($arg12@2171@01 Int) ($arg22@2172@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2170@01)
                ($SortWrappers.IntTo$Snap $arg11@2171@01))
              ($SortWrappers.IntTo$Snap $arg21@2172@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2170@01)
              ($SortWrappers.IntTo$Snap $arg11@2171@01))
            ($SortWrappers.IntTo$Snap $arg21@2172@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2170@01)
              ($SortWrappers.IntTo$Snap $arg11@2171@01))
            ($SortWrappers.IntTo$Snap $arg21@2172@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2170@01)
              ($SortWrappers.IntTo$Snap $arg11@2171@01))
            ($SortWrappers.IntTo$Snap $arg21@2172@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2170@01)
                ($SortWrappers.IntTo$Snap $arg12@2171@01))
              ($SortWrappers.IntTo$Snap $arg22@2172@01)))
            $Perm.No)
          ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2170@01)
              ($SortWrappers.IntTo$Snap $arg12@2171@01))
            ($SortWrappers.IntTo$Snap $arg22@2172@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2170@01)
              ($SortWrappers.IntTo$Snap $arg12@2171@01))
            ($SortWrappers.IntTo$Snap $arg22@2172@01))))
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2170@01)
              ($SortWrappers.IntTo$Snap $arg12@2171@01))
            ($SortWrappers.IntTo$Snap $arg22@2172@01)))))
      (and
        (and (= $arg01@2170@01 $arg02@2170@01) (= $arg11@2171@01 $arg12@2171@01))
        (= $arg21@2172@01 $arg22@2172@01)))
    (and
      (and (= $arg01@2170@01 $arg02@2170@01) (= $arg11@2171@01 $arg12@2171@01))
      (= $arg21@2172@01 $arg22@2172@01)))
  
  :qid |e$TokenPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2170@01 Int) ($arg1@2171@01 Int) ($arg2@2172@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2170@01)
            ($SortWrappers.IntTo$Snap $arg1@2171@01))
          ($SortWrappers.IntTo$Snap $arg2@2172@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2170@01)
            ($SortWrappers.IntTo$Snap $arg1@2171@01))
          ($SortWrappers.IntTo$Snap $arg2@2172@01)))))
    (and
      (and
        (= (inv@2174@01 $arg0@2170@01 $arg1@2171@01 $arg2@2172@01) $arg0@2170@01)
        (= (inv@2176@01 $arg0@2170@01 $arg1@2171@01 $arg2@2172@01) $arg1@2171@01)
        (= (inv@2178@01 $arg0@2170@01 $arg1@2171@01 $arg2@2172@01) $arg2@2172@01))
      (and
        (img@2175@01 $arg0@2170@01 $arg1@2171@01 $arg2@2172@01)
        (img@2177@01 $arg0@2170@01 $arg1@2171@01 $arg2@2172@01)
        (img@2179@01 $arg0@2170@01 $arg1@2171@01 $arg2@2172@01))))
  :pattern (($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2170@01)
      ($SortWrappers.IntTo$Snap $arg1@2171@01))
    ($SortWrappers.IntTo$Snap $arg2@2172@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2170@01)
      ($SortWrappers.IntTo$Snap $arg1@2171@01))
    ($SortWrappers.IntTo$Snap $arg2@2172@01))))
  :qid |e$TokenPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2175@01 $arg0 $arg1 $arg2)
        (img@2177@01 $arg0 $arg1 $arg2)
        (img@2179@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2174@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2176@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2178@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2174@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2176@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2178@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2174@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2176@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2178@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2174@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2176@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2178@01 $arg0 $arg1 $arg2))
  :qid |e$TokenPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2174@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2176@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2178@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$TokenPurchase ($PSF.lookup_e$TokenPurchase (as sm@2078@01  $PSF<e$TokenPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2174@01 $arg0 $arg1 $arg2) (inv@2176@01 $arg0 $arg1 $arg2) (inv@2178@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1864|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 21
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2174@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2176@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2178@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2175@01 $arg0 $arg1 $arg2)
        (img@2177@01 $arg0 $arg1 $arg2)
        (img@2179@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2174@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2176@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2178@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$TokenPurchase (as pm@2173@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2174@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2176@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2178@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1865|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$EthPurchase($arg0, $arg1, $arg2) }
;     perm(e$EthPurchase($arg0, $arg1, $arg2)) > none ==>
;     acc(e$EthPurchase($arg0, $arg1, $arg2), perm(e$EthPurchase($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@2180@01 Int)
(declare-const $arg1@2181@01 Int)
(declare-const $arg2@2182@01 Int)
(push) ; 21
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2)) > none
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@2183@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef194|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef195|)))
(assert ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2180@01)
    ($SortWrappers.IntTo$Snap $arg1@2181@01))
  ($SortWrappers.IntTo$Snap $arg2@2182@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2180@01)
    ($SortWrappers.IntTo$Snap $arg1@2181@01))
  ($SortWrappers.IntTo$Snap $arg2@2182@01))))
(assert (>
  ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2180@01)
      ($SortWrappers.IntTo$Snap $arg1@2181@01))
    ($SortWrappers.IntTo$Snap $arg2@2182@01)))
  $Perm.No))
; [eval] perm(e$EthPurchase($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 21
(declare-fun inv@2184@01 (Int Int Int) Int)
(declare-fun img@2185@01 (Int Int Int) Bool)
(declare-fun inv@2186@01 (Int Int Int) Int)
(declare-fun img@2187@01 (Int Int Int) Bool)
(declare-fun inv@2188@01 (Int Int Int) Int)
(declare-fun img@2189@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef194|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef195|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2180@01 Int) ($arg1@2181@01 Int) ($arg2@2182@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2180@01)
          ($SortWrappers.IntTo$Snap $arg1@2181@01))
        ($SortWrappers.IntTo$Snap $arg2@2182@01)))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2180@01)
        ($SortWrappers.IntTo$Snap $arg1@2181@01))
      ($SortWrappers.IntTo$Snap $arg2@2182@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2180@01)
        ($SortWrappers.IntTo$Snap $arg1@2181@01))
      ($SortWrappers.IntTo$Snap $arg2@2182@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2180@01)
      ($SortWrappers.IntTo$Snap $arg1@2181@01))
    ($SortWrappers.IntTo$Snap $arg2@2182@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2180@01)
      ($SortWrappers.IntTo$Snap $arg1@2181@01))
    ($SortWrappers.IntTo$Snap $arg2@2182@01))))
  :qid |e$EthPurchase-aux|)))
(push) ; 21
(assert (not (forall (($arg0@2180@01 Int) ($arg1@2181@01 Int) ($arg2@2182@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2180@01)
          ($SortWrappers.IntTo$Snap $arg1@2181@01))
        ($SortWrappers.IntTo$Snap $arg2@2182@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2180@01)
            ($SortWrappers.IntTo$Snap $arg1@2181@01))
          ($SortWrappers.IntTo$Snap $arg2@2182@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2180@01)
            ($SortWrappers.IntTo$Snap $arg1@2181@01))
          ($SortWrappers.IntTo$Snap $arg2@2182@01))))))
  
  :qid |quant-u-1866|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 21
(assert (not (forall (($arg01@2180@01 Int) ($arg11@2181@01 Int) ($arg21@2182@01 Int) ($arg02@2180@01 Int) ($arg12@2181@01 Int) ($arg22@2182@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2180@01)
                ($SortWrappers.IntTo$Snap $arg11@2181@01))
              ($SortWrappers.IntTo$Snap $arg21@2182@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2180@01)
              ($SortWrappers.IntTo$Snap $arg11@2181@01))
            ($SortWrappers.IntTo$Snap $arg21@2182@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2180@01)
              ($SortWrappers.IntTo$Snap $arg11@2181@01))
            ($SortWrappers.IntTo$Snap $arg21@2182@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2180@01)
              ($SortWrappers.IntTo$Snap $arg11@2181@01))
            ($SortWrappers.IntTo$Snap $arg21@2182@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2180@01)
                ($SortWrappers.IntTo$Snap $arg12@2181@01))
              ($SortWrappers.IntTo$Snap $arg22@2182@01)))
            $Perm.No)
          ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2180@01)
              ($SortWrappers.IntTo$Snap $arg12@2181@01))
            ($SortWrappers.IntTo$Snap $arg22@2182@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2180@01)
              ($SortWrappers.IntTo$Snap $arg12@2181@01))
            ($SortWrappers.IntTo$Snap $arg22@2182@01))))
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2180@01)
              ($SortWrappers.IntTo$Snap $arg12@2181@01))
            ($SortWrappers.IntTo$Snap $arg22@2182@01)))))
      (and
        (and (= $arg01@2180@01 $arg02@2180@01) (= $arg11@2181@01 $arg12@2181@01))
        (= $arg21@2182@01 $arg22@2182@01)))
    (and
      (and (= $arg01@2180@01 $arg02@2180@01) (= $arg11@2181@01 $arg12@2181@01))
      (= $arg21@2182@01 $arg22@2182@01)))
  
  :qid |e$EthPurchase-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2180@01 Int) ($arg1@2181@01 Int) ($arg2@2182@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2180@01)
            ($SortWrappers.IntTo$Snap $arg1@2181@01))
          ($SortWrappers.IntTo$Snap $arg2@2182@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2180@01)
            ($SortWrappers.IntTo$Snap $arg1@2181@01))
          ($SortWrappers.IntTo$Snap $arg2@2182@01)))))
    (and
      (and
        (= (inv@2184@01 $arg0@2180@01 $arg1@2181@01 $arg2@2182@01) $arg0@2180@01)
        (= (inv@2186@01 $arg0@2180@01 $arg1@2181@01 $arg2@2182@01) $arg1@2181@01)
        (= (inv@2188@01 $arg0@2180@01 $arg1@2181@01 $arg2@2182@01) $arg2@2182@01))
      (and
        (img@2185@01 $arg0@2180@01 $arg1@2181@01 $arg2@2182@01)
        (img@2187@01 $arg0@2180@01 $arg1@2181@01 $arg2@2182@01)
        (img@2189@01 $arg0@2180@01 $arg1@2181@01 $arg2@2182@01))))
  :pattern (($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2180@01)
      ($SortWrappers.IntTo$Snap $arg1@2181@01))
    ($SortWrappers.IntTo$Snap $arg2@2182@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2180@01)
      ($SortWrappers.IntTo$Snap $arg1@2181@01))
    ($SortWrappers.IntTo$Snap $arg2@2182@01))))
  :qid |e$EthPurchase-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2185@01 $arg0 $arg1 $arg2)
        (img@2187@01 $arg0 $arg1 $arg2)
        (img@2189@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2184@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2186@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2188@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2184@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2186@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2188@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2184@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2186@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2188@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2184@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2186@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2188@01 $arg0 $arg1 $arg2))
  :qid |e$EthPurchase-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2184@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2186@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2188@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$EthPurchase ($PSF.lookup_e$EthPurchase (as sm@2090@01  $PSF<e$EthPurchase>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2184@01 $arg0 $arg1 $arg2) (inv@2186@01 $arg0 $arg1 $arg2) (inv@2188@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1867|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 21
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2184@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2186@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2188@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2185@01 $arg0 $arg1 $arg2)
        (img@2187@01 $arg0 $arg1 $arg2)
        (img@2189@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2184@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2186@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2188@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$EthPurchase (as pm@2183@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2184@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2186@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2188@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1868|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$AddLiquidity($arg0, $arg1, $arg2) }
;     perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$AddLiquidity($arg0, $arg1, $arg2), perm(e$AddLiquidity($arg0, $arg1,
;     $arg2))))
(declare-const $arg0@2190@01 Int)
(declare-const $arg1@2191@01 Int)
(declare-const $arg2@2192@01 Int)
(push) ; 21
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@2193@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef196|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef197|)))
(assert ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2190@01)
    ($SortWrappers.IntTo$Snap $arg1@2191@01))
  ($SortWrappers.IntTo$Snap $arg2@2192@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2190@01)
    ($SortWrappers.IntTo$Snap $arg1@2191@01))
  ($SortWrappers.IntTo$Snap $arg2@2192@01))))
(assert (>
  ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2190@01)
      ($SortWrappers.IntTo$Snap $arg1@2191@01))
    ($SortWrappers.IntTo$Snap $arg2@2192@01)))
  $Perm.No))
; [eval] perm(e$AddLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 21
(declare-fun inv@2194@01 (Int Int Int) Int)
(declare-fun img@2195@01 (Int Int Int) Bool)
(declare-fun inv@2196@01 (Int Int Int) Int)
(declare-fun img@2197@01 (Int Int Int) Bool)
(declare-fun inv@2198@01 (Int Int Int) Int)
(declare-fun img@2199@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef196|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef197|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2190@01 Int) ($arg1@2191@01 Int) ($arg2@2192@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2190@01)
          ($SortWrappers.IntTo$Snap $arg1@2191@01))
        ($SortWrappers.IntTo$Snap $arg2@2192@01)))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2190@01)
        ($SortWrappers.IntTo$Snap $arg1@2191@01))
      ($SortWrappers.IntTo$Snap $arg2@2192@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2190@01)
        ($SortWrappers.IntTo$Snap $arg1@2191@01))
      ($SortWrappers.IntTo$Snap $arg2@2192@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2190@01)
      ($SortWrappers.IntTo$Snap $arg1@2191@01))
    ($SortWrappers.IntTo$Snap $arg2@2192@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2190@01)
      ($SortWrappers.IntTo$Snap $arg1@2191@01))
    ($SortWrappers.IntTo$Snap $arg2@2192@01))))
  :qid |e$AddLiquidity-aux|)))
(push) ; 21
(assert (not (forall (($arg0@2190@01 Int) ($arg1@2191@01 Int) ($arg2@2192@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2190@01)
          ($SortWrappers.IntTo$Snap $arg1@2191@01))
        ($SortWrappers.IntTo$Snap $arg2@2192@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2190@01)
            ($SortWrappers.IntTo$Snap $arg1@2191@01))
          ($SortWrappers.IntTo$Snap $arg2@2192@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2190@01)
            ($SortWrappers.IntTo$Snap $arg1@2191@01))
          ($SortWrappers.IntTo$Snap $arg2@2192@01))))))
  
  :qid |quant-u-1869|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 21
(assert (not (forall (($arg01@2190@01 Int) ($arg11@2191@01 Int) ($arg21@2192@01 Int) ($arg02@2190@01 Int) ($arg12@2191@01 Int) ($arg22@2192@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2190@01)
                ($SortWrappers.IntTo$Snap $arg11@2191@01))
              ($SortWrappers.IntTo$Snap $arg21@2192@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2190@01)
              ($SortWrappers.IntTo$Snap $arg11@2191@01))
            ($SortWrappers.IntTo$Snap $arg21@2192@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2190@01)
              ($SortWrappers.IntTo$Snap $arg11@2191@01))
            ($SortWrappers.IntTo$Snap $arg21@2192@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2190@01)
              ($SortWrappers.IntTo$Snap $arg11@2191@01))
            ($SortWrappers.IntTo$Snap $arg21@2192@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2190@01)
                ($SortWrappers.IntTo$Snap $arg12@2191@01))
              ($SortWrappers.IntTo$Snap $arg22@2192@01)))
            $Perm.No)
          ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2190@01)
              ($SortWrappers.IntTo$Snap $arg12@2191@01))
            ($SortWrappers.IntTo$Snap $arg22@2192@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2190@01)
              ($SortWrappers.IntTo$Snap $arg12@2191@01))
            ($SortWrappers.IntTo$Snap $arg22@2192@01))))
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2190@01)
              ($SortWrappers.IntTo$Snap $arg12@2191@01))
            ($SortWrappers.IntTo$Snap $arg22@2192@01)))))
      (and
        (and (= $arg01@2190@01 $arg02@2190@01) (= $arg11@2191@01 $arg12@2191@01))
        (= $arg21@2192@01 $arg22@2192@01)))
    (and
      (and (= $arg01@2190@01 $arg02@2190@01) (= $arg11@2191@01 $arg12@2191@01))
      (= $arg21@2192@01 $arg22@2192@01)))
  
  :qid |e$AddLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2190@01 Int) ($arg1@2191@01 Int) ($arg2@2192@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2190@01)
            ($SortWrappers.IntTo$Snap $arg1@2191@01))
          ($SortWrappers.IntTo$Snap $arg2@2192@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2190@01)
            ($SortWrappers.IntTo$Snap $arg1@2191@01))
          ($SortWrappers.IntTo$Snap $arg2@2192@01)))))
    (and
      (and
        (= (inv@2194@01 $arg0@2190@01 $arg1@2191@01 $arg2@2192@01) $arg0@2190@01)
        (= (inv@2196@01 $arg0@2190@01 $arg1@2191@01 $arg2@2192@01) $arg1@2191@01)
        (= (inv@2198@01 $arg0@2190@01 $arg1@2191@01 $arg2@2192@01) $arg2@2192@01))
      (and
        (img@2195@01 $arg0@2190@01 $arg1@2191@01 $arg2@2192@01)
        (img@2197@01 $arg0@2190@01 $arg1@2191@01 $arg2@2192@01)
        (img@2199@01 $arg0@2190@01 $arg1@2191@01 $arg2@2192@01))))
  :pattern (($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2190@01)
      ($SortWrappers.IntTo$Snap $arg1@2191@01))
    ($SortWrappers.IntTo$Snap $arg2@2192@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2190@01)
      ($SortWrappers.IntTo$Snap $arg1@2191@01))
    ($SortWrappers.IntTo$Snap $arg2@2192@01))))
  :qid |e$AddLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2195@01 $arg0 $arg1 $arg2)
        (img@2197@01 $arg0 $arg1 $arg2)
        (img@2199@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2194@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2196@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2198@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2194@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2196@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2198@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2194@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2196@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2198@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2194@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2196@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2198@01 $arg0 $arg1 $arg2))
  :qid |e$AddLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2194@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2196@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2198@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$AddLiquidity ($PSF.lookup_e$AddLiquidity (as sm@2102@01  $PSF<e$AddLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2194@01 $arg0 $arg1 $arg2) (inv@2196@01 $arg0 $arg1 $arg2) (inv@2198@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1870|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 21
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2194@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2196@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2198@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2195@01 $arg0 $arg1 $arg2)
        (img@2197@01 $arg0 $arg1 $arg2)
        (img@2199@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2194@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2196@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2198@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$AddLiquidity (as pm@2193@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2194@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2196@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2198@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1871|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$RemoveLiquidity($arg0, $arg1, $arg2) }
;     perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none ==>
;     acc(e$RemoveLiquidity($arg0, $arg1, $arg2), perm(e$RemoveLiquidity($arg0,
;     $arg1, $arg2))))
(declare-const $arg0@2200@01 Int)
(declare-const $arg1@2201@01 Int)
(declare-const $arg2@2202@01 Int)
(push) ; 21
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2)) > none
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@2203@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef198|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef199|)))
(assert ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2200@01)
    ($SortWrappers.IntTo$Snap $arg1@2201@01))
  ($SortWrappers.IntTo$Snap $arg2@2202@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2200@01)
    ($SortWrappers.IntTo$Snap $arg1@2201@01))
  ($SortWrappers.IntTo$Snap $arg2@2202@01))))
(assert (>
  ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2200@01)
      ($SortWrappers.IntTo$Snap $arg1@2201@01))
    ($SortWrappers.IntTo$Snap $arg2@2202@01)))
  $Perm.No))
; [eval] perm(e$RemoveLiquidity($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 21
(declare-fun inv@2204@01 (Int Int Int) Int)
(declare-fun img@2205@01 (Int Int Int) Bool)
(declare-fun inv@2206@01 (Int Int Int) Int)
(declare-fun img@2207@01 (Int Int Int) Bool)
(declare-fun inv@2208@01 (Int Int Int) Int)
(declare-fun img@2209@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef198|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef199|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2200@01 Int) ($arg1@2201@01 Int) ($arg2@2202@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2200@01)
          ($SortWrappers.IntTo$Snap $arg1@2201@01))
        ($SortWrappers.IntTo$Snap $arg2@2202@01)))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2200@01)
        ($SortWrappers.IntTo$Snap $arg1@2201@01))
      ($SortWrappers.IntTo$Snap $arg2@2202@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2200@01)
        ($SortWrappers.IntTo$Snap $arg1@2201@01))
      ($SortWrappers.IntTo$Snap $arg2@2202@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2200@01)
      ($SortWrappers.IntTo$Snap $arg1@2201@01))
    ($SortWrappers.IntTo$Snap $arg2@2202@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2200@01)
      ($SortWrappers.IntTo$Snap $arg1@2201@01))
    ($SortWrappers.IntTo$Snap $arg2@2202@01))))
  :qid |e$RemoveLiquidity-aux|)))
(push) ; 21
(assert (not (forall (($arg0@2200@01 Int) ($arg1@2201@01 Int) ($arg2@2202@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2200@01)
          ($SortWrappers.IntTo$Snap $arg1@2201@01))
        ($SortWrappers.IntTo$Snap $arg2@2202@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2200@01)
            ($SortWrappers.IntTo$Snap $arg1@2201@01))
          ($SortWrappers.IntTo$Snap $arg2@2202@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2200@01)
            ($SortWrappers.IntTo$Snap $arg1@2201@01))
          ($SortWrappers.IntTo$Snap $arg2@2202@01))))))
  
  :qid |quant-u-1872|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 21
(assert (not (forall (($arg01@2200@01 Int) ($arg11@2201@01 Int) ($arg21@2202@01 Int) ($arg02@2200@01 Int) ($arg12@2201@01 Int) ($arg22@2202@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2200@01)
                ($SortWrappers.IntTo$Snap $arg11@2201@01))
              ($SortWrappers.IntTo$Snap $arg21@2202@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2200@01)
              ($SortWrappers.IntTo$Snap $arg11@2201@01))
            ($SortWrappers.IntTo$Snap $arg21@2202@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2200@01)
              ($SortWrappers.IntTo$Snap $arg11@2201@01))
            ($SortWrappers.IntTo$Snap $arg21@2202@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2200@01)
              ($SortWrappers.IntTo$Snap $arg11@2201@01))
            ($SortWrappers.IntTo$Snap $arg21@2202@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2200@01)
                ($SortWrappers.IntTo$Snap $arg12@2201@01))
              ($SortWrappers.IntTo$Snap $arg22@2202@01)))
            $Perm.No)
          ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2200@01)
              ($SortWrappers.IntTo$Snap $arg12@2201@01))
            ($SortWrappers.IntTo$Snap $arg22@2202@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2200@01)
              ($SortWrappers.IntTo$Snap $arg12@2201@01))
            ($SortWrappers.IntTo$Snap $arg22@2202@01))))
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2200@01)
              ($SortWrappers.IntTo$Snap $arg12@2201@01))
            ($SortWrappers.IntTo$Snap $arg22@2202@01)))))
      (and
        (and (= $arg01@2200@01 $arg02@2200@01) (= $arg11@2201@01 $arg12@2201@01))
        (= $arg21@2202@01 $arg22@2202@01)))
    (and
      (and (= $arg01@2200@01 $arg02@2200@01) (= $arg11@2201@01 $arg12@2201@01))
      (= $arg21@2202@01 $arg22@2202@01)))
  
  :qid |e$RemoveLiquidity-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2200@01 Int) ($arg1@2201@01 Int) ($arg2@2202@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2200@01)
            ($SortWrappers.IntTo$Snap $arg1@2201@01))
          ($SortWrappers.IntTo$Snap $arg2@2202@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2200@01)
            ($SortWrappers.IntTo$Snap $arg1@2201@01))
          ($SortWrappers.IntTo$Snap $arg2@2202@01)))))
    (and
      (and
        (= (inv@2204@01 $arg0@2200@01 $arg1@2201@01 $arg2@2202@01) $arg0@2200@01)
        (= (inv@2206@01 $arg0@2200@01 $arg1@2201@01 $arg2@2202@01) $arg1@2201@01)
        (= (inv@2208@01 $arg0@2200@01 $arg1@2201@01 $arg2@2202@01) $arg2@2202@01))
      (and
        (img@2205@01 $arg0@2200@01 $arg1@2201@01 $arg2@2202@01)
        (img@2207@01 $arg0@2200@01 $arg1@2201@01 $arg2@2202@01)
        (img@2209@01 $arg0@2200@01 $arg1@2201@01 $arg2@2202@01))))
  :pattern (($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2200@01)
      ($SortWrappers.IntTo$Snap $arg1@2201@01))
    ($SortWrappers.IntTo$Snap $arg2@2202@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2200@01)
      ($SortWrappers.IntTo$Snap $arg1@2201@01))
    ($SortWrappers.IntTo$Snap $arg2@2202@01))))
  :qid |e$RemoveLiquidity-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2205@01 $arg0 $arg1 $arg2)
        (img@2207@01 $arg0 $arg1 $arg2)
        (img@2209@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2204@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2206@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2208@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2204@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2206@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2208@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2204@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2206@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2208@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2204@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2206@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2208@01 $arg0 $arg1 $arg2))
  :qid |e$RemoveLiquidity-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2204@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2206@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2208@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$RemoveLiquidity ($PSF.lookup_e$RemoveLiquidity (as sm@2114@01  $PSF<e$RemoveLiquidity>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2204@01 $arg0 $arg1 $arg2) (inv@2206@01 $arg0 $arg1 $arg2) (inv@2208@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1873|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 21
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2204@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2206@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2208@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2205@01 $arg0 $arg1 $arg2)
        (img@2207@01 $arg0 $arg1 $arg2)
        (img@2209@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2204@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2206@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2208@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$RemoveLiquidity (as pm@2203@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2204@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2206@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2208@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1874|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Transfer($arg0, $arg1, $arg2) }
;     perm(e$Transfer($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Transfer($arg0, $arg1, $arg2), perm(e$Transfer($arg0, $arg1, $arg2))))
(declare-const $arg0@2210@01 Int)
(declare-const $arg1@2211@01 Int)
(declare-const $arg2@2212@01 Int)
(push) ; 21
; [eval] perm(e$Transfer($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@2213@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef200|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef201|)))
(assert ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2210@01)
    ($SortWrappers.IntTo$Snap $arg1@2211@01))
  ($SortWrappers.IntTo$Snap $arg2@2212@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2210@01)
    ($SortWrappers.IntTo$Snap $arg1@2211@01))
  ($SortWrappers.IntTo$Snap $arg2@2212@01))))
(assert (>
  ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2210@01)
      ($SortWrappers.IntTo$Snap $arg1@2211@01))
    ($SortWrappers.IntTo$Snap $arg2@2212@01)))
  $Perm.No))
; [eval] perm(e$Transfer($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 21
(declare-fun inv@2214@01 (Int Int Int) Int)
(declare-fun img@2215@01 (Int Int Int) Bool)
(declare-fun inv@2216@01 (Int Int Int) Int)
(declare-fun img@2217@01 (Int Int Int) Bool)
(declare-fun inv@2218@01 (Int Int Int) Int)
(declare-fun img@2219@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef200|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef201|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2210@01 Int) ($arg1@2211@01 Int) ($arg2@2212@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2210@01)
          ($SortWrappers.IntTo$Snap $arg1@2211@01))
        ($SortWrappers.IntTo$Snap $arg2@2212@01)))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2210@01)
        ($SortWrappers.IntTo$Snap $arg1@2211@01))
      ($SortWrappers.IntTo$Snap $arg2@2212@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2210@01)
        ($SortWrappers.IntTo$Snap $arg1@2211@01))
      ($SortWrappers.IntTo$Snap $arg2@2212@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2210@01)
      ($SortWrappers.IntTo$Snap $arg1@2211@01))
    ($SortWrappers.IntTo$Snap $arg2@2212@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2210@01)
      ($SortWrappers.IntTo$Snap $arg1@2211@01))
    ($SortWrappers.IntTo$Snap $arg2@2212@01))))
  :qid |e$Transfer-aux|)))
(push) ; 21
(assert (not (forall (($arg0@2210@01 Int) ($arg1@2211@01 Int) ($arg2@2212@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2210@01)
          ($SortWrappers.IntTo$Snap $arg1@2211@01))
        ($SortWrappers.IntTo$Snap $arg2@2212@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2210@01)
            ($SortWrappers.IntTo$Snap $arg1@2211@01))
          ($SortWrappers.IntTo$Snap $arg2@2212@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2210@01)
            ($SortWrappers.IntTo$Snap $arg1@2211@01))
          ($SortWrappers.IntTo$Snap $arg2@2212@01))))))
  
  :qid |quant-u-1875|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 21
(assert (not (forall (($arg01@2210@01 Int) ($arg11@2211@01 Int) ($arg21@2212@01 Int) ($arg02@2210@01 Int) ($arg12@2211@01 Int) ($arg22@2212@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2210@01)
                ($SortWrappers.IntTo$Snap $arg11@2211@01))
              ($SortWrappers.IntTo$Snap $arg21@2212@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2210@01)
              ($SortWrappers.IntTo$Snap $arg11@2211@01))
            ($SortWrappers.IntTo$Snap $arg21@2212@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2210@01)
              ($SortWrappers.IntTo$Snap $arg11@2211@01))
            ($SortWrappers.IntTo$Snap $arg21@2212@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2210@01)
              ($SortWrappers.IntTo$Snap $arg11@2211@01))
            ($SortWrappers.IntTo$Snap $arg21@2212@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2210@01)
                ($SortWrappers.IntTo$Snap $arg12@2211@01))
              ($SortWrappers.IntTo$Snap $arg22@2212@01)))
            $Perm.No)
          ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2210@01)
              ($SortWrappers.IntTo$Snap $arg12@2211@01))
            ($SortWrappers.IntTo$Snap $arg22@2212@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2210@01)
              ($SortWrappers.IntTo$Snap $arg12@2211@01))
            ($SortWrappers.IntTo$Snap $arg22@2212@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2210@01)
              ($SortWrappers.IntTo$Snap $arg12@2211@01))
            ($SortWrappers.IntTo$Snap $arg22@2212@01)))))
      (and
        (and (= $arg01@2210@01 $arg02@2210@01) (= $arg11@2211@01 $arg12@2211@01))
        (= $arg21@2212@01 $arg22@2212@01)))
    (and
      (and (= $arg01@2210@01 $arg02@2210@01) (= $arg11@2211@01 $arg12@2211@01))
      (= $arg21@2212@01 $arg22@2212@01)))
  
  :qid |e$Transfer-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2210@01 Int) ($arg1@2211@01 Int) ($arg2@2212@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2210@01)
            ($SortWrappers.IntTo$Snap $arg1@2211@01))
          ($SortWrappers.IntTo$Snap $arg2@2212@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2210@01)
            ($SortWrappers.IntTo$Snap $arg1@2211@01))
          ($SortWrappers.IntTo$Snap $arg2@2212@01)))))
    (and
      (and
        (= (inv@2214@01 $arg0@2210@01 $arg1@2211@01 $arg2@2212@01) $arg0@2210@01)
        (= (inv@2216@01 $arg0@2210@01 $arg1@2211@01 $arg2@2212@01) $arg1@2211@01)
        (= (inv@2218@01 $arg0@2210@01 $arg1@2211@01 $arg2@2212@01) $arg2@2212@01))
      (and
        (img@2215@01 $arg0@2210@01 $arg1@2211@01 $arg2@2212@01)
        (img@2217@01 $arg0@2210@01 $arg1@2211@01 $arg2@2212@01)
        (img@2219@01 $arg0@2210@01 $arg1@2211@01 $arg2@2212@01))))
  :pattern (($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2210@01)
      ($SortWrappers.IntTo$Snap $arg1@2211@01))
    ($SortWrappers.IntTo$Snap $arg2@2212@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2210@01)
      ($SortWrappers.IntTo$Snap $arg1@2211@01))
    ($SortWrappers.IntTo$Snap $arg2@2212@01))))
  :qid |e$Transfer-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2215@01 $arg0 $arg1 $arg2)
        (img@2217@01 $arg0 $arg1 $arg2)
        (img@2219@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2214@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2216@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2218@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2214@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2216@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2218@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2214@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2216@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2218@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2214@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2216@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2218@01 $arg0 $arg1 $arg2))
  :qid |e$Transfer-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2214@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2216@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2218@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Transfer ($PSF.lookup_e$Transfer (as sm@2126@01  $PSF<e$Transfer>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2214@01 $arg0 $arg1 $arg2) (inv@2216@01 $arg0 $arg1 $arg2) (inv@2218@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1876|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 21
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2214@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2216@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2218@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2215@01 $arg0 $arg1 $arg2)
        (img@2217@01 $arg0 $arg1 $arg2)
        (img@2219@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2214@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2216@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2218@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Transfer (as pm@2213@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2214@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2216@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2218@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1877|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; exhale true &&
;   (forall $arg0: Int, $arg1: Int, $arg2: Int ::
;     { e$Approval($arg0, $arg1, $arg2) }
;     perm(e$Approval($arg0, $arg1, $arg2)) > none ==>
;     acc(e$Approval($arg0, $arg1, $arg2), perm(e$Approval($arg0, $arg1, $arg2))))
(declare-const $arg0@2220@01 Int)
(declare-const $arg1@2221@01 Int)
(declare-const $arg2@2222@01 Int)
(push) ; 21
; [eval] perm(e$Approval($arg0, $arg1, $arg2)) > none
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
(declare-const pm@2223@01 $PPM)
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef202|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef203|)))
(assert ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2220@01)
    ($SortWrappers.IntTo$Snap $arg1@2221@01))
  ($SortWrappers.IntTo$Snap $arg2@2222@01))) ($Snap.combine
  ($Snap.combine
    ($SortWrappers.IntTo$Snap $arg0@2220@01)
    ($SortWrappers.IntTo$Snap $arg1@2221@01))
  ($SortWrappers.IntTo$Snap $arg2@2222@01))))
(assert (>
  ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2220@01)
      ($SortWrappers.IntTo$Snap $arg1@2221@01))
    ($SortWrappers.IntTo$Snap $arg2@2222@01)))
  $Perm.No))
; [eval] perm(e$Approval($arg0, $arg1, $arg2))
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 21
(declare-fun inv@2224@01 (Int Int Int) Int)
(declare-fun img@2225@01 (Int Int Int) Bool)
(declare-fun inv@2226@01 (Int Int Int) Int)
(declare-fun img@2227@01 (Int Int Int) Bool)
(declare-fun inv@2228@01 (Int Int Int) Int)
(declare-fun img@2229@01 (Int Int Int) Bool)
; Nested auxiliary terms: globals
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=
    ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2)))
    $Perm.No)
  :pattern (($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resPrmSumDef202|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2)))
  :pattern (($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0)
      ($SortWrappers.IntTo$Snap $arg1))
    ($SortWrappers.IntTo$Snap $arg2))))
  :qid |qp.resTrgDef203|)))
; Nested auxiliary terms: non-globals
(assert (forall (($arg0@2220@01 Int) ($arg1@2221@01 Int) ($arg2@2222@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2220@01)
          ($SortWrappers.IntTo$Snap $arg1@2221@01))
        ($SortWrappers.IntTo$Snap $arg2@2222@01)))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2220@01)
        ($SortWrappers.IntTo$Snap $arg1@2221@01))
      ($SortWrappers.IntTo$Snap $arg2@2222@01))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0@2220@01)
        ($SortWrappers.IntTo$Snap $arg1@2221@01))
      ($SortWrappers.IntTo$Snap $arg2@2222@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2220@01)
      ($SortWrappers.IntTo$Snap $arg1@2221@01))
    ($SortWrappers.IntTo$Snap $arg2@2222@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2220@01)
      ($SortWrappers.IntTo$Snap $arg1@2221@01))
    ($SortWrappers.IntTo$Snap $arg2@2222@01))))
  :qid |e$Approval-aux|)))
(push) ; 21
(assert (not (forall (($arg0@2220@01 Int) ($arg1@2221@01 Int) ($arg2@2222@01 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap $arg0@2220@01)
          ($SortWrappers.IntTo$Snap $arg1@2221@01))
        ($SortWrappers.IntTo$Snap $arg2@2222@01)))
      $Perm.No)
    (or
      (=
        ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2220@01)
            ($SortWrappers.IntTo$Snap $arg1@2221@01))
          ($SortWrappers.IntTo$Snap $arg2@2222@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2220@01)
            ($SortWrappers.IntTo$Snap $arg1@2221@01))
          ($SortWrappers.IntTo$Snap $arg2@2222@01))))))
  
  :qid |quant-u-1878|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 21
(assert (not (forall (($arg01@2220@01 Int) ($arg11@2221@01 Int) ($arg21@2222@01 Int) ($arg02@2220@01 Int) ($arg12@2221@01 Int) ($arg22@2222@01 Int)) (!
  (=>
    (and
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg01@2220@01)
                ($SortWrappers.IntTo$Snap $arg11@2221@01))
              ($SortWrappers.IntTo$Snap $arg21@2222@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2220@01)
              ($SortWrappers.IntTo$Snap $arg11@2221@01))
            ($SortWrappers.IntTo$Snap $arg21@2222@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2220@01)
              ($SortWrappers.IntTo$Snap $arg11@2221@01))
            ($SortWrappers.IntTo$Snap $arg21@2222@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg01@2220@01)
              ($SortWrappers.IntTo$Snap $arg11@2221@01))
            ($SortWrappers.IntTo$Snap $arg21@2222@01)))))
      (and
        (and
          (>
            ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
              ($Snap.combine
                ($SortWrappers.IntTo$Snap $arg02@2220@01)
                ($SortWrappers.IntTo$Snap $arg12@2221@01))
              ($SortWrappers.IntTo$Snap $arg22@2222@01)))
            $Perm.No)
          ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2220@01)
              ($SortWrappers.IntTo$Snap $arg12@2221@01))
            ($SortWrappers.IntTo$Snap $arg22@2222@01))) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2220@01)
              ($SortWrappers.IntTo$Snap $arg12@2221@01))
            ($SortWrappers.IntTo$Snap $arg22@2222@01))))
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap $arg02@2220@01)
              ($SortWrappers.IntTo$Snap $arg12@2221@01))
            ($SortWrappers.IntTo$Snap $arg22@2222@01)))))
      (and
        (and (= $arg01@2220@01 $arg02@2220@01) (= $arg11@2221@01 $arg12@2221@01))
        (= $arg21@2222@01 $arg22@2222@01)))
    (and
      (and (= $arg01@2220@01 $arg02@2220@01) (= $arg11@2221@01 $arg12@2221@01))
      (= $arg21@2222@01 $arg22@2222@01)))
  
  :qid |e$Approval-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall (($arg0@2220@01 Int) ($arg1@2221@01 Int) ($arg2@2222@01 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2220@01)
            ($SortWrappers.IntTo$Snap $arg1@2221@01))
          ($SortWrappers.IntTo$Snap $arg2@2222@01)))
        $Perm.No)
      (<
        $Perm.No
        ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap $arg0@2220@01)
            ($SortWrappers.IntTo$Snap $arg1@2221@01))
          ($SortWrappers.IntTo$Snap $arg2@2222@01)))))
    (and
      (and
        (= (inv@2224@01 $arg0@2220@01 $arg1@2221@01 $arg2@2222@01) $arg0@2220@01)
        (= (inv@2226@01 $arg0@2220@01 $arg1@2221@01 $arg2@2222@01) $arg1@2221@01)
        (= (inv@2228@01 $arg0@2220@01 $arg1@2221@01 $arg2@2222@01) $arg2@2222@01))
      (and
        (img@2225@01 $arg0@2220@01 $arg1@2221@01 $arg2@2222@01)
        (img@2227@01 $arg0@2220@01 $arg1@2221@01 $arg2@2222@01)
        (img@2229@01 $arg0@2220@01 $arg1@2221@01 $arg2@2222@01))))
  :pattern (($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2220@01)
      ($SortWrappers.IntTo$Snap $arg1@2221@01))
    ($SortWrappers.IntTo$Snap $arg2@2222@01))) ($Snap.combine
    ($Snap.combine
      ($SortWrappers.IntTo$Snap $arg0@2220@01)
      ($SortWrappers.IntTo$Snap $arg1@2221@01))
    ($SortWrappers.IntTo$Snap $arg2@2222@01))))
  :qid |e$Approval-invOfFct|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (and
        (img@2225@01 $arg0 $arg1 $arg2)
        (img@2227@01 $arg0 $arg1 $arg2)
        (img@2229@01 $arg0 $arg1 $arg2))
      (and
        (>
          ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2224@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2226@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2228@01 $arg0 $arg1 $arg2))))
          $Perm.No)
        (<
          $Perm.No
          ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
            ($Snap.combine
              ($SortWrappers.IntTo$Snap (inv@2224@01 $arg0 $arg1 $arg2))
              ($SortWrappers.IntTo$Snap (inv@2226@01 $arg0 $arg1 $arg2)))
            ($SortWrappers.IntTo$Snap (inv@2228@01 $arg0 $arg1 $arg2)))))))
    (and
      (= (inv@2224@01 $arg0 $arg1 $arg2) $arg0)
      (= (inv@2226@01 $arg0 $arg1 $arg2) $arg1)
      (= (inv@2228@01 $arg0 $arg1 $arg2) $arg2)))
  :pattern ((inv@2224@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2226@01 $arg0 $arg1 $arg2))
  :pattern ((inv@2228@01 $arg0 $arg1 $arg2))
  :qid |e$Approval-fctOfInv|)))
(assert (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (>
      ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2224@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2226@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2228@01 $arg0 $arg1 $arg2))))
      $Perm.No)
    ($PSF.loc_e$Approval ($PSF.lookup_e$Approval (as sm@2138@01  $PSF<e$Approval>) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))) ($Snap.combine
      ($Snap.combine
        ($SortWrappers.IntTo$Snap $arg0)
        ($SortWrappers.IntTo$Snap $arg1))
      ($SortWrappers.IntTo$Snap $arg2))))
  :pattern ((inv@2224@01 $arg0 $arg1 $arg2) (inv@2226@01 $arg0 $arg1 $arg2) (inv@2228@01 $arg0 $arg1 $arg2))
  :qid |quant-u-1879|)))
; Precomputing data for removing quantified permissions
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Final check if taken enough permissions
(set-option :timeout 0)
(push) ; 21
(assert (not (forall (($arg0 Int) ($arg1 Int) ($arg2 Int)) (!
  (=>
    (and
      (>
        ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
          ($Snap.combine
            ($SortWrappers.IntTo$Snap (inv@2224@01 $arg0 $arg1 $arg2))
            ($SortWrappers.IntTo$Snap (inv@2226@01 $arg0 $arg1 $arg2)))
          ($SortWrappers.IntTo$Snap (inv@2228@01 $arg0 $arg1 $arg2))))
        $Perm.No)
      (and
        (img@2225@01 $arg0 $arg1 $arg2)
        (img@2227@01 $arg0 $arg1 $arg2)
        (img@2229@01 $arg0 $arg1 $arg2))
      (and
        (= $arg0 (inv@2224@01 $arg0 $arg1 $arg2))
        (= $arg1 (inv@2226@01 $arg0 $arg1 $arg2))
        (= $arg2 (inv@2228@01 $arg0 $arg1 $arg2))))
    (=
      ($PSF.perm_e$Approval (as pm@2223@01  $PPM) ($Snap.combine
        ($Snap.combine
          ($SortWrappers.IntTo$Snap (inv@2224@01 $arg0 $arg1 $arg2))
          ($SortWrappers.IntTo$Snap (inv@2226@01 $arg0 $arg1 $arg2)))
        ($SortWrappers.IntTo$Snap (inv@2228@01 $arg0 $arg1 $arg2))))
      $Perm.No))
  
  :qid |quant-u-1880|))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; Done removing quantified permissions
; [exec]
; $old_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc
(push) ; 21
(set-option :timeout 10)
(assert (not (not l$i0$send_fail$1@2009@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not l$i0$send_fail$1@2009@01))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
; [then-branch: 606 | l$i0$send_fail$1@2009@01 | live]
; [else-branch: 606 | !(l$i0$send_fail$1@2009@01) | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 606 | l$i0$send_fail$1@2009@01]
(assert l$i0$send_fail$1@2009@01)
; [exec]
; inhale acc($failed(($struct_get($struct_loc(self, 6)): Int)), write)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(declare-const $t@2230@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label revert
; [exec]
; $succ := false
; [exec]
; $res := l$havoc
; [exec]
; self := $pre_self
; [exec]
; $contracts := $pre_$contracts
; [exec]
; $old_self := $pre_self
; [exec]
; $old_$contracts := $pre_$contracts
; [exec]
; label end
; [eval] !$succ
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 607 | True | live]
; [else-branch: 607 | False | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 607 | True]
; [exec]
; inhale l$havoc$1 >= 0
(declare-const $t@2231@01 $Snap)
(assert (= $t@2231@01 $Snap.unit))
; [eval] l$havoc$1 >= 0
(assert (>= l$havoc$1@2021@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; self := ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) +
;   l$havoc$1): $Struct)
; [eval] ($struct_set(self, 8, ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1): $Struct)
; [eval] ($struct_get($struct_loc(self, 8)): Int) + l$havoc$1
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(declare-const self@2232@01 $Struct)
(assert (=
  self@2232@01
  ($struct_set<$Struct> self@1980@01 8 (+
    ($struct_get<Int> ($struct_loc<Int> self@1980@01 8))
    l$havoc$1@2021@01))))
; [exec]
; $contracts := l$havoc$2
(pop) ; 22
; [then-branch: 608 | False | dead]
; [else-branch: 608 | True | live]
(set-option :timeout 0)
(push) ; 22
; [else-branch: 608 | True]
(pop) ; 22
(pop) ; 21
(push) ; 21
; [else-branch: 606 | !(l$i0$send_fail$1@2009@01)]
(assert (not l$i0$send_fail$1@2009@01))
(pop) ; 21
; [eval] !l$i0$send_fail$1
(push) ; 21
(set-option :timeout 10)
(assert (not l$i0$send_fail$1@2009@01))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not l$i0$send_fail$1@2009@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
; [then-branch: 609 | !(l$i0$send_fail$1@2009@01) | live]
; [else-branch: 609 | l$i0$send_fail$1@2009@01 | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 609 | !(l$i0$send_fail$1@2009@01)]
(assert (not l$i0$send_fail$1@2009@01))
; [exec]
; $contracts := $old_$contracts
; [exec]
; $old_self := self
; [exec]
; $old_$contracts := $contracts
; [exec]
; i3$$pre_self := self
; [exec]
; i3$$pre_$contracts := $contracts
; [exec]
; $contracts := l$i0$havoc$1
; [exec]
; $old_$contracts := $contracts
; [exec]
; self := l$i0$havoc$2
; [exec]
; $contracts := l$i0$havoc$3
; [exec]
; inhale |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
(declare-const $t@2233@01 $Snap)
(assert (= $t@2233@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 0)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 0)): Seq[Int])
; [eval] $struct_loc(self, 0)
(assert (=
  (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 0)))
  32))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
(declare-const $t@2234@01 $Snap)
(assert (= $t@2234@01 $Snap.unit))
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])| == 32
; [eval] |($struct_get($struct_loc(self, 1)): Seq[Int])|
; [eval] ($struct_get($struct_loc(self, 1)): Seq[Int])
; [eval] $struct_loc(self, 1)
(assert (=
  (Seq_length ($struct_get<Seq<Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 1)))
  32))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 2)): Int) &&
;   ($struct_get($struct_loc(self, 2)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2235@01 $Snap)
(assert (= $t@2235@01 ($Snap.combine ($Snap.first $t@2235@01) ($Snap.second $t@2235@01))))
(assert (= ($Snap.first $t@2235@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 2)): Int)
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 2))))
(assert (= ($Snap.second $t@2235@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 2)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 2)): Int)
; [eval] $struct_loc(self, 2)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 2))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 3)): Int) &&
;   ($struct_get($struct_loc(self, 3)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2236@01 $Snap)
(assert (= $t@2236@01 ($Snap.combine ($Snap.first $t@2236@01) ($Snap.second $t@2236@01))))
(assert (= ($Snap.first $t@2236@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 3)): Int)
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 3))))
(assert (= ($Snap.second $t@2236@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 3)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 3)): Int)
; [eval] $struct_loc(self, 3)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 3))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@2237@01 $Snap)
(assert (= $t@2237@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q2@2238@01 Int)
(set-option :timeout 0)
(push) ; 22
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) && ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(push) ; 23
; [then-branch: 610 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@2014@01, 4)), $q2@2238@01)) | live]
; [else-branch: 610 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@2014@01, 4)), $q2@2238@01) | live]
(push) ; 24
; [then-branch: 610 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@2014@01, 4)), $q2@2238@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2238@01))))
(pop) ; 24
(push) ; 24
; [else-branch: 610 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@2014@01, 4)), $q2@2238@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2238@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2238@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2238@01)))))
(pop) ; 22
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@2238@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2238@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2238@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2238@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2636@11@2636@345-aux|)))
(assert (forall (($q2@2238@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2238@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2238@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2238@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2636@11@2636@345|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q2: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) }
;     ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $t@2239@01 $Snap)
(assert (= $t@2239@01 $Snap.unit))
; [eval] (forall $q2: Int :: { ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) } ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int))
(declare-const $q2@2240@01 Int)
(set-option :timeout 0)
(push) ; 22
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int) <= ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 4)): $Map[Int, Int]), $q2): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
; [eval] ($map_sum(($struct_get($struct_loc(self, 4)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 4)): $Map[Int, Int])
; [eval] $struct_loc(self, 4)
(pop) ; 22
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q2@2240@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2240@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 4)) $q2@2240@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2637@11@2637@253|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       0 <=
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) &&
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $t@2241@01 $Snap)
(assert (= $t@2241@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935))
(declare-const $q3@2242@01 Int)
(set-option :timeout 0)
(push) ; 22
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q4@2243@01 Int)
(push) ; 23
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) && ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(push) ; 24
; [then-branch: 611 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@2014@01, 5)), $q3@2242@01), $q4@2243@01)) | live]
; [else-branch: 611 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@2014@01, 5)), $q3@2242@01), $q4@2243@01) | live]
(push) ; 25
; [then-branch: 611 | !(0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@2014@01, 5)), $q3@2242@01), $q4@2243@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01))))
(pop) ; 25
(push) ; 25
; [else-branch: 611 | 0 <= $map_get[Int]($map_get[$Map[Int, Int]]($struct_get[$Map[Int, $Map[Int, Int]]]($struct_loc[Int](l$i0$havoc$2@2014@01, 5)), $q3@2242@01), $q4@2243@01)]
(assert (<=
  0
  ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01)))
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 25
(pop) ; 24
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01))
  (not
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01)))))
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q4@2243@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01))
    (not
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01))))
  :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2638@131@2638@597-aux|)))
(pop) ; 22
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@2242@01 Int)) (!
  (forall (($q4@2243@01 Int)) (!
    (or
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01))
      (not
        (<=
          0
          ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01))))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2638@131@2638@597-aux|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2638@11@2638@598-aux|)))
(assert (forall (($q3@2242@01 Int)) (!
  (forall (($q4@2243@01 Int)) (!
    (and
      (<=
        0
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01))
      (<=
        ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01)
        115792089237316195423570985008687907853269984665640564039457584007913129639935))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01) $q4@2243@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2638@131@2638@597|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2242@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2638@11@2638@598|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q3: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;     $q3): $Map[Int, Int]) }
;     (forall $q4: Int ::
;       { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) }
;       ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int]), $q4): Int) <=
;       ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]),
;       $q3): $Map[Int, Int])): Int)))
(declare-const $t@2244@01 $Snap)
(assert (= $t@2244@01 $Snap.unit))
; [eval] (forall $q3: Int :: { ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]) } (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)))
(declare-const $q3@2245@01 Int)
(set-option :timeout 0)
(push) ; 22
; [eval] (forall $q4: Int :: { ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) } ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int))
(declare-const $q4@2246@01 Int)
(push) ; 23
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int) <= ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int]), $q4): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
; [eval] ($map_sum(($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]]), $q3): $Map[Int, Int])
; [eval] ($struct_get($struct_loc(self, 5)): $Map[Int, $Map[Int, Int]])
; [eval] $struct_loc(self, 5)
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(pop) ; 22
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q3@2245@01 Int)) (!
  (forall (($q4@2246@01 Int)) (!
    (<=
      ($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2245@01) $q4@2246@01)
      ($map_sum<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2245@01)))
    :pattern (($map_get<Int> ($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2245@01) $q4@2246@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2639@131@2639@505|))
  :pattern (($map_get<$Map<Int~_Int>> ($struct_get<$Map<Int~_$Map<Int~_Int>>> ($struct_loc<Int> l$i0$havoc$2@2014@01 5)) $q3@2245@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2639@11@2639@506|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 6)): Int) &&
;   ($struct_get($struct_loc(self, 6)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@2247@01 $Snap)
(assert (= $t@2247@01 ($Snap.combine ($Snap.first $t@2247@01) ($Snap.second $t@2247@01))))
(assert (= ($Snap.first $t@2247@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 6)): Int)
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 6))))
(assert (= ($Snap.second $t@2247@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 6)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 6)): Int)
; [eval] $struct_loc(self, 6)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 6))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 7)): Int) &&
;   ($struct_get($struct_loc(self, 7)): Int) <=
;   1461501637330902918203684832716283019655932542975
(declare-const $t@2248@01 $Snap)
(assert (= $t@2248@01 ($Snap.combine ($Snap.first $t@2248@01) ($Snap.second $t@2248@01))))
(assert (= ($Snap.first $t@2248@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 7)): Int)
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 7))))
(assert (= ($Snap.second $t@2248@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 7)): Int) <= 1461501637330902918203684832716283019655932542975
; [eval] ($struct_get($struct_loc(self, 7)): Int)
; [eval] $struct_loc(self, 7)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 7))
  1461501637330902918203684832716283019655932542975))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale 0 <= ($struct_get($struct_loc(self, 8)): Int) &&
;   ($struct_get($struct_loc(self, 8)): Int) <=
;   115792089237316195423570985008687907853269984665640564039457584007913129639935
(declare-const $t@2249@01 $Snap)
(assert (= $t@2249@01 ($Snap.combine ($Snap.first $t@2249@01) ($Snap.second $t@2249@01))))
(assert (= ($Snap.first $t@2249@01) $Snap.unit))
; [eval] 0 <= ($struct_get($struct_loc(self, 8)): Int)
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<= 0 ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 8))))
(assert (= ($Snap.second $t@2249@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 8)): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($struct_get($struct_loc(self, 8)): Int)
; [eval] $struct_loc(self, 8)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 8))
  115792089237316195423570985008687907853269984665640564039457584007913129639935))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale -170141183460469231731687303715884105728 <=
;   ($struct_get($struct_loc(self, 9)): Int) &&
;   ($struct_get($struct_loc(self, 9)): Int) <=
;   170141183460469231731687303715884105727
(declare-const $t@2250@01 $Snap)
(assert (= $t@2250@01 ($Snap.combine ($Snap.first $t@2250@01) ($Snap.second $t@2250@01))))
(assert (= ($Snap.first $t@2250@01) $Snap.unit))
; [eval] -170141183460469231731687303715884105728 <= ($struct_get($struct_loc(self, 9)): Int)
; [eval] -170141183460469231731687303715884105728
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  (- 0 170141183460469231731687303715884105728)
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 9))))
(assert (= ($Snap.second $t@2250@01) $Snap.unit))
; [eval] ($struct_get($struct_loc(self, 9)): Int) <= 170141183460469231731687303715884105727
; [eval] ($struct_get($struct_loc(self, 9)): Int)
; [eval] $struct_loc(self, 9)
(assert (<=
  ($struct_get<Int> ($struct_loc<Int> l$i0$havoc$2@2014@01 9))
  170141183460469231731687303715884105727))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     0 <=
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) &&
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $t@2251@01 $Snap)
(assert (= $t@2251@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935)
(declare-const $q5@2252@01 Int)
(set-option :timeout 0)
(push) ; 22
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) && ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] 0 <= ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(push) ; 23
; [then-branch: 612 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@2014@01, 11)), $q5@2252@01)) | live]
; [else-branch: 612 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@2014@01, 11)), $q5@2252@01) | live]
(push) ; 24
; [then-branch: 612 | !(0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@2014@01, 11)), $q5@2252@01))]
(assert (not
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2252@01))))
(pop) ; 24
(push) ; 24
; [else-branch: 612 | 0 <= $map_get[Int]($struct_get[$Map[Int, Int]]($struct_loc[Int](l$i0$havoc$2@2014@01, 11)), $q5@2252@01)]
(assert (<=
  0
  ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2252@01)))
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= 115792089237316195423570985008687907853269984665640564039457584007913129639935
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(assert (or
  (<=
    0
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2252@01))
  (not
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2252@01)))))
(pop) ; 22
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@2252@01 Int)) (!
  (or
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2252@01))
    (not
      (<=
        0
        ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2252@01))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2252@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2644@11@2644@348-aux|)))
(assert (forall (($q5@2252@01 Int)) (!
  (and
    (<=
      0
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2252@01))
    (<=
      ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2252@01)
      115792089237316195423570985008687907853269984665640564039457584007913129639935))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2252@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2644@11@2644@348|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall $q5: Int ::
;     { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) }
;     ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <=
;     ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $t@2253@01 $Snap)
(assert (= $t@2253@01 $Snap.unit))
; [eval] (forall $q5: Int :: { ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) } ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int))
(declare-const $q5@2254@01 Int)
(set-option :timeout 0)
(push) ; 22
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int) <= ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($map_get(($struct_get($struct_loc(self, 11)): $Map[Int, Int]), $q5): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
; [eval] ($map_sum(($struct_get($struct_loc(self, 11)): $Map[Int, Int])): Int)
; [eval] ($struct_get($struct_loc(self, 11)): $Map[Int, Int])
; [eval] $struct_loc(self, 11)
(pop) ; 22
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall (($q5@2254@01 Int)) (!
  (<=
    ($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2254@01)
    ($map_sum<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11))))
  :pattern (($map_get<Int> ($struct_get<$Map<Int~_Int>> ($struct_loc<Int> l$i0$havoc$2@2014@01 11)) $q5@2254@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/vyper/testsresourcesexamplesuniswap.vy.vpr@2645@11@2645@256|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
