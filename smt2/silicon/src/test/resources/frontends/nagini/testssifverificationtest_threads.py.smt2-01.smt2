(get-info :version)
; (:version "4.12.1")
; Started: 2024-12-26 19:28:51
; Silicon.version: 1.1-SNAPSHOT (457c6eca@(detached))
; Input file: <unknown>
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Necessary for push pop mode
(set-option :auto_config false)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :type_check true)
(set-option :smt.mbqi false)
(set-option :pp.bv_literals false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.arith.solver 2)
(set-option :model.v2 true)
(set-option :smt.qi.max_multi_patterns 1000)
; 
; ; /preamble.smt2
(declare-datatypes (($Snap 0)) ((
    ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM 0)
(declare-sort $PPM 0)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<PyType> 0)
(declare-sort Seq<Measure$> 0)
(declare-sort Seq<$Ref> 0)
(declare-sort Set<$Ref> 0)
(declare-sort Set<_Name> 0)
(declare-sort PyType 0)
(declare-sort Thread 0)
(declare-sort _list_ce_helper 0)
(declare-sort ThreadingID 0)
(declare-sort _Name 0)
(declare-sort Measure$ 0)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<PyType>To$Snap (Seq<PyType>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<PyType> ($Snap) Seq<PyType>)
(assert (forall ((x Seq<PyType>)) (!
    (= x ($SortWrappers.$SnapToSeq<PyType>($SortWrappers.Seq<PyType>To$Snap x)))
    :pattern (($SortWrappers.Seq<PyType>To$Snap x))
    :qid |$Snap.$SnapToSeq<PyType>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<PyType>To$Snap($SortWrappers.$SnapToSeq<PyType> x)))
    :pattern (($SortWrappers.$SnapToSeq<PyType> x))
    :qid |$Snap.Seq<PyType>To$SnapToSeq<PyType>|
    )))
(declare-fun $SortWrappers.Seq<Measure$>To$Snap (Seq<Measure$>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Measure$> ($Snap) Seq<Measure$>)
(assert (forall ((x Seq<Measure$>)) (!
    (= x ($SortWrappers.$SnapToSeq<Measure$>($SortWrappers.Seq<Measure$>To$Snap x)))
    :pattern (($SortWrappers.Seq<Measure$>To$Snap x))
    :qid |$Snap.$SnapToSeq<Measure$>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Measure$>To$Snap($SortWrappers.$SnapToSeq<Measure$> x)))
    :pattern (($SortWrappers.$SnapToSeq<Measure$> x))
    :qid |$Snap.Seq<Measure$>To$SnapToSeq<Measure$>|
    )))
(declare-fun $SortWrappers.Seq<$Ref>To$Snap (Seq<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<$Ref> ($Snap) Seq<$Ref>)
(assert (forall ((x Seq<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSeq<$Ref>($SortWrappers.Seq<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Seq<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSeq<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<$Ref>To$Snap($SortWrappers.$SnapToSeq<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSeq<$Ref> x))
    :qid |$Snap.Seq<$Ref>To$SnapToSeq<$Ref>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<_Name>To$Snap (Set<_Name>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<_Name> ($Snap) Set<_Name>)
(assert (forall ((x Set<_Name>)) (!
    (= x ($SortWrappers.$SnapToSet<_Name>($SortWrappers.Set<_Name>To$Snap x)))
    :pattern (($SortWrappers.Set<_Name>To$Snap x))
    :qid |$Snap.$SnapToSet<_Name>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<_Name>To$Snap($SortWrappers.$SnapToSet<_Name> x)))
    :pattern (($SortWrappers.$SnapToSet<_Name> x))
    :qid |$Snap.Set<_Name>To$SnapToSet<_Name>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.PyTypeTo$Snap (PyType) $Snap)
(declare-fun $SortWrappers.$SnapToPyType ($Snap) PyType)
(assert (forall ((x PyType)) (!
    (= x ($SortWrappers.$SnapToPyType($SortWrappers.PyTypeTo$Snap x)))
    :pattern (($SortWrappers.PyTypeTo$Snap x))
    :qid |$Snap.$SnapToPyTypeTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.PyTypeTo$Snap($SortWrappers.$SnapToPyType x)))
    :pattern (($SortWrappers.$SnapToPyType x))
    :qid |$Snap.PyTypeTo$SnapToPyType|
    )))
(declare-fun $SortWrappers.ThreadTo$Snap (Thread) $Snap)
(declare-fun $SortWrappers.$SnapToThread ($Snap) Thread)
(assert (forall ((x Thread)) (!
    (= x ($SortWrappers.$SnapToThread($SortWrappers.ThreadTo$Snap x)))
    :pattern (($SortWrappers.ThreadTo$Snap x))
    :qid |$Snap.$SnapToThreadTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.ThreadTo$Snap($SortWrappers.$SnapToThread x)))
    :pattern (($SortWrappers.$SnapToThread x))
    :qid |$Snap.ThreadTo$SnapToThread|
    )))
(declare-fun $SortWrappers._list_ce_helperTo$Snap (_list_ce_helper) $Snap)
(declare-fun $SortWrappers.$SnapTo_list_ce_helper ($Snap) _list_ce_helper)
(assert (forall ((x _list_ce_helper)) (!
    (= x ($SortWrappers.$SnapTo_list_ce_helper($SortWrappers._list_ce_helperTo$Snap x)))
    :pattern (($SortWrappers._list_ce_helperTo$Snap x))
    :qid |$Snap.$SnapTo_list_ce_helperTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers._list_ce_helperTo$Snap($SortWrappers.$SnapTo_list_ce_helper x)))
    :pattern (($SortWrappers.$SnapTo_list_ce_helper x))
    :qid |$Snap._list_ce_helperTo$SnapTo_list_ce_helper|
    )))
(declare-fun $SortWrappers.ThreadingIDTo$Snap (ThreadingID) $Snap)
(declare-fun $SortWrappers.$SnapToThreadingID ($Snap) ThreadingID)
(assert (forall ((x ThreadingID)) (!
    (= x ($SortWrappers.$SnapToThreadingID($SortWrappers.ThreadingIDTo$Snap x)))
    :pattern (($SortWrappers.ThreadingIDTo$Snap x))
    :qid |$Snap.$SnapToThreadingIDTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.ThreadingIDTo$Snap($SortWrappers.$SnapToThreadingID x)))
    :pattern (($SortWrappers.$SnapToThreadingID x))
    :qid |$Snap.ThreadingIDTo$SnapToThreadingID|
    )))
(declare-fun $SortWrappers._NameTo$Snap (_Name) $Snap)
(declare-fun $SortWrappers.$SnapTo_Name ($Snap) _Name)
(assert (forall ((x _Name)) (!
    (= x ($SortWrappers.$SnapTo_Name($SortWrappers._NameTo$Snap x)))
    :pattern (($SortWrappers._NameTo$Snap x))
    :qid |$Snap.$SnapTo_NameTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers._NameTo$Snap($SortWrappers.$SnapTo_Name x)))
    :pattern (($SortWrappers.$SnapTo_Name x))
    :qid |$Snap._NameTo$SnapTo_Name|
    )))
(declare-fun $SortWrappers.Measure$To$Snap (Measure$) $Snap)
(declare-fun $SortWrappers.$SnapToMeasure$ ($Snap) Measure$)
(assert (forall ((x Measure$)) (!
    (= x ($SortWrappers.$SnapToMeasure$($SortWrappers.Measure$To$Snap x)))
    :pattern (($SortWrappers.Measure$To$Snap x))
    :qid |$Snap.$SnapToMeasure$To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Measure$To$Snap($SortWrappers.$SnapToMeasure$ x)))
    :pattern (($SortWrappers.$SnapToMeasure$ x))
    :qid |$Snap.Measure$To$SnapToMeasure$|
    )))
; ////////// Symbols
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_skolem_diff (Set<$Ref> Set<$Ref>) $Ref)
(declare-fun Set_card (Set<_Name>) Int)
(declare-const Set_empty Set<_Name>)
(declare-fun Set_in (_Name Set<_Name>) Bool)
(declare-fun Set_singleton (_Name) Set<_Name>)
(declare-fun Set_unionone (Set<_Name> _Name) Set<_Name>)
(declare-fun Set_union (Set<_Name> Set<_Name>) Set<_Name>)
(declare-fun Set_intersection (Set<_Name> Set<_Name>) Set<_Name>)
(declare-fun Set_difference (Set<_Name> Set<_Name>) Set<_Name>)
(declare-fun Set_subset (Set<_Name> Set<_Name>) Bool)
(declare-fun Set_equal (Set<_Name> Set<_Name>) Bool)
(declare-fun Set_skolem_diff (Set<_Name> Set<_Name>) _Name)
(declare-fun Seq_length (Seq<PyType>) Int)
(declare-const Seq_empty Seq<PyType>)
(declare-fun Seq_singleton (PyType) Seq<PyType>)
(declare-fun Seq_append (Seq<PyType> Seq<PyType>) Seq<PyType>)
(declare-fun Seq_index (Seq<PyType> Int) PyType)
(declare-fun Seq_add (Int Int) Int)
(declare-fun Seq_sub (Int Int) Int)
(declare-fun Seq_update (Seq<PyType> Int PyType) Seq<PyType>)
(declare-fun Seq_take (Seq<PyType> Int) Seq<PyType>)
(declare-fun Seq_drop (Seq<PyType> Int) Seq<PyType>)
(declare-fun Seq_contains (Seq<PyType> PyType) Bool)
(declare-fun Seq_contains_trigger (Seq<PyType> PyType) Bool)
(declare-fun Seq_skolem (Seq<PyType> PyType) Int)
(declare-fun Seq_equal (Seq<PyType> Seq<PyType>) Bool)
(declare-fun Seq_skolem_diff (Seq<PyType> Seq<PyType>) Int)
(declare-fun Seq_length (Seq<Measure$>) Int)
(declare-const Seq_empty Seq<Measure$>)
(declare-fun Seq_singleton (Measure$) Seq<Measure$>)
(declare-fun Seq_append (Seq<Measure$> Seq<Measure$>) Seq<Measure$>)
(declare-fun Seq_index (Seq<Measure$> Int) Measure$)
(declare-fun Seq_update (Seq<Measure$> Int Measure$) Seq<Measure$>)
(declare-fun Seq_take (Seq<Measure$> Int) Seq<Measure$>)
(declare-fun Seq_drop (Seq<Measure$> Int) Seq<Measure$>)
(declare-fun Seq_contains (Seq<Measure$> Measure$) Bool)
(declare-fun Seq_contains_trigger (Seq<Measure$> Measure$) Bool)
(declare-fun Seq_skolem (Seq<Measure$> Measure$) Int)
(declare-fun Seq_equal (Seq<Measure$> Seq<Measure$>) Bool)
(declare-fun Seq_skolem_diff (Seq<Measure$> Seq<Measure$>) Int)
(declare-fun Seq_length (Seq<$Ref>) Int)
(declare-const Seq_empty Seq<$Ref>)
(declare-fun Seq_singleton ($Ref) Seq<$Ref>)
(declare-fun Seq_append (Seq<$Ref> Seq<$Ref>) Seq<$Ref>)
(declare-fun Seq_index (Seq<$Ref> Int) $Ref)
(declare-fun Seq_update (Seq<$Ref> Int $Ref) Seq<$Ref>)
(declare-fun Seq_take (Seq<$Ref> Int) Seq<$Ref>)
(declare-fun Seq_drop (Seq<$Ref> Int) Seq<$Ref>)
(declare-fun Seq_contains (Seq<$Ref> $Ref) Bool)
(declare-fun Seq_contains_trigger (Seq<$Ref> $Ref) Bool)
(declare-fun Seq_skolem (Seq<$Ref> $Ref) Int)
(declare-fun Seq_equal (Seq<$Ref> Seq<$Ref>) Bool)
(declare-fun Seq_skolem_diff (Seq<$Ref> Seq<$Ref>) Int)
(declare-fun getMethod<ThreadingID> ($Ref) ThreadingID)
(declare-fun getMethod_0<ThreadingID> ($Ref) ThreadingID)
(declare-fun getArg<Ref> ($Ref Int) $Ref)
(declare-fun getArg_0<Ref> ($Ref Int) $Ref)
(declare-fun getOld<Ref> ($Ref Int) $Ref)
(declare-fun getOld_0<Ref> ($Ref Int) $Ref)
(declare-fun extends_<Bool> (PyType PyType) Bool)
(declare-fun issubtype<Bool> (PyType PyType) Bool)
(declare-fun isnotsubtype<Bool> (PyType PyType) Bool)
(declare-fun tuple_args<Seq<PyType>> (PyType) Seq<PyType>)
(declare-fun typeof<PyType> ($Ref) PyType)
(declare-fun get_basic<PyType> (PyType) PyType)
(declare-fun union_type_1<PyType> (PyType) PyType)
(declare-fun union_type_2<PyType> (PyType PyType) PyType)
(declare-fun union_type_3<PyType> (PyType PyType PyType) PyType)
(declare-fun union_type_4<PyType> (PyType PyType PyType PyType) PyType)
(declare-const object<PyType> PyType)
(declare-const list_basic<PyType> PyType)
(declare-fun list<PyType> (PyType) PyType)
(declare-fun list_arg<PyType> (PyType Int) PyType)
(declare-const set_basic<PyType> PyType)
(declare-fun set<PyType> (PyType) PyType)
(declare-fun set_arg<PyType> (PyType Int) PyType)
(declare-const dict_basic<PyType> PyType)
(declare-fun dict<PyType> (PyType PyType) PyType)
(declare-fun dict_arg<PyType> (PyType Int) PyType)
(declare-const int<PyType> PyType)
(declare-const float<PyType> PyType)
(declare-const bool<PyType> PyType)
(declare-const NoneType<PyType> PyType)
(declare-const Exception<PyType> PyType)
(declare-const ConnectionRefusedError<PyType> PyType)
(declare-const traceback<PyType> PyType)
(declare-const str<PyType> PyType)
(declare-const bytes<PyType> PyType)
(declare-const tuple_basic<PyType> PyType)
(declare-fun tuple<PyType> (Seq<PyType>) PyType)
(declare-fun tuple_arg<PyType> (PyType Int) PyType)
(declare-const PSeq_basic<PyType> PyType)
(declare-fun PSeq<PyType> (PyType) PyType)
(declare-fun PSeq_arg<PyType> (PyType Int) PyType)
(declare-const PSet_basic<PyType> PyType)
(declare-fun PSet<PyType> (PyType) PyType)
(declare-fun PSet_arg<PyType> (PyType Int) PyType)
(declare-const PMultiset_basic<PyType> PyType)
(declare-fun PMultiset<PyType> (PyType) PyType)
(declare-fun PMultiset_arg<PyType> (PyType Int) PyType)
(declare-const slice<PyType> PyType)
(declare-const py_range<PyType> PyType)
(declare-const Iterator_basic<PyType> PyType)
(declare-fun Iterator<PyType> (PyType) PyType)
(declare-fun Iterator_arg<PyType> (PyType Int) PyType)
(declare-const Thread_0<PyType> PyType)
(declare-const LevelType<PyType> PyType)
(declare-const type<PyType> PyType)
(declare-const Place<PyType> PyType)
(declare-const __prim__Seq_type<PyType> PyType)
(declare-const Cell<PyType> PyType)
(declare-const CellLock<PyType> PyType)
(declare-const A<PyType> PyType)
(declare-const B<PyType> PyType)
(declare-const Lock_basic<PyType> PyType)
(declare-fun Lock<PyType> (PyType) PyType)
(declare-fun Lock_arg<PyType> (PyType Int) PyType)
(declare-const BaseLock<PyType> PyType)
(declare-fun Measure$create<Measure$> (Bool $Ref Int) Measure$)
(declare-fun Measure$guard<Bool> (Measure$) Bool)
(declare-fun Measure$key<Ref> (Measure$) $Ref)
(declare-fun Measure$value<Int> (Measure$) Int)
(declare-const print_threading<ThreadingID> ThreadingID)
(declare-const __init___threading<ThreadingID> ThreadingID)
(declare-const append_threading<ThreadingID> ThreadingID)
(declare-const extend_threading<ThreadingID> ThreadingID)
(declare-const reverse_threading<ThreadingID> ThreadingID)
(declare-const __setitem___threading<ThreadingID> ThreadingID)
(declare-const __iter___threading<ThreadingID> ThreadingID)
(declare-const __getitem_slice___threading<ThreadingID> ThreadingID)
(declare-const __add___threading<ThreadingID> ThreadingID)
(declare-const __mul___threading<ThreadingID> ThreadingID)
(declare-const __init___threading_0<ThreadingID> ThreadingID)
(declare-const add_threading<ThreadingID> ThreadingID)
(declare-const remove_threading<ThreadingID> ThreadingID)
(declare-const clear_threading<ThreadingID> ThreadingID)
(declare-const __iter___threading_0<ThreadingID> ThreadingID)
(declare-const __init___threading_1<ThreadingID> ThreadingID)
(declare-const keys_threading<ThreadingID> ThreadingID)
(declare-const __setitem___threading_0<ThreadingID> ThreadingID)
(declare-const __iter___threading_1<ThreadingID> ThreadingID)
(declare-const values_threading<ThreadingID> ThreadingID)
(declare-const split_threading<ThreadingID> ThreadingID)
(declare-const __iter___threading_2<ThreadingID> ThreadingID)
(declare-const __next___threading<ThreadingID> ThreadingID)
(declare-const __del___threading<ThreadingID> ThreadingID)
(declare-const sif_print_threading<ThreadingID> ThreadingID)
(declare-const printTwice_threading<ThreadingID> ThreadingID)
(declare-const printZero_threading<ThreadingID> ThreadingID)
(declare-const printOne_threading<ThreadingID> ThreadingID)
(declare-const zero_threading<ThreadingID> ThreadingID)
(declare-const one_threading<ThreadingID> ThreadingID)
(declare-const client_threading<ThreadingID> ThreadingID)
(declare-const fork_lowevent_threading<ThreadingID> ThreadingID)
(declare-const join_low_threading<ThreadingID> ThreadingID)
(declare-const join_low_dyn_bound_threading<ThreadingID> ThreadingID)
(declare-const __init___threading_2<ThreadingID> ThreadingID)
(declare-const foo_threading<ThreadingID> ThreadingID)
(declare-const foo_threading_0<ThreadingID> ThreadingID)
(declare-const __init___threading_3<ThreadingID> ThreadingID)
(declare-const acquire_threading<ThreadingID> ThreadingID)
(declare-const release_threading<ThreadingID> ThreadingID)
(declare-fun seq_ref_length<Int> (Seq<$Ref>) Int)
(declare-fun seq_ref_index<Ref> (Seq<$Ref> Int) $Ref)
(declare-fun _combine<_Name> (_Name _Name) _Name)
(declare-fun _single<_Name> (Int) _Name)
(declare-fun _get_combined_prefix<_Name> (_Name) _Name)
(declare-fun _get_combined_name<_Name> (_Name) _Name)
(declare-fun _get_value<Int> (_Name) Int)
(declare-fun _name_type<Bool> (_Name) Bool)
(declare-fun _is_single<Bool> (_Name) Bool)
(declare-fun _is_combined<Bool> (_Name) Bool)
; Declaring symbols related to program functions (from program analysis)
(declare-fun __prim__bool___box__ ($Snap Bool) $Ref)
(declare-fun __prim__bool___box__%limited ($Snap Bool) $Ref)
(declare-fun __prim__bool___box__%stateless (Bool) Bool)
(declare-fun __prim__bool___box__%precondition ($Snap Bool) Bool)
(declare-fun bool___unbox__ ($Snap $Ref) Bool)
(declare-fun bool___unbox__%limited ($Snap $Ref) Bool)
(declare-fun bool___unbox__%stateless ($Ref) Bool)
(declare-fun bool___unbox__%precondition ($Snap $Ref) Bool)
(declare-fun int___unbox__ ($Snap $Ref) Int)
(declare-fun int___unbox__%limited ($Snap $Ref) Int)
(declare-fun int___unbox__%stateless ($Ref) Bool)
(declare-fun int___unbox__%precondition ($Snap $Ref) Bool)
(declare-fun __prim__int___box__ ($Snap Int) $Ref)
(declare-fun __prim__int___box__%limited ($Snap Int) $Ref)
(declare-fun __prim__int___box__%stateless (Int) Bool)
(declare-fun __prim__int___box__%precondition ($Snap Int) Bool)
(declare-fun str___val__ ($Snap $Ref) Int)
(declare-fun str___val__%limited ($Snap $Ref) Int)
(declare-fun str___val__%stateless ($Ref) Bool)
(declare-fun str___val__%precondition ($Snap $Ref) Bool)
(declare-fun str___len__ ($Snap $Ref) Int)
(declare-fun str___len__%limited ($Snap $Ref) Int)
(declare-fun str___len__%stateless ($Ref) Bool)
(declare-fun str___len__%precondition ($Snap $Ref) Bool)
(declare-fun Lock_get_locked ($Snap $Ref) $Ref)
(declare-fun Lock_get_locked%limited ($Snap $Ref) $Ref)
(declare-fun Lock_get_locked%stateless ($Ref) Bool)
(declare-fun Lock_get_locked%precondition ($Snap $Ref) Bool)
(declare-fun int___eq__ ($Snap $Ref $Ref) Bool)
(declare-fun int___eq__%limited ($Snap $Ref $Ref) Bool)
(declare-fun int___eq__%stateless ($Ref $Ref) Bool)
(declare-fun int___eq__%precondition ($Snap $Ref $Ref) Bool)
(declare-fun _isDefined ($Snap Int) Bool)
(declare-fun _isDefined%limited ($Snap Int) Bool)
(declare-fun _isDefined%stateless (Int) Bool)
(declare-fun _isDefined%precondition ($Snap Int) Bool)
(declare-fun Level ($Snap $Ref) $Perm)
(declare-fun Level%limited ($Snap $Ref) $Perm)
(declare-fun Level%stateless ($Ref) Bool)
(declare-fun Level%precondition ($Snap $Ref) Bool)
(declare-fun str___create__ ($Snap Int Int) $Ref)
(declare-fun str___create__%limited ($Snap Int Int) $Ref)
(declare-fun str___create__%stateless (Int Int) Bool)
(declare-fun str___create__%precondition ($Snap Int Int) Bool)
(declare-fun Measure$check ($Snap Seq<Measure$> $Ref Int) Bool)
(declare-fun Measure$check%limited ($Snap Seq<Measure$> $Ref Int) Bool)
(declare-fun Measure$check%stateless (Seq<Measure$> $Ref Int) Bool)
(declare-fun Measure$check%precondition ($Snap Seq<Measure$> $Ref Int) Bool)
(declare-fun __name___0 ($Snap) $Ref)
(declare-fun __name___0%limited ($Snap) $Ref)
(declare-const __name___0%stateless Bool)
(declare-fun __name___0%precondition ($Snap) Bool)
(declare-fun _joinable ($Snap $Ref) Bool)
(declare-fun _joinable%limited ($Snap $Ref) Bool)
(declare-fun _joinable%stateless ($Ref) Bool)
(declare-fun _joinable%precondition ($Snap $Ref) Bool)
(declare-fun str___eq__ ($Snap $Ref $Ref) Bool)
(declare-fun str___eq__%limited ($Snap $Ref $Ref) Bool)
(declare-fun str___eq__%stateless ($Ref $Ref) Bool)
(declare-fun str___eq__%precondition ($Snap $Ref $Ref) Bool)
(declare-fun Lock_invariant_low ($Snap $Ref $Ref) Bool)
(declare-fun Lock_invariant_low%limited ($Snap $Ref $Ref) Bool)
(declare-fun Lock_invariant_low%stateless ($Ref $Ref) Bool)
(declare-fun Lock_invariant_low%precondition ($Snap $Ref $Ref) Bool)
(declare-fun __file___0 ($Snap) $Ref)
(declare-fun __file___0%limited ($Snap) $Ref)
(declare-const __file___0%stateless Bool)
(declare-fun __file___0%precondition ($Snap) Bool)
(declare-fun __file__ ($Snap) $Ref)
(declare-fun __file__%limited ($Snap) $Ref)
(declare-const __file__%stateless Bool)
(declare-fun __file__%precondition ($Snap) Bool)
(declare-fun _checkDefined ($Snap $Ref Int) $Ref)
(declare-fun _checkDefined%limited ($Snap $Ref Int) $Ref)
(declare-fun _checkDefined%stateless ($Ref Int) Bool)
(declare-fun _checkDefined%precondition ($Snap $Ref Int) Bool)
(declare-fun __name__ ($Snap) $Ref)
(declare-fun __name__%limited ($Snap) $Ref)
(declare-const __name__%stateless Bool)
(declare-fun __name__%precondition ($Snap) Bool)
(declare-fun Lock_invariant_all_low ($Snap $Ref $Ref) Bool)
(declare-fun Lock_invariant_all_low%limited ($Snap $Ref $Ref) Bool)
(declare-fun Lock_invariant_all_low%stateless ($Ref $Ref) Bool)
(declare-fun Lock_invariant_all_low%precondition ($Snap $Ref $Ref) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun MustTerminate%trigger ($Snap $Ref) Bool)
(declare-fun MustTerminate_0%trigger ($Snap $Ref) Bool)
(declare-fun MustInvokeBounded%trigger ($Snap $Ref) Bool)
(declare-fun MustInvokeBounded_0%trigger ($Snap $Ref) Bool)
(declare-fun MustInvokeUnbounded%trigger ($Snap $Ref) Bool)
(declare-fun MustInvokeUnbounded_0%trigger ($Snap $Ref) Bool)
(declare-fun _thread_start%trigger ($Snap $Ref) Bool)
(declare-fun _thread_start_0%trigger ($Snap $Ref) Bool)
(declare-fun _thread_post%trigger ($Snap $Ref) Bool)
(declare-fun _thread_post_0%trigger ($Snap $Ref) Bool)
(declare-fun _MaySet%trigger ($Snap $Ref Int) Bool)
(declare-fun _MaySet_0%trigger ($Snap $Ref Int) Bool)
(declare-fun Lock_invariant%trigger ($Snap $Ref) Bool)
(declare-fun Lock_invariant_0%trigger ($Snap $Ref) Bool)
; ////////// Uniqueness assumptions from domains
(assert (distinct bool<PyType> float<PyType> bytes<PyType> Cell<PyType> slice<PyType> list_basic<PyType> set_basic<PyType> ConnectionRefusedError<PyType> PMultiset_basic<PyType> BaseLock<PyType> Iterator_basic<PyType> Lock_basic<PyType> traceback<PyType> dict_basic<PyType> type<PyType> B<PyType> PSet_basic<PyType> py_range<PyType> int<PyType> Exception<PyType> __prim__Seq_type<PyType> tuple_basic<PyType> str<PyType> PSeq_basic<PyType> A<PyType> object<PyType> CellLock<PyType> Thread_0<PyType> Place<PyType> LevelType<PyType> NoneType<PyType>))
(assert (distinct printTwice_threading<ThreadingID> __iter___threading<ThreadingID> __add___threading<ThreadingID> __init___threading_1<ThreadingID> __mul___threading<ThreadingID> __getitem_slice___threading<ThreadingID> acquire_threading<ThreadingID> extend_threading<ThreadingID> __iter___threading_1<ThreadingID> one_threading<ThreadingID> foo_threading_0<ThreadingID> __setitem___threading<ThreadingID> foo_threading<ThreadingID> __init___threading_0<ThreadingID> __iter___threading_0<ThreadingID> clear_threading<ThreadingID> printOne_threading<ThreadingID> append_threading<ThreadingID> __init___threading_2<ThreadingID> join_low_dyn_bound_threading<ThreadingID> values_threading<ThreadingID> __iter___threading_2<ThreadingID> add_threading<ThreadingID> remove_threading<ThreadingID> join_low_threading<ThreadingID> zero_threading<ThreadingID> keys_threading<ThreadingID> print_threading<ThreadingID> __del___threading<ThreadingID> __init___threading<ThreadingID> printZero_threading<ThreadingID> __next___threading<ThreadingID> fork_lowevent_threading<ThreadingID> release_threading<ThreadingID> __init___threading_3<ThreadingID> reverse_threading<ThreadingID> split_threading<ThreadingID> __setitem___threading_0<ThreadingID> sif_print_threading<ThreadingID> client_threading<ThreadingID>))
; ////////// Axioms
(assert (forall ((s Seq<PyType>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  )))
(assert (= (Seq_length (as Seq_empty  Seq<PyType>)) 0))
(assert (forall ((s Seq<PyType>)) (!
  (=> (= (Seq_length s) 0) (= s (as Seq_empty  Seq<PyType>)))
  :pattern ((Seq_length s))
  )))
(assert (forall ((e PyType)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((s0 Seq<PyType>) (s1 Seq<PyType>)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<PyType>)))
      (not (= s1 (as Seq_empty  Seq<PyType>))))
    (= (Seq_length (Seq_append s0 s1)) (+ (Seq_length s0) (Seq_length s1))))
  :pattern ((Seq_length (Seq_append s0 s1)))
  )))
(assert (forall ((s0 Seq<PyType>) (s1 Seq<PyType>)) (!
  (and
    (=> (= s0 (as Seq_empty  Seq<PyType>)) (= (Seq_append s0 s1) s1))
    (=> (= s1 (as Seq_empty  Seq<PyType>)) (= (Seq_append s0 s1) s0)))
  :pattern ((Seq_append s0 s1))
  )))
(assert (forall ((e PyType)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((i Int) (j Int)) (!
  (= (Seq_add i j) (+ i j))
  :pattern ((Seq_add i j))
  )))
(assert (forall ((i Int) (j Int)) (!
  (= (Seq_sub i j) (- i j))
  :pattern ((Seq_sub i j))
  )))
(assert (forall ((s0 Seq<PyType>) (s1 Seq<PyType>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<PyType>)))
      (and
        (not (= s1 (as Seq_empty  Seq<PyType>)))
        (and (<= 0 n) (< n (Seq_length s0)))))
    (= (Seq_index (Seq_append s0 s1) n) (Seq_index s0 n)))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  :pattern ((Seq_index s0 n) (Seq_append s0 s1))
  )))
(assert (forall ((s0 Seq<PyType>) (s1 Seq<PyType>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<PyType>)))
      (and
        (not (= s1 (as Seq_empty  Seq<PyType>)))
        (and (<= (Seq_length s0) n) (< n (Seq_length (Seq_append s0 s1))))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s0)) (Seq_length s0)) n)
      (=
        (Seq_index (Seq_append s0 s1) n)
        (Seq_index s1 (Seq_sub n (Seq_length s0))))))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  )))
(assert (forall ((s0 Seq<PyType>) (s1 Seq<PyType>) (m Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<PyType>)))
      (and
        (not (= s1 (as Seq_empty  Seq<PyType>)))
        (and (<= 0 m) (< m (Seq_length s1)))))
    (and
      (= (Seq_sub (Seq_add m (Seq_length s0)) (Seq_length s0)) m)
      (=
        (Seq_index (Seq_append s0 s1) (Seq_add m (Seq_length s0)))
        (Seq_index s1 m))))
  :pattern ((Seq_index s1 m) (Seq_append s0 s1))
  )))
(assert (forall ((s Seq<PyType>) (i Int) (v PyType)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i v)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i v)))
  :pattern ((Seq_length s) (Seq_update s i v))
  )))
(assert (forall ((s Seq<PyType>) (i Int) (v PyType) (n Int)) (!
  (=>
    (and (<= 0 n) (< n (Seq_length s)))
    (and
      (=> (= i n) (= (Seq_index (Seq_update s i v) n) v))
      (=> (not (= i n)) (= (Seq_index (Seq_update s i v) n) (Seq_index s n)))))
  :pattern ((Seq_index (Seq_update s i v) n))
  :pattern ((Seq_index s n) (Seq_update s i v))
  )))
(assert (forall ((s Seq<PyType>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=> (<= n (Seq_length s)) (= (Seq_length (Seq_take s n)) n))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_take s n)) (Seq_length s)))))
    (=> (< n 0) (= (Seq_length (Seq_take s n)) 0)))
  :pattern ((Seq_length (Seq_take s n)))
  :pattern ((Seq_take s n) (Seq_length s))
  )))
(assert (forall ((s Seq<PyType>) (n Int) (j Int)) (!
  (=>
    (and (<= 0 j) (and (< j n) (< j (Seq_length s))))
    (= (Seq_index (Seq_take s n) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_take s n) j))
  :pattern ((Seq_index s j) (Seq_take s n))
  )))
(assert (forall ((s Seq<PyType>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=>
          (<= n (Seq_length s))
          (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n)))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_drop s n)) 0))))
    (=> (< n 0) (= (Seq_length (Seq_drop s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_drop s n)))
  :pattern ((Seq_length s) (Seq_drop s n))
  )))
(assert (forall ((s Seq<PyType>) (n Int) (j Int)) (!
  (=>
    (and (< 0 n) (and (<= 0 j) (< j (- (Seq_length s) n))))
    (and
      (= (Seq_sub (Seq_add j n) n) j)
      (= (Seq_index (Seq_drop s n) j) (Seq_index s (Seq_add j n)))))
  :pattern ((Seq_index (Seq_drop s n) j))
  )))
(assert (forall ((s Seq<PyType>) (n Int) (i Int)) (!
  (=>
    (and (< 0 n) (and (<= n i) (< i (Seq_length s))))
    (and
      (= (Seq_add (Seq_sub i n) n) i)
      (= (Seq_index (Seq_drop s n) (Seq_sub i n)) (Seq_index s i))))
  :pattern ((Seq_drop s n) (Seq_index s i))
  )))
(assert (forall ((s Seq<PyType>) (t Seq<PyType>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_take (Seq_append s t) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<PyType>) (t Seq<PyType>) (n Int)) (!
  (=>
    (and (> n 0) (and (> n (Seq_length s)) (< n (Seq_length (Seq_append s t)))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (=
        (Seq_take (Seq_append s t) n)
        (Seq_append s (Seq_take t (Seq_sub n (Seq_length s)))))))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<PyType>) (t Seq<PyType>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_append s t) n) (Seq_append (Seq_drop s n) t)))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<PyType>) (t Seq<PyType>) (n Int)) (!
  (=>
    (and (> n 0) (> n (Seq_length s)))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (= (Seq_drop (Seq_append s t) n) (Seq_drop t (Seq_sub n (Seq_length s))))))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<PyType>) (n Int)) (!
  (=> (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<PyType>)))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<PyType>) (n Int)) (!
  (=> (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<PyType>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_take s n) s))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<PyType>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_drop s n) (as Seq_empty  Seq<PyType>)))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<PyType>) (x PyType)) (!
  (=>
    (Seq_contains s x)
    (and
      (<= 0 (Seq_skolem s x))
      (and
        (< (Seq_skolem s x) (Seq_length s))
        (= (Seq_index s (Seq_skolem s x)) x))))
  :pattern ((Seq_contains s x))
  )))
(assert (forall ((s Seq<PyType>) (x PyType) (i Int)) (!
  (=>
    (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) x)))
    (Seq_contains s x))
  :pattern ((Seq_contains s x) (Seq_index s i))
  )))
(assert (forall ((s Seq<PyType>) (i Int)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (Seq_contains_trigger s (Seq_index s i)))
  :pattern ((Seq_index s i))
  )))
(assert (forall ((s0 Seq<PyType>) (s1 Seq<PyType>)) (!
  (or
    (and (= s0 s1) (Seq_equal s0 s1))
    (or
      (and
        (not (= s0 s1))
        (and (not (Seq_equal s0 s1)) (not (= (Seq_length s0) (Seq_length s1)))))
      (and
        (not (= s0 s1))
        (and
          (not (Seq_equal s0 s1))
          (and
            (= (Seq_length s0) (Seq_length s1))
            (and
              (= (Seq_skolem_diff s0 s1) (Seq_skolem_diff s1 s0))
              (and
                (<= 0 (Seq_skolem_diff s0 s1))
                (and
                  (< (Seq_skolem_diff s0 s1) (Seq_length s0))
                  (not
                    (=
                      (Seq_index s0 (Seq_skolem_diff s0 s1))
                      (Seq_index s1 (Seq_skolem_diff s0 s1))))))))))))
  :pattern ((Seq_equal s0 s1))
  )))
(assert (forall ((a Seq<PyType>) (b Seq<PyType>)) (!
  (=> (Seq_equal a b) (= a b))
  :pattern ((Seq_equal a b))
  )))
(assert (forall ((x PyType) (y PyType)) (!
  (= (Seq_contains (Seq_singleton x) y) (= x y))
  :pattern ((Seq_contains (Seq_singleton x) y))
  )))
(assert (forall ((s Seq<Measure$>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  )))
(assert (= (Seq_length (as Seq_empty  Seq<Measure$>)) 0))
(assert (forall ((s Seq<Measure$>)) (!
  (=> (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Measure$>)))
  :pattern ((Seq_length s))
  )))
(assert (forall ((e Measure$)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((s0 Seq<Measure$>) (s1 Seq<Measure$>)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Measure$>)))
      (not (= s1 (as Seq_empty  Seq<Measure$>))))
    (= (Seq_length (Seq_append s0 s1)) (+ (Seq_length s0) (Seq_length s1))))
  :pattern ((Seq_length (Seq_append s0 s1)))
  )))
(assert (forall ((s0 Seq<Measure$>) (s1 Seq<Measure$>)) (!
  (and
    (=> (= s0 (as Seq_empty  Seq<Measure$>)) (= (Seq_append s0 s1) s1))
    (=> (= s1 (as Seq_empty  Seq<Measure$>)) (= (Seq_append s0 s1) s0)))
  :pattern ((Seq_append s0 s1))
  )))
(assert (forall ((e Measure$)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((s0 Seq<Measure$>) (s1 Seq<Measure$>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Measure$>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Measure$>)))
        (and (<= 0 n) (< n (Seq_length s0)))))
    (= (Seq_index (Seq_append s0 s1) n) (Seq_index s0 n)))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  :pattern ((Seq_index s0 n) (Seq_append s0 s1))
  )))
(assert (forall ((s0 Seq<Measure$>) (s1 Seq<Measure$>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Measure$>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Measure$>)))
        (and (<= (Seq_length s0) n) (< n (Seq_length (Seq_append s0 s1))))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s0)) (Seq_length s0)) n)
      (=
        (Seq_index (Seq_append s0 s1) n)
        (Seq_index s1 (Seq_sub n (Seq_length s0))))))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  )))
(assert (forall ((s0 Seq<Measure$>) (s1 Seq<Measure$>) (m Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Measure$>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Measure$>)))
        (and (<= 0 m) (< m (Seq_length s1)))))
    (and
      (= (Seq_sub (Seq_add m (Seq_length s0)) (Seq_length s0)) m)
      (=
        (Seq_index (Seq_append s0 s1) (Seq_add m (Seq_length s0)))
        (Seq_index s1 m))))
  :pattern ((Seq_index s1 m) (Seq_append s0 s1))
  )))
(assert (forall ((s Seq<Measure$>) (i Int) (v Measure$)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i v)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i v)))
  :pattern ((Seq_length s) (Seq_update s i v))
  )))
(assert (forall ((s Seq<Measure$>) (i Int) (v Measure$) (n Int)) (!
  (=>
    (and (<= 0 n) (< n (Seq_length s)))
    (and
      (=> (= i n) (= (Seq_index (Seq_update s i v) n) v))
      (=> (not (= i n)) (= (Seq_index (Seq_update s i v) n) (Seq_index s n)))))
  :pattern ((Seq_index (Seq_update s i v) n))
  :pattern ((Seq_index s n) (Seq_update s i v))
  )))
(assert (forall ((s Seq<Measure$>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=> (<= n (Seq_length s)) (= (Seq_length (Seq_take s n)) n))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_take s n)) (Seq_length s)))))
    (=> (< n 0) (= (Seq_length (Seq_take s n)) 0)))
  :pattern ((Seq_length (Seq_take s n)))
  :pattern ((Seq_take s n) (Seq_length s))
  )))
(assert (forall ((s Seq<Measure$>) (n Int) (j Int)) (!
  (=>
    (and (<= 0 j) (and (< j n) (< j (Seq_length s))))
    (= (Seq_index (Seq_take s n) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_take s n) j))
  :pattern ((Seq_index s j) (Seq_take s n))
  )))
(assert (forall ((s Seq<Measure$>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=>
          (<= n (Seq_length s))
          (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n)))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_drop s n)) 0))))
    (=> (< n 0) (= (Seq_length (Seq_drop s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_drop s n)))
  :pattern ((Seq_length s) (Seq_drop s n))
  )))
(assert (forall ((s Seq<Measure$>) (n Int) (j Int)) (!
  (=>
    (and (< 0 n) (and (<= 0 j) (< j (- (Seq_length s) n))))
    (and
      (= (Seq_sub (Seq_add j n) n) j)
      (= (Seq_index (Seq_drop s n) j) (Seq_index s (Seq_add j n)))))
  :pattern ((Seq_index (Seq_drop s n) j))
  )))
(assert (forall ((s Seq<Measure$>) (n Int) (i Int)) (!
  (=>
    (and (< 0 n) (and (<= n i) (< i (Seq_length s))))
    (and
      (= (Seq_add (Seq_sub i n) n) i)
      (= (Seq_index (Seq_drop s n) (Seq_sub i n)) (Seq_index s i))))
  :pattern ((Seq_drop s n) (Seq_index s i))
  )))
(assert (forall ((s Seq<Measure$>) (t Seq<Measure$>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_take (Seq_append s t) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Measure$>) (t Seq<Measure$>) (n Int)) (!
  (=>
    (and (> n 0) (and (> n (Seq_length s)) (< n (Seq_length (Seq_append s t)))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (=
        (Seq_take (Seq_append s t) n)
        (Seq_append s (Seq_take t (Seq_sub n (Seq_length s)))))))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Measure$>) (t Seq<Measure$>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_append s t) n) (Seq_append (Seq_drop s n) t)))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Measure$>) (t Seq<Measure$>) (n Int)) (!
  (=>
    (and (> n 0) (> n (Seq_length s)))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (= (Seq_drop (Seq_append s t) n) (Seq_drop t (Seq_sub n (Seq_length s))))))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Measure$>) (n Int)) (!
  (=> (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Measure$>)))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<Measure$>) (n Int)) (!
  (=> (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<Measure$>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_take s n) s))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<Measure$>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_drop s n) (as Seq_empty  Seq<Measure$>)))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<Measure$>) (x Measure$)) (!
  (=>
    (Seq_contains s x)
    (and
      (<= 0 (Seq_skolem s x))
      (and
        (< (Seq_skolem s x) (Seq_length s))
        (= (Seq_index s (Seq_skolem s x)) x))))
  :pattern ((Seq_contains s x))
  )))
(assert (forall ((s Seq<Measure$>) (x Measure$) (i Int)) (!
  (=>
    (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) x)))
    (Seq_contains s x))
  :pattern ((Seq_contains s x) (Seq_index s i))
  )))
(assert (forall ((s Seq<Measure$>) (i Int)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (Seq_contains_trigger s (Seq_index s i)))
  :pattern ((Seq_index s i))
  )))
(assert (forall ((s0 Seq<Measure$>) (s1 Seq<Measure$>)) (!
  (or
    (and (= s0 s1) (Seq_equal s0 s1))
    (or
      (and
        (not (= s0 s1))
        (and (not (Seq_equal s0 s1)) (not (= (Seq_length s0) (Seq_length s1)))))
      (and
        (not (= s0 s1))
        (and
          (not (Seq_equal s0 s1))
          (and
            (= (Seq_length s0) (Seq_length s1))
            (and
              (= (Seq_skolem_diff s0 s1) (Seq_skolem_diff s1 s0))
              (and
                (<= 0 (Seq_skolem_diff s0 s1))
                (and
                  (< (Seq_skolem_diff s0 s1) (Seq_length s0))
                  (not
                    (=
                      (Seq_index s0 (Seq_skolem_diff s0 s1))
                      (Seq_index s1 (Seq_skolem_diff s0 s1))))))))))))
  :pattern ((Seq_equal s0 s1))
  )))
(assert (forall ((a Seq<Measure$>) (b Seq<Measure$>)) (!
  (=> (Seq_equal a b) (= a b))
  :pattern ((Seq_equal a b))
  )))
(assert (forall ((x Measure$) (y Measure$)) (!
  (= (Seq_contains (Seq_singleton x) y) (= x y))
  :pattern ((Seq_contains (Seq_singleton x) y))
  )))
(assert (forall ((s Seq<$Ref>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  )))
(assert (= (Seq_length (as Seq_empty  Seq<$Ref>)) 0))
(assert (forall ((s Seq<$Ref>)) (!
  (=> (= (Seq_length s) 0) (= s (as Seq_empty  Seq<$Ref>)))
  :pattern ((Seq_length s))
  )))
(assert (forall ((e $Ref)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<$Ref>)))
      (not (= s1 (as Seq_empty  Seq<$Ref>))))
    (= (Seq_length (Seq_append s0 s1)) (+ (Seq_length s0) (Seq_length s1))))
  :pattern ((Seq_length (Seq_append s0 s1)))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>)) (!
  (and
    (=> (= s0 (as Seq_empty  Seq<$Ref>)) (= (Seq_append s0 s1) s1))
    (=> (= s1 (as Seq_empty  Seq<$Ref>)) (= (Seq_append s0 s1) s0)))
  :pattern ((Seq_append s0 s1))
  )))
(assert (forall ((e $Ref)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<$Ref>)))
      (and
        (not (= s1 (as Seq_empty  Seq<$Ref>)))
        (and (<= 0 n) (< n (Seq_length s0)))))
    (= (Seq_index (Seq_append s0 s1) n) (Seq_index s0 n)))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  :pattern ((Seq_index s0 n) (Seq_append s0 s1))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<$Ref>)))
      (and
        (not (= s1 (as Seq_empty  Seq<$Ref>)))
        (and (<= (Seq_length s0) n) (< n (Seq_length (Seq_append s0 s1))))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s0)) (Seq_length s0)) n)
      (=
        (Seq_index (Seq_append s0 s1) n)
        (Seq_index s1 (Seq_sub n (Seq_length s0))))))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>) (m Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<$Ref>)))
      (and
        (not (= s1 (as Seq_empty  Seq<$Ref>)))
        (and (<= 0 m) (< m (Seq_length s1)))))
    (and
      (= (Seq_sub (Seq_add m (Seq_length s0)) (Seq_length s0)) m)
      (=
        (Seq_index (Seq_append s0 s1) (Seq_add m (Seq_length s0)))
        (Seq_index s1 m))))
  :pattern ((Seq_index s1 m) (Seq_append s0 s1))
  )))
(assert (forall ((s Seq<$Ref>) (i Int) (v $Ref)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i v)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i v)))
  :pattern ((Seq_length s) (Seq_update s i v))
  )))
(assert (forall ((s Seq<$Ref>) (i Int) (v $Ref) (n Int)) (!
  (=>
    (and (<= 0 n) (< n (Seq_length s)))
    (and
      (=> (= i n) (= (Seq_index (Seq_update s i v) n) v))
      (=> (not (= i n)) (= (Seq_index (Seq_update s i v) n) (Seq_index s n)))))
  :pattern ((Seq_index (Seq_update s i v) n))
  :pattern ((Seq_index s n) (Seq_update s i v))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=> (<= n (Seq_length s)) (= (Seq_length (Seq_take s n)) n))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_take s n)) (Seq_length s)))))
    (=> (< n 0) (= (Seq_length (Seq_take s n)) 0)))
  :pattern ((Seq_length (Seq_take s n)))
  :pattern ((Seq_take s n) (Seq_length s))
  )))
(assert (forall ((s Seq<$Ref>) (n Int) (j Int)) (!
  (=>
    (and (<= 0 j) (and (< j n) (< j (Seq_length s))))
    (= (Seq_index (Seq_take s n) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_take s n) j))
  :pattern ((Seq_index s j) (Seq_take s n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=>
          (<= n (Seq_length s))
          (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n)))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_drop s n)) 0))))
    (=> (< n 0) (= (Seq_length (Seq_drop s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_drop s n)))
  :pattern ((Seq_length s) (Seq_drop s n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int) (j Int)) (!
  (=>
    (and (< 0 n) (and (<= 0 j) (< j (- (Seq_length s) n))))
    (and
      (= (Seq_sub (Seq_add j n) n) j)
      (= (Seq_index (Seq_drop s n) j) (Seq_index s (Seq_add j n)))))
  :pattern ((Seq_index (Seq_drop s n) j))
  )))
(assert (forall ((s Seq<$Ref>) (n Int) (i Int)) (!
  (=>
    (and (< 0 n) (and (<= n i) (< i (Seq_length s))))
    (and
      (= (Seq_add (Seq_sub i n) n) i)
      (= (Seq_index (Seq_drop s n) (Seq_sub i n)) (Seq_index s i))))
  :pattern ((Seq_drop s n) (Seq_index s i))
  )))
(assert (forall ((s Seq<$Ref>) (t Seq<$Ref>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_take (Seq_append s t) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<$Ref>) (t Seq<$Ref>) (n Int)) (!
  (=>
    (and (> n 0) (and (> n (Seq_length s)) (< n (Seq_length (Seq_append s t)))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (=
        (Seq_take (Seq_append s t) n)
        (Seq_append s (Seq_take t (Seq_sub n (Seq_length s)))))))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<$Ref>) (t Seq<$Ref>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_append s t) n) (Seq_append (Seq_drop s n) t)))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<$Ref>) (t Seq<$Ref>) (n Int)) (!
  (=>
    (and (> n 0) (> n (Seq_length s)))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (= (Seq_drop (Seq_append s t) n) (Seq_drop t (Seq_sub n (Seq_length s))))))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (=> (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<$Ref>)))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (=> (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_take s n) s))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_drop s n) (as Seq_empty  Seq<$Ref>)))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<$Ref>) (x $Ref)) (!
  (=>
    (Seq_contains s x)
    (and
      (<= 0 (Seq_skolem s x))
      (and
        (< (Seq_skolem s x) (Seq_length s))
        (= (Seq_index s (Seq_skolem s x)) x))))
  :pattern ((Seq_contains s x))
  )))
(assert (forall ((s Seq<$Ref>) (x $Ref) (i Int)) (!
  (=>
    (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) x)))
    (Seq_contains s x))
  :pattern ((Seq_contains s x) (Seq_index s i))
  )))
(assert (forall ((s Seq<$Ref>) (i Int)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (Seq_contains_trigger s (Seq_index s i)))
  :pattern ((Seq_index s i))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>)) (!
  (or
    (and (= s0 s1) (Seq_equal s0 s1))
    (or
      (and
        (not (= s0 s1))
        (and (not (Seq_equal s0 s1)) (not (= (Seq_length s0) (Seq_length s1)))))
      (and
        (not (= s0 s1))
        (and
          (not (Seq_equal s0 s1))
          (and
            (= (Seq_length s0) (Seq_length s1))
            (and
              (= (Seq_skolem_diff s0 s1) (Seq_skolem_diff s1 s0))
              (and
                (<= 0 (Seq_skolem_diff s0 s1))
                (and
                  (< (Seq_skolem_diff s0 s1) (Seq_length s0))
                  (not
                    (=
                      (Seq_index s0 (Seq_skolem_diff s0 s1))
                      (Seq_index s1 (Seq_skolem_diff s0 s1))))))))))))
  :pattern ((Seq_equal s0 s1))
  )))
(assert (forall ((a Seq<$Ref>) (b Seq<$Ref>)) (!
  (=> (Seq_equal a b) (= a b))
  :pattern ((Seq_equal a b))
  )))
(assert (forall ((x $Ref) (y $Ref)) (!
  (= (Seq_contains (Seq_singleton x) y) (= x y))
  :pattern ((Seq_contains (Seq_singleton x) y))
  )))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Ref)) (!
  (not (Set_in o (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in o (as Set_empty  Set<$Ref>)))
  )))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Ref))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Ref)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Ref) (o $Ref)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Ref)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (o $Ref)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Ref)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<_Name>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o _Name)) (!
  (not (Set_in o (as Set_empty  Set<_Name>)))
  :pattern ((Set_in o (as Set_empty  Set<_Name>)))
  )))
(assert (forall ((s Set<_Name>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<_Name>)))
    (=> (not (= (Set_card s) 0)) (exists ((x _Name))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r _Name)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r _Name) (o _Name)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r _Name)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<_Name>) (x _Name) (o _Name)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<_Name>) (x _Name)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<_Name>) (x _Name) (y _Name)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<_Name>) (x _Name)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<_Name>) (x _Name)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>) (o _Name)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>) (y _Name)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>) (y _Name)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>) (o _Name)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>) (o _Name)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>) (y _Name)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>)) (!
  (=
    (Set_subset a b)
    (forall ((o _Name)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<_Name>) (b Set<_Name>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((sub PyType) (middle PyType) (super PyType)) (!
  (=>
    (and (issubtype<Bool> sub middle) (issubtype<Bool> middle super))
    (issubtype<Bool> sub super))
  :pattern ((issubtype<Bool> sub middle) (issubtype<Bool> middle super))
  :qid |prog.issubtype_transitivity|)))
(assert (forall ((type_ PyType)) (!
  (issubtype<Bool> type_ type_)
  :pattern ((issubtype<Bool> type_ type_))
  :qid |prog.issubtype_reflexivity|)))
(assert (forall ((sub PyType) (sub2 PyType)) (!
  (=> (extends_<Bool> sub sub2) (issubtype<Bool> sub sub2))
  :pattern ((extends_<Bool> sub sub2))
  :qid |prog.extends_implies_subtype|)))
(assert (forall ((r $Ref)) (!
  (=
    (issubtype<Bool> (typeof<PyType> r) (as NoneType<PyType>  PyType))
    (= r $Ref.null))
  :pattern ((typeof<PyType> r))
  :qid |prog.null_nonetype|)))
(assert (forall ((type_ PyType)) (!
  (issubtype<Bool> type_ (as object<PyType>  PyType))
  :pattern ((issubtype<Bool> type_ (as object<PyType>  PyType)))
  :qid |prog.issubtype_object|)))
(assert (forall ((sub PyType) (sub2 PyType) (super PyType)) (!
  (=>
    (and
      (extends_<Bool> sub super)
      (and (extends_<Bool> sub2 super) (not (= sub sub2))))
    (and (isnotsubtype<Bool> sub sub2) (isnotsubtype<Bool> sub2 sub)))
  :pattern ((extends_<Bool> sub super) (extends_<Bool> sub2 super))
  :qid |prog.issubtype_exclusion|)))
(assert (forall ((sub PyType) (super PyType)) (!
  (=>
    (and (issubtype<Bool> sub super) (not (= sub super)))
    (not (issubtype<Bool> super sub)))
  :pattern ((issubtype<Bool> sub super))
  :pattern ((issubtype<Bool> super sub))
  :qid |prog.issubtype_exclusion_2|)))
(assert (forall ((sub PyType) (middle PyType) (super PyType)) (!
  (=>
    (and (issubtype<Bool> sub middle) (isnotsubtype<Bool> middle super))
    (not (issubtype<Bool> sub super)))
  :pattern ((issubtype<Bool> sub middle) (isnotsubtype<Bool> middle super))
  :qid |prog.issubtype_exclusion_propagation|)))
(assert (forall ((seq Seq<PyType>) (i Int) (Z PyType)) (!
  (=>
    (issubtype<Bool> Z (tuple<PyType> seq))
    (issubtype<Bool> (tuple_arg<PyType> Z i) (Seq_index seq i)))
  :pattern ((tuple<PyType> seq) (tuple_arg<PyType> Z i))
  :qid |prog.tuple_arg_def|)))
(assert (forall ((seq Seq<PyType>) (Z PyType)) (!
  (=>
    (issubtype<Bool> Z (tuple<PyType> seq))
    (= (Seq_length (tuple_args<Seq<PyType>> Z)) (Seq_length seq)))
  :pattern ((issubtype<Bool> Z (tuple<PyType> seq)))
  :qid |prog.tuple_args_def|)))
(assert (forall ((seq1 Seq<PyType>) (seq2 Seq<PyType>)) (!
  (=>
    (and
      (not (Seq_equal seq1 seq2))
      (and
        (= (Seq_length seq1) (Seq_length seq2))
        (forall ((i Int)) (!
          (=>
            (and (>= i 0) (< i (Seq_length seq1)))
            (issubtype<Bool> (Seq_index seq1 i) (Seq_index seq2 i)))
          :pattern ((issubtype<Bool> (Seq_index seq1 i) (Seq_index seq2 i)))
          ))))
    (issubtype<Bool> (tuple<PyType> seq1) (tuple<PyType> seq2)))
  :pattern ((Seq_length seq1) (Seq_length seq2))
  :pattern ((Seq_length seq1) (tuple<PyType> seq2))
  :pattern ((Seq_length seq1) (issubtype<Bool> (tuple<PyType> seq1) (tuple<PyType> seq2)))
  :pattern ((Seq_length seq2) (Seq_length seq1))
  :pattern ((Seq_length seq2) (tuple<PyType> seq1))
  :pattern ((Seq_length seq2) (issubtype<Bool> (tuple<PyType> seq1) (tuple<PyType> seq2)))
  :pattern ((issubtype<Bool> (tuple<PyType> seq1) (tuple<PyType> seq2)))
  :qid |prog.tuple_self_subtype|)))
(assert (forall ((arg_1 PyType) (X PyType)) (!
  (= (issubtype<Bool> X (union_type_1<PyType> arg_1)) (issubtype<Bool> X arg_1))
  :pattern ((issubtype<Bool> X (union_type_1<PyType> arg_1)))
  :qid |prog.union_subtype_1|)))
(assert (forall ((arg_1 PyType) (arg_2 PyType) (X PyType)) (!
  (=
    (issubtype<Bool> X (union_type_2<PyType> arg_1 arg_2))
    (or (issubtype<Bool> X arg_1) (issubtype<Bool> X arg_2)))
  :pattern ((issubtype<Bool> X (union_type_2<PyType> arg_1 arg_2)))
  :qid |prog.union_subtype_2|)))
(assert (forall ((arg_1 PyType) (arg_2 PyType) (arg_3 PyType) (X PyType)) (!
  (=
    (issubtype<Bool> X (union_type_3<PyType> arg_1 arg_2 arg_3))
    (or
      (issubtype<Bool> X arg_1)
      (or (issubtype<Bool> X arg_2) (issubtype<Bool> X arg_3))))
  :pattern ((issubtype<Bool> X (union_type_3<PyType> arg_1 arg_2 arg_3)))
  :qid |prog.union_subtype_3|)))
(assert (forall ((arg_1 PyType) (arg_2 PyType) (arg_3 PyType) (arg_4 PyType) (X PyType)) (!
  (=
    (issubtype<Bool> X (union_type_4<PyType> arg_1 arg_2 arg_3 arg_4))
    (or
      (issubtype<Bool> X arg_1)
      (or
        (issubtype<Bool> X arg_2)
        (or (issubtype<Bool> X arg_3) (issubtype<Bool> X arg_4)))))
  :pattern ((issubtype<Bool> X (union_type_4<PyType> arg_1 arg_2 arg_3 arg_4)))
  :qid |prog.union_subtype_4|)))
(assert (forall ((arg_1 PyType) (X PyType)) (!
  (= (issubtype<Bool> (union_type_1<PyType> arg_1) X) (issubtype<Bool> arg_1 X))
  :pattern ((issubtype<Bool> (union_type_1<PyType> arg_1) X))
  :qid |prog.subtype_union_1|)))
(assert (forall ((arg_1 PyType) (arg_2 PyType) (X PyType)) (!
  (=
    (issubtype<Bool> (union_type_2<PyType> arg_1 arg_2) X)
    (and (issubtype<Bool> arg_1 X) (issubtype<Bool> arg_2 X)))
  :pattern ((issubtype<Bool> (union_type_2<PyType> arg_1 arg_2) X))
  :qid |prog.subtype_union_2|)))
(assert (forall ((arg_1 PyType) (arg_2 PyType) (arg_3 PyType) (X PyType)) (!
  (=
    (issubtype<Bool> (union_type_3<PyType> arg_1 arg_2 arg_3) X)
    (and
      (issubtype<Bool> arg_1 X)
      (and (issubtype<Bool> arg_2 X) (issubtype<Bool> arg_3 X))))
  :pattern ((issubtype<Bool> (union_type_3<PyType> arg_1 arg_2 arg_3) X))
  :qid |prog.subtype_union_3|)))
(assert (forall ((arg_1 PyType) (arg_2 PyType) (arg_3 PyType) (arg_4 PyType) (X PyType)) (!
  (=
    (issubtype<Bool> (union_type_4<PyType> arg_1 arg_2 arg_3 arg_4) X)
    (and
      (issubtype<Bool> arg_1 X)
      (and
        (issubtype<Bool> arg_2 X)
        (and (issubtype<Bool> arg_3 X) (issubtype<Bool> arg_4 X)))))
  :pattern ((issubtype<Bool> (union_type_4<PyType> arg_1 arg_2 arg_3 arg_4) X))
  :qid |prog.subtype_union_4|)))
(assert (forall ((var0 PyType)) (!
  (and
    (extends_<Bool> (list<PyType> var0) (as object<PyType>  PyType))
    (= (get_basic<PyType> (list<PyType> var0)) (as list_basic<PyType>  PyType)))
  :pattern ((list<PyType> var0))
  :qid |prog.subtype_list|)))
(assert (forall ((Z PyType) (arg0 PyType)) (!
  (=> (issubtype<Bool> Z (list<PyType> arg0)) (= (list_arg<PyType> Z 0) arg0))
  :pattern ((list<PyType> arg0) (list_arg<PyType> Z 0))
  :qid |prog.list_args0|)))
(assert (forall ((var0 PyType)) (!
  (and
    (extends_<Bool> (set<PyType> var0) (as object<PyType>  PyType))
    (= (get_basic<PyType> (set<PyType> var0)) (as set_basic<PyType>  PyType)))
  :pattern ((set<PyType> var0))
  :qid |prog.subtype_set|)))
(assert (forall ((Z PyType) (arg0 PyType)) (!
  (=> (issubtype<Bool> Z (set<PyType> arg0)) (= (set_arg<PyType> Z 0) arg0))
  :pattern ((set<PyType> arg0) (set_arg<PyType> Z 0))
  :qid |prog.set_args0|)))
(assert (forall ((var0 PyType) (var1 PyType)) (!
  (and
    (extends_<Bool> (dict<PyType> var0 var1) (as object<PyType>  PyType))
    (=
      (get_basic<PyType> (dict<PyType> var0 var1))
      (as dict_basic<PyType>  PyType)))
  :pattern ((dict<PyType> var0 var1))
  :qid |prog.subtype_dict|)))
(assert (forall ((Z PyType) (arg0 PyType) (arg1 PyType)) (!
  (=>
    (issubtype<Bool> Z (dict<PyType> arg0 arg1))
    (= (dict_arg<PyType> Z 0) arg0))
  :pattern ((dict<PyType> arg0 arg1) (dict_arg<PyType> Z 0))
  :qid |prog.dict_args0|)))
(assert (forall ((Z PyType) (arg0 PyType) (arg1 PyType)) (!
  (=>
    (issubtype<Bool> Z (dict<PyType> arg0 arg1))
    (= (dict_arg<PyType> Z 1) arg1))
  :pattern ((dict<PyType> arg0 arg1) (dict_arg<PyType> Z 1))
  :qid |prog.dict_args1|)))
(assert (and
  (extends_<Bool> (as int<PyType>  PyType) (as float<PyType>  PyType))
  (= (get_basic<PyType> (as int<PyType>  PyType)) (as int<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as float<PyType>  PyType) (as object<PyType>  PyType))
  (= (get_basic<PyType> (as float<PyType>  PyType)) (as float<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as bool<PyType>  PyType) (as int<PyType>  PyType))
  (= (get_basic<PyType> (as bool<PyType>  PyType)) (as bool<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as NoneType<PyType>  PyType) (as object<PyType>  PyType))
  (=
    (get_basic<PyType> (as NoneType<PyType>  PyType))
    (as NoneType<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as Exception<PyType>  PyType) (as object<PyType>  PyType))
  (=
    (get_basic<PyType> (as Exception<PyType>  PyType))
    (as Exception<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as ConnectionRefusedError<PyType>  PyType) (as Exception<PyType>  PyType))
  (=
    (get_basic<PyType> (as ConnectionRefusedError<PyType>  PyType))
    (as ConnectionRefusedError<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as traceback<PyType>  PyType) (as object<PyType>  PyType))
  (=
    (get_basic<PyType> (as traceback<PyType>  PyType))
    (as traceback<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as str<PyType>  PyType) (as object<PyType>  PyType))
  (= (get_basic<PyType> (as str<PyType>  PyType)) (as str<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as bytes<PyType>  PyType) (as object<PyType>  PyType))
  (= (get_basic<PyType> (as bytes<PyType>  PyType)) (as bytes<PyType>  PyType))))
(assert (forall ((args Seq<PyType>)) (!
  (and
    (=>
      (forall ((e PyType)) (!
        (=> (Seq_contains args e) (= e (as object<PyType>  PyType)))
        :pattern ((Seq_contains args e))
        :pattern ((Seq_contains_trigger args e))
        ))
      (extends_<Bool> (tuple<PyType> args) (as object<PyType>  PyType)))
    (= (get_basic<PyType> (tuple<PyType> args)) (as tuple_basic<PyType>  PyType)))
  :pattern ((tuple<PyType> args))
  :qid |prog.subtype_tuple|)))
(assert (forall ((var0 PyType)) (!
  (and
    (extends_<Bool> (PSeq<PyType> var0) (as object<PyType>  PyType))
    (= (get_basic<PyType> (PSeq<PyType> var0)) (as PSeq_basic<PyType>  PyType)))
  :pattern ((PSeq<PyType> var0))
  :qid |prog.subtype_PSeq|)))
(assert (forall ((Z PyType) (arg0 PyType)) (!
  (=> (issubtype<Bool> Z (PSeq<PyType> arg0)) (= (PSeq_arg<PyType> Z 0) arg0))
  :pattern ((PSeq<PyType> arg0) (PSeq_arg<PyType> Z 0))
  :qid |prog.PSeq_args0|)))
(assert (forall ((var0 PyType)) (!
  (and
    (extends_<Bool> (PSet<PyType> var0) (as object<PyType>  PyType))
    (= (get_basic<PyType> (PSet<PyType> var0)) (as PSet_basic<PyType>  PyType)))
  :pattern ((PSet<PyType> var0))
  :qid |prog.subtype_PSet|)))
(assert (forall ((Z PyType) (arg0 PyType)) (!
  (=> (issubtype<Bool> Z (PSet<PyType> arg0)) (= (PSet_arg<PyType> Z 0) arg0))
  :pattern ((PSet<PyType> arg0) (PSet_arg<PyType> Z 0))
  :qid |prog.PSet_args0|)))
(assert (forall ((var0 PyType)) (!
  (and
    (extends_<Bool> (PMultiset<PyType> var0) (as object<PyType>  PyType))
    (=
      (get_basic<PyType> (PMultiset<PyType> var0))
      (as PMultiset_basic<PyType>  PyType)))
  :pattern ((PMultiset<PyType> var0))
  :qid |prog.subtype_PMultiset|)))
(assert (forall ((Z PyType) (arg0 PyType)) (!
  (=>
    (issubtype<Bool> Z (PMultiset<PyType> arg0))
    (= (PMultiset_arg<PyType> Z 0) arg0))
  :pattern ((PMultiset<PyType> arg0) (PMultiset_arg<PyType> Z 0))
  :qid |prog.PMultiset_args0|)))
(assert (and
  (extends_<Bool> (as slice<PyType>  PyType) (as object<PyType>  PyType))
  (= (get_basic<PyType> (as slice<PyType>  PyType)) (as slice<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as py_range<PyType>  PyType) (as object<PyType>  PyType))
  (=
    (get_basic<PyType> (as py_range<PyType>  PyType))
    (as py_range<PyType>  PyType))))
(assert (forall ((var0 PyType)) (!
  (and
    (extends_<Bool> (Iterator<PyType> var0) (as object<PyType>  PyType))
    (=
      (get_basic<PyType> (Iterator<PyType> var0))
      (as Iterator_basic<PyType>  PyType)))
  :pattern ((Iterator<PyType> var0))
  :qid |prog.subtype_Iterator|)))
(assert (forall ((Z PyType) (arg0 PyType)) (!
  (=>
    (issubtype<Bool> Z (Iterator<PyType> arg0))
    (= (Iterator_arg<PyType> Z 0) arg0))
  :pattern ((Iterator<PyType> arg0) (Iterator_arg<PyType> Z 0))
  :qid |prog.Iterator_args0|)))
(assert (and
  (extends_<Bool> (as Thread_0<PyType>  PyType) (as object<PyType>  PyType))
  (=
    (get_basic<PyType> (as Thread_0<PyType>  PyType))
    (as Thread_0<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as LevelType<PyType>  PyType) (as object<PyType>  PyType))
  (=
    (get_basic<PyType> (as LevelType<PyType>  PyType))
    (as LevelType<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as type<PyType>  PyType) (as object<PyType>  PyType))
  (= (get_basic<PyType> (as type<PyType>  PyType)) (as type<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as Place<PyType>  PyType) (as object<PyType>  PyType))
  (= (get_basic<PyType> (as Place<PyType>  PyType)) (as Place<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as __prim__Seq_type<PyType>  PyType) (as object<PyType>  PyType))
  (=
    (get_basic<PyType> (as __prim__Seq_type<PyType>  PyType))
    (as __prim__Seq_type<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as Cell<PyType>  PyType) (as object<PyType>  PyType))
  (= (get_basic<PyType> (as Cell<PyType>  PyType)) (as Cell<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as CellLock<PyType>  PyType) (Lock<PyType> (as Cell<PyType>  PyType)))
  (=
    (get_basic<PyType> (as CellLock<PyType>  PyType))
    (as CellLock<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as A<PyType>  PyType) (as object<PyType>  PyType))
  (= (get_basic<PyType> (as A<PyType>  PyType)) (as A<PyType>  PyType))))
(assert (and
  (extends_<Bool> (as B<PyType>  PyType) (as A<PyType>  PyType))
  (= (get_basic<PyType> (as B<PyType>  PyType)) (as B<PyType>  PyType))))
(assert (forall ((T PyType)) (!
  (and
    (extends_<Bool> (Lock<PyType> T) (as BaseLock<PyType>  PyType))
    (= (get_basic<PyType> (Lock<PyType> T)) (as Lock_basic<PyType>  PyType)))
  :pattern ((Lock<PyType> T))
  :qid |prog.subtype_Lock|)))
(assert (forall ((Z PyType) (arg0 PyType)) (!
  (=> (issubtype<Bool> Z (Lock<PyType> arg0)) (= (Lock_arg<PyType> Z 0) arg0))
  :pattern ((Lock<PyType> arg0) (Lock_arg<PyType> Z 0))
  :qid |prog.Lock_args0|)))
(assert (and
  (extends_<Bool> (as BaseLock<PyType>  PyType) (as object<PyType>  PyType))
  (=
    (get_basic<PyType> (as BaseLock<PyType>  PyType))
    (as BaseLock<PyType>  PyType))))
(assert (forall ((g Bool) (k $Ref) (v Int)) (!
  (= (Measure$guard<Bool> (Measure$create<Measure$> g k v)) g)
  :pattern ((Measure$guard<Bool> (Measure$create<Measure$> g k v)))
  :qid |prog.Measure$A0|)))
(assert (forall ((g Bool) (k $Ref) (v Int)) (!
  (= (Measure$key<Ref> (Measure$create<Measure$> g k v)) k)
  :pattern ((Measure$key<Ref> (Measure$create<Measure$> g k v)))
  :qid |prog.Measure$A1|)))
(assert (forall ((g Bool) (k $Ref) (v Int)) (!
  (= (Measure$value<Int> (Measure$create<Measure$> g k v)) v)
  :pattern ((Measure$value<Int> (Measure$create<Measure$> g k v)))
  :qid |prog.Measure$A2|)))
(assert (forall ((___s Seq<$Ref>)) (!
  (= (Seq_length ___s) (seq_ref_length<Int> ___s))
  :pattern ((Seq_length ___s))
  :qid |prog.relate_length|)))
(assert (forall ((___s Seq<$Ref>) (___i Int)) (!
  (= (Seq_index ___s ___i) (seq_ref_index<Ref> ___s ___i))
  :pattern ((Seq_index ___s ___i))
  :qid |prog.relate_index|)))
(assert (forall ((i Int)) (!
  (= (_get_value<Int> (_single<_Name> i)) i)
  :pattern ((_single<_Name> i))
  :qid |prog.decompose_single|)))
(assert (forall ((n _Name)) (!
  (=> (_is_single<Bool> n) (= n (_single<_Name> (_get_value<Int> n))))
  :pattern ((_get_value<Int> n))
  :qid |prog.compose_single|)))
(assert (forall ((i Int)) (!
  (_name_type<Bool> (_single<_Name> i))
  :pattern ((_single<_Name> i))
  :qid |prog.type_of_single|)))
(assert (forall ((n1 _Name) (n2 _Name)) (!
  (and
    (= (_get_combined_prefix<_Name> (_combine<_Name> n1 n2)) n1)
    (= (_get_combined_name<_Name> (_combine<_Name> n1 n2)) n2))
  :pattern ((_combine<_Name> n1 n2))
  :qid |prog.decompose_combined|)))
(assert (forall ((n _Name)) (!
  (=>
    (_is_combined<Bool> n)
    (=
      n
      (_combine<_Name> (_get_combined_prefix<_Name> n) (_get_combined_name<_Name> n))))
  :pattern ((_get_combined_prefix<_Name> n))
  :pattern ((_get_combined_name<_Name> n))
  :qid |prog.compose_combined|)))
(assert (forall ((n1 _Name) (n2 _Name)) (!
  (not (_name_type<Bool> (_combine<_Name> n1 n2)))
  :pattern ((_combine<_Name> n1 n2))
  :qid |prog.type_of_composed|)))
(assert (forall ((n _Name)) (!
  (= (_name_type<Bool> n) (_is_single<Bool> n))
  :pattern ((_name_type<Bool> n))
  :qid |prog.type_is_single|)))
(assert (forall ((n _Name)) (!
  (= (not (_name_type<Bool> n)) (_is_combined<Bool> n))
  :pattern ((_name_type<Bool> n))
  :qid |prog.type_is_combined|)))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun $k@55@00 () $Perm)
(declare-fun $k@56@00 () $Perm)
(declare-fun joined_unfolding@61@00 ($Snap $Ref $Ref) Bool)
(declare-fun joined_unfolding@64@00 ($Snap $Ref $Ref) Bool)
(declare-fun joined_unfolding@65@00 ($Snap $Ref $Ref) Bool)
(declare-fun $k@57@00 () $Perm)
(declare-fun $k@58@00 () $Perm)
(declare-fun $k@59@00 () $Perm)
(declare-fun $k@60@00 () $Perm)
(declare-fun $k@62@00 () $Perm)
(declare-fun $k@63@00 () $Perm)
(declare-fun $k@66@00 () $Perm)
(declare-fun $k@67@00 () $Perm)
(declare-fun joined_unfolding@72@00 ($Snap $Ref $Ref) Bool)
(declare-fun joined_unfolding@75@00 ($Snap $Ref $Ref) Bool)
(declare-fun joined_unfolding@76@00 ($Snap $Ref $Ref) Bool)
(declare-fun $k@68@00 () $Perm)
(declare-fun $k@69@00 () $Perm)
(declare-fun $k@70@00 () $Perm)
(declare-fun $k@71@00 () $Perm)
(declare-fun $k@73@00 () $Perm)
(declare-fun $k@74@00 () $Perm)
(assert (forall ((s@$ $Snap) (prim@0@00 Bool)) (!
  (=
    (__prim__bool___box__%limited s@$ prim@0@00)
    (__prim__bool___box__ s@$ prim@0@00))
  :pattern ((__prim__bool___box__ s@$ prim@0@00))
  :qid |quant-u-3546|)))
(assert (forall ((s@$ $Snap) (prim@0@00 Bool)) (!
  (__prim__bool___box__%stateless prim@0@00)
  :pattern ((__prim__bool___box__%limited s@$ prim@0@00))
  :qid |quant-u-3547|)))
(assert (forall ((s@$ $Snap) (prim@0@00 Bool)) (!
  (let ((result@1@00 (__prim__bool___box__%limited s@$ prim@0@00))) (=>
    (__prim__bool___box__%precondition s@$ prim@0@00)
    (and
      (= (typeof<PyType> result@1@00) (as bool<PyType>  PyType))
      (= (bool___unbox__%limited $Snap.unit result@1@00) prim@0@00)
      (= (int___unbox__%limited $Snap.unit result@1@00) (ite prim@0@00 1 0)))))
  :pattern ((__prim__bool___box__%limited s@$ prim@0@00))
  :qid |quant-u-3588|)))
(assert (forall ((s@$ $Snap) (prim@0@00 Bool)) (!
  (let ((result@1@00 (__prim__bool___box__%limited s@$ prim@0@00))) true)
  :pattern ((__prim__bool___box__%limited s@$ prim@0@00))
  :qid |quant-u-3589|)))
(assert (forall ((s@$ $Snap) (prim@0@00 Bool)) (!
  (let ((result@1@00 (__prim__bool___box__%limited s@$ prim@0@00))) (=>
    (__prim__bool___box__%precondition s@$ prim@0@00)
    (bool___unbox__%precondition $Snap.unit result@1@00)))
  :pattern ((__prim__bool___box__%limited s@$ prim@0@00))
  :qid |quant-u-3590|)))
(assert (forall ((s@$ $Snap) (prim@0@00 Bool)) (!
  (let ((result@1@00 (__prim__bool___box__%limited s@$ prim@0@00))) (=>
    (__prim__bool___box__%precondition s@$ prim@0@00)
    (int___unbox__%precondition $Snap.unit result@1@00)))
  :pattern ((__prim__bool___box__%limited s@$ prim@0@00))
  :qid |quant-u-3591|)))
(assert (forall ((s@$ $Snap) (box@2@00 $Ref)) (!
  (= (bool___unbox__%limited s@$ box@2@00) (bool___unbox__ s@$ box@2@00))
  :pattern ((bool___unbox__ s@$ box@2@00))
  :qid |quant-u-3548|)))
(assert (forall ((s@$ $Snap) (box@2@00 $Ref)) (!
  (bool___unbox__%stateless box@2@00)
  :pattern ((bool___unbox__%limited s@$ box@2@00))
  :qid |quant-u-3549|)))
(assert (forall ((s@$ $Snap) (box@2@00 $Ref)) (!
  (let ((result@3@00 (bool___unbox__%limited s@$ box@2@00))) (=>
    (bool___unbox__%precondition s@$ box@2@00)
    (= (__prim__bool___box__%limited $Snap.unit result@3@00) box@2@00)))
  :pattern ((bool___unbox__%limited s@$ box@2@00))
  :qid |quant-u-3592|)))
(assert (forall ((s@$ $Snap) (box@2@00 $Ref)) (!
  (let ((result@3@00 (bool___unbox__%limited s@$ box@2@00))) (=>
    (bool___unbox__%precondition s@$ box@2@00)
    (__prim__bool___box__%precondition $Snap.unit result@3@00)))
  :pattern ((bool___unbox__%limited s@$ box@2@00))
  :qid |quant-u-3593|)))
(assert (forall ((s@$ $Snap) (box@4@00 $Ref)) (!
  (= (int___unbox__%limited s@$ box@4@00) (int___unbox__ s@$ box@4@00))
  :pattern ((int___unbox__ s@$ box@4@00))
  :qid |quant-u-3550|)))
(assert (forall ((s@$ $Snap) (box@4@00 $Ref)) (!
  (int___unbox__%stateless box@4@00)
  :pattern ((int___unbox__%limited s@$ box@4@00))
  :qid |quant-u-3551|)))
(assert (forall ((s@$ $Snap) (box@4@00 $Ref)) (!
  (let ((result@5@00 (int___unbox__%limited s@$ box@4@00))) (=>
    (int___unbox__%precondition s@$ box@4@00)
    (and
      (=>
        (not
          (issubtype<Bool> (typeof<PyType> box@4@00) (as bool<PyType>  PyType)))
        (= (__prim__int___box__%limited $Snap.unit result@5@00) box@4@00))
      (=>
        (issubtype<Bool> (typeof<PyType> box@4@00) (as bool<PyType>  PyType))
        (=
          (__prim__bool___box__%limited $Snap.unit (not (= result@5@00 0)))
          box@4@00)))))
  :pattern ((int___unbox__%limited s@$ box@4@00))
  :qid |quant-u-3594|)))
(assert (forall ((s@$ $Snap) (box@4@00 $Ref)) (!
  (let ((result@5@00 (int___unbox__%limited s@$ box@4@00))) (=>
    (and
      (int___unbox__%precondition s@$ box@4@00)
      (not (issubtype<Bool> (typeof<PyType> box@4@00) (as bool<PyType>  PyType))))
    (__prim__int___box__%precondition $Snap.unit result@5@00)))
  :pattern ((int___unbox__%limited s@$ box@4@00))
  :qid |quant-u-3595|)))
(assert (forall ((s@$ $Snap) (box@4@00 $Ref)) (!
  (let ((result@5@00 (int___unbox__%limited s@$ box@4@00))) (=>
    (and
      (int___unbox__%precondition s@$ box@4@00)
      (issubtype<Bool> (typeof<PyType> box@4@00) (as bool<PyType>  PyType)))
    (__prim__bool___box__%precondition $Snap.unit (not (= result@5@00 0)))))
  :pattern ((int___unbox__%limited s@$ box@4@00))
  :qid |quant-u-3596|)))
(assert (forall ((s@$ $Snap) (prim@6@00 Int)) (!
  (=
    (__prim__int___box__%limited s@$ prim@6@00)
    (__prim__int___box__ s@$ prim@6@00))
  :pattern ((__prim__int___box__ s@$ prim@6@00))
  :qid |quant-u-3552|)))
(assert (forall ((s@$ $Snap) (prim@6@00 Int)) (!
  (__prim__int___box__%stateless prim@6@00)
  :pattern ((__prim__int___box__%limited s@$ prim@6@00))
  :qid |quant-u-3553|)))
(assert (forall ((s@$ $Snap) (prim@6@00 Int)) (!
  (let ((result@7@00 (__prim__int___box__%limited s@$ prim@6@00))) (=>
    (__prim__int___box__%precondition s@$ prim@6@00)
    (and
      (= (typeof<PyType> result@7@00) (as int<PyType>  PyType))
      (= (int___unbox__%limited $Snap.unit result@7@00) prim@6@00))))
  :pattern ((__prim__int___box__%limited s@$ prim@6@00))
  :qid |quant-u-3597|)))
(assert (forall ((s@$ $Snap) (prim@6@00 Int)) (!
  (let ((result@7@00 (__prim__int___box__%limited s@$ prim@6@00))) true)
  :pattern ((__prim__int___box__%limited s@$ prim@6@00))
  :qid |quant-u-3598|)))
(assert (forall ((s@$ $Snap) (prim@6@00 Int)) (!
  (let ((result@7@00 (__prim__int___box__%limited s@$ prim@6@00))) (=>
    (__prim__int___box__%precondition s@$ prim@6@00)
    (int___unbox__%precondition $Snap.unit result@7@00)))
  :pattern ((__prim__int___box__%limited s@$ prim@6@00))
  :qid |quant-u-3599|)))
(assert (forall ((s@$ $Snap) (self@8@00 $Ref)) (!
  (= (str___val__%limited s@$ self@8@00) (str___val__ s@$ self@8@00))
  :pattern ((str___val__ s@$ self@8@00))
  :qid |quant-u-3554|)))
(assert (forall ((s@$ $Snap) (self@8@00 $Ref)) (!
  (str___val__%stateless self@8@00)
  :pattern ((str___val__%limited s@$ self@8@00))
  :qid |quant-u-3555|)))
(assert (forall ((s@$ $Snap) (self@10@00 $Ref)) (!
  (= (str___len__%limited s@$ self@10@00) (str___len__ s@$ self@10@00))
  :pattern ((str___len__ s@$ self@10@00))
  :qid |quant-u-3556|)))
(assert (forall ((s@$ $Snap) (self@10@00 $Ref)) (!
  (str___len__%stateless self@10@00)
  :pattern ((str___len__%limited s@$ self@10@00))
  :qid |quant-u-3557|)))
(assert (forall ((s@$ $Snap) (self@10@00 $Ref)) (!
  (let ((result@11@00 (str___len__%limited s@$ self@10@00))) (=>
    (str___len__%precondition s@$ self@10@00)
    (>= result@11@00 0)))
  :pattern ((str___len__%limited s@$ self@10@00))
  :qid |quant-u-3600|)))
(assert (forall ((s@$ $Snap) (self@10@00 $Ref)) (!
  (let ((result@11@00 (str___len__%limited s@$ self@10@00))) true)
  :pattern ((str___len__%limited s@$ self@10@00))
  :qid |quant-u-3601|)))
(assert (forall ((s@$ $Snap) (self_3@12@00 $Ref)) (!
  (=
    (Lock_get_locked%limited s@$ self_3@12@00)
    (Lock_get_locked s@$ self_3@12@00))
  :pattern ((Lock_get_locked s@$ self_3@12@00))
  :qid |quant-u-3558|)))
(assert (forall ((s@$ $Snap) (self_3@12@00 $Ref)) (!
  (Lock_get_locked%stateless self_3@12@00)
  :pattern ((Lock_get_locked%limited s@$ self_3@12@00))
  :qid |quant-u-3559|)))
(assert (forall ((s@$ $Snap) (self_3@12@00 $Ref)) (!
  (let ((result@13@00 (Lock_get_locked%limited s@$ self_3@12@00))) (=>
    (Lock_get_locked%precondition s@$ self_3@12@00)
    (issubtype<Bool> (typeof<PyType> result@13@00) (Lock_arg<PyType> (typeof<PyType> self_3@12@00) 0))))
  :pattern ((Lock_get_locked%limited s@$ self_3@12@00))
  :qid |quant-u-3602|)))
(assert (forall ((s@$ $Snap) (self_3@12@00 $Ref)) (!
  (let ((result@13@00 (Lock_get_locked%limited s@$ self_3@12@00))) true)
  :pattern ((Lock_get_locked%limited s@$ self_3@12@00))
  :qid |quant-u-3603|)))
(assert (forall ((s@$ $Snap) (self@14@00 $Ref) (other@15@00 $Ref)) (!
  (=
    (int___eq__%limited s@$ self@14@00 other@15@00)
    (int___eq__ s@$ self@14@00 other@15@00))
  :pattern ((int___eq__ s@$ self@14@00 other@15@00))
  :qid |quant-u-3560|)))
(assert (forall ((s@$ $Snap) (self@14@00 $Ref) (other@15@00 $Ref)) (!
  (int___eq__%stateless self@14@00 other@15@00)
  :pattern ((int___eq__%limited s@$ self@14@00 other@15@00))
  :qid |quant-u-3561|)))
(assert (forall ((s@$ $Snap) (self@14@00 $Ref) (other@15@00 $Ref)) (!
  (=>
    (int___eq__%precondition s@$ self@14@00 other@15@00)
    (=
      (int___eq__ s@$ self@14@00 other@15@00)
      (=
        (int___unbox__ $Snap.unit self@14@00)
        (int___unbox__ $Snap.unit other@15@00))))
  :pattern ((int___eq__ s@$ self@14@00 other@15@00))
  :qid |quant-u-3604|)))
(assert (forall ((s@$ $Snap) (self@14@00 $Ref) (other@15@00 $Ref)) (!
  (=>
    (int___eq__%precondition s@$ self@14@00 other@15@00)
    (and
      (int___unbox__%precondition $Snap.unit self@14@00)
      (int___unbox__%precondition $Snap.unit other@15@00)))
  :pattern ((int___eq__ s@$ self@14@00 other@15@00))
  :qid |quant-u-3605|)))
(assert (forall ((s@$ $Snap) (id@17@00 Int)) (!
  (= (_isDefined%limited s@$ id@17@00) (_isDefined s@$ id@17@00))
  :pattern ((_isDefined s@$ id@17@00))
  :qid |quant-u-3562|)))
(assert (forall ((s@$ $Snap) (id@17@00 Int)) (!
  (_isDefined%stateless id@17@00)
  :pattern ((_isDefined%limited s@$ id@17@00))
  :qid |quant-u-3563|)))
(assert (forall ((s@$ $Snap) (r@19@00 $Ref)) (!
  (= (Level%limited s@$ r@19@00) (Level s@$ r@19@00))
  :pattern ((Level s@$ r@19@00))
  :qid |quant-u-3564|)))
(assert (forall ((s@$ $Snap) (r@19@00 $Ref)) (!
  (Level%stateless r@19@00)
  :pattern ((Level%limited s@$ r@19@00))
  :qid |quant-u-3565|)))
(assert (forall ((s@$ $Snap) (len@21@00 Int) (value@22@00 Int)) (!
  (=
    (str___create__%limited s@$ len@21@00 value@22@00)
    (str___create__ s@$ len@21@00 value@22@00))
  :pattern ((str___create__ s@$ len@21@00 value@22@00))
  :qid |quant-u-3566|)))
(assert (forall ((s@$ $Snap) (len@21@00 Int) (value@22@00 Int)) (!
  (str___create__%stateless len@21@00 value@22@00)
  :pattern ((str___create__%limited s@$ len@21@00 value@22@00))
  :qid |quant-u-3567|)))
(assert (forall ((s@$ $Snap) (len@21@00 Int) (value@22@00 Int)) (!
  (let ((result@23@00 (str___create__%limited s@$ len@21@00 value@22@00))) (=>
    (str___create__%precondition s@$ len@21@00 value@22@00)
    (and
      (= (str___len__ $Snap.unit result@23@00) len@21@00)
      (= (str___val__ $Snap.unit result@23@00) value@22@00)
      (= (typeof<PyType> result@23@00) (as str<PyType>  PyType)))))
  :pattern ((str___create__%limited s@$ len@21@00 value@22@00))
  :qid |quant-u-3606|)))
(assert (forall ((s@$ $Snap) (len@21@00 Int) (value@22@00 Int)) (!
  (let ((result@23@00 (str___create__%limited s@$ len@21@00 value@22@00))) (=>
    (str___create__%precondition s@$ len@21@00 value@22@00)
    (str___len__%precondition $Snap.unit result@23@00)))
  :pattern ((str___create__%limited s@$ len@21@00 value@22@00))
  :qid |quant-u-3607|)))
(assert (forall ((s@$ $Snap) (len@21@00 Int) (value@22@00 Int)) (!
  (let ((result@23@00 (str___create__%limited s@$ len@21@00 value@22@00))) (=>
    (str___create__%precondition s@$ len@21@00 value@22@00)
    (str___val__%precondition $Snap.unit result@23@00)))
  :pattern ((str___create__%limited s@$ len@21@00 value@22@00))
  :qid |quant-u-3608|)))
(assert (forall ((s@$ $Snap) (len@21@00 Int) (value@22@00 Int)) (!
  (let ((result@23@00 (str___create__%limited s@$ len@21@00 value@22@00))) true)
  :pattern ((str___create__%limited s@$ len@21@00 value@22@00))
  :qid |quant-u-3609|)))
(assert (forall ((s@$ $Snap) (map@24@00 Seq<Measure$>) (key@25@00 $Ref) (value@26@00 Int)) (!
  (=
    (Measure$check%limited s@$ map@24@00 key@25@00 value@26@00)
    (Measure$check s@$ map@24@00 key@25@00 value@26@00))
  :pattern ((Measure$check s@$ map@24@00 key@25@00 value@26@00))
  :qid |quant-u-3568|)))
(assert (forall ((s@$ $Snap) (map@24@00 Seq<Measure$>) (key@25@00 $Ref) (value@26@00 Int)) (!
  (Measure$check%stateless map@24@00 key@25@00 value@26@00)
  :pattern ((Measure$check%limited s@$ map@24@00 key@25@00 value@26@00))
  :qid |quant-u-3569|)))
(assert (forall ((s@$ $Snap) (map@24@00 Seq<Measure$>) (key@25@00 $Ref) (value@26@00 Int)) (!
  (=>
    (Measure$check%precondition s@$ map@24@00 key@25@00 value@26@00)
    (=
      (Measure$check s@$ map@24@00 key@25@00 value@26@00)
      (forall ((m Measure$)) (!
        (=>
          (and
            (Seq_contains map@24@00 m)
            (and (Measure$guard<Bool> m) (= (Measure$key<Ref> m) key@25@00)))
          (> (Measure$value<Int> m) value@26@00))
        :pattern ((Seq_contains map@24@00 m))
        :pattern ((Seq_contains_trigger map@24@00 m))
        :pattern ((Seq_contains_trigger map@24@00 m))
        ))))
  :pattern ((Measure$check s@$ map@24@00 key@25@00 value@26@00))
  :qid |quant-u-3610|)))
(assert (forall ((s@$ $Snap) (map@24@00 Seq<Measure$>) (key@25@00 $Ref) (value@26@00 Int)) (!
  true
  :pattern ((Measure$check s@$ map@24@00 key@25@00 value@26@00))
  :qid |quant-u-3611|)))
(assert (forall ((s@$ $Snap)) (!
  (= (__name___0%limited s@$) (__name___0 s@$))
  :pattern ((__name___0 s@$))
  :qid |quant-u-3570|)))
(assert (forall ((s@$ $Snap)) (!
  (as __name___0%stateless  Bool)
  :pattern ((__name___0%limited s@$))
  :qid |quant-u-3571|)))
(assert (forall ((s@$ $Snap) (t@29@00 $Ref)) (!
  (= (_joinable%limited s@$ t@29@00) (_joinable s@$ t@29@00))
  :pattern ((_joinable s@$ t@29@00))
  :qid |quant-u-3572|)))
(assert (forall ((s@$ $Snap) (t@29@00 $Ref)) (!
  (_joinable%stateless t@29@00)
  :pattern ((_joinable%limited s@$ t@29@00))
  :qid |quant-u-3573|)))
(assert (forall ((s@$ $Snap) (self@31@00 $Ref) (other@32@00 $Ref)) (!
  (=
    (str___eq__%limited s@$ self@31@00 other@32@00)
    (str___eq__ s@$ self@31@00 other@32@00))
  :pattern ((str___eq__ s@$ self@31@00 other@32@00))
  :qid |quant-u-3574|)))
(assert (forall ((s@$ $Snap) (self@31@00 $Ref) (other@32@00 $Ref)) (!
  (str___eq__%stateless self@31@00 other@32@00)
  :pattern ((str___eq__%limited s@$ self@31@00 other@32@00))
  :qid |quant-u-3575|)))
(assert (forall ((s@$ $Snap) (self@31@00 $Ref) (other@32@00 $Ref)) (!
  (let ((result@33@00 (str___eq__%limited s@$ self@31@00 other@32@00))) (=>
    (str___eq__%precondition s@$ self@31@00 other@32@00)
    (and
      (=
        (=
          (str___val__ $Snap.unit self@31@00)
          (str___val__ $Snap.unit other@32@00))
        result@33@00)
      (=>
        result@33@00
        (=
          (str___len__ $Snap.unit self@31@00)
          (str___len__ $Snap.unit other@32@00))))))
  :pattern ((str___eq__%limited s@$ self@31@00 other@32@00))
  :qid |quant-u-3612|)))
(assert (forall ((s@$ $Snap) (self@31@00 $Ref) (other@32@00 $Ref)) (!
  (let ((result@33@00 (str___eq__%limited s@$ self@31@00 other@32@00))) (=>
    (str___eq__%precondition s@$ self@31@00 other@32@00)
    (and
      (str___val__%precondition $Snap.unit self@31@00)
      (str___val__%precondition $Snap.unit other@32@00))))
  :pattern ((str___eq__%limited s@$ self@31@00 other@32@00))
  :qid |quant-u-3613|)))
(assert (forall ((s@$ $Snap) (self@31@00 $Ref) (other@32@00 $Ref)) (!
  (let ((result@33@00 (str___eq__%limited s@$ self@31@00 other@32@00))) (=>
    (and (str___eq__%precondition s@$ self@31@00 other@32@00) result@33@00)
    (and
      (str___len__%precondition $Snap.unit self@31@00)
      (str___len__%precondition $Snap.unit other@32@00))))
  :pattern ((str___eq__%limited s@$ self@31@00 other@32@00))
  :qid |quant-u-3614|)))
(assert (forall ((s@$ $Snap) (self_7@34@00 $Ref) (self_7_0@35@00 $Ref)) (!
  (=
    (Lock_invariant_low%limited s@$ self_7@34@00 self_7_0@35@00)
    (Lock_invariant_low s@$ self_7@34@00 self_7_0@35@00))
  :pattern ((Lock_invariant_low s@$ self_7@34@00 self_7_0@35@00))
  :qid |quant-u-3576|)))
(assert (forall ((s@$ $Snap) (self_7@34@00 $Ref) (self_7_0@35@00 $Ref)) (!
  (Lock_invariant_low%stateless self_7@34@00 self_7_0@35@00)
  :pattern ((Lock_invariant_low%limited s@$ self_7@34@00 self_7_0@35@00))
  :qid |quant-u-3577|)))
(assert (forall ((s@$ $Snap) (self_7@34@00 $Ref) (self_7_0@35@00 $Ref)) (!
  (and
    ($Perm.isReadVar $k@55@00)
    ($Perm.isReadVar $k@56@00)
    ($Perm.isReadVar $k@57@00)
    ($Perm.isReadVar $k@58@00)
    ($Perm.isReadVar $k@59@00)
    ($Perm.isReadVar $k@60@00)
    ($Perm.isReadVar $k@62@00)
    ($Perm.isReadVar $k@63@00)
    (=>
      (Lock_invariant_low%precondition s@$ self_7@34@00 self_7_0@35@00)
      (=
        (Lock_invariant_low s@$ self_7@34@00 self_7_0@35@00)
        (=>
          (and
            (issubtype<Bool> (typeof<PyType> self_7@34@00) (as CellLock<PyType>  PyType))
            (issubtype<Bool> (typeof<PyType> self_7_0@35@00) (as CellLock<PyType>  PyType)))
          (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.first s@$)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second s@$)))))))))
  :pattern ((Lock_invariant_low s@$ self_7@34@00 self_7_0@35@00))
  :pattern ((Lock_invariant_low%stateless self_7@34@00 self_7_0@35@00) (Lock_invariant%trigger ($Snap.first s@$) self_7@34@00))
  :qid |quant-u-3615|)))
(assert (forall ((s@$ $Snap) (self_7@34@00 $Ref) (self_7_0@35@00 $Ref)) (!
  (=>
    (and
      (Lock_invariant_low%precondition s@$ self_7@34@00 self_7_0@35@00)
      (and
        (issubtype<Bool> (typeof<PyType> self_7@34@00) (as CellLock<PyType>  PyType))
        (issubtype<Bool> (typeof<PyType> self_7_0@35@00) (as CellLock<PyType>  PyType))))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.first s@$)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second s@$))))))
  :pattern ((Lock_invariant_low s@$ self_7@34@00 self_7_0@35@00))
  :qid |quant-u-3616|)))
(assert (forall ((s@$ $Snap)) (!
  (= (__file___0%limited s@$) (__file___0 s@$))
  :pattern ((__file___0 s@$))
  :qid |quant-u-3578|)))
(assert (forall ((s@$ $Snap)) (!
  (as __file___0%stateless  Bool)
  :pattern ((__file___0%limited s@$))
  :qid |quant-u-3579|)))
(assert (forall ((s@$ $Snap)) (!
  (= (__file__%limited s@$) (__file__ s@$))
  :pattern ((__file__ s@$))
  :qid |quant-u-3580|)))
(assert (forall ((s@$ $Snap)) (!
  (as __file__%stateless  Bool)
  :pattern ((__file__%limited s@$))
  :qid |quant-u-3581|)))
(assert (forall ((s@$ $Snap) (val@39@00 $Ref) (id@40@00 Int)) (!
  (=
    (_checkDefined%limited s@$ val@39@00 id@40@00)
    (_checkDefined s@$ val@39@00 id@40@00))
  :pattern ((_checkDefined s@$ val@39@00 id@40@00))
  :qid |quant-u-3582|)))
(assert (forall ((s@$ $Snap) (val@39@00 $Ref) (id@40@00 Int)) (!
  (_checkDefined%stateless val@39@00 id@40@00)
  :pattern ((_checkDefined%limited s@$ val@39@00 id@40@00))
  :qid |quant-u-3583|)))
(assert (forall ((s@$ $Snap) (val@39@00 $Ref) (id@40@00 Int)) (!
  (=>
    (_checkDefined%precondition s@$ val@39@00 id@40@00)
    (= (_checkDefined s@$ val@39@00 id@40@00) val@39@00))
  :pattern ((_checkDefined s@$ val@39@00 id@40@00))
  :qid |quant-u-3617|)))
(assert (forall ((s@$ $Snap) (val@39@00 $Ref) (id@40@00 Int)) (!
  true
  :pattern ((_checkDefined s@$ val@39@00 id@40@00))
  :qid |quant-u-3618|)))
(assert (forall ((s@$ $Snap)) (!
  (= (__name__%limited s@$) (__name__ s@$))
  :pattern ((__name__ s@$))
  :qid |quant-u-3584|)))
(assert (forall ((s@$ $Snap)) (!
  (as __name__%stateless  Bool)
  :pattern ((__name__%limited s@$))
  :qid |quant-u-3585|)))
(assert (forall ((s@$ $Snap) (self_7@43@00 $Ref) (self_7_0@44@00 $Ref)) (!
  (=
    (Lock_invariant_all_low%limited s@$ self_7@43@00 self_7_0@44@00)
    (Lock_invariant_all_low s@$ self_7@43@00 self_7_0@44@00))
  :pattern ((Lock_invariant_all_low s@$ self_7@43@00 self_7_0@44@00))
  :qid |quant-u-3586|)))
(assert (forall ((s@$ $Snap) (self_7@43@00 $Ref) (self_7_0@44@00 $Ref)) (!
  (Lock_invariant_all_low%stateless self_7@43@00 self_7_0@44@00)
  :pattern ((Lock_invariant_all_low%limited s@$ self_7@43@00 self_7_0@44@00))
  :qid |quant-u-3587|)))
(assert (forall ((s@$ $Snap) (self_7@43@00 $Ref) (self_7_0@44@00 $Ref)) (!
  (and
    ($Perm.isReadVar $k@66@00)
    ($Perm.isReadVar $k@67@00)
    ($Perm.isReadVar $k@68@00)
    ($Perm.isReadVar $k@69@00)
    ($Perm.isReadVar $k@70@00)
    ($Perm.isReadVar $k@71@00)
    ($Perm.isReadVar $k@73@00)
    ($Perm.isReadVar $k@74@00)
    (=>
      (Lock_invariant_all_low%precondition s@$ self_7@43@00 self_7_0@44@00)
      (=
        (Lock_invariant_all_low s@$ self_7@43@00 self_7_0@44@00)
        (=>
          (and
            (issubtype<Bool> (typeof<PyType> self_7@43@00) (as CellLock<PyType>  PyType))
            (issubtype<Bool> (typeof<PyType> self_7_0@44@00) (as CellLock<PyType>  PyType)))
          (=
            ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.first s@$))))
            ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second s@$)))))))))
  :pattern ((Lock_invariant_all_low s@$ self_7@43@00 self_7_0@44@00))
  :pattern ((Lock_invariant_all_low%stateless self_7@43@00 self_7_0@44@00) (Lock_invariant%trigger ($Snap.first s@$) self_7@43@00))
  :qid |quant-u-3619|)))
(assert (forall ((s@$ $Snap) (self_7@43@00 $Ref) (self_7_0@44@00 $Ref)) (!
  true
  :pattern ((Lock_invariant_all_low s@$ self_7@43@00 self_7_0@44@00))
  :qid |quant-u-3620|)))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- sif_print ----------
(declare-const p1@0@01 Bool)
(declare-const p2@1@01 Bool)
(declare-const _cthread_160@2@01 $Ref)
(declare-const _cthread_160_0@3@01 $Ref)
(declare-const _caller_measures_160@4@01 Seq<Measure$>)
(declare-const _caller_measures_160_0@5@01 Seq<Measure$>)
(declare-const _residue_160@6@01 $Perm)
(declare-const _residue_160_0@7@01 $Perm)
(declare-const x_0@8@01 $Ref)
(declare-const x_0_0@9@01 $Ref)
(declare-const _current_wait_level_160@10@01 $Perm)
(declare-const _current_wait_level_160_0@11@01 $Perm)
(declare-const p1@12@01 Bool)
(declare-const p2@13@01 Bool)
(declare-const _cthread_160@14@01 $Ref)
(declare-const _cthread_160_0@15@01 $Ref)
(declare-const _caller_measures_160@16@01 Seq<Measure$>)
(declare-const _caller_measures_160_0@17@01 Seq<Measure$>)
(declare-const _residue_160@18@01 $Perm)
(declare-const _residue_160_0@19@01 $Perm)
(declare-const x_0@20@01 $Ref)
(declare-const x_0_0@21@01 $Ref)
(declare-const _current_wait_level_160@22@01 $Perm)
(declare-const _current_wait_level_160_0@23@01 $Perm)
(set-option :timeout 0)
(push) ; 1
(declare-const $t@24@01 $Snap)
(assert (= $t@24@01 ($Snap.combine ($Snap.first $t@24@01) ($Snap.second $t@24@01))))
(assert (= ($Snap.first $t@24@01) $Snap.unit))
; [eval] p1 ==> _cthread_160 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1@12@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1@12@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 0 | p1@12@01 | live]
; [else-branch: 0 | !(p1@12@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 0 | p1@12@01]
(assert p1@12@01)
; [eval] _cthread_160 != null
(pop) ; 3
(push) ; 3
; [else-branch: 0 | !(p1@12@01)]
(assert (not p1@12@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1@12@01) p1@12@01))
(assert (=> p1@12@01 (not (= _cthread_160@14@01 $Ref.null))))
(assert (=
  ($Snap.second $t@24@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@24@01))
    ($Snap.second ($Snap.second $t@24@01)))))
(assert (= ($Snap.first ($Snap.second $t@24@01)) $Snap.unit))
; [eval] p2 ==> _cthread_160_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2@13@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1 | p2@13@01 | live]
; [else-branch: 1 | !(p2@13@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1 | p2@13@01]
(assert p2@13@01)
; [eval] _cthread_160_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1 | !(p2@13@01)]
(assert (not p2@13@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2@13@01) p2@13@01))
(assert (=> p2@13@01 (not (= _cthread_160_0@15@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@24@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@24@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@24@01))) $Snap.unit))
; [eval] p1 ==> issubtype(typeof(_cthread_160), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1@12@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1@12@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2 | p1@12@01 | live]
; [else-branch: 2 | !(p1@12@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2 | p1@12@01]
(assert p1@12@01)
; [eval] issubtype(typeof(_cthread_160), Thread_0())
; [eval] typeof(_cthread_160)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2 | !(p1@12@01)]
(assert (not p1@12@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1@12@01
  (issubtype<Bool> (typeof<PyType> _cthread_160@14@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@24@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@24@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@24@01))))
  $Snap.unit))
; [eval] p2 ==> issubtype(typeof(_cthread_160_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2@13@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 3 | p2@13@01 | live]
; [else-branch: 3 | !(p2@13@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 3 | p2@13@01]
(assert p2@13@01)
; [eval] issubtype(typeof(_cthread_160_0), Thread_0())
; [eval] typeof(_cthread_160_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 3 | !(p2@13@01)]
(assert (not p2@13@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2@13@01
  (issubtype<Bool> (typeof<PyType> _cthread_160_0@15@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))
  $Snap.unit))
; [eval] p1 ==> issubtype(typeof(x_0), int())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1@12@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1@12@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 4 | p1@12@01 | live]
; [else-branch: 4 | !(p1@12@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 4 | p1@12@01]
(assert p1@12@01)
; [eval] issubtype(typeof(x_0), int())
; [eval] typeof(x_0)
; [eval] int()
(pop) ; 3
(push) ; 3
; [else-branch: 4 | !(p1@12@01)]
(assert (not p1@12@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1@12@01
  (issubtype<Bool> (typeof<PyType> x_0@20@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))
  $Snap.unit))
; [eval] p2 ==> issubtype(typeof(x_0_0), int())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2@13@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 5 | p2@13@01 | live]
; [else-branch: 5 | !(p2@13@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 5 | p2@13@01]
(assert p2@13@01)
; [eval] issubtype(typeof(x_0_0), int())
; [eval] typeof(x_0_0)
; [eval] int()
(pop) ; 3
(push) ; 3
; [else-branch: 5 | !(p2@13@01)]
(assert (not p2@13@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2@13@01
  (issubtype<Bool> (typeof<PyType> x_0_0@21@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))
  $Snap.unit))
; [eval] p1 == p2
(assert (= p1@12@01 p2@13@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))
  $Snap.unit))
; [eval] p1 && p2 ==> int___eq__(x_0, x_0_0)
; [eval] p1 && p2
(push) ; 2
; [then-branch: 6 | !(p1@12@01) | live]
; [else-branch: 6 | p1@12@01 | live]
(push) ; 3
; [then-branch: 6 | !(p1@12@01)]
(assert (not p1@12@01))
(pop) ; 3
(push) ; 3
; [else-branch: 6 | p1@12@01]
(assert p1@12@01)
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or p1@12@01 (not p1@12@01)))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not (and p1@12@01 p2@13@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and p1@12@01 p2@13@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 7 | p1@12@01 && p2@13@01 | live]
; [else-branch: 7 | !(p1@12@01 && p2@13@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 7 | p1@12@01 && p2@13@01]
(assert (and p1@12@01 p2@13@01))
; [eval] int___eq__(x_0, x_0_0)
(push) ; 4
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 5
(assert (not (issubtype<Bool> (typeof<PyType> x_0@20@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> x_0@20@01) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 5
(assert (not (issubtype<Bool> (typeof<PyType> x_0_0@21@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> x_0_0@21@01) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_0@20@01 x_0_0@21@01))
(pop) ; 4
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> x_0@20@01) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> x_0_0@21@01) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_0@20@01 x_0_0@21@01)))
(pop) ; 3
(push) ; 3
; [else-branch: 7 | !(p1@12@01 && p2@13@01)]
(assert (not (and p1@12@01 p2@13@01)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (=>
  (and p1@12@01 p2@13@01)
  (and
    p1@12@01
    p2@13@01
    (issubtype<Bool> (typeof<PyType> x_0@20@01) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> x_0_0@21@01) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_0@20@01 x_0_0@21@01))))
; Joined path conditions
(assert (or (not (and p1@12@01 p2@13@01)) (and p1@12@01 p2@13@01)))
(assert (=>
  (and p1@12@01 p2@13@01)
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) x_0@20@01 x_0_0@21@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))))))
(push) ; 2
(set-option :timeout 10)
(assert (not (not p1@12@01)))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 2
(set-option :timeout 10)
(assert (not p1@12@01))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; [then-branch: 8 | p1@12@01 | live]
; [else-branch: 8 | !(p1@12@01) | live]
(set-option :timeout 0)
(push) ; 2
; [then-branch: 8 | p1@12@01]
(assert p1@12@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2@13@01))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 9 | p2@13@01 | live]
; [else-branch: 9 | !(p2@13@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 9 | p2@13@01]
(assert p2@13@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))))
  $Snap.unit))
; [eval] p1 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1@12@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 10 | p1@12@01 | live]
; [else-branch: 10 | !(p1@12@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 10 | p1@12@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))))
  $Snap.unit))
; [eval] p2 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 11 | p2@13@01 | live]
; [else-branch: 11 | !(p2@13@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 11 | p2@13@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(declare-const $t@25@01 $Snap)
(assert (= $t@25@01 ($Snap.combine ($Snap.first $t@25@01) ($Snap.second $t@25@01))))
(assert (= ($Snap.first $t@25@01) $Snap.unit))
; [eval] p1 ==> (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1@12@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 12 | p1@12@01 | live]
; [else-branch: 12 | !(p1@12@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 12 | p1@12@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 7
; [then-branch: 13 | False | live]
; [else-branch: 13 | True | live]
(push) ; 8
; [then-branch: 13 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 13 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 9
; [then-branch: 14 | False | live]
; [else-branch: 14 | True | live]
(push) ; 10
; [then-branch: 14 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 14 | True]
; [eval] _residue_160 <= _current_wait_level_160
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=> p1@12@01 (<= _residue_160@18@01 _current_wait_level_160@22@01)))
(assert (=
  ($Snap.second $t@25@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@25@01))
    ($Snap.second ($Snap.second $t@25@01)))))
(assert (= ($Snap.first ($Snap.second $t@25@01)) $Snap.unit))
; [eval] p2 ==> (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 15 | p2@13@01 | live]
; [else-branch: 15 | !(p2@13@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 15 | p2@13@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 7
; [then-branch: 16 | False | live]
; [else-branch: 16 | True | live]
(push) ; 8
; [then-branch: 16 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 16 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 9
; [then-branch: 17 | False | live]
; [else-branch: 17 | True | live]
(push) ; 10
; [then-branch: 17 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 17 | True]
; [eval] _residue_160_0 <= _current_wait_level_160_0
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=> p2@13@01 (<= _residue_160_0@19@01 _current_wait_level_160_0@23@01)))
(assert (=
  ($Snap.second ($Snap.second $t@25@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@25@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@25@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@25@01))) $Snap.unit))
; [eval] p1 ==> true
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1@12@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 18 | p1@12@01 | live]
; [else-branch: 18 | !(p1@12@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 18 | p1@12@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@25@01))) $Snap.unit))
; [eval] p2 ==> true
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 19 | p2@13@01 | live]
; [else-branch: 19 | !(p2@13@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 19 | p2@13@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [exec]
; var _err: Ref
(declare-const _err@26@01 $Ref)
; [exec]
; var _err_0: Ref
(declare-const _err_0@27@01 $Ref)
; [exec]
; var x_4: Ref
(declare-const x_4@28@01 $Ref)
; [exec]
; var x_4_0: Ref
(declare-const x_4_0@29@01 $Ref)
; [exec]
; var _cwl_160: Perm
(declare-const _cwl_160@30@01 $Perm)
; [exec]
; var _cwl_160_0: Perm
(declare-const _cwl_160_0@31@01 $Perm)
; [exec]
; var _method_measures_160: Seq[Measure$]
(declare-const _method_measures_160@32@01 Seq<Measure$>)
; [exec]
; var _method_measures_160_0: Seq[Measure$]
(declare-const _method_measures_160_0@33@01 Seq<Measure$>)
; [exec]
; inhale p1
(declare-const $t@34@01 $Snap)
(assert (= $t@34@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1@12@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 20 | p1@12@01 | live]
; [else-branch: 20 | !(p1@12@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 20 | p1@12@01]
; [exec]
; _method_measures_160 := Seq(Measure$create(true, _cthread_160, 1))
; [eval] Seq(Measure$create(true, _cthread_160, 1))
; [eval] Measure$create(true, _cthread_160, 1)
(assert (=
  (Seq_length
    (Seq_singleton (Measure$create<Measure$> true _cthread_160@14@01 1)))
  1))
(declare-const _method_measures_160@35@01 Seq<Measure$>)
(assert (=
  _method_measures_160@35@01
  (Seq_singleton (Measure$create<Measure$> true _cthread_160@14@01 1))))
; [exec]
; _err := null
; [exec]
; x_4 := x_0
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 21 | p2@13@01 | live]
; [else-branch: 21 | !(p2@13@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 21 | p2@13@01]
; [exec]
; _method_measures_160_0 := Seq(Measure$create(true, _cthread_160_0, 1))
; [eval] Seq(Measure$create(true, _cthread_160_0, 1))
; [eval] Measure$create(true, _cthread_160_0, 1)
(assert (=
  (Seq_length
    (Seq_singleton (Measure$create<Measure$> true _cthread_160_0@15@01 1)))
  1))
(declare-const _method_measures_160_0@36@01 Seq<Measure$>)
(assert (=
  _method_measures_160_0@36@01
  (Seq_singleton (Measure$create<Measure$> true _cthread_160_0@15@01 1))))
; [exec]
; _err_0 := null
; [exec]
; x_4_0 := x_0_0
; [exec]
; assert true
; [eval] p1 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1@12@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 22 | p1@12@01 | live]
; [else-branch: 22 | !(p1@12@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 22 | p1@12@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p2 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 23 | p2@13@01 | live]
; [else-branch: 23 | !(p2@13@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 23 | p2@13@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p1 ==> (forperm _r_0: Ref [MustInvokeBounded(_r_0)] :: false) && ((forperm _r_0: Ref [MustInvokeUnbounded(_r_0)] :: false) && ((forperm _r_0: Ref [_r_0.MustReleaseBounded] :: false) && (forperm _r_0: Ref [_r_0.MustReleaseUnbounded] :: false)))
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1@12@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 24 | p1@12@01 | live]
; [else-branch: 24 | !(p1@12@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 24 | p1@12@01]
; [eval] (forperm _r_0: Ref [MustInvokeBounded(_r_0)] :: false) && ((forperm _r_0: Ref [MustInvokeUnbounded(_r_0)] :: false) && ((forperm _r_0: Ref [_r_0.MustReleaseBounded] :: false) && (forperm _r_0: Ref [_r_0.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_0: Ref [MustInvokeBounded(_r_0)] :: false)
(push) ; 9
; [then-branch: 25 | False | live]
; [else-branch: 25 | True | live]
(push) ; 10
; [then-branch: 25 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 25 | True]
; [eval] (forperm _r_0: Ref [MustInvokeUnbounded(_r_0)] :: false)
(push) ; 11
; [then-branch: 26 | False | live]
; [else-branch: 26 | True | live]
(push) ; 12
; [then-branch: 26 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 26 | True]
; [eval] (forperm _r_0: Ref [_r_0.MustReleaseBounded] :: false)
(push) ; 13
; [then-branch: 27 | False | live]
; [else-branch: 27 | True | live]
(push) ; 14
; [then-branch: 27 | False]
(assert false)
(pop) ; 14
(push) ; 14
; [else-branch: 27 | True]
; [eval] (forperm _r_0: Ref [_r_0.MustReleaseUnbounded] :: false)
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p2 ==> (forperm _r_0: Ref [MustInvokeBounded_0(_r_0)] :: false) && ((forperm _r_0: Ref [MustInvokeUnbounded_0(_r_0)] :: false) && ((forperm _r_0: Ref [_r_0.MustReleaseBoundedp] :: false) && (forperm _r_0: Ref [_r_0.MustReleaseUnboundedp] :: false)))
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 28 | p2@13@01 | live]
; [else-branch: 28 | !(p2@13@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 28 | p2@13@01]
; [eval] (forperm _r_0: Ref [MustInvokeBounded_0(_r_0)] :: false) && ((forperm _r_0: Ref [MustInvokeUnbounded_0(_r_0)] :: false) && ((forperm _r_0: Ref [_r_0.MustReleaseBoundedp] :: false) && (forperm _r_0: Ref [_r_0.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_0: Ref [MustInvokeBounded_0(_r_0)] :: false)
(push) ; 9
; [then-branch: 29 | False | live]
; [else-branch: 29 | True | live]
(push) ; 10
; [then-branch: 29 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 29 | True]
; [eval] (forperm _r_0: Ref [MustInvokeUnbounded_0(_r_0)] :: false)
(push) ; 11
; [then-branch: 30 | False | live]
; [else-branch: 30 | True | live]
(push) ; 12
; [then-branch: 30 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 30 | True]
; [eval] (forperm _r_0: Ref [_r_0.MustReleaseBoundedp] :: false)
(push) ; 13
; [then-branch: 31 | False | live]
; [else-branch: 31 | True | live]
(push) ; 14
; [then-branch: 31 | False]
(assert false)
(pop) ; 14
(push) ; 14
; [else-branch: 31 | True]
; [eval] (forperm _r_0: Ref [_r_0.MustReleaseUnboundedp] :: false)
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(pop) ; 6
; [eval] !p2
; [then-branch: 32 | !(p2@13@01) | dead]
; [else-branch: 32 | p2@13@01 | live]
(push) ; 6
; [else-branch: 32 | p2@13@01]
(pop) ; 6
(pop) ; 5
; [eval] !p1
; [then-branch: 33 | !(p1@12@01) | dead]
; [else-branch: 33 | p1@12@01 | live]
(push) ; 5
; [else-branch: 33 | p1@12@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [else-branch: 8 | !(p1@12@01)]
(assert (not p1@12@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2@13@01)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 34 | p2@13@01 | dead]
; [else-branch: 34 | !(p2@13@01) | live]
(set-option :timeout 0)
(push) ; 3
; [else-branch: 34 | !(p2@13@01)]
(assert (not p2@13@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))))
  $Snap.unit))
; [eval] p1 ==> true
(push) ; 4
; [then-branch: 35 | p1@12@01 | dead]
; [else-branch: 35 | !(p1@12@01) | live]
(push) ; 5
; [else-branch: 35 | !(p1@12@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@24@01)))))))))))
  $Snap.unit))
; [eval] p2 ==> true
(push) ; 4
; [then-branch: 36 | p2@13@01 | dead]
; [else-branch: 36 | !(p2@13@01) | live]
(push) ; 5
; [else-branch: 36 | !(p2@13@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(declare-const $t@37@01 $Snap)
(assert (= $t@37@01 ($Snap.combine ($Snap.first $t@37@01) ($Snap.second $t@37@01))))
(assert (= ($Snap.first $t@37@01) $Snap.unit))
; [eval] p1 ==> (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
(push) ; 5
; [then-branch: 37 | p1@12@01 | dead]
; [else-branch: 37 | !(p1@12@01) | live]
(push) ; 6
; [else-branch: 37 | !(p1@12@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second $t@37@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@37@01))
    ($Snap.second ($Snap.second $t@37@01)))))
(assert (= ($Snap.first ($Snap.second $t@37@01)) $Snap.unit))
; [eval] p2 ==> (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
(push) ; 5
; [then-branch: 38 | p2@13@01 | dead]
; [else-branch: 38 | !(p2@13@01) | live]
(push) ; 6
; [else-branch: 38 | !(p2@13@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@37@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@37@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@37@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@37@01))) $Snap.unit))
; [eval] p1 ==> true
(push) ; 5
; [then-branch: 39 | p1@12@01 | dead]
; [else-branch: 39 | !(p1@12@01) | live]
(push) ; 6
; [else-branch: 39 | !(p1@12@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@37@01))) $Snap.unit))
; [eval] p2 ==> true
(push) ; 5
; [then-branch: 40 | p2@13@01 | dead]
; [else-branch: 40 | !(p2@13@01) | live]
(push) ; 6
; [else-branch: 40 | !(p2@13@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [exec]
; var _err: Ref
(declare-const _err@38@01 $Ref)
; [exec]
; var _err_0: Ref
(declare-const _err_0@39@01 $Ref)
; [exec]
; var x_4: Ref
(declare-const x_4@40@01 $Ref)
; [exec]
; var x_4_0: Ref
(declare-const x_4_0@41@01 $Ref)
; [exec]
; var _cwl_160: Perm
(declare-const _cwl_160@42@01 $Perm)
; [exec]
; var _cwl_160_0: Perm
(declare-const _cwl_160_0@43@01 $Perm)
; [exec]
; var _method_measures_160: Seq[Measure$]
(declare-const _method_measures_160@44@01 Seq<Measure$>)
; [exec]
; var _method_measures_160_0: Seq[Measure$]
(declare-const _method_measures_160_0@45@01 Seq<Measure$>)
; [exec]
; inhale p1
(declare-const $t@46@01 $Snap)
(assert (= $t@46@01 $Snap.unit))
(assert p1@12@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 41 | p1@12@01 | dead]
; [else-branch: 41 | !(p1@12@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 41 | !(p1@12@01)]
(pop) ; 5
; [eval] !p1
; [then-branch: 42 | !(p1@12@01) | dead]
; [else-branch: 42 | p1@12@01 | live]
(push) ; 5
; [else-branch: 42 | p1@12@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- printTwice ----------
(declare-const p1_0@47@01 Bool)
(declare-const p2_0@48@01 Bool)
(declare-const _cthread_161@49@01 $Ref)
(declare-const _cthread_161_0@50@01 $Ref)
(declare-const _caller_measures_161@51@01 Seq<Measure$>)
(declare-const _caller_measures_161_0@52@01 Seq<Measure$>)
(declare-const _residue_161@53@01 $Perm)
(declare-const _residue_161_0@54@01 $Perm)
(declare-const l@55@01 $Ref)
(declare-const l_1@56@01 $Ref)
(declare-const x_1@57@01 $Ref)
(declare-const x_1_0@58@01 $Ref)
(declare-const _current_wait_level_161@59@01 $Perm)
(declare-const _current_wait_level_161_0@60@01 $Perm)
(declare-const p1_0@61@01 Bool)
(declare-const p2_0@62@01 Bool)
(declare-const _cthread_161@63@01 $Ref)
(declare-const _cthread_161_0@64@01 $Ref)
(declare-const _caller_measures_161@65@01 Seq<Measure$>)
(declare-const _caller_measures_161_0@66@01 Seq<Measure$>)
(declare-const _residue_161@67@01 $Perm)
(declare-const _residue_161_0@68@01 $Perm)
(declare-const l@69@01 $Ref)
(declare-const l_1@70@01 $Ref)
(declare-const x_1@71@01 $Ref)
(declare-const x_1_0@72@01 $Ref)
(declare-const _current_wait_level_161@73@01 $Perm)
(declare-const _current_wait_level_161_0@74@01 $Perm)
(push) ; 1
(declare-const $t@75@01 $Snap)
(assert (= $t@75@01 ($Snap.combine ($Snap.first $t@75@01) ($Snap.second $t@75@01))))
(assert (= ($Snap.first $t@75@01) $Snap.unit))
; [eval] p1_0 ==> _cthread_161 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 43 | p1_0@61@01 | live]
; [else-branch: 43 | !(p1_0@61@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 43 | p1_0@61@01]
(assert p1_0@61@01)
; [eval] _cthread_161 != null
(pop) ; 3
(push) ; 3
; [else-branch: 43 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_0@61@01) p1_0@61@01))
(assert (=> p1_0@61@01 (not (= _cthread_161@63@01 $Ref.null))))
(assert (=
  ($Snap.second $t@75@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@75@01))
    ($Snap.second ($Snap.second $t@75@01)))))
(assert (= ($Snap.first ($Snap.second $t@75@01)) $Snap.unit))
; [eval] p2_0 ==> _cthread_161_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 44 | p2_0@62@01 | live]
; [else-branch: 44 | !(p2_0@62@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 44 | p2_0@62@01]
(assert p2_0@62@01)
; [eval] _cthread_161_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 44 | !(p2_0@62@01)]
(assert (not p2_0@62@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_0@62@01) p2_0@62@01))
(assert (=> p2_0@62@01 (not (= _cthread_161_0@64@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@75@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@75@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@75@01))) $Snap.unit))
; [eval] p1_0 ==> issubtype(typeof(_cthread_161), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 45 | p1_0@61@01 | live]
; [else-branch: 45 | !(p1_0@61@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 45 | p1_0@61@01]
(assert p1_0@61@01)
; [eval] issubtype(typeof(_cthread_161), Thread_0())
; [eval] typeof(_cthread_161)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 45 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_0@61@01
  (issubtype<Bool> (typeof<PyType> _cthread_161@63@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@75@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@01))))
  $Snap.unit))
; [eval] p2_0 ==> issubtype(typeof(_cthread_161_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 46 | p2_0@62@01 | live]
; [else-branch: 46 | !(p2_0@62@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 46 | p2_0@62@01]
(assert p2_0@62@01)
; [eval] issubtype(typeof(_cthread_161_0), Thread_0())
; [eval] typeof(_cthread_161_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 46 | !(p2_0@62@01)]
(assert (not p2_0@62@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_0@62@01
  (issubtype<Bool> (typeof<PyType> _cthread_161_0@64@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))
  $Snap.unit))
; [eval] p1_0 ==> issubtype(typeof(l), Lock(Cell()))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 47 | p1_0@61@01 | live]
; [else-branch: 47 | !(p1_0@61@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 47 | p1_0@61@01]
(assert p1_0@61@01)
; [eval] issubtype(typeof(l), Lock(Cell()))
; [eval] typeof(l)
; [eval] Lock(Cell())
; [eval] Cell()
(pop) ; 3
(push) ; 3
; [else-branch: 47 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_0@61@01
  (issubtype<Bool> (typeof<PyType> l@69@01) (Lock<PyType> (as Cell<PyType>  PyType)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))
  $Snap.unit))
; [eval] p2_0 ==> issubtype(typeof(l_1), Lock(Cell()))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 48 | p2_0@62@01 | live]
; [else-branch: 48 | !(p2_0@62@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 48 | p2_0@62@01]
(assert p2_0@62@01)
; [eval] issubtype(typeof(l_1), Lock(Cell()))
; [eval] typeof(l_1)
; [eval] Lock(Cell())
; [eval] Cell()
(pop) ; 3
(push) ; 3
; [else-branch: 48 | !(p2_0@62@01)]
(assert (not p2_0@62@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_0@62@01
  (issubtype<Bool> (typeof<PyType> l_1@70@01) (Lock<PyType> (as Cell<PyType>  PyType)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))
  $Snap.unit))
; [eval] p1_0 ==> issubtype(typeof(x_1), int())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 49 | p1_0@61@01 | live]
; [else-branch: 49 | !(p1_0@61@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 49 | p1_0@61@01]
(assert p1_0@61@01)
; [eval] issubtype(typeof(x_1), int())
; [eval] typeof(x_1)
; [eval] int()
(pop) ; 3
(push) ; 3
; [else-branch: 49 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_0@61@01
  (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))
  $Snap.unit))
; [eval] p2_0 ==> issubtype(typeof(x_1_0), int())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 50 | p2_0@62@01 | live]
; [else-branch: 50 | !(p2_0@62@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 50 | p2_0@62@01]
(assert p2_0@62@01)
; [eval] issubtype(typeof(x_1_0), int())
; [eval] typeof(x_1_0)
; [eval] int()
(pop) ; 3
(push) ; 3
; [else-branch: 50 | !(p2_0@62@01)]
(assert (not p2_0@62@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_0@62@01
  (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))
  $Snap.unit))
; [eval] p1_0 == p2_0
(assert (= p1_0@61@01 p2_0@62@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))
  $Snap.unit))
; [eval] p1_0 && p2_0 ==> l == l_1
; [eval] p1_0 && p2_0
(push) ; 2
; [then-branch: 51 | !(p1_0@61@01) | live]
; [else-branch: 51 | p1_0@61@01 | live]
(push) ; 3
; [then-branch: 51 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 3
(push) ; 3
; [else-branch: 51 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or p1_0@61@01 (not p1_0@61@01)))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 52 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 52 | !(p1_0@61@01 && p2_0@62@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 52 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] l == l_1
(pop) ; 3
(push) ; 3
; [else-branch: 52 | !(p1_0@61@01 && p2_0@62@01)]
(assert (not (and p1_0@61@01 p2_0@62@01)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not (and p1_0@61@01 p2_0@62@01)) (and p1_0@61@01 p2_0@62@01)))
(assert (=> (and p1_0@61@01 p2_0@62@01) (= l@69@01 l_1@70@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))
  $Snap.unit))
; [eval] p1_0 && p2_0 ==> x_1 == x_1_0
; [eval] p1_0 && p2_0
(push) ; 2
; [then-branch: 53 | !(p1_0@61@01) | live]
; [else-branch: 53 | p1_0@61@01 | live]
(push) ; 3
; [then-branch: 53 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 3
(push) ; 3
; [else-branch: 53 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 54 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 54 | !(p1_0@61@01 && p2_0@62@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 54 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] x_1 == x_1_0
(pop) ; 3
(push) ; 3
; [else-branch: 54 | !(p1_0@61@01 && p2_0@62@01)]
(assert (not (and p1_0@61@01 p2_0@62@01)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> (and p1_0@61@01 p2_0@62@01) (= x_1@71@01 x_1_0@72@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))
(push) ; 2
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 2
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; [then-branch: 55 | p1_0@61@01 | live]
; [else-branch: 55 | !(p1_0@61@01) | live]
(set-option :timeout 0)
(push) ; 2
; [then-branch: 55 | p1_0@61@01]
(assert p1_0@61@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 56 | p2_0@62@01 | live]
; [else-branch: 56 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 56 | p2_0@62@01]
(assert p2_0@62@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))
  $Snap.unit))
; [eval] p1_0 ==> _residue_161 < Level(l)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 57 | p1_0@61@01 | live]
; [else-branch: 57 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 57 | p1_0@61@01]
; [eval] _residue_161 < Level(l)
; [eval] Level(l)
(push) ; 6
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 6
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=> p1_0@61@01 (Level%precondition $Snap.unit l@69@01)))
(assert (=> p1_0@61@01 (< _residue_161@67@01 (Level $Snap.unit l@69@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))
  $Snap.unit))
; [eval] p2_0 ==> _residue_161_0 < Level(l_1)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 58 | p2_0@62@01 | live]
; [else-branch: 58 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 58 | p2_0@62@01]
; [eval] _residue_161_0 < Level(l_1)
; [eval] Level(l_1)
(push) ; 6
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 6
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=> p2_0@62@01 (Level%precondition $Snap.unit l_1@70@01)))
(assert (=> p2_0@62@01 (< _residue_161_0@68@01 (Level $Snap.unit l_1@70@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))
  $Snap.unit))
; [eval] p1_0 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 59 | p1_0@61@01 | live]
; [else-branch: 59 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 59 | p1_0@61@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))
  $Snap.unit))
; [eval] p2_0 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 60 | p2_0@62@01 | live]
; [else-branch: 60 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 60 | p2_0@62@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))))
  $Snap.unit))
; [eval] p1_0 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 61 | p1_0@61@01 | live]
; [else-branch: 61 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 61 | p1_0@61@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))))
  $Snap.unit))
; [eval] p2_0 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 62 | p2_0@62@01 | live]
; [else-branch: 62 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 62 | p2_0@62@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(declare-const $t@76@01 $Snap)
(assert (= $t@76@01 ($Snap.combine ($Snap.first $t@76@01) ($Snap.second $t@76@01))))
(assert (= ($Snap.first $t@76@01) $Snap.unit))
; [eval] p1_0 ==> (forperm _r_3: Ref [_r_3.MustReleaseBounded] :: Level(_r_3) <= _current_wait_level_161) && ((forperm _r_3: Ref [_r_3.MustReleaseUnbounded] :: Level(_r_3) <= _current_wait_level_161) && _residue_161 <= _current_wait_level_161)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 63 | p1_0@61@01 | live]
; [else-branch: 63 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 63 | p1_0@61@01]
; [eval] (forperm _r_3: Ref [_r_3.MustReleaseBounded] :: Level(_r_3) <= _current_wait_level_161) && ((forperm _r_3: Ref [_r_3.MustReleaseUnbounded] :: Level(_r_3) <= _current_wait_level_161) && _residue_161 <= _current_wait_level_161)
; [eval] (forperm _r_3: Ref [_r_3.MustReleaseBounded] :: Level(_r_3) <= _current_wait_level_161)
(push) ; 7
; [then-branch: 64 | False | live]
; [else-branch: 64 | True | live]
(push) ; 8
; [then-branch: 64 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 64 | True]
; [eval] (forperm _r_3: Ref [_r_3.MustReleaseUnbounded] :: Level(_r_3) <= _current_wait_level_161)
(push) ; 9
; [then-branch: 65 | False | live]
; [else-branch: 65 | True | live]
(push) ; 10
; [then-branch: 65 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 65 | True]
; [eval] _residue_161 <= _current_wait_level_161
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=> p1_0@61@01 (<= _residue_161@67@01 _current_wait_level_161@73@01)))
(assert (=
  ($Snap.second $t@76@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@76@01))
    ($Snap.second ($Snap.second $t@76@01)))))
(assert (= ($Snap.first ($Snap.second $t@76@01)) $Snap.unit))
; [eval] p2_0 ==> (forperm _r_3: Ref [_r_3.MustReleaseBoundedp] :: Level(_r_3) <= _current_wait_level_161_0) && ((forperm _r_3: Ref [_r_3.MustReleaseUnboundedp] :: Level(_r_3) <= _current_wait_level_161_0) && _residue_161_0 <= _current_wait_level_161_0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 66 | p2_0@62@01 | live]
; [else-branch: 66 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 66 | p2_0@62@01]
; [eval] (forperm _r_3: Ref [_r_3.MustReleaseBoundedp] :: Level(_r_3) <= _current_wait_level_161_0) && ((forperm _r_3: Ref [_r_3.MustReleaseUnboundedp] :: Level(_r_3) <= _current_wait_level_161_0) && _residue_161_0 <= _current_wait_level_161_0)
; [eval] (forperm _r_3: Ref [_r_3.MustReleaseBoundedp] :: Level(_r_3) <= _current_wait_level_161_0)
(push) ; 7
; [then-branch: 67 | False | live]
; [else-branch: 67 | True | live]
(push) ; 8
; [then-branch: 67 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 67 | True]
; [eval] (forperm _r_3: Ref [_r_3.MustReleaseUnboundedp] :: Level(_r_3) <= _current_wait_level_161_0)
(push) ; 9
; [then-branch: 68 | False | live]
; [else-branch: 68 | True | live]
(push) ; 10
; [then-branch: 68 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 68 | True]
; [eval] _residue_161_0 <= _current_wait_level_161_0
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=> p2_0@62@01 (<= _residue_161_0@68@01 _current_wait_level_161_0@74@01)))
(assert (=
  ($Snap.second ($Snap.second $t@76@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@76@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@76@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@76@01))) $Snap.unit))
; [eval] p1_0 ==> true
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 69 | p1_0@61@01 | live]
; [else-branch: 69 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 69 | p1_0@61@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@76@01))) $Snap.unit))
; [eval] p2_0 ==> true
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 70 | p2_0@62@01 | live]
; [else-branch: 70 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 70 | p2_0@62@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [exec]
; var _err: Ref
(declare-const _err@77@01 $Ref)
; [exec]
; var _err_1: Ref
(declare-const _err_1@78@01 $Ref)
; [exec]
; var l_0: Ref
(declare-const l_0@79@01 $Ref)
; [exec]
; var l_0_0: Ref
(declare-const l_0_0@80@01 $Ref)
; [exec]
; var x_5: Ref
(declare-const x_5@81@01 $Ref)
; [exec]
; var x_5_0: Ref
(declare-const x_5_0@82@01 $Ref)
; [exec]
; var _cwl_161: Perm
(declare-const _cwl_161@83@01 $Perm)
; [exec]
; var _cwl_161_0: Perm
(declare-const _cwl_161_0@84@01 $Perm)
; [exec]
; var _method_measures_161: Seq[Measure$]
(declare-const _method_measures_161@85@01 Seq<Measure$>)
; [exec]
; var _method_measures_161_0: Seq[Measure$]
(declare-const _method_measures_161_0@86@01 Seq<Measure$>)
; [exec]
; inhale p1_0
(declare-const $t@87@01 $Snap)
(assert (= $t@87@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 71 | p1_0@61@01 | live]
; [else-branch: 71 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 71 | p1_0@61@01]
; [exec]
; _method_measures_161 := Seq(Measure$create(true, _cthread_161, 4))
; [eval] Seq(Measure$create(true, _cthread_161, 4))
; [eval] Measure$create(true, _cthread_161, 4)
(assert (=
  (Seq_length
    (Seq_singleton (Measure$create<Measure$> true _cthread_161@63@01 4)))
  1))
(declare-const _method_measures_161@88@01 Seq<Measure$>)
(assert (=
  _method_measures_161@88@01
  (Seq_singleton (Measure$create<Measure$> true _cthread_161@63@01 4))))
; [exec]
; _err := null
; [exec]
; l_0 := l
; [exec]
; x_5 := x_1
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 72 | p2_0@62@01 | live]
; [else-branch: 72 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 72 | p2_0@62@01]
; [exec]
; _method_measures_161_0 := Seq(Measure$create(true, _cthread_161_0, 4))
; [eval] Seq(Measure$create(true, _cthread_161_0, 4))
; [eval] Measure$create(true, _cthread_161_0, 4)
(assert (=
  (Seq_length
    (Seq_singleton (Measure$create<Measure$> true _cthread_161_0@64@01 4)))
  1))
(declare-const _method_measures_161_0@89@01 Seq<Measure$>)
(assert (=
  _method_measures_161_0@89@01
  (Seq_singleton (Measure$create<Measure$> true _cthread_161_0@64@01 4))))
; [exec]
; _err_1 := null
; [exec]
; l_0_0 := l_1
; [exec]
; x_5_0 := x_1_0
; [eval] p1_0 || p2_0
(push) ; 7
; [then-branch: 73 | p1_0@61@01 | live]
; [else-branch: 73 | !(p1_0@61@01) | live]
(push) ; 8
; [then-branch: 73 | p1_0@61@01]
(pop) ; 8
(push) ; 8
; [else-branch: 73 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(assert (not (not (or p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (or p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 74 | p1_0@61@01 || p2_0@62@01 | live]
; [else-branch: 74 | !(p1_0@61@01 || p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 74 | p1_0@61@01 || p2_0@62@01]
(assert (or p1_0@61@01 p2_0@62@01))
; [exec]
; var tmp1: Ref
(declare-const tmp1@90@01 $Ref)
; [exec]
; var tmp2: Ref
(declare-const tmp2@91@01 $Ref)
; [exec]
; var tmp1_0: Seq[Measure$]
(declare-const tmp1_0@92@01 Seq<Measure$>)
; [exec]
; var tmp2_0: Seq[Measure$]
(declare-const tmp2_0@93@01 Seq<Measure$>)
; [exec]
; var tmp1_1: Perm
(declare-const tmp1_1@94@01 $Perm)
; [exec]
; var tmp2_1: Perm
(declare-const tmp2_1@95@01 $Perm)
; [exec]
; var tmp1_2: Ref
(declare-const tmp1_2@96@01 $Ref)
; [exec]
; var tmp2_2: Ref
(declare-const tmp2_2@97@01 $Ref)
; [exec]
; var tmp1_3: Perm
(declare-const tmp1_3@98@01 $Perm)
; [exec]
; var tmp2_3: Perm
(declare-const tmp2_3@99@01 $Perm)
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 75 | p1_0@61@01 | live]
; [else-branch: 75 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 75 | p1_0@61@01]
; [exec]
; tmp1 := _cthread_161
; [exec]
; tmp1_0 := _method_measures_161
; [exec]
; tmp1_1 := _residue_161
; [exec]
; tmp1_2 := l_0
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 76 | p2_0@62@01 | live]
; [else-branch: 76 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 76 | p2_0@62@01]
; [exec]
; tmp2 := _cthread_161_0
; [exec]
; tmp2_0 := _method_measures_161_0
; [exec]
; tmp2_1 := _residue_161_0
; [exec]
; tmp2_2 := l_0_0
; [exec]
; tmp1_3, tmp2_3 := Lock_acquire(p1_0, p2_0, tmp1, tmp2, tmp1_0, tmp2_0, tmp1_1,
;   tmp2_1, tmp1_2, tmp2_2)
; [eval] p1_31 ==> _cthread_172 != null
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 77 | p1_0@61@01 | live]
; [else-branch: 77 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 77 | p1_0@61@01]
; [eval] _cthread_172 != null
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_31 ==> _cthread_172_0 != null
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 78 | p2_0@62@01 | live]
; [else-branch: 78 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 78 | p2_0@62@01]
; [eval] _cthread_172_0 != null
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_31 ==> issubtype(typeof(_cthread_172), Thread_0())
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 79 | p1_0@61@01 | live]
; [else-branch: 79 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 79 | p1_0@61@01]
; [eval] issubtype(typeof(_cthread_172), Thread_0())
; [eval] typeof(_cthread_172)
; [eval] Thread_0()
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_31 ==> issubtype(typeof(_cthread_172_0), Thread_0())
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 80 | p2_0@62@01 | live]
; [else-branch: 80 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 80 | p2_0@62@01]
; [eval] issubtype(typeof(_cthread_172_0), Thread_0())
; [eval] typeof(_cthread_172_0)
; [eval] Thread_0()
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_31 ==> issubtype(typeof(self_5), Lock(Lock_arg(typeof(self_5), 0)))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 81 | p1_0@61@01 | live]
; [else-branch: 81 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 81 | p1_0@61@01]
; [eval] issubtype(typeof(self_5), Lock(Lock_arg(typeof(self_5), 0)))
; [eval] typeof(self_5)
; [eval] Lock(Lock_arg(typeof(self_5), 0))
; [eval] Lock_arg(typeof(self_5), 0)
; [eval] typeof(self_5)
(pop) ; 11
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (=>
  p1_0@61@01
  (issubtype<Bool> (typeof<PyType> l@69@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> l@69@01) 0))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_0@61@01
  (issubtype<Bool> (typeof<PyType> l@69@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> l@69@01) 0)))))
; [eval] p2_31 ==> issubtype(typeof(self_5_0), Lock(Lock_arg(typeof(self_5_0), 0)))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 82 | p2_0@62@01 | live]
; [else-branch: 82 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 82 | p2_0@62@01]
; [eval] issubtype(typeof(self_5_0), Lock(Lock_arg(typeof(self_5_0), 0)))
; [eval] typeof(self_5_0)
; [eval] Lock(Lock_arg(typeof(self_5_0), 0))
; [eval] Lock_arg(typeof(self_5_0), 0)
; [eval] typeof(self_5_0)
(pop) ; 11
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (=>
  p2_0@62@01
  (issubtype<Bool> (typeof<PyType> l_1@70@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> l_1@70@01) 0))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_0@62@01
  (issubtype<Bool> (typeof<PyType> l_1@70@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> l_1@70@01) 0)))))
; [eval] p1_31 ==> issubtype(Lock_arg(typeof(self_5), 0), object())
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 83 | p1_0@61@01 | live]
; [else-branch: 83 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 83 | p1_0@61@01]
; [eval] issubtype(Lock_arg(typeof(self_5), 0), object())
; [eval] Lock_arg(typeof(self_5), 0)
; [eval] typeof(self_5)
; [eval] object()
(pop) ; 11
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (=>
  p1_0@61@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> l@69@01) 0) (as object<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_0@61@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> l@69@01) 0) (as object<PyType>  PyType))))
; [eval] p2_31 ==> issubtype(Lock_arg(typeof(self_5_0), 0), object())
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 84 | p2_0@62@01 | live]
; [else-branch: 84 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 84 | p2_0@62@01]
; [eval] issubtype(Lock_arg(typeof(self_5_0), 0), object())
; [eval] Lock_arg(typeof(self_5_0), 0)
; [eval] typeof(self_5_0)
; [eval] object()
(pop) ; 11
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (=>
  p2_0@62@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> l_1@70@01) 0) (as object<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_0@62@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> l_1@70@01) 0) (as object<PyType>  PyType))))
; [eval] p1_31 ==> self_5 != null
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 85 | p1_0@61@01 | live]
; [else-branch: 85 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 85 | p1_0@61@01]
; [eval] self_5 != null
(pop) ; 11
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (=> p1_0@61@01 (not (= l@69@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_0@61@01 (not (= l@69@01 $Ref.null))))
; [eval] p2_31 ==> self_5_0 != null
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 86 | p2_0@62@01 | live]
; [else-branch: 86 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 86 | p2_0@62@01]
; [eval] self_5_0 != null
(pop) ; 11
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (=> p2_0@62@01 (not (= l_1@70@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_0@62@01 (not (= l_1@70@01 $Ref.null))))
; [eval] p1_31 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 87 | p1_0@61@01 | live]
; [else-branch: 87 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 87 | p1_0@61@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_31 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 88 | p2_0@62@01 | live]
; [else-branch: 88 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 88 | p2_0@62@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_31 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 89 | p1_0@61@01 | live]
; [else-branch: 89 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 89 | p1_0@61@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_31 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 90 | p2_0@62@01 | live]
; [else-branch: 90 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 90 | p2_0@62@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_31 && p2_31 ==> self_5 == self_5_0
; [eval] p1_31 && p2_31
(push) ; 10
; [then-branch: 91 | !(p1_0@61@01) | live]
; [else-branch: 91 | p1_0@61@01 | live]
(push) ; 11
; [then-branch: 91 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 11
(push) ; 11
; [else-branch: 91 | p1_0@61@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 92 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 92 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 92 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] self_5 == self_5_0
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] p1_31 == p2_31
; [eval] p1_31 ==> typeof(self_5) == typeof(self_5_0)
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 93 | p1_0@61@01 | live]
; [else-branch: 93 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 93 | p1_0@61@01]
; [eval] typeof(self_5) == typeof(self_5_0)
; [eval] typeof(self_5)
; [eval] typeof(self_5_0)
(pop) ; 11
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (=> p1_0@61@01 (= (typeof<PyType> l@69@01) (typeof<PyType> l_1@70@01)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_0@61@01 (= (typeof<PyType> l@69@01) (typeof<PyType> l_1@70@01))))
; [eval] p1_31 ==> (forperm _r_55: Ref [_r_55.MustReleaseBounded] :: Level(_r_55) < Level(self_5)) && ((forperm _r_55: Ref [_r_55.MustReleaseUnbounded] :: Level(_r_55) < Level(self_5)) && _residue_172 < Level(self_5))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 94 | p1_0@61@01 | live]
; [else-branch: 94 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 94 | p1_0@61@01]
; [eval] (forperm _r_55: Ref [_r_55.MustReleaseBounded] :: Level(_r_55) < Level(self_5)) && ((forperm _r_55: Ref [_r_55.MustReleaseUnbounded] :: Level(_r_55) < Level(self_5)) && _residue_172 < Level(self_5))
; [eval] (forperm _r_55: Ref [_r_55.MustReleaseBounded] :: Level(_r_55) < Level(self_5))
(push) ; 12
; [then-branch: 95 | False | live]
; [else-branch: 95 | True | live]
(push) ; 13
; [then-branch: 95 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 95 | True]
; [eval] (forperm _r_55: Ref [_r_55.MustReleaseUnbounded] :: Level(_r_55) < Level(self_5))
(push) ; 14
; [then-branch: 96 | False | live]
; [else-branch: 96 | True | live]
(push) ; 15
; [then-branch: 96 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 96 | True]
; [eval] _residue_172 < Level(self_5)
; [eval] Level(self_5)
(push) ; 16
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 16
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_31 ==> (forperm _r_55: Ref [_r_55.MustReleaseBoundedp] :: Level(_r_55) < Level(self_5_0)) && ((forperm _r_55: Ref [_r_55.MustReleaseUnboundedp] :: Level(_r_55) < Level(self_5_0)) && _residue_172_0 < Level(self_5_0))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 97 | p2_0@62@01 | live]
; [else-branch: 97 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 97 | p2_0@62@01]
; [eval] (forperm _r_55: Ref [_r_55.MustReleaseBoundedp] :: Level(_r_55) < Level(self_5_0)) && ((forperm _r_55: Ref [_r_55.MustReleaseUnboundedp] :: Level(_r_55) < Level(self_5_0)) && _residue_172_0 < Level(self_5_0))
; [eval] (forperm _r_55: Ref [_r_55.MustReleaseBoundedp] :: Level(_r_55) < Level(self_5_0))
(push) ; 12
; [then-branch: 98 | False | live]
; [else-branch: 98 | True | live]
(push) ; 13
; [then-branch: 98 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 98 | True]
; [eval] (forperm _r_55: Ref [_r_55.MustReleaseUnboundedp] :: Level(_r_55) < Level(self_5_0))
(push) ; 14
; [then-branch: 99 | False | live]
; [else-branch: 99 | True | live]
(push) ; 15
; [then-branch: 99 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 99 | True]
; [eval] _residue_172_0 < Level(self_5_0)
; [eval] Level(self_5_0)
(push) ; 16
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 16
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_31 ==> Measure$check(_caller_measures_172, _cthread_172, 1) || perm(MustTerminate(_cthread_172)) == none && ((forperm _r_57: Ref [MustInvokeBounded(_r_57)] :: false) && ((forperm _r_57: Ref [MustInvokeUnbounded(_r_57)] :: false) && ((forperm _r_57: Ref [_r_57.MustReleaseBounded] :: false) && (forperm _r_57: Ref [_r_57.MustReleaseUnbounded] :: false))))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 100 | p1_0@61@01 | live]
; [else-branch: 100 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 100 | p1_0@61@01]
; [eval] Measure$check(_caller_measures_172, _cthread_172, 1) || perm(MustTerminate(_cthread_172)) == none && ((forperm _r_57: Ref [MustInvokeBounded(_r_57)] :: false) && ((forperm _r_57: Ref [MustInvokeUnbounded(_r_57)] :: false) && ((forperm _r_57: Ref [_r_57.MustReleaseBounded] :: false) && (forperm _r_57: Ref [_r_57.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_172, _cthread_172, 1)
(push) ; 12
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 12
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(push) ; 12
; [then-branch: 101 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1) | live]
; [else-branch: 101 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)) | live]
(push) ; 13
; [then-branch: 101 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 13
(push) ; 13
; [else-branch: 101 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1))]
(assert (not (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
; [eval] perm(MustTerminate(_cthread_172)) == none && ((forperm _r_57: Ref [MustInvokeBounded(_r_57)] :: false) && ((forperm _r_57: Ref [MustInvokeUnbounded(_r_57)] :: false) && ((forperm _r_57: Ref [_r_57.MustReleaseBounded] :: false) && (forperm _r_57: Ref [_r_57.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_172)) == none
; [eval] perm(MustTerminate(_cthread_172))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
  (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (=>
  p1_0@61@01
  (and
    (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)
    (or
      (not
        (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
      (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))))
(push) ; 10
(assert (not (=>
  p1_0@61@01
  (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_0@61@01
  (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
; [eval] p2_31 ==> Measure$check(_caller_measures_172_0, _cthread_172_0, 1) || perm(MustTerminate_0(_cthread_172_0)) == none && ((forperm _r_57: Ref [MustInvokeBounded_0(_r_57)] :: false) && ((forperm _r_57: Ref [MustInvokeUnbounded_0(_r_57)] :: false) && ((forperm _r_57: Ref [_r_57.MustReleaseBoundedp] :: false) && (forperm _r_57: Ref [_r_57.MustReleaseUnboundedp] :: false))))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 102 | p2_0@62@01 | live]
; [else-branch: 102 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 102 | p2_0@62@01]
; [eval] Measure$check(_caller_measures_172_0, _cthread_172_0, 1) || perm(MustTerminate_0(_cthread_172_0)) == none && ((forperm _r_57: Ref [MustInvokeBounded_0(_r_57)] :: false) && ((forperm _r_57: Ref [MustInvokeUnbounded_0(_r_57)] :: false) && ((forperm _r_57: Ref [_r_57.MustReleaseBoundedp] :: false) && (forperm _r_57: Ref [_r_57.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_172_0, _cthread_172_0, 1)
(push) ; 12
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 12
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(push) ; 12
; [then-branch: 103 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1) | live]
; [else-branch: 103 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)) | live]
(push) ; 13
; [then-branch: 103 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 13
(push) ; 13
; [else-branch: 103 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1))]
(assert (not
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
; [eval] perm(MustTerminate_0(_cthread_172_0)) == none && ((forperm _r_57: Ref [MustInvokeBounded_0(_r_57)] :: false) && ((forperm _r_57: Ref [MustInvokeUnbounded_0(_r_57)] :: false) && ((forperm _r_57: Ref [_r_57.MustReleaseBoundedp] :: false) && (forperm _r_57: Ref [_r_57.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_172_0)) == none
; [eval] perm(MustTerminate_0(_cthread_172_0))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (=>
  p2_0@62@01
  (and
    (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)
    (or
      (not
        (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
      (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))))
(push) ; 10
(assert (not (=>
  p2_0@62@01
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_0@62@01
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
(declare-const _current_wait_level_172@100@01 $Perm)
(declare-const _current_wait_level_172_0@101@01 $Perm)
(declare-const $t@102@01 $Snap)
(assert (= $t@102@01 ($Snap.combine ($Snap.first $t@102@01) ($Snap.second $t@102@01))))
(assert (= ($Snap.first $t@102@01) $Snap.unit))
; [eval] p1_31 ==> (forperm _r_56: Ref [_r_56.MustReleaseBounded] :: Level(_r_56) <= _current_wait_level_172) && ((forperm _r_56: Ref [_r_56.MustReleaseUnbounded] :: Level(_r_56) <= _current_wait_level_172) && _residue_172 <= _current_wait_level_172)
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 104 | p1_0@61@01 | live]
; [else-branch: 104 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 104 | p1_0@61@01]
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseBounded] :: Level(_r_56) <= _current_wait_level_172) && ((forperm _r_56: Ref [_r_56.MustReleaseUnbounded] :: Level(_r_56) <= _current_wait_level_172) && _residue_172 <= _current_wait_level_172)
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseBounded] :: Level(_r_56) <= _current_wait_level_172)
(push) ; 12
; [then-branch: 105 | False | live]
; [else-branch: 105 | True | live]
(push) ; 13
; [then-branch: 105 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 105 | True]
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseUnbounded] :: Level(_r_56) <= _current_wait_level_172)
(push) ; 14
; [then-branch: 106 | False | live]
; [else-branch: 106 | True | live]
(push) ; 15
; [then-branch: 106 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 106 | True]
; [eval] _residue_172 <= _current_wait_level_172
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (=> p1_0@61@01 (<= _residue_161@67@01 _current_wait_level_172@100@01)))
(assert (=
  ($Snap.second $t@102@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@102@01))
    ($Snap.second ($Snap.second $t@102@01)))))
(assert (= ($Snap.first ($Snap.second $t@102@01)) $Snap.unit))
; [eval] p2_31 ==> (forperm _r_56: Ref [_r_56.MustReleaseBoundedp] :: Level(_r_56) <= _current_wait_level_172_0) && ((forperm _r_56: Ref [_r_56.MustReleaseUnboundedp] :: Level(_r_56) <= _current_wait_level_172_0) && _residue_172_0 <= _current_wait_level_172_0)
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 107 | p2_0@62@01 | live]
; [else-branch: 107 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 107 | p2_0@62@01]
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseBoundedp] :: Level(_r_56) <= _current_wait_level_172_0) && ((forperm _r_56: Ref [_r_56.MustReleaseUnboundedp] :: Level(_r_56) <= _current_wait_level_172_0) && _residue_172_0 <= _current_wait_level_172_0)
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseBoundedp] :: Level(_r_56) <= _current_wait_level_172_0)
(push) ; 12
; [then-branch: 108 | False | live]
; [else-branch: 108 | True | live]
(push) ; 13
; [then-branch: 108 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 108 | True]
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseUnboundedp] :: Level(_r_56) <= _current_wait_level_172_0)
(push) ; 14
; [then-branch: 109 | False | live]
; [else-branch: 109 | True | live]
(push) ; 15
; [then-branch: 109 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 109 | True]
; [eval] _residue_172_0 <= _current_wait_level_172_0
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (=> p2_0@62@01 (<= _residue_161_0@68@01 _current_wait_level_172_0@101@01)))
(assert (=
  ($Snap.second ($Snap.second $t@102@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 110 | p1_0@61@01 | live]
; [else-branch: 110 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 110 | p1_0@61@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@102@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))))
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 111 | p2_0@62@01 | live]
; [else-branch: 111 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 111 | p2_0@62@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@102@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))
  $Snap.unit))
; [eval] typeof(self_5) == typeof(self_5_0) ==> p1_31 && p2_31 ==> Lock_invariant_low(self_5, self_5_0)
; [eval] typeof(self_5) == typeof(self_5_0)
; [eval] typeof(self_5)
; [eval] typeof(self_5_0)
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not (= (typeof<PyType> l@69@01) (typeof<PyType> l_1@70@01)))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= (typeof<PyType> l@69@01) (typeof<PyType> l_1@70@01))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 112 | typeof[PyType](l@69@01) == typeof[PyType](l_1@70@01) | live]
; [else-branch: 112 | typeof[PyType](l@69@01) != typeof[PyType](l_1@70@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 112 | typeof[PyType](l@69@01) == typeof[PyType](l_1@70@01)]
(assert (= (typeof<PyType> l@69@01) (typeof<PyType> l_1@70@01)))
; [eval] p1_31 && p2_31 ==> Lock_invariant_low(self_5, self_5_0)
; [eval] p1_31 && p2_31
(push) ; 14
; [then-branch: 113 | !(p1_0@61@01) | live]
; [else-branch: 113 | p1_0@61@01 | live]
(push) ; 15
; [then-branch: 113 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 15
(push) ; 15
; [else-branch: 113 | p1_0@61@01]
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 114 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 114 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 114 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] Lock_invariant_low(self_5, self_5_0)
(push) ; 16
(declare-const $k@103@01 $Perm)
(assert ($Perm.isReadVar $k@103@01))
(push) ; 17
(set-option :timeout 10)
(assert (not (< $Perm.No $k@103@01)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(declare-const $k@104@01 $Perm)
(assert ($Perm.isReadVar $k@104@01))
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (< $Perm.No $k@104@01)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01))
(pop) ; 16
; Joined path conditions
(assert ($Perm.isReadVar $k@103@01))
(assert ($Perm.isReadVar $k@104@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert ($Perm.isReadVar $k@103@01))
(assert ($Perm.isReadVar $k@104@01))
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (and
    p1_0@61@01
    p2_0@62@01
    (Lock_invariant_low%precondition ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01))))
(assert (and p1_0@61@01 p2_0@62@01))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert ($Perm.isReadVar $k@103@01))
(assert ($Perm.isReadVar $k@104@01))
(assert (=>
  (= (typeof<PyType> l@69@01) (typeof<PyType> l_1@70@01))
  (and
    (= (typeof<PyType> l@69@01) (typeof<PyType> l_1@70@01))
    (=>
      (and p1_0@61@01 p2_0@62@01)
      (and
        p1_0@61@01
        p2_0@62@01
        (Lock_invariant_low%precondition ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01)))
    p1_0@61@01
    p2_0@62@01)))
(assert (= (typeof<PyType> l@69@01) (typeof<PyType> l_1@70@01)))
(assert (=>
  (and
    (= (typeof<PyType> l@69@01) (typeof<PyType> l_1@70@01))
    (and p1_0@61@01 p2_0@62@01))
  (Lock_invariant_low ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))))))
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 115 | p1_0@61@01 | live]
; [else-branch: 115 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 115 | p1_0@61@01]
(assert p1_0@61@01)
(assert (not (= l@69@01 $Ref.null)))
(push) ; 13
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 116 | p2_0@62@01 | live]
; [else-branch: 116 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 116 | p2_0@62@01]
(assert p2_0@62@01)
(assert (not (= l_1@70@01 $Ref.null)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 117 | p1_0@61@01 | live]
; [else-branch: 117 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 117 | p1_0@61@01]
; [exec]
; _cwl_161 := tmp1_3
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 118 | p2_0@62@01 | live]
; [else-branch: 118 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 118 | p2_0@62@01]
; [exec]
; _cwl_161_0 := tmp2_3
; [exec]
; assert p1_0 && p2_0 ==>
;   perm(Lock_invariant(l_0)) >= write &&
;   perm(Lock_invariant_0(l_0_0)) >= write ==>
;   Lock_invariant_low(l_0, l_0_0)
; [eval] p1_0 && p2_0 ==> perm(Lock_invariant(l_0)) >= write && perm(Lock_invariant_0(l_0_0)) >= write ==> Lock_invariant_low(l_0, l_0_0)
; [eval] p1_0 && p2_0
(push) ; 16
; [then-branch: 119 | !(p1_0@61@01) | live]
; [else-branch: 119 | p1_0@61@01 | live]
(push) ; 17
; [then-branch: 119 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 17
(push) ; 17
; [else-branch: 119 | p1_0@61@01]
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 120 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 120 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 120 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] perm(Lock_invariant(l_0)) >= write && perm(Lock_invariant_0(l_0_0)) >= write ==> Lock_invariant_low(l_0, l_0_0)
; [eval] perm(Lock_invariant(l_0)) >= write && perm(Lock_invariant_0(l_0_0)) >= write
; [eval] perm(Lock_invariant(l_0)) >= write
; [eval] perm(Lock_invariant(l_0))
(push) ; 18
; [then-branch: 121 | False | live]
; [else-branch: 121 | True | live]
(push) ; 19
; [then-branch: 121 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 121 | True]
; [eval] perm(Lock_invariant_0(l_0_0)) >= write
; [eval] perm(Lock_invariant_0(l_0_0))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(push) ; 18
(push) ; 19
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 122 | True | live]
; [else-branch: 122 | False | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 122 | True]
; [eval] Lock_invariant_low(l_0, l_0_0)
(push) ; 20
(declare-const $k@105@01 $Perm)
(assert ($Perm.isReadVar $k@105@01))
(push) ; 21
(set-option :timeout 10)
(assert (not (< $Perm.No $k@105@01)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(declare-const $k@106@01 $Perm)
(assert ($Perm.isReadVar $k@106@01))
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (< $Perm.No $k@106@01)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01))
(pop) ; 20
; Joined path conditions
(assert ($Perm.isReadVar $k@105@01))
(assert ($Perm.isReadVar $k@106@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert ($Perm.isReadVar $k@105@01))
(assert ($Perm.isReadVar $k@106@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert ($Perm.isReadVar $k@105@01))
(assert ($Perm.isReadVar $k@106@01))
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (and
    p1_0@61@01
    p2_0@62@01
    (Lock_invariant_low%precondition ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01))))
(assert (and p1_0@61@01 p2_0@62@01))
(set-option :timeout 0)
(push) ; 16
(assert (not (=>
  (and p1_0@61@01 p2_0@62@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))) l@69@01 l_1@70@01)))
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 123 | p1_0@61@01 | live]
; [else-branch: 123 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 123 | p1_0@61@01]
; [exec]
; unfold acc(Lock_invariant(l_0), write)
(assert (=
  ($Snap.first ($Snap.second ($Snap.second $t@102@01)))
  ($Snap.combine
    ($Snap.first ($Snap.first ($Snap.second ($Snap.second $t@102@01))))
    ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))))
(assert (=
  ($Snap.first ($Snap.first ($Snap.second ($Snap.second $t@102@01))))
  $Snap.unit))
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
(assert (issubtype<Bool> (typeof<PyType> l@69@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> l@69@01) 0))))
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
(push) ; 17
(set-option :timeout 10)
(assert (not (not (issubtype<Bool> (typeof<PyType> l@69@01) (as CellLock<PyType>  PyType)))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (issubtype<Bool> (typeof<PyType> l@69@01) (as CellLock<PyType>  PyType))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 124 | issubtype[Bool](typeof[PyType](l@69@01), CellLock[PyType]) | live]
; [else-branch: 124 | !(issubtype[Bool](typeof[PyType](l@69@01), CellLock[PyType])) | live]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 124 | issubtype[Bool](typeof[PyType](l@69@01), CellLock[PyType])]
(assert (issubtype<Bool> (typeof<PyType> l@69@01) (as CellLock<PyType>  PyType)))
(assert (=
  ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))
    ($Snap.second ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01))))))))
; [eval] Lock_get_locked(self_7)
(push) ; 18
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
(push) ; 19
(assert (not (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> l@69@01) 0) (as object<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> l@69@01) 0) (as object<PyType>  PyType)))
; [eval] self_3 != null
(assert (Lock_get_locked%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine $Snap.unit $Snap.unit)) l@69@01))
(pop) ; 18
; Joined path conditions
(assert (and
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> l@69@01) 0) (as object<PyType>  PyType))
  (Lock_get_locked%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) l@69@01)))
(assert (not
  (=
    (Lock_get_locked ($Snap.combine
      $Snap.unit
      ($Snap.combine $Snap.unit $Snap.unit)) l@69@01)
    $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))
  $Snap.unit))
; [eval] issubtype(typeof(Lock_get_locked(self_7).Cell_val), int())
; [eval] typeof(Lock_get_locked(self_7).Cell_val)
; [eval] Lock_get_locked(self_7)
(push) ; 18
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 18
; Joined path conditions
; [eval] int()
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01))))))) (as int<PyType>  PyType)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (Lock_invariant%trigger ($Snap.first ($Snap.second ($Snap.second $t@102@01))) l@69@01))
(set-option :timeout 0)
(push) ; 18
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 125 | p2_0@62@01 | live]
; [else-branch: 125 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 125 | p2_0@62@01]
; [exec]
; unfold acc(Lock_invariant_0(l_0_0), write)
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))
  ($Snap.combine
    ($Snap.first ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))
    ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))))
(assert (=
  ($Snap.first ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))
  $Snap.unit))
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
(assert (issubtype<Bool> (typeof<PyType> l_1@70@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> l_1@70@01) 0))))
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
(push) ; 19
(set-option :timeout 10)
(assert (not (not (issubtype<Bool> (typeof<PyType> l_1@70@01) (as CellLock<PyType>  PyType)))))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (issubtype<Bool> (typeof<PyType> l_1@70@01) (as CellLock<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 126 | issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType]) | live]
; [else-branch: 126 | !(issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType])) | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 126 | issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType])]
(assert (issubtype<Bool> (typeof<PyType> l_1@70@01) (as CellLock<PyType>  PyType)))
(assert (=
  ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
    ($Snap.second ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))))))
; [eval] Lock_get_locked(self_7)
(push) ; 20
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
(push) ; 21
(assert (not (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> l_1@70@01) 0) (as object<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> l_1@70@01) 0) (as object<PyType>  PyType)))
; [eval] self_3 != null
(assert (Lock_get_locked%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine $Snap.unit $Snap.unit)) l_1@70@01))
(pop) ; 20
; Joined path conditions
(assert (and
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> l_1@70@01) 0) (as object<PyType>  PyType))
  (Lock_get_locked%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) l_1@70@01)))
(assert (not
  (=
    (Lock_get_locked ($Snap.combine
      $Snap.unit
      ($Snap.combine $Snap.unit $Snap.unit)) l_1@70@01)
    $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
  $Snap.unit))
; [eval] issubtype(typeof(Lock_get_locked(self_7).Cell_valp), int())
; [eval] typeof(Lock_get_locked(self_7).Cell_valp)
; [eval] Lock_get_locked(self_7)
(push) ; 20
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 20
; Joined path conditions
; [eval] int()
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))))) (as int<PyType>  PyType)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (Lock_invariant_0%trigger ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01)))) l_1@70@01))
; [eval] p1_0 || p2_0
(set-option :timeout 0)
(push) ; 20
; [then-branch: 127 | p1_0@61@01 | live]
; [else-branch: 127 | !(p1_0@61@01) | live]
(push) ; 21
; [then-branch: 127 | p1_0@61@01]
(pop) ; 21
(push) ; 21
; [else-branch: 127 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
(set-option :timeout 10)
(assert (not (not (or p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 128 | p1_0@61@01 || p2_0@62@01 | live]
; [else-branch: 128 | !(p1_0@61@01 || p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 128 | p1_0@61@01 || p2_0@62@01]
; [exec]
; var tmp1_4: Ref
(declare-const tmp1_4@107@01 $Ref)
; [exec]
; var tmp2_4: Ref
(declare-const tmp2_4@108@01 $Ref)
; [exec]
; var tmp1_5: Seq[Measure$]
(declare-const tmp1_5@109@01 Seq<Measure$>)
; [exec]
; var tmp2_5: Seq[Measure$]
(declare-const tmp2_5@110@01 Seq<Measure$>)
; [exec]
; var tmp1_6: Perm
(declare-const tmp1_6@111@01 $Perm)
; [exec]
; var tmp2_6: Perm
(declare-const tmp2_6@112@01 $Perm)
; [exec]
; var tmp1_7: Ref
(declare-const tmp1_7@113@01 $Ref)
; [exec]
; var tmp2_7: Ref
(declare-const tmp2_7@114@01 $Ref)
; [exec]
; var tmp1_8: Perm
(declare-const tmp1_8@115@01 $Perm)
; [exec]
; var tmp2_8: Perm
(declare-const tmp2_8@116@01 $Perm)
(push) ; 21
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 129 | p1_0@61@01 | live]
; [else-branch: 129 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 129 | p1_0@61@01]
; [exec]
; tmp1_4 := _cthread_161
; [exec]
; tmp1_5 := _method_measures_161
; [exec]
; tmp1_6 := _residue_161
; [exec]
; tmp1_7 := x_5
(push) ; 22
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 130 | p2_0@62@01 | live]
; [else-branch: 130 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 130 | p2_0@62@01]
; [exec]
; tmp2_4 := _cthread_161_0
; [exec]
; tmp2_5 := _method_measures_161_0
; [exec]
; tmp2_6 := _residue_161_0
; [exec]
; tmp2_7 := x_5_0
; [exec]
; tmp1_8, tmp2_8 := sif_print(p1_0, p2_0, tmp1_4, tmp2_4, tmp1_5, tmp2_5, tmp1_6,
;   tmp2_6, tmp1_7, tmp2_7)
; [eval] p1 ==> _cthread_160 != null
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 131 | p1_0@61@01 | live]
; [else-branch: 131 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 131 | p1_0@61@01]
; [eval] _cthread_160 != null
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2 ==> _cthread_160_0 != null
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 132 | p2_0@62@01 | live]
; [else-branch: 132 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 132 | p2_0@62@01]
; [eval] _cthread_160_0 != null
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(_cthread_160), Thread_0())
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 133 | p1_0@61@01 | live]
; [else-branch: 133 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 133 | p1_0@61@01]
; [eval] issubtype(typeof(_cthread_160), Thread_0())
; [eval] typeof(_cthread_160)
; [eval] Thread_0()
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2 ==> issubtype(typeof(_cthread_160_0), Thread_0())
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 134 | p2_0@62@01 | live]
; [else-branch: 134 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 134 | p2_0@62@01]
; [eval] issubtype(typeof(_cthread_160_0), Thread_0())
; [eval] typeof(_cthread_160_0)
; [eval] Thread_0()
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(x_0), int())
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 135 | p1_0@61@01 | live]
; [else-branch: 135 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 135 | p1_0@61@01]
; [eval] issubtype(typeof(x_0), int())
; [eval] typeof(x_0)
; [eval] int()
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2 ==> issubtype(typeof(x_0_0), int())
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 136 | p2_0@62@01 | live]
; [else-branch: 136 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 136 | p2_0@62@01]
; [eval] issubtype(typeof(x_0_0), int())
; [eval] typeof(x_0_0)
; [eval] int()
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p1 == p2
; [eval] p1 && p2 ==> int___eq__(x_0, x_0_0)
; [eval] p1 && p2
(push) ; 23
; [then-branch: 137 | !(p1_0@61@01) | live]
; [else-branch: 137 | p1_0@61@01 | live]
(push) ; 24
; [then-branch: 137 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 24
(push) ; 24
; [else-branch: 137 | p1_0@61@01]
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 138 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 138 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 138 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] int___eq__(x_0, x_0_0)
(push) ; 25
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 26
(assert (not (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 26
(assert (not (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01))
(pop) ; 25
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (and
    p1_0@61@01
    p2_0@62@01
    (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01))))
(assert (and p1_0@61@01 p2_0@62@01))
(push) ; 23
(assert (not (=>
  (and p1_0@61@01 p2_0@62@01)
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01)))
; [eval] p1 ==> true
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 139 | p1_0@61@01 | live]
; [else-branch: 139 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 139 | p1_0@61@01]
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2 ==> true
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 140 | p2_0@62@01 | live]
; [else-branch: 140 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 140 | p2_0@62@01]
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p1 ==> Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 141 | p1_0@61@01 | live]
; [else-branch: 141 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 141 | p1_0@61@01]
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1)
(push) ; 25
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 25
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(push) ; 25
; [then-branch: 142 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1) | live]
; [else-branch: 142 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)) | live]
(push) ; 26
; [then-branch: 142 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 26
(push) ; 26
; [else-branch: 142 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1))]
(assert (not (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
; [eval] perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_160)) == none
; [eval] perm(MustTerminate(_cthread_160))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
  (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2 ==> Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 143 | p2_0@62@01 | live]
; [else-branch: 143 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 143 | p2_0@62@01]
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1)
(push) ; 25
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 25
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(push) ; 25
; [then-branch: 144 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1) | live]
; [else-branch: 144 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)) | live]
(push) ; 26
; [then-branch: 144 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 26
(push) ; 26
; [else-branch: 144 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1))]
(assert (not
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none
; [eval] perm(MustTerminate_0(_cthread_160_0))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(declare-const _current_wait_level_160@117@01 $Perm)
(declare-const _current_wait_level_160_0@118@01 $Perm)
(declare-const $t@119@01 $Snap)
(assert (= $t@119@01 ($Snap.combine ($Snap.first $t@119@01) ($Snap.second $t@119@01))))
(assert (= ($Snap.first $t@119@01) $Snap.unit))
; [eval] p1 ==> (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 145 | p1_0@61@01 | live]
; [else-branch: 145 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 145 | p1_0@61@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 25
; [then-branch: 146 | False | live]
; [else-branch: 146 | True | live]
(push) ; 26
; [then-branch: 146 | False]
(assert false)
(pop) ; 26
(push) ; 26
; [else-branch: 146 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 27
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 147 | True | live]
; [else-branch: 147 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 147 | True]
; [eval] Level(_r) <= _current_wait_level_160
; [eval] Level(_r)
(push) ; 29
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 29
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 28
(pop) ; 27
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(push) ; 27
; [then-branch: 148 | !(Level(_, l@69@01) <= _current_wait_level_160@117@01) | live]
; [else-branch: 148 | Level(_, l@69@01) <= _current_wait_level_160@117@01 | live]
(push) ; 28
; [then-branch: 148 | !(Level(_, l@69@01) <= _current_wait_level_160@117@01)]
(assert (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@117@01)))
(pop) ; 28
(push) ; 28
; [else-branch: 148 | Level(_, l@69@01) <= _current_wait_level_160@117@01]
(assert (<= (Level $Snap.unit l@69@01) _current_wait_level_160@117@01))
; [eval] _residue_160 <= _current_wait_level_160
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(assert (or
  (<= (Level $Snap.unit l@69@01) _current_wait_level_160@117@01)
  (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@117@01))))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(assert (and
  (Level%precondition $Snap.unit l@69@01)
  (or
    (<= (Level $Snap.unit l@69@01) _current_wait_level_160@117@01)
    (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@117@01)))))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (=>
  p1_0@61@01
  (and
    (Level%precondition $Snap.unit l@69@01)
    (or
      (<= (Level $Snap.unit l@69@01) _current_wait_level_160@117@01)
      (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@117@01))))))
(assert (=>
  p1_0@61@01
  (and
    (<= (Level $Snap.unit l@69@01) _current_wait_level_160@117@01)
    (<= _residue_161@67@01 _current_wait_level_160@117@01))))
(assert (=
  ($Snap.second $t@119@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@119@01))
    ($Snap.second ($Snap.second $t@119@01)))))
(assert (= ($Snap.first ($Snap.second $t@119@01)) $Snap.unit))
; [eval] p2 ==> (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 149 | p2_0@62@01 | live]
; [else-branch: 149 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 149 | p2_0@62@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 25
; [then-branch: 150 | False | live]
; [else-branch: 150 | True | live]
(push) ; 26
; [then-branch: 150 | False]
(assert false)
(pop) ; 26
(push) ; 26
; [else-branch: 150 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 27
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 151 | True | live]
; [else-branch: 151 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 151 | True]
; [eval] Level(_r) <= _current_wait_level_160_0
; [eval] Level(_r)
(push) ; 29
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 29
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 28
(pop) ; 27
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(push) ; 27
; [then-branch: 152 | !(Level(_, l_1@70@01) <= _current_wait_level_160_0@118@01) | live]
; [else-branch: 152 | Level(_, l_1@70@01) <= _current_wait_level_160_0@118@01 | live]
(push) ; 28
; [then-branch: 152 | !(Level(_, l_1@70@01) <= _current_wait_level_160_0@118@01)]
(assert (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@118@01)))
(pop) ; 28
(push) ; 28
; [else-branch: 152 | Level(_, l_1@70@01) <= _current_wait_level_160_0@118@01]
(assert (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@118@01))
; [eval] _residue_160_0 <= _current_wait_level_160_0
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(assert (or
  (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@118@01)
  (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@118@01))))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(assert (and
  (Level%precondition $Snap.unit l_1@70@01)
  (or
    (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@118@01)
    (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@118@01)))))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (=>
  p2_0@62@01
  (and
    (Level%precondition $Snap.unit l_1@70@01)
    (or
      (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@118@01)
      (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@118@01))))))
(assert (=>
  p2_0@62@01
  (and
    (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@118@01)
    (<= _residue_161_0@68@01 _current_wait_level_160_0@118@01))))
(assert (=
  ($Snap.second ($Snap.second $t@119@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@119@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@119@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@119@01))) $Snap.unit))
; [eval] p1 ==> true
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 153 | p1_0@61@01 | live]
; [else-branch: 153 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 153 | p1_0@61@01]
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@119@01))) $Snap.unit))
; [eval] p2 ==> true
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 154 | p2_0@62@01 | live]
; [else-branch: 154 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 154 | p2_0@62@01]
(pop) ; 24
(pop) ; 23
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 155 | p1_0@61@01 | live]
; [else-branch: 155 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 155 | p1_0@61@01]
; [exec]
; _cwl_161 := tmp1_8
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 156 | p2_0@62@01 | live]
; [else-branch: 156 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 156 | p2_0@62@01]
; [exec]
; _cwl_161_0 := tmp2_8
; [eval] p1_0 || p2_0
(push) ; 25
; [then-branch: 157 | p1_0@61@01 | live]
; [else-branch: 157 | !(p1_0@61@01) | live]
(push) ; 26
; [then-branch: 157 | p1_0@61@01]
(pop) ; 26
(push) ; 26
; [else-branch: 157 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(push) ; 25
(set-option :timeout 10)
(assert (not (not (or p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 158 | p1_0@61@01 || p2_0@62@01 | live]
; [else-branch: 158 | !(p1_0@61@01 || p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 158 | p1_0@61@01 || p2_0@62@01]
; [exec]
; var tmp1_9: Ref
(declare-const tmp1_9@120@01 $Ref)
; [exec]
; var tmp2_9: Ref
(declare-const tmp2_9@121@01 $Ref)
; [exec]
; var tmp1_10: Seq[Measure$]
(declare-const tmp1_10@122@01 Seq<Measure$>)
; [exec]
; var tmp2_10: Seq[Measure$]
(declare-const tmp2_10@123@01 Seq<Measure$>)
; [exec]
; var tmp1_11: Perm
(declare-const tmp1_11@124@01 $Perm)
; [exec]
; var tmp2_11: Perm
(declare-const tmp2_11@125@01 $Perm)
; [exec]
; var tmp1_12: Ref
(declare-const tmp1_12@126@01 $Ref)
; [exec]
; var tmp2_12: Ref
(declare-const tmp2_12@127@01 $Ref)
; [exec]
; var tmp1_13: Perm
(declare-const tmp1_13@128@01 $Perm)
; [exec]
; var tmp2_13: Perm
(declare-const tmp2_13@129@01 $Perm)
(push) ; 26
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 159 | p1_0@61@01 | live]
; [else-branch: 159 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 159 | p1_0@61@01]
; [exec]
; tmp1_9 := _cthread_161
; [exec]
; tmp1_10 := _method_measures_161
; [exec]
; tmp1_11 := _residue_161
; [exec]
; tmp1_12 := x_5
(push) ; 27
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 160 | p2_0@62@01 | live]
; [else-branch: 160 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 160 | p2_0@62@01]
; [exec]
; tmp2_9 := _cthread_161_0
; [exec]
; tmp2_10 := _method_measures_161_0
; [exec]
; tmp2_11 := _residue_161_0
; [exec]
; tmp2_12 := x_5_0
; [exec]
; tmp1_13, tmp2_13 := sif_print(p1_0, p2_0, tmp1_9, tmp2_9, tmp1_10, tmp2_10,
;   tmp1_11, tmp2_11, tmp1_12, tmp2_12)
; [eval] p1 ==> _cthread_160 != null
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 161 | p1_0@61@01 | live]
; [else-branch: 161 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 161 | p1_0@61@01]
; [eval] _cthread_160 != null
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p2 ==> _cthread_160_0 != null
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 162 | p2_0@62@01 | live]
; [else-branch: 162 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 162 | p2_0@62@01]
; [eval] _cthread_160_0 != null
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(_cthread_160), Thread_0())
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 163 | p1_0@61@01 | live]
; [else-branch: 163 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 163 | p1_0@61@01]
; [eval] issubtype(typeof(_cthread_160), Thread_0())
; [eval] typeof(_cthread_160)
; [eval] Thread_0()
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p2 ==> issubtype(typeof(_cthread_160_0), Thread_0())
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 164 | p2_0@62@01 | live]
; [else-branch: 164 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 164 | p2_0@62@01]
; [eval] issubtype(typeof(_cthread_160_0), Thread_0())
; [eval] typeof(_cthread_160_0)
; [eval] Thread_0()
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(x_0), int())
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 165 | p1_0@61@01 | live]
; [else-branch: 165 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 165 | p1_0@61@01]
; [eval] issubtype(typeof(x_0), int())
; [eval] typeof(x_0)
; [eval] int()
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p2 ==> issubtype(typeof(x_0_0), int())
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 166 | p2_0@62@01 | live]
; [else-branch: 166 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 166 | p2_0@62@01]
; [eval] issubtype(typeof(x_0_0), int())
; [eval] typeof(x_0_0)
; [eval] int()
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p1 == p2
; [eval] p1 && p2 ==> int___eq__(x_0, x_0_0)
; [eval] p1 && p2
(push) ; 28
; [then-branch: 167 | !(p1_0@61@01) | live]
; [else-branch: 167 | p1_0@61@01 | live]
(push) ; 29
; [then-branch: 167 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 29
(push) ; 29
; [else-branch: 167 | p1_0@61@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
; Joined path conditions
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 29
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 168 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 168 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 168 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] int___eq__(x_0, x_0_0)
(push) ; 30
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 31
(assert (not (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 31
(assert (not (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01))
(pop) ; 30
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01)))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] p1 ==> true
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 169 | p1_0@61@01 | live]
; [else-branch: 169 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 169 | p1_0@61@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p2 ==> true
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 170 | p2_0@62@01 | live]
; [else-branch: 170 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 170 | p2_0@62@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p1 ==> Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 171 | p1_0@61@01 | live]
; [else-branch: 171 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 171 | p1_0@61@01]
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1)
(push) ; 30
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 30
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(push) ; 30
; [then-branch: 172 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1) | live]
; [else-branch: 172 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)) | live]
(push) ; 31
; [then-branch: 172 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 31
(push) ; 31
; [else-branch: 172 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1))]
(assert (not (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
; [eval] perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_160)) == none
; [eval] perm(MustTerminate(_cthread_160))
(pop) ; 31
(pop) ; 30
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
  (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p2 ==> Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 173 | p2_0@62@01 | live]
; [else-branch: 173 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 173 | p2_0@62@01]
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1)
(push) ; 30
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 30
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(push) ; 30
; [then-branch: 174 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1) | live]
; [else-branch: 174 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)) | live]
(push) ; 31
; [then-branch: 174 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 31
(push) ; 31
; [else-branch: 174 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1))]
(assert (not
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none
; [eval] perm(MustTerminate_0(_cthread_160_0))
(pop) ; 31
(pop) ; 30
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(declare-const _current_wait_level_160@130@01 $Perm)
(declare-const _current_wait_level_160_0@131@01 $Perm)
(declare-const $t@132@01 $Snap)
(assert (= $t@132@01 ($Snap.combine ($Snap.first $t@132@01) ($Snap.second $t@132@01))))
(assert (= ($Snap.first $t@132@01) $Snap.unit))
; [eval] p1 ==> (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 175 | p1_0@61@01 | live]
; [else-branch: 175 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 175 | p1_0@61@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 30
; [then-branch: 176 | False | live]
; [else-branch: 176 | True | live]
(push) ; 31
; [then-branch: 176 | False]
(assert false)
(pop) ; 31
(push) ; 31
; [else-branch: 176 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 32
(push) ; 33
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
; [then-branch: 177 | True | live]
; [else-branch: 177 | False | dead]
(set-option :timeout 0)
(push) ; 33
; [then-branch: 177 | True]
; [eval] Level(_r) <= _current_wait_level_160
; [eval] Level(_r)
(push) ; 34
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 34
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 33
(pop) ; 32
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(push) ; 32
; [then-branch: 178 | !(Level(_, l@69@01) <= _current_wait_level_160@130@01) | live]
; [else-branch: 178 | Level(_, l@69@01) <= _current_wait_level_160@130@01 | live]
(push) ; 33
; [then-branch: 178 | !(Level(_, l@69@01) <= _current_wait_level_160@130@01)]
(assert (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@130@01)))
(pop) ; 33
(push) ; 33
; [else-branch: 178 | Level(_, l@69@01) <= _current_wait_level_160@130@01]
(assert (<= (Level $Snap.unit l@69@01) _current_wait_level_160@130@01))
; [eval] _residue_160 <= _current_wait_level_160
(pop) ; 33
(pop) ; 32
; Joined path conditions
; Joined path conditions
(assert (or
  (<= (Level $Snap.unit l@69@01) _current_wait_level_160@130@01)
  (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@130@01))))
(pop) ; 31
(pop) ; 30
; Joined path conditions
; Joined path conditions
(assert (and
  (Level%precondition $Snap.unit l@69@01)
  (or
    (<= (Level $Snap.unit l@69@01) _current_wait_level_160@130@01)
    (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@130@01)))))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert (=>
  p1_0@61@01
  (and
    (Level%precondition $Snap.unit l@69@01)
    (or
      (<= (Level $Snap.unit l@69@01) _current_wait_level_160@130@01)
      (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@130@01))))))
(assert (=>
  p1_0@61@01
  (and
    (<= (Level $Snap.unit l@69@01) _current_wait_level_160@130@01)
    (<= _residue_161@67@01 _current_wait_level_160@130@01))))
(assert (=
  ($Snap.second $t@132@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@132@01))
    ($Snap.second ($Snap.second $t@132@01)))))
(assert (= ($Snap.first ($Snap.second $t@132@01)) $Snap.unit))
; [eval] p2 ==> (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 179 | p2_0@62@01 | live]
; [else-branch: 179 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 179 | p2_0@62@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 30
; [then-branch: 180 | False | live]
; [else-branch: 180 | True | live]
(push) ; 31
; [then-branch: 180 | False]
(assert false)
(pop) ; 31
(push) ; 31
; [else-branch: 180 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 32
(push) ; 33
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
; [then-branch: 181 | True | live]
; [else-branch: 181 | False | dead]
(set-option :timeout 0)
(push) ; 33
; [then-branch: 181 | True]
; [eval] Level(_r) <= _current_wait_level_160_0
; [eval] Level(_r)
(push) ; 34
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 34
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 33
(pop) ; 32
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(push) ; 32
; [then-branch: 182 | !(Level(_, l_1@70@01) <= _current_wait_level_160_0@131@01) | live]
; [else-branch: 182 | Level(_, l_1@70@01) <= _current_wait_level_160_0@131@01 | live]
(push) ; 33
; [then-branch: 182 | !(Level(_, l_1@70@01) <= _current_wait_level_160_0@131@01)]
(assert (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@131@01)))
(pop) ; 33
(push) ; 33
; [else-branch: 182 | Level(_, l_1@70@01) <= _current_wait_level_160_0@131@01]
(assert (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@131@01))
; [eval] _residue_160_0 <= _current_wait_level_160_0
(pop) ; 33
(pop) ; 32
; Joined path conditions
; Joined path conditions
(assert (or
  (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@131@01)
  (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@131@01))))
(pop) ; 31
(pop) ; 30
; Joined path conditions
; Joined path conditions
(assert (and
  (Level%precondition $Snap.unit l_1@70@01)
  (or
    (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@131@01)
    (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@131@01)))))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert (=>
  p2_0@62@01
  (and
    (Level%precondition $Snap.unit l_1@70@01)
    (or
      (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@131@01)
      (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@131@01))))))
(assert (=>
  p2_0@62@01
  (and
    (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@131@01)
    (<= _residue_161_0@68@01 _current_wait_level_160_0@131@01))))
(assert (=
  ($Snap.second ($Snap.second $t@132@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@132@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@132@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@132@01))) $Snap.unit))
; [eval] p1 ==> true
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 183 | p1_0@61@01 | live]
; [else-branch: 183 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 183 | p1_0@61@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@132@01))) $Snap.unit))
; [eval] p2 ==> true
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 184 | p2_0@62@01 | live]
; [else-branch: 184 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 184 | p2_0@62@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 28
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 185 | p1_0@61@01 | live]
; [else-branch: 185 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 185 | p1_0@61@01]
; [exec]
; _cwl_161 := tmp1_13
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 186 | p2_0@62@01 | live]
; [else-branch: 186 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 186 | p2_0@62@01]
; [exec]
; _cwl_161_0 := tmp2_13
(push) ; 30
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
; [then-branch: 187 | p1_0@61@01 | live]
; [else-branch: 187 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 30
; [then-branch: 187 | p1_0@61@01]
; [exec]
; fold acc(Lock_invariant(l_0), write)
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
(push) ; 31
(set-option :timeout 10)
(assert (not (not (issubtype<Bool> (typeof<PyType> l@69@01) (as CellLock<PyType>  PyType)))))
(check-sat)
; unknown
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
; [then-branch: 188 | issubtype[Bool](typeof[PyType](l@69@01), CellLock[PyType]) | live]
; [else-branch: 188 | !(issubtype[Bool](typeof[PyType](l@69@01), CellLock[PyType])) | dead]
(set-option :timeout 0)
(push) ; 31
; [then-branch: 188 | issubtype[Bool](typeof[PyType](l@69@01), CellLock[PyType])]
; [eval] Lock_get_locked(self_7)
(push) ; 32
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 32
; Joined path conditions
; [eval] issubtype(typeof(Lock_get_locked(self_7).Cell_val), int())
; [eval] typeof(Lock_get_locked(self_7).Cell_val)
; [eval] Lock_get_locked(self_7)
(push) ; 32
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 32
; Joined path conditions
; [eval] int()
(assert (Lock_invariant%trigger ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))
    $Snap.unit)) l@69@01))
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 189 | p2_0@62@01 | live]
; [else-branch: 189 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 189 | p2_0@62@01]
; [exec]
; fold acc(Lock_invariant_0(l_0_0), write)
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
(push) ; 33
(set-option :timeout 10)
(assert (not (not (issubtype<Bool> (typeof<PyType> l_1@70@01) (as CellLock<PyType>  PyType)))))
(check-sat)
; unknown
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
; [then-branch: 190 | issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType]) | live]
; [else-branch: 190 | !(issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType])) | dead]
(set-option :timeout 0)
(push) ; 33
; [then-branch: 190 | issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType])]
; [eval] Lock_get_locked(self_7)
(push) ; 34
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 34
; Joined path conditions
; [eval] issubtype(typeof(Lock_get_locked(self_7).Cell_valp), int())
; [eval] typeof(Lock_get_locked(self_7).Cell_valp)
; [eval] Lock_get_locked(self_7)
(push) ; 34
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 34
; Joined path conditions
; [eval] int()
(assert (Lock_invariant_0%trigger ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
    $Snap.unit)) l_1@70@01))
; [exec]
; assert p1_0 && p2_0 ==> Lock_invariant_low(l_0, l_0_0)
; [eval] p1_0 && p2_0 ==> Lock_invariant_low(l_0, l_0_0)
; [eval] p1_0 && p2_0
(push) ; 34
; [then-branch: 191 | !(p1_0@61@01) | live]
; [else-branch: 191 | p1_0@61@01 | live]
(push) ; 35
; [then-branch: 191 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 35
(push) ; 35
; [else-branch: 191 | p1_0@61@01]
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(push) ; 34
(push) ; 35
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 35
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 192 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 192 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 192 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] Lock_invariant_low(l_0, l_0_0)
(push) ; 36
(declare-const $k@133@01 $Perm)
(assert ($Perm.isReadVar $k@133@01))
(push) ; 37
(set-option :timeout 10)
(assert (not (< $Perm.No $k@133@01)))
(check-sat)
; unsat
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
(declare-const $k@134@01 $Perm)
(assert ($Perm.isReadVar $k@134@01))
(set-option :timeout 0)
(push) ; 37
(set-option :timeout 10)
(assert (not (< $Perm.No $k@134@01)))
(check-sat)
; unsat
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
      $Snap.unit))) l@69@01 l_1@70@01))
(pop) ; 36
; Joined path conditions
(assert ($Perm.isReadVar $k@133@01))
(assert ($Perm.isReadVar $k@134@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
      $Snap.unit))) l@69@01 l_1@70@01))
(pop) ; 35
(pop) ; 34
; Joined path conditions
(assert ($Perm.isReadVar $k@133@01))
(assert ($Perm.isReadVar $k@134@01))
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (and
    p1_0@61@01
    p2_0@62@01
    (Lock_invariant_low%precondition ($Snap.combine
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))
          $Snap.unit))
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
          $Snap.unit))) l@69@01 l_1@70@01))))
(assert (and p1_0@61@01 p2_0@62@01))
(set-option :timeout 0)
(push) ; 34
(assert (not (=>
  (and p1_0@61@01 p2_0@62@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))
        $Snap.unit))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
        $Snap.unit))) l@69@01 l_1@70@01))))
(check-sat)
; unsat
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))
        $Snap.unit))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
        $Snap.unit))) l@69@01 l_1@70@01)))
; [eval] p1_0 || p2_0
(push) ; 34
; [then-branch: 193 | p1_0@61@01 | live]
; [else-branch: 193 | !(p1_0@61@01) | live]
(push) ; 35
; [then-branch: 193 | p1_0@61@01]
(pop) ; 35
(push) ; 35
; [else-branch: 193 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(push) ; 34
(set-option :timeout 10)
(assert (not (not (or p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 194 | p1_0@61@01 || p2_0@62@01 | live]
; [else-branch: 194 | !(p1_0@61@01 || p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 194 | p1_0@61@01 || p2_0@62@01]
; [exec]
; var tmp1_14: Ref
(declare-const tmp1_14@135@01 $Ref)
; [exec]
; var tmp2_14: Ref
(declare-const tmp2_14@136@01 $Ref)
; [exec]
; var tmp1_15: Seq[Measure$]
(declare-const tmp1_15@137@01 Seq<Measure$>)
; [exec]
; var tmp2_15: Seq[Measure$]
(declare-const tmp2_15@138@01 Seq<Measure$>)
; [exec]
; var tmp1_16: Perm
(declare-const tmp1_16@139@01 $Perm)
; [exec]
; var tmp2_16: Perm
(declare-const tmp2_16@140@01 $Perm)
; [exec]
; var tmp1_17: Ref
(declare-const tmp1_17@141@01 $Ref)
; [exec]
; var tmp2_17: Ref
(declare-const tmp2_17@142@01 $Ref)
; [exec]
; var tmp1_18: Perm
(declare-const tmp1_18@143@01 $Perm)
; [exec]
; var tmp2_18: Perm
(declare-const tmp2_18@144@01 $Perm)
(push) ; 35
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 195 | p1_0@61@01 | live]
; [else-branch: 195 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 195 | p1_0@61@01]
; [exec]
; tmp1_14 := _cthread_161
; [exec]
; tmp1_15 := _method_measures_161
; [exec]
; tmp1_16 := _residue_161
; [exec]
; tmp1_17 := l_0
(push) ; 36
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 196 | p2_0@62@01 | live]
; [else-branch: 196 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 36
; [then-branch: 196 | p2_0@62@01]
; [exec]
; tmp2_14 := _cthread_161_0
; [exec]
; tmp2_15 := _method_measures_161_0
; [exec]
; tmp2_16 := _residue_161_0
; [exec]
; tmp2_17 := l_0_0
; [exec]
; tmp1_18, tmp2_18 := Lock_release(p1_0, p2_0, tmp1_14, tmp2_14, tmp1_15, tmp2_15,
;   tmp1_16, tmp2_16, tmp1_17, tmp2_17)
; [eval] p1_32 ==> _cthread_173 != null
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 197 | p1_0@61@01 | live]
; [else-branch: 197 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 197 | p1_0@61@01]
; [eval] _cthread_173 != null
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> _cthread_173_0 != null
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 198 | p2_0@62@01 | live]
; [else-branch: 198 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 198 | p2_0@62@01]
; [eval] _cthread_173_0 != null
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p1_32 ==> issubtype(typeof(_cthread_173), Thread_0())
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 199 | p1_0@61@01 | live]
; [else-branch: 199 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 199 | p1_0@61@01]
; [eval] issubtype(typeof(_cthread_173), Thread_0())
; [eval] typeof(_cthread_173)
; [eval] Thread_0()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> issubtype(typeof(_cthread_173_0), Thread_0())
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 200 | p2_0@62@01 | live]
; [else-branch: 200 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 200 | p2_0@62@01]
; [eval] issubtype(typeof(_cthread_173_0), Thread_0())
; [eval] typeof(_cthread_173_0)
; [eval] Thread_0()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p1_32 ==> issubtype(typeof(self_6), Lock(Lock_arg(typeof(self_6), 0)))
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 201 | p1_0@61@01 | live]
; [else-branch: 201 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 201 | p1_0@61@01]
; [eval] issubtype(typeof(self_6), Lock(Lock_arg(typeof(self_6), 0)))
; [eval] typeof(self_6)
; [eval] Lock(Lock_arg(typeof(self_6), 0))
; [eval] Lock_arg(typeof(self_6), 0)
; [eval] typeof(self_6)
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> issubtype(typeof(self_6_0), Lock(Lock_arg(typeof(self_6_0), 0)))
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 202 | p2_0@62@01 | live]
; [else-branch: 202 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 202 | p2_0@62@01]
; [eval] issubtype(typeof(self_6_0), Lock(Lock_arg(typeof(self_6_0), 0)))
; [eval] typeof(self_6_0)
; [eval] Lock(Lock_arg(typeof(self_6_0), 0))
; [eval] Lock_arg(typeof(self_6_0), 0)
; [eval] typeof(self_6_0)
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p1_32 ==> issubtype(Lock_arg(typeof(self_6), 0), object())
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 203 | p1_0@61@01 | live]
; [else-branch: 203 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 203 | p1_0@61@01]
; [eval] issubtype(Lock_arg(typeof(self_6), 0), object())
; [eval] Lock_arg(typeof(self_6), 0)
; [eval] typeof(self_6)
; [eval] object()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> issubtype(Lock_arg(typeof(self_6_0), 0), object())
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 204 | p2_0@62@01 | live]
; [else-branch: 204 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 204 | p2_0@62@01]
; [eval] issubtype(Lock_arg(typeof(self_6_0), 0), object())
; [eval] Lock_arg(typeof(self_6_0), 0)
; [eval] typeof(self_6_0)
; [eval] object()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p1_32 ==> self_6 != null
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 205 | p1_0@61@01 | live]
; [else-branch: 205 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 205 | p1_0@61@01]
; [eval] self_6 != null
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> self_6_0 != null
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 206 | p2_0@62@01 | live]
; [else-branch: 206 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 206 | p2_0@62@01]
; [eval] self_6_0 != null
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p1_32 ==> true
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 207 | p1_0@61@01 | live]
; [else-branch: 207 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 207 | p1_0@61@01]
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> true
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 208 | p2_0@62@01 | live]
; [else-branch: 208 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 208 | p2_0@62@01]
(pop) ; 38
(pop) ; 37
; Joined path conditions
(push) ; 37
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
; [then-branch: 209 | p1_0@61@01 | live]
; [else-branch: 209 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 37
; [then-branch: 209 | p1_0@61@01]
; [eval] perm(self_6.MustReleaseBounded) > none && Measure$check(_caller_measures_173, self_6, 1)
; [eval] perm(self_6.MustReleaseBounded) > none
; [eval] perm(self_6.MustReleaseBounded)
; [then-branch: 210 | False | dead]
; [else-branch: 210 | True | live]
(push) ; 38
; [else-branch: 210 | True]
(push) ; 39
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 39
; 0.00s
; (get-info :all-statistics)
; [then-branch: 211 | p2_0@62@01 | live]
; [else-branch: 211 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 39
; [then-branch: 211 | p2_0@62@01]
; [eval] perm(self_6_0.MustReleaseBoundedp) > none && Measure$check(_caller_measures_173_0, self_6_0, 1)
; [eval] perm(self_6_0.MustReleaseBoundedp) > none
; [eval] perm(self_6_0.MustReleaseBoundedp)
; [then-branch: 212 | False | dead]
; [else-branch: 212 | True | live]
(push) ; 40
; [else-branch: 212 | True]
(push) ; 41
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 41
; 0.00s
; (get-info :all-statistics)
; [then-branch: 213 | p1_0@61@01 | live]
; [else-branch: 213 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 41
; [then-branch: 213 | p1_0@61@01]
(push) ; 42
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
; [then-branch: 214 | p2_0@62@01 | live]
; [else-branch: 214 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 42
; [then-branch: 214 | p2_0@62@01]
; [eval] p1_32 && p2_32 ==> Lock_invariant_low(self_6, self_6_0)
; [eval] p1_32 && p2_32
(push) ; 43
; [then-branch: 215 | !(p1_0@61@01) | live]
; [else-branch: 215 | p1_0@61@01 | live]
(push) ; 44
; [then-branch: 215 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 44
(push) ; 44
; [else-branch: 215 | p1_0@61@01]
(pop) ; 44
(pop) ; 43
; Joined path conditions
; Joined path conditions
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 44
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 216 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 216 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 216 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] Lock_invariant_low(self_6, self_6_0)
(push) ; 45
(declare-const $k@145@01 $Perm)
(assert ($Perm.isReadVar $k@145@01))
(push) ; 46
(set-option :timeout 10)
(assert (not (< $Perm.No $k@145@01)))
(check-sat)
; unsat
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
(declare-const $k@146@01 $Perm)
(assert ($Perm.isReadVar $k@146@01))
(set-option :timeout 0)
(push) ; 46
(set-option :timeout 10)
(assert (not (< $Perm.No $k@146@01)))
(check-sat)
; unsat
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
      $Snap.unit))) l@69@01 l_1@70@01))
(pop) ; 45
; Joined path conditions
(assert ($Perm.isReadVar $k@145@01))
(assert ($Perm.isReadVar $k@146@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01)))))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))
      $Snap.unit))) l@69@01 l_1@70@01))
(pop) ; 44
(pop) ; 43
; Joined path conditions
(assert ($Perm.isReadVar $k@145@01))
(assert ($Perm.isReadVar $k@146@01))
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] p1_32 && p2_32 ==> self_6 == self_6_0
; [eval] p1_32 && p2_32
(set-option :timeout 0)
(push) ; 43
; [then-branch: 217 | !(p1_0@61@01) | live]
; [else-branch: 217 | p1_0@61@01 | live]
(push) ; 44
; [then-branch: 217 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 44
(push) ; 44
; [else-branch: 217 | p1_0@61@01]
(pop) ; 44
(pop) ; 43
; Joined path conditions
; Joined path conditions
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 44
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 218 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 218 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 218 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] self_6 == self_6_0
(pop) ; 44
(pop) ; 43
; Joined path conditions
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] p1_32 == p2_32
; [eval] p1_32 ==> typeof(self_6) == typeof(self_6_0)
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 219 | p1_0@61@01 | live]
; [else-branch: 219 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 219 | p1_0@61@01]
; [eval] typeof(self_6) == typeof(self_6_0)
; [eval] typeof(self_6)
; [eval] typeof(self_6_0)
(pop) ; 44
(pop) ; 43
; Joined path conditions
; [eval] p1_32 ==> Measure$check(_caller_measures_173, _cthread_173, 1) || perm(MustTerminate(_cthread_173)) == none && ((forperm _r_59: Ref [MustInvokeBounded(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBounded] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnbounded] :: false))))
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 220 | p1_0@61@01 | live]
; [else-branch: 220 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 220 | p1_0@61@01]
; [eval] Measure$check(_caller_measures_173, _cthread_173, 1) || perm(MustTerminate(_cthread_173)) == none && ((forperm _r_59: Ref [MustInvokeBounded(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBounded] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_173, _cthread_173, 1)
(push) ; 45
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 45
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(push) ; 45
; [then-branch: 221 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1) | live]
; [else-branch: 221 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)) | live]
(push) ; 46
; [then-branch: 221 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 46
(push) ; 46
; [else-branch: 221 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1))]
(assert (not (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
; [eval] perm(MustTerminate(_cthread_173)) == none && ((forperm _r_59: Ref [MustInvokeBounded(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBounded] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_173)) == none
; [eval] perm(MustTerminate(_cthread_173))
(pop) ; 46
(pop) ; 45
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
  (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
(pop) ; 44
(pop) ; 43
; Joined path conditions
; [eval] p2_32 ==> Measure$check(_caller_measures_173_0, _cthread_173_0, 1) || perm(MustTerminate_0(_cthread_173_0)) == none && ((forperm _r_59: Ref [MustInvokeBounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBoundedp] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnboundedp] :: false))))
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 222 | p2_0@62@01 | live]
; [else-branch: 222 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 222 | p2_0@62@01]
; [eval] Measure$check(_caller_measures_173_0, _cthread_173_0, 1) || perm(MustTerminate_0(_cthread_173_0)) == none && ((forperm _r_59: Ref [MustInvokeBounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBoundedp] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_173_0, _cthread_173_0, 1)
(push) ; 45
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 45
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(push) ; 45
; [then-branch: 223 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1) | live]
; [else-branch: 223 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)) | live]
(push) ; 46
; [then-branch: 223 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 46
(push) ; 46
; [else-branch: 223 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1))]
(assert (not
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
; [eval] perm(MustTerminate_0(_cthread_173_0)) == none && ((forperm _r_59: Ref [MustInvokeBounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBoundedp] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_173_0)) == none
; [eval] perm(MustTerminate_0(_cthread_173_0))
(pop) ; 46
(pop) ; 45
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
(pop) ; 44
(pop) ; 43
; Joined path conditions
(declare-const _current_wait_level_173@147@01 $Perm)
(declare-const _current_wait_level_173_0@148@01 $Perm)
(declare-const $t@149@01 $Snap)
(assert (= $t@149@01 ($Snap.combine ($Snap.first $t@149@01) ($Snap.second $t@149@01))))
(assert (= ($Snap.first $t@149@01) $Snap.unit))
; [eval] p1_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173) && ((forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173) && _residue_173 <= _current_wait_level_173)
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 224 | p1_0@61@01 | live]
; [else-branch: 224 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 224 | p1_0@61@01]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173) && ((forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173) && _residue_173 <= _current_wait_level_173)
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173)
(push) ; 45
; [then-branch: 225 | False | live]
; [else-branch: 225 | True | live]
(push) ; 46
; [then-branch: 225 | False]
(assert false)
(pop) ; 46
(push) ; 46
; [else-branch: 225 | True]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173)
(push) ; 47
; [then-branch: 226 | False | live]
; [else-branch: 226 | True | live]
(push) ; 48
; [then-branch: 226 | False]
(assert false)
(pop) ; 48
(push) ; 48
; [else-branch: 226 | True]
; [eval] _residue_173 <= _current_wait_level_173
(pop) ; 48
(pop) ; 47
; Joined path conditions
; Joined path conditions
(pop) ; 46
(pop) ; 45
; Joined path conditions
; Joined path conditions
(pop) ; 44
(pop) ; 43
; Joined path conditions
(assert (=> p1_0@61@01 (<= _residue_161@67@01 _current_wait_level_173@147@01)))
(assert (= ($Snap.second $t@149@01) $Snap.unit))
; [eval] p2_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0) && ((forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0) && _residue_173_0 <= _current_wait_level_173_0)
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 227 | p2_0@62@01 | live]
; [else-branch: 227 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 227 | p2_0@62@01]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0) && ((forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0) && _residue_173_0 <= _current_wait_level_173_0)
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0)
(push) ; 45
; [then-branch: 228 | False | live]
; [else-branch: 228 | True | live]
(push) ; 46
; [then-branch: 228 | False]
(assert false)
(pop) ; 46
(push) ; 46
; [else-branch: 228 | True]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0)
(push) ; 47
; [then-branch: 229 | False | live]
; [else-branch: 229 | True | live]
(push) ; 48
; [then-branch: 229 | False]
(assert false)
(pop) ; 48
(push) ; 48
; [else-branch: 229 | True]
; [eval] _residue_173_0 <= _current_wait_level_173_0
(pop) ; 48
(pop) ; 47
; Joined path conditions
; Joined path conditions
(pop) ; 46
(pop) ; 45
; Joined path conditions
; Joined path conditions
(pop) ; 44
(pop) ; 43
; Joined path conditions
(assert (=> p2_0@62@01 (<= _residue_161_0@68@01 _current_wait_level_173_0@148@01)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 43
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 230 | p1_0@61@01 | live]
; [else-branch: 230 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 230 | p1_0@61@01]
; [exec]
; _cwl_161 := tmp1_18
(push) ; 44
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 231 | p2_0@62@01 | live]
; [else-branch: 231 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 231 | p2_0@62@01]
; [exec]
; _cwl_161_0 := tmp2_18
; [exec]
; assert true
; [eval] p1_0 ==> true
(push) ; 45
(push) ; 46
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 232 | p1_0@61@01 | live]
; [else-branch: 232 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 232 | p1_0@61@01]
(pop) ; 46
(pop) ; 45
; Joined path conditions
; [eval] p2_0 ==> true
(push) ; 45
(push) ; 46
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 233 | p2_0@62@01 | live]
; [else-branch: 233 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 233 | p2_0@62@01]
(pop) ; 46
(pop) ; 45
; Joined path conditions
; [eval] p1_0 ==> (forperm _r_4: Ref [MustInvokeBounded(_r_4)] :: false) && ((forperm _r_4: Ref [MustInvokeUnbounded(_r_4)] :: false) && ((forperm _r_4: Ref [_r_4.MustReleaseBounded] :: false) && (forperm _r_4: Ref [_r_4.MustReleaseUnbounded] :: false)))
(push) ; 45
(push) ; 46
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 234 | p1_0@61@01 | live]
; [else-branch: 234 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 234 | p1_0@61@01]
; [eval] (forperm _r_4: Ref [MustInvokeBounded(_r_4)] :: false) && ((forperm _r_4: Ref [MustInvokeUnbounded(_r_4)] :: false) && ((forperm _r_4: Ref [_r_4.MustReleaseBounded] :: false) && (forperm _r_4: Ref [_r_4.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_4: Ref [MustInvokeBounded(_r_4)] :: false)
(push) ; 47
; [then-branch: 235 | False | live]
; [else-branch: 235 | True | live]
(push) ; 48
; [then-branch: 235 | False]
(assert false)
(pop) ; 48
(push) ; 48
; [else-branch: 235 | True]
; [eval] (forperm _r_4: Ref [MustInvokeUnbounded(_r_4)] :: false)
(push) ; 49
; [then-branch: 236 | False | live]
; [else-branch: 236 | True | live]
(push) ; 50
; [then-branch: 236 | False]
(assert false)
(pop) ; 50
(push) ; 50
; [else-branch: 236 | True]
; [eval] (forperm _r_4: Ref [_r_4.MustReleaseBounded] :: false)
(push) ; 51
; [then-branch: 237 | False | live]
; [else-branch: 237 | True | live]
(push) ; 52
; [then-branch: 237 | False]
(assert false)
(pop) ; 52
(push) ; 52
; [else-branch: 237 | True]
; [eval] (forperm _r_4: Ref [_r_4.MustReleaseUnbounded] :: false)
(pop) ; 52
(pop) ; 51
; Joined path conditions
; Joined path conditions
(pop) ; 50
(pop) ; 49
; Joined path conditions
; Joined path conditions
(pop) ; 48
(pop) ; 47
; Joined path conditions
; Joined path conditions
(pop) ; 46
(pop) ; 45
; Joined path conditions
; [eval] p2_0 ==> (forperm _r_4: Ref [MustInvokeBounded_0(_r_4)] :: false) && ((forperm _r_4: Ref [MustInvokeUnbounded_0(_r_4)] :: false) && ((forperm _r_4: Ref [_r_4.MustReleaseBoundedp] :: false) && (forperm _r_4: Ref [_r_4.MustReleaseUnboundedp] :: false)))
(push) ; 45
(push) ; 46
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 238 | p2_0@62@01 | live]
; [else-branch: 238 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 238 | p2_0@62@01]
; [eval] (forperm _r_4: Ref [MustInvokeBounded_0(_r_4)] :: false) && ((forperm _r_4: Ref [MustInvokeUnbounded_0(_r_4)] :: false) && ((forperm _r_4: Ref [_r_4.MustReleaseBoundedp] :: false) && (forperm _r_4: Ref [_r_4.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_4: Ref [MustInvokeBounded_0(_r_4)] :: false)
(push) ; 47
; [then-branch: 239 | False | live]
; [else-branch: 239 | True | live]
(push) ; 48
; [then-branch: 239 | False]
(assert false)
(pop) ; 48
(push) ; 48
; [else-branch: 239 | True]
; [eval] (forperm _r_4: Ref [MustInvokeUnbounded_0(_r_4)] :: false)
(push) ; 49
; [then-branch: 240 | False | live]
; [else-branch: 240 | True | live]
(push) ; 50
; [then-branch: 240 | False]
(assert false)
(pop) ; 50
(push) ; 50
; [else-branch: 240 | True]
; [eval] (forperm _r_4: Ref [_r_4.MustReleaseBoundedp] :: false)
(push) ; 51
; [then-branch: 241 | False | live]
; [else-branch: 241 | True | live]
(push) ; 52
; [then-branch: 241 | False]
(assert false)
(pop) ; 52
(push) ; 52
; [else-branch: 241 | True]
; [eval] (forperm _r_4: Ref [_r_4.MustReleaseUnboundedp] :: false)
(pop) ; 52
(pop) ; 51
; Joined path conditions
; Joined path conditions
(pop) ; 50
(pop) ; 49
; Joined path conditions
; Joined path conditions
(pop) ; 48
(pop) ; 47
; Joined path conditions
; Joined path conditions
(pop) ; 46
(pop) ; 45
; Joined path conditions
(pop) ; 44
; [eval] !p2_0
; [then-branch: 242 | !(p2_0@62@01) | dead]
; [else-branch: 242 | p2_0@62@01 | live]
(push) ; 44
; [else-branch: 242 | p2_0@62@01]
(pop) ; 44
(pop) ; 43
; [eval] !p1_0
; [then-branch: 243 | !(p1_0@61@01) | dead]
; [else-branch: 243 | p1_0@61@01 | live]
(push) ; 43
; [else-branch: 243 | p1_0@61@01]
(pop) ; 43
(pop) ; 42
(pop) ; 41
(pop) ; 40
(pop) ; 39
(pop) ; 38
(pop) ; 37
(pop) ; 36
; [eval] !p2_0
(push) ; 36
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 244 | !(p2_0@62@01) | dead]
; [else-branch: 244 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 36
; [else-branch: 244 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 36
(pop) ; 35
; [eval] !p1_0
(push) ; 35
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 245 | !(p1_0@61@01) | dead]
; [else-branch: 245 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 35
; [else-branch: 245 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 35
(pop) ; 34
; [eval] !(p1_0 || p2_0)
; [eval] p1_0 || p2_0
(push) ; 34
; [then-branch: 246 | p1_0@61@01 | live]
; [else-branch: 246 | !(p1_0@61@01) | live]
(push) ; 35
; [then-branch: 246 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 35
(push) ; 35
; [else-branch: 246 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
; [then-branch: 247 | !(p1_0@61@01 || p2_0@62@01) | dead]
; [else-branch: 247 | p1_0@61@01 || p2_0@62@01 | live]
(push) ; 34
; [else-branch: 247 | p1_0@61@01 || p2_0@62@01]
(pop) ; 34
(pop) ; 33
(pop) ; 32
; [eval] !p2_0
(push) ; 32
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 248 | !(p2_0@62@01) | dead]
; [else-branch: 248 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 32
; [else-branch: 248 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 32
(pop) ; 31
(pop) ; 30
; [eval] !p1_0
(push) ; 30
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
; [then-branch: 249 | !(p1_0@61@01) | dead]
; [else-branch: 249 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 30
; [else-branch: 249 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 30
(pop) ; 29
; [eval] !p2_0
(push) ; 29
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 250 | !(p2_0@62@01) | dead]
; [else-branch: 250 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 29
; [else-branch: 250 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 29
(pop) ; 28
; [eval] !p1_0
(push) ; 28
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 251 | !(p1_0@61@01) | dead]
; [else-branch: 251 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 28
; [else-branch: 251 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 28
(pop) ; 27
; [eval] !p2_0
(push) ; 27
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 252 | !(p2_0@62@01) | dead]
; [else-branch: 252 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 27
; [else-branch: 252 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 27
(pop) ; 26
; [eval] !p1_0
(push) ; 26
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 253 | !(p1_0@61@01) | dead]
; [else-branch: 253 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 26
; [else-branch: 253 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 26
(pop) ; 25
; [eval] !(p1_0 || p2_0)
; [eval] p1_0 || p2_0
(push) ; 25
; [then-branch: 254 | p1_0@61@01 | live]
; [else-branch: 254 | !(p1_0@61@01) | live]
(push) ; 26
; [then-branch: 254 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 26
(push) ; 26
; [else-branch: 254 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
; [then-branch: 255 | !(p1_0@61@01 || p2_0@62@01) | dead]
; [else-branch: 255 | p1_0@61@01 || p2_0@62@01 | live]
(push) ; 25
; [else-branch: 255 | p1_0@61@01 || p2_0@62@01]
(pop) ; 25
(pop) ; 24
; [eval] !p2_0
(push) ; 24
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 256 | !(p2_0@62@01) | dead]
; [else-branch: 256 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 24
; [else-branch: 256 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 24
(pop) ; 23
; [eval] !p1_0
(push) ; 23
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 257 | !(p1_0@61@01) | dead]
; [else-branch: 257 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 23
; [else-branch: 257 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 23
(pop) ; 22
; [eval] !p2_0
(push) ; 22
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 258 | !(p2_0@62@01) | dead]
; [else-branch: 258 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 22
; [else-branch: 258 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 22
(pop) ; 21
; [eval] !p1_0
(push) ; 21
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 259 | !(p1_0@61@01) | dead]
; [else-branch: 259 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 21
; [else-branch: 259 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 21
(pop) ; 20
; [eval] !(p1_0 || p2_0)
; [eval] p1_0 || p2_0
(push) ; 20
; [then-branch: 260 | p1_0@61@01 | live]
; [else-branch: 260 | !(p1_0@61@01) | live]
(push) ; 21
; [then-branch: 260 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 21
(push) ; 21
; [else-branch: 260 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
; [then-branch: 261 | !(p1_0@61@01 || p2_0@62@01) | dead]
; [else-branch: 261 | p1_0@61@01 || p2_0@62@01 | live]
(push) ; 20
; [else-branch: 261 | p1_0@61@01 || p2_0@62@01]
(pop) ; 20
(pop) ; 19
(pop) ; 18
; [eval] !p2_0
(push) ; 18
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 262 | !(p2_0@62@01) | dead]
; [else-branch: 262 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 18
; [else-branch: 262 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 18
(pop) ; 17
(push) ; 17
; [else-branch: 124 | !(issubtype[Bool](typeof[PyType](l@69@01), CellLock[PyType]))]
(assert (not (issubtype<Bool> (typeof<PyType> l@69@01) (as CellLock<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.first ($Snap.second ($Snap.second $t@102@01))))
  $Snap.unit))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (Lock_invariant%trigger ($Snap.first ($Snap.second ($Snap.second $t@102@01))) l@69@01))
(set-option :timeout 0)
(push) ; 18
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 18
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 263 | p2_0@62@01 | live]
; [else-branch: 263 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 263 | p2_0@62@01]
(assert p2_0@62@01)
; [exec]
; unfold acc(Lock_invariant_0(l_0_0), write)
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))
  ($Snap.combine
    ($Snap.first ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))
    ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01))))))))
(assert (=
  ($Snap.first ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))
  $Snap.unit))
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
(assert (issubtype<Bool> (typeof<PyType> l_1@70@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> l_1@70@01) 0))))
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
(push) ; 19
(set-option :timeout 10)
(assert (not (not (issubtype<Bool> (typeof<PyType> l_1@70@01) (as CellLock<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 264 | issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType]) | dead]
; [else-branch: 264 | !(issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType])) | live]
(set-option :timeout 0)
(push) ; 19
; [else-branch: 264 | !(issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType]))]
(assert (not (issubtype<Bool> (typeof<PyType> l_1@70@01) (as CellLock<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01)))))
  $Snap.unit))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (Lock_invariant_0%trigger ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@102@01)))) l_1@70@01))
; [eval] p1_0 || p2_0
(set-option :timeout 0)
(push) ; 20
; [then-branch: 265 | p1_0@61@01 | live]
; [else-branch: 265 | !(p1_0@61@01) | live]
(push) ; 21
; [then-branch: 265 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 21
(push) ; 21
; [else-branch: 265 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
(set-option :timeout 10)
(assert (not (not (or p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 266 | p1_0@61@01 || p2_0@62@01 | live]
; [else-branch: 266 | !(p1_0@61@01 || p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 266 | p1_0@61@01 || p2_0@62@01]
; [exec]
; var tmp1_4: Ref
(declare-const tmp1_4@150@01 $Ref)
; [exec]
; var tmp2_4: Ref
(declare-const tmp2_4@151@01 $Ref)
; [exec]
; var tmp1_5: Seq[Measure$]
(declare-const tmp1_5@152@01 Seq<Measure$>)
; [exec]
; var tmp2_5: Seq[Measure$]
(declare-const tmp2_5@153@01 Seq<Measure$>)
; [exec]
; var tmp1_6: Perm
(declare-const tmp1_6@154@01 $Perm)
; [exec]
; var tmp2_6: Perm
(declare-const tmp2_6@155@01 $Perm)
; [exec]
; var tmp1_7: Ref
(declare-const tmp1_7@156@01 $Ref)
; [exec]
; var tmp2_7: Ref
(declare-const tmp2_7@157@01 $Ref)
; [exec]
; var tmp1_8: Perm
(declare-const tmp1_8@158@01 $Perm)
; [exec]
; var tmp2_8: Perm
(declare-const tmp2_8@159@01 $Perm)
(push) ; 21
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 267 | p1_0@61@01 | live]
; [else-branch: 267 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 267 | p1_0@61@01]
(assert p1_0@61@01)
; [exec]
; tmp1_4 := _cthread_161
; [exec]
; tmp1_5 := _method_measures_161
; [exec]
; tmp1_6 := _residue_161
; [exec]
; tmp1_7 := x_5
(push) ; 22
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 268 | p2_0@62@01 | live]
; [else-branch: 268 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 268 | p2_0@62@01]
; [exec]
; tmp2_4 := _cthread_161_0
; [exec]
; tmp2_5 := _method_measures_161_0
; [exec]
; tmp2_6 := _residue_161_0
; [exec]
; tmp2_7 := x_5_0
; [exec]
; tmp1_8, tmp2_8 := sif_print(p1_0, p2_0, tmp1_4, tmp2_4, tmp1_5, tmp2_5, tmp1_6,
;   tmp2_6, tmp1_7, tmp2_7)
; [eval] p1 ==> _cthread_160 != null
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 269 | p1_0@61@01 | live]
; [else-branch: 269 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 269 | p1_0@61@01]
; [eval] _cthread_160 != null
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2 ==> _cthread_160_0 != null
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 270 | p2_0@62@01 | live]
; [else-branch: 270 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 270 | p2_0@62@01]
; [eval] _cthread_160_0 != null
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(_cthread_160), Thread_0())
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 271 | p1_0@61@01 | live]
; [else-branch: 271 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 271 | p1_0@61@01]
; [eval] issubtype(typeof(_cthread_160), Thread_0())
; [eval] typeof(_cthread_160)
; [eval] Thread_0()
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2 ==> issubtype(typeof(_cthread_160_0), Thread_0())
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 272 | p2_0@62@01 | live]
; [else-branch: 272 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 272 | p2_0@62@01]
; [eval] issubtype(typeof(_cthread_160_0), Thread_0())
; [eval] typeof(_cthread_160_0)
; [eval] Thread_0()
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(x_0), int())
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 273 | p1_0@61@01 | live]
; [else-branch: 273 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 273 | p1_0@61@01]
; [eval] issubtype(typeof(x_0), int())
; [eval] typeof(x_0)
; [eval] int()
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2 ==> issubtype(typeof(x_0_0), int())
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 274 | p2_0@62@01 | live]
; [else-branch: 274 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 274 | p2_0@62@01]
; [eval] issubtype(typeof(x_0_0), int())
; [eval] typeof(x_0_0)
; [eval] int()
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p1 == p2
; [eval] p1 && p2 ==> int___eq__(x_0, x_0_0)
; [eval] p1 && p2
(push) ; 23
; [then-branch: 275 | !(p1_0@61@01) | live]
; [else-branch: 275 | p1_0@61@01 | live]
(push) ; 24
; [then-branch: 275 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 24
(push) ; 24
; [else-branch: 275 | p1_0@61@01]
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 276 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 276 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 276 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] int___eq__(x_0, x_0_0)
(push) ; 25
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 26
(assert (not (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 26
(assert (not (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01))
(pop) ; 25
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (and
    p1_0@61@01
    p2_0@62@01
    (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01))))
(assert (and p1_0@61@01 p2_0@62@01))
(push) ; 23
(assert (not (=>
  (and p1_0@61@01 p2_0@62@01)
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01)))
; [eval] p1 ==> true
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 277 | p1_0@61@01 | live]
; [else-branch: 277 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 277 | p1_0@61@01]
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2 ==> true
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 278 | p2_0@62@01 | live]
; [else-branch: 278 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 278 | p2_0@62@01]
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p1 ==> Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 279 | p1_0@61@01 | live]
; [else-branch: 279 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 279 | p1_0@61@01]
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1)
(push) ; 25
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 25
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(push) ; 25
; [then-branch: 280 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1) | live]
; [else-branch: 280 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)) | live]
(push) ; 26
; [then-branch: 280 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 26
(push) ; 26
; [else-branch: 280 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1))]
(assert (not (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
; [eval] perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_160)) == none
; [eval] perm(MustTerminate(_cthread_160))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
  (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2 ==> Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 281 | p2_0@62@01 | live]
; [else-branch: 281 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 281 | p2_0@62@01]
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1)
(push) ; 25
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 25
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(push) ; 25
; [then-branch: 282 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1) | live]
; [else-branch: 282 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)) | live]
(push) ; 26
; [then-branch: 282 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 26
(push) ; 26
; [else-branch: 282 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1))]
(assert (not
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none
; [eval] perm(MustTerminate_0(_cthread_160_0))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(declare-const _current_wait_level_160@160@01 $Perm)
(declare-const _current_wait_level_160_0@161@01 $Perm)
(declare-const $t@162@01 $Snap)
(assert (= $t@162@01 ($Snap.combine ($Snap.first $t@162@01) ($Snap.second $t@162@01))))
(assert (= ($Snap.first $t@162@01) $Snap.unit))
; [eval] p1 ==> (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 283 | p1_0@61@01 | live]
; [else-branch: 283 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 283 | p1_0@61@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 25
; [then-branch: 284 | False | live]
; [else-branch: 284 | True | live]
(push) ; 26
; [then-branch: 284 | False]
(assert false)
(pop) ; 26
(push) ; 26
; [else-branch: 284 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 27
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 285 | True | live]
; [else-branch: 285 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 285 | True]
; [eval] Level(_r) <= _current_wait_level_160
; [eval] Level(_r)
(push) ; 29
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 29
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 28
(pop) ; 27
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(push) ; 27
; [then-branch: 286 | !(Level(_, l@69@01) <= _current_wait_level_160@160@01) | live]
; [else-branch: 286 | Level(_, l@69@01) <= _current_wait_level_160@160@01 | live]
(push) ; 28
; [then-branch: 286 | !(Level(_, l@69@01) <= _current_wait_level_160@160@01)]
(assert (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@160@01)))
(pop) ; 28
(push) ; 28
; [else-branch: 286 | Level(_, l@69@01) <= _current_wait_level_160@160@01]
(assert (<= (Level $Snap.unit l@69@01) _current_wait_level_160@160@01))
; [eval] _residue_160 <= _current_wait_level_160
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(assert (or
  (<= (Level $Snap.unit l@69@01) _current_wait_level_160@160@01)
  (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@160@01))))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(assert (and
  (Level%precondition $Snap.unit l@69@01)
  (or
    (<= (Level $Snap.unit l@69@01) _current_wait_level_160@160@01)
    (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@160@01)))))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (=>
  p1_0@61@01
  (and
    (Level%precondition $Snap.unit l@69@01)
    (or
      (<= (Level $Snap.unit l@69@01) _current_wait_level_160@160@01)
      (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@160@01))))))
(assert (=>
  p1_0@61@01
  (and
    (<= (Level $Snap.unit l@69@01) _current_wait_level_160@160@01)
    (<= _residue_161@67@01 _current_wait_level_160@160@01))))
(assert (=
  ($Snap.second $t@162@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@162@01))
    ($Snap.second ($Snap.second $t@162@01)))))
(assert (= ($Snap.first ($Snap.second $t@162@01)) $Snap.unit))
; [eval] p2 ==> (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 287 | p2_0@62@01 | live]
; [else-branch: 287 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 287 | p2_0@62@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 25
; [then-branch: 288 | False | live]
; [else-branch: 288 | True | live]
(push) ; 26
; [then-branch: 288 | False]
(assert false)
(pop) ; 26
(push) ; 26
; [else-branch: 288 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 27
(push) ; 28
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 289 | True | live]
; [else-branch: 289 | False | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 289 | True]
; [eval] Level(_r) <= _current_wait_level_160_0
; [eval] Level(_r)
(push) ; 29
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 29
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 28
(pop) ; 27
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(push) ; 27
; [then-branch: 290 | !(Level(_, l_1@70@01) <= _current_wait_level_160_0@161@01) | live]
; [else-branch: 290 | Level(_, l_1@70@01) <= _current_wait_level_160_0@161@01 | live]
(push) ; 28
; [then-branch: 290 | !(Level(_, l_1@70@01) <= _current_wait_level_160_0@161@01)]
(assert (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@161@01)))
(pop) ; 28
(push) ; 28
; [else-branch: 290 | Level(_, l_1@70@01) <= _current_wait_level_160_0@161@01]
(assert (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@161@01))
; [eval] _residue_160_0 <= _current_wait_level_160_0
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(assert (or
  (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@161@01)
  (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@161@01))))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(assert (and
  (Level%precondition $Snap.unit l_1@70@01)
  (or
    (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@161@01)
    (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@161@01)))))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (=>
  p2_0@62@01
  (and
    (Level%precondition $Snap.unit l_1@70@01)
    (or
      (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@161@01)
      (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@161@01))))))
(assert (=>
  p2_0@62@01
  (and
    (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@161@01)
    (<= _residue_161_0@68@01 _current_wait_level_160_0@161@01))))
(assert (=
  ($Snap.second ($Snap.second $t@162@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@162@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@162@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@162@01))) $Snap.unit))
; [eval] p1 ==> true
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 291 | p1_0@61@01 | live]
; [else-branch: 291 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 291 | p1_0@61@01]
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@162@01))) $Snap.unit))
; [eval] p2 ==> true
(push) ; 23
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 292 | p2_0@62@01 | live]
; [else-branch: 292 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 292 | p2_0@62@01]
(pop) ; 24
(pop) ; 23
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 293 | p1_0@61@01 | live]
; [else-branch: 293 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 293 | p1_0@61@01]
; [exec]
; _cwl_161 := tmp1_8
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 294 | p2_0@62@01 | live]
; [else-branch: 294 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 294 | p2_0@62@01]
; [exec]
; _cwl_161_0 := tmp2_8
; [eval] p1_0 || p2_0
(push) ; 25
; [then-branch: 295 | p1_0@61@01 | live]
; [else-branch: 295 | !(p1_0@61@01) | live]
(push) ; 26
; [then-branch: 295 | p1_0@61@01]
(pop) ; 26
(push) ; 26
; [else-branch: 295 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(push) ; 25
(set-option :timeout 10)
(assert (not (not (or p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 296 | p1_0@61@01 || p2_0@62@01 | live]
; [else-branch: 296 | !(p1_0@61@01 || p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 296 | p1_0@61@01 || p2_0@62@01]
; [exec]
; var tmp1_9: Ref
(declare-const tmp1_9@163@01 $Ref)
; [exec]
; var tmp2_9: Ref
(declare-const tmp2_9@164@01 $Ref)
; [exec]
; var tmp1_10: Seq[Measure$]
(declare-const tmp1_10@165@01 Seq<Measure$>)
; [exec]
; var tmp2_10: Seq[Measure$]
(declare-const tmp2_10@166@01 Seq<Measure$>)
; [exec]
; var tmp1_11: Perm
(declare-const tmp1_11@167@01 $Perm)
; [exec]
; var tmp2_11: Perm
(declare-const tmp2_11@168@01 $Perm)
; [exec]
; var tmp1_12: Ref
(declare-const tmp1_12@169@01 $Ref)
; [exec]
; var tmp2_12: Ref
(declare-const tmp2_12@170@01 $Ref)
; [exec]
; var tmp1_13: Perm
(declare-const tmp1_13@171@01 $Perm)
; [exec]
; var tmp2_13: Perm
(declare-const tmp2_13@172@01 $Perm)
(push) ; 26
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 297 | p1_0@61@01 | live]
; [else-branch: 297 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 297 | p1_0@61@01]
; [exec]
; tmp1_9 := _cthread_161
; [exec]
; tmp1_10 := _method_measures_161
; [exec]
; tmp1_11 := _residue_161
; [exec]
; tmp1_12 := x_5
(push) ; 27
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 298 | p2_0@62@01 | live]
; [else-branch: 298 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 298 | p2_0@62@01]
; [exec]
; tmp2_9 := _cthread_161_0
; [exec]
; tmp2_10 := _method_measures_161_0
; [exec]
; tmp2_11 := _residue_161_0
; [exec]
; tmp2_12 := x_5_0
; [exec]
; tmp1_13, tmp2_13 := sif_print(p1_0, p2_0, tmp1_9, tmp2_9, tmp1_10, tmp2_10,
;   tmp1_11, tmp2_11, tmp1_12, tmp2_12)
; [eval] p1 ==> _cthread_160 != null
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 299 | p1_0@61@01 | live]
; [else-branch: 299 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 299 | p1_0@61@01]
; [eval] _cthread_160 != null
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p2 ==> _cthread_160_0 != null
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 300 | p2_0@62@01 | live]
; [else-branch: 300 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 300 | p2_0@62@01]
; [eval] _cthread_160_0 != null
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(_cthread_160), Thread_0())
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 301 | p1_0@61@01 | live]
; [else-branch: 301 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 301 | p1_0@61@01]
; [eval] issubtype(typeof(_cthread_160), Thread_0())
; [eval] typeof(_cthread_160)
; [eval] Thread_0()
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p2 ==> issubtype(typeof(_cthread_160_0), Thread_0())
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 302 | p2_0@62@01 | live]
; [else-branch: 302 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 302 | p2_0@62@01]
; [eval] issubtype(typeof(_cthread_160_0), Thread_0())
; [eval] typeof(_cthread_160_0)
; [eval] Thread_0()
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(x_0), int())
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 303 | p1_0@61@01 | live]
; [else-branch: 303 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 303 | p1_0@61@01]
; [eval] issubtype(typeof(x_0), int())
; [eval] typeof(x_0)
; [eval] int()
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p2 ==> issubtype(typeof(x_0_0), int())
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 304 | p2_0@62@01 | live]
; [else-branch: 304 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 304 | p2_0@62@01]
; [eval] issubtype(typeof(x_0_0), int())
; [eval] typeof(x_0_0)
; [eval] int()
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p1 == p2
; [eval] p1 && p2 ==> int___eq__(x_0, x_0_0)
; [eval] p1 && p2
(push) ; 28
; [then-branch: 305 | !(p1_0@61@01) | live]
; [else-branch: 305 | p1_0@61@01 | live]
(push) ; 29
; [then-branch: 305 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 29
(push) ; 29
; [else-branch: 305 | p1_0@61@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
; Joined path conditions
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 29
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 306 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 306 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 306 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] int___eq__(x_0, x_0_0)
(push) ; 30
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 31
(assert (not (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 31
(assert (not (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01))
(pop) ; 30
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> x_1@71@01) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> x_1_0@72@01) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) x_1@71@01 x_1_0@72@01)))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] p1 ==> true
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 307 | p1_0@61@01 | live]
; [else-branch: 307 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 307 | p1_0@61@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p2 ==> true
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 308 | p2_0@62@01 | live]
; [else-branch: 308 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 308 | p2_0@62@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p1 ==> Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 309 | p1_0@61@01 | live]
; [else-branch: 309 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 309 | p1_0@61@01]
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1)
(push) ; 30
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 30
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(push) ; 30
; [then-branch: 310 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1) | live]
; [else-branch: 310 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)) | live]
(push) ; 31
; [then-branch: 310 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 31
(push) ; 31
; [else-branch: 310 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1))]
(assert (not (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
; [eval] perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_160)) == none
; [eval] perm(MustTerminate(_cthread_160))
(pop) ; 31
(pop) ; 30
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
  (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
(pop) ; 29
(pop) ; 28
; Joined path conditions
; [eval] p2 ==> Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 311 | p2_0@62@01 | live]
; [else-branch: 311 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 311 | p2_0@62@01]
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1)
(push) ; 30
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 30
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(push) ; 30
; [then-branch: 312 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1) | live]
; [else-branch: 312 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)) | live]
(push) ; 31
; [then-branch: 312 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 31
(push) ; 31
; [else-branch: 312 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1))]
(assert (not
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none
; [eval] perm(MustTerminate_0(_cthread_160_0))
(pop) ; 31
(pop) ; 30
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(declare-const _current_wait_level_160@173@01 $Perm)
(declare-const _current_wait_level_160_0@174@01 $Perm)
(declare-const $t@175@01 $Snap)
(assert (= $t@175@01 ($Snap.combine ($Snap.first $t@175@01) ($Snap.second $t@175@01))))
(assert (= ($Snap.first $t@175@01) $Snap.unit))
; [eval] p1 ==> (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 313 | p1_0@61@01 | live]
; [else-branch: 313 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 313 | p1_0@61@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 30
; [then-branch: 314 | False | live]
; [else-branch: 314 | True | live]
(push) ; 31
; [then-branch: 314 | False]
(assert false)
(pop) ; 31
(push) ; 31
; [else-branch: 314 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 32
(push) ; 33
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
; [then-branch: 315 | True | live]
; [else-branch: 315 | False | dead]
(set-option :timeout 0)
(push) ; 33
; [then-branch: 315 | True]
; [eval] Level(_r) <= _current_wait_level_160
; [eval] Level(_r)
(push) ; 34
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 34
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(pop) ; 33
(pop) ; 32
; Joined path conditions
(assert (Level%precondition $Snap.unit l@69@01))
(push) ; 32
; [then-branch: 316 | !(Level(_, l@69@01) <= _current_wait_level_160@173@01) | live]
; [else-branch: 316 | Level(_, l@69@01) <= _current_wait_level_160@173@01 | live]
(push) ; 33
; [then-branch: 316 | !(Level(_, l@69@01) <= _current_wait_level_160@173@01)]
(assert (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@173@01)))
(pop) ; 33
(push) ; 33
; [else-branch: 316 | Level(_, l@69@01) <= _current_wait_level_160@173@01]
(assert (<= (Level $Snap.unit l@69@01) _current_wait_level_160@173@01))
; [eval] _residue_160 <= _current_wait_level_160
(pop) ; 33
(pop) ; 32
; Joined path conditions
; Joined path conditions
(assert (or
  (<= (Level $Snap.unit l@69@01) _current_wait_level_160@173@01)
  (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@173@01))))
(pop) ; 31
(pop) ; 30
; Joined path conditions
; Joined path conditions
(assert (and
  (Level%precondition $Snap.unit l@69@01)
  (or
    (<= (Level $Snap.unit l@69@01) _current_wait_level_160@173@01)
    (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@173@01)))))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert (=>
  p1_0@61@01
  (and
    (Level%precondition $Snap.unit l@69@01)
    (or
      (<= (Level $Snap.unit l@69@01) _current_wait_level_160@173@01)
      (not (<= (Level $Snap.unit l@69@01) _current_wait_level_160@173@01))))))
(assert (=>
  p1_0@61@01
  (and
    (<= (Level $Snap.unit l@69@01) _current_wait_level_160@173@01)
    (<= _residue_161@67@01 _current_wait_level_160@173@01))))
(assert (=
  ($Snap.second $t@175@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@175@01))
    ($Snap.second ($Snap.second $t@175@01)))))
(assert (= ($Snap.first ($Snap.second $t@175@01)) $Snap.unit))
; [eval] p2 ==> (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 317 | p2_0@62@01 | live]
; [else-branch: 317 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 317 | p2_0@62@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 30
; [then-branch: 318 | False | live]
; [else-branch: 318 | True | live]
(push) ; 31
; [then-branch: 318 | False]
(assert false)
(pop) ; 31
(push) ; 31
; [else-branch: 318 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 32
(push) ; 33
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
; [then-branch: 319 | True | live]
; [else-branch: 319 | False | dead]
(set-option :timeout 0)
(push) ; 33
; [then-branch: 319 | True]
; [eval] Level(_r) <= _current_wait_level_160_0
; [eval] Level(_r)
(push) ; 34
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 34
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(pop) ; 33
(pop) ; 32
; Joined path conditions
(assert (Level%precondition $Snap.unit l_1@70@01))
(push) ; 32
; [then-branch: 320 | !(Level(_, l_1@70@01) <= _current_wait_level_160_0@174@01) | live]
; [else-branch: 320 | Level(_, l_1@70@01) <= _current_wait_level_160_0@174@01 | live]
(push) ; 33
; [then-branch: 320 | !(Level(_, l_1@70@01) <= _current_wait_level_160_0@174@01)]
(assert (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@174@01)))
(pop) ; 33
(push) ; 33
; [else-branch: 320 | Level(_, l_1@70@01) <= _current_wait_level_160_0@174@01]
(assert (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@174@01))
; [eval] _residue_160_0 <= _current_wait_level_160_0
(pop) ; 33
(pop) ; 32
; Joined path conditions
; Joined path conditions
(assert (or
  (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@174@01)
  (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@174@01))))
(pop) ; 31
(pop) ; 30
; Joined path conditions
; Joined path conditions
(assert (and
  (Level%precondition $Snap.unit l_1@70@01)
  (or
    (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@174@01)
    (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@174@01)))))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert (=>
  p2_0@62@01
  (and
    (Level%precondition $Snap.unit l_1@70@01)
    (or
      (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@174@01)
      (not (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@174@01))))))
(assert (=>
  p2_0@62@01
  (and
    (<= (Level $Snap.unit l_1@70@01) _current_wait_level_160_0@174@01)
    (<= _residue_161_0@68@01 _current_wait_level_160_0@174@01))))
(assert (=
  ($Snap.second ($Snap.second $t@175@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@175@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@175@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@175@01))) $Snap.unit))
; [eval] p1 ==> true
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 321 | p1_0@61@01 | live]
; [else-branch: 321 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 321 | p1_0@61@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@175@01))) $Snap.unit))
; [eval] p2 ==> true
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 322 | p2_0@62@01 | live]
; [else-branch: 322 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 322 | p2_0@62@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 28
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 323 | p1_0@61@01 | live]
; [else-branch: 323 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 323 | p1_0@61@01]
; [exec]
; _cwl_161 := tmp1_13
(push) ; 29
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 324 | p2_0@62@01 | live]
; [else-branch: 324 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 324 | p2_0@62@01]
; [exec]
; _cwl_161_0 := tmp2_13
(push) ; 30
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
; [then-branch: 325 | p1_0@61@01 | live]
; [else-branch: 325 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 30
; [then-branch: 325 | p1_0@61@01]
; [exec]
; fold acc(Lock_invariant(l_0), write)
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
; [then-branch: 326 | issubtype[Bool](typeof[PyType](l@69@01), CellLock[PyType]) | dead]
; [else-branch: 326 | !(issubtype[Bool](typeof[PyType](l@69@01), CellLock[PyType])) | live]
(push) ; 31
; [else-branch: 326 | !(issubtype[Bool](typeof[PyType](l@69@01), CellLock[PyType]))]
(assert (Lock_invariant%trigger ($Snap.combine $Snap.unit $Snap.unit) l@69@01))
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 327 | p2_0@62@01 | live]
; [else-branch: 327 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 327 | p2_0@62@01]
; [exec]
; fold acc(Lock_invariant_0(l_0_0), write)
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
; [then-branch: 328 | issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType]) | dead]
; [else-branch: 328 | !(issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType])) | live]
(push) ; 33
; [else-branch: 328 | !(issubtype[Bool](typeof[PyType](l_1@70@01), CellLock[PyType]))]
(assert (Lock_invariant_0%trigger ($Snap.combine $Snap.unit $Snap.unit) l_1@70@01))
; [exec]
; assert p1_0 && p2_0 ==> Lock_invariant_low(l_0, l_0_0)
; [eval] p1_0 && p2_0 ==> Lock_invariant_low(l_0, l_0_0)
; [eval] p1_0 && p2_0
(push) ; 34
; [then-branch: 329 | !(p1_0@61@01) | live]
; [else-branch: 329 | p1_0@61@01 | live]
(push) ; 35
; [then-branch: 329 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 35
(push) ; 35
; [else-branch: 329 | p1_0@61@01]
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(push) ; 34
(push) ; 35
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 35
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 330 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 330 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 330 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] Lock_invariant_low(l_0, l_0_0)
(push) ; 36
(declare-const $k@176@01 $Perm)
(assert ($Perm.isReadVar $k@176@01))
(push) ; 37
(set-option :timeout 10)
(assert (not (< $Perm.No $k@176@01)))
(check-sat)
; unsat
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
(declare-const $k@177@01 $Perm)
(assert ($Perm.isReadVar $k@177@01))
(set-option :timeout 0)
(push) ; 37
(set-option :timeout 10)
(assert (not (< $Perm.No $k@177@01)))
(check-sat)
; unsat
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine $Snap.unit $Snap.unit)
  ($Snap.combine $Snap.unit $Snap.unit)) l@69@01 l_1@70@01))
(pop) ; 36
; Joined path conditions
(assert ($Perm.isReadVar $k@176@01))
(assert ($Perm.isReadVar $k@177@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine $Snap.unit $Snap.unit)
  ($Snap.combine $Snap.unit $Snap.unit)) l@69@01 l_1@70@01))
(pop) ; 35
(pop) ; 34
; Joined path conditions
(assert ($Perm.isReadVar $k@176@01))
(assert ($Perm.isReadVar $k@177@01))
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (and
    p1_0@61@01
    p2_0@62@01
    (Lock_invariant_low%precondition ($Snap.combine
      ($Snap.combine $Snap.unit $Snap.unit)
      ($Snap.combine $Snap.unit $Snap.unit)) l@69@01 l_1@70@01))))
(assert (and p1_0@61@01 p2_0@62@01))
(set-option :timeout 0)
(push) ; 34
(assert (not (=>
  (and p1_0@61@01 p2_0@62@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.combine $Snap.unit $Snap.unit)
    ($Snap.combine $Snap.unit $Snap.unit)) l@69@01 l_1@70@01))))
(check-sat)
; unsat
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_0@61@01 p2_0@62@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.combine $Snap.unit $Snap.unit)
    ($Snap.combine $Snap.unit $Snap.unit)) l@69@01 l_1@70@01)))
; [eval] p1_0 || p2_0
(push) ; 34
; [then-branch: 331 | p1_0@61@01 | live]
; [else-branch: 331 | !(p1_0@61@01) | live]
(push) ; 35
; [then-branch: 331 | p1_0@61@01]
(pop) ; 35
(push) ; 35
; [else-branch: 331 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(push) ; 34
(set-option :timeout 10)
(assert (not (not (or p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 332 | p1_0@61@01 || p2_0@62@01 | live]
; [else-branch: 332 | !(p1_0@61@01 || p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 332 | p1_0@61@01 || p2_0@62@01]
; [exec]
; var tmp1_14: Ref
(declare-const tmp1_14@178@01 $Ref)
; [exec]
; var tmp2_14: Ref
(declare-const tmp2_14@179@01 $Ref)
; [exec]
; var tmp1_15: Seq[Measure$]
(declare-const tmp1_15@180@01 Seq<Measure$>)
; [exec]
; var tmp2_15: Seq[Measure$]
(declare-const tmp2_15@181@01 Seq<Measure$>)
; [exec]
; var tmp1_16: Perm
(declare-const tmp1_16@182@01 $Perm)
; [exec]
; var tmp2_16: Perm
(declare-const tmp2_16@183@01 $Perm)
; [exec]
; var tmp1_17: Ref
(declare-const tmp1_17@184@01 $Ref)
; [exec]
; var tmp2_17: Ref
(declare-const tmp2_17@185@01 $Ref)
; [exec]
; var tmp1_18: Perm
(declare-const tmp1_18@186@01 $Perm)
; [exec]
; var tmp2_18: Perm
(declare-const tmp2_18@187@01 $Perm)
(push) ; 35
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 333 | p1_0@61@01 | live]
; [else-branch: 333 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 333 | p1_0@61@01]
; [exec]
; tmp1_14 := _cthread_161
; [exec]
; tmp1_15 := _method_measures_161
; [exec]
; tmp1_16 := _residue_161
; [exec]
; tmp1_17 := l_0
(push) ; 36
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 334 | p2_0@62@01 | live]
; [else-branch: 334 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 36
; [then-branch: 334 | p2_0@62@01]
; [exec]
; tmp2_14 := _cthread_161_0
; [exec]
; tmp2_15 := _method_measures_161_0
; [exec]
; tmp2_16 := _residue_161_0
; [exec]
; tmp2_17 := l_0_0
; [exec]
; tmp1_18, tmp2_18 := Lock_release(p1_0, p2_0, tmp1_14, tmp2_14, tmp1_15, tmp2_15,
;   tmp1_16, tmp2_16, tmp1_17, tmp2_17)
; [eval] p1_32 ==> _cthread_173 != null
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 335 | p1_0@61@01 | live]
; [else-branch: 335 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 335 | p1_0@61@01]
; [eval] _cthread_173 != null
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> _cthread_173_0 != null
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 336 | p2_0@62@01 | live]
; [else-branch: 336 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 336 | p2_0@62@01]
; [eval] _cthread_173_0 != null
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p1_32 ==> issubtype(typeof(_cthread_173), Thread_0())
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 337 | p1_0@61@01 | live]
; [else-branch: 337 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 337 | p1_0@61@01]
; [eval] issubtype(typeof(_cthread_173), Thread_0())
; [eval] typeof(_cthread_173)
; [eval] Thread_0()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> issubtype(typeof(_cthread_173_0), Thread_0())
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 338 | p2_0@62@01 | live]
; [else-branch: 338 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 338 | p2_0@62@01]
; [eval] issubtype(typeof(_cthread_173_0), Thread_0())
; [eval] typeof(_cthread_173_0)
; [eval] Thread_0()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p1_32 ==> issubtype(typeof(self_6), Lock(Lock_arg(typeof(self_6), 0)))
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 339 | p1_0@61@01 | live]
; [else-branch: 339 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 339 | p1_0@61@01]
; [eval] issubtype(typeof(self_6), Lock(Lock_arg(typeof(self_6), 0)))
; [eval] typeof(self_6)
; [eval] Lock(Lock_arg(typeof(self_6), 0))
; [eval] Lock_arg(typeof(self_6), 0)
; [eval] typeof(self_6)
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> issubtype(typeof(self_6_0), Lock(Lock_arg(typeof(self_6_0), 0)))
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 340 | p2_0@62@01 | live]
; [else-branch: 340 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 340 | p2_0@62@01]
; [eval] issubtype(typeof(self_6_0), Lock(Lock_arg(typeof(self_6_0), 0)))
; [eval] typeof(self_6_0)
; [eval] Lock(Lock_arg(typeof(self_6_0), 0))
; [eval] Lock_arg(typeof(self_6_0), 0)
; [eval] typeof(self_6_0)
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p1_32 ==> issubtype(Lock_arg(typeof(self_6), 0), object())
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 341 | p1_0@61@01 | live]
; [else-branch: 341 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 341 | p1_0@61@01]
; [eval] issubtype(Lock_arg(typeof(self_6), 0), object())
; [eval] Lock_arg(typeof(self_6), 0)
; [eval] typeof(self_6)
; [eval] object()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> issubtype(Lock_arg(typeof(self_6_0), 0), object())
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 342 | p2_0@62@01 | live]
; [else-branch: 342 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 342 | p2_0@62@01]
; [eval] issubtype(Lock_arg(typeof(self_6_0), 0), object())
; [eval] Lock_arg(typeof(self_6_0), 0)
; [eval] typeof(self_6_0)
; [eval] object()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p1_32 ==> self_6 != null
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 343 | p1_0@61@01 | live]
; [else-branch: 343 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 343 | p1_0@61@01]
; [eval] self_6 != null
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> self_6_0 != null
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 344 | p2_0@62@01 | live]
; [else-branch: 344 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 344 | p2_0@62@01]
; [eval] self_6_0 != null
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p1_32 ==> true
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 345 | p1_0@61@01 | live]
; [else-branch: 345 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 345 | p1_0@61@01]
(pop) ; 38
(pop) ; 37
; Joined path conditions
; [eval] p2_32 ==> true
(push) ; 37
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 346 | p2_0@62@01 | live]
; [else-branch: 346 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 346 | p2_0@62@01]
(pop) ; 38
(pop) ; 37
; Joined path conditions
(push) ; 37
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
; [then-branch: 347 | p1_0@61@01 | live]
; [else-branch: 347 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 37
; [then-branch: 347 | p1_0@61@01]
; [eval] perm(self_6.MustReleaseBounded) > none && Measure$check(_caller_measures_173, self_6, 1)
; [eval] perm(self_6.MustReleaseBounded) > none
; [eval] perm(self_6.MustReleaseBounded)
; [then-branch: 348 | False | dead]
; [else-branch: 348 | True | live]
(push) ; 38
; [else-branch: 348 | True]
(push) ; 39
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 39
; 0.00s
; (get-info :all-statistics)
; [then-branch: 349 | p2_0@62@01 | live]
; [else-branch: 349 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 39
; [then-branch: 349 | p2_0@62@01]
; [eval] perm(self_6_0.MustReleaseBoundedp) > none && Measure$check(_caller_measures_173_0, self_6_0, 1)
; [eval] perm(self_6_0.MustReleaseBoundedp) > none
; [eval] perm(self_6_0.MustReleaseBoundedp)
; [then-branch: 350 | False | dead]
; [else-branch: 350 | True | live]
(push) ; 40
; [else-branch: 350 | True]
(push) ; 41
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 41
; 0.00s
; (get-info :all-statistics)
; [then-branch: 351 | p1_0@61@01 | live]
; [else-branch: 351 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 41
; [then-branch: 351 | p1_0@61@01]
(push) ; 42
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
; [then-branch: 352 | p2_0@62@01 | live]
; [else-branch: 352 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 42
; [then-branch: 352 | p2_0@62@01]
; [eval] p1_32 && p2_32 ==> Lock_invariant_low(self_6, self_6_0)
; [eval] p1_32 && p2_32
(push) ; 43
; [then-branch: 353 | !(p1_0@61@01) | live]
; [else-branch: 353 | p1_0@61@01 | live]
(push) ; 44
; [then-branch: 353 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 44
(push) ; 44
; [else-branch: 353 | p1_0@61@01]
(pop) ; 44
(pop) ; 43
; Joined path conditions
; Joined path conditions
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 44
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 354 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 354 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 354 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] Lock_invariant_low(self_6, self_6_0)
(push) ; 45
(declare-const $k@188@01 $Perm)
(assert ($Perm.isReadVar $k@188@01))
(push) ; 46
(set-option :timeout 10)
(assert (not (< $Perm.No $k@188@01)))
(check-sat)
; unsat
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
(declare-const $k@189@01 $Perm)
(assert ($Perm.isReadVar $k@189@01))
(set-option :timeout 0)
(push) ; 46
(set-option :timeout 10)
(assert (not (< $Perm.No $k@189@01)))
(check-sat)
; unsat
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine $Snap.unit $Snap.unit)
  ($Snap.combine $Snap.unit $Snap.unit)) l@69@01 l_1@70@01))
(pop) ; 45
; Joined path conditions
(assert ($Perm.isReadVar $k@188@01))
(assert ($Perm.isReadVar $k@189@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine $Snap.unit $Snap.unit)
  ($Snap.combine $Snap.unit $Snap.unit)) l@69@01 l_1@70@01))
(pop) ; 44
(pop) ; 43
; Joined path conditions
(assert ($Perm.isReadVar $k@188@01))
(assert ($Perm.isReadVar $k@189@01))
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] p1_32 && p2_32 ==> self_6 == self_6_0
; [eval] p1_32 && p2_32
(set-option :timeout 0)
(push) ; 43
; [then-branch: 355 | !(p1_0@61@01) | live]
; [else-branch: 355 | p1_0@61@01 | live]
(push) ; 44
; [then-branch: 355 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 44
(push) ; 44
; [else-branch: 355 | p1_0@61@01]
(pop) ; 44
(pop) ; 43
; Joined path conditions
; Joined path conditions
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not (and p1_0@61@01 p2_0@62@01))))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 44
(set-option :timeout 10)
(assert (not (and p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 356 | p1_0@61@01 && p2_0@62@01 | live]
; [else-branch: 356 | !(p1_0@61@01 && p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 356 | p1_0@61@01 && p2_0@62@01]
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] self_6 == self_6_0
(pop) ; 44
(pop) ; 43
; Joined path conditions
(assert (and p1_0@61@01 p2_0@62@01))
; [eval] p1_32 == p2_32
; [eval] p1_32 ==> typeof(self_6) == typeof(self_6_0)
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 357 | p1_0@61@01 | live]
; [else-branch: 357 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 357 | p1_0@61@01]
; [eval] typeof(self_6) == typeof(self_6_0)
; [eval] typeof(self_6)
; [eval] typeof(self_6_0)
(pop) ; 44
(pop) ; 43
; Joined path conditions
; [eval] p1_32 ==> Measure$check(_caller_measures_173, _cthread_173, 1) || perm(MustTerminate(_cthread_173)) == none && ((forperm _r_59: Ref [MustInvokeBounded(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBounded] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnbounded] :: false))))
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 358 | p1_0@61@01 | live]
; [else-branch: 358 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 358 | p1_0@61@01]
; [eval] Measure$check(_caller_measures_173, _cthread_173, 1) || perm(MustTerminate(_cthread_173)) == none && ((forperm _r_59: Ref [MustInvokeBounded(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBounded] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_173, _cthread_173, 1)
(push) ; 45
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 45
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(push) ; 45
; [then-branch: 359 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1) | live]
; [else-branch: 359 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)) | live]
(push) ; 46
; [then-branch: 359 | Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
(pop) ; 46
(push) ; 46
; [else-branch: 359 | !(Measure$check(_, _method_measures_161@88@01, _cthread_161@63@01, 1))]
(assert (not (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
; [eval] perm(MustTerminate(_cthread_173)) == none && ((forperm _r_59: Ref [MustInvokeBounded(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBounded] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_173)) == none
; [eval] perm(MustTerminate(_cthread_173))
(pop) ; 46
(pop) ; 45
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1))
  (Measure$check $Snap.unit _method_measures_161@88@01 _cthread_161@63@01 1)))
(pop) ; 44
(pop) ; 43
; Joined path conditions
; [eval] p2_32 ==> Measure$check(_caller_measures_173_0, _cthread_173_0, 1) || perm(MustTerminate_0(_cthread_173_0)) == none && ((forperm _r_59: Ref [MustInvokeBounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBoundedp] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnboundedp] :: false))))
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 360 | p2_0@62@01 | live]
; [else-branch: 360 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 360 | p2_0@62@01]
; [eval] Measure$check(_caller_measures_173_0, _cthread_173_0, 1) || perm(MustTerminate_0(_cthread_173_0)) == none && ((forperm _r_59: Ref [MustInvokeBounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBoundedp] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_173_0, _cthread_173_0, 1)
(push) ; 45
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 45
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(push) ; 45
; [then-branch: 361 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1) | live]
; [else-branch: 361 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)) | live]
(push) ; 46
; [then-branch: 361 | Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1)]
(assert (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
(pop) ; 46
(push) ; 46
; [else-branch: 361 | !(Measure$check(_, _method_measures_161_0@89@01, _cthread_161_0@64@01, 1))]
(assert (not
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
; [eval] perm(MustTerminate_0(_cthread_173_0)) == none && ((forperm _r_59: Ref [MustInvokeBounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [MustInvokeUnbounded_0(_r_59)] :: false) && ((forperm _r_59: Ref [_r_59.MustReleaseBoundedp] :: false) && (forperm _r_59: Ref [_r_59.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_173_0)) == none
; [eval] perm(MustTerminate_0(_cthread_173_0))
(pop) ; 46
(pop) ; 45
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1))
  (Measure$check $Snap.unit _method_measures_161_0@89@01 _cthread_161_0@64@01 1)))
(pop) ; 44
(pop) ; 43
; Joined path conditions
(declare-const _current_wait_level_173@190@01 $Perm)
(declare-const _current_wait_level_173_0@191@01 $Perm)
(declare-const $t@192@01 $Snap)
(assert (= $t@192@01 ($Snap.combine ($Snap.first $t@192@01) ($Snap.second $t@192@01))))
(assert (= ($Snap.first $t@192@01) $Snap.unit))
; [eval] p1_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173) && ((forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173) && _residue_173 <= _current_wait_level_173)
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 362 | p1_0@61@01 | live]
; [else-branch: 362 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 362 | p1_0@61@01]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173) && ((forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173) && _residue_173 <= _current_wait_level_173)
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173)
(push) ; 45
; [then-branch: 363 | False | live]
; [else-branch: 363 | True | live]
(push) ; 46
; [then-branch: 363 | False]
(assert false)
(pop) ; 46
(push) ; 46
; [else-branch: 363 | True]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173)
(push) ; 47
; [then-branch: 364 | False | live]
; [else-branch: 364 | True | live]
(push) ; 48
; [then-branch: 364 | False]
(assert false)
(pop) ; 48
(push) ; 48
; [else-branch: 364 | True]
; [eval] _residue_173 <= _current_wait_level_173
(pop) ; 48
(pop) ; 47
; Joined path conditions
; Joined path conditions
(pop) ; 46
(pop) ; 45
; Joined path conditions
; Joined path conditions
(pop) ; 44
(pop) ; 43
; Joined path conditions
(assert (=> p1_0@61@01 (<= _residue_161@67@01 _current_wait_level_173@190@01)))
(assert (= ($Snap.second $t@192@01) $Snap.unit))
; [eval] p2_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0) && ((forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0) && _residue_173_0 <= _current_wait_level_173_0)
(push) ; 43
(push) ; 44
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 365 | p2_0@62@01 | live]
; [else-branch: 365 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 365 | p2_0@62@01]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0) && ((forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0) && _residue_173_0 <= _current_wait_level_173_0)
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0)
(push) ; 45
; [then-branch: 366 | False | live]
; [else-branch: 366 | True | live]
(push) ; 46
; [then-branch: 366 | False]
(assert false)
(pop) ; 46
(push) ; 46
; [else-branch: 366 | True]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0)
(push) ; 47
; [then-branch: 367 | False | live]
; [else-branch: 367 | True | live]
(push) ; 48
; [then-branch: 367 | False]
(assert false)
(pop) ; 48
(push) ; 48
; [else-branch: 367 | True]
; [eval] _residue_173_0 <= _current_wait_level_173_0
(pop) ; 48
(pop) ; 47
; Joined path conditions
; Joined path conditions
(pop) ; 46
(pop) ; 45
; Joined path conditions
; Joined path conditions
(pop) ; 44
(pop) ; 43
; Joined path conditions
(assert (=> p2_0@62@01 (<= _residue_161_0@68@01 _current_wait_level_173_0@191@01)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 43
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 368 | p1_0@61@01 | live]
; [else-branch: 368 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 368 | p1_0@61@01]
; [exec]
; _cwl_161 := tmp1_18
(push) ; 44
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 369 | p2_0@62@01 | live]
; [else-branch: 369 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 369 | p2_0@62@01]
; [exec]
; _cwl_161_0 := tmp2_18
; [exec]
; assert true
; [eval] p1_0 ==> true
(push) ; 45
(push) ; 46
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 370 | p1_0@61@01 | live]
; [else-branch: 370 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 370 | p1_0@61@01]
(pop) ; 46
(pop) ; 45
; Joined path conditions
; [eval] p2_0 ==> true
(push) ; 45
(push) ; 46
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 371 | p2_0@62@01 | live]
; [else-branch: 371 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 371 | p2_0@62@01]
(pop) ; 46
(pop) ; 45
; Joined path conditions
; [eval] p1_0 ==> (forperm _r_4: Ref [MustInvokeBounded(_r_4)] :: false) && ((forperm _r_4: Ref [MustInvokeUnbounded(_r_4)] :: false) && ((forperm _r_4: Ref [_r_4.MustReleaseBounded] :: false) && (forperm _r_4: Ref [_r_4.MustReleaseUnbounded] :: false)))
(push) ; 45
(push) ; 46
(set-option :timeout 10)
(assert (not (not p1_0@61@01)))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 372 | p1_0@61@01 | live]
; [else-branch: 372 | !(p1_0@61@01) | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 372 | p1_0@61@01]
; [eval] (forperm _r_4: Ref [MustInvokeBounded(_r_4)] :: false) && ((forperm _r_4: Ref [MustInvokeUnbounded(_r_4)] :: false) && ((forperm _r_4: Ref [_r_4.MustReleaseBounded] :: false) && (forperm _r_4: Ref [_r_4.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_4: Ref [MustInvokeBounded(_r_4)] :: false)
(push) ; 47
; [then-branch: 373 | False | live]
; [else-branch: 373 | True | live]
(push) ; 48
; [then-branch: 373 | False]
(assert false)
(pop) ; 48
(push) ; 48
; [else-branch: 373 | True]
; [eval] (forperm _r_4: Ref [MustInvokeUnbounded(_r_4)] :: false)
(push) ; 49
; [then-branch: 374 | False | live]
; [else-branch: 374 | True | live]
(push) ; 50
; [then-branch: 374 | False]
(assert false)
(pop) ; 50
(push) ; 50
; [else-branch: 374 | True]
; [eval] (forperm _r_4: Ref [_r_4.MustReleaseBounded] :: false)
(push) ; 51
; [then-branch: 375 | False | live]
; [else-branch: 375 | True | live]
(push) ; 52
; [then-branch: 375 | False]
(assert false)
(pop) ; 52
(push) ; 52
; [else-branch: 375 | True]
; [eval] (forperm _r_4: Ref [_r_4.MustReleaseUnbounded] :: false)
(pop) ; 52
(pop) ; 51
; Joined path conditions
; Joined path conditions
(pop) ; 50
(pop) ; 49
; Joined path conditions
; Joined path conditions
(pop) ; 48
(pop) ; 47
; Joined path conditions
; Joined path conditions
(pop) ; 46
(pop) ; 45
; Joined path conditions
; [eval] p2_0 ==> (forperm _r_4: Ref [MustInvokeBounded_0(_r_4)] :: false) && ((forperm _r_4: Ref [MustInvokeUnbounded_0(_r_4)] :: false) && ((forperm _r_4: Ref [_r_4.MustReleaseBoundedp] :: false) && (forperm _r_4: Ref [_r_4.MustReleaseUnboundedp] :: false)))
(push) ; 45
(push) ; 46
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 376 | p2_0@62@01 | live]
; [else-branch: 376 | !(p2_0@62@01) | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 376 | p2_0@62@01]
; [eval] (forperm _r_4: Ref [MustInvokeBounded_0(_r_4)] :: false) && ((forperm _r_4: Ref [MustInvokeUnbounded_0(_r_4)] :: false) && ((forperm _r_4: Ref [_r_4.MustReleaseBoundedp] :: false) && (forperm _r_4: Ref [_r_4.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_4: Ref [MustInvokeBounded_0(_r_4)] :: false)
(push) ; 47
; [then-branch: 377 | False | live]
; [else-branch: 377 | True | live]
(push) ; 48
; [then-branch: 377 | False]
(assert false)
(pop) ; 48
(push) ; 48
; [else-branch: 377 | True]
; [eval] (forperm _r_4: Ref [MustInvokeUnbounded_0(_r_4)] :: false)
(push) ; 49
; [then-branch: 378 | False | live]
; [else-branch: 378 | True | live]
(push) ; 50
; [then-branch: 378 | False]
(assert false)
(pop) ; 50
(push) ; 50
; [else-branch: 378 | True]
; [eval] (forperm _r_4: Ref [_r_4.MustReleaseBoundedp] :: false)
(push) ; 51
; [then-branch: 379 | False | live]
; [else-branch: 379 | True | live]
(push) ; 52
; [then-branch: 379 | False]
(assert false)
(pop) ; 52
(push) ; 52
; [else-branch: 379 | True]
; [eval] (forperm _r_4: Ref [_r_4.MustReleaseUnboundedp] :: false)
(pop) ; 52
(pop) ; 51
; Joined path conditions
; Joined path conditions
(pop) ; 50
(pop) ; 49
; Joined path conditions
; Joined path conditions
(pop) ; 48
(pop) ; 47
; Joined path conditions
; Joined path conditions
(pop) ; 46
(pop) ; 45
; Joined path conditions
(pop) ; 44
; [eval] !p2_0
; [then-branch: 380 | !(p2_0@62@01) | dead]
; [else-branch: 380 | p2_0@62@01 | live]
(push) ; 44
; [else-branch: 380 | p2_0@62@01]
(pop) ; 44
(pop) ; 43
; [eval] !p1_0
; [then-branch: 381 | !(p1_0@61@01) | dead]
; [else-branch: 381 | p1_0@61@01 | live]
(push) ; 43
; [else-branch: 381 | p1_0@61@01]
(pop) ; 43
(pop) ; 42
(pop) ; 41
(pop) ; 40
(pop) ; 39
(pop) ; 38
(pop) ; 37
(pop) ; 36
; [eval] !p2_0
(push) ; 36
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 382 | !(p2_0@62@01) | dead]
; [else-branch: 382 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 36
; [else-branch: 382 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 36
(pop) ; 35
; [eval] !p1_0
(push) ; 35
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 383 | !(p1_0@61@01) | dead]
; [else-branch: 383 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 35
; [else-branch: 383 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 35
(pop) ; 34
; [eval] !(p1_0 || p2_0)
; [eval] p1_0 || p2_0
(push) ; 34
; [then-branch: 384 | p1_0@61@01 | live]
; [else-branch: 384 | !(p1_0@61@01) | live]
(push) ; 35
; [then-branch: 384 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 35
(push) ; 35
; [else-branch: 384 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
; [then-branch: 385 | !(p1_0@61@01 || p2_0@62@01) | dead]
; [else-branch: 385 | p1_0@61@01 || p2_0@62@01 | live]
(push) ; 34
; [else-branch: 385 | p1_0@61@01 || p2_0@62@01]
(pop) ; 34
(pop) ; 33
(pop) ; 32
; [eval] !p2_0
(push) ; 32
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 386 | !(p2_0@62@01) | dead]
; [else-branch: 386 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 32
; [else-branch: 386 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 32
(pop) ; 31
(pop) ; 30
; [eval] !p1_0
(push) ; 30
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
; [then-branch: 387 | !(p1_0@61@01) | dead]
; [else-branch: 387 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 30
; [else-branch: 387 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 30
(pop) ; 29
; [eval] !p2_0
(push) ; 29
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 388 | !(p2_0@62@01) | dead]
; [else-branch: 388 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 29
; [else-branch: 388 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 29
(pop) ; 28
; [eval] !p1_0
(push) ; 28
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 389 | !(p1_0@61@01) | dead]
; [else-branch: 389 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 28
; [else-branch: 389 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 28
(pop) ; 27
; [eval] !p2_0
(push) ; 27
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 390 | !(p2_0@62@01) | dead]
; [else-branch: 390 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 27
; [else-branch: 390 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 27
(pop) ; 26
; [eval] !p1_0
(push) ; 26
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 391 | !(p1_0@61@01) | dead]
; [else-branch: 391 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 26
; [else-branch: 391 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 26
(pop) ; 25
; [eval] !(p1_0 || p2_0)
; [eval] p1_0 || p2_0
(push) ; 25
; [then-branch: 392 | p1_0@61@01 | live]
; [else-branch: 392 | !(p1_0@61@01) | live]
(push) ; 26
; [then-branch: 392 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 26
(push) ; 26
; [else-branch: 392 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
; [then-branch: 393 | !(p1_0@61@01 || p2_0@62@01) | dead]
; [else-branch: 393 | p1_0@61@01 || p2_0@62@01 | live]
(push) ; 25
; [else-branch: 393 | p1_0@61@01 || p2_0@62@01]
(pop) ; 25
(pop) ; 24
; [eval] !p2_0
(push) ; 24
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 394 | !(p2_0@62@01) | dead]
; [else-branch: 394 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 24
; [else-branch: 394 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 24
(pop) ; 23
; [eval] !p1_0
(push) ; 23
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 395 | !(p1_0@61@01) | dead]
; [else-branch: 395 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 23
; [else-branch: 395 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 23
(pop) ; 22
; [eval] !p2_0
(push) ; 22
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 396 | !(p2_0@62@01) | dead]
; [else-branch: 396 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 22
; [else-branch: 396 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 22
(pop) ; 21
; [eval] !p1_0
(push) ; 21
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 397 | !(p1_0@61@01) | dead]
; [else-branch: 397 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 21
; [else-branch: 397 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 21
(pop) ; 20
; [eval] !(p1_0 || p2_0)
; [eval] p1_0 || p2_0
(push) ; 20
; [then-branch: 398 | p1_0@61@01 | live]
; [else-branch: 398 | !(p1_0@61@01) | live]
(push) ; 21
; [then-branch: 398 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 21
(push) ; 21
; [else-branch: 398 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
; [then-branch: 399 | !(p1_0@61@01 || p2_0@62@01) | dead]
; [else-branch: 399 | p1_0@61@01 || p2_0@62@01 | live]
(push) ; 20
; [else-branch: 399 | p1_0@61@01 || p2_0@62@01]
(pop) ; 20
(pop) ; 19
(pop) ; 18
; [eval] !p2_0
(push) ; 18
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 400 | !(p2_0@62@01) | dead]
; [else-branch: 400 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 18
; [else-branch: 400 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 18
(pop) ; 17
(pop) ; 16
; [eval] !p1_0
(push) ; 16
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 401 | !(p1_0@61@01) | dead]
; [else-branch: 401 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 401 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 16
(pop) ; 15
; [eval] !p2_0
(push) ; 15
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 402 | !(p2_0@62@01) | dead]
; [else-branch: 402 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 15
; [else-branch: 402 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 15
(pop) ; 14
; [eval] !p1_0
(push) ; 14
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 403 | !(p1_0@61@01) | dead]
; [else-branch: 403 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 14
; [else-branch: 403 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 14
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
; [eval] !p2_0
(push) ; 9
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 404 | !(p2_0@62@01) | dead]
; [else-branch: 404 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 404 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 9
(pop) ; 8
; [eval] !p1_0
(push) ; 8
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 405 | !(p1_0@61@01) | dead]
; [else-branch: 405 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 405 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 8
(pop) ; 7
; [eval] !(p1_0 || p2_0)
; [eval] p1_0 || p2_0
(push) ; 7
; [then-branch: 406 | p1_0@61@01 | live]
; [else-branch: 406 | !(p1_0@61@01) | live]
(push) ; 8
; [then-branch: 406 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 8
(push) ; 8
; [else-branch: 406 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(assert (not (or p1_0@61@01 p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 407 | !(p1_0@61@01 || p2_0@62@01) | dead]
; [else-branch: 407 | p1_0@61@01 || p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 407 | p1_0@61@01 || p2_0@62@01]
(assert (or p1_0@61@01 p2_0@62@01))
(pop) ; 7
(pop) ; 6
; [eval] !p2_0
(push) ; 6
(set-option :timeout 10)
(assert (not p2_0@62@01))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 408 | !(p2_0@62@01) | dead]
; [else-branch: 408 | p2_0@62@01 | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 408 | p2_0@62@01]
(assert p2_0@62@01)
(pop) ; 6
(pop) ; 5
; [eval] !p1_0
(push) ; 5
(set-option :timeout 10)
(assert (not p1_0@61@01))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 409 | !(p1_0@61@01) | dead]
; [else-branch: 409 | p1_0@61@01 | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 409 | p1_0@61@01]
(assert p1_0@61@01)
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [else-branch: 55 | !(p1_0@61@01)]
(assert (not p1_0@61@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_0@62@01)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 410 | p2_0@62@01 | dead]
; [else-branch: 410 | !(p2_0@62@01) | live]
(set-option :timeout 0)
(push) ; 3
; [else-branch: 410 | !(p2_0@62@01)]
(assert (not p2_0@62@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))
  $Snap.unit))
; [eval] p1_0 ==> _residue_161 < Level(l)
(push) ; 4
; [then-branch: 411 | p1_0@61@01 | dead]
; [else-branch: 411 | !(p1_0@61@01) | live]
(push) ; 5
; [else-branch: 411 | !(p1_0@61@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))
  $Snap.unit))
; [eval] p2_0 ==> _residue_161_0 < Level(l_1)
(push) ; 4
; [then-branch: 412 | p2_0@62@01 | dead]
; [else-branch: 412 | !(p2_0@62@01) | live]
(push) ; 5
; [else-branch: 412 | !(p2_0@62@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))
  $Snap.unit))
; [eval] p1_0 ==> true
(push) ; 4
; [then-branch: 413 | p1_0@61@01 | dead]
; [else-branch: 413 | !(p1_0@61@01) | live]
(push) ; 5
; [else-branch: 413 | !(p1_0@61@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))
  $Snap.unit))
; [eval] p2_0 ==> true
(push) ; 4
; [then-branch: 414 | p2_0@62@01 | dead]
; [else-branch: 414 | !(p2_0@62@01) | live]
(push) ; 5
; [else-branch: 414 | !(p2_0@62@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))))
  $Snap.unit))
; [eval] p1_0 ==> true
(push) ; 4
; [then-branch: 415 | p1_0@61@01 | dead]
; [else-branch: 415 | !(p1_0@61@01) | live]
(push) ; 5
; [else-branch: 415 | !(p1_0@61@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@01))))))))))))))))))
  $Snap.unit))
; [eval] p2_0 ==> true
(push) ; 4
; [then-branch: 416 | p2_0@62@01 | dead]
; [else-branch: 416 | !(p2_0@62@01) | live]
(push) ; 5
; [else-branch: 416 | !(p2_0@62@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(declare-const $t@193@01 $Snap)
(assert (= $t@193@01 ($Snap.combine ($Snap.first $t@193@01) ($Snap.second $t@193@01))))
(assert (= ($Snap.first $t@193@01) $Snap.unit))
; [eval] p1_0 ==> (forperm _r_3: Ref [_r_3.MustReleaseBounded] :: Level(_r_3) <= _current_wait_level_161) && ((forperm _r_3: Ref [_r_3.MustReleaseUnbounded] :: Level(_r_3) <= _current_wait_level_161) && _residue_161 <= _current_wait_level_161)
(push) ; 5
; [then-branch: 417 | p1_0@61@01 | dead]
; [else-branch: 417 | !(p1_0@61@01) | live]
(push) ; 6
; [else-branch: 417 | !(p1_0@61@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second $t@193@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@193@01))
    ($Snap.second ($Snap.second $t@193@01)))))
(assert (= ($Snap.first ($Snap.second $t@193@01)) $Snap.unit))
; [eval] p2_0 ==> (forperm _r_3: Ref [_r_3.MustReleaseBoundedp] :: Level(_r_3) <= _current_wait_level_161_0) && ((forperm _r_3: Ref [_r_3.MustReleaseUnboundedp] :: Level(_r_3) <= _current_wait_level_161_0) && _residue_161_0 <= _current_wait_level_161_0)
(push) ; 5
; [then-branch: 418 | p2_0@62@01 | dead]
; [else-branch: 418 | !(p2_0@62@01) | live]
(push) ; 6
; [else-branch: 418 | !(p2_0@62@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@193@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@193@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@193@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@193@01))) $Snap.unit))
; [eval] p1_0 ==> true
(push) ; 5
; [then-branch: 419 | p1_0@61@01 | dead]
; [else-branch: 419 | !(p1_0@61@01) | live]
(push) ; 6
; [else-branch: 419 | !(p1_0@61@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@193@01))) $Snap.unit))
; [eval] p2_0 ==> true
(push) ; 5
; [then-branch: 420 | p2_0@62@01 | dead]
; [else-branch: 420 | !(p2_0@62@01) | live]
(push) ; 6
; [else-branch: 420 | !(p2_0@62@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [exec]
; var _err: Ref
(declare-const _err@194@01 $Ref)
; [exec]
; var _err_1: Ref
(declare-const _err_1@195@01 $Ref)
; [exec]
; var l_0: Ref
(declare-const l_0@196@01 $Ref)
; [exec]
; var l_0_0: Ref
(declare-const l_0_0@197@01 $Ref)
; [exec]
; var x_5: Ref
(declare-const x_5@198@01 $Ref)
; [exec]
; var x_5_0: Ref
(declare-const x_5_0@199@01 $Ref)
; [exec]
; var _cwl_161: Perm
(declare-const _cwl_161@200@01 $Perm)
; [exec]
; var _cwl_161_0: Perm
(declare-const _cwl_161_0@201@01 $Perm)
; [exec]
; var _method_measures_161: Seq[Measure$]
(declare-const _method_measures_161@202@01 Seq<Measure$>)
; [exec]
; var _method_measures_161_0: Seq[Measure$]
(declare-const _method_measures_161_0@203@01 Seq<Measure$>)
; [exec]
; inhale p1_0
(declare-const $t@204@01 $Snap)
(assert (= $t@204@01 $Snap.unit))
(assert p1_0@61@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 421 | p1_0@61@01 | dead]
; [else-branch: 421 | !(p1_0@61@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 421 | !(p1_0@61@01)]
(pop) ; 5
; [eval] !p1_0
; [then-branch: 422 | !(p1_0@61@01) | dead]
; [else-branch: 422 | p1_0@61@01 | live]
(push) ; 5
; [else-branch: 422 | p1_0@61@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- printZero ----------
(declare-const p1_1@205@01 Bool)
(declare-const p2_1@206@01 Bool)
(declare-const _cthread_162@207@01 $Ref)
(declare-const _cthread_162_0@208@01 $Ref)
(declare-const _caller_measures_162@209@01 Seq<Measure$>)
(declare-const _caller_measures_162_0@210@01 Seq<Measure$>)
(declare-const _residue_162@211@01 $Perm)
(declare-const _residue_162_0@212@01 $Perm)
(declare-const _current_wait_level_162@213@01 $Perm)
(declare-const _current_wait_level_162_0@214@01 $Perm)
(declare-const p1_1@215@01 Bool)
(declare-const p2_1@216@01 Bool)
(declare-const _cthread_162@217@01 $Ref)
(declare-const _cthread_162_0@218@01 $Ref)
(declare-const _caller_measures_162@219@01 Seq<Measure$>)
(declare-const _caller_measures_162_0@220@01 Seq<Measure$>)
(declare-const _residue_162@221@01 $Perm)
(declare-const _residue_162_0@222@01 $Perm)
(declare-const _current_wait_level_162@223@01 $Perm)
(declare-const _current_wait_level_162_0@224@01 $Perm)
(push) ; 1
(declare-const $t@225@01 $Snap)
(assert (= $t@225@01 ($Snap.combine ($Snap.first $t@225@01) ($Snap.second $t@225@01))))
(assert (= ($Snap.first $t@225@01) $Snap.unit))
; [eval] p1_1 ==> _cthread_162 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_1@215@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 423 | p1_1@215@01 | live]
; [else-branch: 423 | !(p1_1@215@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 423 | p1_1@215@01]
(assert p1_1@215@01)
; [eval] _cthread_162 != null
(pop) ; 3
(push) ; 3
; [else-branch: 423 | !(p1_1@215@01)]
(assert (not p1_1@215@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_1@215@01) p1_1@215@01))
(assert (=> p1_1@215@01 (not (= _cthread_162@217@01 $Ref.null))))
(assert (=
  ($Snap.second $t@225@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@225@01))
    ($Snap.second ($Snap.second $t@225@01)))))
(assert (= ($Snap.first ($Snap.second $t@225@01)) $Snap.unit))
; [eval] p2_1 ==> _cthread_162_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_1@216@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 424 | p2_1@216@01 | live]
; [else-branch: 424 | !(p2_1@216@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 424 | p2_1@216@01]
(assert p2_1@216@01)
; [eval] _cthread_162_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 424 | !(p2_1@216@01)]
(assert (not p2_1@216@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_1@216@01) p2_1@216@01))
(assert (=> p2_1@216@01 (not (= _cthread_162_0@218@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@225@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@225@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@225@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@225@01))) $Snap.unit))
; [eval] p1_1 ==> issubtype(typeof(_cthread_162), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_1@215@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 425 | p1_1@215@01 | live]
; [else-branch: 425 | !(p1_1@215@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 425 | p1_1@215@01]
(assert p1_1@215@01)
; [eval] issubtype(typeof(_cthread_162), Thread_0())
; [eval] typeof(_cthread_162)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 425 | !(p1_1@215@01)]
(assert (not p1_1@215@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_1@215@01
  (issubtype<Bool> (typeof<PyType> _cthread_162@217@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@225@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@225@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@225@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@225@01))))
  $Snap.unit))
; [eval] p2_1 ==> issubtype(typeof(_cthread_162_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_1@216@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 426 | p2_1@216@01 | live]
; [else-branch: 426 | !(p2_1@216@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 426 | p2_1@216@01]
(assert p2_1@216@01)
; [eval] issubtype(typeof(_cthread_162_0), Thread_0())
; [eval] typeof(_cthread_162_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 426 | !(p2_1@216@01)]
(assert (not p2_1@216@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_1@216@01
  (issubtype<Bool> (typeof<PyType> _cthread_162_0@218@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@225@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@225@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@225@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@225@01)))))
  $Snap.unit))
; [eval] p1_1 == p2_1
(assert (= p1_1@215@01 p2_1@216@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@225@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@225@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@225@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@225@01))))))
  $Snap.unit))
; [eval] p1_1 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_1@215@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 427 | p1_1@215@01 | live]
; [else-branch: 427 | !(p1_1@215@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 427 | p1_1@215@01]
(assert p1_1@215@01)
(pop) ; 3
(push) ; 3
; [else-branch: 427 | !(p1_1@215@01)]
(assert (not p1_1@215@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@225@01))))))
  $Snap.unit))
; [eval] p2_1 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_1@216@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 428 | p2_1@216@01 | live]
; [else-branch: 428 | !(p2_1@216@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 428 | p2_1@216@01]
(assert p2_1@216@01)
(pop) ; 3
(push) ; 3
; [else-branch: 428 | !(p2_1@216@01)]
(assert (not p2_1@216@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@226@01 $Snap)
(assert (= $t@226@01 ($Snap.combine ($Snap.first $t@226@01) ($Snap.second $t@226@01))))
(assert (= ($Snap.first $t@226@01) $Snap.unit))
; [eval] p1_1 ==> (forperm _r_6: Ref [_r_6.MustReleaseBounded] :: Level(_r_6) <= _current_wait_level_162) && ((forperm _r_6: Ref [_r_6.MustReleaseUnbounded] :: Level(_r_6) <= _current_wait_level_162) && _residue_162 <= _current_wait_level_162)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_1@215@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 429 | p1_1@215@01 | live]
; [else-branch: 429 | !(p1_1@215@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 429 | p1_1@215@01]
(assert p1_1@215@01)
; [eval] (forperm _r_6: Ref [_r_6.MustReleaseBounded] :: Level(_r_6) <= _current_wait_level_162) && ((forperm _r_6: Ref [_r_6.MustReleaseUnbounded] :: Level(_r_6) <= _current_wait_level_162) && _residue_162 <= _current_wait_level_162)
; [eval] (forperm _r_6: Ref [_r_6.MustReleaseBounded] :: Level(_r_6) <= _current_wait_level_162)
(push) ; 5
; [then-branch: 430 | False | live]
; [else-branch: 430 | True | live]
(push) ; 6
; [then-branch: 430 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 430 | True]
; [eval] (forperm _r_6: Ref [_r_6.MustReleaseUnbounded] :: Level(_r_6) <= _current_wait_level_162)
(push) ; 7
; [then-branch: 431 | False | live]
; [else-branch: 431 | True | live]
(push) ; 8
; [then-branch: 431 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 431 | True]
; [eval] _residue_162 <= _current_wait_level_162
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 429 | !(p1_1@215@01)]
(assert (not p1_1@215@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p1_1@215@01 (<= _residue_162@221@01 _current_wait_level_162@223@01)))
(assert (=
  ($Snap.second $t@226@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@226@01))
    ($Snap.second ($Snap.second $t@226@01)))))
(assert (= ($Snap.first ($Snap.second $t@226@01)) $Snap.unit))
; [eval] p2_1 ==> (forperm _r_6: Ref [_r_6.MustReleaseBoundedp] :: Level(_r_6) <= _current_wait_level_162_0) && ((forperm _r_6: Ref [_r_6.MustReleaseUnboundedp] :: Level(_r_6) <= _current_wait_level_162_0) && _residue_162_0 <= _current_wait_level_162_0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_1@216@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 432 | p2_1@216@01 | live]
; [else-branch: 432 | !(p2_1@216@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 432 | p2_1@216@01]
(assert p2_1@216@01)
; [eval] (forperm _r_6: Ref [_r_6.MustReleaseBoundedp] :: Level(_r_6) <= _current_wait_level_162_0) && ((forperm _r_6: Ref [_r_6.MustReleaseUnboundedp] :: Level(_r_6) <= _current_wait_level_162_0) && _residue_162_0 <= _current_wait_level_162_0)
; [eval] (forperm _r_6: Ref [_r_6.MustReleaseBoundedp] :: Level(_r_6) <= _current_wait_level_162_0)
(push) ; 5
; [then-branch: 433 | False | live]
; [else-branch: 433 | True | live]
(push) ; 6
; [then-branch: 433 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 433 | True]
; [eval] (forperm _r_6: Ref [_r_6.MustReleaseUnboundedp] :: Level(_r_6) <= _current_wait_level_162_0)
(push) ; 7
; [then-branch: 434 | False | live]
; [else-branch: 434 | True | live]
(push) ; 8
; [then-branch: 434 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 434 | True]
; [eval] _residue_162_0 <= _current_wait_level_162_0
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 432 | !(p2_1@216@01)]
(assert (not p2_1@216@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p2_1@216@01 (<= _residue_162_0@222@01 _current_wait_level_162_0@224@01)))
(assert (=
  ($Snap.second ($Snap.second $t@226@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@226@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@226@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@226@01))) $Snap.unit))
; [eval] p1_1 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_1@215@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 435 | p1_1@215@01 | live]
; [else-branch: 435 | !(p1_1@215@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 435 | p1_1@215@01]
(assert p1_1@215@01)
(pop) ; 4
(push) ; 4
; [else-branch: 435 | !(p1_1@215@01)]
(assert (not p1_1@215@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@226@01))) $Snap.unit))
; [eval] p2_1 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_1@216@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 436 | p2_1@216@01 | live]
; [else-branch: 436 | !(p2_1@216@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 436 | p2_1@216@01]
(assert p2_1@216@01)
(pop) ; 4
(push) ; 4
; [else-branch: 436 | !(p2_1@216@01)]
(assert (not p2_1@216@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
(push) ; 2
; [exec]
; var _err: Ref
(declare-const _err@227@01 $Ref)
; [exec]
; var _err_2: Ref
(declare-const _err_2@228@01 $Ref)
; [exec]
; var _cwl_162: Perm
(declare-const _cwl_162@229@01 $Perm)
; [exec]
; var _cwl_162_0: Perm
(declare-const _cwl_162_0@230@01 $Perm)
; [exec]
; var _method_measures_162: Seq[Measure$]
(declare-const _method_measures_162@231@01 Seq<Measure$>)
; [exec]
; var _method_measures_162_0: Seq[Measure$]
(declare-const _method_measures_162_0@232@01 Seq<Measure$>)
; [exec]
; inhale p1_1
(declare-const $t@233@01 $Snap)
(assert (= $t@233@01 $Snap.unit))
(assert p1_1@215@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 437 | p1_1@215@01 | live]
; [else-branch: 437 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 437 | p1_1@215@01]
; [exec]
; _method_measures_162 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err := null
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_1@216@01))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 438 | p2_1@216@01 | live]
; [else-branch: 438 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 438 | p2_1@216@01]
(assert p2_1@216@01)
; [exec]
; _method_measures_162_0 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err_2 := null
; [eval] p1_1 || p2_1
(push) ; 5
; [then-branch: 439 | p1_1@215@01 | live]
; [else-branch: 439 | !(p1_1@215@01) | live]
(push) ; 6
; [then-branch: 439 | p1_1@215@01]
(pop) ; 6
(push) ; 6
; [else-branch: 439 | !(p1_1@215@01)]
(assert (not p1_1@215@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (not (or p1_1@215@01 p2_1@216@01))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (or p1_1@215@01 p2_1@216@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 440 | p1_1@215@01 || p2_1@216@01 | live]
; [else-branch: 440 | !(p1_1@215@01 || p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 440 | p1_1@215@01 || p2_1@216@01]
(assert (or p1_1@215@01 p2_1@216@01))
; [exec]
; var tmp1_19: Ref
(declare-const tmp1_19@234@01 $Ref)
; [exec]
; var tmp2_19: Ref
(declare-const tmp2_19@235@01 $Ref)
; [exec]
; var tmp1_20: Seq[Measure$]
(declare-const tmp1_20@236@01 Seq<Measure$>)
; [exec]
; var tmp2_20: Seq[Measure$]
(declare-const tmp2_20@237@01 Seq<Measure$>)
; [exec]
; var tmp1_21: Perm
(declare-const tmp1_21@238@01 $Perm)
; [exec]
; var tmp2_21: Perm
(declare-const tmp2_21@239@01 $Perm)
; [exec]
; var tmp1_22: Ref
(declare-const tmp1_22@240@01 $Ref)
; [exec]
; var tmp2_22: Ref
(declare-const tmp2_22@241@01 $Ref)
; [exec]
; var tmp1_23: Perm
(declare-const tmp1_23@242@01 $Perm)
; [exec]
; var tmp2_23: Perm
(declare-const tmp2_23@243@01 $Perm)
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 441 | p1_1@215@01 | live]
; [else-branch: 441 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 441 | p1_1@215@01]
; [exec]
; tmp1_19 := _cthread_162
; [exec]
; tmp1_20 := _method_measures_162
; [exec]
; tmp1_21 := _residue_162
; [exec]
; tmp1_22 := __prim__int___box__(0)
; [eval] __prim__int___box__(0)
(push) ; 7
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 7
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(declare-const tmp1_22@244@01 $Ref)
(assert (= tmp1_22@244@01 (__prim__int___box__ $Snap.unit 0)))
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 442 | p2_1@216@01 | live]
; [else-branch: 442 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 442 | p2_1@216@01]
; [exec]
; tmp2_19 := _cthread_162_0
; [exec]
; tmp2_20 := _method_measures_162_0
; [exec]
; tmp2_21 := _residue_162_0
; [exec]
; tmp2_22 := __prim__int___box__(0)
; [eval] __prim__int___box__(0)
(push) ; 8
(pop) ; 8
; Joined path conditions
(declare-const tmp2_22@245@01 $Ref)
(assert (= tmp2_22@245@01 (__prim__int___box__ $Snap.unit 0)))
; [exec]
; tmp1_23, tmp2_23 := sif_print(p1_1, p2_1, tmp1_19, tmp2_19, tmp1_20, tmp2_20,
;   tmp1_21, tmp2_21, tmp1_22, tmp2_22)
; [eval] p1 ==> _cthread_160 != null
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 443 | p1_1@215@01 | live]
; [else-branch: 443 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 443 | p1_1@215@01]
; [eval] _cthread_160 != null
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2 ==> _cthread_160_0 != null
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 444 | p2_1@216@01 | live]
; [else-branch: 444 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 444 | p2_1@216@01]
; [eval] _cthread_160_0 != null
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(_cthread_160), Thread_0())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 445 | p1_1@215@01 | live]
; [else-branch: 445 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 445 | p1_1@215@01]
; [eval] issubtype(typeof(_cthread_160), Thread_0())
; [eval] typeof(_cthread_160)
; [eval] Thread_0()
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2 ==> issubtype(typeof(_cthread_160_0), Thread_0())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 446 | p2_1@216@01 | live]
; [else-branch: 446 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 446 | p2_1@216@01]
; [eval] issubtype(typeof(_cthread_160_0), Thread_0())
; [eval] typeof(_cthread_160_0)
; [eval] Thread_0()
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(x_0), int())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 447 | p1_1@215@01 | live]
; [else-branch: 447 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 447 | p1_1@215@01]
; [eval] issubtype(typeof(x_0), int())
; [eval] typeof(x_0)
; [eval] int()
(pop) ; 9
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (=>
  p1_1@215@01
  (issubtype<Bool> (typeof<PyType> tmp1_22@244@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_1@215@01
  (issubtype<Bool> (typeof<PyType> tmp1_22@244@01) (as int<PyType>  PyType))))
; [eval] p2 ==> issubtype(typeof(x_0_0), int())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 448 | p2_1@216@01 | live]
; [else-branch: 448 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 448 | p2_1@216@01]
; [eval] issubtype(typeof(x_0_0), int())
; [eval] typeof(x_0_0)
; [eval] int()
(pop) ; 9
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (=>
  p2_1@216@01
  (issubtype<Bool> (typeof<PyType> tmp2_22@245@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_1@216@01
  (issubtype<Bool> (typeof<PyType> tmp2_22@245@01) (as int<PyType>  PyType))))
; [eval] p1 == p2
; [eval] p1 && p2 ==> int___eq__(x_0, x_0_0)
; [eval] p1 && p2
(push) ; 8
; [then-branch: 449 | !(p1_1@215@01) | live]
; [else-branch: 449 | p1_1@215@01 | live]
(push) ; 9
; [then-branch: 449 | !(p1_1@215@01)]
(assert (not p1_1@215@01))
(pop) ; 9
(push) ; 9
; [else-branch: 449 | p1_1@215@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or p1_1@215@01 (not p1_1@215@01)))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not (and p1_1@215@01 p2_1@216@01))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and p1_1@215@01 p2_1@216@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 450 | p1_1@215@01 && p2_1@216@01 | live]
; [else-branch: 450 | !(p1_1@215@01 && p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 450 | p1_1@215@01 && p2_1@216@01]
(assert (and p1_1@215@01 p2_1@216@01))
; [eval] int___eq__(x_0, x_0_0)
(push) ; 10
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 11
(assert (not (issubtype<Bool> (typeof<PyType> tmp1_22@244@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> tmp1_22@244@01) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 11
(assert (not (issubtype<Bool> (typeof<PyType> tmp2_22@245@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> tmp2_22@245@01) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) tmp1_22@244@01 tmp2_22@245@01))
(pop) ; 10
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> tmp1_22@244@01) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> tmp2_22@245@01) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) tmp1_22@244@01 tmp2_22@245@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  (and p1_1@215@01 p2_1@216@01)
  (and
    p1_1@215@01
    p2_1@216@01
    (issubtype<Bool> (typeof<PyType> tmp1_22@244@01) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> tmp2_22@245@01) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) tmp1_22@244@01 tmp2_22@245@01))))
(assert (and p1_1@215@01 p2_1@216@01))
(push) ; 8
(assert (not (=>
  (and p1_1@215@01 p2_1@216@01)
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) tmp1_22@244@01 tmp2_22@245@01))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_1@215@01 p2_1@216@01)
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) tmp1_22@244@01 tmp2_22@245@01)))
; [eval] p1 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 451 | p1_1@215@01 | live]
; [else-branch: 451 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 451 | p1_1@215@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 452 | p2_1@216@01 | live]
; [else-branch: 452 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 452 | p2_1@216@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1 ==> Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 453 | p1_1@215@01 | live]
; [else-branch: 453 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 453 | p1_1@215@01]
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1)
(push) ; 10
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162@217@01 1))
(pop) ; 10
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162@217@01 1))
(push) ; 10
; [then-branch: 454 | Measure$check(_, Nil, _cthread_162@217@01, 1) | live]
; [else-branch: 454 | !(Measure$check(_, Nil, _cthread_162@217@01, 1)) | live]
(push) ; 11
; [then-branch: 454 | Measure$check(_, Nil, _cthread_162@217@01, 1)]
(assert (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162@217@01 1))
(pop) ; 11
(push) ; 11
; [else-branch: 454 | !(Measure$check(_, Nil, _cthread_162@217@01, 1))]
(assert (not
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162@217@01 1)))
; [eval] perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_160)) == none
; [eval] perm(MustTerminate(_cthread_160))
(push) ; 12
; [then-branch: 455 | False | live]
; [else-branch: 455 | True | live]
(push) ; 13
; [then-branch: 455 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 455 | True]
; [eval] (forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false)
(push) ; 14
; [then-branch: 456 | False | live]
; [else-branch: 456 | True | live]
(push) ; 15
; [then-branch: 456 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 456 | True]
; [eval] (forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false)
(push) ; 16
; [then-branch: 457 | False | live]
; [else-branch: 457 | True | live]
(push) ; 17
; [then-branch: 457 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 457 | True]
; [eval] (forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false)
(push) ; 18
; [then-branch: 458 | False | live]
; [else-branch: 458 | True | live]
(push) ; 19
; [then-branch: 458 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 458 | True]
; [eval] (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false)
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162@217@01 1))
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162@217@01 1)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  p1_1@215@01
  (and
    (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162@217@01 1)
    (or
      (not
        (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162@217@01 1))
      (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162@217@01 1)))))
; [eval] p2 ==> Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 459 | p2_1@216@01 | live]
; [else-branch: 459 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 459 | p2_1@216@01]
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1)
(push) ; 10
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162_0@218@01 1))
(pop) ; 10
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162_0@218@01 1))
(push) ; 10
; [then-branch: 460 | Measure$check(_, Nil, _cthread_162_0@218@01, 1) | live]
; [else-branch: 460 | !(Measure$check(_, Nil, _cthread_162_0@218@01, 1)) | live]
(push) ; 11
; [then-branch: 460 | Measure$check(_, Nil, _cthread_162_0@218@01, 1)]
(assert (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162_0@218@01 1))
(pop) ; 11
(push) ; 11
; [else-branch: 460 | !(Measure$check(_, Nil, _cthread_162_0@218@01, 1))]
(assert (not
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162_0@218@01 1)))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none
; [eval] perm(MustTerminate_0(_cthread_160_0))
(push) ; 12
; [then-branch: 461 | False | live]
; [else-branch: 461 | True | live]
(push) ; 13
; [then-branch: 461 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 461 | True]
; [eval] (forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false)
(push) ; 14
; [then-branch: 462 | False | live]
; [else-branch: 462 | True | live]
(push) ; 15
; [then-branch: 462 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 462 | True]
; [eval] (forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false)
(push) ; 16
; [then-branch: 463 | False | live]
; [else-branch: 463 | True | live]
(push) ; 17
; [then-branch: 463 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 463 | True]
; [eval] (forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false)
(push) ; 18
; [then-branch: 464 | False | live]
; [else-branch: 464 | True | live]
(push) ; 19
; [then-branch: 464 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 464 | True]
; [eval] (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false)
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162_0@218@01 1))
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162_0@218@01 1)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  p2_1@216@01
  (and
    (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162_0@218@01 1)
    (or
      (not
        (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162_0@218@01 1))
      (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_162_0@218@01 1)))))
(declare-const _current_wait_level_160@246@01 $Perm)
(declare-const _current_wait_level_160_0@247@01 $Perm)
(declare-const $t@248@01 $Snap)
(assert (= $t@248@01 ($Snap.combine ($Snap.first $t@248@01) ($Snap.second $t@248@01))))
(assert (= ($Snap.first $t@248@01) $Snap.unit))
; [eval] p1 ==> (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 465 | p1_1@215@01 | live]
; [else-branch: 465 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 465 | p1_1@215@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 10
; [then-branch: 466 | False | live]
; [else-branch: 466 | True | live]
(push) ; 11
; [then-branch: 466 | False]
(assert false)
(pop) ; 11
(push) ; 11
; [else-branch: 466 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 12
; [then-branch: 467 | False | live]
; [else-branch: 467 | True | live]
(push) ; 13
; [then-branch: 467 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 467 | True]
; [eval] _residue_160 <= _current_wait_level_160
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=> p1_1@215@01 (<= _residue_162@221@01 _current_wait_level_160@246@01)))
(assert (=
  ($Snap.second $t@248@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@248@01))
    ($Snap.second ($Snap.second $t@248@01)))))
(assert (= ($Snap.first ($Snap.second $t@248@01)) $Snap.unit))
; [eval] p2 ==> (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 468 | p2_1@216@01 | live]
; [else-branch: 468 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 468 | p2_1@216@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 10
; [then-branch: 469 | False | live]
; [else-branch: 469 | True | live]
(push) ; 11
; [then-branch: 469 | False]
(assert false)
(pop) ; 11
(push) ; 11
; [else-branch: 469 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 12
; [then-branch: 470 | False | live]
; [else-branch: 470 | True | live]
(push) ; 13
; [then-branch: 470 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 470 | True]
; [eval] _residue_160_0 <= _current_wait_level_160_0
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=> p2_1@216@01 (<= _residue_162_0@222@01 _current_wait_level_160_0@247@01)))
(assert (=
  ($Snap.second ($Snap.second $t@248@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@248@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@248@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@248@01))) $Snap.unit))
; [eval] p1 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 471 | p1_1@215@01 | live]
; [else-branch: 471 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 471 | p1_1@215@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@248@01))) $Snap.unit))
; [eval] p2 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 472 | p2_1@216@01 | live]
; [else-branch: 472 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 472 | p2_1@216@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 473 | p1_1@215@01 | live]
; [else-branch: 473 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 473 | p1_1@215@01]
; [exec]
; _cwl_162 := tmp1_23
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 474 | p2_1@216@01 | live]
; [else-branch: 474 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 474 | p2_1@216@01]
; [exec]
; _cwl_162_0 := tmp2_23
; [exec]
; assert true
; [eval] p1_1 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 475 | p1_1@215@01 | live]
; [else-branch: 475 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 475 | p1_1@215@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_1 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 476 | p2_1@216@01 | live]
; [else-branch: 476 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 476 | p2_1@216@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_1 ==> (forperm _r_7: Ref [MustInvokeBounded(_r_7)] :: false) && ((forperm _r_7: Ref [MustInvokeUnbounded(_r_7)] :: false) && ((forperm _r_7: Ref [_r_7.MustReleaseBounded] :: false) && (forperm _r_7: Ref [_r_7.MustReleaseUnbounded] :: false)))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_1@215@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 477 | p1_1@215@01 | live]
; [else-branch: 477 | !(p1_1@215@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 477 | p1_1@215@01]
; [eval] (forperm _r_7: Ref [MustInvokeBounded(_r_7)] :: false) && ((forperm _r_7: Ref [MustInvokeUnbounded(_r_7)] :: false) && ((forperm _r_7: Ref [_r_7.MustReleaseBounded] :: false) && (forperm _r_7: Ref [_r_7.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_7: Ref [MustInvokeBounded(_r_7)] :: false)
(push) ; 12
; [then-branch: 478 | False | live]
; [else-branch: 478 | True | live]
(push) ; 13
; [then-branch: 478 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 478 | True]
; [eval] (forperm _r_7: Ref [MustInvokeUnbounded(_r_7)] :: false)
(push) ; 14
; [then-branch: 479 | False | live]
; [else-branch: 479 | True | live]
(push) ; 15
; [then-branch: 479 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 479 | True]
; [eval] (forperm _r_7: Ref [_r_7.MustReleaseBounded] :: false)
(push) ; 16
; [then-branch: 480 | False | live]
; [else-branch: 480 | True | live]
(push) ; 17
; [then-branch: 480 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 480 | True]
; [eval] (forperm _r_7: Ref [_r_7.MustReleaseUnbounded] :: false)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_1 ==> (forperm _r_7: Ref [MustInvokeBounded_0(_r_7)] :: false) && ((forperm _r_7: Ref [MustInvokeUnbounded_0(_r_7)] :: false) && ((forperm _r_7: Ref [_r_7.MustReleaseBoundedp] :: false) && (forperm _r_7: Ref [_r_7.MustReleaseUnboundedp] :: false)))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_1@216@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 481 | p2_1@216@01 | live]
; [else-branch: 481 | !(p2_1@216@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 481 | p2_1@216@01]
; [eval] (forperm _r_7: Ref [MustInvokeBounded_0(_r_7)] :: false) && ((forperm _r_7: Ref [MustInvokeUnbounded_0(_r_7)] :: false) && ((forperm _r_7: Ref [_r_7.MustReleaseBoundedp] :: false) && (forperm _r_7: Ref [_r_7.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_7: Ref [MustInvokeBounded_0(_r_7)] :: false)
(push) ; 12
; [then-branch: 482 | False | live]
; [else-branch: 482 | True | live]
(push) ; 13
; [then-branch: 482 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 482 | True]
; [eval] (forperm _r_7: Ref [MustInvokeUnbounded_0(_r_7)] :: false)
(push) ; 14
; [then-branch: 483 | False | live]
; [else-branch: 483 | True | live]
(push) ; 15
; [then-branch: 483 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 483 | True]
; [eval] (forperm _r_7: Ref [_r_7.MustReleaseBoundedp] :: false)
(push) ; 16
; [then-branch: 484 | False | live]
; [else-branch: 484 | True | live]
(push) ; 17
; [then-branch: 484 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 484 | True]
; [eval] (forperm _r_7: Ref [_r_7.MustReleaseUnboundedp] :: false)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(pop) ; 9
; [eval] !p2_1
; [then-branch: 485 | !(p2_1@216@01) | dead]
; [else-branch: 485 | p2_1@216@01 | live]
(push) ; 9
; [else-branch: 485 | p2_1@216@01]
(pop) ; 9
(pop) ; 8
; [eval] !p1_1
; [then-branch: 486 | !(p1_1@215@01) | dead]
; [else-branch: 486 | p1_1@215@01 | live]
(push) ; 8
; [else-branch: 486 | p1_1@215@01]
(pop) ; 8
(pop) ; 7
; [eval] !p2_1
(push) ; 7
(set-option :timeout 10)
(assert (not p2_1@216@01))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 487 | !(p2_1@216@01) | dead]
; [else-branch: 487 | p2_1@216@01 | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 487 | p2_1@216@01]
(assert p2_1@216@01)
(pop) ; 7
(pop) ; 6
; [eval] !p1_1
(push) ; 6
(set-option :timeout 10)
(assert (not p1_1@215@01))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 488 | !(p1_1@215@01) | dead]
; [else-branch: 488 | p1_1@215@01 | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 488 | p1_1@215@01]
(assert p1_1@215@01)
(pop) ; 6
(pop) ; 5
; [eval] !(p1_1 || p2_1)
; [eval] p1_1 || p2_1
(push) ; 5
; [then-branch: 489 | p1_1@215@01 | live]
; [else-branch: 489 | !(p1_1@215@01) | live]
(push) ; 6
; [then-branch: 489 | p1_1@215@01]
(assert p1_1@215@01)
(pop) ; 6
(push) ; 6
; [else-branch: 489 | !(p1_1@215@01)]
(assert (not p1_1@215@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (or p1_1@215@01 p2_1@216@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 490 | !(p1_1@215@01 || p2_1@216@01) | dead]
; [else-branch: 490 | p1_1@215@01 || p2_1@216@01 | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 490 | p1_1@215@01 || p2_1@216@01]
(assert (or p1_1@215@01 p2_1@216@01))
(pop) ; 5
(pop) ; 4
; [eval] !p2_1
(push) ; 4
(set-option :timeout 10)
(assert (not p2_1@216@01))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 491 | !(p2_1@216@01) | dead]
; [else-branch: 491 | p2_1@216@01 | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 491 | p2_1@216@01]
(assert p2_1@216@01)
(pop) ; 4
(pop) ; 3
; [eval] !p1_1
(push) ; 3
(set-option :timeout 10)
(assert (not p1_1@215@01))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 492 | !(p1_1@215@01) | dead]
; [else-branch: 492 | p1_1@215@01 | live]
(set-option :timeout 0)
(push) ; 3
; [else-branch: 492 | p1_1@215@01]
(assert p1_1@215@01)
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- printOne ----------
(declare-const p1_2@249@01 Bool)
(declare-const p2_2@250@01 Bool)
(declare-const _cthread_163@251@01 $Ref)
(declare-const _cthread_163_0@252@01 $Ref)
(declare-const _caller_measures_163@253@01 Seq<Measure$>)
(declare-const _caller_measures_163_0@254@01 Seq<Measure$>)
(declare-const _residue_163@255@01 $Perm)
(declare-const _residue_163_0@256@01 $Perm)
(declare-const _current_wait_level_163@257@01 $Perm)
(declare-const _current_wait_level_163_0@258@01 $Perm)
(declare-const p1_2@259@01 Bool)
(declare-const p2_2@260@01 Bool)
(declare-const _cthread_163@261@01 $Ref)
(declare-const _cthread_163_0@262@01 $Ref)
(declare-const _caller_measures_163@263@01 Seq<Measure$>)
(declare-const _caller_measures_163_0@264@01 Seq<Measure$>)
(declare-const _residue_163@265@01 $Perm)
(declare-const _residue_163_0@266@01 $Perm)
(declare-const _current_wait_level_163@267@01 $Perm)
(declare-const _current_wait_level_163_0@268@01 $Perm)
(push) ; 1
(declare-const $t@269@01 $Snap)
(assert (= $t@269@01 ($Snap.combine ($Snap.first $t@269@01) ($Snap.second $t@269@01))))
(assert (= ($Snap.first $t@269@01) $Snap.unit))
; [eval] p1_2 ==> _cthread_163 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_2@259@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 493 | p1_2@259@01 | live]
; [else-branch: 493 | !(p1_2@259@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 493 | p1_2@259@01]
(assert p1_2@259@01)
; [eval] _cthread_163 != null
(pop) ; 3
(push) ; 3
; [else-branch: 493 | !(p1_2@259@01)]
(assert (not p1_2@259@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_2@259@01) p1_2@259@01))
(assert (=> p1_2@259@01 (not (= _cthread_163@261@01 $Ref.null))))
(assert (=
  ($Snap.second $t@269@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@269@01))
    ($Snap.second ($Snap.second $t@269@01)))))
(assert (= ($Snap.first ($Snap.second $t@269@01)) $Snap.unit))
; [eval] p2_2 ==> _cthread_163_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_2@260@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 494 | p2_2@260@01 | live]
; [else-branch: 494 | !(p2_2@260@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 494 | p2_2@260@01]
(assert p2_2@260@01)
; [eval] _cthread_163_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 494 | !(p2_2@260@01)]
(assert (not p2_2@260@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_2@260@01) p2_2@260@01))
(assert (=> p2_2@260@01 (not (= _cthread_163_0@262@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@269@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@269@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@269@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@269@01))) $Snap.unit))
; [eval] p1_2 ==> issubtype(typeof(_cthread_163), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_2@259@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 495 | p1_2@259@01 | live]
; [else-branch: 495 | !(p1_2@259@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 495 | p1_2@259@01]
(assert p1_2@259@01)
; [eval] issubtype(typeof(_cthread_163), Thread_0())
; [eval] typeof(_cthread_163)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 495 | !(p1_2@259@01)]
(assert (not p1_2@259@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_2@259@01
  (issubtype<Bool> (typeof<PyType> _cthread_163@261@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@269@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@269@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@269@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@269@01))))
  $Snap.unit))
; [eval] p2_2 ==> issubtype(typeof(_cthread_163_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_2@260@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 496 | p2_2@260@01 | live]
; [else-branch: 496 | !(p2_2@260@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 496 | p2_2@260@01]
(assert p2_2@260@01)
; [eval] issubtype(typeof(_cthread_163_0), Thread_0())
; [eval] typeof(_cthread_163_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 496 | !(p2_2@260@01)]
(assert (not p2_2@260@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_2@260@01
  (issubtype<Bool> (typeof<PyType> _cthread_163_0@262@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@269@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@269@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@269@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@269@01)))))
  $Snap.unit))
; [eval] p1_2 == p2_2
(assert (= p1_2@259@01 p2_2@260@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@269@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@269@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@269@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@269@01))))))
  $Snap.unit))
; [eval] p1_2 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_2@259@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 497 | p1_2@259@01 | live]
; [else-branch: 497 | !(p1_2@259@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 497 | p1_2@259@01]
(assert p1_2@259@01)
(pop) ; 3
(push) ; 3
; [else-branch: 497 | !(p1_2@259@01)]
(assert (not p1_2@259@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@269@01))))))
  $Snap.unit))
; [eval] p2_2 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_2@260@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 498 | p2_2@260@01 | live]
; [else-branch: 498 | !(p2_2@260@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 498 | p2_2@260@01]
(assert p2_2@260@01)
(pop) ; 3
(push) ; 3
; [else-branch: 498 | !(p2_2@260@01)]
(assert (not p2_2@260@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@270@01 $Snap)
(assert (= $t@270@01 ($Snap.combine ($Snap.first $t@270@01) ($Snap.second $t@270@01))))
(assert (= ($Snap.first $t@270@01) $Snap.unit))
; [eval] p1_2 ==> (forperm _r_9: Ref [_r_9.MustReleaseBounded] :: Level(_r_9) <= _current_wait_level_163) && ((forperm _r_9: Ref [_r_9.MustReleaseUnbounded] :: Level(_r_9) <= _current_wait_level_163) && _residue_163 <= _current_wait_level_163)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_2@259@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 499 | p1_2@259@01 | live]
; [else-branch: 499 | !(p1_2@259@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 499 | p1_2@259@01]
(assert p1_2@259@01)
; [eval] (forperm _r_9: Ref [_r_9.MustReleaseBounded] :: Level(_r_9) <= _current_wait_level_163) && ((forperm _r_9: Ref [_r_9.MustReleaseUnbounded] :: Level(_r_9) <= _current_wait_level_163) && _residue_163 <= _current_wait_level_163)
; [eval] (forperm _r_9: Ref [_r_9.MustReleaseBounded] :: Level(_r_9) <= _current_wait_level_163)
(push) ; 5
; [then-branch: 500 | False | live]
; [else-branch: 500 | True | live]
(push) ; 6
; [then-branch: 500 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 500 | True]
; [eval] (forperm _r_9: Ref [_r_9.MustReleaseUnbounded] :: Level(_r_9) <= _current_wait_level_163)
(push) ; 7
; [then-branch: 501 | False | live]
; [else-branch: 501 | True | live]
(push) ; 8
; [then-branch: 501 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 501 | True]
; [eval] _residue_163 <= _current_wait_level_163
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 499 | !(p1_2@259@01)]
(assert (not p1_2@259@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p1_2@259@01 (<= _residue_163@265@01 _current_wait_level_163@267@01)))
(assert (=
  ($Snap.second $t@270@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@270@01))
    ($Snap.second ($Snap.second $t@270@01)))))
(assert (= ($Snap.first ($Snap.second $t@270@01)) $Snap.unit))
; [eval] p2_2 ==> (forperm _r_9: Ref [_r_9.MustReleaseBoundedp] :: Level(_r_9) <= _current_wait_level_163_0) && ((forperm _r_9: Ref [_r_9.MustReleaseUnboundedp] :: Level(_r_9) <= _current_wait_level_163_0) && _residue_163_0 <= _current_wait_level_163_0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_2@260@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 502 | p2_2@260@01 | live]
; [else-branch: 502 | !(p2_2@260@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 502 | p2_2@260@01]
(assert p2_2@260@01)
; [eval] (forperm _r_9: Ref [_r_9.MustReleaseBoundedp] :: Level(_r_9) <= _current_wait_level_163_0) && ((forperm _r_9: Ref [_r_9.MustReleaseUnboundedp] :: Level(_r_9) <= _current_wait_level_163_0) && _residue_163_0 <= _current_wait_level_163_0)
; [eval] (forperm _r_9: Ref [_r_9.MustReleaseBoundedp] :: Level(_r_9) <= _current_wait_level_163_0)
(push) ; 5
; [then-branch: 503 | False | live]
; [else-branch: 503 | True | live]
(push) ; 6
; [then-branch: 503 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 503 | True]
; [eval] (forperm _r_9: Ref [_r_9.MustReleaseUnboundedp] :: Level(_r_9) <= _current_wait_level_163_0)
(push) ; 7
; [then-branch: 504 | False | live]
; [else-branch: 504 | True | live]
(push) ; 8
; [then-branch: 504 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 504 | True]
; [eval] _residue_163_0 <= _current_wait_level_163_0
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 502 | !(p2_2@260@01)]
(assert (not p2_2@260@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p2_2@260@01 (<= _residue_163_0@266@01 _current_wait_level_163_0@268@01)))
(assert (=
  ($Snap.second ($Snap.second $t@270@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@270@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@270@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@270@01))) $Snap.unit))
; [eval] p1_2 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_2@259@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 505 | p1_2@259@01 | live]
; [else-branch: 505 | !(p1_2@259@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 505 | p1_2@259@01]
(assert p1_2@259@01)
(pop) ; 4
(push) ; 4
; [else-branch: 505 | !(p1_2@259@01)]
(assert (not p1_2@259@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@270@01))) $Snap.unit))
; [eval] p2_2 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_2@260@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 506 | p2_2@260@01 | live]
; [else-branch: 506 | !(p2_2@260@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 506 | p2_2@260@01]
(assert p2_2@260@01)
(pop) ; 4
(push) ; 4
; [else-branch: 506 | !(p2_2@260@01)]
(assert (not p2_2@260@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
(push) ; 2
; [exec]
; var _err: Ref
(declare-const _err@271@01 $Ref)
; [exec]
; var _err_3: Ref
(declare-const _err_3@272@01 $Ref)
; [exec]
; var _cwl_163: Perm
(declare-const _cwl_163@273@01 $Perm)
; [exec]
; var _cwl_163_0: Perm
(declare-const _cwl_163_0@274@01 $Perm)
; [exec]
; var _method_measures_163: Seq[Measure$]
(declare-const _method_measures_163@275@01 Seq<Measure$>)
; [exec]
; var _method_measures_163_0: Seq[Measure$]
(declare-const _method_measures_163_0@276@01 Seq<Measure$>)
; [exec]
; inhale p1_2
(declare-const $t@277@01 $Snap)
(assert (= $t@277@01 $Snap.unit))
(assert p1_2@259@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 507 | p1_2@259@01 | live]
; [else-branch: 507 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 507 | p1_2@259@01]
; [exec]
; _method_measures_163 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err := null
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_2@260@01))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 508 | p2_2@260@01 | live]
; [else-branch: 508 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 508 | p2_2@260@01]
(assert p2_2@260@01)
; [exec]
; _method_measures_163_0 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err_3 := null
; [eval] p1_2 || p2_2
(push) ; 5
; [then-branch: 509 | p1_2@259@01 | live]
; [else-branch: 509 | !(p1_2@259@01) | live]
(push) ; 6
; [then-branch: 509 | p1_2@259@01]
(pop) ; 6
(push) ; 6
; [else-branch: 509 | !(p1_2@259@01)]
(assert (not p1_2@259@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (not (or p1_2@259@01 p2_2@260@01))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (or p1_2@259@01 p2_2@260@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 510 | p1_2@259@01 || p2_2@260@01 | live]
; [else-branch: 510 | !(p1_2@259@01 || p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 510 | p1_2@259@01 || p2_2@260@01]
(assert (or p1_2@259@01 p2_2@260@01))
; [exec]
; var tmp1_24: Ref
(declare-const tmp1_24@278@01 $Ref)
; [exec]
; var tmp2_24: Ref
(declare-const tmp2_24@279@01 $Ref)
; [exec]
; var tmp1_25: Seq[Measure$]
(declare-const tmp1_25@280@01 Seq<Measure$>)
; [exec]
; var tmp2_25: Seq[Measure$]
(declare-const tmp2_25@281@01 Seq<Measure$>)
; [exec]
; var tmp1_26: Perm
(declare-const tmp1_26@282@01 $Perm)
; [exec]
; var tmp2_26: Perm
(declare-const tmp2_26@283@01 $Perm)
; [exec]
; var tmp1_27: Ref
(declare-const tmp1_27@284@01 $Ref)
; [exec]
; var tmp2_27: Ref
(declare-const tmp2_27@285@01 $Ref)
; [exec]
; var tmp1_28: Perm
(declare-const tmp1_28@286@01 $Perm)
; [exec]
; var tmp2_28: Perm
(declare-const tmp2_28@287@01 $Perm)
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 511 | p1_2@259@01 | live]
; [else-branch: 511 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 511 | p1_2@259@01]
; [exec]
; tmp1_24 := _cthread_163
; [exec]
; tmp1_25 := _method_measures_163
; [exec]
; tmp1_26 := _residue_163
; [exec]
; tmp1_27 := __prim__int___box__(1)
; [eval] __prim__int___box__(1)
(push) ; 7
(assert (__prim__int___box__%precondition $Snap.unit 1))
(pop) ; 7
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 1))
(declare-const tmp1_27@288@01 $Ref)
(assert (= tmp1_27@288@01 (__prim__int___box__ $Snap.unit 1)))
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 512 | p2_2@260@01 | live]
; [else-branch: 512 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 512 | p2_2@260@01]
; [exec]
; tmp2_24 := _cthread_163_0
; [exec]
; tmp2_25 := _method_measures_163_0
; [exec]
; tmp2_26 := _residue_163_0
; [exec]
; tmp2_27 := __prim__int___box__(1)
; [eval] __prim__int___box__(1)
(push) ; 8
(pop) ; 8
; Joined path conditions
(declare-const tmp2_27@289@01 $Ref)
(assert (= tmp2_27@289@01 (__prim__int___box__ $Snap.unit 1)))
; [exec]
; tmp1_28, tmp2_28 := sif_print(p1_2, p2_2, tmp1_24, tmp2_24, tmp1_25, tmp2_25,
;   tmp1_26, tmp2_26, tmp1_27, tmp2_27)
; [eval] p1 ==> _cthread_160 != null
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 513 | p1_2@259@01 | live]
; [else-branch: 513 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 513 | p1_2@259@01]
; [eval] _cthread_160 != null
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2 ==> _cthread_160_0 != null
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 514 | p2_2@260@01 | live]
; [else-branch: 514 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 514 | p2_2@260@01]
; [eval] _cthread_160_0 != null
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(_cthread_160), Thread_0())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 515 | p1_2@259@01 | live]
; [else-branch: 515 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 515 | p1_2@259@01]
; [eval] issubtype(typeof(_cthread_160), Thread_0())
; [eval] typeof(_cthread_160)
; [eval] Thread_0()
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2 ==> issubtype(typeof(_cthread_160_0), Thread_0())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 516 | p2_2@260@01 | live]
; [else-branch: 516 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 516 | p2_2@260@01]
; [eval] issubtype(typeof(_cthread_160_0), Thread_0())
; [eval] typeof(_cthread_160_0)
; [eval] Thread_0()
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1 ==> issubtype(typeof(x_0), int())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 517 | p1_2@259@01 | live]
; [else-branch: 517 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 517 | p1_2@259@01]
; [eval] issubtype(typeof(x_0), int())
; [eval] typeof(x_0)
; [eval] int()
(pop) ; 9
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (=>
  p1_2@259@01
  (issubtype<Bool> (typeof<PyType> tmp1_27@288@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_2@259@01
  (issubtype<Bool> (typeof<PyType> tmp1_27@288@01) (as int<PyType>  PyType))))
; [eval] p2 ==> issubtype(typeof(x_0_0), int())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 518 | p2_2@260@01 | live]
; [else-branch: 518 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 518 | p2_2@260@01]
; [eval] issubtype(typeof(x_0_0), int())
; [eval] typeof(x_0_0)
; [eval] int()
(pop) ; 9
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (=>
  p2_2@260@01
  (issubtype<Bool> (typeof<PyType> tmp2_27@289@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_2@260@01
  (issubtype<Bool> (typeof<PyType> tmp2_27@289@01) (as int<PyType>  PyType))))
; [eval] p1 == p2
; [eval] p1 && p2 ==> int___eq__(x_0, x_0_0)
; [eval] p1 && p2
(push) ; 8
; [then-branch: 519 | !(p1_2@259@01) | live]
; [else-branch: 519 | p1_2@259@01 | live]
(push) ; 9
; [then-branch: 519 | !(p1_2@259@01)]
(assert (not p1_2@259@01))
(pop) ; 9
(push) ; 9
; [else-branch: 519 | p1_2@259@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or p1_2@259@01 (not p1_2@259@01)))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not (and p1_2@259@01 p2_2@260@01))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and p1_2@259@01 p2_2@260@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 520 | p1_2@259@01 && p2_2@260@01 | live]
; [else-branch: 520 | !(p1_2@259@01 && p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 520 | p1_2@259@01 && p2_2@260@01]
(assert (and p1_2@259@01 p2_2@260@01))
; [eval] int___eq__(x_0, x_0_0)
(push) ; 10
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 11
(assert (not (issubtype<Bool> (typeof<PyType> tmp1_27@288@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> tmp1_27@288@01) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 11
(assert (not (issubtype<Bool> (typeof<PyType> tmp2_27@289@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> tmp2_27@289@01) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) tmp1_27@288@01 tmp2_27@289@01))
(pop) ; 10
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> tmp1_27@288@01) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> tmp2_27@289@01) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) tmp1_27@288@01 tmp2_27@289@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  (and p1_2@259@01 p2_2@260@01)
  (and
    p1_2@259@01
    p2_2@260@01
    (issubtype<Bool> (typeof<PyType> tmp1_27@288@01) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> tmp2_27@289@01) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) tmp1_27@288@01 tmp2_27@289@01))))
(assert (and p1_2@259@01 p2_2@260@01))
(push) ; 8
(assert (not (=>
  (and p1_2@259@01 p2_2@260@01)
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) tmp1_27@288@01 tmp2_27@289@01))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_2@259@01 p2_2@260@01)
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) tmp1_27@288@01 tmp2_27@289@01)))
; [eval] p1 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 521 | p1_2@259@01 | live]
; [else-branch: 521 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 521 | p1_2@259@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 522 | p2_2@260@01 | live]
; [else-branch: 522 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 522 | p2_2@260@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1 ==> Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 523 | p1_2@259@01 | live]
; [else-branch: 523 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 523 | p1_2@259@01]
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1) || perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_160, _cthread_160, 1)
(push) ; 10
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163@261@01 1))
(pop) ; 10
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163@261@01 1))
(push) ; 10
; [then-branch: 524 | Measure$check(_, Nil, _cthread_163@261@01, 1) | live]
; [else-branch: 524 | !(Measure$check(_, Nil, _cthread_163@261@01, 1)) | live]
(push) ; 11
; [then-branch: 524 | Measure$check(_, Nil, _cthread_163@261@01, 1)]
(assert (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163@261@01 1))
(pop) ; 11
(push) ; 11
; [else-branch: 524 | !(Measure$check(_, Nil, _cthread_163@261@01, 1))]
(assert (not
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163@261@01 1)))
; [eval] perm(MustTerminate(_cthread_160)) == none && ((forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_160)) == none
; [eval] perm(MustTerminate(_cthread_160))
(push) ; 12
; [then-branch: 525 | False | live]
; [else-branch: 525 | True | live]
(push) ; 13
; [then-branch: 525 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 525 | True]
; [eval] (forperm _r_1: Ref [MustInvokeBounded(_r_1)] :: false)
(push) ; 14
; [then-branch: 526 | False | live]
; [else-branch: 526 | True | live]
(push) ; 15
; [then-branch: 526 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 526 | True]
; [eval] (forperm _r_1: Ref [MustInvokeUnbounded(_r_1)] :: false)
(push) ; 16
; [then-branch: 527 | False | live]
; [else-branch: 527 | True | live]
(push) ; 17
; [then-branch: 527 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 527 | True]
; [eval] (forperm _r_1: Ref [_r_1.MustReleaseBounded] :: false)
(push) ; 18
; [then-branch: 528 | False | live]
; [else-branch: 528 | True | live]
(push) ; 19
; [then-branch: 528 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 528 | True]
; [eval] (forperm _r_1: Ref [_r_1.MustReleaseUnbounded] :: false)
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163@261@01 1))
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163@261@01 1)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  p1_2@259@01
  (and
    (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163@261@01 1)
    (or
      (not
        (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163@261@01 1))
      (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163@261@01 1)))))
; [eval] p2 ==> Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 529 | p2_2@260@01 | live]
; [else-branch: 529 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 529 | p2_2@260@01]
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1) || perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_160_0, _cthread_160_0, 1)
(push) ; 10
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163_0@262@01 1))
(pop) ; 10
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163_0@262@01 1))
(push) ; 10
; [then-branch: 530 | Measure$check(_, Nil, _cthread_163_0@262@01, 1) | live]
; [else-branch: 530 | !(Measure$check(_, Nil, _cthread_163_0@262@01, 1)) | live]
(push) ; 11
; [then-branch: 530 | Measure$check(_, Nil, _cthread_163_0@262@01, 1)]
(assert (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163_0@262@01 1))
(pop) ; 11
(push) ; 11
; [else-branch: 530 | !(Measure$check(_, Nil, _cthread_163_0@262@01, 1))]
(assert (not
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163_0@262@01 1)))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none && ((forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false) && ((forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false) && (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_160_0)) == none
; [eval] perm(MustTerminate_0(_cthread_160_0))
(push) ; 12
; [then-branch: 531 | False | live]
; [else-branch: 531 | True | live]
(push) ; 13
; [then-branch: 531 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 531 | True]
; [eval] (forperm _r_1: Ref [MustInvokeBounded_0(_r_1)] :: false)
(push) ; 14
; [then-branch: 532 | False | live]
; [else-branch: 532 | True | live]
(push) ; 15
; [then-branch: 532 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 532 | True]
; [eval] (forperm _r_1: Ref [MustInvokeUnbounded_0(_r_1)] :: false)
(push) ; 16
; [then-branch: 533 | False | live]
; [else-branch: 533 | True | live]
(push) ; 17
; [then-branch: 533 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 533 | True]
; [eval] (forperm _r_1: Ref [_r_1.MustReleaseBoundedp] :: false)
(push) ; 18
; [then-branch: 534 | False | live]
; [else-branch: 534 | True | live]
(push) ; 19
; [then-branch: 534 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 534 | True]
; [eval] (forperm _r_1: Ref [_r_1.MustReleaseUnboundedp] :: false)
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163_0@262@01 1))
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163_0@262@01 1)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  p2_2@260@01
  (and
    (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163_0@262@01 1)
    (or
      (not
        (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163_0@262@01 1))
      (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_163_0@262@01 1)))))
(declare-const _current_wait_level_160@290@01 $Perm)
(declare-const _current_wait_level_160_0@291@01 $Perm)
(declare-const $t@292@01 $Snap)
(assert (= $t@292@01 ($Snap.combine ($Snap.first $t@292@01) ($Snap.second $t@292@01))))
(assert (= ($Snap.first $t@292@01) $Snap.unit))
; [eval] p1 ==> (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 535 | p1_2@259@01 | live]
; [else-branch: 535 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 535 | p1_2@259@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160) && ((forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160) && _residue_160 <= _current_wait_level_160)
; [eval] (forperm _r: Ref [_r.MustReleaseBounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 10
; [then-branch: 536 | False | live]
; [else-branch: 536 | True | live]
(push) ; 11
; [then-branch: 536 | False]
(assert false)
(pop) ; 11
(push) ; 11
; [else-branch: 536 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnbounded] :: Level(_r) <= _current_wait_level_160)
(push) ; 12
; [then-branch: 537 | False | live]
; [else-branch: 537 | True | live]
(push) ; 13
; [then-branch: 537 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 537 | True]
; [eval] _residue_160 <= _current_wait_level_160
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=> p1_2@259@01 (<= _residue_163@265@01 _current_wait_level_160@290@01)))
(assert (=
  ($Snap.second $t@292@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@292@01))
    ($Snap.second ($Snap.second $t@292@01)))))
(assert (= ($Snap.first ($Snap.second $t@292@01)) $Snap.unit))
; [eval] p2 ==> (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 538 | p2_2@260@01 | live]
; [else-branch: 538 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 538 | p2_2@260@01]
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0) && ((forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0) && _residue_160_0 <= _current_wait_level_160_0)
; [eval] (forperm _r: Ref [_r.MustReleaseBoundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 10
; [then-branch: 539 | False | live]
; [else-branch: 539 | True | live]
(push) ; 11
; [then-branch: 539 | False]
(assert false)
(pop) ; 11
(push) ; 11
; [else-branch: 539 | True]
; [eval] (forperm _r: Ref [_r.MustReleaseUnboundedp] :: Level(_r) <= _current_wait_level_160_0)
(push) ; 12
; [then-branch: 540 | False | live]
; [else-branch: 540 | True | live]
(push) ; 13
; [then-branch: 540 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 540 | True]
; [eval] _residue_160_0 <= _current_wait_level_160_0
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=> p2_2@260@01 (<= _residue_163_0@266@01 _current_wait_level_160_0@291@01)))
(assert (=
  ($Snap.second ($Snap.second $t@292@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@292@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@292@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@292@01))) $Snap.unit))
; [eval] p1 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 541 | p1_2@259@01 | live]
; [else-branch: 541 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 541 | p1_2@259@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@292@01))) $Snap.unit))
; [eval] p2 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 542 | p2_2@260@01 | live]
; [else-branch: 542 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 542 | p2_2@260@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 543 | p1_2@259@01 | live]
; [else-branch: 543 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 543 | p1_2@259@01]
; [exec]
; _cwl_163 := tmp1_28
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 544 | p2_2@260@01 | live]
; [else-branch: 544 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 544 | p2_2@260@01]
; [exec]
; _cwl_163_0 := tmp2_28
; [exec]
; assert true
; [eval] p1_2 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 545 | p1_2@259@01 | live]
; [else-branch: 545 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 545 | p1_2@259@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_2 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 546 | p2_2@260@01 | live]
; [else-branch: 546 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 546 | p2_2@260@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_2 ==> (forperm _r_10: Ref [MustInvokeBounded(_r_10)] :: false) && ((forperm _r_10: Ref [MustInvokeUnbounded(_r_10)] :: false) && ((forperm _r_10: Ref [_r_10.MustReleaseBounded] :: false) && (forperm _r_10: Ref [_r_10.MustReleaseUnbounded] :: false)))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_2@259@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 547 | p1_2@259@01 | live]
; [else-branch: 547 | !(p1_2@259@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 547 | p1_2@259@01]
; [eval] (forperm _r_10: Ref [MustInvokeBounded(_r_10)] :: false) && ((forperm _r_10: Ref [MustInvokeUnbounded(_r_10)] :: false) && ((forperm _r_10: Ref [_r_10.MustReleaseBounded] :: false) && (forperm _r_10: Ref [_r_10.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_10: Ref [MustInvokeBounded(_r_10)] :: false)
(push) ; 12
; [then-branch: 548 | False | live]
; [else-branch: 548 | True | live]
(push) ; 13
; [then-branch: 548 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 548 | True]
; [eval] (forperm _r_10: Ref [MustInvokeUnbounded(_r_10)] :: false)
(push) ; 14
; [then-branch: 549 | False | live]
; [else-branch: 549 | True | live]
(push) ; 15
; [then-branch: 549 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 549 | True]
; [eval] (forperm _r_10: Ref [_r_10.MustReleaseBounded] :: false)
(push) ; 16
; [then-branch: 550 | False | live]
; [else-branch: 550 | True | live]
(push) ; 17
; [then-branch: 550 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 550 | True]
; [eval] (forperm _r_10: Ref [_r_10.MustReleaseUnbounded] :: false)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_2 ==> (forperm _r_10: Ref [MustInvokeBounded_0(_r_10)] :: false) && ((forperm _r_10: Ref [MustInvokeUnbounded_0(_r_10)] :: false) && ((forperm _r_10: Ref [_r_10.MustReleaseBoundedp] :: false) && (forperm _r_10: Ref [_r_10.MustReleaseUnboundedp] :: false)))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_2@260@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 551 | p2_2@260@01 | live]
; [else-branch: 551 | !(p2_2@260@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 551 | p2_2@260@01]
; [eval] (forperm _r_10: Ref [MustInvokeBounded_0(_r_10)] :: false) && ((forperm _r_10: Ref [MustInvokeUnbounded_0(_r_10)] :: false) && ((forperm _r_10: Ref [_r_10.MustReleaseBoundedp] :: false) && (forperm _r_10: Ref [_r_10.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_10: Ref [MustInvokeBounded_0(_r_10)] :: false)
(push) ; 12
; [then-branch: 552 | False | live]
; [else-branch: 552 | True | live]
(push) ; 13
; [then-branch: 552 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 552 | True]
; [eval] (forperm _r_10: Ref [MustInvokeUnbounded_0(_r_10)] :: false)
(push) ; 14
; [then-branch: 553 | False | live]
; [else-branch: 553 | True | live]
(push) ; 15
; [then-branch: 553 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 553 | True]
; [eval] (forperm _r_10: Ref [_r_10.MustReleaseBoundedp] :: false)
(push) ; 16
; [then-branch: 554 | False | live]
; [else-branch: 554 | True | live]
(push) ; 17
; [then-branch: 554 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 554 | True]
; [eval] (forperm _r_10: Ref [_r_10.MustReleaseUnboundedp] :: false)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(pop) ; 9
; [eval] !p2_2
; [then-branch: 555 | !(p2_2@260@01) | dead]
; [else-branch: 555 | p2_2@260@01 | live]
(push) ; 9
; [else-branch: 555 | p2_2@260@01]
(pop) ; 9
(pop) ; 8
; [eval] !p1_2
; [then-branch: 556 | !(p1_2@259@01) | dead]
; [else-branch: 556 | p1_2@259@01 | live]
(push) ; 8
; [else-branch: 556 | p1_2@259@01]
(pop) ; 8
(pop) ; 7
; [eval] !p2_2
(push) ; 7
(set-option :timeout 10)
(assert (not p2_2@260@01))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 557 | !(p2_2@260@01) | dead]
; [else-branch: 557 | p2_2@260@01 | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 557 | p2_2@260@01]
(assert p2_2@260@01)
(pop) ; 7
(pop) ; 6
; [eval] !p1_2
(push) ; 6
(set-option :timeout 10)
(assert (not p1_2@259@01))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 558 | !(p1_2@259@01) | dead]
; [else-branch: 558 | p1_2@259@01 | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 558 | p1_2@259@01]
(assert p1_2@259@01)
(pop) ; 6
(pop) ; 5
; [eval] !(p1_2 || p2_2)
; [eval] p1_2 || p2_2
(push) ; 5
; [then-branch: 559 | p1_2@259@01 | live]
; [else-branch: 559 | !(p1_2@259@01) | live]
(push) ; 6
; [then-branch: 559 | p1_2@259@01]
(assert p1_2@259@01)
(pop) ; 6
(push) ; 6
; [else-branch: 559 | !(p1_2@259@01)]
(assert (not p1_2@259@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (or p1_2@259@01 p2_2@260@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 560 | !(p1_2@259@01 || p2_2@260@01) | dead]
; [else-branch: 560 | p1_2@259@01 || p2_2@260@01 | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 560 | p1_2@259@01 || p2_2@260@01]
(assert (or p1_2@259@01 p2_2@260@01))
(pop) ; 5
(pop) ; 4
; [eval] !p2_2
(push) ; 4
(set-option :timeout 10)
(assert (not p2_2@260@01))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 561 | !(p2_2@260@01) | dead]
; [else-branch: 561 | p2_2@260@01 | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 561 | p2_2@260@01]
(assert p2_2@260@01)
(pop) ; 4
(pop) ; 3
; [eval] !p1_2
(push) ; 3
(set-option :timeout 10)
(assert (not p1_2@259@01))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 562 | !(p1_2@259@01) | dead]
; [else-branch: 562 | p1_2@259@01 | live]
(set-option :timeout 0)
(push) ; 3
; [else-branch: 562 | p1_2@259@01]
(assert p1_2@259@01)
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- zero ----------
(declare-const p1_3@293@01 Bool)
(declare-const p2_3@294@01 Bool)
(declare-const _cthread_164@295@01 $Ref)
(declare-const _cthread_164_0@296@01 $Ref)
(declare-const _caller_measures_164@297@01 Seq<Measure$>)
(declare-const _caller_measures_164_0@298@01 Seq<Measure$>)
(declare-const _residue_164@299@01 $Perm)
(declare-const _residue_164_0@300@01 $Perm)
(declare-const c@301@01 $Ref)
(declare-const c_4@302@01 $Ref)
(declare-const _current_wait_level_164@303@01 $Perm)
(declare-const _current_wait_level_164_0@304@01 $Perm)
(declare-const p1_3@305@01 Bool)
(declare-const p2_3@306@01 Bool)
(declare-const _cthread_164@307@01 $Ref)
(declare-const _cthread_164_0@308@01 $Ref)
(declare-const _caller_measures_164@309@01 Seq<Measure$>)
(declare-const _caller_measures_164_0@310@01 Seq<Measure$>)
(declare-const _residue_164@311@01 $Perm)
(declare-const _residue_164_0@312@01 $Perm)
(declare-const c@313@01 $Ref)
(declare-const c_4@314@01 $Ref)
(declare-const _current_wait_level_164@315@01 $Perm)
(declare-const _current_wait_level_164_0@316@01 $Perm)
(push) ; 1
(declare-const $t@317@01 $Snap)
(assert (= $t@317@01 ($Snap.combine ($Snap.first $t@317@01) ($Snap.second $t@317@01))))
(assert (= ($Snap.first $t@317@01) $Snap.unit))
; [eval] p1_3 ==> _cthread_164 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_3@305@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 563 | p1_3@305@01 | live]
; [else-branch: 563 | !(p1_3@305@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 563 | p1_3@305@01]
(assert p1_3@305@01)
; [eval] _cthread_164 != null
(pop) ; 3
(push) ; 3
; [else-branch: 563 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_3@305@01) p1_3@305@01))
(assert (=> p1_3@305@01 (not (= _cthread_164@307@01 $Ref.null))))
(assert (=
  ($Snap.second $t@317@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@317@01))
    ($Snap.second ($Snap.second $t@317@01)))))
(assert (= ($Snap.first ($Snap.second $t@317@01)) $Snap.unit))
; [eval] p2_3 ==> _cthread_164_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_3@306@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 564 | p2_3@306@01 | live]
; [else-branch: 564 | !(p2_3@306@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 564 | p2_3@306@01]
(assert p2_3@306@01)
; [eval] _cthread_164_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 564 | !(p2_3@306@01)]
(assert (not p2_3@306@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_3@306@01) p2_3@306@01))
(assert (=> p2_3@306@01 (not (= _cthread_164_0@308@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@317@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@317@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@317@01))) $Snap.unit))
; [eval] p1_3 ==> issubtype(typeof(_cthread_164), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_3@305@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 565 | p1_3@305@01 | live]
; [else-branch: 565 | !(p1_3@305@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 565 | p1_3@305@01]
(assert p1_3@305@01)
; [eval] issubtype(typeof(_cthread_164), Thread_0())
; [eval] typeof(_cthread_164)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 565 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_3@305@01
  (issubtype<Bool> (typeof<PyType> _cthread_164@307@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@317@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@317@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@317@01))))
  $Snap.unit))
; [eval] p2_3 ==> issubtype(typeof(_cthread_164_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_3@306@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 566 | p2_3@306@01 | live]
; [else-branch: 566 | !(p2_3@306@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 566 | p2_3@306@01]
(assert p2_3@306@01)
; [eval] issubtype(typeof(_cthread_164_0), Thread_0())
; [eval] typeof(_cthread_164_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 566 | !(p2_3@306@01)]
(assert (not p2_3@306@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_3@306@01
  (issubtype<Bool> (typeof<PyType> _cthread_164_0@308@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))
  $Snap.unit))
; [eval] p1_3 ==> issubtype(typeof(c), Cell())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_3@305@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 567 | p1_3@305@01 | live]
; [else-branch: 567 | !(p1_3@305@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 567 | p1_3@305@01]
(assert p1_3@305@01)
; [eval] issubtype(typeof(c), Cell())
; [eval] typeof(c)
; [eval] Cell()
(pop) ; 3
(push) ; 3
; [else-branch: 567 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_3@305@01
  (issubtype<Bool> (typeof<PyType> c@313@01) (as Cell<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))
  $Snap.unit))
; [eval] p2_3 ==> issubtype(typeof(c_4), Cell())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_3@306@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 568 | p2_3@306@01 | live]
; [else-branch: 568 | !(p2_3@306@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 568 | p2_3@306@01]
(assert p2_3@306@01)
; [eval] issubtype(typeof(c_4), Cell())
; [eval] typeof(c_4)
; [eval] Cell()
(pop) ; 3
(push) ; 3
; [else-branch: 568 | !(p2_3@306@01)]
(assert (not p2_3@306@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_3@306@01
  (issubtype<Bool> (typeof<PyType> c_4@314@01) (as Cell<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
(push) ; 2
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 2
(set-option :timeout 10)
(assert (not p1_3@305@01))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; [then-branch: 569 | p1_3@305@01 | live]
; [else-branch: 569 | !(p1_3@305@01) | live]
(set-option :timeout 0)
(push) ; 2
; [then-branch: 569 | p1_3@305@01]
(assert p1_3@305@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_3@306@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 570 | p2_3@306@01 | live]
; [else-branch: 570 | !(p2_3@306@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 570 | p2_3@306@01]
(assert p2_3@306@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 571 | p1_3@305@01 | live]
; [else-branch: 571 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 571 | p1_3@305@01]
(assert (not (= c@313@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 572 | p2_3@306@01 | live]
; [else-branch: 572 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 572 | p2_3@306@01]
(assert (not (= c_4@314@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
  $Snap.unit))
; [eval] p1_3 ==> issubtype(typeof(c.Cell_val), int())
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 573 | p1_3@305@01 | live]
; [else-branch: 573 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 573 | p1_3@305@01]
; [eval] issubtype(typeof(c.Cell_val), int())
; [eval] typeof(c.Cell_val)
; [eval] int()
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  p1_3@305@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
  $Snap.unit))
; [eval] p2_3 ==> issubtype(typeof(c_4.Cell_valp), int())
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 574 | p2_3@306@01 | live]
; [else-branch: 574 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 574 | p2_3@306@01]
; [eval] issubtype(typeof(c_4.Cell_valp), int())
; [eval] typeof(c_4.Cell_valp)
; [eval] int()
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  p2_3@306@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
  $Snap.unit))
; [eval] p1_3 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 575 | p1_3@305@01 | live]
; [else-branch: 575 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 575 | p1_3@305@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
  $Snap.unit))
; [eval] p2_3 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 576 | p2_3@306@01 | live]
; [else-branch: 576 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 576 | p2_3@306@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@318@01 $Snap)
(assert (= $t@318@01 ($Snap.combine ($Snap.first $t@318@01) ($Snap.second $t@318@01))))
(assert (= ($Snap.first $t@318@01) $Snap.unit))
; [eval] p1_3 ==> (forperm _r_12: Ref [_r_12.MustReleaseBounded] :: Level(_r_12) <= _current_wait_level_164) && ((forperm _r_12: Ref [_r_12.MustReleaseUnbounded] :: Level(_r_12) <= _current_wait_level_164) && _residue_164 <= _current_wait_level_164)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 577 | p1_3@305@01 | live]
; [else-branch: 577 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 577 | p1_3@305@01]
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseBounded] :: Level(_r_12) <= _current_wait_level_164) && ((forperm _r_12: Ref [_r_12.MustReleaseUnbounded] :: Level(_r_12) <= _current_wait_level_164) && _residue_164 <= _current_wait_level_164)
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseBounded] :: Level(_r_12) <= _current_wait_level_164)
(push) ; 9
; [then-branch: 578 | False | live]
; [else-branch: 578 | True | live]
(push) ; 10
; [then-branch: 578 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 578 | True]
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseUnbounded] :: Level(_r_12) <= _current_wait_level_164)
(push) ; 11
; [then-branch: 579 | False | live]
; [else-branch: 579 | True | live]
(push) ; 12
; [then-branch: 579 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 579 | True]
; [eval] _residue_164 <= _current_wait_level_164
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p1_3@305@01 (<= _residue_164@311@01 _current_wait_level_164@315@01)))
(assert (=
  ($Snap.second $t@318@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@318@01))
    ($Snap.second ($Snap.second $t@318@01)))))
(assert (= ($Snap.first ($Snap.second $t@318@01)) $Snap.unit))
; [eval] p2_3 ==> (forperm _r_12: Ref [_r_12.MustReleaseBoundedp] :: Level(_r_12) <= _current_wait_level_164_0) && ((forperm _r_12: Ref [_r_12.MustReleaseUnboundedp] :: Level(_r_12) <= _current_wait_level_164_0) && _residue_164_0 <= _current_wait_level_164_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 580 | p2_3@306@01 | live]
; [else-branch: 580 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 580 | p2_3@306@01]
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseBoundedp] :: Level(_r_12) <= _current_wait_level_164_0) && ((forperm _r_12: Ref [_r_12.MustReleaseUnboundedp] :: Level(_r_12) <= _current_wait_level_164_0) && _residue_164_0 <= _current_wait_level_164_0)
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseBoundedp] :: Level(_r_12) <= _current_wait_level_164_0)
(push) ; 9
; [then-branch: 581 | False | live]
; [else-branch: 581 | True | live]
(push) ; 10
; [then-branch: 581 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 581 | True]
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseUnboundedp] :: Level(_r_12) <= _current_wait_level_164_0)
(push) ; 11
; [then-branch: 582 | False | live]
; [else-branch: 582 | True | live]
(push) ; 12
; [then-branch: 582 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 582 | True]
; [eval] _residue_164_0 <= _current_wait_level_164_0
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p2_3@306@01 (<= _residue_164_0@312@01 _current_wait_level_164_0@316@01)))
(assert (=
  ($Snap.second ($Snap.second $t@318@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@318@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@318@01))))))
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 583 | p1_3@305@01 | live]
; [else-branch: 583 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 583 | p1_3@305@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@318@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@318@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01)))))))
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 584 | p2_3@306@01 | live]
; [else-branch: 584 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 584 | p2_3@306@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01)))))
  $Snap.unit))
; [eval] p1_3 ==> issubtype(typeof(c.Cell_val), int())
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 585 | p1_3@305@01 | live]
; [else-branch: 585 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 585 | p1_3@305@01]
; [eval] issubtype(typeof(c.Cell_val), int())
; [eval] typeof(c.Cell_val)
; [eval] int()
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  p1_3@305@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@318@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01))))))
  $Snap.unit))
; [eval] p2_3 ==> issubtype(typeof(c_4.Cell_valp), int())
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 586 | p2_3@306@01 | live]
; [else-branch: 586 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 586 | p2_3@306@01]
; [eval] issubtype(typeof(c_4.Cell_valp), int())
; [eval] typeof(c_4.Cell_valp)
; [eval] int()
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  p2_3@306@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@318@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01)))))))
  $Snap.unit))
; [eval] p1_3 && p2_3 ==> c.Cell_val == c_4.Cell_valp
; [eval] p1_3 && p2_3
(push) ; 9
; [then-branch: 587 | !(p1_3@305@01) | live]
; [else-branch: 587 | p1_3@305@01 | live]
(push) ; 10
; [then-branch: 587 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 10
(push) ; 10
; [else-branch: 587 | p1_3@305@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_3@305@01 (not p1_3@305@01)))
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (and p1_3@305@01 p2_3@306@01))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (and p1_3@305@01 p2_3@306@01)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 588 | p1_3@305@01 && p2_3@306@01 | live]
; [else-branch: 588 | !(p1_3@305@01 && p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 588 | p1_3@305@01 && p2_3@306@01]
(assert (and p1_3@305@01 p2_3@306@01))
; [eval] c.Cell_val == c_4.Cell_valp
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (and p1_3@305@01 p2_3@306@01))
(assert (=>
  (and p1_3@305@01 p2_3@306@01)
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@318@01))))
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@318@01))))))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01))))))))
  $Snap.unit))
; [eval] p1_3 ==> true
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 589 | p1_3@305@01 | live]
; [else-branch: 589 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 589 | p1_3@305@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@318@01))))))))
  $Snap.unit))
; [eval] p2_3 ==> true
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 590 | p2_3@306@01 | live]
; [else-branch: 590 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 590 | p2_3@306@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
(pop) ; 6
(push) ; 6
; [exec]
; var _err: Ref
(declare-const _err@319@01 $Ref)
; [exec]
; var _err_4: Ref
(declare-const _err_4@320@01 $Ref)
; [exec]
; var c_2: Ref
(declare-const c_2@321@01 $Ref)
; [exec]
; var c_2_0: Ref
(declare-const c_2_0@322@01 $Ref)
; [exec]
; var _cwl_164: Perm
(declare-const _cwl_164@323@01 $Perm)
; [exec]
; var _cwl_164_0: Perm
(declare-const _cwl_164_0@324@01 $Perm)
; [exec]
; var _method_measures_164: Seq[Measure$]
(declare-const _method_measures_164@325@01 Seq<Measure$>)
; [exec]
; var _method_measures_164_0: Seq[Measure$]
(declare-const _method_measures_164_0@326@01 Seq<Measure$>)
; [exec]
; var p1_4: Bool
(declare-const p1_4@327@01 Bool)
; [exec]
; var p2_4: Bool
(declare-const p2_4@328@01 Bool)
; [exec]
; var p3: Bool
(declare-const p3@329@01 Bool)
; [exec]
; var p4: Bool
(declare-const p4@330@01 Bool)
; [exec]
; inhale p1_3
(declare-const $t@331@01 $Snap)
(assert (= $t@331@01 $Snap.unit))
(assert p1_3@305@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 591 | p1_3@305@01 | live]
; [else-branch: 591 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 591 | p1_3@305@01]
; [exec]
; _method_measures_164 := Seq(Measure$create(true, _cthread_164, 1))
; [eval] Seq(Measure$create(true, _cthread_164, 1))
; [eval] Measure$create(true, _cthread_164, 1)
(assert (=
  (Seq_length
    (Seq_singleton (Measure$create<Measure$> true _cthread_164@307@01 1)))
  1))
(declare-const _method_measures_164@332@01 Seq<Measure$>)
(assert (=
  _method_measures_164@332@01
  (Seq_singleton (Measure$create<Measure$> true _cthread_164@307@01 1))))
; [exec]
; _err := null
; [exec]
; c_2 := c
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not p2_3@306@01))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 592 | p2_3@306@01 | live]
; [else-branch: 592 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 592 | p2_3@306@01]
(assert p2_3@306@01)
; [exec]
; _method_measures_164_0 := Seq(Measure$create(true, _cthread_164_0, 1))
; [eval] Seq(Measure$create(true, _cthread_164_0, 1))
; [eval] Measure$create(true, _cthread_164_0, 1)
(assert (=
  (Seq_length
    (Seq_singleton (Measure$create<Measure$> true _cthread_164_0@308@01 1)))
  1))
(declare-const _method_measures_164_0@333@01 Seq<Measure$>)
(assert (=
  _method_measures_164_0@333@01
  (Seq_singleton (Measure$create<Measure$> true _cthread_164_0@308@01 1))))
; [exec]
; _err_4 := null
; [exec]
; c_2_0 := c_4
; [exec]
; p1_4 := p1_3 && perm(_MaySet(c_2, 7809653381050164547)) > none
; [eval] p1_3 && perm(_MaySet(c_2, 7809653381050164547)) > none
(push) ; 9
; [then-branch: 593 | !(p1_3@305@01) | live]
; [else-branch: 593 | p1_3@305@01 | live]
(push) ; 10
; [then-branch: 593 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 10
(push) ; 10
; [else-branch: 593 | p1_3@305@01]
; [eval] perm(_MaySet(c_2, 7809653381050164547)) > none
; [eval] perm(_MaySet(c_2, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_3@305@01 (not p1_3@305@01)))
; [exec]
; p2_4 := p2_3 && perm(_MaySet_0(c_2_0, 7809653381050164547)) > none
; [eval] p2_3 && perm(_MaySet_0(c_2_0, 7809653381050164547)) > none
(push) ; 9
; [then-branch: 594 | !(p2_3@306@01) | live]
; [else-branch: 594 | p2_3@306@01 | live]
(push) ; 10
; [then-branch: 594 | !(p2_3@306@01)]
(assert (not p2_3@306@01))
(pop) ; 10
(push) ; 10
; [else-branch: 594 | p2_3@306@01]
; [eval] perm(_MaySet_0(c_2_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(c_2_0, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p2_3@306@01 (not p2_3@306@01)))
; [exec]
; p3 := p1_3 && !(perm(_MaySet(c_2, 7809653381050164547)) > none)
; [eval] p1_3 && !(perm(_MaySet(c_2, 7809653381050164547)) > none)
(push) ; 9
; [then-branch: 595 | !(p1_3@305@01) | live]
; [else-branch: 595 | p1_3@305@01 | live]
(push) ; 10
; [then-branch: 595 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 10
(push) ; 10
; [else-branch: 595 | p1_3@305@01]
; [eval] !(perm(_MaySet(c_2, 7809653381050164547)) > none)
; [eval] perm(_MaySet(c_2, 7809653381050164547)) > none
; [eval] perm(_MaySet(c_2, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
; [exec]
; p4 := p2_3 && !(perm(_MaySet_0(c_2_0, 7809653381050164547)) > none)
; [eval] p2_3 && !(perm(_MaySet_0(c_2_0, 7809653381050164547)) > none)
(push) ; 9
; [then-branch: 596 | !(p2_3@306@01) | live]
; [else-branch: 596 | p2_3@306@01 | live]
(push) ; 10
; [then-branch: 596 | !(p2_3@306@01)]
(assert (not p2_3@306@01))
(pop) ; 10
(push) ; 10
; [else-branch: 596 | p2_3@306@01]
; [eval] !(perm(_MaySet_0(c_2_0, 7809653381050164547)) > none)
; [eval] perm(_MaySet_0(c_2_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(c_2_0, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
; [then-branch: 597 | False | dead]
; [else-branch: 597 | True | live]
(push) ; 9
; [else-branch: 597 | True]
(pop) ; 9
; [eval] !p1_4
(push) ; 9
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 598 | True | live]
; [else-branch: 598 | False | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 598 | True]
; [then-branch: 599 | False | dead]
; [else-branch: 599 | True | live]
(push) ; 10
; [else-branch: 599 | True]
(pop) ; 10
; [eval] !p2_4
(push) ; 10
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 600 | True | live]
; [else-branch: 600 | False | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 600 | True]
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 601 | p1_3@305@01 | live]
; [else-branch: 601 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 601 | p1_3@305@01]
; [exec]
; c_2.Cell_val := __prim__int___box__(0)
; [eval] __prim__int___box__(0)
(push) ; 12
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 12
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(declare-const Cell_val@334@01 $Ref)
(assert (= Cell_val@334@01 (__prim__int___box__ $Snap.unit 0)))
(push) ; 12
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 602 | p2_3@306@01 | live]
; [else-branch: 602 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 602 | p2_3@306@01]
; [exec]
; c_2_0.Cell_valp := __prim__int___box__(0)
; [eval] __prim__int___box__(0)
(push) ; 13
(pop) ; 13
; Joined path conditions
(declare-const Cell_valp@335@01 $Ref)
(assert (= Cell_valp@335@01 (__prim__int___box__ $Snap.unit 0)))
; [exec]
; assert true
; [eval] p1_3 ==> true
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 603 | p1_3@305@01 | live]
; [else-branch: 603 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 603 | p1_3@305@01]
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p2_3 ==> true
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 604 | p2_3@306@01 | live]
; [else-branch: 604 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 604 | p2_3@306@01]
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 605 | p1_3@305@01 | live]
; [else-branch: 605 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 605 | p1_3@305@01]
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 606 | p2_3@306@01 | live]
; [else-branch: 606 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 606 | p2_3@306@01]
; [eval] p1_3 ==> issubtype(typeof(c.Cell_val), int())
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 607 | p1_3@305@01 | live]
; [else-branch: 607 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 607 | p1_3@305@01]
; [eval] issubtype(typeof(c.Cell_val), int())
; [eval] typeof(c.Cell_val)
; [eval] int()
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (=>
  p1_3@305@01
  (issubtype<Bool> (typeof<PyType> Cell_val@334@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_3@305@01
  (issubtype<Bool> (typeof<PyType> Cell_val@334@01) (as int<PyType>  PyType))))
; [eval] p2_3 ==> issubtype(typeof(c_4.Cell_valp), int())
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 608 | p2_3@306@01 | live]
; [else-branch: 608 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 608 | p2_3@306@01]
; [eval] issubtype(typeof(c_4.Cell_valp), int())
; [eval] typeof(c_4.Cell_valp)
; [eval] int()
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (=>
  p2_3@306@01
  (issubtype<Bool> (typeof<PyType> Cell_valp@335@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_3@306@01
  (issubtype<Bool> (typeof<PyType> Cell_valp@335@01) (as int<PyType>  PyType))))
; [eval] p1_3 && p2_3 ==> c.Cell_val == c_4.Cell_valp
; [eval] p1_3 && p2_3
(push) ; 15
; [then-branch: 609 | !(p1_3@305@01) | live]
; [else-branch: 609 | p1_3@305@01 | live]
(push) ; 16
; [then-branch: 609 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 16
(push) ; 16
; [else-branch: 609 | p1_3@305@01]
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not (and p1_3@305@01 p2_3@306@01))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (and p1_3@305@01 p2_3@306@01)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 610 | p1_3@305@01 && p2_3@306@01 | live]
; [else-branch: 610 | !(p1_3@305@01 && p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 610 | p1_3@305@01 && p2_3@306@01]
(assert (and p1_3@305@01 p2_3@306@01))
; [eval] c.Cell_val == c_4.Cell_valp
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (and p1_3@305@01 p2_3@306@01))
(push) ; 15
(assert (not (=> (and p1_3@305@01 p2_3@306@01) (= Cell_val@334@01 Cell_valp@335@01))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=> (and p1_3@305@01 p2_3@306@01) (= Cell_val@334@01 Cell_valp@335@01)))
; [eval] p1_3 ==> (forperm _r_13: Ref [MustInvokeBounded(_r_13)] :: false) && ((forperm _r_13: Ref [MustInvokeUnbounded(_r_13)] :: false) && ((forperm _r_13: Ref [_r_13.MustReleaseBounded] :: false) && (forperm _r_13: Ref [_r_13.MustReleaseUnbounded] :: false)))
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 611 | p1_3@305@01 | live]
; [else-branch: 611 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 611 | p1_3@305@01]
; [eval] (forperm _r_13: Ref [MustInvokeBounded(_r_13)] :: false) && ((forperm _r_13: Ref [MustInvokeUnbounded(_r_13)] :: false) && ((forperm _r_13: Ref [_r_13.MustReleaseBounded] :: false) && (forperm _r_13: Ref [_r_13.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_13: Ref [MustInvokeBounded(_r_13)] :: false)
(push) ; 17
; [then-branch: 612 | False | live]
; [else-branch: 612 | True | live]
(push) ; 18
; [then-branch: 612 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 612 | True]
; [eval] (forperm _r_13: Ref [MustInvokeUnbounded(_r_13)] :: false)
(push) ; 19
; [then-branch: 613 | False | live]
; [else-branch: 613 | True | live]
(push) ; 20
; [then-branch: 613 | False]
(assert false)
(pop) ; 20
(push) ; 20
; [else-branch: 613 | True]
; [eval] (forperm _r_13: Ref [_r_13.MustReleaseBounded] :: false)
(push) ; 21
; [then-branch: 614 | False | live]
; [else-branch: 614 | True | live]
(push) ; 22
; [then-branch: 614 | False]
(assert false)
(pop) ; 22
(push) ; 22
; [else-branch: 614 | True]
; [eval] (forperm _r_13: Ref [_r_13.MustReleaseUnbounded] :: false)
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(pop) ; 15
; Joined path conditions
; [eval] p2_3 ==> (forperm _r_13: Ref [MustInvokeBounded_0(_r_13)] :: false) && ((forperm _r_13: Ref [MustInvokeUnbounded_0(_r_13)] :: false) && ((forperm _r_13: Ref [_r_13.MustReleaseBoundedp] :: false) && (forperm _r_13: Ref [_r_13.MustReleaseUnboundedp] :: false)))
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 615 | p2_3@306@01 | live]
; [else-branch: 615 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 615 | p2_3@306@01]
; [eval] (forperm _r_13: Ref [MustInvokeBounded_0(_r_13)] :: false) && ((forperm _r_13: Ref [MustInvokeUnbounded_0(_r_13)] :: false) && ((forperm _r_13: Ref [_r_13.MustReleaseBoundedp] :: false) && (forperm _r_13: Ref [_r_13.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_13: Ref [MustInvokeBounded_0(_r_13)] :: false)
(push) ; 17
; [then-branch: 616 | False | live]
; [else-branch: 616 | True | live]
(push) ; 18
; [then-branch: 616 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 616 | True]
; [eval] (forperm _r_13: Ref [MustInvokeUnbounded_0(_r_13)] :: false)
(push) ; 19
; [then-branch: 617 | False | live]
; [else-branch: 617 | True | live]
(push) ; 20
; [then-branch: 617 | False]
(assert false)
(pop) ; 20
(push) ; 20
; [else-branch: 617 | True]
; [eval] (forperm _r_13: Ref [_r_13.MustReleaseBoundedp] :: false)
(push) ; 21
; [then-branch: 618 | False | live]
; [else-branch: 618 | True | live]
(push) ; 22
; [then-branch: 618 | False]
(assert false)
(pop) ; 22
(push) ; 22
; [else-branch: 618 | True]
; [eval] (forperm _r_13: Ref [_r_13.MustReleaseUnboundedp] :: false)
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(pop) ; 15
; Joined path conditions
(pop) ; 14
(pop) ; 13
(pop) ; 12
; [eval] !p2_3
(push) ; 12
(set-option :timeout 10)
(assert (not p2_3@306@01))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 619 | !(p2_3@306@01) | dead]
; [else-branch: 619 | p2_3@306@01 | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 619 | p2_3@306@01]
(assert p2_3@306@01)
(pop) ; 12
(pop) ; 11
; [eval] !p1_3
(push) ; 11
(set-option :timeout 10)
(assert (not p1_3@305@01))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 620 | !(p1_3@305@01) | dead]
; [else-branch: 620 | p1_3@305@01 | live]
(set-option :timeout 0)
(push) ; 11
; [else-branch: 620 | p1_3@305@01]
(assert p1_3@305@01)
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
; [eval] !p2_3
(push) ; 8
(set-option :timeout 10)
(assert (not p2_3@306@01))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 621 | !(p2_3@306@01) | dead]
; [else-branch: 621 | p2_3@306@01 | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 621 | p2_3@306@01]
(assert p2_3@306@01)
(pop) ; 8
(pop) ; 7
; [eval] !p1_3
(push) ; 7
(set-option :timeout 10)
(assert (not p1_3@305@01))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 622 | !(p1_3@305@01) | dead]
; [else-branch: 622 | p1_3@305@01 | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 622 | p1_3@305@01]
(assert p1_3@305@01)
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 570 | !(p2_3@306@01)]
(assert (not p2_3@306@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_3@305@01))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 623 | p1_3@305@01 | live]
; [else-branch: 623 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 623 | p1_3@305@01]
(assert p1_3@305@01)
(assert (not (= c@313@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
; [then-branch: 624 | p2_3@306@01 | dead]
; [else-branch: 624 | !(p2_3@306@01) | live]
(push) ; 5
; [else-branch: 624 | !(p2_3@306@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
  $Snap.unit))
; [eval] p1_3 ==> issubtype(typeof(c.Cell_val), int())
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 625 | p1_3@305@01 | live]
; [else-branch: 625 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 625 | p1_3@305@01]
; [eval] issubtype(typeof(c.Cell_val), int())
; [eval] typeof(c.Cell_val)
; [eval] int()
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  p1_3@305@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
  $Snap.unit))
; [eval] p2_3 ==> issubtype(typeof(c_4.Cell_valp), int())
(push) ; 6
; [then-branch: 626 | p2_3@306@01 | dead]
; [else-branch: 626 | !(p2_3@306@01) | live]
(push) ; 7
; [else-branch: 626 | !(p2_3@306@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
  $Snap.unit))
; [eval] p1_3 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 627 | p1_3@305@01 | live]
; [else-branch: 627 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 627 | p1_3@305@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
  $Snap.unit))
; [eval] p2_3 ==> true
(push) ; 6
; [then-branch: 628 | p2_3@306@01 | dead]
; [else-branch: 628 | !(p2_3@306@01) | live]
(push) ; 7
; [else-branch: 628 | !(p2_3@306@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@336@01 $Snap)
(assert (= $t@336@01 ($Snap.combine ($Snap.first $t@336@01) ($Snap.second $t@336@01))))
(assert (= ($Snap.first $t@336@01) $Snap.unit))
; [eval] p1_3 ==> (forperm _r_12: Ref [_r_12.MustReleaseBounded] :: Level(_r_12) <= _current_wait_level_164) && ((forperm _r_12: Ref [_r_12.MustReleaseUnbounded] :: Level(_r_12) <= _current_wait_level_164) && _residue_164 <= _current_wait_level_164)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 629 | p1_3@305@01 | live]
; [else-branch: 629 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 629 | p1_3@305@01]
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseBounded] :: Level(_r_12) <= _current_wait_level_164) && ((forperm _r_12: Ref [_r_12.MustReleaseUnbounded] :: Level(_r_12) <= _current_wait_level_164) && _residue_164 <= _current_wait_level_164)
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseBounded] :: Level(_r_12) <= _current_wait_level_164)
(push) ; 9
; [then-branch: 630 | False | live]
; [else-branch: 630 | True | live]
(push) ; 10
; [then-branch: 630 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 630 | True]
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseUnbounded] :: Level(_r_12) <= _current_wait_level_164)
(push) ; 11
; [then-branch: 631 | False | live]
; [else-branch: 631 | True | live]
(push) ; 12
; [then-branch: 631 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 631 | True]
; [eval] _residue_164 <= _current_wait_level_164
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p1_3@305@01 (<= _residue_164@311@01 _current_wait_level_164@315@01)))
(assert (=
  ($Snap.second $t@336@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@336@01))
    ($Snap.second ($Snap.second $t@336@01)))))
(assert (= ($Snap.first ($Snap.second $t@336@01)) $Snap.unit))
; [eval] p2_3 ==> (forperm _r_12: Ref [_r_12.MustReleaseBoundedp] :: Level(_r_12) <= _current_wait_level_164_0) && ((forperm _r_12: Ref [_r_12.MustReleaseUnboundedp] :: Level(_r_12) <= _current_wait_level_164_0) && _residue_164_0 <= _current_wait_level_164_0)
(push) ; 7
; [then-branch: 632 | p2_3@306@01 | dead]
; [else-branch: 632 | !(p2_3@306@01) | live]
(push) ; 8
; [else-branch: 632 | !(p2_3@306@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@336@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@336@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@336@01))))))
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 633 | p1_3@305@01 | live]
; [else-branch: 633 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 633 | p1_3@305@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@336@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@336@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01)))))))
; [then-branch: 634 | p2_3@306@01 | dead]
; [else-branch: 634 | !(p2_3@306@01) | live]
(push) ; 8
; [else-branch: 634 | !(p2_3@306@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@336@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01)))))
  $Snap.unit))
; [eval] p1_3 ==> issubtype(typeof(c.Cell_val), int())
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 635 | p1_3@305@01 | live]
; [else-branch: 635 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 635 | p1_3@305@01]
; [eval] issubtype(typeof(c.Cell_val), int())
; [eval] typeof(c.Cell_val)
; [eval] int()
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  p1_3@305@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@336@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01))))))
  $Snap.unit))
; [eval] p2_3 ==> issubtype(typeof(c_4.Cell_valp), int())
(push) ; 9
; [then-branch: 636 | p2_3@306@01 | dead]
; [else-branch: 636 | !(p2_3@306@01) | live]
(push) ; 10
; [else-branch: 636 | !(p2_3@306@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01)))))))
  $Snap.unit))
; [eval] p1_3 && p2_3 ==> c.Cell_val == c_4.Cell_valp
; [eval] p1_3 && p2_3
(push) ; 9
; [then-branch: 637 | !(p1_3@305@01) | live]
; [else-branch: 637 | p1_3@305@01 | live]
(push) ; 10
; [then-branch: 637 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 10
(push) ; 10
; [else-branch: 637 | p1_3@305@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_3@305@01 (not p1_3@305@01)))
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (and p1_3@305@01 p2_3@306@01))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 638 | p1_3@305@01 && p2_3@306@01 | dead]
; [else-branch: 638 | !(p1_3@305@01 && p2_3@306@01) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 638 | !(p1_3@305@01 && p2_3@306@01)]
(assert (not (and p1_3@305@01 p2_3@306@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (not (and p1_3@305@01 p2_3@306@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01))))))))
  $Snap.unit))
; [eval] p1_3 ==> true
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 639 | p1_3@305@01 | live]
; [else-branch: 639 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 639 | p1_3@305@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@336@01))))))))
  $Snap.unit))
; [eval] p2_3 ==> true
(push) ; 9
; [then-branch: 640 | p2_3@306@01 | dead]
; [else-branch: 640 | !(p2_3@306@01) | live]
(push) ; 10
; [else-branch: 640 | !(p2_3@306@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
(pop) ; 6
(push) ; 6
; [exec]
; var _err: Ref
(declare-const _err@337@01 $Ref)
; [exec]
; var _err_4: Ref
(declare-const _err_4@338@01 $Ref)
; [exec]
; var c_2: Ref
(declare-const c_2@339@01 $Ref)
; [exec]
; var c_2_0: Ref
(declare-const c_2_0@340@01 $Ref)
; [exec]
; var _cwl_164: Perm
(declare-const _cwl_164@341@01 $Perm)
; [exec]
; var _cwl_164_0: Perm
(declare-const _cwl_164_0@342@01 $Perm)
; [exec]
; var _method_measures_164: Seq[Measure$]
(declare-const _method_measures_164@343@01 Seq<Measure$>)
; [exec]
; var _method_measures_164_0: Seq[Measure$]
(declare-const _method_measures_164_0@344@01 Seq<Measure$>)
; [exec]
; var p1_4: Bool
(declare-const p1_4@345@01 Bool)
; [exec]
; var p2_4: Bool
(declare-const p2_4@346@01 Bool)
; [exec]
; var p3: Bool
(declare-const p3@347@01 Bool)
; [exec]
; var p4: Bool
(declare-const p4@348@01 Bool)
; [exec]
; inhale p1_3
(declare-const $t@349@01 $Snap)
(assert (= $t@349@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 641 | p1_3@305@01 | live]
; [else-branch: 641 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 641 | p1_3@305@01]
; [exec]
; _method_measures_164 := Seq(Measure$create(true, _cthread_164, 1))
; [eval] Seq(Measure$create(true, _cthread_164, 1))
; [eval] Measure$create(true, _cthread_164, 1)
(assert (=
  (Seq_length
    (Seq_singleton (Measure$create<Measure$> true _cthread_164@307@01 1)))
  1))
(declare-const _method_measures_164@350@01 Seq<Measure$>)
(assert (=
  _method_measures_164@350@01
  (Seq_singleton (Measure$create<Measure$> true _cthread_164@307@01 1))))
; [exec]
; _err := null
; [exec]
; c_2 := c
; [then-branch: 642 | p2_3@306@01 | dead]
; [else-branch: 642 | !(p2_3@306@01) | live]
(push) ; 8
; [else-branch: 642 | !(p2_3@306@01)]
(pop) ; 8
; [eval] !p2_3
(push) ; 8
(set-option :timeout 10)
(assert (not p2_3@306@01))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 643 | !(p2_3@306@01) | live]
; [else-branch: 643 | p2_3@306@01 | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 643 | !(p2_3@306@01)]
; [exec]
; p1_4 := p1_3 && perm(_MaySet(c_2, 7809653381050164547)) > none
; [eval] p1_3 && perm(_MaySet(c_2, 7809653381050164547)) > none
(push) ; 9
; [then-branch: 644 | !(p1_3@305@01) | live]
; [else-branch: 644 | p1_3@305@01 | live]
(push) ; 10
; [then-branch: 644 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 10
(push) ; 10
; [else-branch: 644 | p1_3@305@01]
; [eval] perm(_MaySet(c_2, 7809653381050164547)) > none
; [eval] perm(_MaySet(c_2, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_3@305@01 (not p1_3@305@01)))
; [exec]
; p2_4 := p2_3 && perm(_MaySet_0(c_2_0, 7809653381050164547)) > none
; [eval] p2_3 && perm(_MaySet_0(c_2_0, 7809653381050164547)) > none
(push) ; 9
; [then-branch: 645 | !(p2_3@306@01) | live]
; [else-branch: 645 | p2_3@306@01 | live]
(push) ; 10
; [then-branch: 645 | !(p2_3@306@01)]
(pop) ; 10
(push) ; 10
; [else-branch: 645 | p2_3@306@01]
(assert p2_3@306@01)
; [eval] perm(_MaySet_0(c_2_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(c_2_0, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p2_3@306@01 (not p2_3@306@01)))
; [exec]
; p3 := p1_3 && !(perm(_MaySet(c_2, 7809653381050164547)) > none)
; [eval] p1_3 && !(perm(_MaySet(c_2, 7809653381050164547)) > none)
(push) ; 9
; [then-branch: 646 | !(p1_3@305@01) | live]
; [else-branch: 646 | p1_3@305@01 | live]
(push) ; 10
; [then-branch: 646 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 10
(push) ; 10
; [else-branch: 646 | p1_3@305@01]
; [eval] !(perm(_MaySet(c_2, 7809653381050164547)) > none)
; [eval] perm(_MaySet(c_2, 7809653381050164547)) > none
; [eval] perm(_MaySet(c_2, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
; [exec]
; p4 := p2_3 && !(perm(_MaySet_0(c_2_0, 7809653381050164547)) > none)
; [eval] p2_3 && !(perm(_MaySet_0(c_2_0, 7809653381050164547)) > none)
(push) ; 9
; [then-branch: 647 | !(p2_3@306@01) | live]
; [else-branch: 647 | p2_3@306@01 | live]
(push) ; 10
; [then-branch: 647 | !(p2_3@306@01)]
(pop) ; 10
(push) ; 10
; [else-branch: 647 | p2_3@306@01]
(assert p2_3@306@01)
; [eval] !(perm(_MaySet_0(c_2_0, 7809653381050164547)) > none)
; [eval] perm(_MaySet_0(c_2_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(c_2_0, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
; [then-branch: 648 | False | dead]
; [else-branch: 648 | True | live]
(push) ; 9
; [else-branch: 648 | True]
(pop) ; 9
; [eval] !p1_4
(push) ; 9
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 649 | True | live]
; [else-branch: 649 | False | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 649 | True]
; [then-branch: 650 | False | dead]
; [else-branch: 650 | True | live]
(push) ; 10
; [else-branch: 650 | True]
(pop) ; 10
; [eval] !p2_4
(push) ; 10
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 651 | True | live]
; [else-branch: 651 | False | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 651 | True]
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 652 | p1_3@305@01 | live]
; [else-branch: 652 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 652 | p1_3@305@01]
; [exec]
; c_2.Cell_val := __prim__int___box__(0)
; [eval] __prim__int___box__(0)
(push) ; 12
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 12
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(declare-const Cell_val@351@01 $Ref)
(assert (= Cell_val@351@01 (__prim__int___box__ $Snap.unit 0)))
; [then-branch: 653 | p2_3@306@01 | dead]
; [else-branch: 653 | !(p2_3@306@01) | live]
(push) ; 12
; [else-branch: 653 | !(p2_3@306@01)]
(pop) ; 12
; [eval] !p2_3
(push) ; 12
(set-option :timeout 10)
(assert (not p2_3@306@01))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 654 | !(p2_3@306@01) | live]
; [else-branch: 654 | p2_3@306@01 | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 654 | !(p2_3@306@01)]
; [exec]
; assert true
; [eval] p1_3 ==> true
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 655 | p1_3@305@01 | live]
; [else-branch: 655 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 655 | p1_3@305@01]
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p2_3 ==> true
(push) ; 13
; [then-branch: 656 | p2_3@306@01 | dead]
; [else-branch: 656 | !(p2_3@306@01) | live]
(push) ; 14
; [else-branch: 656 | !(p2_3@306@01)]
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 657 | p1_3@305@01 | live]
; [else-branch: 657 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 657 | p1_3@305@01]
; [then-branch: 658 | p2_3@306@01 | dead]
; [else-branch: 658 | !(p2_3@306@01) | live]
(push) ; 14
; [else-branch: 658 | !(p2_3@306@01)]
; [eval] p1_3 ==> issubtype(typeof(c.Cell_val), int())
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 659 | p1_3@305@01 | live]
; [else-branch: 659 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 659 | p1_3@305@01]
; [eval] issubtype(typeof(c.Cell_val), int())
; [eval] typeof(c.Cell_val)
; [eval] int()
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (=>
  p1_3@305@01
  (issubtype<Bool> (typeof<PyType> Cell_val@351@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_3@305@01
  (issubtype<Bool> (typeof<PyType> Cell_val@351@01) (as int<PyType>  PyType))))
; [eval] p2_3 ==> issubtype(typeof(c_4.Cell_valp), int())
(push) ; 15
; [then-branch: 660 | p2_3@306@01 | dead]
; [else-branch: 660 | !(p2_3@306@01) | live]
(push) ; 16
; [else-branch: 660 | !(p2_3@306@01)]
(pop) ; 16
(pop) ; 15
; Joined path conditions
; [eval] p1_3 && p2_3 ==> c.Cell_val == c_4.Cell_valp
; [eval] p1_3 && p2_3
(push) ; 15
; [then-branch: 661 | !(p1_3@305@01) | live]
; [else-branch: 661 | p1_3@305@01 | live]
(push) ; 16
; [then-branch: 661 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(pop) ; 16
(push) ; 16
; [else-branch: 661 | p1_3@305@01]
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not (and p1_3@305@01 p2_3@306@01))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 662 | p1_3@305@01 && p2_3@306@01 | dead]
; [else-branch: 662 | !(p1_3@305@01 && p2_3@306@01) | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 662 | !(p1_3@305@01 && p2_3@306@01)]
(assert (not (and p1_3@305@01 p2_3@306@01)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (not (and p1_3@305@01 p2_3@306@01)))
; [eval] p1_3 ==> (forperm _r_13: Ref [MustInvokeBounded(_r_13)] :: false) && ((forperm _r_13: Ref [MustInvokeUnbounded(_r_13)] :: false) && ((forperm _r_13: Ref [_r_13.MustReleaseBounded] :: false) && (forperm _r_13: Ref [_r_13.MustReleaseUnbounded] :: false)))
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_3@305@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 663 | p1_3@305@01 | live]
; [else-branch: 663 | !(p1_3@305@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 663 | p1_3@305@01]
; [eval] (forperm _r_13: Ref [MustInvokeBounded(_r_13)] :: false) && ((forperm _r_13: Ref [MustInvokeUnbounded(_r_13)] :: false) && ((forperm _r_13: Ref [_r_13.MustReleaseBounded] :: false) && (forperm _r_13: Ref [_r_13.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_13: Ref [MustInvokeBounded(_r_13)] :: false)
(push) ; 17
; [then-branch: 664 | False | live]
; [else-branch: 664 | True | live]
(push) ; 18
; [then-branch: 664 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 664 | True]
; [eval] (forperm _r_13: Ref [MustInvokeUnbounded(_r_13)] :: false)
(push) ; 19
; [then-branch: 665 | False | live]
; [else-branch: 665 | True | live]
(push) ; 20
; [then-branch: 665 | False]
(assert false)
(pop) ; 20
(push) ; 20
; [else-branch: 665 | True]
; [eval] (forperm _r_13: Ref [_r_13.MustReleaseBounded] :: false)
(push) ; 21
; [then-branch: 666 | False | live]
; [else-branch: 666 | True | live]
(push) ; 22
; [then-branch: 666 | False]
(assert false)
(pop) ; 22
(push) ; 22
; [else-branch: 666 | True]
; [eval] (forperm _r_13: Ref [_r_13.MustReleaseUnbounded] :: false)
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(pop) ; 15
; Joined path conditions
; [eval] p2_3 ==> (forperm _r_13: Ref [MustInvokeBounded_0(_r_13)] :: false) && ((forperm _r_13: Ref [MustInvokeUnbounded_0(_r_13)] :: false) && ((forperm _r_13: Ref [_r_13.MustReleaseBoundedp] :: false) && (forperm _r_13: Ref [_r_13.MustReleaseUnboundedp] :: false)))
(push) ; 15
; [then-branch: 667 | p2_3@306@01 | dead]
; [else-branch: 667 | !(p2_3@306@01) | live]
(push) ; 16
; [else-branch: 667 | !(p2_3@306@01)]
(pop) ; 16
(pop) ; 15
; Joined path conditions
(pop) ; 14
(pop) ; 13
(pop) ; 12
(pop) ; 11
; [eval] !p1_3
; [then-branch: 668 | !(p1_3@305@01) | dead]
; [else-branch: 668 | p1_3@305@01 | live]
(push) ; 11
; [else-branch: 668 | p1_3@305@01]
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
; [eval] !p1_3
; [then-branch: 669 | !(p1_3@305@01) | dead]
; [else-branch: 669 | p1_3@305@01 | live]
(push) ; 7
; [else-branch: 669 | p1_3@305@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [else-branch: 569 | !(p1_3@305@01)]
(assert (not p1_3@305@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_3@306@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 670 | p2_3@306@01 | live]
; [else-branch: 670 | !(p2_3@306@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 670 | p2_3@306@01]
(assert p2_3@306@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
; [then-branch: 671 | p1_3@305@01 | dead]
; [else-branch: 671 | !(p1_3@305@01) | live]
(push) ; 4
; [else-branch: 671 | !(p1_3@305@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 672 | p2_3@306@01 | live]
; [else-branch: 672 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 672 | p2_3@306@01]
(assert (not (= c_4@314@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
  $Snap.unit))
; [eval] p1_3 ==> issubtype(typeof(c.Cell_val), int())
(push) ; 6
; [then-branch: 673 | p1_3@305@01 | dead]
; [else-branch: 673 | !(p1_3@305@01) | live]
(push) ; 7
; [else-branch: 673 | !(p1_3@305@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
  $Snap.unit))
; [eval] p2_3 ==> issubtype(typeof(c_4.Cell_valp), int())
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 674 | p2_3@306@01 | live]
; [else-branch: 674 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 674 | p2_3@306@01]
; [eval] issubtype(typeof(c_4.Cell_valp), int())
; [eval] typeof(c_4.Cell_valp)
; [eval] int()
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  p2_3@306@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
  $Snap.unit))
; [eval] p1_3 ==> true
(push) ; 6
; [then-branch: 675 | p1_3@305@01 | dead]
; [else-branch: 675 | !(p1_3@305@01) | live]
(push) ; 7
; [else-branch: 675 | !(p1_3@305@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
  $Snap.unit))
; [eval] p2_3 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 676 | p2_3@306@01 | live]
; [else-branch: 676 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 676 | p2_3@306@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@352@01 $Snap)
(assert (= $t@352@01 ($Snap.combine ($Snap.first $t@352@01) ($Snap.second $t@352@01))))
(assert (= ($Snap.first $t@352@01) $Snap.unit))
; [eval] p1_3 ==> (forperm _r_12: Ref [_r_12.MustReleaseBounded] :: Level(_r_12) <= _current_wait_level_164) && ((forperm _r_12: Ref [_r_12.MustReleaseUnbounded] :: Level(_r_12) <= _current_wait_level_164) && _residue_164 <= _current_wait_level_164)
(push) ; 7
; [then-branch: 677 | p1_3@305@01 | dead]
; [else-branch: 677 | !(p1_3@305@01) | live]
(push) ; 8
; [else-branch: 677 | !(p1_3@305@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second $t@352@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@352@01))
    ($Snap.second ($Snap.second $t@352@01)))))
(assert (= ($Snap.first ($Snap.second $t@352@01)) $Snap.unit))
; [eval] p2_3 ==> (forperm _r_12: Ref [_r_12.MustReleaseBoundedp] :: Level(_r_12) <= _current_wait_level_164_0) && ((forperm _r_12: Ref [_r_12.MustReleaseUnboundedp] :: Level(_r_12) <= _current_wait_level_164_0) && _residue_164_0 <= _current_wait_level_164_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 678 | p2_3@306@01 | live]
; [else-branch: 678 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 678 | p2_3@306@01]
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseBoundedp] :: Level(_r_12) <= _current_wait_level_164_0) && ((forperm _r_12: Ref [_r_12.MustReleaseUnboundedp] :: Level(_r_12) <= _current_wait_level_164_0) && _residue_164_0 <= _current_wait_level_164_0)
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseBoundedp] :: Level(_r_12) <= _current_wait_level_164_0)
(push) ; 9
; [then-branch: 679 | False | live]
; [else-branch: 679 | True | live]
(push) ; 10
; [then-branch: 679 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 679 | True]
; [eval] (forperm _r_12: Ref [_r_12.MustReleaseUnboundedp] :: Level(_r_12) <= _current_wait_level_164_0)
(push) ; 11
; [then-branch: 680 | False | live]
; [else-branch: 680 | True | live]
(push) ; 12
; [then-branch: 680 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 680 | True]
; [eval] _residue_164_0 <= _current_wait_level_164_0
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p2_3@306@01 (<= _residue_164_0@312@01 _current_wait_level_164_0@316@01)))
(assert (=
  ($Snap.second ($Snap.second $t@352@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@352@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@352@01))))))
; [then-branch: 681 | p1_3@305@01 | dead]
; [else-branch: 681 | !(p1_3@305@01) | live]
(push) ; 7
; [else-branch: 681 | !(p1_3@305@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@352@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@352@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@352@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01)))))))
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 682 | p2_3@306@01 | live]
; [else-branch: 682 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 682 | p2_3@306@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01)))))
  $Snap.unit))
; [eval] p1_3 ==> issubtype(typeof(c.Cell_val), int())
(push) ; 9
; [then-branch: 683 | p1_3@305@01 | dead]
; [else-branch: 683 | !(p1_3@305@01) | live]
(push) ; 10
; [else-branch: 683 | !(p1_3@305@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01))))))
  $Snap.unit))
; [eval] p2_3 ==> issubtype(typeof(c_4.Cell_valp), int())
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 684 | p2_3@306@01 | live]
; [else-branch: 684 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 684 | p2_3@306@01]
; [eval] issubtype(typeof(c_4.Cell_valp), int())
; [eval] typeof(c_4.Cell_valp)
; [eval] int()
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  p2_3@306@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@352@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01)))))))
  $Snap.unit))
; [eval] p1_3 && p2_3 ==> c.Cell_val == c_4.Cell_valp
; [eval] p1_3 && p2_3
(push) ; 9
; [then-branch: 685 | !(p1_3@305@01) | live]
; [else-branch: 685 | p1_3@305@01 | live]
(push) ; 10
; [then-branch: 685 | !(p1_3@305@01)]
(pop) ; 10
(push) ; 10
; [else-branch: 685 | p1_3@305@01]
(assert p1_3@305@01)
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_3@305@01 (not p1_3@305@01)))
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (and p1_3@305@01 p2_3@306@01))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 686 | p1_3@305@01 && p2_3@306@01 | dead]
; [else-branch: 686 | !(p1_3@305@01 && p2_3@306@01) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 686 | !(p1_3@305@01 && p2_3@306@01)]
(assert (not (and p1_3@305@01 p2_3@306@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (not (and p1_3@305@01 p2_3@306@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01))))))))
  $Snap.unit))
; [eval] p1_3 ==> true
(push) ; 9
; [then-branch: 687 | p1_3@305@01 | dead]
; [else-branch: 687 | !(p1_3@305@01) | live]
(push) ; 10
; [else-branch: 687 | !(p1_3@305@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@352@01))))))))
  $Snap.unit))
; [eval] p2_3 ==> true
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_3@306@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 688 | p2_3@306@01 | live]
; [else-branch: 688 | !(p2_3@306@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 688 | p2_3@306@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
(pop) ; 6
(push) ; 6
; [exec]
; var _err: Ref
(declare-const _err@353@01 $Ref)
; [exec]
; var _err_4: Ref
(declare-const _err_4@354@01 $Ref)
; [exec]
; var c_2: Ref
(declare-const c_2@355@01 $Ref)
; [exec]
; var c_2_0: Ref
(declare-const c_2_0@356@01 $Ref)
; [exec]
; var _cwl_164: Perm
(declare-const _cwl_164@357@01 $Perm)
; [exec]
; var _cwl_164_0: Perm
(declare-const _cwl_164_0@358@01 $Perm)
; [exec]
; var _method_measures_164: Seq[Measure$]
(declare-const _method_measures_164@359@01 Seq<Measure$>)
; [exec]
; var _method_measures_164_0: Seq[Measure$]
(declare-const _method_measures_164_0@360@01 Seq<Measure$>)
; [exec]
; var p1_4: Bool
(declare-const p1_4@361@01 Bool)
; [exec]
; var p2_4: Bool
(declare-const p2_4@362@01 Bool)
; [exec]
; var p3: Bool
(declare-const p3@363@01 Bool)
; [exec]
; var p4: Bool
(declare-const p4@364@01 Bool)
; [exec]
; inhale p1_3
(declare-const $t@365@01 $Snap)
(assert (= $t@365@01 $Snap.unit))
(assert p1_3@305@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 689 | p1_3@305@01 | dead]
; [else-branch: 689 | !(p1_3@305@01) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 689 | !(p1_3@305@01)]
(pop) ; 7
; [eval] !p1_3
; [then-branch: 690 | !(p1_3@305@01) | dead]
; [else-branch: 690 | p1_3@305@01 | live]
(push) ; 7
; [else-branch: 690 | p1_3@305@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 670 | !(p2_3@306@01)]
(assert (not p2_3@306@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
; [then-branch: 691 | p1_3@305@01 | dead]
; [else-branch: 691 | !(p1_3@305@01) | live]
(push) ; 4
; [else-branch: 691 | !(p1_3@305@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
; [then-branch: 692 | p2_3@306@01 | dead]
; [else-branch: 692 | !(p2_3@306@01) | live]
(push) ; 5
; [else-branch: 692 | !(p2_3@306@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
  $Snap.unit))
; [eval] p1_3 ==> issubtype(typeof(c.Cell_val), int())
(push) ; 6
; [then-branch: 693 | p1_3@305@01 | dead]
; [else-branch: 693 | !(p1_3@305@01) | live]
(push) ; 7
; [else-branch: 693 | !(p1_3@305@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
  $Snap.unit))
; [eval] p2_3 ==> issubtype(typeof(c_4.Cell_valp), int())
(push) ; 6
; [then-branch: 694 | p2_3@306@01 | dead]
; [else-branch: 694 | !(p2_3@306@01) | live]
(push) ; 7
; [else-branch: 694 | !(p2_3@306@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
  $Snap.unit))
; [eval] p1_3 ==> true
(push) ; 6
; [then-branch: 695 | p1_3@305@01 | dead]
; [else-branch: 695 | !(p1_3@305@01) | live]
(push) ; 7
; [else-branch: 695 | !(p1_3@305@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@317@01)))))))))))))
  $Snap.unit))
; [eval] p2_3 ==> true
(push) ; 6
; [then-branch: 696 | p2_3@306@01 | dead]
; [else-branch: 696 | !(p2_3@306@01) | live]
(push) ; 7
; [else-branch: 696 | !(p2_3@306@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@366@01 $Snap)
(assert (= $t@366@01 ($Snap.combine ($Snap.first $t@366@01) ($Snap.second $t@366@01))))
(assert (= ($Snap.first $t@366@01) $Snap.unit))
; [eval] p1_3 ==> (forperm _r_12: Ref [_r_12.MustReleaseBounded] :: Level(_r_12) <= _current_wait_level_164) && ((forperm _r_12: Ref [_r_12.MustReleaseUnbounded] :: Level(_r_12) <= _current_wait_level_164) && _residue_164 <= _current_wait_level_164)
(push) ; 7
; [then-branch: 697 | p1_3@305@01 | dead]
; [else-branch: 697 | !(p1_3@305@01) | live]
(push) ; 8
; [else-branch: 697 | !(p1_3@305@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second $t@366@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@366@01))
    ($Snap.second ($Snap.second $t@366@01)))))
(assert (= ($Snap.first ($Snap.second $t@366@01)) $Snap.unit))
; [eval] p2_3 ==> (forperm _r_12: Ref [_r_12.MustReleaseBoundedp] :: Level(_r_12) <= _current_wait_level_164_0) && ((forperm _r_12: Ref [_r_12.MustReleaseUnboundedp] :: Level(_r_12) <= _current_wait_level_164_0) && _residue_164_0 <= _current_wait_level_164_0)
(push) ; 7
; [then-branch: 698 | p2_3@306@01 | dead]
; [else-branch: 698 | !(p2_3@306@01) | live]
(push) ; 8
; [else-branch: 698 | !(p2_3@306@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@366@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@366@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@366@01))))))
; [then-branch: 699 | p1_3@305@01 | dead]
; [else-branch: 699 | !(p1_3@305@01) | live]
(push) ; 7
; [else-branch: 699 | !(p1_3@305@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@366@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@366@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@366@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01)))))))
; [then-branch: 700 | p2_3@306@01 | dead]
; [else-branch: 700 | !(p2_3@306@01) | live]
(push) ; 8
; [else-branch: 700 | !(p2_3@306@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@366@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01)))))
  $Snap.unit))
; [eval] p1_3 ==> issubtype(typeof(c.Cell_val), int())
(push) ; 9
; [then-branch: 701 | p1_3@305@01 | dead]
; [else-branch: 701 | !(p1_3@305@01) | live]
(push) ; 10
; [else-branch: 701 | !(p1_3@305@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01))))))
  $Snap.unit))
; [eval] p2_3 ==> issubtype(typeof(c_4.Cell_valp), int())
(push) ; 9
; [then-branch: 702 | p2_3@306@01 | dead]
; [else-branch: 702 | !(p2_3@306@01) | live]
(push) ; 10
; [else-branch: 702 | !(p2_3@306@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01)))))))
  $Snap.unit))
; [eval] p1_3 && p2_3 ==> c.Cell_val == c_4.Cell_valp
; [eval] p1_3 && p2_3
(push) ; 9
; [then-branch: 703 | !(p1_3@305@01) | live]
; [else-branch: 703 | p1_3@305@01 | live]
(push) ; 10
; [then-branch: 703 | !(p1_3@305@01)]
(pop) ; 10
(push) ; 10
; [else-branch: 703 | p1_3@305@01]
(assert p1_3@305@01)
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_3@305@01 (not p1_3@305@01)))
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (and p1_3@305@01 p2_3@306@01))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 704 | p1_3@305@01 && p2_3@306@01 | dead]
; [else-branch: 704 | !(p1_3@305@01 && p2_3@306@01) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 704 | !(p1_3@305@01 && p2_3@306@01)]
(assert (not (and p1_3@305@01 p2_3@306@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (not (and p1_3@305@01 p2_3@306@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01))))))))
  $Snap.unit))
; [eval] p1_3 ==> true
(push) ; 9
; [then-branch: 705 | p1_3@305@01 | dead]
; [else-branch: 705 | !(p1_3@305@01) | live]
(push) ; 10
; [else-branch: 705 | !(p1_3@305@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@366@01))))))))
  $Snap.unit))
; [eval] p2_3 ==> true
(push) ; 9
; [then-branch: 706 | p2_3@306@01 | dead]
; [else-branch: 706 | !(p2_3@306@01) | live]
(push) ; 10
; [else-branch: 706 | !(p2_3@306@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
(pop) ; 6
(push) ; 6
; [exec]
; var _err: Ref
(declare-const _err@367@01 $Ref)
; [exec]
; var _err_4: Ref
(declare-const _err_4@368@01 $Ref)
; [exec]
; var c_2: Ref
(declare-const c_2@369@01 $Ref)
; [exec]
; var c_2_0: Ref
(declare-const c_2_0@370@01 $Ref)
; [exec]
; var _cwl_164: Perm
(declare-const _cwl_164@371@01 $Perm)
; [exec]
; var _cwl_164_0: Perm
(declare-const _cwl_164_0@372@01 $Perm)
; [exec]
; var _method_measures_164: Seq[Measure$]
(declare-const _method_measures_164@373@01 Seq<Measure$>)
; [exec]
; var _method_measures_164_0: Seq[Measure$]
(declare-const _method_measures_164_0@374@01 Seq<Measure$>)
; [exec]
; var p1_4: Bool
(declare-const p1_4@375@01 Bool)
; [exec]
; var p2_4: Bool
(declare-const p2_4@376@01 Bool)
; [exec]
; var p3: Bool
(declare-const p3@377@01 Bool)
; [exec]
; var p4: Bool
(declare-const p4@378@01 Bool)
; [exec]
; inhale p1_3
(declare-const $t@379@01 $Snap)
(assert (= $t@379@01 $Snap.unit))
(assert p1_3@305@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 707 | p1_3@305@01 | dead]
; [else-branch: 707 | !(p1_3@305@01) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 707 | !(p1_3@305@01)]
(pop) ; 7
; [eval] !p1_3
; [then-branch: 708 | !(p1_3@305@01) | dead]
; [else-branch: 708 | p1_3@305@01 | live]
(push) ; 7
; [else-branch: 708 | p1_3@305@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- one ----------
(declare-const p1_5@380@01 Bool)
(declare-const p2_5@381@01 Bool)
(declare-const _cthread_165@382@01 $Ref)
(declare-const _cthread_165_0@383@01 $Ref)
(declare-const _caller_measures_165@384@01 Seq<Measure$>)
(declare-const _caller_measures_165_0@385@01 Seq<Measure$>)
(declare-const _residue_165@386@01 $Perm)
(declare-const _residue_165_0@387@01 $Perm)
(declare-const c_0@388@01 $Ref)
(declare-const c_0_0@389@01 $Ref)
(declare-const _current_wait_level_165@390@01 $Perm)
(declare-const _current_wait_level_165_0@391@01 $Perm)
(declare-const p1_5@392@01 Bool)
(declare-const p2_5@393@01 Bool)
(declare-const _cthread_165@394@01 $Ref)
(declare-const _cthread_165_0@395@01 $Ref)
(declare-const _caller_measures_165@396@01 Seq<Measure$>)
(declare-const _caller_measures_165_0@397@01 Seq<Measure$>)
(declare-const _residue_165@398@01 $Perm)
(declare-const _residue_165_0@399@01 $Perm)
(declare-const c_0@400@01 $Ref)
(declare-const c_0_0@401@01 $Ref)
(declare-const _current_wait_level_165@402@01 $Perm)
(declare-const _current_wait_level_165_0@403@01 $Perm)
(push) ; 1
(declare-const $t@404@01 $Snap)
(assert (= $t@404@01 ($Snap.combine ($Snap.first $t@404@01) ($Snap.second $t@404@01))))
(assert (= ($Snap.first $t@404@01) $Snap.unit))
; [eval] p1_5 ==> _cthread_165 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_5@392@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 709 | p1_5@392@01 | live]
; [else-branch: 709 | !(p1_5@392@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 709 | p1_5@392@01]
(assert p1_5@392@01)
; [eval] _cthread_165 != null
(pop) ; 3
(push) ; 3
; [else-branch: 709 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_5@392@01) p1_5@392@01))
(assert (=> p1_5@392@01 (not (= _cthread_165@394@01 $Ref.null))))
(assert (=
  ($Snap.second $t@404@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@404@01))
    ($Snap.second ($Snap.second $t@404@01)))))
(assert (= ($Snap.first ($Snap.second $t@404@01)) $Snap.unit))
; [eval] p2_5 ==> _cthread_165_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_5@393@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 710 | p2_5@393@01 | live]
; [else-branch: 710 | !(p2_5@393@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 710 | p2_5@393@01]
(assert p2_5@393@01)
; [eval] _cthread_165_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 710 | !(p2_5@393@01)]
(assert (not p2_5@393@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_5@393@01) p2_5@393@01))
(assert (=> p2_5@393@01 (not (= _cthread_165_0@395@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@404@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@404@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@404@01))) $Snap.unit))
; [eval] p1_5 ==> issubtype(typeof(_cthread_165), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_5@392@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 711 | p1_5@392@01 | live]
; [else-branch: 711 | !(p1_5@392@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 711 | p1_5@392@01]
(assert p1_5@392@01)
; [eval] issubtype(typeof(_cthread_165), Thread_0())
; [eval] typeof(_cthread_165)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 711 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_5@392@01
  (issubtype<Bool> (typeof<PyType> _cthread_165@394@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@404@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@404@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@404@01))))
  $Snap.unit))
; [eval] p2_5 ==> issubtype(typeof(_cthread_165_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_5@393@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 712 | p2_5@393@01 | live]
; [else-branch: 712 | !(p2_5@393@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 712 | p2_5@393@01]
(assert p2_5@393@01)
; [eval] issubtype(typeof(_cthread_165_0), Thread_0())
; [eval] typeof(_cthread_165_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 712 | !(p2_5@393@01)]
(assert (not p2_5@393@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_5@393@01
  (issubtype<Bool> (typeof<PyType> _cthread_165_0@395@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))
  $Snap.unit))
; [eval] p1_5 ==> issubtype(typeof(c_0), Cell())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_5@392@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 713 | p1_5@392@01 | live]
; [else-branch: 713 | !(p1_5@392@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 713 | p1_5@392@01]
(assert p1_5@392@01)
; [eval] issubtype(typeof(c_0), Cell())
; [eval] typeof(c_0)
; [eval] Cell()
(pop) ; 3
(push) ; 3
; [else-branch: 713 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_5@392@01
  (issubtype<Bool> (typeof<PyType> c_0@400@01) (as Cell<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))
  $Snap.unit))
; [eval] p2_5 ==> issubtype(typeof(c_0_0), Cell())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_5@393@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 714 | p2_5@393@01 | live]
; [else-branch: 714 | !(p2_5@393@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 714 | p2_5@393@01]
(assert p2_5@393@01)
; [eval] issubtype(typeof(c_0_0), Cell())
; [eval] typeof(c_0_0)
; [eval] Cell()
(pop) ; 3
(push) ; 3
; [else-branch: 714 | !(p2_5@393@01)]
(assert (not p2_5@393@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_5@393@01
  (issubtype<Bool> (typeof<PyType> c_0_0@401@01) (as Cell<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
(push) ; 2
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 2
(set-option :timeout 10)
(assert (not p1_5@392@01))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; [then-branch: 715 | p1_5@392@01 | live]
; [else-branch: 715 | !(p1_5@392@01) | live]
(set-option :timeout 0)
(push) ; 2
; [then-branch: 715 | p1_5@392@01]
(assert p1_5@392@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_5@393@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 716 | p2_5@393@01 | live]
; [else-branch: 716 | !(p2_5@393@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 716 | p2_5@393@01]
(assert p2_5@393@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 717 | p1_5@392@01 | live]
; [else-branch: 717 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 717 | p1_5@392@01]
(assert (not (= c_0@400@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 718 | p2_5@393@01 | live]
; [else-branch: 718 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 718 | p2_5@393@01]
(assert (not (= c_0_0@401@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
  $Snap.unit))
; [eval] p1_5 ==> issubtype(typeof(c_0.Cell_val), int())
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 719 | p1_5@392@01 | live]
; [else-branch: 719 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 719 | p1_5@392@01]
; [eval] issubtype(typeof(c_0.Cell_val), int())
; [eval] typeof(c_0.Cell_val)
; [eval] int()
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  p1_5@392@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
  $Snap.unit))
; [eval] p2_5 ==> issubtype(typeof(c_0_0.Cell_valp), int())
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 720 | p2_5@393@01 | live]
; [else-branch: 720 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 720 | p2_5@393@01]
; [eval] issubtype(typeof(c_0_0.Cell_valp), int())
; [eval] typeof(c_0_0.Cell_valp)
; [eval] int()
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  p2_5@393@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
  $Snap.unit))
; [eval] p1_5 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 721 | p1_5@392@01 | live]
; [else-branch: 721 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 721 | p1_5@392@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
  $Snap.unit))
; [eval] p2_5 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 722 | p2_5@393@01 | live]
; [else-branch: 722 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 722 | p2_5@393@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@405@01 $Snap)
(assert (= $t@405@01 ($Snap.combine ($Snap.first $t@405@01) ($Snap.second $t@405@01))))
(assert (= ($Snap.first $t@405@01) $Snap.unit))
; [eval] p1_5 ==> (forperm _r_15: Ref [_r_15.MustReleaseBounded] :: Level(_r_15) <= _current_wait_level_165) && ((forperm _r_15: Ref [_r_15.MustReleaseUnbounded] :: Level(_r_15) <= _current_wait_level_165) && _residue_165 <= _current_wait_level_165)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 723 | p1_5@392@01 | live]
; [else-branch: 723 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 723 | p1_5@392@01]
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseBounded] :: Level(_r_15) <= _current_wait_level_165) && ((forperm _r_15: Ref [_r_15.MustReleaseUnbounded] :: Level(_r_15) <= _current_wait_level_165) && _residue_165 <= _current_wait_level_165)
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseBounded] :: Level(_r_15) <= _current_wait_level_165)
(push) ; 9
; [then-branch: 724 | False | live]
; [else-branch: 724 | True | live]
(push) ; 10
; [then-branch: 724 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 724 | True]
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseUnbounded] :: Level(_r_15) <= _current_wait_level_165)
(push) ; 11
; [then-branch: 725 | False | live]
; [else-branch: 725 | True | live]
(push) ; 12
; [then-branch: 725 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 725 | True]
; [eval] _residue_165 <= _current_wait_level_165
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p1_5@392@01 (<= _residue_165@398@01 _current_wait_level_165@402@01)))
(assert (=
  ($Snap.second $t@405@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@405@01))
    ($Snap.second ($Snap.second $t@405@01)))))
(assert (= ($Snap.first ($Snap.second $t@405@01)) $Snap.unit))
; [eval] p2_5 ==> (forperm _r_15: Ref [_r_15.MustReleaseBoundedp] :: Level(_r_15) <= _current_wait_level_165_0) && ((forperm _r_15: Ref [_r_15.MustReleaseUnboundedp] :: Level(_r_15) <= _current_wait_level_165_0) && _residue_165_0 <= _current_wait_level_165_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 726 | p2_5@393@01 | live]
; [else-branch: 726 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 726 | p2_5@393@01]
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseBoundedp] :: Level(_r_15) <= _current_wait_level_165_0) && ((forperm _r_15: Ref [_r_15.MustReleaseUnboundedp] :: Level(_r_15) <= _current_wait_level_165_0) && _residue_165_0 <= _current_wait_level_165_0)
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseBoundedp] :: Level(_r_15) <= _current_wait_level_165_0)
(push) ; 9
; [then-branch: 727 | False | live]
; [else-branch: 727 | True | live]
(push) ; 10
; [then-branch: 727 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 727 | True]
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseUnboundedp] :: Level(_r_15) <= _current_wait_level_165_0)
(push) ; 11
; [then-branch: 728 | False | live]
; [else-branch: 728 | True | live]
(push) ; 12
; [then-branch: 728 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 728 | True]
; [eval] _residue_165_0 <= _current_wait_level_165_0
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p2_5@393@01 (<= _residue_165_0@399@01 _current_wait_level_165_0@403@01)))
(assert (=
  ($Snap.second ($Snap.second $t@405@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@405@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@405@01))))))
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 729 | p1_5@392@01 | live]
; [else-branch: 729 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 729 | p1_5@392@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@405@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@405@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01)))))))
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 730 | p2_5@393@01 | live]
; [else-branch: 730 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 730 | p2_5@393@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01)))))
  $Snap.unit))
; [eval] p1_5 ==> issubtype(typeof(c_0.Cell_val), int())
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 731 | p1_5@392@01 | live]
; [else-branch: 731 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 731 | p1_5@392@01]
; [eval] issubtype(typeof(c_0.Cell_val), int())
; [eval] typeof(c_0.Cell_val)
; [eval] int()
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  p1_5@392@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@405@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01))))))
  $Snap.unit))
; [eval] p2_5 ==> issubtype(typeof(c_0_0.Cell_valp), int())
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 732 | p2_5@393@01 | live]
; [else-branch: 732 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 732 | p2_5@393@01]
; [eval] issubtype(typeof(c_0_0.Cell_valp), int())
; [eval] typeof(c_0_0.Cell_valp)
; [eval] int()
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  p2_5@393@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@405@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01)))))))
  $Snap.unit))
; [eval] p1_5 && p2_5 ==> c_0.Cell_val == c_0_0.Cell_valp
; [eval] p1_5 && p2_5
(push) ; 9
; [then-branch: 733 | !(p1_5@392@01) | live]
; [else-branch: 733 | p1_5@392@01 | live]
(push) ; 10
; [then-branch: 733 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 10
(push) ; 10
; [else-branch: 733 | p1_5@392@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_5@392@01 (not p1_5@392@01)))
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (and p1_5@392@01 p2_5@393@01))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (and p1_5@392@01 p2_5@393@01)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 734 | p1_5@392@01 && p2_5@393@01 | live]
; [else-branch: 734 | !(p1_5@392@01 && p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 734 | p1_5@392@01 && p2_5@393@01]
(assert (and p1_5@392@01 p2_5@393@01))
; [eval] c_0.Cell_val == c_0_0.Cell_valp
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (and p1_5@392@01 p2_5@393@01))
(assert (=>
  (and p1_5@392@01 p2_5@393@01)
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@405@01))))
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@405@01))))))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01))))))))
  $Snap.unit))
; [eval] p1_5 ==> true
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 735 | p1_5@392@01 | live]
; [else-branch: 735 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 735 | p1_5@392@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@405@01))))))))
  $Snap.unit))
; [eval] p2_5 ==> true
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 736 | p2_5@393@01 | live]
; [else-branch: 736 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 736 | p2_5@393@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
(pop) ; 6
(push) ; 6
; [exec]
; var _err: Ref
(declare-const _err@406@01 $Ref)
; [exec]
; var _err_5: Ref
(declare-const _err_5@407@01 $Ref)
; [exec]
; var c_3: Ref
(declare-const c_3@408@01 $Ref)
; [exec]
; var c_3_0: Ref
(declare-const c_3_0@409@01 $Ref)
; [exec]
; var _cwl_165: Perm
(declare-const _cwl_165@410@01 $Perm)
; [exec]
; var _cwl_165_0: Perm
(declare-const _cwl_165_0@411@01 $Perm)
; [exec]
; var _method_measures_165: Seq[Measure$]
(declare-const _method_measures_165@412@01 Seq<Measure$>)
; [exec]
; var _method_measures_165_0: Seq[Measure$]
(declare-const _method_measures_165_0@413@01 Seq<Measure$>)
; [exec]
; var p1_6: Bool
(declare-const p1_6@414@01 Bool)
; [exec]
; var p2_6: Bool
(declare-const p2_6@415@01 Bool)
; [exec]
; var p3_0: Bool
(declare-const p3_0@416@01 Bool)
; [exec]
; var p4_0: Bool
(declare-const p4_0@417@01 Bool)
; [exec]
; inhale p1_5
(declare-const $t@418@01 $Snap)
(assert (= $t@418@01 $Snap.unit))
(assert p1_5@392@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 737 | p1_5@392@01 | live]
; [else-branch: 737 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 737 | p1_5@392@01]
; [exec]
; _method_measures_165 := Seq(Measure$create(true, _cthread_165, 1))
; [eval] Seq(Measure$create(true, _cthread_165, 1))
; [eval] Measure$create(true, _cthread_165, 1)
(assert (=
  (Seq_length
    (Seq_singleton (Measure$create<Measure$> true _cthread_165@394@01 1)))
  1))
(declare-const _method_measures_165@419@01 Seq<Measure$>)
(assert (=
  _method_measures_165@419@01
  (Seq_singleton (Measure$create<Measure$> true _cthread_165@394@01 1))))
; [exec]
; _err := null
; [exec]
; c_3 := c_0
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not p2_5@393@01))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 738 | p2_5@393@01 | live]
; [else-branch: 738 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 738 | p2_5@393@01]
(assert p2_5@393@01)
; [exec]
; _method_measures_165_0 := Seq(Measure$create(true, _cthread_165_0, 1))
; [eval] Seq(Measure$create(true, _cthread_165_0, 1))
; [eval] Measure$create(true, _cthread_165_0, 1)
(assert (=
  (Seq_length
    (Seq_singleton (Measure$create<Measure$> true _cthread_165_0@395@01 1)))
  1))
(declare-const _method_measures_165_0@420@01 Seq<Measure$>)
(assert (=
  _method_measures_165_0@420@01
  (Seq_singleton (Measure$create<Measure$> true _cthread_165_0@395@01 1))))
; [exec]
; _err_5 := null
; [exec]
; c_3_0 := c_0_0
; [exec]
; p1_6 := p1_5 && perm(_MaySet(c_3, 7809653381050164547)) > none
; [eval] p1_5 && perm(_MaySet(c_3, 7809653381050164547)) > none
(push) ; 9
; [then-branch: 739 | !(p1_5@392@01) | live]
; [else-branch: 739 | p1_5@392@01 | live]
(push) ; 10
; [then-branch: 739 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 10
(push) ; 10
; [else-branch: 739 | p1_5@392@01]
; [eval] perm(_MaySet(c_3, 7809653381050164547)) > none
; [eval] perm(_MaySet(c_3, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_5@392@01 (not p1_5@392@01)))
; [exec]
; p2_6 := p2_5 && perm(_MaySet_0(c_3_0, 7809653381050164547)) > none
; [eval] p2_5 && perm(_MaySet_0(c_3_0, 7809653381050164547)) > none
(push) ; 9
; [then-branch: 740 | !(p2_5@393@01) | live]
; [else-branch: 740 | p2_5@393@01 | live]
(push) ; 10
; [then-branch: 740 | !(p2_5@393@01)]
(assert (not p2_5@393@01))
(pop) ; 10
(push) ; 10
; [else-branch: 740 | p2_5@393@01]
; [eval] perm(_MaySet_0(c_3_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(c_3_0, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p2_5@393@01 (not p2_5@393@01)))
; [exec]
; p3_0 := p1_5 && !(perm(_MaySet(c_3, 7809653381050164547)) > none)
; [eval] p1_5 && !(perm(_MaySet(c_3, 7809653381050164547)) > none)
(push) ; 9
; [then-branch: 741 | !(p1_5@392@01) | live]
; [else-branch: 741 | p1_5@392@01 | live]
(push) ; 10
; [then-branch: 741 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 10
(push) ; 10
; [else-branch: 741 | p1_5@392@01]
; [eval] !(perm(_MaySet(c_3, 7809653381050164547)) > none)
; [eval] perm(_MaySet(c_3, 7809653381050164547)) > none
; [eval] perm(_MaySet(c_3, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
; [exec]
; p4_0 := p2_5 && !(perm(_MaySet_0(c_3_0, 7809653381050164547)) > none)
; [eval] p2_5 && !(perm(_MaySet_0(c_3_0, 7809653381050164547)) > none)
(push) ; 9
; [then-branch: 742 | !(p2_5@393@01) | live]
; [else-branch: 742 | p2_5@393@01 | live]
(push) ; 10
; [then-branch: 742 | !(p2_5@393@01)]
(assert (not p2_5@393@01))
(pop) ; 10
(push) ; 10
; [else-branch: 742 | p2_5@393@01]
; [eval] !(perm(_MaySet_0(c_3_0, 7809653381050164547)) > none)
; [eval] perm(_MaySet_0(c_3_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(c_3_0, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
; [then-branch: 743 | False | dead]
; [else-branch: 743 | True | live]
(push) ; 9
; [else-branch: 743 | True]
(pop) ; 9
; [eval] !p1_6
(push) ; 9
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 744 | True | live]
; [else-branch: 744 | False | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 744 | True]
; [then-branch: 745 | False | dead]
; [else-branch: 745 | True | live]
(push) ; 10
; [else-branch: 745 | True]
(pop) ; 10
; [eval] !p2_6
(push) ; 10
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 746 | True | live]
; [else-branch: 746 | False | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 746 | True]
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 747 | p1_5@392@01 | live]
; [else-branch: 747 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 747 | p1_5@392@01]
; [exec]
; c_3.Cell_val := __prim__int___box__(1)
; [eval] __prim__int___box__(1)
(push) ; 12
(assert (__prim__int___box__%precondition $Snap.unit 1))
(pop) ; 12
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 1))
(declare-const Cell_val@421@01 $Ref)
(assert (= Cell_val@421@01 (__prim__int___box__ $Snap.unit 1)))
(push) ; 12
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 748 | p2_5@393@01 | live]
; [else-branch: 748 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 748 | p2_5@393@01]
; [exec]
; c_3_0.Cell_valp := __prim__int___box__(1)
; [eval] __prim__int___box__(1)
(push) ; 13
(pop) ; 13
; Joined path conditions
(declare-const Cell_valp@422@01 $Ref)
(assert (= Cell_valp@422@01 (__prim__int___box__ $Snap.unit 1)))
; [exec]
; assert true
; [eval] p1_5 ==> true
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 749 | p1_5@392@01 | live]
; [else-branch: 749 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 749 | p1_5@392@01]
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p2_5 ==> true
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 750 | p2_5@393@01 | live]
; [else-branch: 750 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 750 | p2_5@393@01]
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 751 | p1_5@392@01 | live]
; [else-branch: 751 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 751 | p1_5@392@01]
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 752 | p2_5@393@01 | live]
; [else-branch: 752 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 752 | p2_5@393@01]
; [eval] p1_5 ==> issubtype(typeof(c_0.Cell_val), int())
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 753 | p1_5@392@01 | live]
; [else-branch: 753 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 753 | p1_5@392@01]
; [eval] issubtype(typeof(c_0.Cell_val), int())
; [eval] typeof(c_0.Cell_val)
; [eval] int()
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (=>
  p1_5@392@01
  (issubtype<Bool> (typeof<PyType> Cell_val@421@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_5@392@01
  (issubtype<Bool> (typeof<PyType> Cell_val@421@01) (as int<PyType>  PyType))))
; [eval] p2_5 ==> issubtype(typeof(c_0_0.Cell_valp), int())
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 754 | p2_5@393@01 | live]
; [else-branch: 754 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 754 | p2_5@393@01]
; [eval] issubtype(typeof(c_0_0.Cell_valp), int())
; [eval] typeof(c_0_0.Cell_valp)
; [eval] int()
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (=>
  p2_5@393@01
  (issubtype<Bool> (typeof<PyType> Cell_valp@422@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_5@393@01
  (issubtype<Bool> (typeof<PyType> Cell_valp@422@01) (as int<PyType>  PyType))))
; [eval] p1_5 && p2_5 ==> c_0.Cell_val == c_0_0.Cell_valp
; [eval] p1_5 && p2_5
(push) ; 15
; [then-branch: 755 | !(p1_5@392@01) | live]
; [else-branch: 755 | p1_5@392@01 | live]
(push) ; 16
; [then-branch: 755 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 16
(push) ; 16
; [else-branch: 755 | p1_5@392@01]
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not (and p1_5@392@01 p2_5@393@01))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (and p1_5@392@01 p2_5@393@01)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 756 | p1_5@392@01 && p2_5@393@01 | live]
; [else-branch: 756 | !(p1_5@392@01 && p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 756 | p1_5@392@01 && p2_5@393@01]
(assert (and p1_5@392@01 p2_5@393@01))
; [eval] c_0.Cell_val == c_0_0.Cell_valp
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (and p1_5@392@01 p2_5@393@01))
(push) ; 15
(assert (not (=> (and p1_5@392@01 p2_5@393@01) (= Cell_val@421@01 Cell_valp@422@01))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=> (and p1_5@392@01 p2_5@393@01) (= Cell_val@421@01 Cell_valp@422@01)))
; [eval] p1_5 ==> (forperm _r_16: Ref [MustInvokeBounded(_r_16)] :: false) && ((forperm _r_16: Ref [MustInvokeUnbounded(_r_16)] :: false) && ((forperm _r_16: Ref [_r_16.MustReleaseBounded] :: false) && (forperm _r_16: Ref [_r_16.MustReleaseUnbounded] :: false)))
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 757 | p1_5@392@01 | live]
; [else-branch: 757 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 757 | p1_5@392@01]
; [eval] (forperm _r_16: Ref [MustInvokeBounded(_r_16)] :: false) && ((forperm _r_16: Ref [MustInvokeUnbounded(_r_16)] :: false) && ((forperm _r_16: Ref [_r_16.MustReleaseBounded] :: false) && (forperm _r_16: Ref [_r_16.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_16: Ref [MustInvokeBounded(_r_16)] :: false)
(push) ; 17
; [then-branch: 758 | False | live]
; [else-branch: 758 | True | live]
(push) ; 18
; [then-branch: 758 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 758 | True]
; [eval] (forperm _r_16: Ref [MustInvokeUnbounded(_r_16)] :: false)
(push) ; 19
; [then-branch: 759 | False | live]
; [else-branch: 759 | True | live]
(push) ; 20
; [then-branch: 759 | False]
(assert false)
(pop) ; 20
(push) ; 20
; [else-branch: 759 | True]
; [eval] (forperm _r_16: Ref [_r_16.MustReleaseBounded] :: false)
(push) ; 21
; [then-branch: 760 | False | live]
; [else-branch: 760 | True | live]
(push) ; 22
; [then-branch: 760 | False]
(assert false)
(pop) ; 22
(push) ; 22
; [else-branch: 760 | True]
; [eval] (forperm _r_16: Ref [_r_16.MustReleaseUnbounded] :: false)
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(pop) ; 15
; Joined path conditions
; [eval] p2_5 ==> (forperm _r_16: Ref [MustInvokeBounded_0(_r_16)] :: false) && ((forperm _r_16: Ref [MustInvokeUnbounded_0(_r_16)] :: false) && ((forperm _r_16: Ref [_r_16.MustReleaseBoundedp] :: false) && (forperm _r_16: Ref [_r_16.MustReleaseUnboundedp] :: false)))
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 761 | p2_5@393@01 | live]
; [else-branch: 761 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 761 | p2_5@393@01]
; [eval] (forperm _r_16: Ref [MustInvokeBounded_0(_r_16)] :: false) && ((forperm _r_16: Ref [MustInvokeUnbounded_0(_r_16)] :: false) && ((forperm _r_16: Ref [_r_16.MustReleaseBoundedp] :: false) && (forperm _r_16: Ref [_r_16.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_16: Ref [MustInvokeBounded_0(_r_16)] :: false)
(push) ; 17
; [then-branch: 762 | False | live]
; [else-branch: 762 | True | live]
(push) ; 18
; [then-branch: 762 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 762 | True]
; [eval] (forperm _r_16: Ref [MustInvokeUnbounded_0(_r_16)] :: false)
(push) ; 19
; [then-branch: 763 | False | live]
; [else-branch: 763 | True | live]
(push) ; 20
; [then-branch: 763 | False]
(assert false)
(pop) ; 20
(push) ; 20
; [else-branch: 763 | True]
; [eval] (forperm _r_16: Ref [_r_16.MustReleaseBoundedp] :: false)
(push) ; 21
; [then-branch: 764 | False | live]
; [else-branch: 764 | True | live]
(push) ; 22
; [then-branch: 764 | False]
(assert false)
(pop) ; 22
(push) ; 22
; [else-branch: 764 | True]
; [eval] (forperm _r_16: Ref [_r_16.MustReleaseUnboundedp] :: false)
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(pop) ; 15
; Joined path conditions
(pop) ; 14
(pop) ; 13
(pop) ; 12
; [eval] !p2_5
(push) ; 12
(set-option :timeout 10)
(assert (not p2_5@393@01))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 765 | !(p2_5@393@01) | dead]
; [else-branch: 765 | p2_5@393@01 | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 765 | p2_5@393@01]
(assert p2_5@393@01)
(pop) ; 12
(pop) ; 11
; [eval] !p1_5
(push) ; 11
(set-option :timeout 10)
(assert (not p1_5@392@01))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 766 | !(p1_5@392@01) | dead]
; [else-branch: 766 | p1_5@392@01 | live]
(set-option :timeout 0)
(push) ; 11
; [else-branch: 766 | p1_5@392@01]
(assert p1_5@392@01)
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
; [eval] !p2_5
(push) ; 8
(set-option :timeout 10)
(assert (not p2_5@393@01))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 767 | !(p2_5@393@01) | dead]
; [else-branch: 767 | p2_5@393@01 | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 767 | p2_5@393@01]
(assert p2_5@393@01)
(pop) ; 8
(pop) ; 7
; [eval] !p1_5
(push) ; 7
(set-option :timeout 10)
(assert (not p1_5@392@01))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 768 | !(p1_5@392@01) | dead]
; [else-branch: 768 | p1_5@392@01 | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 768 | p1_5@392@01]
(assert p1_5@392@01)
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 716 | !(p2_5@393@01)]
(assert (not p2_5@393@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_5@392@01))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 769 | p1_5@392@01 | live]
; [else-branch: 769 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 769 | p1_5@392@01]
(assert p1_5@392@01)
(assert (not (= c_0@400@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
; [then-branch: 770 | p2_5@393@01 | dead]
; [else-branch: 770 | !(p2_5@393@01) | live]
(push) ; 5
; [else-branch: 770 | !(p2_5@393@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
  $Snap.unit))
; [eval] p1_5 ==> issubtype(typeof(c_0.Cell_val), int())
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 771 | p1_5@392@01 | live]
; [else-branch: 771 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 771 | p1_5@392@01]
; [eval] issubtype(typeof(c_0.Cell_val), int())
; [eval] typeof(c_0.Cell_val)
; [eval] int()
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  p1_5@392@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
  $Snap.unit))
; [eval] p2_5 ==> issubtype(typeof(c_0_0.Cell_valp), int())
(push) ; 6
; [then-branch: 772 | p2_5@393@01 | dead]
; [else-branch: 772 | !(p2_5@393@01) | live]
(push) ; 7
; [else-branch: 772 | !(p2_5@393@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
  $Snap.unit))
; [eval] p1_5 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 773 | p1_5@392@01 | live]
; [else-branch: 773 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 773 | p1_5@392@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
  $Snap.unit))
; [eval] p2_5 ==> true
(push) ; 6
; [then-branch: 774 | p2_5@393@01 | dead]
; [else-branch: 774 | !(p2_5@393@01) | live]
(push) ; 7
; [else-branch: 774 | !(p2_5@393@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@423@01 $Snap)
(assert (= $t@423@01 ($Snap.combine ($Snap.first $t@423@01) ($Snap.second $t@423@01))))
(assert (= ($Snap.first $t@423@01) $Snap.unit))
; [eval] p1_5 ==> (forperm _r_15: Ref [_r_15.MustReleaseBounded] :: Level(_r_15) <= _current_wait_level_165) && ((forperm _r_15: Ref [_r_15.MustReleaseUnbounded] :: Level(_r_15) <= _current_wait_level_165) && _residue_165 <= _current_wait_level_165)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 775 | p1_5@392@01 | live]
; [else-branch: 775 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 775 | p1_5@392@01]
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseBounded] :: Level(_r_15) <= _current_wait_level_165) && ((forperm _r_15: Ref [_r_15.MustReleaseUnbounded] :: Level(_r_15) <= _current_wait_level_165) && _residue_165 <= _current_wait_level_165)
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseBounded] :: Level(_r_15) <= _current_wait_level_165)
(push) ; 9
; [then-branch: 776 | False | live]
; [else-branch: 776 | True | live]
(push) ; 10
; [then-branch: 776 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 776 | True]
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseUnbounded] :: Level(_r_15) <= _current_wait_level_165)
(push) ; 11
; [then-branch: 777 | False | live]
; [else-branch: 777 | True | live]
(push) ; 12
; [then-branch: 777 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 777 | True]
; [eval] _residue_165 <= _current_wait_level_165
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p1_5@392@01 (<= _residue_165@398@01 _current_wait_level_165@402@01)))
(assert (=
  ($Snap.second $t@423@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@423@01))
    ($Snap.second ($Snap.second $t@423@01)))))
(assert (= ($Snap.first ($Snap.second $t@423@01)) $Snap.unit))
; [eval] p2_5 ==> (forperm _r_15: Ref [_r_15.MustReleaseBoundedp] :: Level(_r_15) <= _current_wait_level_165_0) && ((forperm _r_15: Ref [_r_15.MustReleaseUnboundedp] :: Level(_r_15) <= _current_wait_level_165_0) && _residue_165_0 <= _current_wait_level_165_0)
(push) ; 7
; [then-branch: 778 | p2_5@393@01 | dead]
; [else-branch: 778 | !(p2_5@393@01) | live]
(push) ; 8
; [else-branch: 778 | !(p2_5@393@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@423@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@423@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@423@01))))))
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 779 | p1_5@392@01 | live]
; [else-branch: 779 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 779 | p1_5@392@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@423@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@423@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01)))))))
; [then-branch: 780 | p2_5@393@01 | dead]
; [else-branch: 780 | !(p2_5@393@01) | live]
(push) ; 8
; [else-branch: 780 | !(p2_5@393@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@423@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01)))))
  $Snap.unit))
; [eval] p1_5 ==> issubtype(typeof(c_0.Cell_val), int())
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 781 | p1_5@392@01 | live]
; [else-branch: 781 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 781 | p1_5@392@01]
; [eval] issubtype(typeof(c_0.Cell_val), int())
; [eval] typeof(c_0.Cell_val)
; [eval] int()
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  p1_5@392@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@423@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01))))))
  $Snap.unit))
; [eval] p2_5 ==> issubtype(typeof(c_0_0.Cell_valp), int())
(push) ; 9
; [then-branch: 782 | p2_5@393@01 | dead]
; [else-branch: 782 | !(p2_5@393@01) | live]
(push) ; 10
; [else-branch: 782 | !(p2_5@393@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01)))))))
  $Snap.unit))
; [eval] p1_5 && p2_5 ==> c_0.Cell_val == c_0_0.Cell_valp
; [eval] p1_5 && p2_5
(push) ; 9
; [then-branch: 783 | !(p1_5@392@01) | live]
; [else-branch: 783 | p1_5@392@01 | live]
(push) ; 10
; [then-branch: 783 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 10
(push) ; 10
; [else-branch: 783 | p1_5@392@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_5@392@01 (not p1_5@392@01)))
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (and p1_5@392@01 p2_5@393@01))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 784 | p1_5@392@01 && p2_5@393@01 | dead]
; [else-branch: 784 | !(p1_5@392@01 && p2_5@393@01) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 784 | !(p1_5@392@01 && p2_5@393@01)]
(assert (not (and p1_5@392@01 p2_5@393@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (not (and p1_5@392@01 p2_5@393@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01))))))))
  $Snap.unit))
; [eval] p1_5 ==> true
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 785 | p1_5@392@01 | live]
; [else-branch: 785 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 785 | p1_5@392@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@423@01))))))))
  $Snap.unit))
; [eval] p2_5 ==> true
(push) ; 9
; [then-branch: 786 | p2_5@393@01 | dead]
; [else-branch: 786 | !(p2_5@393@01) | live]
(push) ; 10
; [else-branch: 786 | !(p2_5@393@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
(pop) ; 6
(push) ; 6
; [exec]
; var _err: Ref
(declare-const _err@424@01 $Ref)
; [exec]
; var _err_5: Ref
(declare-const _err_5@425@01 $Ref)
; [exec]
; var c_3: Ref
(declare-const c_3@426@01 $Ref)
; [exec]
; var c_3_0: Ref
(declare-const c_3_0@427@01 $Ref)
; [exec]
; var _cwl_165: Perm
(declare-const _cwl_165@428@01 $Perm)
; [exec]
; var _cwl_165_0: Perm
(declare-const _cwl_165_0@429@01 $Perm)
; [exec]
; var _method_measures_165: Seq[Measure$]
(declare-const _method_measures_165@430@01 Seq<Measure$>)
; [exec]
; var _method_measures_165_0: Seq[Measure$]
(declare-const _method_measures_165_0@431@01 Seq<Measure$>)
; [exec]
; var p1_6: Bool
(declare-const p1_6@432@01 Bool)
; [exec]
; var p2_6: Bool
(declare-const p2_6@433@01 Bool)
; [exec]
; var p3_0: Bool
(declare-const p3_0@434@01 Bool)
; [exec]
; var p4_0: Bool
(declare-const p4_0@435@01 Bool)
; [exec]
; inhale p1_5
(declare-const $t@436@01 $Snap)
(assert (= $t@436@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 787 | p1_5@392@01 | live]
; [else-branch: 787 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 787 | p1_5@392@01]
; [exec]
; _method_measures_165 := Seq(Measure$create(true, _cthread_165, 1))
; [eval] Seq(Measure$create(true, _cthread_165, 1))
; [eval] Measure$create(true, _cthread_165, 1)
(assert (=
  (Seq_length
    (Seq_singleton (Measure$create<Measure$> true _cthread_165@394@01 1)))
  1))
(declare-const _method_measures_165@437@01 Seq<Measure$>)
(assert (=
  _method_measures_165@437@01
  (Seq_singleton (Measure$create<Measure$> true _cthread_165@394@01 1))))
; [exec]
; _err := null
; [exec]
; c_3 := c_0
; [then-branch: 788 | p2_5@393@01 | dead]
; [else-branch: 788 | !(p2_5@393@01) | live]
(push) ; 8
; [else-branch: 788 | !(p2_5@393@01)]
(pop) ; 8
; [eval] !p2_5
(push) ; 8
(set-option :timeout 10)
(assert (not p2_5@393@01))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 789 | !(p2_5@393@01) | live]
; [else-branch: 789 | p2_5@393@01 | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 789 | !(p2_5@393@01)]
; [exec]
; p1_6 := p1_5 && perm(_MaySet(c_3, 7809653381050164547)) > none
; [eval] p1_5 && perm(_MaySet(c_3, 7809653381050164547)) > none
(push) ; 9
; [then-branch: 790 | !(p1_5@392@01) | live]
; [else-branch: 790 | p1_5@392@01 | live]
(push) ; 10
; [then-branch: 790 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 10
(push) ; 10
; [else-branch: 790 | p1_5@392@01]
; [eval] perm(_MaySet(c_3, 7809653381050164547)) > none
; [eval] perm(_MaySet(c_3, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_5@392@01 (not p1_5@392@01)))
; [exec]
; p2_6 := p2_5 && perm(_MaySet_0(c_3_0, 7809653381050164547)) > none
; [eval] p2_5 && perm(_MaySet_0(c_3_0, 7809653381050164547)) > none
(push) ; 9
; [then-branch: 791 | !(p2_5@393@01) | live]
; [else-branch: 791 | p2_5@393@01 | live]
(push) ; 10
; [then-branch: 791 | !(p2_5@393@01)]
(pop) ; 10
(push) ; 10
; [else-branch: 791 | p2_5@393@01]
(assert p2_5@393@01)
; [eval] perm(_MaySet_0(c_3_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(c_3_0, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p2_5@393@01 (not p2_5@393@01)))
; [exec]
; p3_0 := p1_5 && !(perm(_MaySet(c_3, 7809653381050164547)) > none)
; [eval] p1_5 && !(perm(_MaySet(c_3, 7809653381050164547)) > none)
(push) ; 9
; [then-branch: 792 | !(p1_5@392@01) | live]
; [else-branch: 792 | p1_5@392@01 | live]
(push) ; 10
; [then-branch: 792 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 10
(push) ; 10
; [else-branch: 792 | p1_5@392@01]
; [eval] !(perm(_MaySet(c_3, 7809653381050164547)) > none)
; [eval] perm(_MaySet(c_3, 7809653381050164547)) > none
; [eval] perm(_MaySet(c_3, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
; [exec]
; p4_0 := p2_5 && !(perm(_MaySet_0(c_3_0, 7809653381050164547)) > none)
; [eval] p2_5 && !(perm(_MaySet_0(c_3_0, 7809653381050164547)) > none)
(push) ; 9
; [then-branch: 793 | !(p2_5@393@01) | live]
; [else-branch: 793 | p2_5@393@01 | live]
(push) ; 10
; [then-branch: 793 | !(p2_5@393@01)]
(pop) ; 10
(push) ; 10
; [else-branch: 793 | p2_5@393@01]
(assert p2_5@393@01)
; [eval] !(perm(_MaySet_0(c_3_0, 7809653381050164547)) > none)
; [eval] perm(_MaySet_0(c_3_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(c_3_0, 7809653381050164547))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
; [then-branch: 794 | False | dead]
; [else-branch: 794 | True | live]
(push) ; 9
; [else-branch: 794 | True]
(pop) ; 9
; [eval] !p1_6
(push) ; 9
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 795 | True | live]
; [else-branch: 795 | False | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 795 | True]
; [then-branch: 796 | False | dead]
; [else-branch: 796 | True | live]
(push) ; 10
; [else-branch: 796 | True]
(pop) ; 10
; [eval] !p2_6
(push) ; 10
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 797 | True | live]
; [else-branch: 797 | False | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 797 | True]
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 798 | p1_5@392@01 | live]
; [else-branch: 798 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 798 | p1_5@392@01]
; [exec]
; c_3.Cell_val := __prim__int___box__(1)
; [eval] __prim__int___box__(1)
(push) ; 12
(assert (__prim__int___box__%precondition $Snap.unit 1))
(pop) ; 12
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 1))
(declare-const Cell_val@438@01 $Ref)
(assert (= Cell_val@438@01 (__prim__int___box__ $Snap.unit 1)))
; [then-branch: 799 | p2_5@393@01 | dead]
; [else-branch: 799 | !(p2_5@393@01) | live]
(push) ; 12
; [else-branch: 799 | !(p2_5@393@01)]
(pop) ; 12
; [eval] !p2_5
(push) ; 12
(set-option :timeout 10)
(assert (not p2_5@393@01))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 800 | !(p2_5@393@01) | live]
; [else-branch: 800 | p2_5@393@01 | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 800 | !(p2_5@393@01)]
; [exec]
; assert true
; [eval] p1_5 ==> true
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 801 | p1_5@392@01 | live]
; [else-branch: 801 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 801 | p1_5@392@01]
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p2_5 ==> true
(push) ; 13
; [then-branch: 802 | p2_5@393@01 | dead]
; [else-branch: 802 | !(p2_5@393@01) | live]
(push) ; 14
; [else-branch: 802 | !(p2_5@393@01)]
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 803 | p1_5@392@01 | live]
; [else-branch: 803 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 803 | p1_5@392@01]
; [then-branch: 804 | p2_5@393@01 | dead]
; [else-branch: 804 | !(p2_5@393@01) | live]
(push) ; 14
; [else-branch: 804 | !(p2_5@393@01)]
; [eval] p1_5 ==> issubtype(typeof(c_0.Cell_val), int())
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 805 | p1_5@392@01 | live]
; [else-branch: 805 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 805 | p1_5@392@01]
; [eval] issubtype(typeof(c_0.Cell_val), int())
; [eval] typeof(c_0.Cell_val)
; [eval] int()
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (=>
  p1_5@392@01
  (issubtype<Bool> (typeof<PyType> Cell_val@438@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_5@392@01
  (issubtype<Bool> (typeof<PyType> Cell_val@438@01) (as int<PyType>  PyType))))
; [eval] p2_5 ==> issubtype(typeof(c_0_0.Cell_valp), int())
(push) ; 15
; [then-branch: 806 | p2_5@393@01 | dead]
; [else-branch: 806 | !(p2_5@393@01) | live]
(push) ; 16
; [else-branch: 806 | !(p2_5@393@01)]
(pop) ; 16
(pop) ; 15
; Joined path conditions
; [eval] p1_5 && p2_5 ==> c_0.Cell_val == c_0_0.Cell_valp
; [eval] p1_5 && p2_5
(push) ; 15
; [then-branch: 807 | !(p1_5@392@01) | live]
; [else-branch: 807 | p1_5@392@01 | live]
(push) ; 16
; [then-branch: 807 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(pop) ; 16
(push) ; 16
; [else-branch: 807 | p1_5@392@01]
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not (and p1_5@392@01 p2_5@393@01))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 808 | p1_5@392@01 && p2_5@393@01 | dead]
; [else-branch: 808 | !(p1_5@392@01 && p2_5@393@01) | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 808 | !(p1_5@392@01 && p2_5@393@01)]
(assert (not (and p1_5@392@01 p2_5@393@01)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (not (and p1_5@392@01 p2_5@393@01)))
; [eval] p1_5 ==> (forperm _r_16: Ref [MustInvokeBounded(_r_16)] :: false) && ((forperm _r_16: Ref [MustInvokeUnbounded(_r_16)] :: false) && ((forperm _r_16: Ref [_r_16.MustReleaseBounded] :: false) && (forperm _r_16: Ref [_r_16.MustReleaseUnbounded] :: false)))
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_5@392@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 809 | p1_5@392@01 | live]
; [else-branch: 809 | !(p1_5@392@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 809 | p1_5@392@01]
; [eval] (forperm _r_16: Ref [MustInvokeBounded(_r_16)] :: false) && ((forperm _r_16: Ref [MustInvokeUnbounded(_r_16)] :: false) && ((forperm _r_16: Ref [_r_16.MustReleaseBounded] :: false) && (forperm _r_16: Ref [_r_16.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_16: Ref [MustInvokeBounded(_r_16)] :: false)
(push) ; 17
; [then-branch: 810 | False | live]
; [else-branch: 810 | True | live]
(push) ; 18
; [then-branch: 810 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 810 | True]
; [eval] (forperm _r_16: Ref [MustInvokeUnbounded(_r_16)] :: false)
(push) ; 19
; [then-branch: 811 | False | live]
; [else-branch: 811 | True | live]
(push) ; 20
; [then-branch: 811 | False]
(assert false)
(pop) ; 20
(push) ; 20
; [else-branch: 811 | True]
; [eval] (forperm _r_16: Ref [_r_16.MustReleaseBounded] :: false)
(push) ; 21
; [then-branch: 812 | False | live]
; [else-branch: 812 | True | live]
(push) ; 22
; [then-branch: 812 | False]
(assert false)
(pop) ; 22
(push) ; 22
; [else-branch: 812 | True]
; [eval] (forperm _r_16: Ref [_r_16.MustReleaseUnbounded] :: false)
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(pop) ; 15
; Joined path conditions
; [eval] p2_5 ==> (forperm _r_16: Ref [MustInvokeBounded_0(_r_16)] :: false) && ((forperm _r_16: Ref [MustInvokeUnbounded_0(_r_16)] :: false) && ((forperm _r_16: Ref [_r_16.MustReleaseBoundedp] :: false) && (forperm _r_16: Ref [_r_16.MustReleaseUnboundedp] :: false)))
(push) ; 15
; [then-branch: 813 | p2_5@393@01 | dead]
; [else-branch: 813 | !(p2_5@393@01) | live]
(push) ; 16
; [else-branch: 813 | !(p2_5@393@01)]
(pop) ; 16
(pop) ; 15
; Joined path conditions
(pop) ; 14
(pop) ; 13
(pop) ; 12
(pop) ; 11
; [eval] !p1_5
; [then-branch: 814 | !(p1_5@392@01) | dead]
; [else-branch: 814 | p1_5@392@01 | live]
(push) ; 11
; [else-branch: 814 | p1_5@392@01]
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
; [eval] !p1_5
; [then-branch: 815 | !(p1_5@392@01) | dead]
; [else-branch: 815 | p1_5@392@01 | live]
(push) ; 7
; [else-branch: 815 | p1_5@392@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [else-branch: 715 | !(p1_5@392@01)]
(assert (not p1_5@392@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_5@393@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 816 | p2_5@393@01 | live]
; [else-branch: 816 | !(p2_5@393@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 816 | p2_5@393@01]
(assert p2_5@393@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
; [then-branch: 817 | p1_5@392@01 | dead]
; [else-branch: 817 | !(p1_5@392@01) | live]
(push) ; 4
; [else-branch: 817 | !(p1_5@392@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 818 | p2_5@393@01 | live]
; [else-branch: 818 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 818 | p2_5@393@01]
(assert (not (= c_0_0@401@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
  $Snap.unit))
; [eval] p1_5 ==> issubtype(typeof(c_0.Cell_val), int())
(push) ; 6
; [then-branch: 819 | p1_5@392@01 | dead]
; [else-branch: 819 | !(p1_5@392@01) | live]
(push) ; 7
; [else-branch: 819 | !(p1_5@392@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
  $Snap.unit))
; [eval] p2_5 ==> issubtype(typeof(c_0_0.Cell_valp), int())
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 820 | p2_5@393@01 | live]
; [else-branch: 820 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 820 | p2_5@393@01]
; [eval] issubtype(typeof(c_0_0.Cell_valp), int())
; [eval] typeof(c_0_0.Cell_valp)
; [eval] int()
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  p2_5@393@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
  $Snap.unit))
; [eval] p1_5 ==> true
(push) ; 6
; [then-branch: 821 | p1_5@392@01 | dead]
; [else-branch: 821 | !(p1_5@392@01) | live]
(push) ; 7
; [else-branch: 821 | !(p1_5@392@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
  $Snap.unit))
; [eval] p2_5 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 822 | p2_5@393@01 | live]
; [else-branch: 822 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 822 | p2_5@393@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@439@01 $Snap)
(assert (= $t@439@01 ($Snap.combine ($Snap.first $t@439@01) ($Snap.second $t@439@01))))
(assert (= ($Snap.first $t@439@01) $Snap.unit))
; [eval] p1_5 ==> (forperm _r_15: Ref [_r_15.MustReleaseBounded] :: Level(_r_15) <= _current_wait_level_165) && ((forperm _r_15: Ref [_r_15.MustReleaseUnbounded] :: Level(_r_15) <= _current_wait_level_165) && _residue_165 <= _current_wait_level_165)
(push) ; 7
; [then-branch: 823 | p1_5@392@01 | dead]
; [else-branch: 823 | !(p1_5@392@01) | live]
(push) ; 8
; [else-branch: 823 | !(p1_5@392@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second $t@439@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@439@01))
    ($Snap.second ($Snap.second $t@439@01)))))
(assert (= ($Snap.first ($Snap.second $t@439@01)) $Snap.unit))
; [eval] p2_5 ==> (forperm _r_15: Ref [_r_15.MustReleaseBoundedp] :: Level(_r_15) <= _current_wait_level_165_0) && ((forperm _r_15: Ref [_r_15.MustReleaseUnboundedp] :: Level(_r_15) <= _current_wait_level_165_0) && _residue_165_0 <= _current_wait_level_165_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 824 | p2_5@393@01 | live]
; [else-branch: 824 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 824 | p2_5@393@01]
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseBoundedp] :: Level(_r_15) <= _current_wait_level_165_0) && ((forperm _r_15: Ref [_r_15.MustReleaseUnboundedp] :: Level(_r_15) <= _current_wait_level_165_0) && _residue_165_0 <= _current_wait_level_165_0)
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseBoundedp] :: Level(_r_15) <= _current_wait_level_165_0)
(push) ; 9
; [then-branch: 825 | False | live]
; [else-branch: 825 | True | live]
(push) ; 10
; [then-branch: 825 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 825 | True]
; [eval] (forperm _r_15: Ref [_r_15.MustReleaseUnboundedp] :: Level(_r_15) <= _current_wait_level_165_0)
(push) ; 11
; [then-branch: 826 | False | live]
; [else-branch: 826 | True | live]
(push) ; 12
; [then-branch: 826 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 826 | True]
; [eval] _residue_165_0 <= _current_wait_level_165_0
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p2_5@393@01 (<= _residue_165_0@399@01 _current_wait_level_165_0@403@01)))
(assert (=
  ($Snap.second ($Snap.second $t@439@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@439@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@439@01))))))
; [then-branch: 827 | p1_5@392@01 | dead]
; [else-branch: 827 | !(p1_5@392@01) | live]
(push) ; 7
; [else-branch: 827 | !(p1_5@392@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@439@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@439@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@439@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01)))))))
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 828 | p2_5@393@01 | live]
; [else-branch: 828 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 828 | p2_5@393@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01)))))
  $Snap.unit))
; [eval] p1_5 ==> issubtype(typeof(c_0.Cell_val), int())
(push) ; 9
; [then-branch: 829 | p1_5@392@01 | dead]
; [else-branch: 829 | !(p1_5@392@01) | live]
(push) ; 10
; [else-branch: 829 | !(p1_5@392@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01))))))
  $Snap.unit))
; [eval] p2_5 ==> issubtype(typeof(c_0_0.Cell_valp), int())
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 830 | p2_5@393@01 | live]
; [else-branch: 830 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 830 | p2_5@393@01]
; [eval] issubtype(typeof(c_0_0.Cell_valp), int())
; [eval] typeof(c_0_0.Cell_valp)
; [eval] int()
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  p2_5@393@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@439@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01)))))))
  $Snap.unit))
; [eval] p1_5 && p2_5 ==> c_0.Cell_val == c_0_0.Cell_valp
; [eval] p1_5 && p2_5
(push) ; 9
; [then-branch: 831 | !(p1_5@392@01) | live]
; [else-branch: 831 | p1_5@392@01 | live]
(push) ; 10
; [then-branch: 831 | !(p1_5@392@01)]
(pop) ; 10
(push) ; 10
; [else-branch: 831 | p1_5@392@01]
(assert p1_5@392@01)
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_5@392@01 (not p1_5@392@01)))
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (and p1_5@392@01 p2_5@393@01))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 832 | p1_5@392@01 && p2_5@393@01 | dead]
; [else-branch: 832 | !(p1_5@392@01 && p2_5@393@01) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 832 | !(p1_5@392@01 && p2_5@393@01)]
(assert (not (and p1_5@392@01 p2_5@393@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (not (and p1_5@392@01 p2_5@393@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01))))))))
  $Snap.unit))
; [eval] p1_5 ==> true
(push) ; 9
; [then-branch: 833 | p1_5@392@01 | dead]
; [else-branch: 833 | !(p1_5@392@01) | live]
(push) ; 10
; [else-branch: 833 | !(p1_5@392@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@439@01))))))))
  $Snap.unit))
; [eval] p2_5 ==> true
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_5@393@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 834 | p2_5@393@01 | live]
; [else-branch: 834 | !(p2_5@393@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 834 | p2_5@393@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
(pop) ; 6
(push) ; 6
; [exec]
; var _err: Ref
(declare-const _err@440@01 $Ref)
; [exec]
; var _err_5: Ref
(declare-const _err_5@441@01 $Ref)
; [exec]
; var c_3: Ref
(declare-const c_3@442@01 $Ref)
; [exec]
; var c_3_0: Ref
(declare-const c_3_0@443@01 $Ref)
; [exec]
; var _cwl_165: Perm
(declare-const _cwl_165@444@01 $Perm)
; [exec]
; var _cwl_165_0: Perm
(declare-const _cwl_165_0@445@01 $Perm)
; [exec]
; var _method_measures_165: Seq[Measure$]
(declare-const _method_measures_165@446@01 Seq<Measure$>)
; [exec]
; var _method_measures_165_0: Seq[Measure$]
(declare-const _method_measures_165_0@447@01 Seq<Measure$>)
; [exec]
; var p1_6: Bool
(declare-const p1_6@448@01 Bool)
; [exec]
; var p2_6: Bool
(declare-const p2_6@449@01 Bool)
; [exec]
; var p3_0: Bool
(declare-const p3_0@450@01 Bool)
; [exec]
; var p4_0: Bool
(declare-const p4_0@451@01 Bool)
; [exec]
; inhale p1_5
(declare-const $t@452@01 $Snap)
(assert (= $t@452@01 $Snap.unit))
(assert p1_5@392@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 835 | p1_5@392@01 | dead]
; [else-branch: 835 | !(p1_5@392@01) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 835 | !(p1_5@392@01)]
(pop) ; 7
; [eval] !p1_5
; [then-branch: 836 | !(p1_5@392@01) | dead]
; [else-branch: 836 | p1_5@392@01 | live]
(push) ; 7
; [else-branch: 836 | p1_5@392@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 816 | !(p2_5@393@01)]
(assert (not p2_5@393@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
; [then-branch: 837 | p1_5@392@01 | dead]
; [else-branch: 837 | !(p1_5@392@01) | live]
(push) ; 4
; [else-branch: 837 | !(p1_5@392@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
; [then-branch: 838 | p2_5@393@01 | dead]
; [else-branch: 838 | !(p2_5@393@01) | live]
(push) ; 5
; [else-branch: 838 | !(p2_5@393@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
  $Snap.unit))
; [eval] p1_5 ==> issubtype(typeof(c_0.Cell_val), int())
(push) ; 6
; [then-branch: 839 | p1_5@392@01 | dead]
; [else-branch: 839 | !(p1_5@392@01) | live]
(push) ; 7
; [else-branch: 839 | !(p1_5@392@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
  $Snap.unit))
; [eval] p2_5 ==> issubtype(typeof(c_0_0.Cell_valp), int())
(push) ; 6
; [then-branch: 840 | p2_5@393@01 | dead]
; [else-branch: 840 | !(p2_5@393@01) | live]
(push) ; 7
; [else-branch: 840 | !(p2_5@393@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
  $Snap.unit))
; [eval] p1_5 ==> true
(push) ; 6
; [then-branch: 841 | p1_5@392@01 | dead]
; [else-branch: 841 | !(p1_5@392@01) | live]
(push) ; 7
; [else-branch: 841 | !(p1_5@392@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@404@01)))))))))))))
  $Snap.unit))
; [eval] p2_5 ==> true
(push) ; 6
; [then-branch: 842 | p2_5@393@01 | dead]
; [else-branch: 842 | !(p2_5@393@01) | live]
(push) ; 7
; [else-branch: 842 | !(p2_5@393@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@453@01 $Snap)
(assert (= $t@453@01 ($Snap.combine ($Snap.first $t@453@01) ($Snap.second $t@453@01))))
(assert (= ($Snap.first $t@453@01) $Snap.unit))
; [eval] p1_5 ==> (forperm _r_15: Ref [_r_15.MustReleaseBounded] :: Level(_r_15) <= _current_wait_level_165) && ((forperm _r_15: Ref [_r_15.MustReleaseUnbounded] :: Level(_r_15) <= _current_wait_level_165) && _residue_165 <= _current_wait_level_165)
(push) ; 7
; [then-branch: 843 | p1_5@392@01 | dead]
; [else-branch: 843 | !(p1_5@392@01) | live]
(push) ; 8
; [else-branch: 843 | !(p1_5@392@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second $t@453@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@453@01))
    ($Snap.second ($Snap.second $t@453@01)))))
(assert (= ($Snap.first ($Snap.second $t@453@01)) $Snap.unit))
; [eval] p2_5 ==> (forperm _r_15: Ref [_r_15.MustReleaseBoundedp] :: Level(_r_15) <= _current_wait_level_165_0) && ((forperm _r_15: Ref [_r_15.MustReleaseUnboundedp] :: Level(_r_15) <= _current_wait_level_165_0) && _residue_165_0 <= _current_wait_level_165_0)
(push) ; 7
; [then-branch: 844 | p2_5@393@01 | dead]
; [else-branch: 844 | !(p2_5@393@01) | live]
(push) ; 8
; [else-branch: 844 | !(p2_5@393@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@453@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@453@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@453@01))))))
; [then-branch: 845 | p1_5@392@01 | dead]
; [else-branch: 845 | !(p1_5@392@01) | live]
(push) ; 7
; [else-branch: 845 | !(p1_5@392@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@453@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@453@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@453@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01)))))))
; [then-branch: 846 | p2_5@393@01 | dead]
; [else-branch: 846 | !(p2_5@393@01) | live]
(push) ; 8
; [else-branch: 846 | !(p2_5@393@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@453@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01)))))
  $Snap.unit))
; [eval] p1_5 ==> issubtype(typeof(c_0.Cell_val), int())
(push) ; 9
; [then-branch: 847 | p1_5@392@01 | dead]
; [else-branch: 847 | !(p1_5@392@01) | live]
(push) ; 10
; [else-branch: 847 | !(p1_5@392@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01))))))
  $Snap.unit))
; [eval] p2_5 ==> issubtype(typeof(c_0_0.Cell_valp), int())
(push) ; 9
; [then-branch: 848 | p2_5@393@01 | dead]
; [else-branch: 848 | !(p2_5@393@01) | live]
(push) ; 10
; [else-branch: 848 | !(p2_5@393@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01)))))))
  $Snap.unit))
; [eval] p1_5 && p2_5 ==> c_0.Cell_val == c_0_0.Cell_valp
; [eval] p1_5 && p2_5
(push) ; 9
; [then-branch: 849 | !(p1_5@392@01) | live]
; [else-branch: 849 | p1_5@392@01 | live]
(push) ; 10
; [then-branch: 849 | !(p1_5@392@01)]
(pop) ; 10
(push) ; 10
; [else-branch: 849 | p1_5@392@01]
(assert p1_5@392@01)
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (or p1_5@392@01 (not p1_5@392@01)))
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (and p1_5@392@01 p2_5@393@01))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 850 | p1_5@392@01 && p2_5@393@01 | dead]
; [else-branch: 850 | !(p1_5@392@01 && p2_5@393@01) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 850 | !(p1_5@392@01 && p2_5@393@01)]
(assert (not (and p1_5@392@01 p2_5@393@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (not (and p1_5@392@01 p2_5@393@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01))))))))
  $Snap.unit))
; [eval] p1_5 ==> true
(push) ; 9
; [then-branch: 851 | p1_5@392@01 | dead]
; [else-branch: 851 | !(p1_5@392@01) | live]
(push) ; 10
; [else-branch: 851 | !(p1_5@392@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@453@01))))))))
  $Snap.unit))
; [eval] p2_5 ==> true
(push) ; 9
; [then-branch: 852 | p2_5@393@01 | dead]
; [else-branch: 852 | !(p2_5@393@01) | live]
(push) ; 10
; [else-branch: 852 | !(p2_5@393@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
(pop) ; 6
(push) ; 6
; [exec]
; var _err: Ref
(declare-const _err@454@01 $Ref)
; [exec]
; var _err_5: Ref
(declare-const _err_5@455@01 $Ref)
; [exec]
; var c_3: Ref
(declare-const c_3@456@01 $Ref)
; [exec]
; var c_3_0: Ref
(declare-const c_3_0@457@01 $Ref)
; [exec]
; var _cwl_165: Perm
(declare-const _cwl_165@458@01 $Perm)
; [exec]
; var _cwl_165_0: Perm
(declare-const _cwl_165_0@459@01 $Perm)
; [exec]
; var _method_measures_165: Seq[Measure$]
(declare-const _method_measures_165@460@01 Seq<Measure$>)
; [exec]
; var _method_measures_165_0: Seq[Measure$]
(declare-const _method_measures_165_0@461@01 Seq<Measure$>)
; [exec]
; var p1_6: Bool
(declare-const p1_6@462@01 Bool)
; [exec]
; var p2_6: Bool
(declare-const p2_6@463@01 Bool)
; [exec]
; var p3_0: Bool
(declare-const p3_0@464@01 Bool)
; [exec]
; var p4_0: Bool
(declare-const p4_0@465@01 Bool)
; [exec]
; inhale p1_5
(declare-const $t@466@01 $Snap)
(assert (= $t@466@01 $Snap.unit))
(assert p1_5@392@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 853 | p1_5@392@01 | dead]
; [else-branch: 853 | !(p1_5@392@01) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 853 | !(p1_5@392@01)]
(pop) ; 7
; [eval] !p1_5
; [then-branch: 854 | !(p1_5@392@01) | dead]
; [else-branch: 854 | p1_5@392@01 | live]
(push) ; 7
; [else-branch: 854 | p1_5@392@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- client ----------
(declare-const p1_7@467@01 Bool)
(declare-const p2_7@468@01 Bool)
(declare-const _cthread_166@469@01 $Ref)
(declare-const _cthread_166_0@470@01 $Ref)
(declare-const _caller_measures_166@471@01 Seq<Measure$>)
(declare-const _caller_measures_166_0@472@01 Seq<Measure$>)
(declare-const _residue_166@473@01 $Perm)
(declare-const _residue_166_0@474@01 $Perm)
(declare-const secret@475@01 $Ref)
(declare-const secret_7@476@01 $Ref)
(declare-const _current_wait_level_166@477@01 $Perm)
(declare-const _current_wait_level_166_0@478@01 $Perm)
(declare-const p1_7@479@01 Bool)
(declare-const p2_7@480@01 Bool)
(declare-const _cthread_166@481@01 $Ref)
(declare-const _cthread_166_0@482@01 $Ref)
(declare-const _caller_measures_166@483@01 Seq<Measure$>)
(declare-const _caller_measures_166_0@484@01 Seq<Measure$>)
(declare-const _residue_166@485@01 $Perm)
(declare-const _residue_166_0@486@01 $Perm)
(declare-const secret@487@01 $Ref)
(declare-const secret_7@488@01 $Ref)
(declare-const _current_wait_level_166@489@01 $Perm)
(declare-const _current_wait_level_166_0@490@01 $Perm)
(push) ; 1
(declare-const $t@491@01 $Snap)
(assert (= $t@491@01 ($Snap.combine ($Snap.first $t@491@01) ($Snap.second $t@491@01))))
(assert (= ($Snap.first $t@491@01) $Snap.unit))
; [eval] p1_7 ==> _cthread_166 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_7@479@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 855 | p1_7@479@01 | live]
; [else-branch: 855 | !(p1_7@479@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 855 | p1_7@479@01]
(assert p1_7@479@01)
; [eval] _cthread_166 != null
(pop) ; 3
(push) ; 3
; [else-branch: 855 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_7@479@01) p1_7@479@01))
(assert (=> p1_7@479@01 (not (= _cthread_166@481@01 $Ref.null))))
(assert (=
  ($Snap.second $t@491@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@491@01))
    ($Snap.second ($Snap.second $t@491@01)))))
(assert (= ($Snap.first ($Snap.second $t@491@01)) $Snap.unit))
; [eval] p2_7 ==> _cthread_166_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_7@480@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 856 | p2_7@480@01 | live]
; [else-branch: 856 | !(p2_7@480@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 856 | p2_7@480@01]
(assert p2_7@480@01)
; [eval] _cthread_166_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 856 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_7@480@01) p2_7@480@01))
(assert (=> p2_7@480@01 (not (= _cthread_166_0@482@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@491@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@491@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@491@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@491@01))) $Snap.unit))
; [eval] p1_7 ==> issubtype(typeof(_cthread_166), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_7@479@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 857 | p1_7@479@01 | live]
; [else-branch: 857 | !(p1_7@479@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 857 | p1_7@479@01]
(assert p1_7@479@01)
; [eval] issubtype(typeof(_cthread_166), Thread_0())
; [eval] typeof(_cthread_166)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 857 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> _cthread_166@481@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@491@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@491@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@491@01))))
  $Snap.unit))
; [eval] p2_7 ==> issubtype(typeof(_cthread_166_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_7@480@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 858 | p2_7@480@01 | live]
; [else-branch: 858 | !(p2_7@480@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 858 | p2_7@480@01]
(assert p2_7@480@01)
; [eval] issubtype(typeof(_cthread_166_0), Thread_0())
; [eval] typeof(_cthread_166_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 858 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> _cthread_166_0@482@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01)))))
  $Snap.unit))
; [eval] p1_7 ==> issubtype(typeof(secret), bool())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_7@479@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 859 | p1_7@479@01 | live]
; [else-branch: 859 | !(p1_7@479@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 859 | p1_7@479@01]
(assert p1_7@479@01)
; [eval] issubtype(typeof(secret), bool())
; [eval] typeof(secret)
; [eval] bool()
(pop) ; 3
(push) ; 3
; [else-branch: 859 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> secret@487@01) (as bool<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01))))))
  $Snap.unit))
; [eval] p2_7 ==> issubtype(typeof(secret_7), bool())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_7@480@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 860 | p2_7@480@01 | live]
; [else-branch: 860 | !(p2_7@480@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 860 | p2_7@480@01]
(assert p2_7@480@01)
; [eval] issubtype(typeof(secret_7), bool())
; [eval] typeof(secret_7)
; [eval] bool()
(pop) ; 3
(push) ; 3
; [else-branch: 860 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> secret_7@488@01) (as bool<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01)))))))
  $Snap.unit))
; [eval] p1_7 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_7@479@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 861 | p1_7@479@01 | live]
; [else-branch: 861 | !(p1_7@479@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 861 | p1_7@479@01]
(assert p1_7@479@01)
(pop) ; 3
(push) ; 3
; [else-branch: 861 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@491@01)))))))
  $Snap.unit))
; [eval] p2_7 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_7@480@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 862 | p2_7@480@01 | live]
; [else-branch: 862 | !(p2_7@480@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 862 | p2_7@480@01]
(assert p2_7@480@01)
(pop) ; 3
(push) ; 3
; [else-branch: 862 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@492@01 $Snap)
(assert (= $t@492@01 ($Snap.combine ($Snap.first $t@492@01) ($Snap.second $t@492@01))))
(assert (= ($Snap.first $t@492@01) $Snap.unit))
; [eval] p1_7 ==> (forperm _r_22: Ref [_r_22.MustReleaseBounded] :: Level(_r_22) <= _current_wait_level_166) && ((forperm _r_22: Ref [_r_22.MustReleaseUnbounded] :: Level(_r_22) <= _current_wait_level_166) && _residue_166 <= _current_wait_level_166)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_7@479@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 863 | p1_7@479@01 | live]
; [else-branch: 863 | !(p1_7@479@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 863 | p1_7@479@01]
(assert p1_7@479@01)
; [eval] (forperm _r_22: Ref [_r_22.MustReleaseBounded] :: Level(_r_22) <= _current_wait_level_166) && ((forperm _r_22: Ref [_r_22.MustReleaseUnbounded] :: Level(_r_22) <= _current_wait_level_166) && _residue_166 <= _current_wait_level_166)
; [eval] (forperm _r_22: Ref [_r_22.MustReleaseBounded] :: Level(_r_22) <= _current_wait_level_166)
(push) ; 5
; [then-branch: 864 | False | live]
; [else-branch: 864 | True | live]
(push) ; 6
; [then-branch: 864 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 864 | True]
; [eval] (forperm _r_22: Ref [_r_22.MustReleaseUnbounded] :: Level(_r_22) <= _current_wait_level_166)
(push) ; 7
; [then-branch: 865 | False | live]
; [else-branch: 865 | True | live]
(push) ; 8
; [then-branch: 865 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 865 | True]
; [eval] _residue_166 <= _current_wait_level_166
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 863 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p1_7@479@01 (<= _residue_166@485@01 _current_wait_level_166@489@01)))
(assert (=
  ($Snap.second $t@492@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@492@01))
    ($Snap.second ($Snap.second $t@492@01)))))
(assert (= ($Snap.first ($Snap.second $t@492@01)) $Snap.unit))
; [eval] p2_7 ==> (forperm _r_22: Ref [_r_22.MustReleaseBoundedp] :: Level(_r_22) <= _current_wait_level_166_0) && ((forperm _r_22: Ref [_r_22.MustReleaseUnboundedp] :: Level(_r_22) <= _current_wait_level_166_0) && _residue_166_0 <= _current_wait_level_166_0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_7@480@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 866 | p2_7@480@01 | live]
; [else-branch: 866 | !(p2_7@480@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 866 | p2_7@480@01]
(assert p2_7@480@01)
; [eval] (forperm _r_22: Ref [_r_22.MustReleaseBoundedp] :: Level(_r_22) <= _current_wait_level_166_0) && ((forperm _r_22: Ref [_r_22.MustReleaseUnboundedp] :: Level(_r_22) <= _current_wait_level_166_0) && _residue_166_0 <= _current_wait_level_166_0)
; [eval] (forperm _r_22: Ref [_r_22.MustReleaseBoundedp] :: Level(_r_22) <= _current_wait_level_166_0)
(push) ; 5
; [then-branch: 867 | False | live]
; [else-branch: 867 | True | live]
(push) ; 6
; [then-branch: 867 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 867 | True]
; [eval] (forperm _r_22: Ref [_r_22.MustReleaseUnboundedp] :: Level(_r_22) <= _current_wait_level_166_0)
(push) ; 7
; [then-branch: 868 | False | live]
; [else-branch: 868 | True | live]
(push) ; 8
; [then-branch: 868 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 868 | True]
; [eval] _residue_166_0 <= _current_wait_level_166_0
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 866 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p2_7@480@01 (<= _residue_166_0@486@01 _current_wait_level_166_0@490@01)))
(assert (=
  ($Snap.second ($Snap.second $t@492@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@492@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@492@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@492@01))) $Snap.unit))
; [eval] p1_7 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_7@479@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 869 | p1_7@479@01 | live]
; [else-branch: 869 | !(p1_7@479@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 869 | p1_7@479@01]
(assert p1_7@479@01)
(pop) ; 4
(push) ; 4
; [else-branch: 869 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@492@01))) $Snap.unit))
; [eval] p2_7 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_7@480@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 870 | p2_7@480@01 | live]
; [else-branch: 870 | !(p2_7@480@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 870 | p2_7@480@01]
(assert p2_7@480@01)
(pop) ; 4
(push) ; 4
; [else-branch: 870 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
(push) ; 2
; [exec]
; var _err: Ref
(declare-const _err@493@01 $Ref)
; [exec]
; var _err_6: Ref
(declare-const _err_6@494@01 $Ref)
; [exec]
; var c1: Ref
(declare-const c1@495@01 $Ref)
; [exec]
; var c1_0: Ref
(declare-const c1_0@496@01 $Ref)
; [exec]
; var l1: Ref
(declare-const l1@497@01 $Ref)
; [exec]
; var l1_0: Ref
(declare-const l1_0@498@01 $Ref)
; [exec]
; var c2: Ref
(declare-const c2@499@01 $Ref)
; [exec]
; var c2_0: Ref
(declare-const c2_0@500@01 $Ref)
; [exec]
; var l2: Ref
(declare-const l2@501@01 $Ref)
; [exec]
; var l2_0: Ref
(declare-const l2_0@502@01 $Ref)
; [exec]
; var x_2: Ref
(declare-const x_2@503@01 $Ref)
; [exec]
; var x_2_0: Ref
(declare-const x_2_0@504@01 $Ref)
; [exec]
; var t1: Ref
(declare-const t1@505@01 $Ref)
; [exec]
; var t1_14: Ref
(declare-const t1_14@506@01 $Ref)
; [exec]
; var t2: Ref
(declare-const t2@507@01 $Ref)
; [exec]
; var t2_14: Ref
(declare-const t2_14@508@01 $Ref)
; [exec]
; var secret_3: Ref
(declare-const secret_3@509@01 $Ref)
; [exec]
; var secret_3_0: Ref
(declare-const secret_3_0@510@01 $Ref)
; [exec]
; var Cell_res: Ref
(declare-const Cell_res@511@01 $Ref)
; [exec]
; var Cell_res_2: Ref
(declare-const Cell_res_2@512@01 $Ref)
; [exec]
; var CellLock_res: Ref
(declare-const CellLock_res@513@01 $Ref)
; [exec]
; var CellLock_res_1: Ref
(declare-const CellLock_res_1@514@01 $Ref)
; [exec]
; var Cell_res_0: Ref
(declare-const Cell_res_0@515@01 $Ref)
; [exec]
; var Cell_res_0_0: Ref
(declare-const Cell_res_0_0@516@01 $Ref)
; [exec]
; var CellLock_res_0: Ref
(declare-const CellLock_res_0@517@01 $Ref)
; [exec]
; var CellLock_res_0_0: Ref
(declare-const CellLock_res_0_0@518@01 $Ref)
; [exec]
; var threadingVar: Ref
(declare-const threadingVar@519@01 $Ref)
; [exec]
; var threadingVar_6: Ref
(declare-const threadingVar_6@520@01 $Ref)
; [exec]
; var threadingVar_0: Ref
(declare-const threadingVar_0@521@01 $Ref)
; [exec]
; var threadingVar_0_0: Ref
(declare-const threadingVar_0_0@522@01 $Ref)
; [exec]
; var thread_arg: Ref
(declare-const thread_arg@523@01 $Ref)
; [exec]
; var thread_arg_9: Ref
(declare-const thread_arg_9@524@01 $Ref)
; [exec]
; var thread_arg_0: Ref
(declare-const thread_arg_0@525@01 $Ref)
; [exec]
; var thread_arg_0_0: Ref
(declare-const thread_arg_0_0@526@01 $Ref)
; [exec]
; var thread_arg_1: Ref
(declare-const thread_arg_1@527@01 $Ref)
; [exec]
; var thread_arg_1_0: Ref
(declare-const thread_arg_1_0@528@01 $Ref)
; [exec]
; var thread_arg_2: Ref
(declare-const thread_arg_2@529@01 $Ref)
; [exec]
; var thread_arg_2_0: Ref
(declare-const thread_arg_2_0@530@01 $Ref)
; [exec]
; var _cwl_166: Perm
(declare-const _cwl_166@531@01 $Perm)
; [exec]
; var _cwl_166_0: Perm
(declare-const _cwl_166_0@532@01 $Perm)
; [exec]
; var _method_measures_166: Seq[Measure$]
(declare-const _method_measures_166@533@01 Seq<Measure$>)
; [exec]
; var _method_measures_166_0: Seq[Measure$]
(declare-const _method_measures_166_0@534@01 Seq<Measure$>)
; [exec]
; var tmp: Ref
(declare-const tmp@535@01 $Ref)
; [exec]
; var tmp_0: Ref
(declare-const tmp_0@536@01 $Ref)
; [exec]
; var tmp_1: Ref
(declare-const tmp_1@537@01 $Ref)
; [exec]
; var tmp_2: Ref
(declare-const tmp_2@538@01 $Ref)
; [exec]
; var p1_8: Bool
(declare-const p1_8@539@01 Bool)
; [exec]
; var p2_8: Bool
(declare-const p2_8@540@01 Bool)
; [exec]
; var p3_1: Bool
(declare-const p3_1@541@01 Bool)
; [exec]
; var p4_1: Bool
(declare-const p4_1@542@01 Bool)
; [exec]
; var tmp_3: Ref
(declare-const tmp_3@543@01 $Ref)
; [exec]
; var tmp_4: Ref
(declare-const tmp_4@544@01 $Ref)
; [exec]
; var p1_9: Bool
(declare-const p1_9@545@01 Bool)
; [exec]
; var p2_9: Bool
(declare-const p2_9@546@01 Bool)
; [exec]
; var p3_2: Bool
(declare-const p3_2@547@01 Bool)
; [exec]
; var p4_2: Bool
(declare-const p4_2@548@01 Bool)
; [exec]
; var p1_10: Bool
(declare-const p1_10@549@01 Bool)
; [exec]
; var p2_10: Bool
(declare-const p2_10@550@01 Bool)
; [exec]
; var p3_3: Bool
(declare-const p3_3@551@01 Bool)
; [exec]
; var p4_3: Bool
(declare-const p4_3@552@01 Bool)
; [exec]
; inhale p1_7
(declare-const $t@553@01 $Snap)
(assert (= $t@553@01 $Snap.unit))
(assert p1_7@479@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 871 | p1_7@479@01 | live]
; [else-branch: 871 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 871 | p1_7@479@01]
; [exec]
; _method_measures_166 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err := null
; [exec]
; secret_3 := secret
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_7@480@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 872 | p2_7@480@01 | live]
; [else-branch: 872 | !(p2_7@480@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 872 | p2_7@480@01]
(assert p2_7@480@01)
; [exec]
; _method_measures_166_0 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err_6 := null
; [exec]
; secret_3_0 := secret_7
; [exec]
; tmp := new()
(declare-const tmp@554@01 $Ref)
(assert (not (= tmp@554@01 $Ref.null)))
(assert (not (= tmp@554@01 tmp_1@537@01)))
(assert (not (= tmp@554@01 l2@501@01)))
(assert (not (= tmp@554@01 secret_7@488@01)))
(assert (not (= tmp@554@01 t2_14@508@01)))
(assert (not (= tmp@554@01 c2_0@500@01)))
(assert (not (= tmp@554@01 c1_0@496@01)))
(assert (not (= tmp@554@01 thread_arg_2@529@01)))
(assert (not (= tmp@554@01 threadingVar_6@520@01)))
(assert (not (= tmp@554@01 Cell_res_0@515@01)))
(assert (not (= tmp@554@01 threadingVar_0@521@01)))
(assert (not (= tmp@554@01 secret@487@01)))
(assert (not (= tmp@554@01 l1@497@01)))
(assert (not (= tmp@554@01 CellLock_res_1@514@01)))
(assert (not (= tmp@554@01 tmp_3@543@01)))
(assert (not (= tmp@554@01 thread_arg_9@524@01)))
(assert (not (= tmp@554@01 Cell_res_0_0@516@01)))
(assert (not (= tmp@554@01 CellLock_res_0@517@01)))
(assert (not (= tmp@554@01 tmp@535@01)))
(assert (not (= tmp@554@01 thread_arg_0_0@526@01)))
(assert (not (= tmp@554@01 c1@495@01)))
(assert (not (= tmp@554@01 c2@499@01)))
(assert (not (= tmp@554@01 thread_arg_2_0@530@01)))
(assert (not (= tmp@554@01 _cthread_166_0@482@01)))
(assert (not (= tmp@554@01 tmp_0@536@01)))
(assert (not (= tmp@554@01 Cell_res_2@512@01)))
(assert (not (= tmp@554@01 thread_arg_1_0@528@01)))
(assert (not (= tmp@554@01 CellLock_res_0_0@518@01)))
(assert (not (= tmp@554@01 x_2@503@01)))
(assert (not (= tmp@554@01 threadingVar@519@01)))
(assert (not (= tmp@554@01 threadingVar_0_0@522@01)))
(assert (not (= tmp@554@01 t2@507@01)))
(assert (not (= tmp@554@01 x_2_0@504@01)))
(assert (not (= tmp@554@01 Cell_res@511@01)))
(assert (not (= tmp@554@01 tmp_2@538@01)))
(assert (not (= tmp@554@01 _cthread_166@481@01)))
(assert (not (= tmp@554@01 l2_0@502@01)))
(assert (not (= tmp@554@01 tmp_4@544@01)))
(assert (not (= tmp@554@01 thread_arg@523@01)))
(assert (not (= tmp@554@01 thread_arg_1@527@01)))
(assert (not (= tmp@554@01 CellLock_res@513@01)))
(assert (not (= tmp@554@01 l1_0@498@01)))
(assert (not (= tmp@554@01 thread_arg_0@525@01)))
(assert (not (= tmp@554@01 t1_14@506@01)))
(assert (not (= tmp@554@01 t1@505@01)))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 873 | p1_7@479@01 | live]
; [else-branch: 873 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 873 | p1_7@479@01]
; [exec]
; Cell_res := tmp
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 874 | p2_7@480@01 | live]
; [else-branch: 874 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 874 | p2_7@480@01]
; [exec]
; Cell_res_2 := tmp
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 875 | p1_7@479@01 | live]
; [else-branch: 875 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 875 | p1_7@479@01]
; [exec]
; inhale typeof(Cell_res) == Cell()
(declare-const $t@555@01 $Snap)
(assert (= $t@555@01 $Snap.unit))
; [eval] typeof(Cell_res) == Cell()
; [eval] typeof(Cell_res)
; [eval] Cell()
(assert (= (typeof<PyType> tmp@554@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_MaySet(Cell_res, 7809653381050164547), write)
(declare-const $t@556@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 876 | p2_7@480@01 | live]
; [else-branch: 876 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 876 | p2_7@480@01]
; [exec]
; inhale typeof(Cell_res_2) == Cell()
(declare-const $t@557@01 $Snap)
(assert (= $t@557@01 $Snap.unit))
; [eval] typeof(Cell_res_2) == Cell()
; [eval] typeof(Cell_res_2)
; [eval] Cell()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_MaySet_0(Cell_res_2, 7809653381050164547), write)
(declare-const $t@558@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [eval] p1_7 || p2_7
(set-option :timeout 0)
(push) ; 9
; [then-branch: 877 | p1_7@479@01 | live]
; [else-branch: 877 | !(p1_7@479@01) | live]
(push) ; 10
; [then-branch: 877 | p1_7@479@01]
(pop) ; 10
(push) ; 10
; [else-branch: 877 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
(set-option :timeout 10)
(assert (not (not (or p1_7@479@01 p2_7@480@01))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (or p1_7@479@01 p2_7@480@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 878 | p1_7@479@01 || p2_7@480@01 | live]
; [else-branch: 878 | !(p1_7@479@01 || p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 878 | p1_7@479@01 || p2_7@480@01]
(assert (or p1_7@479@01 p2_7@480@01))
; [exec]
; var tmp1_29: Ref
(declare-const tmp1_29@559@01 $Ref)
; [exec]
; var tmp2_29: Ref
(declare-const tmp2_29@560@01 $Ref)
; [exec]
; var tmp1_30: Seq[Measure$]
(declare-const tmp1_30@561@01 Seq<Measure$>)
; [exec]
; var tmp2_30: Seq[Measure$]
(declare-const tmp2_30@562@01 Seq<Measure$>)
; [exec]
; var tmp1_31: Perm
(declare-const tmp1_31@563@01 $Perm)
; [exec]
; var tmp2_31: Perm
(declare-const tmp2_31@564@01 $Perm)
; [exec]
; var tmp1_32: Ref
(declare-const tmp1_32@565@01 $Ref)
; [exec]
; var tmp2_32: Ref
(declare-const tmp2_32@566@01 $Ref)
; [exec]
; var tmp1_33: Perm
(declare-const tmp1_33@567@01 $Perm)
; [exec]
; var tmp2_33: Perm
(declare-const tmp2_33@568@01 $Perm)
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 879 | p1_7@479@01 | live]
; [else-branch: 879 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 879 | p1_7@479@01]
; [exec]
; tmp1_29 := _cthread_166
; [exec]
; tmp1_30 := _method_measures_166
; [exec]
; tmp1_31 := _residue_166
; [exec]
; tmp1_32 := Cell_res
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 880 | p2_7@480@01 | live]
; [else-branch: 880 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 880 | p2_7@480@01]
; [exec]
; tmp2_29 := _cthread_166_0
; [exec]
; tmp2_30 := _method_measures_166_0
; [exec]
; tmp2_31 := _residue_166_0
; [exec]
; tmp2_32 := Cell_res_2
; [exec]
; tmp1_33, tmp2_33 := Cell___init__(p1_7, p2_7, tmp1_29, tmp2_29, tmp1_30, tmp2_30,
;   tmp1_31, tmp2_31, tmp1_32, tmp2_32)
; [eval] p1_25 ==> _cthread_156 != null
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 881 | p1_7@479@01 | live]
; [else-branch: 881 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 881 | p1_7@479@01]
; [eval] _cthread_156 != null
(pop) ; 13
(pop) ; 12
; Joined path conditions
; [eval] p2_25 ==> _cthread_156_0 != null
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 882 | p2_7@480@01 | live]
; [else-branch: 882 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 882 | p2_7@480@01]
; [eval] _cthread_156_0 != null
(pop) ; 13
(pop) ; 12
; Joined path conditions
; [eval] p1_25 ==> issubtype(typeof(_cthread_156), Thread_0())
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 883 | p1_7@479@01 | live]
; [else-branch: 883 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 883 | p1_7@479@01]
; [eval] issubtype(typeof(_cthread_156), Thread_0())
; [eval] typeof(_cthread_156)
; [eval] Thread_0()
(pop) ; 13
(pop) ; 12
; Joined path conditions
; [eval] p2_25 ==> issubtype(typeof(_cthread_156_0), Thread_0())
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 884 | p2_7@480@01 | live]
; [else-branch: 884 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 884 | p2_7@480@01]
; [eval] issubtype(typeof(_cthread_156_0), Thread_0())
; [eval] typeof(_cthread_156_0)
; [eval] Thread_0()
(pop) ; 13
(pop) ; 12
; Joined path conditions
; [eval] p1_25 ==> self != null
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 885 | p1_7@479@01 | live]
; [else-branch: 885 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 885 | p1_7@479@01]
; [eval] self != null
(pop) ; 13
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (=> p1_7@479@01 (not (= tmp@554@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_7@479@01 (not (= tmp@554@01 $Ref.null))))
; [eval] p2_25 ==> self_0 != null
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 886 | p2_7@480@01 | live]
; [else-branch: 886 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 886 | p2_7@480@01]
; [eval] self_0 != null
(pop) ; 13
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (=> p2_7@480@01 (not (= tmp@554@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_7@480@01 (not (= tmp@554@01 $Ref.null))))
(push) ; 12
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 887 | p1_7@479@01 | live]
; [else-branch: 887 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 887 | p1_7@479@01]
(push) ; 13
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 888 | p2_7@480@01 | live]
; [else-branch: 888 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 888 | p2_7@480@01]
; [eval] p1_25 ==> issubtype(typeof(self), Cell())
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 889 | p1_7@479@01 | live]
; [else-branch: 889 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 889 | p1_7@479@01]
; [eval] issubtype(typeof(self), Cell())
; [eval] typeof(self)
; [eval] Cell()
(pop) ; 15
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp@554@01) (as Cell<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp@554@01) (as Cell<PyType>  PyType))))
; [eval] p2_25 ==> issubtype(typeof(self_0), Cell())
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 890 | p2_7@480@01 | live]
; [else-branch: 890 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 890 | p2_7@480@01]
; [eval] issubtype(typeof(self_0), Cell())
; [eval] typeof(self_0)
; [eval] Cell()
(pop) ; 15
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp@554@01) (as Cell<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp@554@01) (as Cell<PyType>  PyType))))
; [eval] p1_25 ==> self != null
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 891 | p1_7@479@01 | live]
; [else-branch: 891 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 891 | p1_7@479@01]
; [eval] self != null
(pop) ; 15
(pop) ; 14
; Joined path conditions
; [eval] p2_25 ==> self_0 != null
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 892 | p2_7@480@01 | live]
; [else-branch: 892 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 892 | p2_7@480@01]
; [eval] self_0 != null
(pop) ; 15
(pop) ; 14
; Joined path conditions
; [eval] p1_25 ==> perm(MustTerminate(_cthread_156)) == none && ((forperm _r_41: Ref [MustInvokeBounded(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBounded] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnbounded] :: false))))
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 893 | p1_7@479@01 | live]
; [else-branch: 893 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 893 | p1_7@479@01]
; [eval] perm(MustTerminate(_cthread_156)) == none && ((forperm _r_41: Ref [MustInvokeBounded(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBounded] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_156)) == none
; [eval] perm(MustTerminate(_cthread_156))
(push) ; 16
; [then-branch: 894 | False | live]
; [else-branch: 894 | True | live]
(push) ; 17
; [then-branch: 894 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 894 | True]
; [eval] (forperm _r_41: Ref [MustInvokeBounded(_r_41)] :: false)
(push) ; 18
; [then-branch: 895 | False | live]
; [else-branch: 895 | True | live]
(push) ; 19
; [then-branch: 895 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 895 | True]
; [eval] (forperm _r_41: Ref [MustInvokeUnbounded(_r_41)] :: false)
(push) ; 20
; [then-branch: 896 | False | live]
; [else-branch: 896 | True | live]
(push) ; 21
; [then-branch: 896 | False]
(assert false)
(pop) ; 21
(push) ; 21
; [else-branch: 896 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseBounded] :: false)
(push) ; 22
; [then-branch: 897 | False | live]
; [else-branch: 897 | True | live]
(push) ; 23
; [then-branch: 897 | False]
(assert false)
(pop) ; 23
(push) ; 23
; [else-branch: 897 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseUnbounded] :: false)
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; [eval] p2_25 ==> perm(MustTerminate_0(_cthread_156_0)) == none && ((forperm _r_41: Ref [MustInvokeBounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBoundedp] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnboundedp] :: false))))
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 898 | p2_7@480@01 | live]
; [else-branch: 898 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 898 | p2_7@480@01]
; [eval] perm(MustTerminate_0(_cthread_156_0)) == none && ((forperm _r_41: Ref [MustInvokeBounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBoundedp] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_156_0)) == none
; [eval] perm(MustTerminate_0(_cthread_156_0))
(push) ; 16
; [then-branch: 899 | False | live]
; [else-branch: 899 | True | live]
(push) ; 17
; [then-branch: 899 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 899 | True]
; [eval] (forperm _r_41: Ref [MustInvokeBounded_0(_r_41)] :: false)
(push) ; 18
; [then-branch: 900 | False | live]
; [else-branch: 900 | True | live]
(push) ; 19
; [then-branch: 900 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 900 | True]
; [eval] (forperm _r_41: Ref [MustInvokeUnbounded_0(_r_41)] :: false)
(push) ; 20
; [then-branch: 901 | False | live]
; [else-branch: 901 | True | live]
(push) ; 21
; [then-branch: 901 | False]
(assert false)
(pop) ; 21
(push) ; 21
; [else-branch: 901 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseBoundedp] :: false)
(push) ; 22
; [then-branch: 902 | False | live]
; [else-branch: 902 | True | live]
(push) ; 23
; [then-branch: 902 | False]
(assert false)
(pop) ; 23
(push) ; 23
; [else-branch: 902 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseUnboundedp] :: false)
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
(declare-const _current_wait_level_156@569@01 $Perm)
(declare-const _current_wait_level_156_0@570@01 $Perm)
(declare-const $t@571@01 $Snap)
(assert (= $t@571@01 ($Snap.combine ($Snap.first $t@571@01) ($Snap.second $t@571@01))))
(assert (= ($Snap.first $t@571@01) $Snap.unit))
; [eval] p1_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 903 | p1_7@479@01 | live]
; [else-branch: 903 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 903 | p1_7@479@01]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156)
(push) ; 16
; [then-branch: 904 | False | live]
; [else-branch: 904 | True | live]
(push) ; 17
; [then-branch: 904 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 904 | True]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156)
(push) ; 18
; [then-branch: 905 | False | live]
; [else-branch: 905 | True | live]
(push) ; 19
; [then-branch: 905 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 905 | True]
; [eval] _residue_156 <= _current_wait_level_156
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (=> p1_7@479@01 (<= _residue_166@485@01 _current_wait_level_156@569@01)))
(assert (=
  ($Snap.second $t@571@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@571@01))
    ($Snap.second ($Snap.second $t@571@01)))))
(assert (= ($Snap.first ($Snap.second $t@571@01)) $Snap.unit))
; [eval] p2_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 906 | p2_7@480@01 | live]
; [else-branch: 906 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 906 | p2_7@480@01]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0)
(push) ; 16
; [then-branch: 907 | False | live]
; [else-branch: 907 | True | live]
(push) ; 17
; [then-branch: 907 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 907 | True]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0)
(push) ; 18
; [then-branch: 908 | False | live]
; [else-branch: 908 | True | live]
(push) ; 19
; [then-branch: 908 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 908 | True]
; [eval] _residue_156_0 <= _current_wait_level_156_0
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (=> p2_7@480@01 (<= _residue_166_0@486@01 _current_wait_level_156_0@570@01)))
(assert (=
  ($Snap.second ($Snap.second $t@571@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@571@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 909 | p1_7@479@01 | live]
; [else-branch: 909 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 909 | p1_7@479@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@571@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))))
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 910 | p2_7@480@01 | live]
; [else-branch: 910 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 910 | p2_7@480@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self.Cell_val), int())
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 911 | p1_7@479@01 | live]
; [else-branch: 911 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 911 | p1_7@479@01]
; [eval] issubtype(typeof(self.Cell_val), int())
; [eval] typeof(self.Cell_val)
; [eval] int()
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0.Cell_valp), int())
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 912 | p2_7@480@01 | live]
; [else-branch: 912 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 912 | p2_7@480@01]
; [eval] issubtype(typeof(self_0.Cell_valp), int())
; [eval] typeof(self_0.Cell_valp)
; [eval] int()
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))))
  $Snap.unit))
; [eval] p1_25 ==> int___eq__(self.Cell_val, __prim__int___box__(0))
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 913 | p1_7@479@01 | live]
; [else-branch: 913 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 913 | p1_7@479@01]
; [eval] int___eq__(self.Cell_val, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 18
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 18
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(push) ; 18
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 19
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01))))) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 19
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01)))) (__prim__int___box__ $Snap.unit 0)))
(pop) ; 18
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01))))) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01)))) (__prim__int___box__ $Snap.unit 0))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=>
  p1_7@479@01
  (and
    (__prim__int___box__%precondition $Snap.unit 0)
    (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01))))) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01)))) (__prim__int___box__ $Snap.unit 0)))))
(assert (=>
  p1_7@479@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01)))) (__prim__int___box__ $Snap.unit 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))))
  $Snap.unit))
; [eval] p2_25 ==> int___eq__(self_0.Cell_valp, __prim__int___box__(0))
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 914 | p2_7@480@01 | live]
; [else-branch: 914 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 914 | p2_7@480@01]
; [eval] int___eq__(self_0.Cell_valp, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 18
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 18
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(push) ; 18
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 19
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 19
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))) (__prim__int___box__ $Snap.unit 0)))
(pop) ; 18
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))) (__prim__int___box__ $Snap.unit 0))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=>
  p2_7@480@01
  (and
    (__prim__int___box__%precondition $Snap.unit 0)
    (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))) (__prim__int___box__ $Snap.unit 0)))))
(assert (=>
  p2_7@480@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))) (__prim__int___box__ $Snap.unit 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 915 | p1_7@479@01 | live]
; [else-branch: 915 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 915 | p1_7@479@01]
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 916 | p2_7@480@01 | live]
; [else-branch: 916 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 916 | p2_7@480@01]
(pop) ; 17
(pop) ; 16
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 917 | p1_7@479@01 | live]
; [else-branch: 917 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 917 | p1_7@479@01]
; [exec]
; _cwl_166 := tmp1_33
(push) ; 17
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 918 | p2_7@480@01 | live]
; [else-branch: 918 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 918 | p2_7@480@01]
; [exec]
; _cwl_166_0 := tmp2_33
(push) ; 18
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 919 | p1_7@479@01 | live]
; [else-branch: 919 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 919 | p1_7@479@01]
; [exec]
; c1 := Cell_res
; [exec]
; inhale _isDefined(12643)
(declare-const $t@572@01 $Snap)
(assert (= $t@572@01 $Snap.unit))
; [eval] _isDefined(12643)
(push) ; 19
(assert (_isDefined%precondition $Snap.unit 12643))
(pop) ; 19
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 12643))
(assert (_isDefined $Snap.unit 12643))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 920 | p2_7@480@01 | live]
; [else-branch: 920 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 920 | p2_7@480@01]
; [exec]
; c1_0 := Cell_res_2
; [exec]
; inhale true
(declare-const $t@573@01 $Snap)
(assert (= $t@573@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; tmp_0 := new()
(declare-const tmp_0@574@01 $Ref)
(assert (not (= tmp_0@574@01 $Ref.null)))
(assert (not (= tmp_0@574@01 tmp_1@537@01)))
(assert (not (= tmp_0@574@01 l2@501@01)))
(assert (not (= tmp_0@574@01 secret_7@488@01)))
(assert (not (= tmp_0@574@01 t2_14@508@01)))
(assert (not (= tmp_0@574@01 c2_0@500@01)))
(assert (not (= tmp_0@574@01 thread_arg_2@529@01)))
(assert (not (= tmp_0@574@01 threadingVar_6@520@01)))
(assert (not (= tmp_0@574@01 Cell_res_0@515@01)))
(assert (not (= tmp_0@574@01 threadingVar_0@521@01)))
(assert (not (= tmp_0@574@01 secret@487@01)))
(assert (not (= tmp_0@574@01 l1@497@01)))
(assert (not (= tmp_0@574@01 CellLock_res_1@514@01)))
(assert (not
  (=
    tmp_0@574@01
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))))))
(assert (not
  (=
    tmp_0@574@01
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01)))))))
(assert (not (= tmp_0@574@01 tmp_3@543@01)))
(assert (not (= tmp_0@574@01 thread_arg_9@524@01)))
(assert (not (= tmp_0@574@01 Cell_res_0_0@516@01)))
(assert (not (= tmp_0@574@01 CellLock_res_0@517@01)))
(assert (not (= tmp_0@574@01 thread_arg_0_0@526@01)))
(assert (not (= tmp_0@574@01 tmp@554@01)))
(assert (not (= tmp_0@574@01 c2@499@01)))
(assert (not (= tmp_0@574@01 thread_arg_2_0@530@01)))
(assert (not (= tmp_0@574@01 _cthread_166_0@482@01)))
(assert (not (= tmp_0@574@01 tmp_0@536@01)))
(assert (not (= tmp_0@574@01 thread_arg_1_0@528@01)))
(assert (not (= tmp_0@574@01 CellLock_res_0_0@518@01)))
(assert (not (= tmp_0@574@01 x_2@503@01)))
(assert (not (= tmp_0@574@01 threadingVar@519@01)))
(assert (not (= tmp_0@574@01 threadingVar_0_0@522@01)))
(assert (not (= tmp_0@574@01 t2@507@01)))
(assert (not (= tmp_0@574@01 x_2_0@504@01)))
(assert (not (= tmp_0@574@01 tmp_2@538@01)))
(assert (not (= tmp_0@574@01 _cthread_166@481@01)))
(assert (not (= tmp_0@574@01 l2_0@502@01)))
(assert (not (= tmp_0@574@01 tmp_4@544@01)))
(assert (not (= tmp_0@574@01 thread_arg@523@01)))
(assert (not (= tmp_0@574@01 thread_arg_1@527@01)))
(assert (not (= tmp_0@574@01 CellLock_res@513@01)))
(assert (not (= tmp_0@574@01 l1_0@498@01)))
(assert (not (= tmp_0@574@01 thread_arg_0@525@01)))
(assert (not (= tmp_0@574@01 t1_14@506@01)))
(assert (not (= tmp_0@574@01 t1@505@01)))
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 921 | p1_7@479@01 | live]
; [else-branch: 921 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 921 | p1_7@479@01]
; [exec]
; CellLock_res := tmp_0
(push) ; 21
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 922 | p2_7@480@01 | live]
; [else-branch: 922 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 922 | p2_7@480@01]
; [exec]
; CellLock_res_1 := tmp_0
(push) ; 22
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 923 | p1_7@479@01 | live]
; [else-branch: 923 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 923 | p1_7@479@01]
; [exec]
; inhale typeof(CellLock_res) == CellLock()
(declare-const $t@575@01 $Snap)
(assert (= $t@575@01 $Snap.unit))
; [eval] typeof(CellLock_res) == CellLock()
; [eval] typeof(CellLock_res)
; [eval] CellLock()
(assert (= (typeof<PyType> tmp_0@574@01) (as CellLock<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale Lock_get_locked(CellLock_res) == _checkDefined(c1, 12643)
(declare-const $t@576@01 $Snap)
(assert (= $t@576@01 $Snap.unit))
; [eval] Lock_get_locked(CellLock_res) == _checkDefined(c1, 12643)
; [eval] Lock_get_locked(CellLock_res)
(set-option :timeout 0)
(push) ; 23
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
(push) ; 24
(assert (not (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0))))
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
(push) ; 24
(assert (not (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0) (as object<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0) (as object<PyType>  PyType)))
; [eval] self_3 != null
(assert (Lock_get_locked%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine $Snap.unit $Snap.unit)) tmp_0@574@01))
(pop) ; 23
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0)))
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0) (as object<PyType>  PyType))
  (Lock_get_locked%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_0@574@01)))
; [eval] _checkDefined(c1, 12643)
(push) ; 23
; [eval] _isDefined(id)
(push) ; 24
(pop) ; 24
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp@554@01 12643))
(pop) ; 23
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp@554@01 12643))
(assert (=
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_0@574@01)
  (_checkDefined $Snap.unit tmp@554@01 12643)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 924 | p2_7@480@01 | live]
; [else-branch: 924 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 924 | p2_7@480@01]
; [exec]
; inhale typeof(CellLock_res_1) == CellLock()
(declare-const $t@577@01 $Snap)
(assert (= $t@577@01 $Snap.unit))
; [eval] typeof(CellLock_res_1) == CellLock()
; [eval] typeof(CellLock_res_1)
; [eval] CellLock()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale Lock_get_locked(CellLock_res_1) == c1_0
(declare-const $t@578@01 $Snap)
(assert (= $t@578@01 $Snap.unit))
; [eval] Lock_get_locked(CellLock_res_1) == c1_0
; [eval] Lock_get_locked(CellLock_res_1)
(set-option :timeout 0)
(push) ; 24
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 24
; Joined path conditions
(assert (=
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_0@574@01)
  tmp@554@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 925 | p1_7@479@01 | live]
; [else-branch: 925 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 925 | p1_7@479@01]
; [exec]
; fold acc(Lock_invariant(CellLock_res), write)
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
(push) ; 25
(set-option :timeout 10)
(assert (not (not
  (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (as CellLock<PyType>  PyType)))))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (as CellLock<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 926 | issubtype[Bool](typeof[PyType](tmp_0@574@01), CellLock[PyType]) | live]
; [else-branch: 926 | !(issubtype[Bool](typeof[PyType](tmp_0@574@01), CellLock[PyType])) | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 926 | issubtype[Bool](typeof[PyType](tmp_0@574@01), CellLock[PyType])]
(assert (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (as CellLock<PyType>  PyType)))
; [eval] Lock_get_locked(self_7)
(push) ; 26
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 26
; Joined path conditions
(push) ; 26
(set-option :timeout 10)
(assert (not (=
  tmp@554@01
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_0@574@01))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [eval] issubtype(typeof(Lock_get_locked(self_7).Cell_val), int())
; [eval] typeof(Lock_get_locked(self_7).Cell_val)
; [eval] Lock_get_locked(self_7)
(set-option :timeout 0)
(push) ; 26
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 26
; Joined path conditions
(push) ; 26
(set-option :timeout 10)
(assert (not (=
  tmp@554@01
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_0@574@01))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [eval] int()
(set-option :timeout 0)
(push) ; 26
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@571@01))))) (as int<PyType>  PyType)))
(assert (Lock_invariant%trigger ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@571@01)))
    $Snap.unit)) tmp_0@574@01))
(push) ; 26
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 927 | p2_7@480@01 | live]
; [else-branch: 927 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 927 | p2_7@480@01]
; [exec]
; fold acc(Lock_invariant_0(CellLock_res_1), write)
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
(push) ; 27
(set-option :timeout 10)
(assert (not (not
  (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (as CellLock<PyType>  PyType)))))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 928 | issubtype[Bool](typeof[PyType](tmp_0@574@01), CellLock[PyType]) | live]
; [else-branch: 928 | !(issubtype[Bool](typeof[PyType](tmp_0@574@01), CellLock[PyType])) | dead]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 928 | issubtype[Bool](typeof[PyType](tmp_0@574@01), CellLock[PyType])]
; [eval] Lock_get_locked(self_7)
(push) ; 28
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 28
; Joined path conditions
(push) ; 28
(set-option :timeout 10)
(assert (not (=
  tmp@554@01
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_0@574@01))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [eval] issubtype(typeof(Lock_get_locked(self_7).Cell_valp), int())
; [eval] typeof(Lock_get_locked(self_7).Cell_valp)
; [eval] Lock_get_locked(self_7)
(set-option :timeout 0)
(push) ; 28
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 28
; Joined path conditions
(push) ; 28
(set-option :timeout 10)
(assert (not (=
  tmp@554@01
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_0@574@01))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [eval] int()
(set-option :timeout 0)
(push) ; 28
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01)))))) (as int<PyType>  PyType)))
(assert (Lock_invariant_0%trigger ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))
    $Snap.unit)) tmp_0@574@01))
; [exec]
; assert p1_7 && p2_7 ==> Lock_invariant_low(CellLock_res, CellLock_res_1)
; [eval] p1_7 && p2_7 ==> Lock_invariant_low(CellLock_res, CellLock_res_1)
; [eval] p1_7 && p2_7
(push) ; 28
; [then-branch: 929 | !(p1_7@479@01) | live]
; [else-branch: 929 | p1_7@479@01 | live]
(push) ; 29
; [then-branch: 929 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 29
(push) ; 29
; [else-branch: 929 | p1_7@479@01]
(pop) ; 29
(pop) ; 28
; Joined path conditions
; Joined path conditions
(assert (or p1_7@479@01 (not p1_7@479@01)))
(push) ; 28
(push) ; 29
(set-option :timeout 10)
(assert (not (not (and p1_7@479@01 p2_7@480@01))))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 29
(set-option :timeout 10)
(assert (not (and p1_7@479@01 p2_7@480@01)))
(check-sat)
; unsat
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 930 | p1_7@479@01 && p2_7@480@01 | live]
; [else-branch: 930 | !(p1_7@479@01 && p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 930 | p1_7@479@01 && p2_7@480@01]
(assert (and p1_7@479@01 p2_7@480@01))
; [eval] Lock_invariant_low(CellLock_res, CellLock_res_1)
(push) ; 30
(declare-const $k@579@01 $Perm)
(assert ($Perm.isReadVar $k@579@01))
(push) ; 31
(set-option :timeout 10)
(assert (not (< $Perm.No $k@579@01)))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(declare-const $k@580@01 $Perm)
(assert ($Perm.isReadVar $k@580@01))
(set-option :timeout 0)
(push) ; 31
(set-option :timeout 10)
(assert (not (< $Perm.No $k@580@01)))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@571@01)))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))
      $Snap.unit))) tmp_0@574@01 tmp_0@574@01))
(pop) ; 30
; Joined path conditions
(assert ($Perm.isReadVar $k@579@01))
(assert ($Perm.isReadVar $k@580@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@571@01)))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))
      $Snap.unit))) tmp_0@574@01 tmp_0@574@01))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert ($Perm.isReadVar $k@579@01))
(assert ($Perm.isReadVar $k@580@01))
(assert (=>
  (and p1_7@479@01 p2_7@480@01)
  (and
    p1_7@479@01
    p2_7@480@01
    (Lock_invariant_low%precondition ($Snap.combine
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second $t@571@01)))
          $Snap.unit))
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))
          $Snap.unit))) tmp_0@574@01 tmp_0@574@01))))
(assert (and p1_7@479@01 p2_7@480@01))
(set-option :timeout 0)
(push) ; 28
(assert (not (=>
  (and p1_7@479@01 p2_7@480@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.second $t@571@01)))
        $Snap.unit))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))
        $Snap.unit))) tmp_0@574@01 tmp_0@574@01))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_7@479@01 p2_7@480@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.second $t@571@01)))
        $Snap.unit))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))
        $Snap.unit))) tmp_0@574@01 tmp_0@574@01)))
; [eval] p1_7 || p2_7
(push) ; 28
; [then-branch: 931 | p1_7@479@01 | live]
; [else-branch: 931 | !(p1_7@479@01) | live]
(push) ; 29
; [then-branch: 931 | p1_7@479@01]
(pop) ; 29
(push) ; 29
; [else-branch: 931 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 29
(pop) ; 28
; Joined path conditions
; Joined path conditions
(push) ; 28
(set-option :timeout 10)
(assert (not (not (or p1_7@479@01 p2_7@480@01))))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 932 | p1_7@479@01 || p2_7@480@01 | live]
; [else-branch: 932 | !(p1_7@479@01 || p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 932 | p1_7@479@01 || p2_7@480@01]
; [exec]
; var tmp1_34: Ref
(declare-const tmp1_34@581@01 $Ref)
; [exec]
; var tmp2_34: Ref
(declare-const tmp2_34@582@01 $Ref)
; [exec]
; var tmp1_35: Seq[Measure$]
(declare-const tmp1_35@583@01 Seq<Measure$>)
; [exec]
; var tmp2_35: Seq[Measure$]
(declare-const tmp2_35@584@01 Seq<Measure$>)
; [exec]
; var tmp1_36: Perm
(declare-const tmp1_36@585@01 $Perm)
; [exec]
; var tmp2_36: Perm
(declare-const tmp2_36@586@01 $Perm)
; [exec]
; var tmp1_37: Ref
(declare-const tmp1_37@587@01 $Ref)
; [exec]
; var tmp2_37: Ref
(declare-const tmp2_37@588@01 $Ref)
; [exec]
; var tmp1_38: Ref
(declare-const tmp1_38@589@01 $Ref)
; [exec]
; var tmp2_38: Ref
(declare-const tmp2_38@590@01 $Ref)
; [exec]
; var tmp1_39: Ref
(declare-const tmp1_39@591@01 $Ref)
; [exec]
; var tmp2_39: Ref
(declare-const tmp2_39@592@01 $Ref)
; [exec]
; var tmp1_40: Ref
(declare-const tmp1_40@593@01 $Ref)
; [exec]
; var tmp2_40: Ref
(declare-const tmp2_40@594@01 $Ref)
; [exec]
; var tmp1_41: Perm
(declare-const tmp1_41@595@01 $Perm)
; [exec]
; var tmp2_41: Perm
(declare-const tmp2_41@596@01 $Perm)
(push) ; 29
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 933 | p1_7@479@01 | live]
; [else-branch: 933 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 933 | p1_7@479@01]
; [exec]
; tmp1_34 := _cthread_166
; [exec]
; tmp1_35 := _method_measures_166
; [exec]
; tmp1_36 := _residue_166
; [exec]
; tmp1_37 := CellLock_res
; [exec]
; tmp1_38 := _checkDefined(c1, 12643)
; [eval] _checkDefined(c1, 12643)
(push) ; 30
; [eval] _isDefined(id)
(push) ; 31
(pop) ; 31
; Joined path conditions
(pop) ; 30
; Joined path conditions
(declare-const tmp1_38@597@01 $Ref)
(assert (= tmp1_38@597@01 (_checkDefined $Snap.unit tmp@554@01 12643)))
; [exec]
; tmp1_39 := null
; [exec]
; tmp1_40 := null
(push) ; 30
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
; [then-branch: 934 | p2_7@480@01 | live]
; [else-branch: 934 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 30
; [then-branch: 934 | p2_7@480@01]
; [exec]
; tmp2_34 := _cthread_166_0
; [exec]
; tmp2_35 := _method_measures_166_0
; [exec]
; tmp2_36 := _residue_166_0
; [exec]
; tmp2_37 := CellLock_res_1
; [exec]
; tmp2_38 := c1_0
; [exec]
; tmp2_39 := null
; [exec]
; tmp2_40 := null
; [exec]
; tmp1_41, tmp2_41 := Lock___init__(p1_7, p2_7, tmp1_34, tmp2_34, tmp1_35, tmp2_35,
;   tmp1_36, tmp2_36, tmp1_37, tmp2_37, tmp1_38, tmp2_38, tmp1_39, tmp2_39, tmp1_40,
;   tmp2_40)
; [eval] p1_30 ==> _cthread_171 != null
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 935 | p1_7@479@01 | live]
; [else-branch: 935 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 935 | p1_7@479@01]
; [eval] _cthread_171 != null
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p2_30 ==> _cthread_171_0 != null
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 936 | p2_7@480@01 | live]
; [else-branch: 936 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 936 | p2_7@480@01]
; [eval] _cthread_171_0 != null
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p1_30 ==> issubtype(typeof(_cthread_171), Thread_0())
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 937 | p1_7@479@01 | live]
; [else-branch: 937 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 937 | p1_7@479@01]
; [eval] issubtype(typeof(_cthread_171), Thread_0())
; [eval] typeof(_cthread_171)
; [eval] Thread_0()
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p2_30 ==> issubtype(typeof(_cthread_171_0), Thread_0())
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 938 | p2_7@480@01 | live]
; [else-branch: 938 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 938 | p2_7@480@01]
; [eval] issubtype(typeof(_cthread_171_0), Thread_0())
; [eval] typeof(_cthread_171_0)
; [eval] Thread_0()
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p1_30 ==> self_4 != null
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 939 | p1_7@479@01 | live]
; [else-branch: 939 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 939 | p1_7@479@01]
; [eval] self_4 != null
(pop) ; 32
(pop) ; 31
; Joined path conditions
(push) ; 31
(assert (not (=> p1_7@479@01 (not (= tmp_0@574@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_7@479@01 (not (= tmp_0@574@01 $Ref.null))))
; [eval] p2_30 ==> self_4_0 != null
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 940 | p2_7@480@01 | live]
; [else-branch: 940 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 940 | p2_7@480@01]
; [eval] self_4_0 != null
(pop) ; 32
(pop) ; 31
; Joined path conditions
(push) ; 31
(assert (not (=> p2_7@480@01 (not (= tmp_0@574@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_7@480@01 (not (= tmp_0@574@01 $Ref.null))))
; [eval] p1_30 ==> issubtype(typeof(self_4), Lock(Lock_arg(typeof(self_4), 0)))
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 941 | p1_7@479@01 | live]
; [else-branch: 941 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 941 | p1_7@479@01]
; [eval] issubtype(typeof(self_4), Lock(Lock_arg(typeof(self_4), 0)))
; [eval] typeof(self_4)
; [eval] Lock(Lock_arg(typeof(self_4), 0))
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
(pop) ; 32
(pop) ; 31
; Joined path conditions
(push) ; 31
(assert (not (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0))))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0)))))
; [eval] p2_30 ==> issubtype(typeof(self_4_0), Lock(Lock_arg(typeof(self_4_0), 0)))
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 942 | p2_7@480@01 | live]
; [else-branch: 942 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 942 | p2_7@480@01]
; [eval] issubtype(typeof(self_4_0), Lock(Lock_arg(typeof(self_4_0), 0)))
; [eval] typeof(self_4_0)
; [eval] Lock(Lock_arg(typeof(self_4_0), 0))
; [eval] Lock_arg(typeof(self_4_0), 0)
; [eval] typeof(self_4_0)
(pop) ; 32
(pop) ; 31
; Joined path conditions
(push) ; 31
(assert (not (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0))))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0)))))
; [eval] p1_30 ==> issubtype(typeof(locked_object), Lock_arg(typeof(self_4), 0))
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 943 | p1_7@479@01 | live]
; [else-branch: 943 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 943 | p1_7@479@01]
; [eval] issubtype(typeof(locked_object), Lock_arg(typeof(self_4), 0))
; [eval] typeof(locked_object)
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
(pop) ; 32
(pop) ; 31
; Joined path conditions
(push) ; 31
(assert (not (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp1_38@597@01) (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0)))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp1_38@597@01) (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0))))
; [eval] p2_30 ==> issubtype(typeof(locked_object_0), Lock_arg(typeof(self_4_0), 0))
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 944 | p2_7@480@01 | live]
; [else-branch: 944 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 944 | p2_7@480@01]
; [eval] issubtype(typeof(locked_object_0), Lock_arg(typeof(self_4_0), 0))
; [eval] typeof(locked_object_0)
; [eval] Lock_arg(typeof(self_4_0), 0)
; [eval] typeof(self_4_0)
(pop) ; 32
(pop) ; 31
; Joined path conditions
(push) ; 31
(assert (not (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp@554@01) (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0)))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp@554@01) (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0))))
; [eval] p1_30 ==> above == null || issubtype(typeof(above), BaseLock())
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 945 | p1_7@479@01 | live]
; [else-branch: 945 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 945 | p1_7@479@01]
; [eval] above == null || issubtype(typeof(above), BaseLock())
; [eval] above == null
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p2_30 ==> above_0 == null || issubtype(typeof(above_0), BaseLock())
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 946 | p2_7@480@01 | live]
; [else-branch: 946 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 946 | p2_7@480@01]
; [eval] above_0 == null || issubtype(typeof(above_0), BaseLock())
; [eval] above_0 == null
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p1_30 ==> below == null || issubtype(typeof(below), BaseLock())
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 947 | p1_7@479@01 | live]
; [else-branch: 947 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 947 | p1_7@479@01]
; [eval] below == null || issubtype(typeof(below), BaseLock())
; [eval] below == null
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p2_30 ==> below_0 == null || issubtype(typeof(below_0), BaseLock())
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 948 | p2_7@480@01 | live]
; [else-branch: 948 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 948 | p2_7@480@01]
; [eval] below_0 == null || issubtype(typeof(below_0), BaseLock())
; [eval] below_0 == null
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p1_30 ==> issubtype(Lock_arg(typeof(self_4), 0), object())
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 949 | p1_7@479@01 | live]
; [else-branch: 949 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 949 | p1_7@479@01]
; [eval] issubtype(Lock_arg(typeof(self_4), 0), object())
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
; [eval] object()
(pop) ; 32
(pop) ; 31
; Joined path conditions
(push) ; 31
(assert (not (=>
  p1_7@479@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0) (as object<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0) (as object<PyType>  PyType))))
; [eval] p2_30 ==> issubtype(Lock_arg(typeof(self_4_0), 0), object())
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 950 | p2_7@480@01 | live]
; [else-branch: 950 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 950 | p2_7@480@01]
; [eval] issubtype(Lock_arg(typeof(self_4_0), 0), object())
; [eval] Lock_arg(typeof(self_4_0), 0)
; [eval] typeof(self_4_0)
; [eval] object()
(pop) ; 32
(pop) ; 31
; Joined path conditions
(push) ; 31
(assert (not (=>
  p2_7@480@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0) (as object<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_0@574@01) 0) (as object<PyType>  PyType))))
; [eval] p1_30 ==> self_4 != null
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 951 | p1_7@479@01 | live]
; [else-branch: 951 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 951 | p1_7@479@01]
; [eval] self_4 != null
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p2_30 ==> self_4_0 != null
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 952 | p2_7@480@01 | live]
; [else-branch: 952 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 952 | p2_7@480@01]
; [eval] self_4_0 != null
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p1_30 ==> true
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 953 | p1_7@479@01 | live]
; [else-branch: 953 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 953 | p1_7@479@01]
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p2_30 ==> true
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 954 | p2_7@480@01 | live]
; [else-branch: 954 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 954 | p2_7@480@01]
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p1_30 ==> above == null && below != null ==> true
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 955 | p1_7@479@01 | live]
; [else-branch: 955 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 955 | p1_7@479@01]
; [eval] above == null && below != null ==> true
; [eval] above == null && below != null
; [eval] above == null
(push) ; 33
; [then-branch: 956 | False | live]
; [else-branch: 956 | True | live]
(push) ; 34
; [then-branch: 956 | False]
(assert false)
(pop) ; 34
(push) ; 34
; [else-branch: 956 | True]
; [eval] below != null
(pop) ; 34
(pop) ; 33
; Joined path conditions
; Joined path conditions
(push) ; 33
; [then-branch: 957 | False | dead]
; [else-branch: 957 | True | live]
(push) ; 34
; [else-branch: 957 | True]
(pop) ; 34
(pop) ; 33
; Joined path conditions
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p2_30 ==> above_0 == null && below_0 != null ==> true
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 958 | p2_7@480@01 | live]
; [else-branch: 958 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 958 | p2_7@480@01]
; [eval] above_0 == null && below_0 != null ==> true
; [eval] above_0 == null && below_0 != null
; [eval] above_0 == null
(push) ; 33
; [then-branch: 959 | False | live]
; [else-branch: 959 | True | live]
(push) ; 34
; [then-branch: 959 | False]
(assert false)
(pop) ; 34
(push) ; 34
; [else-branch: 959 | True]
; [eval] below_0 != null
(pop) ; 34
(pop) ; 33
; Joined path conditions
; Joined path conditions
(push) ; 33
; [then-branch: 960 | False | dead]
; [else-branch: 960 | True | live]
(push) ; 34
; [else-branch: 960 | True]
(pop) ; 34
(pop) ; 33
; Joined path conditions
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p1_30 ==> above != null && below != null ==> Level(above) < Level(below)
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 961 | p1_7@479@01 | live]
; [else-branch: 961 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 961 | p1_7@479@01]
; [eval] above != null && below != null ==> Level(above) < Level(below)
; [eval] above != null && below != null
; [eval] above != null
(push) ; 33
; [then-branch: 962 | False | dead]
; [else-branch: 962 | True | live]
(push) ; 34
; [else-branch: 962 | True]
(pop) ; 34
(pop) ; 33
; Joined path conditions
(pop) ; 32
(pop) ; 31
; Joined path conditions
; [eval] p2_30 ==> above_0 != null && below_0 != null ==> Level(above_0) < Level(below_0)
(push) ; 31
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 963 | p2_7@480@01 | live]
; [else-branch: 963 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 963 | p2_7@480@01]
; [eval] above_0 != null && below_0 != null ==> Level(above_0) < Level(below_0)
; [eval] above_0 != null && below_0 != null
; [eval] above_0 != null
(push) ; 33
; [then-branch: 964 | False | dead]
; [else-branch: 964 | True | live]
(push) ; 34
; [else-branch: 964 | True]
(pop) ; 34
(pop) ; 33
; Joined path conditions
(pop) ; 32
(pop) ; 31
; Joined path conditions
(push) ; 31
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
; [then-branch: 965 | p1_7@479@01 | live]
; [else-branch: 965 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 31
; [then-branch: 965 | p1_7@479@01]
(push) ; 32
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 966 | p2_7@480@01 | live]
; [else-branch: 966 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 966 | p2_7@480@01]
; [eval] p1_30 && p2_30 ==> Lock_invariant_low(self_4, self_4_0)
; [eval] p1_30 && p2_30
(push) ; 33
; [then-branch: 967 | !(p1_7@479@01) | live]
; [else-branch: 967 | p1_7@479@01 | live]
(push) ; 34
; [then-branch: 967 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 34
(push) ; 34
; [else-branch: 967 | p1_7@479@01]
(pop) ; 34
(pop) ; 33
; Joined path conditions
; Joined path conditions
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not (and p1_7@479@01 p2_7@480@01))))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 34
(set-option :timeout 10)
(assert (not (and p1_7@479@01 p2_7@480@01)))
(check-sat)
; unsat
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 968 | p1_7@479@01 && p2_7@480@01 | live]
; [else-branch: 968 | !(p1_7@479@01 && p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 968 | p1_7@479@01 && p2_7@480@01]
(assert (and p1_7@479@01 p2_7@480@01))
; [eval] Lock_invariant_low(self_4, self_4_0)
(push) ; 35
(declare-const $k@598@01 $Perm)
(assert ($Perm.isReadVar $k@598@01))
(push) ; 36
(set-option :timeout 10)
(assert (not (< $Perm.No $k@598@01)))
(check-sat)
; unsat
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
(declare-const $k@599@01 $Perm)
(assert ($Perm.isReadVar $k@599@01))
(set-option :timeout 0)
(push) ; 36
(set-option :timeout 10)
(assert (not (< $Perm.No $k@599@01)))
(check-sat)
; unsat
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@571@01)))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))
      $Snap.unit))) tmp_0@574@01 tmp_0@574@01))
(pop) ; 35
; Joined path conditions
(assert ($Perm.isReadVar $k@598@01))
(assert ($Perm.isReadVar $k@599@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@571@01)))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@571@01))))
      $Snap.unit))) tmp_0@574@01 tmp_0@574@01))
(pop) ; 34
(pop) ; 33
; Joined path conditions
(assert ($Perm.isReadVar $k@598@01))
(assert ($Perm.isReadVar $k@599@01))
(assert (and p1_7@479@01 p2_7@480@01))
; [eval] p1_30 ==> above == null && below != null ==> (forperm _r_51: Ref [_r_51.MustReleaseBounded] :: Level(_r_51) < Level(below)) && ((forperm _r_51: Ref [_r_51.MustReleaseUnbounded] :: Level(_r_51) < Level(below)) && _residue_171 < Level(below))
(set-option :timeout 0)
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 969 | p1_7@479@01 | live]
; [else-branch: 969 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 969 | p1_7@479@01]
; [eval] above == null && below != null ==> (forperm _r_51: Ref [_r_51.MustReleaseBounded] :: Level(_r_51) < Level(below)) && ((forperm _r_51: Ref [_r_51.MustReleaseUnbounded] :: Level(_r_51) < Level(below)) && _residue_171 < Level(below))
; [eval] above == null && below != null
; [eval] above == null
(push) ; 35
; [then-branch: 970 | False | live]
; [else-branch: 970 | True | live]
(push) ; 36
; [then-branch: 970 | False]
(assert false)
(pop) ; 36
(push) ; 36
; [else-branch: 970 | True]
; [eval] below != null
(pop) ; 36
(pop) ; 35
; Joined path conditions
; Joined path conditions
(push) ; 35
; [then-branch: 971 | False | dead]
; [else-branch: 971 | True | live]
(push) ; 36
; [else-branch: 971 | True]
(pop) ; 36
(pop) ; 35
; Joined path conditions
(pop) ; 34
(pop) ; 33
; Joined path conditions
; [eval] p2_30 ==> above_0 == null && below_0 != null ==> (forperm _r_51: Ref [_r_51.MustReleaseBoundedp] :: Level(_r_51) < Level(below_0)) && ((forperm _r_51: Ref [_r_51.MustReleaseUnboundedp] :: Level(_r_51) < Level(below_0)) && _residue_171_0 < Level(below_0))
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 972 | p2_7@480@01 | live]
; [else-branch: 972 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 972 | p2_7@480@01]
; [eval] above_0 == null && below_0 != null ==> (forperm _r_51: Ref [_r_51.MustReleaseBoundedp] :: Level(_r_51) < Level(below_0)) && ((forperm _r_51: Ref [_r_51.MustReleaseUnboundedp] :: Level(_r_51) < Level(below_0)) && _residue_171_0 < Level(below_0))
; [eval] above_0 == null && below_0 != null
; [eval] above_0 == null
(push) ; 35
; [then-branch: 973 | False | live]
; [else-branch: 973 | True | live]
(push) ; 36
; [then-branch: 973 | False]
(assert false)
(pop) ; 36
(push) ; 36
; [else-branch: 973 | True]
; [eval] below_0 != null
(pop) ; 36
(pop) ; 35
; Joined path conditions
; Joined path conditions
(push) ; 35
; [then-branch: 974 | False | dead]
; [else-branch: 974 | True | live]
(push) ; 36
; [else-branch: 974 | True]
(pop) ; 36
(pop) ; 35
; Joined path conditions
(pop) ; 34
(pop) ; 33
; Joined path conditions
; [eval] p1_30 ==> Measure$check(_caller_measures_171, _cthread_171, 1) || perm(MustTerminate(_cthread_171)) == none && ((forperm _r_54: Ref [MustInvokeBounded(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBounded] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnbounded] :: false))))
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 975 | p1_7@479@01 | live]
; [else-branch: 975 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 975 | p1_7@479@01]
; [eval] Measure$check(_caller_measures_171, _cthread_171, 1) || perm(MustTerminate(_cthread_171)) == none && ((forperm _r_54: Ref [MustInvokeBounded(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBounded] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_171, _cthread_171, 1)
(push) ; 35
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1))
(pop) ; 35
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1))
(push) ; 35
; [then-branch: 976 | Measure$check(_, Nil, _cthread_166@481@01, 1) | live]
; [else-branch: 976 | !(Measure$check(_, Nil, _cthread_166@481@01, 1)) | live]
(push) ; 36
; [then-branch: 976 | Measure$check(_, Nil, _cthread_166@481@01, 1)]
(assert (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1))
(pop) ; 36
(push) ; 36
; [else-branch: 976 | !(Measure$check(_, Nil, _cthread_166@481@01, 1))]
(assert (not
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1)))
; [eval] perm(MustTerminate(_cthread_171)) == none && ((forperm _r_54: Ref [MustInvokeBounded(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBounded] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_171)) == none
; [eval] perm(MustTerminate(_cthread_171))
(push) ; 37
; [then-branch: 977 | False | live]
; [else-branch: 977 | True | live]
(push) ; 38
; [then-branch: 977 | False]
(assert false)
(pop) ; 38
(push) ; 38
; [else-branch: 977 | True]
; [eval] (forperm _r_54: Ref [MustInvokeBounded(_r_54)] :: false)
(push) ; 39
; [then-branch: 978 | False | live]
; [else-branch: 978 | True | live]
(push) ; 40
; [then-branch: 978 | False]
(assert false)
(pop) ; 40
(push) ; 40
; [else-branch: 978 | True]
; [eval] (forperm _r_54: Ref [MustInvokeUnbounded(_r_54)] :: false)
(push) ; 41
; [then-branch: 979 | False | live]
; [else-branch: 979 | True | live]
(push) ; 42
; [then-branch: 979 | False]
(assert false)
(pop) ; 42
(push) ; 42
; [else-branch: 979 | True]
; [eval] (forperm _r_54: Ref [_r_54.MustReleaseBounded] :: false)
(push) ; 43
; [then-branch: 980 | False | live]
; [else-branch: 980 | True | live]
(push) ; 44
; [then-branch: 980 | False]
(assert false)
(pop) ; 44
(push) ; 44
; [else-branch: 980 | True]
; [eval] (forperm _r_54: Ref [_r_54.MustReleaseUnbounded] :: false)
(pop) ; 44
(pop) ; 43
; Joined path conditions
; Joined path conditions
(pop) ; 42
(pop) ; 41
; Joined path conditions
; Joined path conditions
(pop) ; 40
(pop) ; 39
; Joined path conditions
; Joined path conditions
(pop) ; 38
(pop) ; 37
; Joined path conditions
; Joined path conditions
(pop) ; 36
(pop) ; 35
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1))
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1)))
(pop) ; 34
(pop) ; 33
; Joined path conditions
(assert (=>
  p1_7@479@01
  (and
    (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1)
    (or
      (not
        (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1))
      (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1)))))
; [eval] p2_30 ==> Measure$check(_caller_measures_171_0, _cthread_171_0, 1) || perm(MustTerminate_0(_cthread_171_0)) == none && ((forperm _r_54: Ref [MustInvokeBounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBoundedp] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnboundedp] :: false))))
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 981 | p2_7@480@01 | live]
; [else-branch: 981 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 981 | p2_7@480@01]
; [eval] Measure$check(_caller_measures_171_0, _cthread_171_0, 1) || perm(MustTerminate_0(_cthread_171_0)) == none && ((forperm _r_54: Ref [MustInvokeBounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBoundedp] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_171_0, _cthread_171_0, 1)
(push) ; 35
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1))
(pop) ; 35
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1))
(push) ; 35
; [then-branch: 982 | Measure$check(_, Nil, _cthread_166_0@482@01, 1) | live]
; [else-branch: 982 | !(Measure$check(_, Nil, _cthread_166_0@482@01, 1)) | live]
(push) ; 36
; [then-branch: 982 | Measure$check(_, Nil, _cthread_166_0@482@01, 1)]
(assert (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1))
(pop) ; 36
(push) ; 36
; [else-branch: 982 | !(Measure$check(_, Nil, _cthread_166_0@482@01, 1))]
(assert (not
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1)))
; [eval] perm(MustTerminate_0(_cthread_171_0)) == none && ((forperm _r_54: Ref [MustInvokeBounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBoundedp] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_171_0)) == none
; [eval] perm(MustTerminate_0(_cthread_171_0))
(push) ; 37
; [then-branch: 983 | False | live]
; [else-branch: 983 | True | live]
(push) ; 38
; [then-branch: 983 | False]
(assert false)
(pop) ; 38
(push) ; 38
; [else-branch: 983 | True]
; [eval] (forperm _r_54: Ref [MustInvokeBounded_0(_r_54)] :: false)
(push) ; 39
; [then-branch: 984 | False | live]
; [else-branch: 984 | True | live]
(push) ; 40
; [then-branch: 984 | False]
(assert false)
(pop) ; 40
(push) ; 40
; [else-branch: 984 | True]
; [eval] (forperm _r_54: Ref [MustInvokeUnbounded_0(_r_54)] :: false)
(push) ; 41
; [then-branch: 985 | False | live]
; [else-branch: 985 | True | live]
(push) ; 42
; [then-branch: 985 | False]
(assert false)
(pop) ; 42
(push) ; 42
; [else-branch: 985 | True]
; [eval] (forperm _r_54: Ref [_r_54.MustReleaseBoundedp] :: false)
(push) ; 43
; [then-branch: 986 | False | live]
; [else-branch: 986 | True | live]
(push) ; 44
; [then-branch: 986 | False]
(assert false)
(pop) ; 44
(push) ; 44
; [else-branch: 986 | True]
; [eval] (forperm _r_54: Ref [_r_54.MustReleaseUnboundedp] :: false)
(pop) ; 44
(pop) ; 43
; Joined path conditions
; Joined path conditions
(pop) ; 42
(pop) ; 41
; Joined path conditions
; Joined path conditions
(pop) ; 40
(pop) ; 39
; Joined path conditions
; Joined path conditions
(pop) ; 38
(pop) ; 37
; Joined path conditions
; Joined path conditions
(pop) ; 36
(pop) ; 35
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1))
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1)))
(pop) ; 34
(pop) ; 33
; Joined path conditions
(assert (=>
  p2_7@480@01
  (and
    (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1)
    (or
      (not
        (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1))
      (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1)))))
(declare-const _current_wait_level_171@600@01 $Perm)
(declare-const _current_wait_level_171_0@601@01 $Perm)
(declare-const $t@602@01 $Snap)
(assert (= $t@602@01 ($Snap.combine ($Snap.first $t@602@01) ($Snap.second $t@602@01))))
(assert (= ($Snap.first $t@602@01) $Snap.unit))
; [eval] p1_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171) && ((forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171) && _residue_171 <= _current_wait_level_171)
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 987 | p1_7@479@01 | live]
; [else-branch: 987 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 987 | p1_7@479@01]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171) && ((forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171) && _residue_171 <= _current_wait_level_171)
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171)
(push) ; 35
; [then-branch: 988 | False | live]
; [else-branch: 988 | True | live]
(push) ; 36
; [then-branch: 988 | False]
(assert false)
(pop) ; 36
(push) ; 36
; [else-branch: 988 | True]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171)
(push) ; 37
; [then-branch: 989 | False | live]
; [else-branch: 989 | True | live]
(push) ; 38
; [then-branch: 989 | False]
(assert false)
(pop) ; 38
(push) ; 38
; [else-branch: 989 | True]
; [eval] _residue_171 <= _current_wait_level_171
(pop) ; 38
(pop) ; 37
; Joined path conditions
; Joined path conditions
(pop) ; 36
(pop) ; 35
; Joined path conditions
; Joined path conditions
(pop) ; 34
(pop) ; 33
; Joined path conditions
(assert (=> p1_7@479@01 (<= _residue_166@485@01 _current_wait_level_171@600@01)))
(assert (=
  ($Snap.second $t@602@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@602@01))
    ($Snap.second ($Snap.second $t@602@01)))))
(assert (= ($Snap.first ($Snap.second $t@602@01)) $Snap.unit))
; [eval] p2_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0) && ((forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0) && _residue_171_0 <= _current_wait_level_171_0)
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 990 | p2_7@480@01 | live]
; [else-branch: 990 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 990 | p2_7@480@01]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0) && ((forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0) && _residue_171_0 <= _current_wait_level_171_0)
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0)
(push) ; 35
; [then-branch: 991 | False | live]
; [else-branch: 991 | True | live]
(push) ; 36
; [then-branch: 991 | False]
(assert false)
(pop) ; 36
(push) ; 36
; [else-branch: 991 | True]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0)
(push) ; 37
; [then-branch: 992 | False | live]
; [else-branch: 992 | True | live]
(push) ; 38
; [then-branch: 992 | False]
(assert false)
(pop) ; 38
(push) ; 38
; [else-branch: 992 | True]
; [eval] _residue_171_0 <= _current_wait_level_171_0
(pop) ; 38
(pop) ; 37
; Joined path conditions
; Joined path conditions
(pop) ; 36
(pop) ; 35
; Joined path conditions
; Joined path conditions
(pop) ; 34
(pop) ; 33
; Joined path conditions
(assert (=> p2_7@480@01 (<= _residue_166_0@486@01 _current_wait_level_171_0@601@01)))
(assert (=
  ($Snap.second ($Snap.second $t@602@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@602@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@602@01))) $Snap.unit))
; [eval] p1_30 ==> above == null ==> _current_wait_level_171 < Level(self_4)
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 993 | p1_7@479@01 | live]
; [else-branch: 993 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 993 | p1_7@479@01]
; [eval] above == null ==> _current_wait_level_171 < Level(self_4)
; [eval] above == null
(push) ; 35
(push) ; 36
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 994 | True | live]
; [else-branch: 994 | False | dead]
(set-option :timeout 0)
(push) ; 36
; [then-branch: 994 | True]
; [eval] _current_wait_level_171 < Level(self_4)
; [eval] Level(self_4)
(push) ; 37
(assert (Level%precondition $Snap.unit tmp_0@574@01))
(pop) ; 37
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_0@574@01))
(pop) ; 36
(pop) ; 35
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_0@574@01))
(pop) ; 34
(pop) ; 33
; Joined path conditions
(assert (=> p1_7@479@01 (Level%precondition $Snap.unit tmp_0@574@01)))
(assert (=>
  p1_7@479@01
  (< _current_wait_level_171@600@01 (Level $Snap.unit tmp_0@574@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@602@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@602@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@602@01))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null ==> _current_wait_level_171_0 < Level(self_4_0)
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 995 | p2_7@480@01 | live]
; [else-branch: 995 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 995 | p2_7@480@01]
; [eval] above_0 == null ==> _current_wait_level_171_0 < Level(self_4_0)
; [eval] above_0 == null
(push) ; 35
(push) ; 36
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 996 | True | live]
; [else-branch: 996 | False | dead]
(set-option :timeout 0)
(push) ; 36
; [then-branch: 996 | True]
; [eval] _current_wait_level_171_0 < Level(self_4_0)
; [eval] Level(self_4_0)
(push) ; 37
(assert (Level%precondition $Snap.unit tmp_0@574@01))
(pop) ; 37
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_0@574@01))
(pop) ; 36
(pop) ; 35
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_0@574@01))
(pop) ; 34
(pop) ; 33
; Joined path conditions
(assert (=> p2_7@480@01 (Level%precondition $Snap.unit tmp_0@574@01)))
(assert (=>
  p2_7@480@01
  (< _current_wait_level_171_0@601@01 (Level $Snap.unit tmp_0@574@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))
  $Snap.unit))
; [eval] p1_30 ==> above != null ==> Level(above) < Level(self_4)
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 997 | p1_7@479@01 | live]
; [else-branch: 997 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 997 | p1_7@479@01]
; [eval] above != null ==> Level(above) < Level(self_4)
; [eval] above != null
(push) ; 35
; [then-branch: 998 | False | dead]
; [else-branch: 998 | True | live]
(push) ; 36
; [else-branch: 998 | True]
(pop) ; 36
(pop) ; 35
; Joined path conditions
(pop) ; 34
(pop) ; 33
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 != null ==> Level(above_0) < Level(self_4_0)
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 999 | p2_7@480@01 | live]
; [else-branch: 999 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 999 | p2_7@480@01]
; [eval] above_0 != null ==> Level(above_0) < Level(self_4_0)
; [eval] above_0 != null
(push) ; 35
; [then-branch: 1000 | False | dead]
; [else-branch: 1000 | True | live]
(push) ; 36
; [else-branch: 1000 | True]
(pop) ; 36
(pop) ; 35
; Joined path conditions
(pop) ; 34
(pop) ; 33
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))))
  $Snap.unit))
; [eval] p1_30 ==> below != null ==> Level(self_4) < Level(below)
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1001 | p1_7@479@01 | live]
; [else-branch: 1001 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 1001 | p1_7@479@01]
; [eval] below != null ==> Level(self_4) < Level(below)
; [eval] below != null
(push) ; 35
; [then-branch: 1002 | False | dead]
; [else-branch: 1002 | True | live]
(push) ; 36
; [else-branch: 1002 | True]
(pop) ; 36
(pop) ; 35
; Joined path conditions
(pop) ; 34
(pop) ; 33
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))))
  $Snap.unit))
; [eval] p2_30 ==> below_0 != null ==> Level(self_4_0) < Level(below_0)
(push) ; 33
(push) ; 34
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1003 | p2_7@480@01 | live]
; [else-branch: 1003 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 1003 | p2_7@480@01]
; [eval] below_0 != null ==> Level(self_4_0) < Level(below_0)
; [eval] below_0 != null
(push) ; 35
; [then-branch: 1004 | False | dead]
; [else-branch: 1004 | True | live]
(push) ; 36
; [else-branch: 1004 | True]
(pop) ; 36
(pop) ; 35
; Joined path conditions
(pop) ; 34
(pop) ; 33
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 33
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1005 | p1_7@479@01 | live]
; [else-branch: 1005 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 33
; [then-branch: 1005 | p1_7@479@01]
; [exec]
; _cwl_166 := tmp1_41
(push) ; 34
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1006 | p2_7@480@01 | live]
; [else-branch: 1006 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 1006 | p2_7@480@01]
; [exec]
; _cwl_166_0 := tmp2_41
(push) ; 35
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1007 | p1_7@479@01 | live]
; [else-branch: 1007 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 1007 | p1_7@479@01]
; [exec]
; l1 := CellLock_res
; [exec]
; inhale _isDefined(12652)
(declare-const $t@603@01 $Snap)
(assert (= $t@603@01 $Snap.unit))
; [eval] _isDefined(12652)
(push) ; 36
(assert (_isDefined%precondition $Snap.unit 12652))
(pop) ; 36
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 12652))
(assert (_isDefined $Snap.unit 12652))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 36
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1008 | p2_7@480@01 | live]
; [else-branch: 1008 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 36
; [then-branch: 1008 | p2_7@480@01]
; [exec]
; l1_0 := CellLock_res_1
; [exec]
; inhale true
(declare-const $t@604@01 $Snap)
(assert (= $t@604@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; tmp_1 := new()
(declare-const tmp_1@605@01 $Ref)
(assert (not (= tmp_1@605@01 $Ref.null)))
(assert (not (= tmp_1@605@01 tmp_1@537@01)))
(assert (not (= tmp_1@605@01 l2@501@01)))
(assert (not (= tmp_1@605@01 secret_7@488@01)))
(assert (not (= tmp_1@605@01 t2_14@508@01)))
(assert (not (= tmp_1@605@01 c2_0@500@01)))
(assert (not (= tmp_1@605@01 thread_arg_2@529@01)))
(assert (not (= tmp_1@605@01 threadingVar_6@520@01)))
(assert (not (= tmp_1@605@01 tmp1_38@597@01)))
(assert (not (= tmp_1@605@01 Cell_res_0@515@01)))
(assert (not (= tmp_1@605@01 threadingVar_0@521@01)))
(assert (not (= tmp_1@605@01 secret@487@01)))
(assert (not (= tmp_1@605@01 tmp_3@543@01)))
(assert (not (= tmp_1@605@01 tmp_0@574@01)))
(assert (not (= tmp_1@605@01 thread_arg_9@524@01)))
(assert (not (= tmp_1@605@01 Cell_res_0_0@516@01)))
(assert (not (= tmp_1@605@01 CellLock_res_0@517@01)))
(assert (not (= tmp_1@605@01 thread_arg_0_0@526@01)))
(assert (not (= tmp_1@605@01 tmp@554@01)))
(assert (not (= tmp_1@605@01 c2@499@01)))
(assert (not (= tmp_1@605@01 thread_arg_2_0@530@01)))
(assert (not (= tmp_1@605@01 _cthread_166_0@482@01)))
(assert (not (= tmp_1@605@01 thread_arg_1_0@528@01)))
(assert (not (= tmp_1@605@01 CellLock_res_0_0@518@01)))
(assert (not (= tmp_1@605@01 x_2@503@01)))
(assert (not (= tmp_1@605@01 threadingVar@519@01)))
(assert (not (= tmp_1@605@01 threadingVar_0_0@522@01)))
(assert (not (= tmp_1@605@01 t2@507@01)))
(assert (not (= tmp_1@605@01 x_2_0@504@01)))
(assert (not (= tmp_1@605@01 tmp_2@538@01)))
(assert (not (= tmp_1@605@01 _cthread_166@481@01)))
(assert (not (= tmp_1@605@01 l2_0@502@01)))
(assert (not (= tmp_1@605@01 tmp_4@544@01)))
(assert (not (= tmp_1@605@01 thread_arg@523@01)))
(assert (not (= tmp_1@605@01 thread_arg_1@527@01)))
(assert (not (= tmp_1@605@01 thread_arg_0@525@01)))
(assert (not (= tmp_1@605@01 t1_14@506@01)))
(assert (not (= tmp_1@605@01 t1@505@01)))
(set-option :timeout 0)
(push) ; 37
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1009 | p1_7@479@01 | live]
; [else-branch: 1009 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 37
; [then-branch: 1009 | p1_7@479@01]
; [exec]
; Cell_res_0 := tmp_1
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1010 | p2_7@480@01 | live]
; [else-branch: 1010 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 1010 | p2_7@480@01]
; [exec]
; Cell_res_0_0 := tmp_1
(push) ; 39
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 39
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1011 | p1_7@479@01 | live]
; [else-branch: 1011 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 39
; [then-branch: 1011 | p1_7@479@01]
; [exec]
; inhale typeof(Cell_res_0) == Cell()
(declare-const $t@606@01 $Snap)
(assert (= $t@606@01 $Snap.unit))
; [eval] typeof(Cell_res_0) == Cell()
; [eval] typeof(Cell_res_0)
; [eval] Cell()
(assert (= (typeof<PyType> tmp_1@605@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_MaySet(Cell_res_0, 7809653381050164547), write)
(declare-const $t@607@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 40
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 40
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1012 | p2_7@480@01 | live]
; [else-branch: 1012 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 40
; [then-branch: 1012 | p2_7@480@01]
; [exec]
; inhale typeof(Cell_res_0_0) == Cell()
(declare-const $t@608@01 $Snap)
(assert (= $t@608@01 $Snap.unit))
; [eval] typeof(Cell_res_0_0) == Cell()
; [eval] typeof(Cell_res_0_0)
; [eval] Cell()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_MaySet_0(Cell_res_0_0, 7809653381050164547), write)
(declare-const $t@609@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [eval] p1_7 || p2_7
(set-option :timeout 0)
(push) ; 41
; [then-branch: 1013 | p1_7@479@01 | live]
; [else-branch: 1013 | !(p1_7@479@01) | live]
(push) ; 42
; [then-branch: 1013 | p1_7@479@01]
(pop) ; 42
(push) ; 42
; [else-branch: 1013 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 42
(pop) ; 41
; Joined path conditions
; Joined path conditions
(push) ; 41
(set-option :timeout 10)
(assert (not (not (or p1_7@479@01 p2_7@480@01))))
(check-sat)
; unknown
(pop) ; 41
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1014 | p1_7@479@01 || p2_7@480@01 | live]
; [else-branch: 1014 | !(p1_7@479@01 || p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 41
; [then-branch: 1014 | p1_7@479@01 || p2_7@480@01]
; [exec]
; var tmp1_42: Ref
(declare-const tmp1_42@610@01 $Ref)
; [exec]
; var tmp2_42: Ref
(declare-const tmp2_42@611@01 $Ref)
; [exec]
; var tmp1_43: Seq[Measure$]
(declare-const tmp1_43@612@01 Seq<Measure$>)
; [exec]
; var tmp2_43: Seq[Measure$]
(declare-const tmp2_43@613@01 Seq<Measure$>)
; [exec]
; var tmp1_44: Perm
(declare-const tmp1_44@614@01 $Perm)
; [exec]
; var tmp2_44: Perm
(declare-const tmp2_44@615@01 $Perm)
; [exec]
; var tmp1_45: Ref
(declare-const tmp1_45@616@01 $Ref)
; [exec]
; var tmp2_45: Ref
(declare-const tmp2_45@617@01 $Ref)
; [exec]
; var tmp1_46: Perm
(declare-const tmp1_46@618@01 $Perm)
; [exec]
; var tmp2_46: Perm
(declare-const tmp2_46@619@01 $Perm)
(push) ; 42
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1015 | p1_7@479@01 | live]
; [else-branch: 1015 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 42
; [then-branch: 1015 | p1_7@479@01]
; [exec]
; tmp1_42 := _cthread_166
; [exec]
; tmp1_43 := _method_measures_166
; [exec]
; tmp1_44 := _residue_166
; [exec]
; tmp1_45 := Cell_res_0
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1016 | p2_7@480@01 | live]
; [else-branch: 1016 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1016 | p2_7@480@01]
; [exec]
; tmp2_42 := _cthread_166_0
; [exec]
; tmp2_43 := _method_measures_166_0
; [exec]
; tmp2_44 := _residue_166_0
; [exec]
; tmp2_45 := Cell_res_0_0
; [exec]
; tmp1_46, tmp2_46 := Cell___init__(p1_7, p2_7, tmp1_42, tmp2_42, tmp1_43, tmp2_43,
;   tmp1_44, tmp2_44, tmp1_45, tmp2_45)
; [eval] p1_25 ==> _cthread_156 != null
(push) ; 44
(push) ; 45
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1017 | p1_7@479@01 | live]
; [else-branch: 1017 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1017 | p1_7@479@01]
; [eval] _cthread_156 != null
(pop) ; 45
(pop) ; 44
; Joined path conditions
; [eval] p2_25 ==> _cthread_156_0 != null
(push) ; 44
(push) ; 45
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1018 | p2_7@480@01 | live]
; [else-branch: 1018 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1018 | p2_7@480@01]
; [eval] _cthread_156_0 != null
(pop) ; 45
(pop) ; 44
; Joined path conditions
; [eval] p1_25 ==> issubtype(typeof(_cthread_156), Thread_0())
(push) ; 44
(push) ; 45
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1019 | p1_7@479@01 | live]
; [else-branch: 1019 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1019 | p1_7@479@01]
; [eval] issubtype(typeof(_cthread_156), Thread_0())
; [eval] typeof(_cthread_156)
; [eval] Thread_0()
(pop) ; 45
(pop) ; 44
; Joined path conditions
; [eval] p2_25 ==> issubtype(typeof(_cthread_156_0), Thread_0())
(push) ; 44
(push) ; 45
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1020 | p2_7@480@01 | live]
; [else-branch: 1020 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1020 | p2_7@480@01]
; [eval] issubtype(typeof(_cthread_156_0), Thread_0())
; [eval] typeof(_cthread_156_0)
; [eval] Thread_0()
(pop) ; 45
(pop) ; 44
; Joined path conditions
; [eval] p1_25 ==> self != null
(push) ; 44
(push) ; 45
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1021 | p1_7@479@01 | live]
; [else-branch: 1021 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1021 | p1_7@479@01]
; [eval] self != null
(pop) ; 45
(pop) ; 44
; Joined path conditions
(push) ; 44
(assert (not (=> p1_7@479@01 (not (= tmp_1@605@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_7@479@01 (not (= tmp_1@605@01 $Ref.null))))
; [eval] p2_25 ==> self_0 != null
(push) ; 44
(push) ; 45
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1022 | p2_7@480@01 | live]
; [else-branch: 1022 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1022 | p2_7@480@01]
; [eval] self_0 != null
(pop) ; 45
(pop) ; 44
; Joined path conditions
(push) ; 44
(assert (not (=> p2_7@480@01 (not (= tmp_1@605@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_7@480@01 (not (= tmp_1@605@01 $Ref.null))))
(push) ; 44
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1023 | p1_7@479@01 | live]
; [else-branch: 1023 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 1023 | p1_7@479@01]
(push) ; 45
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1024 | p2_7@480@01 | live]
; [else-branch: 1024 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1024 | p2_7@480@01]
; [eval] p1_25 ==> issubtype(typeof(self), Cell())
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1025 | p1_7@479@01 | live]
; [else-branch: 1025 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1025 | p1_7@479@01]
; [eval] issubtype(typeof(self), Cell())
; [eval] typeof(self)
; [eval] Cell()
(pop) ; 47
(pop) ; 46
; Joined path conditions
(push) ; 46
(assert (not (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp_1@605@01) (as Cell<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp_1@605@01) (as Cell<PyType>  PyType))))
; [eval] p2_25 ==> issubtype(typeof(self_0), Cell())
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1026 | p2_7@480@01 | live]
; [else-branch: 1026 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1026 | p2_7@480@01]
; [eval] issubtype(typeof(self_0), Cell())
; [eval] typeof(self_0)
; [eval] Cell()
(pop) ; 47
(pop) ; 46
; Joined path conditions
(push) ; 46
(assert (not (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp_1@605@01) (as Cell<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp_1@605@01) (as Cell<PyType>  PyType))))
; [eval] p1_25 ==> self != null
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1027 | p1_7@479@01 | live]
; [else-branch: 1027 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1027 | p1_7@479@01]
; [eval] self != null
(pop) ; 47
(pop) ; 46
; Joined path conditions
; [eval] p2_25 ==> self_0 != null
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1028 | p2_7@480@01 | live]
; [else-branch: 1028 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1028 | p2_7@480@01]
; [eval] self_0 != null
(pop) ; 47
(pop) ; 46
; Joined path conditions
; [eval] p1_25 ==> perm(MustTerminate(_cthread_156)) == none && ((forperm _r_41: Ref [MustInvokeBounded(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBounded] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnbounded] :: false))))
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1029 | p1_7@479@01 | live]
; [else-branch: 1029 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1029 | p1_7@479@01]
; [eval] perm(MustTerminate(_cthread_156)) == none && ((forperm _r_41: Ref [MustInvokeBounded(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBounded] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_156)) == none
; [eval] perm(MustTerminate(_cthread_156))
(push) ; 48
; [then-branch: 1030 | False | live]
; [else-branch: 1030 | True | live]
(push) ; 49
; [then-branch: 1030 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1030 | True]
; [eval] (forperm _r_41: Ref [MustInvokeBounded(_r_41)] :: false)
(push) ; 50
; [then-branch: 1031 | False | live]
; [else-branch: 1031 | True | live]
(push) ; 51
; [then-branch: 1031 | False]
(assert false)
(pop) ; 51
(push) ; 51
; [else-branch: 1031 | True]
; [eval] (forperm _r_41: Ref [MustInvokeUnbounded(_r_41)] :: false)
(push) ; 52
; [then-branch: 1032 | False | live]
; [else-branch: 1032 | True | live]
(push) ; 53
; [then-branch: 1032 | False]
(assert false)
(pop) ; 53
(push) ; 53
; [else-branch: 1032 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseBounded] :: false)
(push) ; 54
; [then-branch: 1033 | False | live]
; [else-branch: 1033 | True | live]
(push) ; 55
; [then-branch: 1033 | False]
(assert false)
(pop) ; 55
(push) ; 55
; [else-branch: 1033 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseUnbounded] :: false)
(pop) ; 55
(pop) ; 54
; Joined path conditions
; Joined path conditions
(pop) ; 53
(pop) ; 52
; Joined path conditions
; Joined path conditions
(pop) ; 51
(pop) ; 50
; Joined path conditions
; Joined path conditions
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
; [eval] p2_25 ==> perm(MustTerminate_0(_cthread_156_0)) == none && ((forperm _r_41: Ref [MustInvokeBounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBoundedp] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnboundedp] :: false))))
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1034 | p2_7@480@01 | live]
; [else-branch: 1034 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1034 | p2_7@480@01]
; [eval] perm(MustTerminate_0(_cthread_156_0)) == none && ((forperm _r_41: Ref [MustInvokeBounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBoundedp] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_156_0)) == none
; [eval] perm(MustTerminate_0(_cthread_156_0))
(push) ; 48
; [then-branch: 1035 | False | live]
; [else-branch: 1035 | True | live]
(push) ; 49
; [then-branch: 1035 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1035 | True]
; [eval] (forperm _r_41: Ref [MustInvokeBounded_0(_r_41)] :: false)
(push) ; 50
; [then-branch: 1036 | False | live]
; [else-branch: 1036 | True | live]
(push) ; 51
; [then-branch: 1036 | False]
(assert false)
(pop) ; 51
(push) ; 51
; [else-branch: 1036 | True]
; [eval] (forperm _r_41: Ref [MustInvokeUnbounded_0(_r_41)] :: false)
(push) ; 52
; [then-branch: 1037 | False | live]
; [else-branch: 1037 | True | live]
(push) ; 53
; [then-branch: 1037 | False]
(assert false)
(pop) ; 53
(push) ; 53
; [else-branch: 1037 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseBoundedp] :: false)
(push) ; 54
; [then-branch: 1038 | False | live]
; [else-branch: 1038 | True | live]
(push) ; 55
; [then-branch: 1038 | False]
(assert false)
(pop) ; 55
(push) ; 55
; [else-branch: 1038 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseUnboundedp] :: false)
(pop) ; 55
(pop) ; 54
; Joined path conditions
; Joined path conditions
(pop) ; 53
(pop) ; 52
; Joined path conditions
; Joined path conditions
(pop) ; 51
(pop) ; 50
; Joined path conditions
; Joined path conditions
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
(declare-const _current_wait_level_156@620@01 $Perm)
(declare-const _current_wait_level_156_0@621@01 $Perm)
(declare-const $t@622@01 $Snap)
(assert (= $t@622@01 ($Snap.combine ($Snap.first $t@622@01) ($Snap.second $t@622@01))))
(assert (= ($Snap.first $t@622@01) $Snap.unit))
; [eval] p1_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1039 | p1_7@479@01 | live]
; [else-branch: 1039 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1039 | p1_7@479@01]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156)
(push) ; 48
; [then-branch: 1040 | False | live]
; [else-branch: 1040 | True | live]
(push) ; 49
; [then-branch: 1040 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1040 | True]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156)
(push) ; 50
; [then-branch: 1041 | False | live]
; [else-branch: 1041 | True | live]
(push) ; 51
; [then-branch: 1041 | False]
(assert false)
(pop) ; 51
(push) ; 51
; [else-branch: 1041 | True]
; [eval] _residue_156 <= _current_wait_level_156
(pop) ; 51
(pop) ; 50
; Joined path conditions
; Joined path conditions
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
(assert (=> p1_7@479@01 (<= _residue_166@485@01 _current_wait_level_156@620@01)))
(assert (=
  ($Snap.second $t@622@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@622@01))
    ($Snap.second ($Snap.second $t@622@01)))))
(assert (= ($Snap.first ($Snap.second $t@622@01)) $Snap.unit))
; [eval] p2_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1042 | p2_7@480@01 | live]
; [else-branch: 1042 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1042 | p2_7@480@01]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0)
(push) ; 48
; [then-branch: 1043 | False | live]
; [else-branch: 1043 | True | live]
(push) ; 49
; [then-branch: 1043 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1043 | True]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0)
(push) ; 50
; [then-branch: 1044 | False | live]
; [else-branch: 1044 | True | live]
(push) ; 51
; [then-branch: 1044 | False]
(assert false)
(pop) ; 51
(push) ; 51
; [else-branch: 1044 | True]
; [eval] _residue_156_0 <= _current_wait_level_156_0
(pop) ; 51
(pop) ; 50
; Joined path conditions
; Joined path conditions
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
(assert (=> p2_7@480@01 (<= _residue_166_0@486@01 _current_wait_level_156_0@621@01)))
(assert (=
  ($Snap.second ($Snap.second $t@622@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@622@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))
(push) ; 46
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1045 | p1_7@479@01 | live]
; [else-branch: 1045 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 1045 | p1_7@479@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@622@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))))
(push) ; 47
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1046 | p2_7@480@01 | live]
; [else-branch: 1046 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1046 | p2_7@480@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self.Cell_val), int())
(push) ; 48
(push) ; 49
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 49
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1047 | p1_7@479@01 | live]
; [else-branch: 1047 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 49
; [then-branch: 1047 | p1_7@479@01]
; [eval] issubtype(typeof(self.Cell_val), int())
; [eval] typeof(self.Cell_val)
; [eval] int()
(pop) ; 49
(pop) ; 48
; Joined path conditions
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0.Cell_valp), int())
(push) ; 48
(push) ; 49
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 49
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1048 | p2_7@480@01 | live]
; [else-branch: 1048 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 49
; [then-branch: 1048 | p2_7@480@01]
; [eval] issubtype(typeof(self_0.Cell_valp), int())
; [eval] typeof(self_0.Cell_valp)
; [eval] int()
(pop) ; 49
(pop) ; 48
; Joined path conditions
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))))
  $Snap.unit))
; [eval] p1_25 ==> int___eq__(self.Cell_val, __prim__int___box__(0))
(push) ; 48
(push) ; 49
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 49
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1049 | p1_7@479@01 | live]
; [else-branch: 1049 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 49
; [then-branch: 1049 | p1_7@479@01]
; [eval] int___eq__(self.Cell_val, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 50
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 50
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(push) ; 50
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 51
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01))))) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 51
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01)))) (__prim__int___box__ $Snap.unit 0)))
(pop) ; 50
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01))))) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01)))) (__prim__int___box__ $Snap.unit 0))))
(pop) ; 49
(pop) ; 48
; Joined path conditions
(assert (=>
  p1_7@479@01
  (and
    (__prim__int___box__%precondition $Snap.unit 0)
    (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01))))) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01)))) (__prim__int___box__ $Snap.unit 0)))))
(assert (=>
  p1_7@479@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01)))) (__prim__int___box__ $Snap.unit 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))))
  $Snap.unit))
; [eval] p2_25 ==> int___eq__(self_0.Cell_valp, __prim__int___box__(0))
(push) ; 48
(push) ; 49
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 49
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1050 | p2_7@480@01 | live]
; [else-branch: 1050 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 49
; [then-branch: 1050 | p2_7@480@01]
; [eval] int___eq__(self_0.Cell_valp, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 50
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 50
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(push) ; 50
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 51
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 51
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))) (__prim__int___box__ $Snap.unit 0)))
(pop) ; 50
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))) (__prim__int___box__ $Snap.unit 0))))
(pop) ; 49
(pop) ; 48
; Joined path conditions
(assert (=>
  p2_7@480@01
  (and
    (__prim__int___box__%precondition $Snap.unit 0)
    (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))) (__prim__int___box__ $Snap.unit 0)))))
(assert (=>
  p2_7@480@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))) (__prim__int___box__ $Snap.unit 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 48
(push) ; 49
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 49
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1051 | p1_7@479@01 | live]
; [else-branch: 1051 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 49
; [then-branch: 1051 | p1_7@479@01]
(pop) ; 49
(pop) ; 48
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 48
(push) ; 49
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 49
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1052 | p2_7@480@01 | live]
; [else-branch: 1052 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 49
; [then-branch: 1052 | p2_7@480@01]
(pop) ; 49
(pop) ; 48
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 48
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 48
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1053 | p1_7@479@01 | live]
; [else-branch: 1053 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 48
; [then-branch: 1053 | p1_7@479@01]
; [exec]
; _cwl_166 := tmp1_46
(push) ; 49
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 49
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1054 | p2_7@480@01 | live]
; [else-branch: 1054 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 49
; [then-branch: 1054 | p2_7@480@01]
; [exec]
; _cwl_166_0 := tmp2_46
(push) ; 50
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 50
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1055 | p1_7@479@01 | live]
; [else-branch: 1055 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 50
; [then-branch: 1055 | p1_7@479@01]
; [exec]
; c2 := Cell_res_0
; [exec]
; inhale _isDefined(12899)
(declare-const $t@623@01 $Snap)
(assert (= $t@623@01 $Snap.unit))
; [eval] _isDefined(12899)
(push) ; 51
(assert (_isDefined%precondition $Snap.unit 12899))
(pop) ; 51
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 12899))
(assert (_isDefined $Snap.unit 12899))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 51
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1056 | p2_7@480@01 | live]
; [else-branch: 1056 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 51
; [then-branch: 1056 | p2_7@480@01]
; [exec]
; c2_0 := Cell_res_0_0
; [exec]
; inhale true
(declare-const $t@624@01 $Snap)
(assert (= $t@624@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; tmp_2 := new()
(declare-const tmp_2@625@01 $Ref)
(assert (not (= tmp_2@625@01 $Ref.null)))
(assert (not (= tmp_2@625@01 l2@501@01)))
(assert (not (= tmp_2@625@01 secret_7@488@01)))
(assert (not (= tmp_2@625@01 t2_14@508@01)))
(assert (not (= tmp_2@625@01 thread_arg_2@529@01)))
(assert (not (= tmp_2@625@01 threadingVar_6@520@01)))
(assert (not (= tmp_2@625@01 tmp1_38@597@01)))
(assert (not (= tmp_2@625@01 threadingVar_0@521@01)))
(assert (not (= tmp_2@625@01 secret@487@01)))
(assert (not (= tmp_2@625@01 tmp_3@543@01)))
(assert (not
  (=
    tmp_2@625@01
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))))
(assert (not
  (=
    tmp_2@625@01
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01)))))))
(assert (not (= tmp_2@625@01 tmp_0@574@01)))
(assert (not (= tmp_2@625@01 thread_arg_9@524@01)))
(assert (not (= tmp_2@625@01 CellLock_res_0@517@01)))
(assert (not (= tmp_2@625@01 thread_arg_0_0@526@01)))
(assert (not (= tmp_2@625@01 tmp@554@01)))
(assert (not (= tmp_2@625@01 thread_arg_2_0@530@01)))
(assert (not (= tmp_2@625@01 _cthread_166_0@482@01)))
(assert (not (= tmp_2@625@01 tmp_1@605@01)))
(assert (not (= tmp_2@625@01 thread_arg_1_0@528@01)))
(assert (not (= tmp_2@625@01 CellLock_res_0_0@518@01)))
(assert (not (= tmp_2@625@01 x_2@503@01)))
(assert (not (= tmp_2@625@01 threadingVar@519@01)))
(assert (not (= tmp_2@625@01 threadingVar_0_0@522@01)))
(assert (not (= tmp_2@625@01 t2@507@01)))
(assert (not (= tmp_2@625@01 x_2_0@504@01)))
(assert (not (= tmp_2@625@01 tmp_2@538@01)))
(assert (not (= tmp_2@625@01 _cthread_166@481@01)))
(assert (not (= tmp_2@625@01 l2_0@502@01)))
(assert (not (= tmp_2@625@01 tmp_4@544@01)))
(assert (not (= tmp_2@625@01 thread_arg@523@01)))
(assert (not (= tmp_2@625@01 thread_arg_1@527@01)))
(assert (not (= tmp_2@625@01 thread_arg_0@525@01)))
(assert (not (= tmp_2@625@01 t1_14@506@01)))
(assert (not (= tmp_2@625@01 t1@505@01)))
(set-option :timeout 0)
(push) ; 52
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 52
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1057 | p1_7@479@01 | live]
; [else-branch: 1057 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 52
; [then-branch: 1057 | p1_7@479@01]
; [exec]
; CellLock_res_0 := tmp_2
(push) ; 53
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1058 | p2_7@480@01 | live]
; [else-branch: 1058 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 53
; [then-branch: 1058 | p2_7@480@01]
; [exec]
; CellLock_res_0_0 := tmp_2
(push) ; 54
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1059 | p1_7@479@01 | live]
; [else-branch: 1059 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 54
; [then-branch: 1059 | p1_7@479@01]
; [exec]
; inhale typeof(CellLock_res_0) == CellLock()
(declare-const $t@626@01 $Snap)
(assert (= $t@626@01 $Snap.unit))
; [eval] typeof(CellLock_res_0) == CellLock()
; [eval] typeof(CellLock_res_0)
; [eval] CellLock()
(assert (= (typeof<PyType> tmp_2@625@01) (as CellLock<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale Lock_get_locked(CellLock_res_0) == _checkDefined(c2, 12899)
(declare-const $t@627@01 $Snap)
(assert (= $t@627@01 $Snap.unit))
; [eval] Lock_get_locked(CellLock_res_0) == _checkDefined(c2, 12899)
; [eval] Lock_get_locked(CellLock_res_0)
(set-option :timeout 0)
(push) ; 55
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
(push) ; 56
(assert (not (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0)))))
(check-sat)
; unsat
(pop) ; 56
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0))))
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
(push) ; 56
(assert (not (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0) (as object<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 56
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0) (as object<PyType>  PyType)))
; [eval] self_3 != null
(assert (Lock_get_locked%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine $Snap.unit $Snap.unit)) tmp_2@625@01))
(pop) ; 55
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0)))
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0) (as object<PyType>  PyType))
  (Lock_get_locked%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_2@625@01)))
; [eval] _checkDefined(c2, 12899)
(push) ; 55
; [eval] _isDefined(id)
(push) ; 56
(pop) ; 56
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_1@605@01 12899))
(pop) ; 55
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_1@605@01 12899))
(assert (=
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_2@625@01)
  (_checkDefined $Snap.unit tmp_1@605@01 12899)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 55
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 55
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1060 | p2_7@480@01 | live]
; [else-branch: 1060 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 55
; [then-branch: 1060 | p2_7@480@01]
; [exec]
; inhale typeof(CellLock_res_0_0) == CellLock()
(declare-const $t@628@01 $Snap)
(assert (= $t@628@01 $Snap.unit))
; [eval] typeof(CellLock_res_0_0) == CellLock()
; [eval] typeof(CellLock_res_0_0)
; [eval] CellLock()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale Lock_get_locked(CellLock_res_0_0) == c2_0
(declare-const $t@629@01 $Snap)
(assert (= $t@629@01 $Snap.unit))
; [eval] Lock_get_locked(CellLock_res_0_0) == c2_0
; [eval] Lock_get_locked(CellLock_res_0_0)
(set-option :timeout 0)
(push) ; 56
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 56
; Joined path conditions
(assert (=
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_2@625@01)
  tmp_1@605@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 56
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 56
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1061 | p1_7@479@01 | live]
; [else-branch: 1061 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 56
; [then-branch: 1061 | p1_7@479@01]
; [exec]
; fold acc(Lock_invariant(CellLock_res_0), write)
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
(push) ; 57
(set-option :timeout 10)
(assert (not (not
  (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (as CellLock<PyType>  PyType)))))
(check-sat)
; unknown
(pop) ; 57
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 57
(set-option :timeout 10)
(assert (not (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (as CellLock<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 57
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1062 | issubtype[Bool](typeof[PyType](tmp_2@625@01), CellLock[PyType]) | live]
; [else-branch: 1062 | !(issubtype[Bool](typeof[PyType](tmp_2@625@01), CellLock[PyType])) | dead]
(set-option :timeout 0)
(push) ; 57
; [then-branch: 1062 | issubtype[Bool](typeof[PyType](tmp_2@625@01), CellLock[PyType])]
(assert (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (as CellLock<PyType>  PyType)))
; [eval] Lock_get_locked(self_7)
(push) ; 58
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 58
; Joined path conditions
(push) ; 58
(set-option :timeout 10)
(assert (not (=
  tmp_1@605@01
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_2@625@01))))
(check-sat)
; unsat
(pop) ; 58
; 0.00s
; (get-info :all-statistics)
; [eval] issubtype(typeof(Lock_get_locked(self_7).Cell_val), int())
; [eval] typeof(Lock_get_locked(self_7).Cell_val)
; [eval] Lock_get_locked(self_7)
(set-option :timeout 0)
(push) ; 58
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 58
; Joined path conditions
(push) ; 58
(set-option :timeout 10)
(assert (not (=
  tmp_1@605@01
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_2@625@01))))
(check-sat)
; unsat
(pop) ; 58
; 0.00s
; (get-info :all-statistics)
; [eval] int()
(set-option :timeout 0)
(push) ; 58
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 58
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@622@01))))) (as int<PyType>  PyType)))
(assert (Lock_invariant%trigger ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@622@01)))
    $Snap.unit)) tmp_2@625@01))
(push) ; 58
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 58
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1063 | p2_7@480@01 | live]
; [else-branch: 1063 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 58
; [then-branch: 1063 | p2_7@480@01]
; [exec]
; fold acc(Lock_invariant_0(CellLock_res_0_0), write)
; [eval] issubtype(typeof(self_7), Lock(Lock_arg(typeof(self_7), 0)))
; [eval] typeof(self_7)
; [eval] Lock(Lock_arg(typeof(self_7), 0))
; [eval] Lock_arg(typeof(self_7), 0)
; [eval] typeof(self_7)
; [eval] issubtype(typeof(self_7), CellLock())
; [eval] typeof(self_7)
; [eval] CellLock()
(push) ; 59
(set-option :timeout 10)
(assert (not (not
  (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (as CellLock<PyType>  PyType)))))
(check-sat)
; unknown
(pop) ; 59
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1064 | issubtype[Bool](typeof[PyType](tmp_2@625@01), CellLock[PyType]) | live]
; [else-branch: 1064 | !(issubtype[Bool](typeof[PyType](tmp_2@625@01), CellLock[PyType])) | dead]
(set-option :timeout 0)
(push) ; 59
; [then-branch: 1064 | issubtype[Bool](typeof[PyType](tmp_2@625@01), CellLock[PyType])]
; [eval] Lock_get_locked(self_7)
(push) ; 60
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 60
; Joined path conditions
(push) ; 60
(set-option :timeout 10)
(assert (not (=
  tmp_1@605@01
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_2@625@01))))
(check-sat)
; unsat
(pop) ; 60
; 0.00s
; (get-info :all-statistics)
; [eval] issubtype(typeof(Lock_get_locked(self_7).Cell_valp), int())
; [eval] typeof(Lock_get_locked(self_7).Cell_valp)
; [eval] Lock_get_locked(self_7)
(set-option :timeout 0)
(push) ; 60
; [eval] issubtype(typeof(self_3), Lock(Lock_arg(typeof(self_3), 0)))
; [eval] typeof(self_3)
; [eval] Lock(Lock_arg(typeof(self_3), 0))
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] issubtype(Lock_arg(typeof(self_3), 0), object())
; [eval] Lock_arg(typeof(self_3), 0)
; [eval] typeof(self_3)
; [eval] object()
; [eval] self_3 != null
(pop) ; 60
; Joined path conditions
(push) ; 60
(set-option :timeout 10)
(assert (not (=
  tmp_1@605@01
  (Lock_get_locked ($Snap.combine
    $Snap.unit
    ($Snap.combine $Snap.unit $Snap.unit)) tmp_2@625@01))))
(check-sat)
; unsat
(pop) ; 60
; 0.00s
; (get-info :all-statistics)
; [eval] int()
(set-option :timeout 0)
(push) ; 60
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 60
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))) (as int<PyType>  PyType)))
(assert (Lock_invariant_0%trigger ($Snap.combine
  $Snap.unit
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
    $Snap.unit)) tmp_2@625@01))
; [exec]
; assert p1_7 && p2_7 ==>
;   Lock_invariant_low(CellLock_res_0, CellLock_res_0_0)
; [eval] p1_7 && p2_7 ==> Lock_invariant_low(CellLock_res_0, CellLock_res_0_0)
; [eval] p1_7 && p2_7
(push) ; 60
; [then-branch: 1065 | !(p1_7@479@01) | live]
; [else-branch: 1065 | p1_7@479@01 | live]
(push) ; 61
; [then-branch: 1065 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 61
(push) ; 61
; [else-branch: 1065 | p1_7@479@01]
(pop) ; 61
(pop) ; 60
; Joined path conditions
; Joined path conditions
(push) ; 60
(push) ; 61
(set-option :timeout 10)
(assert (not (not (and p1_7@479@01 p2_7@480@01))))
(check-sat)
; unknown
(pop) ; 61
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 61
(set-option :timeout 10)
(assert (not (and p1_7@479@01 p2_7@480@01)))
(check-sat)
; unsat
(pop) ; 61
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1066 | p1_7@479@01 && p2_7@480@01 | live]
; [else-branch: 1066 | !(p1_7@479@01 && p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 61
; [then-branch: 1066 | p1_7@479@01 && p2_7@480@01]
(assert (and p1_7@479@01 p2_7@480@01))
; [eval] Lock_invariant_low(CellLock_res_0, CellLock_res_0_0)
(push) ; 62
(declare-const $k@630@01 $Perm)
(assert ($Perm.isReadVar $k@630@01))
(push) ; 63
(set-option :timeout 10)
(assert (not (< $Perm.No $k@630@01)))
(check-sat)
; unsat
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
(declare-const $k@631@01 $Perm)
(assert ($Perm.isReadVar $k@631@01))
(set-option :timeout 0)
(push) ; 63
(set-option :timeout 10)
(assert (not (< $Perm.No $k@631@01)))
(check-sat)
; unsat
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@622@01)))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
      $Snap.unit))) tmp_2@625@01 tmp_2@625@01))
(pop) ; 62
; Joined path conditions
(assert ($Perm.isReadVar $k@630@01))
(assert ($Perm.isReadVar $k@631@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@622@01)))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
      $Snap.unit))) tmp_2@625@01 tmp_2@625@01))
(pop) ; 61
(pop) ; 60
; Joined path conditions
(assert ($Perm.isReadVar $k@630@01))
(assert ($Perm.isReadVar $k@631@01))
(assert (=>
  (and p1_7@479@01 p2_7@480@01)
  (and
    p1_7@479@01
    p2_7@480@01
    (Lock_invariant_low%precondition ($Snap.combine
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second $t@622@01)))
          $Snap.unit))
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
          $Snap.unit))) tmp_2@625@01 tmp_2@625@01))))
(assert (and p1_7@479@01 p2_7@480@01))
(set-option :timeout 0)
(push) ; 60
(assert (not (=>
  (and p1_7@479@01 p2_7@480@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.second $t@622@01)))
        $Snap.unit))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
        $Snap.unit))) tmp_2@625@01 tmp_2@625@01))))
(check-sat)
; unsat
(pop) ; 60
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_7@479@01 p2_7@480@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.second $t@622@01)))
        $Snap.unit))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
        $Snap.unit))) tmp_2@625@01 tmp_2@625@01)))
; [eval] p1_7 || p2_7
(push) ; 60
; [then-branch: 1067 | p1_7@479@01 | live]
; [else-branch: 1067 | !(p1_7@479@01) | live]
(push) ; 61
; [then-branch: 1067 | p1_7@479@01]
(pop) ; 61
(push) ; 61
; [else-branch: 1067 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 61
(pop) ; 60
; Joined path conditions
; Joined path conditions
(push) ; 60
(set-option :timeout 10)
(assert (not (not (or p1_7@479@01 p2_7@480@01))))
(check-sat)
; unknown
(pop) ; 60
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1068 | p1_7@479@01 || p2_7@480@01 | live]
; [else-branch: 1068 | !(p1_7@479@01 || p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 60
; [then-branch: 1068 | p1_7@479@01 || p2_7@480@01]
; [exec]
; var tmp1_47: Ref
(declare-const tmp1_47@632@01 $Ref)
; [exec]
; var tmp2_47: Ref
(declare-const tmp2_47@633@01 $Ref)
; [exec]
; var tmp1_48: Seq[Measure$]
(declare-const tmp1_48@634@01 Seq<Measure$>)
; [exec]
; var tmp2_48: Seq[Measure$]
(declare-const tmp2_48@635@01 Seq<Measure$>)
; [exec]
; var tmp1_49: Perm
(declare-const tmp1_49@636@01 $Perm)
; [exec]
; var tmp2_49: Perm
(declare-const tmp2_49@637@01 $Perm)
; [exec]
; var tmp1_50: Ref
(declare-const tmp1_50@638@01 $Ref)
; [exec]
; var tmp2_50: Ref
(declare-const tmp2_50@639@01 $Ref)
; [exec]
; var tmp1_51: Ref
(declare-const tmp1_51@640@01 $Ref)
; [exec]
; var tmp2_51: Ref
(declare-const tmp2_51@641@01 $Ref)
; [exec]
; var tmp1_52: Ref
(declare-const tmp1_52@642@01 $Ref)
; [exec]
; var tmp2_52: Ref
(declare-const tmp2_52@643@01 $Ref)
; [exec]
; var tmp1_53: Ref
(declare-const tmp1_53@644@01 $Ref)
; [exec]
; var tmp2_53: Ref
(declare-const tmp2_53@645@01 $Ref)
; [exec]
; var tmp1_54: Perm
(declare-const tmp1_54@646@01 $Perm)
; [exec]
; var tmp2_54: Perm
(declare-const tmp2_54@647@01 $Perm)
(push) ; 61
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 61
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1069 | p1_7@479@01 | live]
; [else-branch: 1069 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 61
; [then-branch: 1069 | p1_7@479@01]
; [exec]
; tmp1_47 := _cthread_166
; [exec]
; tmp1_48 := _method_measures_166
; [exec]
; tmp1_49 := _residue_166
; [exec]
; tmp1_50 := CellLock_res_0
; [exec]
; tmp1_51 := _checkDefined(c2, 12899)
; [eval] _checkDefined(c2, 12899)
(push) ; 62
; [eval] _isDefined(id)
(push) ; 63
(pop) ; 63
; Joined path conditions
(pop) ; 62
; Joined path conditions
(declare-const tmp1_51@648@01 $Ref)
(assert (= tmp1_51@648@01 (_checkDefined $Snap.unit tmp_1@605@01 12899)))
; [exec]
; tmp1_52 := null
; [exec]
; tmp1_53 := null
(push) ; 62
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 62
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1070 | p2_7@480@01 | live]
; [else-branch: 1070 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 62
; [then-branch: 1070 | p2_7@480@01]
; [exec]
; tmp2_47 := _cthread_166_0
; [exec]
; tmp2_48 := _method_measures_166_0
; [exec]
; tmp2_49 := _residue_166_0
; [exec]
; tmp2_50 := CellLock_res_0_0
; [exec]
; tmp2_51 := c2_0
; [exec]
; tmp2_52 := null
; [exec]
; tmp2_53 := null
; [exec]
; tmp1_54, tmp2_54 := Lock___init__(p1_7, p2_7, tmp1_47, tmp2_47, tmp1_48, tmp2_48,
;   tmp1_49, tmp2_49, tmp1_50, tmp2_50, tmp1_51, tmp2_51, tmp1_52, tmp2_52, tmp1_53,
;   tmp2_53)
; [eval] p1_30 ==> _cthread_171 != null
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1071 | p1_7@479@01 | live]
; [else-branch: 1071 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1071 | p1_7@479@01]
; [eval] _cthread_171 != null
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p2_30 ==> _cthread_171_0 != null
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1072 | p2_7@480@01 | live]
; [else-branch: 1072 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1072 | p2_7@480@01]
; [eval] _cthread_171_0 != null
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p1_30 ==> issubtype(typeof(_cthread_171), Thread_0())
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1073 | p1_7@479@01 | live]
; [else-branch: 1073 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1073 | p1_7@479@01]
; [eval] issubtype(typeof(_cthread_171), Thread_0())
; [eval] typeof(_cthread_171)
; [eval] Thread_0()
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p2_30 ==> issubtype(typeof(_cthread_171_0), Thread_0())
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1074 | p2_7@480@01 | live]
; [else-branch: 1074 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1074 | p2_7@480@01]
; [eval] issubtype(typeof(_cthread_171_0), Thread_0())
; [eval] typeof(_cthread_171_0)
; [eval] Thread_0()
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p1_30 ==> self_4 != null
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1075 | p1_7@479@01 | live]
; [else-branch: 1075 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1075 | p1_7@479@01]
; [eval] self_4 != null
(pop) ; 64
(pop) ; 63
; Joined path conditions
(push) ; 63
(assert (not (=> p1_7@479@01 (not (= tmp_2@625@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_7@479@01 (not (= tmp_2@625@01 $Ref.null))))
; [eval] p2_30 ==> self_4_0 != null
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1076 | p2_7@480@01 | live]
; [else-branch: 1076 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1076 | p2_7@480@01]
; [eval] self_4_0 != null
(pop) ; 64
(pop) ; 63
; Joined path conditions
(push) ; 63
(assert (not (=> p2_7@480@01 (not (= tmp_2@625@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_7@480@01 (not (= tmp_2@625@01 $Ref.null))))
; [eval] p1_30 ==> issubtype(typeof(self_4), Lock(Lock_arg(typeof(self_4), 0)))
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1077 | p1_7@479@01 | live]
; [else-branch: 1077 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1077 | p1_7@479@01]
; [eval] issubtype(typeof(self_4), Lock(Lock_arg(typeof(self_4), 0)))
; [eval] typeof(self_4)
; [eval] Lock(Lock_arg(typeof(self_4), 0))
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
(pop) ; 64
(pop) ; 63
; Joined path conditions
(push) ; 63
(assert (not (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0))))))
(check-sat)
; unsat
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0)))))
; [eval] p2_30 ==> issubtype(typeof(self_4_0), Lock(Lock_arg(typeof(self_4_0), 0)))
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1078 | p2_7@480@01 | live]
; [else-branch: 1078 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1078 | p2_7@480@01]
; [eval] issubtype(typeof(self_4_0), Lock(Lock_arg(typeof(self_4_0), 0)))
; [eval] typeof(self_4_0)
; [eval] Lock(Lock_arg(typeof(self_4_0), 0))
; [eval] Lock_arg(typeof(self_4_0), 0)
; [eval] typeof(self_4_0)
(pop) ; 64
(pop) ; 63
; Joined path conditions
(push) ; 63
(assert (not (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0))))))
(check-sat)
; unsat
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0)))))
; [eval] p1_30 ==> issubtype(typeof(locked_object), Lock_arg(typeof(self_4), 0))
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1079 | p1_7@479@01 | live]
; [else-branch: 1079 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1079 | p1_7@479@01]
; [eval] issubtype(typeof(locked_object), Lock_arg(typeof(self_4), 0))
; [eval] typeof(locked_object)
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
(pop) ; 64
(pop) ; 63
; Joined path conditions
(push) ; 63
(assert (not (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp1_51@648@01) (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0)))))
(check-sat)
; unsat
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (typeof<PyType> tmp1_51@648@01) (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0))))
; [eval] p2_30 ==> issubtype(typeof(locked_object_0), Lock_arg(typeof(self_4_0), 0))
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1080 | p2_7@480@01 | live]
; [else-branch: 1080 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1080 | p2_7@480@01]
; [eval] issubtype(typeof(locked_object_0), Lock_arg(typeof(self_4_0), 0))
; [eval] typeof(locked_object_0)
; [eval] Lock_arg(typeof(self_4_0), 0)
; [eval] typeof(self_4_0)
(pop) ; 64
(pop) ; 63
; Joined path conditions
(push) ; 63
(assert (not (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp_1@605@01) (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0)))))
(check-sat)
; unsat
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (typeof<PyType> tmp_1@605@01) (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0))))
; [eval] p1_30 ==> above == null || issubtype(typeof(above), BaseLock())
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1081 | p1_7@479@01 | live]
; [else-branch: 1081 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1081 | p1_7@479@01]
; [eval] above == null || issubtype(typeof(above), BaseLock())
; [eval] above == null
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p2_30 ==> above_0 == null || issubtype(typeof(above_0), BaseLock())
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1082 | p2_7@480@01 | live]
; [else-branch: 1082 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1082 | p2_7@480@01]
; [eval] above_0 == null || issubtype(typeof(above_0), BaseLock())
; [eval] above_0 == null
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p1_30 ==> below == null || issubtype(typeof(below), BaseLock())
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1083 | p1_7@479@01 | live]
; [else-branch: 1083 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1083 | p1_7@479@01]
; [eval] below == null || issubtype(typeof(below), BaseLock())
; [eval] below == null
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p2_30 ==> below_0 == null || issubtype(typeof(below_0), BaseLock())
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1084 | p2_7@480@01 | live]
; [else-branch: 1084 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1084 | p2_7@480@01]
; [eval] below_0 == null || issubtype(typeof(below_0), BaseLock())
; [eval] below_0 == null
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p1_30 ==> issubtype(Lock_arg(typeof(self_4), 0), object())
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1085 | p1_7@479@01 | live]
; [else-branch: 1085 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1085 | p1_7@479@01]
; [eval] issubtype(Lock_arg(typeof(self_4), 0), object())
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
; [eval] object()
(pop) ; 64
(pop) ; 63
; Joined path conditions
(push) ; 63
(assert (not (=>
  p1_7@479@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0) (as object<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0) (as object<PyType>  PyType))))
; [eval] p2_30 ==> issubtype(Lock_arg(typeof(self_4_0), 0), object())
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1086 | p2_7@480@01 | live]
; [else-branch: 1086 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1086 | p2_7@480@01]
; [eval] issubtype(Lock_arg(typeof(self_4_0), 0), object())
; [eval] Lock_arg(typeof(self_4_0), 0)
; [eval] typeof(self_4_0)
; [eval] object()
(pop) ; 64
(pop) ; 63
; Joined path conditions
(push) ; 63
(assert (not (=>
  p2_7@480@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0) (as object<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> tmp_2@625@01) 0) (as object<PyType>  PyType))))
; [eval] p1_30 ==> self_4 != null
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1087 | p1_7@479@01 | live]
; [else-branch: 1087 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1087 | p1_7@479@01]
; [eval] self_4 != null
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p2_30 ==> self_4_0 != null
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1088 | p2_7@480@01 | live]
; [else-branch: 1088 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1088 | p2_7@480@01]
; [eval] self_4_0 != null
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p1_30 ==> true
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1089 | p1_7@479@01 | live]
; [else-branch: 1089 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1089 | p1_7@479@01]
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p2_30 ==> true
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1090 | p2_7@480@01 | live]
; [else-branch: 1090 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1090 | p2_7@480@01]
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p1_30 ==> above == null && below != null ==> true
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1091 | p1_7@479@01 | live]
; [else-branch: 1091 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1091 | p1_7@479@01]
; [eval] above == null && below != null ==> true
; [eval] above == null && below != null
; [eval] above == null
(push) ; 65
; [then-branch: 1092 | False | live]
; [else-branch: 1092 | True | live]
(push) ; 66
; [then-branch: 1092 | False]
(assert false)
(pop) ; 66
(push) ; 66
; [else-branch: 1092 | True]
; [eval] below != null
(pop) ; 66
(pop) ; 65
; Joined path conditions
; Joined path conditions
(push) ; 65
; [then-branch: 1093 | False | dead]
; [else-branch: 1093 | True | live]
(push) ; 66
; [else-branch: 1093 | True]
(pop) ; 66
(pop) ; 65
; Joined path conditions
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p2_30 ==> above_0 == null && below_0 != null ==> true
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1094 | p2_7@480@01 | live]
; [else-branch: 1094 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1094 | p2_7@480@01]
; [eval] above_0 == null && below_0 != null ==> true
; [eval] above_0 == null && below_0 != null
; [eval] above_0 == null
(push) ; 65
; [then-branch: 1095 | False | live]
; [else-branch: 1095 | True | live]
(push) ; 66
; [then-branch: 1095 | False]
(assert false)
(pop) ; 66
(push) ; 66
; [else-branch: 1095 | True]
; [eval] below_0 != null
(pop) ; 66
(pop) ; 65
; Joined path conditions
; Joined path conditions
(push) ; 65
; [then-branch: 1096 | False | dead]
; [else-branch: 1096 | True | live]
(push) ; 66
; [else-branch: 1096 | True]
(pop) ; 66
(pop) ; 65
; Joined path conditions
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p1_30 ==> above != null && below != null ==> Level(above) < Level(below)
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1097 | p1_7@479@01 | live]
; [else-branch: 1097 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1097 | p1_7@479@01]
; [eval] above != null && below != null ==> Level(above) < Level(below)
; [eval] above != null && below != null
; [eval] above != null
(push) ; 65
; [then-branch: 1098 | False | dead]
; [else-branch: 1098 | True | live]
(push) ; 66
; [else-branch: 1098 | True]
(pop) ; 66
(pop) ; 65
; Joined path conditions
(pop) ; 64
(pop) ; 63
; Joined path conditions
; [eval] p2_30 ==> above_0 != null && below_0 != null ==> Level(above_0) < Level(below_0)
(push) ; 63
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1099 | p2_7@480@01 | live]
; [else-branch: 1099 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1099 | p2_7@480@01]
; [eval] above_0 != null && below_0 != null ==> Level(above_0) < Level(below_0)
; [eval] above_0 != null && below_0 != null
; [eval] above_0 != null
(push) ; 65
; [then-branch: 1100 | False | dead]
; [else-branch: 1100 | True | live]
(push) ; 66
; [else-branch: 1100 | True]
(pop) ; 66
(pop) ; 65
; Joined path conditions
(pop) ; 64
(pop) ; 63
; Joined path conditions
(push) ; 63
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 63
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1101 | p1_7@479@01 | live]
; [else-branch: 1101 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 63
; [then-branch: 1101 | p1_7@479@01]
(push) ; 64
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 64
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1102 | p2_7@480@01 | live]
; [else-branch: 1102 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 64
; [then-branch: 1102 | p2_7@480@01]
; [eval] p1_30 && p2_30 ==> Lock_invariant_low(self_4, self_4_0)
; [eval] p1_30 && p2_30
(push) ; 65
; [then-branch: 1103 | !(p1_7@479@01) | live]
; [else-branch: 1103 | p1_7@479@01 | live]
(push) ; 66
; [then-branch: 1103 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 66
(push) ; 66
; [else-branch: 1103 | p1_7@479@01]
(pop) ; 66
(pop) ; 65
; Joined path conditions
; Joined path conditions
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not (and p1_7@479@01 p2_7@480@01))))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 66
(set-option :timeout 10)
(assert (not (and p1_7@479@01 p2_7@480@01)))
(check-sat)
; unsat
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1104 | p1_7@479@01 && p2_7@480@01 | live]
; [else-branch: 1104 | !(p1_7@479@01 && p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1104 | p1_7@479@01 && p2_7@480@01]
(assert (and p1_7@479@01 p2_7@480@01))
; [eval] Lock_invariant_low(self_4, self_4_0)
(push) ; 67
(declare-const $k@649@01 $Perm)
(assert ($Perm.isReadVar $k@649@01))
(push) ; 68
(set-option :timeout 10)
(assert (not (< $Perm.No $k@649@01)))
(check-sat)
; unsat
(pop) ; 68
; 0.00s
; (get-info :all-statistics)
(declare-const $k@650@01 $Perm)
(assert ($Perm.isReadVar $k@650@01))
(set-option :timeout 0)
(push) ; 68
(set-option :timeout 10)
(assert (not (< $Perm.No $k@650@01)))
(check-sat)
; unsat
(pop) ; 68
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@622@01)))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
      $Snap.unit))) tmp_2@625@01 tmp_2@625@01))
(pop) ; 67
; Joined path conditions
(assert ($Perm.isReadVar $k@649@01))
(assert ($Perm.isReadVar $k@650@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@622@01)))
      $Snap.unit))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
      $Snap.unit))) tmp_2@625@01 tmp_2@625@01))
(pop) ; 66
(pop) ; 65
; Joined path conditions
(assert ($Perm.isReadVar $k@649@01))
(assert ($Perm.isReadVar $k@650@01))
(assert (and p1_7@479@01 p2_7@480@01))
; [eval] p1_30 ==> above == null && below != null ==> (forperm _r_51: Ref [_r_51.MustReleaseBounded] :: Level(_r_51) < Level(below)) && ((forperm _r_51: Ref [_r_51.MustReleaseUnbounded] :: Level(_r_51) < Level(below)) && _residue_171 < Level(below))
(set-option :timeout 0)
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1105 | p1_7@479@01 | live]
; [else-branch: 1105 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1105 | p1_7@479@01]
; [eval] above == null && below != null ==> (forperm _r_51: Ref [_r_51.MustReleaseBounded] :: Level(_r_51) < Level(below)) && ((forperm _r_51: Ref [_r_51.MustReleaseUnbounded] :: Level(_r_51) < Level(below)) && _residue_171 < Level(below))
; [eval] above == null && below != null
; [eval] above == null
(push) ; 67
; [then-branch: 1106 | False | live]
; [else-branch: 1106 | True | live]
(push) ; 68
; [then-branch: 1106 | False]
(assert false)
(pop) ; 68
(push) ; 68
; [else-branch: 1106 | True]
; [eval] below != null
(pop) ; 68
(pop) ; 67
; Joined path conditions
; Joined path conditions
(push) ; 67
; [then-branch: 1107 | False | dead]
; [else-branch: 1107 | True | live]
(push) ; 68
; [else-branch: 1107 | True]
(pop) ; 68
(pop) ; 67
; Joined path conditions
(pop) ; 66
(pop) ; 65
; Joined path conditions
; [eval] p2_30 ==> above_0 == null && below_0 != null ==> (forperm _r_51: Ref [_r_51.MustReleaseBoundedp] :: Level(_r_51) < Level(below_0)) && ((forperm _r_51: Ref [_r_51.MustReleaseUnboundedp] :: Level(_r_51) < Level(below_0)) && _residue_171_0 < Level(below_0))
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1108 | p2_7@480@01 | live]
; [else-branch: 1108 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1108 | p2_7@480@01]
; [eval] above_0 == null && below_0 != null ==> (forperm _r_51: Ref [_r_51.MustReleaseBoundedp] :: Level(_r_51) < Level(below_0)) && ((forperm _r_51: Ref [_r_51.MustReleaseUnboundedp] :: Level(_r_51) < Level(below_0)) && _residue_171_0 < Level(below_0))
; [eval] above_0 == null && below_0 != null
; [eval] above_0 == null
(push) ; 67
; [then-branch: 1109 | False | live]
; [else-branch: 1109 | True | live]
(push) ; 68
; [then-branch: 1109 | False]
(assert false)
(pop) ; 68
(push) ; 68
; [else-branch: 1109 | True]
; [eval] below_0 != null
(pop) ; 68
(pop) ; 67
; Joined path conditions
; Joined path conditions
(push) ; 67
; [then-branch: 1110 | False | dead]
; [else-branch: 1110 | True | live]
(push) ; 68
; [else-branch: 1110 | True]
(pop) ; 68
(pop) ; 67
; Joined path conditions
(pop) ; 66
(pop) ; 65
; Joined path conditions
; [eval] p1_30 ==> Measure$check(_caller_measures_171, _cthread_171, 1) || perm(MustTerminate(_cthread_171)) == none && ((forperm _r_54: Ref [MustInvokeBounded(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBounded] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnbounded] :: false))))
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1111 | p1_7@479@01 | live]
; [else-branch: 1111 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1111 | p1_7@479@01]
; [eval] Measure$check(_caller_measures_171, _cthread_171, 1) || perm(MustTerminate(_cthread_171)) == none && ((forperm _r_54: Ref [MustInvokeBounded(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBounded] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnbounded] :: false))))
; [eval] Measure$check(_caller_measures_171, _cthread_171, 1)
(push) ; 67
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1))
(pop) ; 67
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1))
(push) ; 67
; [then-branch: 1112 | Measure$check(_, Nil, _cthread_166@481@01, 1) | live]
; [else-branch: 1112 | !(Measure$check(_, Nil, _cthread_166@481@01, 1)) | live]
(push) ; 68
; [then-branch: 1112 | Measure$check(_, Nil, _cthread_166@481@01, 1)]
(assert (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1))
(pop) ; 68
(push) ; 68
; [else-branch: 1112 | !(Measure$check(_, Nil, _cthread_166@481@01, 1))]
(assert (not
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1)))
; [eval] perm(MustTerminate(_cthread_171)) == none && ((forperm _r_54: Ref [MustInvokeBounded(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBounded] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_171)) == none
; [eval] perm(MustTerminate(_cthread_171))
(push) ; 69
; [then-branch: 1113 | False | live]
; [else-branch: 1113 | True | live]
(push) ; 70
; [then-branch: 1113 | False]
(assert false)
(pop) ; 70
(push) ; 70
; [else-branch: 1113 | True]
; [eval] (forperm _r_54: Ref [MustInvokeBounded(_r_54)] :: false)
(push) ; 71
; [then-branch: 1114 | False | live]
; [else-branch: 1114 | True | live]
(push) ; 72
; [then-branch: 1114 | False]
(assert false)
(pop) ; 72
(push) ; 72
; [else-branch: 1114 | True]
; [eval] (forperm _r_54: Ref [MustInvokeUnbounded(_r_54)] :: false)
(push) ; 73
; [then-branch: 1115 | False | live]
; [else-branch: 1115 | True | live]
(push) ; 74
; [then-branch: 1115 | False]
(assert false)
(pop) ; 74
(push) ; 74
; [else-branch: 1115 | True]
; [eval] (forperm _r_54: Ref [_r_54.MustReleaseBounded] :: false)
(push) ; 75
; [then-branch: 1116 | False | live]
; [else-branch: 1116 | True | live]
(push) ; 76
; [then-branch: 1116 | False]
(assert false)
(pop) ; 76
(push) ; 76
; [else-branch: 1116 | True]
; [eval] (forperm _r_54: Ref [_r_54.MustReleaseUnbounded] :: false)
(pop) ; 76
(pop) ; 75
; Joined path conditions
; Joined path conditions
(pop) ; 74
(pop) ; 73
; Joined path conditions
; Joined path conditions
(pop) ; 72
(pop) ; 71
; Joined path conditions
; Joined path conditions
(pop) ; 70
(pop) ; 69
; Joined path conditions
; Joined path conditions
(pop) ; 68
(pop) ; 67
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1))
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166@481@01 1)))
(pop) ; 66
(pop) ; 65
; Joined path conditions
; [eval] p2_30 ==> Measure$check(_caller_measures_171_0, _cthread_171_0, 1) || perm(MustTerminate_0(_cthread_171_0)) == none && ((forperm _r_54: Ref [MustInvokeBounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBoundedp] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnboundedp] :: false))))
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1117 | p2_7@480@01 | live]
; [else-branch: 1117 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1117 | p2_7@480@01]
; [eval] Measure$check(_caller_measures_171_0, _cthread_171_0, 1) || perm(MustTerminate_0(_cthread_171_0)) == none && ((forperm _r_54: Ref [MustInvokeBounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBoundedp] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnboundedp] :: false))))
; [eval] Measure$check(_caller_measures_171_0, _cthread_171_0, 1)
(push) ; 67
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1))
(pop) ; 67
; Joined path conditions
(assert (Measure$check%precondition $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1))
(push) ; 67
; [then-branch: 1118 | Measure$check(_, Nil, _cthread_166_0@482@01, 1) | live]
; [else-branch: 1118 | !(Measure$check(_, Nil, _cthread_166_0@482@01, 1)) | live]
(push) ; 68
; [then-branch: 1118 | Measure$check(_, Nil, _cthread_166_0@482@01, 1)]
(assert (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1))
(pop) ; 68
(push) ; 68
; [else-branch: 1118 | !(Measure$check(_, Nil, _cthread_166_0@482@01, 1))]
(assert (not
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1)))
; [eval] perm(MustTerminate_0(_cthread_171_0)) == none && ((forperm _r_54: Ref [MustInvokeBounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [MustInvokeUnbounded_0(_r_54)] :: false) && ((forperm _r_54: Ref [_r_54.MustReleaseBoundedp] :: false) && (forperm _r_54: Ref [_r_54.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_171_0)) == none
; [eval] perm(MustTerminate_0(_cthread_171_0))
(push) ; 69
; [then-branch: 1119 | False | live]
; [else-branch: 1119 | True | live]
(push) ; 70
; [then-branch: 1119 | False]
(assert false)
(pop) ; 70
(push) ; 70
; [else-branch: 1119 | True]
; [eval] (forperm _r_54: Ref [MustInvokeBounded_0(_r_54)] :: false)
(push) ; 71
; [then-branch: 1120 | False | live]
; [else-branch: 1120 | True | live]
(push) ; 72
; [then-branch: 1120 | False]
(assert false)
(pop) ; 72
(push) ; 72
; [else-branch: 1120 | True]
; [eval] (forperm _r_54: Ref [MustInvokeUnbounded_0(_r_54)] :: false)
(push) ; 73
; [then-branch: 1121 | False | live]
; [else-branch: 1121 | True | live]
(push) ; 74
; [then-branch: 1121 | False]
(assert false)
(pop) ; 74
(push) ; 74
; [else-branch: 1121 | True]
; [eval] (forperm _r_54: Ref [_r_54.MustReleaseBoundedp] :: false)
(push) ; 75
; [then-branch: 1122 | False | live]
; [else-branch: 1122 | True | live]
(push) ; 76
; [then-branch: 1122 | False]
(assert false)
(pop) ; 76
(push) ; 76
; [else-branch: 1122 | True]
; [eval] (forperm _r_54: Ref [_r_54.MustReleaseUnboundedp] :: false)
(pop) ; 76
(pop) ; 75
; Joined path conditions
; Joined path conditions
(pop) ; 74
(pop) ; 73
; Joined path conditions
; Joined path conditions
(pop) ; 72
(pop) ; 71
; Joined path conditions
; Joined path conditions
(pop) ; 70
(pop) ; 69
; Joined path conditions
; Joined path conditions
(pop) ; 68
(pop) ; 67
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1))
  (Measure$check $Snap.unit (as Seq_empty  Seq<Measure$>) _cthread_166_0@482@01 1)))
(pop) ; 66
(pop) ; 65
; Joined path conditions
(declare-const _current_wait_level_171@651@01 $Perm)
(declare-const _current_wait_level_171_0@652@01 $Perm)
(declare-const $t@653@01 $Snap)
(assert (= $t@653@01 ($Snap.combine ($Snap.first $t@653@01) ($Snap.second $t@653@01))))
(assert (= ($Snap.first $t@653@01) $Snap.unit))
; [eval] p1_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171) && ((forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171) && _residue_171 <= _current_wait_level_171)
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1123 | p1_7@479@01 | live]
; [else-branch: 1123 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1123 | p1_7@479@01]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171) && ((forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171) && _residue_171 <= _current_wait_level_171)
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171)
(push) ; 67
; [then-branch: 1124 | False | live]
; [else-branch: 1124 | True | live]
(push) ; 68
; [then-branch: 1124 | False]
(assert false)
(pop) ; 68
(push) ; 68
; [else-branch: 1124 | True]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171)
(push) ; 69
; [then-branch: 1125 | False | live]
; [else-branch: 1125 | True | live]
(push) ; 70
; [then-branch: 1125 | False]
(assert false)
(pop) ; 70
(push) ; 70
; [else-branch: 1125 | True]
; [eval] _residue_171 <= _current_wait_level_171
(pop) ; 70
(pop) ; 69
; Joined path conditions
; Joined path conditions
(pop) ; 68
(pop) ; 67
; Joined path conditions
; Joined path conditions
(pop) ; 66
(pop) ; 65
; Joined path conditions
(assert (=> p1_7@479@01 (<= _residue_166@485@01 _current_wait_level_171@651@01)))
(assert (=
  ($Snap.second $t@653@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@653@01))
    ($Snap.second ($Snap.second $t@653@01)))))
(assert (= ($Snap.first ($Snap.second $t@653@01)) $Snap.unit))
; [eval] p2_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0) && ((forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0) && _residue_171_0 <= _current_wait_level_171_0)
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1126 | p2_7@480@01 | live]
; [else-branch: 1126 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1126 | p2_7@480@01]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0) && ((forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0) && _residue_171_0 <= _current_wait_level_171_0)
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0)
(push) ; 67
; [then-branch: 1127 | False | live]
; [else-branch: 1127 | True | live]
(push) ; 68
; [then-branch: 1127 | False]
(assert false)
(pop) ; 68
(push) ; 68
; [else-branch: 1127 | True]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0)
(push) ; 69
; [then-branch: 1128 | False | live]
; [else-branch: 1128 | True | live]
(push) ; 70
; [then-branch: 1128 | False]
(assert false)
(pop) ; 70
(push) ; 70
; [else-branch: 1128 | True]
; [eval] _residue_171_0 <= _current_wait_level_171_0
(pop) ; 70
(pop) ; 69
; Joined path conditions
; Joined path conditions
(pop) ; 68
(pop) ; 67
; Joined path conditions
; Joined path conditions
(pop) ; 66
(pop) ; 65
; Joined path conditions
(assert (=> p2_7@480@01 (<= _residue_166_0@486@01 _current_wait_level_171_0@652@01)))
(assert (=
  ($Snap.second ($Snap.second $t@653@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@653@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@653@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@653@01))) $Snap.unit))
; [eval] p1_30 ==> above == null ==> _current_wait_level_171 < Level(self_4)
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1129 | p1_7@479@01 | live]
; [else-branch: 1129 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1129 | p1_7@479@01]
; [eval] above == null ==> _current_wait_level_171 < Level(self_4)
; [eval] above == null
(push) ; 67
(push) ; 68
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 68
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1130 | True | live]
; [else-branch: 1130 | False | dead]
(set-option :timeout 0)
(push) ; 68
; [then-branch: 1130 | True]
; [eval] _current_wait_level_171 < Level(self_4)
; [eval] Level(self_4)
(push) ; 69
(assert (Level%precondition $Snap.unit tmp_2@625@01))
(pop) ; 69
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_2@625@01))
(pop) ; 68
(pop) ; 67
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_2@625@01))
(pop) ; 66
(pop) ; 65
; Joined path conditions
(assert (=> p1_7@479@01 (Level%precondition $Snap.unit tmp_2@625@01)))
(assert (=>
  p1_7@479@01
  (< _current_wait_level_171@651@01 (Level $Snap.unit tmp_2@625@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@653@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@653@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@653@01))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null ==> _current_wait_level_171_0 < Level(self_4_0)
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1131 | p2_7@480@01 | live]
; [else-branch: 1131 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1131 | p2_7@480@01]
; [eval] above_0 == null ==> _current_wait_level_171_0 < Level(self_4_0)
; [eval] above_0 == null
(push) ; 67
(push) ; 68
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 68
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1132 | True | live]
; [else-branch: 1132 | False | dead]
(set-option :timeout 0)
(push) ; 68
; [then-branch: 1132 | True]
; [eval] _current_wait_level_171_0 < Level(self_4_0)
; [eval] Level(self_4_0)
(push) ; 69
(assert (Level%precondition $Snap.unit tmp_2@625@01))
(pop) ; 69
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_2@625@01))
(pop) ; 68
(pop) ; 67
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_2@625@01))
(pop) ; 66
(pop) ; 65
; Joined path conditions
(assert (=> p2_7@480@01 (Level%precondition $Snap.unit tmp_2@625@01)))
(assert (=>
  p2_7@480@01
  (< _current_wait_level_171_0@652@01 (Level $Snap.unit tmp_2@625@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01)))))
  $Snap.unit))
; [eval] p1_30 ==> above != null ==> Level(above) < Level(self_4)
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1133 | p1_7@479@01 | live]
; [else-branch: 1133 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1133 | p1_7@479@01]
; [eval] above != null ==> Level(above) < Level(self_4)
; [eval] above != null
(push) ; 67
; [then-branch: 1134 | False | dead]
; [else-branch: 1134 | True | live]
(push) ; 68
; [else-branch: 1134 | True]
(pop) ; 68
(pop) ; 67
; Joined path conditions
(pop) ; 66
(pop) ; 65
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 != null ==> Level(above_0) < Level(self_4_0)
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1135 | p2_7@480@01 | live]
; [else-branch: 1135 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1135 | p2_7@480@01]
; [eval] above_0 != null ==> Level(above_0) < Level(self_4_0)
; [eval] above_0 != null
(push) ; 67
; [then-branch: 1136 | False | dead]
; [else-branch: 1136 | True | live]
(push) ; 68
; [else-branch: 1136 | True]
(pop) ; 68
(pop) ; 67
; Joined path conditions
(pop) ; 66
(pop) ; 65
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01)))))))
  $Snap.unit))
; [eval] p1_30 ==> below != null ==> Level(self_4) < Level(below)
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1137 | p1_7@479@01 | live]
; [else-branch: 1137 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1137 | p1_7@479@01]
; [eval] below != null ==> Level(self_4) < Level(below)
; [eval] below != null
(push) ; 67
; [then-branch: 1138 | False | dead]
; [else-branch: 1138 | True | live]
(push) ; 68
; [else-branch: 1138 | True]
(pop) ; 68
(pop) ; 67
; Joined path conditions
(pop) ; 66
(pop) ; 65
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@653@01)))))))
  $Snap.unit))
; [eval] p2_30 ==> below_0 != null ==> Level(self_4_0) < Level(below_0)
(push) ; 65
(push) ; 66
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1139 | p2_7@480@01 | live]
; [else-branch: 1139 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1139 | p2_7@480@01]
; [eval] below_0 != null ==> Level(self_4_0) < Level(below_0)
; [eval] below_0 != null
(push) ; 67
; [then-branch: 1140 | False | dead]
; [else-branch: 1140 | True | live]
(push) ; 68
; [else-branch: 1140 | True]
(pop) ; 68
(pop) ; 67
; Joined path conditions
(pop) ; 66
(pop) ; 65
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 65
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 65
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1141 | p1_7@479@01 | live]
; [else-branch: 1141 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 65
; [then-branch: 1141 | p1_7@479@01]
; [exec]
; _cwl_166 := tmp1_54
(push) ; 66
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 66
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1142 | p2_7@480@01 | live]
; [else-branch: 1142 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 66
; [then-branch: 1142 | p2_7@480@01]
; [exec]
; _cwl_166_0 := tmp2_54
(push) ; 67
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 67
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1143 | p1_7@479@01 | live]
; [else-branch: 1143 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 67
; [then-branch: 1143 | p1_7@479@01]
; [exec]
; l2 := CellLock_res_0
; [exec]
; inhale _isDefined(12908)
(declare-const $t@654@01 $Snap)
(assert (= $t@654@01 $Snap.unit))
; [eval] _isDefined(12908)
(push) ; 68
(assert (_isDefined%precondition $Snap.unit 12908))
(pop) ; 68
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 12908))
(assert (_isDefined $Snap.unit 12908))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 68
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 68
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1144 | p2_7@480@01 | live]
; [else-branch: 1144 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 68
; [then-branch: 1144 | p2_7@480@01]
; [exec]
; l2_0 := CellLock_res_0_0
; [exec]
; inhale true
(declare-const $t@655@01 $Snap)
(assert (= $t@655@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; p1_8 := p1_7 && bool___unbox__(secret_3)
; [eval] p1_7 && bool___unbox__(secret_3)
(set-option :timeout 0)
(push) ; 69
; [then-branch: 1145 | !(p1_7@479@01) | live]
; [else-branch: 1145 | p1_7@479@01 | live]
(push) ; 70
; [then-branch: 1145 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 70
(push) ; 70
; [else-branch: 1145 | p1_7@479@01]
; [eval] bool___unbox__(secret_3)
(push) ; 71
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 72
(assert (not (issubtype<Bool> (typeof<PyType> secret@487@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 72
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret@487@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret@487@01))
(pop) ; 71
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret@487@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret@487@01)))
(pop) ; 70
(pop) ; 69
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_7@479@01
  (and
    (issubtype<Bool> (typeof<PyType> secret@487@01) (as bool<PyType>  PyType))
    (bool___unbox__%precondition $Snap.unit secret@487@01))))
(declare-const p1_8@656@01 Bool)
(assert (= p1_8@656@01 (and p1_7@479@01 (bool___unbox__ $Snap.unit secret@487@01))))
; [exec]
; p2_8 := p2_7 && bool___unbox__(secret_3_0)
; [eval] p2_7 && bool___unbox__(secret_3_0)
(push) ; 69
; [then-branch: 1146 | !(p2_7@480@01) | live]
; [else-branch: 1146 | p2_7@480@01 | live]
(push) ; 70
; [then-branch: 1146 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 70
(push) ; 70
; [else-branch: 1146 | p2_7@480@01]
; [eval] bool___unbox__(secret_3_0)
(push) ; 71
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 72
(assert (not (issubtype<Bool> (typeof<PyType> secret_7@488@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 72
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_7@488@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_7@488@01))
(pop) ; 71
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_7@488@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_7@488@01)))
(pop) ; 70
(pop) ; 69
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_7@480@01
  (and
    (issubtype<Bool> (typeof<PyType> secret_7@488@01) (as bool<PyType>  PyType))
    (bool___unbox__%precondition $Snap.unit secret_7@488@01))))
(assert (or p2_7@480@01 (not p2_7@480@01)))
(declare-const p2_8@657@01 Bool)
(assert (= p2_8@657@01 (and p2_7@480@01 (bool___unbox__ $Snap.unit secret_7@488@01))))
; [exec]
; p3_1 := p1_7 && !bool___unbox__(secret_3)
; [eval] p1_7 && !bool___unbox__(secret_3)
(push) ; 69
; [then-branch: 1147 | !(p1_7@479@01) | live]
; [else-branch: 1147 | p1_7@479@01 | live]
(push) ; 70
; [then-branch: 1147 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 70
(push) ; 70
; [else-branch: 1147 | p1_7@479@01]
; [eval] !bool___unbox__(secret_3)
; [eval] bool___unbox__(secret_3)
(push) ; 71
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 72
(assert (not (issubtype<Bool> (typeof<PyType> secret@487@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 72
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret@487@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret@487@01))
(pop) ; 71
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret@487@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret@487@01)))
(pop) ; 70
(pop) ; 69
; Joined path conditions
; Joined path conditions
(declare-const p3_1@658@01 Bool)
(assert (= p3_1@658@01 (and p1_7@479@01 (not (bool___unbox__ $Snap.unit secret@487@01)))))
; [exec]
; p4_1 := p2_7 && !bool___unbox__(secret_3_0)
; [eval] p2_7 && !bool___unbox__(secret_3_0)
(push) ; 69
; [then-branch: 1148 | !(p2_7@480@01) | live]
; [else-branch: 1148 | p2_7@480@01 | live]
(push) ; 70
; [then-branch: 1148 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 70
(push) ; 70
; [else-branch: 1148 | p2_7@480@01]
; [eval] !bool___unbox__(secret_3_0)
; [eval] bool___unbox__(secret_3_0)
(push) ; 71
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 72
(assert (not (issubtype<Bool> (typeof<PyType> secret_7@488@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 72
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_7@488@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_7@488@01))
(pop) ; 71
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_7@488@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_7@488@01)))
(pop) ; 70
(pop) ; 69
; Joined path conditions
; Joined path conditions
(declare-const p4_1@659@01 Bool)
(assert (=
  p4_1@659@01
  (and p2_7@480@01 (not (bool___unbox__ $Snap.unit secret_7@488@01)))))
(push) ; 69
(set-option :timeout 10)
(assert (not (not p1_8@656@01)))
(check-sat)
; unknown
(pop) ; 69
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 69
(set-option :timeout 10)
(assert (not p1_8@656@01))
(check-sat)
; unknown
(pop) ; 69
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1149 | p1_8@656@01 | live]
; [else-branch: 1149 | !(p1_8@656@01) | live]
(set-option :timeout 0)
(push) ; 69
; [then-branch: 1149 | p1_8@656@01]
(assert p1_8@656@01)
; [exec]
; x_2 := _checkDefined(l1, 12652)
; [eval] _checkDefined(l1, 12652)
(push) ; 70
; [eval] _isDefined(id)
(push) ; 71
(pop) ; 71
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_0@574@01 12652))
(pop) ; 70
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_0@574@01 12652))
(declare-const x_2@660@01 $Ref)
(assert (= x_2@660@01 (_checkDefined $Snap.unit tmp_0@574@01 12652)))
; [exec]
; inhale _isDefined(3301240)
(declare-const $t@661@01 $Snap)
(assert (= $t@661@01 $Snap.unit))
; [eval] _isDefined(3301240)
(push) ; 70
(assert (_isDefined%precondition $Snap.unit 3301240))
(pop) ; 70
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 3301240))
(assert (_isDefined $Snap.unit 3301240))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 70
(set-option :timeout 10)
(assert (not (not p2_8@657@01)))
(check-sat)
; unknown
(pop) ; 70
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 70
(set-option :timeout 10)
(assert (not p2_8@657@01))
(check-sat)
; unknown
(pop) ; 70
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1150 | p2_8@657@01 | live]
; [else-branch: 1150 | !(p2_8@657@01) | live]
(set-option :timeout 0)
(push) ; 70
; [then-branch: 1150 | p2_8@657@01]
(assert p2_8@657@01)
; [exec]
; x_2_0 := l1_0
; [exec]
; inhale true
(declare-const $t@662@01 $Snap)
(assert (= $t@662@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 71
(set-option :timeout 10)
(assert (not (not p3_1@658@01)))
(check-sat)
; unsat
(pop) ; 71
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1151 | p3_1@658@01 | dead]
; [else-branch: 1151 | !(p3_1@658@01) | live]
(set-option :timeout 0)
(push) ; 71
; [else-branch: 1151 | !(p3_1@658@01)]
(assert (not p3_1@658@01))
(pop) ; 71
; [eval] !p3_1
(push) ; 71
(set-option :timeout 10)
(assert (not p3_1@658@01))
(check-sat)
; unknown
(pop) ; 71
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 71
(set-option :timeout 10)
(assert (not (not p3_1@658@01)))
(check-sat)
; unsat
(pop) ; 71
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1152 | !(p3_1@658@01) | live]
; [else-branch: 1152 | p3_1@658@01 | dead]
(set-option :timeout 0)
(push) ; 71
; [then-branch: 1152 | !(p3_1@658@01)]
(assert (not p3_1@658@01))
(push) ; 72
(set-option :timeout 10)
(assert (not (not p4_1@659@01)))
(check-sat)
; unsat
(pop) ; 72
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1153 | p4_1@659@01 | dead]
; [else-branch: 1153 | !(p4_1@659@01) | live]
(set-option :timeout 0)
(push) ; 72
; [else-branch: 1153 | !(p4_1@659@01)]
(assert (not p4_1@659@01))
(pop) ; 72
; [eval] !p4_1
(push) ; 72
(set-option :timeout 10)
(assert (not p4_1@659@01))
(check-sat)
; unknown
(pop) ; 72
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 72
(set-option :timeout 10)
(assert (not (not p4_1@659@01)))
(check-sat)
; unsat
(pop) ; 72
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1154 | !(p4_1@659@01) | live]
; [else-branch: 1154 | p4_1@659@01 | dead]
(set-option :timeout 0)
(push) ; 72
; [then-branch: 1154 | !(p4_1@659@01)]
(assert (not p4_1@659@01))
; [exec]
; tmp_3 := new()
(declare-const tmp_3@663@01 $Ref)
(assert (not (= tmp_3@663@01 $Ref.null)))
(assert (not (= tmp_3@663@01 secret_7@488@01)))
(assert (not (= tmp_3@663@01 t2_14@508@01)))
(assert (not (= tmp_3@663@01 thread_arg_2@529@01)))
(assert (not (= tmp_3@663@01 threadingVar_6@520@01)))
(assert (not (= tmp_3@663@01 tmp1_38@597@01)))
(assert (not (= tmp_3@663@01 threadingVar_0@521@01)))
(assert (not (= tmp_3@663@01 secret@487@01)))
(assert (not (= tmp_3@663@01 tmp_3@543@01)))
(assert (not (= tmp_3@663@01 tmp_0@574@01)))
(assert (not (= tmp_3@663@01 thread_arg_9@524@01)))
(assert (not (= tmp_3@663@01 thread_arg_0_0@526@01)))
(assert (not (= tmp_3@663@01 tmp@554@01)))
(assert (not (= tmp_3@663@01 thread_arg_2_0@530@01)))
(assert (not (= tmp_3@663@01 _cthread_166_0@482@01)))
(assert (not (= tmp_3@663@01 tmp_1@605@01)))
(assert (not (= tmp_3@663@01 x_2@660@01)))
(assert (not (= tmp_3@663@01 thread_arg_1_0@528@01)))
(assert (not (= tmp_3@663@01 tmp1_51@648@01)))
(assert (not (= tmp_3@663@01 threadingVar@519@01)))
(assert (not (= tmp_3@663@01 threadingVar_0_0@522@01)))
(assert (not (= tmp_3@663@01 t2@507@01)))
(assert (not (= tmp_3@663@01 tmp_2@625@01)))
(assert (not (= tmp_3@663@01 _cthread_166@481@01)))
(assert (not (= tmp_3@663@01 tmp_4@544@01)))
(assert (not (= tmp_3@663@01 thread_arg@523@01)))
(assert (not (= tmp_3@663@01 thread_arg_1@527@01)))
(assert (not (= tmp_3@663@01 thread_arg_0@525@01)))
(assert (not (= tmp_3@663@01 t1_14@506@01)))
(assert (not (= tmp_3@663@01 t1@505@01)))
(push) ; 73
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 73
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1155 | p1_7@479@01 | live]
; [else-branch: 1155 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 73
; [then-branch: 1155 | p1_7@479@01]
; [exec]
; threadingVar := tmp_3
(push) ; 74
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 74
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1156 | p2_7@480@01 | live]
; [else-branch: 1156 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 74
; [then-branch: 1156 | p2_7@480@01]
; [exec]
; threadingVar_6 := tmp_3
(push) ; 75
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 75
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1157 | p1_7@479@01 | live]
; [else-branch: 1157 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 75
; [then-branch: 1157 | p1_7@479@01]
; [exec]
; inhale issubtype(typeof(threadingVar), Thread_0())
(declare-const $t@664@01 $Snap)
(assert (= $t@664@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar), Thread_0())
; [eval] typeof(threadingVar)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_3@663@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod(threadingVar) == printTwice_threading()
(declare-const $t@665@01 $Snap)
(assert (= $t@665@01 $Snap.unit))
; [eval] getMethod(threadingVar) == printTwice_threading()
; [eval] getMethod(threadingVar)
; [eval] printTwice_threading()
(assert (=
  (getMethod<ThreadingID> tmp_3@663@01)
  (as printTwice_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 76
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 76
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1158 | p2_7@480@01 | live]
; [else-branch: 1158 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 76
; [then-branch: 1158 | p2_7@480@01]
; [exec]
; inhale issubtype(typeof(threadingVar_6), Thread_0())
(declare-const $t@666@01 $Snap)
(assert (= $t@666@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_6), Thread_0())
; [eval] typeof(threadingVar_6)
; [eval] Thread_0()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod_0(threadingVar_6) == printTwice_threading()
(declare-const $t@667@01 $Snap)
(assert (= $t@667@01 $Snap.unit))
; [eval] getMethod_0(threadingVar_6) == printTwice_threading()
; [eval] getMethod_0(threadingVar_6)
; [eval] printTwice_threading()
(assert (=
  (getMethod_0<ThreadingID> tmp_3@663@01)
  (as printTwice_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; assert (p1_7 ==>
;   (true == issubtype(typeof(_checkDefined(x_2, 3301240)), Lock(Cell()))) ==
;   issubtype(typeof(__prim__int___box__(1)), int())) &&
;   (p2_7 ==>
;   (true == issubtype(typeof(x_2_0), Lock(Cell()))) ==
;   issubtype(typeof(__prim__int___box__(1)), int()))
; [eval] p1_7 ==> (true == issubtype(typeof(_checkDefined(x_2, 3301240)), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(1)), int())
(set-option :timeout 0)
(push) ; 77
(push) ; 78
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 78
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1159 | p1_7@479@01 | live]
; [else-branch: 1159 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 78
; [then-branch: 1159 | p1_7@479@01]
; [eval] (true == issubtype(typeof(_checkDefined(x_2, 3301240)), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(1)), int())
; [eval] true == issubtype(typeof(_checkDefined(x_2, 3301240)), Lock(Cell()))
; [eval] issubtype(typeof(_checkDefined(x_2, 3301240)), Lock(Cell()))
; [eval] typeof(_checkDefined(x_2, 3301240))
; [eval] _checkDefined(x_2, 3301240)
(push) ; 79
; [eval] _isDefined(id)
(push) ; 80
(pop) ; 80
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit x_2@660@01 3301240))
(pop) ; 79
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit x_2@660@01 3301240))
; [eval] Lock(Cell())
; [eval] Cell()
; [eval] issubtype(typeof(__prim__int___box__(1)), int())
; [eval] typeof(__prim__int___box__(1))
; [eval] __prim__int___box__(1)
(push) ; 79
(assert (__prim__int___box__%precondition $Snap.unit 1))
(pop) ; 79
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 1))
; [eval] int()
(pop) ; 78
(pop) ; 77
; Joined path conditions
(assert (=>
  p1_7@479@01
  (and
    (_checkDefined%precondition $Snap.unit x_2@660@01 3301240)
    (__prim__int___box__%precondition $Snap.unit 1))))
(push) ; 77
(assert (not (=>
  p1_7@479@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit x_2@660@01 3301240)) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 1)) (as int<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 77
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit x_2@660@01 3301240)) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 1)) (as int<PyType>  PyType)))))
; [eval] p2_7 ==> (true == issubtype(typeof(x_2_0), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(1)), int())
(push) ; 77
(push) ; 78
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 78
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1160 | p2_7@480@01 | live]
; [else-branch: 1160 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 78
; [then-branch: 1160 | p2_7@480@01]
; [eval] (true == issubtype(typeof(x_2_0), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(1)), int())
; [eval] true == issubtype(typeof(x_2_0), Lock(Cell()))
; [eval] issubtype(typeof(x_2_0), Lock(Cell()))
; [eval] typeof(x_2_0)
; [eval] Lock(Cell())
; [eval] Cell()
; [eval] issubtype(typeof(__prim__int___box__(1)), int())
; [eval] typeof(__prim__int___box__(1))
; [eval] __prim__int___box__(1)
(push) ; 79
(assert (__prim__int___box__%precondition $Snap.unit 1))
(pop) ; 79
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 1))
; [eval] int()
(pop) ; 78
(pop) ; 77
; Joined path conditions
(assert (=> p2_7@480@01 (__prim__int___box__%precondition $Snap.unit 1)))
(push) ; 77
(assert (not (=>
  p2_7@480@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 1)) (as int<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 77
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> tmp_0@574@01) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 1)) (as int<PyType>  PyType)))))
(push) ; 77
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 77
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1161 | p1_7@479@01 | live]
; [else-branch: 1161 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 77
; [then-branch: 1161 | p1_7@479@01]
; [exec]
; inhale true &&
;   (getArg(threadingVar, 0) == _checkDefined(x_2, 3301240) &&
;   getArg(threadingVar, 1) == __prim__int___box__(1))
(declare-const $t@668@01 $Snap)
(assert (= $t@668@01 ($Snap.combine ($Snap.first $t@668@01) ($Snap.second $t@668@01))))
(assert (= ($Snap.first $t@668@01) $Snap.unit))
(assert (=
  ($Snap.second $t@668@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@668@01))
    ($Snap.second ($Snap.second $t@668@01)))))
(assert (= ($Snap.first ($Snap.second $t@668@01)) $Snap.unit))
; [eval] getArg(threadingVar, 0) == _checkDefined(x_2, 3301240)
; [eval] getArg(threadingVar, 0)
; [eval] _checkDefined(x_2, 3301240)
(push) ; 78
; [eval] _isDefined(id)
(push) ; 79
(pop) ; 79
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit x_2@660@01 3301240))
(pop) ; 78
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit x_2@660@01 3301240))
(assert (= (getArg<Ref> tmp_3@663@01 0) (_checkDefined $Snap.unit x_2@660@01 3301240)))
(assert (= ($Snap.second ($Snap.second $t@668@01)) $Snap.unit))
; [eval] getArg(threadingVar, 1) == __prim__int___box__(1)
; [eval] getArg(threadingVar, 1)
; [eval] __prim__int___box__(1)
(push) ; 78
(assert (__prim__int___box__%precondition $Snap.unit 1))
(pop) ; 78
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 1))
(assert (= (getArg<Ref> tmp_3@663@01 1) (__prim__int___box__ $Snap.unit 1)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start(threadingVar), write)
(declare-const $t@669@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t1 := threadingVar
; [exec]
; inhale _isDefined(12660)
(declare-const $t@670@01 $Snap)
(assert (= $t@670@01 $Snap.unit))
; [eval] _isDefined(12660)
(set-option :timeout 0)
(push) ; 78
(assert (_isDefined%precondition $Snap.unit 12660))
(pop) ; 78
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 12660))
(assert (_isDefined $Snap.unit 12660))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 78
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 78
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1162 | p2_7@480@01 | live]
; [else-branch: 1162 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 78
; [then-branch: 1162 | p2_7@480@01]
; [exec]
; inhale true &&
;   (getArg_0(threadingVar_6, 0) == x_2_0 &&
;   getArg_0(threadingVar_6, 1) == __prim__int___box__(1))
(declare-const $t@671@01 $Snap)
(assert (= $t@671@01 ($Snap.combine ($Snap.first $t@671@01) ($Snap.second $t@671@01))))
(assert (= ($Snap.first $t@671@01) $Snap.unit))
(assert (=
  ($Snap.second $t@671@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@671@01))
    ($Snap.second ($Snap.second $t@671@01)))))
(assert (= ($Snap.first ($Snap.second $t@671@01)) $Snap.unit))
; [eval] getArg_0(threadingVar_6, 0) == x_2_0
; [eval] getArg_0(threadingVar_6, 0)
(assert (= (getArg_0<Ref> tmp_3@663@01 0) tmp_0@574@01))
(assert (= ($Snap.second ($Snap.second $t@671@01)) $Snap.unit))
; [eval] getArg_0(threadingVar_6, 1) == __prim__int___box__(1)
; [eval] getArg_0(threadingVar_6, 1)
; [eval] __prim__int___box__(1)
(push) ; 79
(pop) ; 79
; Joined path conditions
(assert (= (getArg_0<Ref> tmp_3@663@01 1) (__prim__int___box__ $Snap.unit 1)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start_0(threadingVar_6), write)
(declare-const $t@672@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t1_14 := threadingVar_6
; [exec]
; inhale true
(declare-const $t@673@01 $Snap)
(assert (= $t@673@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; tmp_4 := new()
(declare-const tmp_4@674@01 $Ref)
(assert (not (= tmp_4@674@01 $Ref.null)))
(assert (not (= tmp_4@674@01 tmp_3@663@01)))
(assert (not (= tmp_4@674@01 secret_7@488@01)))
(assert (not (= tmp_4@674@01 t2_14@508@01)))
(assert (not (= tmp_4@674@01 thread_arg_2@529@01)))
(assert (not (= tmp_4@674@01 tmp1_38@597@01)))
(assert (not (= tmp_4@674@01 threadingVar_0@521@01)))
(assert (not (= tmp_4@674@01 secret@487@01)))
(assert (not (= tmp_4@674@01 tmp_0@574@01)))
(assert (not (= tmp_4@674@01 thread_arg_9@524@01)))
(assert (not (= tmp_4@674@01 thread_arg_0_0@526@01)))
(assert (not (= tmp_4@674@01 tmp@554@01)))
(assert (not (= tmp_4@674@01 thread_arg_2_0@530@01)))
(assert (not (= tmp_4@674@01 _cthread_166_0@482@01)))
(assert (not (= tmp_4@674@01 tmp_1@605@01)))
(assert (not (= tmp_4@674@01 x_2@660@01)))
(assert (not (= tmp_4@674@01 thread_arg_1_0@528@01)))
(assert (not (= tmp_4@674@01 tmp1_51@648@01)))
(assert (not (= tmp_4@674@01 threadingVar_0_0@522@01)))
(assert (not (= tmp_4@674@01 t2@507@01)))
(assert (not (= tmp_4@674@01 tmp_2@625@01)))
(assert (not (= tmp_4@674@01 _cthread_166@481@01)))
(assert (not (= tmp_4@674@01 tmp_4@544@01)))
(assert (not (= tmp_4@674@01 thread_arg@523@01)))
(assert (not (= tmp_4@674@01 thread_arg_1@527@01)))
(assert (not (= tmp_4@674@01 thread_arg_0@525@01)))
(set-option :timeout 0)
(push) ; 79
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 79
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1163 | p1_7@479@01 | live]
; [else-branch: 1163 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 79
; [then-branch: 1163 | p1_7@479@01]
; [exec]
; threadingVar_0 := tmp_4
(push) ; 80
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 80
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1164 | p2_7@480@01 | live]
; [else-branch: 1164 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 80
; [then-branch: 1164 | p2_7@480@01]
; [exec]
; threadingVar_0_0 := tmp_4
(push) ; 81
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 81
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1165 | p1_7@479@01 | live]
; [else-branch: 1165 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 81
; [then-branch: 1165 | p1_7@479@01]
; [exec]
; inhale issubtype(typeof(threadingVar_0), Thread_0())
(declare-const $t@675@01 $Snap)
(assert (= $t@675@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_0), Thread_0())
; [eval] typeof(threadingVar_0)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_4@674@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod(threadingVar_0) == printTwice_threading()
(declare-const $t@676@01 $Snap)
(assert (= $t@676@01 $Snap.unit))
; [eval] getMethod(threadingVar_0) == printTwice_threading()
; [eval] getMethod(threadingVar_0)
; [eval] printTwice_threading()
(assert (=
  (getMethod<ThreadingID> tmp_4@674@01)
  (as printTwice_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 82
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 82
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1166 | p2_7@480@01 | live]
; [else-branch: 1166 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 82
; [then-branch: 1166 | p2_7@480@01]
; [exec]
; inhale issubtype(typeof(threadingVar_0_0), Thread_0())
(declare-const $t@677@01 $Snap)
(assert (= $t@677@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_0_0), Thread_0())
; [eval] typeof(threadingVar_0_0)
; [eval] Thread_0()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod_0(threadingVar_0_0) == printTwice_threading()
(declare-const $t@678@01 $Snap)
(assert (= $t@678@01 $Snap.unit))
; [eval] getMethod_0(threadingVar_0_0) == printTwice_threading()
; [eval] getMethod_0(threadingVar_0_0)
; [eval] printTwice_threading()
(assert (=
  (getMethod_0<ThreadingID> tmp_4@674@01)
  (as printTwice_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; assert (p1_7 ==>
;   (true == issubtype(typeof(_checkDefined(l2, 12908)), Lock(Cell()))) ==
;   issubtype(typeof(__prim__int___box__(2)), int())) &&
;   (p2_7 ==>
;   (true == issubtype(typeof(l2_0), Lock(Cell()))) ==
;   issubtype(typeof(__prim__int___box__(2)), int()))
; [eval] p1_7 ==> (true == issubtype(typeof(_checkDefined(l2, 12908)), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(2)), int())
(set-option :timeout 0)
(push) ; 83
(push) ; 84
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1167 | p1_7@479@01 | live]
; [else-branch: 1167 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 84
; [then-branch: 1167 | p1_7@479@01]
; [eval] (true == issubtype(typeof(_checkDefined(l2, 12908)), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(2)), int())
; [eval] true == issubtype(typeof(_checkDefined(l2, 12908)), Lock(Cell()))
; [eval] issubtype(typeof(_checkDefined(l2, 12908)), Lock(Cell()))
; [eval] typeof(_checkDefined(l2, 12908))
; [eval] _checkDefined(l2, 12908)
(push) ; 85
; [eval] _isDefined(id)
(push) ; 86
(pop) ; 86
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_2@625@01 12908))
(pop) ; 85
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_2@625@01 12908))
; [eval] Lock(Cell())
; [eval] Cell()
; [eval] issubtype(typeof(__prim__int___box__(2)), int())
; [eval] typeof(__prim__int___box__(2))
; [eval] __prim__int___box__(2)
(push) ; 85
(assert (__prim__int___box__%precondition $Snap.unit 2))
(pop) ; 85
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 2))
; [eval] int()
(pop) ; 84
(pop) ; 83
; Joined path conditions
(assert (=>
  p1_7@479@01
  (and
    (_checkDefined%precondition $Snap.unit tmp_2@625@01 12908)
    (__prim__int___box__%precondition $Snap.unit 2))))
(push) ; 83
(assert (not (=>
  p1_7@479@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit tmp_2@625@01 12908)) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 2)) (as int<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 83
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit tmp_2@625@01 12908)) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 2)) (as int<PyType>  PyType)))))
; [eval] p2_7 ==> (true == issubtype(typeof(l2_0), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(2)), int())
(push) ; 83
(push) ; 84
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1168 | p2_7@480@01 | live]
; [else-branch: 1168 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 84
; [then-branch: 1168 | p2_7@480@01]
; [eval] (true == issubtype(typeof(l2_0), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(2)), int())
; [eval] true == issubtype(typeof(l2_0), Lock(Cell()))
; [eval] issubtype(typeof(l2_0), Lock(Cell()))
; [eval] typeof(l2_0)
; [eval] Lock(Cell())
; [eval] Cell()
; [eval] issubtype(typeof(__prim__int___box__(2)), int())
; [eval] typeof(__prim__int___box__(2))
; [eval] __prim__int___box__(2)
(push) ; 85
(assert (__prim__int___box__%precondition $Snap.unit 2))
(pop) ; 85
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 2))
; [eval] int()
(pop) ; 84
(pop) ; 83
; Joined path conditions
(assert (=> p2_7@480@01 (__prim__int___box__%precondition $Snap.unit 2)))
(push) ; 83
(assert (not (=>
  p2_7@480@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 2)) (as int<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 83
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 2)) (as int<PyType>  PyType)))))
(push) ; 83
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 83
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1169 | p1_7@479@01 | live]
; [else-branch: 1169 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 83
; [then-branch: 1169 | p1_7@479@01]
; [exec]
; inhale true &&
;   (getArg(threadingVar_0, 0) == _checkDefined(l2, 12908) &&
;   getArg(threadingVar_0, 1) == __prim__int___box__(2))
(declare-const $t@679@01 $Snap)
(assert (= $t@679@01 ($Snap.combine ($Snap.first $t@679@01) ($Snap.second $t@679@01))))
(assert (= ($Snap.first $t@679@01) $Snap.unit))
(assert (=
  ($Snap.second $t@679@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@679@01))
    ($Snap.second ($Snap.second $t@679@01)))))
(assert (= ($Snap.first ($Snap.second $t@679@01)) $Snap.unit))
; [eval] getArg(threadingVar_0, 0) == _checkDefined(l2, 12908)
; [eval] getArg(threadingVar_0, 0)
; [eval] _checkDefined(l2, 12908)
(push) ; 84
; [eval] _isDefined(id)
(push) ; 85
(pop) ; 85
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_2@625@01 12908))
(pop) ; 84
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_2@625@01 12908))
(assert (= (getArg<Ref> tmp_4@674@01 0) (_checkDefined $Snap.unit tmp_2@625@01 12908)))
(assert (= ($Snap.second ($Snap.second $t@679@01)) $Snap.unit))
; [eval] getArg(threadingVar_0, 1) == __prim__int___box__(2)
; [eval] getArg(threadingVar_0, 1)
; [eval] __prim__int___box__(2)
(push) ; 84
(assert (__prim__int___box__%precondition $Snap.unit 2))
(pop) ; 84
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 2))
(assert (= (getArg<Ref> tmp_4@674@01 1) (__prim__int___box__ $Snap.unit 2)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start(threadingVar_0), write)
(declare-const $t@680@01 $Snap)
(set-option :timeout 0)
(push) ; 84
(set-option :timeout 10)
(assert (not (= tmp_3@663@01 tmp_4@674@01)))
(check-sat)
; unknown
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; t2 := threadingVar_0
; [exec]
; inhale _isDefined(12916)
(declare-const $t@681@01 $Snap)
(assert (= $t@681@01 $Snap.unit))
; [eval] _isDefined(12916)
(set-option :timeout 0)
(push) ; 84
(assert (_isDefined%precondition $Snap.unit 12916))
(pop) ; 84
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 12916))
(assert (_isDefined $Snap.unit 12916))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; exhale acc(_thread_start(_checkDefined(t1, 12660)), write)
; [eval] _checkDefined(t1, 12660)
(set-option :timeout 0)
(push) ; 84
; [eval] _isDefined(id)
(push) ; 85
(pop) ; 85
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_3@663@01 12660))
(pop) ; 84
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_3@663@01 12660))
(push) ; 84
(set-option :timeout 10)
(assert (not (= tmp_4@674@01 (_checkDefined $Snap.unit tmp_3@663@01 12660))))
(check-sat)
; unknown
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 84
(set-option :timeout 10)
(assert (not (= tmp_3@663@01 (_checkDefined $Snap.unit tmp_3@663@01 12660))))
(check-sat)
; unsat
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 84
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1170 | p2_7@480@01 | live]
; [else-branch: 1170 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 84
; [then-branch: 1170 | p2_7@480@01]
; [exec]
; inhale true &&
;   (getArg_0(threadingVar_0_0, 0) == l2_0 &&
;   getArg_0(threadingVar_0_0, 1) == __prim__int___box__(2))
(declare-const $t@682@01 $Snap)
(assert (= $t@682@01 ($Snap.combine ($Snap.first $t@682@01) ($Snap.second $t@682@01))))
(assert (= ($Snap.first $t@682@01) $Snap.unit))
(assert (=
  ($Snap.second $t@682@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@682@01))
    ($Snap.second ($Snap.second $t@682@01)))))
(assert (= ($Snap.first ($Snap.second $t@682@01)) $Snap.unit))
; [eval] getArg_0(threadingVar_0_0, 0) == l2_0
; [eval] getArg_0(threadingVar_0_0, 0)
(assert (= (getArg_0<Ref> tmp_4@674@01 0) tmp_2@625@01))
(assert (= ($Snap.second ($Snap.second $t@682@01)) $Snap.unit))
; [eval] getArg_0(threadingVar_0_0, 1) == __prim__int___box__(2)
; [eval] getArg_0(threadingVar_0_0, 1)
; [eval] __prim__int___box__(2)
(push) ; 85
(pop) ; 85
; Joined path conditions
(assert (= (getArg_0<Ref> tmp_4@674@01 1) (__prim__int___box__ $Snap.unit 2)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start_0(threadingVar_0_0), write)
(declare-const $t@683@01 $Snap)
(set-option :timeout 0)
(push) ; 85
(set-option :timeout 10)
(assert (not (= tmp_3@663@01 tmp_4@674@01)))
(check-sat)
; unknown
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; t2_14 := threadingVar_0_0
; [exec]
; inhale true
(declare-const $t@684@01 $Snap)
(assert (= $t@684@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale acc(_thread_start_0(t1_14), write)
; [exec]
; assert (p1_7 ==>
;   false || getMethod(_checkDefined(t1, 12660)) == printTwice_threading()) &&
;   (p2_7 ==> false || getMethod_0(t1_14) == printTwice_threading())
; [eval] p1_7 ==> false || getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
(set-option :timeout 0)
(push) ; 85
(push) ; 86
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 86
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1171 | p1_7@479@01 | live]
; [else-branch: 1171 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 86
; [then-branch: 1171 | p1_7@479@01]
; [eval] false || getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
(push) ; 87
; [then-branch: 1172 | False | live]
; [else-branch: 1172 | True | live]
(push) ; 88
; [then-branch: 1172 | False]
(assert false)
(pop) ; 88
(push) ; 88
; [else-branch: 1172 | True]
; [eval] getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
; [eval] getMethod(_checkDefined(t1, 12660))
; [eval] _checkDefined(t1, 12660)
(push) ; 89
; [eval] _isDefined(id)
(push) ; 90
(pop) ; 90
; Joined path conditions
(pop) ; 89
; Joined path conditions
; [eval] printTwice_threading()
(pop) ; 88
(pop) ; 87
; Joined path conditions
; Joined path conditions
(pop) ; 86
(pop) ; 85
; Joined path conditions
(push) ; 85
(assert (not (=>
  p1_7@479@01
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_3@663@01 12660))
    (as printTwice_threading<ThreadingID>  ThreadingID)))))
(check-sat)
; unsat
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_3@663@01 12660))
    (as printTwice_threading<ThreadingID>  ThreadingID))))
; [eval] p2_7 ==> false || getMethod_0(t1_14) == printTwice_threading()
(push) ; 85
(push) ; 86
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 86
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1173 | p2_7@480@01 | live]
; [else-branch: 1173 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 86
; [then-branch: 1173 | p2_7@480@01]
; [eval] false || getMethod_0(t1_14) == printTwice_threading()
(push) ; 87
; [then-branch: 1174 | False | live]
; [else-branch: 1174 | True | live]
(push) ; 88
; [then-branch: 1174 | False]
(assert false)
(pop) ; 88
(push) ; 88
; [else-branch: 1174 | True]
; [eval] getMethod_0(t1_14) == printTwice_threading()
; [eval] getMethod_0(t1_14)
; [eval] printTwice_threading()
(pop) ; 88
(pop) ; 87
; Joined path conditions
; Joined path conditions
(pop) ; 86
(pop) ; 85
; Joined path conditions
(push) ; 85
(assert (not (=>
  p2_7@480@01
  (=
    (getMethod_0<ThreadingID> tmp_3@663@01)
    (as printTwice_threading<ThreadingID>  ThreadingID)))))
(check-sat)
; unsat
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (=
    (getMethod_0<ThreadingID> tmp_3@663@01)
    (as printTwice_threading<ThreadingID>  ThreadingID))))
; [exec]
; p1_9 := p1_7 &&
;   getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
; [eval] p1_7 && getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
(push) ; 85
; [then-branch: 1175 | !(p1_7@479@01) | live]
; [else-branch: 1175 | p1_7@479@01 | live]
(push) ; 86
; [then-branch: 1175 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 86
(push) ; 86
; [else-branch: 1175 | p1_7@479@01]
; [eval] getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
; [eval] getMethod(_checkDefined(t1, 12660))
; [eval] _checkDefined(t1, 12660)
(push) ; 87
; [eval] _isDefined(id)
(push) ; 88
(pop) ; 88
; Joined path conditions
(pop) ; 87
; Joined path conditions
; [eval] printTwice_threading()
(pop) ; 86
(pop) ; 85
; Joined path conditions
; Joined path conditions
(declare-const p1_9@685@01 Bool)
(assert (=
  p1_9@685@01
  (and
    p1_7@479@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_3@663@01 12660))
      (as printTwice_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_9 := p2_7 && getMethod_0(t1_14) == printTwice_threading()
; [eval] p2_7 && getMethod_0(t1_14) == printTwice_threading()
(push) ; 85
; [then-branch: 1176 | !(p2_7@480@01) | live]
; [else-branch: 1176 | p2_7@480@01 | live]
(push) ; 86
; [then-branch: 1176 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 86
(push) ; 86
; [else-branch: 1176 | p2_7@480@01]
; [eval] getMethod_0(t1_14) == printTwice_threading()
; [eval] getMethod_0(t1_14)
; [eval] printTwice_threading()
(pop) ; 86
(pop) ; 85
; Joined path conditions
; Joined path conditions
(declare-const p2_9@686@01 Bool)
(assert (=
  p2_9@686@01
  (and
    p2_7@480@01
    (=
      (getMethod_0<ThreadingID> tmp_3@663@01)
      (as printTwice_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_2 := p1_7 &&
;   !(getMethod(_checkDefined(t1, 12660)) == printTwice_threading())
; [eval] p1_7 && !(getMethod(_checkDefined(t1, 12660)) == printTwice_threading())
(push) ; 85
; [then-branch: 1177 | !(p1_7@479@01) | live]
; [else-branch: 1177 | p1_7@479@01 | live]
(push) ; 86
; [then-branch: 1177 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 86
(push) ; 86
; [else-branch: 1177 | p1_7@479@01]
; [eval] !(getMethod(_checkDefined(t1, 12660)) == printTwice_threading())
; [eval] getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
; [eval] getMethod(_checkDefined(t1, 12660))
; [eval] _checkDefined(t1, 12660)
(push) ; 87
; [eval] _isDefined(id)
(push) ; 88
(pop) ; 88
; Joined path conditions
(pop) ; 87
; Joined path conditions
; [eval] printTwice_threading()
(pop) ; 86
(pop) ; 85
; Joined path conditions
; Joined path conditions
(declare-const p3_2@687@01 Bool)
(assert (=
  p3_2@687@01
  (and
    p1_7@479@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_3@663@01 12660))
        (as printTwice_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_2 := p2_7 && !(getMethod_0(t1_14) == printTwice_threading())
; [eval] p2_7 && !(getMethod_0(t1_14) == printTwice_threading())
(push) ; 85
; [then-branch: 1178 | !(p2_7@480@01) | live]
; [else-branch: 1178 | p2_7@480@01 | live]
(push) ; 86
; [then-branch: 1178 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 86
(push) ; 86
; [else-branch: 1178 | p2_7@480@01]
; [eval] !(getMethod_0(t1_14) == printTwice_threading())
; [eval] getMethod_0(t1_14) == printTwice_threading()
; [eval] getMethod_0(t1_14)
; [eval] printTwice_threading()
(pop) ; 86
(pop) ; 85
; Joined path conditions
; Joined path conditions
(declare-const p4_2@688@01 Bool)
(assert (=
  p4_2@688@01
  (and
    p2_7@480@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_3@663@01)
        (as printTwice_threading<ThreadingID>  ThreadingID))))))
(push) ; 85
(set-option :timeout 10)
(assert (not (not p1_9@685@01)))
(check-sat)
; unknown
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 85
(set-option :timeout 10)
(assert (not p1_9@685@01))
(check-sat)
; unsat
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1179 | p1_9@685@01 | live]
; [else-branch: 1179 | !(p1_9@685@01) | dead]
(set-option :timeout 0)
(push) ; 85
; [then-branch: 1179 | p1_9@685@01]
(assert p1_9@685@01)
; [exec]
; thread_arg := getArg(_checkDefined(t1, 12660), 0)
; [eval] getArg(_checkDefined(t1, 12660), 0)
; [eval] _checkDefined(t1, 12660)
(push) ; 86
; [eval] _isDefined(id)
(push) ; 87
(pop) ; 87
; Joined path conditions
(pop) ; 86
; Joined path conditions
(declare-const thread_arg@689@01 $Ref)
(assert (=
  thread_arg@689@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_3@663@01 12660) 0)))
; [exec]
; inhale issubtype(typeof(thread_arg), Lock(Cell()))
(declare-const $t@690@01 $Snap)
(assert (= $t@690@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg), Lock(Cell()))
; [eval] typeof(thread_arg)
; [eval] Lock(Cell())
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg@689@01) (Lock<PyType> (as Cell<PyType>  PyType))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; thread_arg_0 := getArg(_checkDefined(t1, 12660), 1)
; [eval] getArg(_checkDefined(t1, 12660), 1)
; [eval] _checkDefined(t1, 12660)
(set-option :timeout 0)
(push) ; 86
; [eval] _isDefined(id)
(push) ; 87
(pop) ; 87
; Joined path conditions
(pop) ; 86
; Joined path conditions
(declare-const thread_arg_0@691@01 $Ref)
(assert (=
  thread_arg_0@691@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_3@663@01 12660) 1)))
; [exec]
; inhale issubtype(typeof(thread_arg_0), int())
(declare-const $t@692@01 $Snap)
(assert (= $t@692@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_0), int())
; [eval] typeof(thread_arg_0)
; [eval] int()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_0@691@01) (as int<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@693@01 $Snap)
(assert (= $t@693@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 86
(set-option :timeout 10)
(assert (not (not p2_9@686@01)))
(check-sat)
; unknown
(pop) ; 86
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 86
(set-option :timeout 10)
(assert (not p2_9@686@01))
(check-sat)
; unsat
(pop) ; 86
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1180 | p2_9@686@01 | live]
; [else-branch: 1180 | !(p2_9@686@01) | dead]
(set-option :timeout 0)
(push) ; 86
; [then-branch: 1180 | p2_9@686@01]
(assert p2_9@686@01)
; [exec]
; thread_arg_9 := getArg_0(t1_14, 0)
; [eval] getArg_0(t1_14, 0)
(declare-const thread_arg_9@694@01 $Ref)
(assert (= thread_arg_9@694@01 (getArg_0<Ref> tmp_3@663@01 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_9), Lock(Cell()))
(declare-const $t@695@01 $Snap)
(assert (= $t@695@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_9), Lock(Cell()))
; [eval] typeof(thread_arg_9)
; [eval] Lock(Cell())
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_9@694@01) (Lock<PyType> (as Cell<PyType>  PyType))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; thread_arg_0_0 := getArg_0(t1_14, 1)
; [eval] getArg_0(t1_14, 1)
(declare-const thread_arg_0_0@696@01 $Ref)
(assert (= thread_arg_0_0@696@01 (getArg_0<Ref> tmp_3@663@01 1)))
; [exec]
; inhale issubtype(typeof(thread_arg_0_0), int())
(declare-const $t@697@01 $Snap)
(assert (= $t@697@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_0_0), int())
; [eval] typeof(thread_arg_0_0)
; [eval] int()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_0_0@696@01) (as int<PyType>  PyType)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@698@01 $Snap)
(assert (= $t@698@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale (p1_9 ==> true) &&
;   ((p2_9 ==> true) &&
;   (p1_9 == p2_9 &&
;   ((p1_9 && p2_9 ==> thread_arg == thread_arg_9) &&
;   (p1_9 && p2_9 ==> thread_arg_0 == thread_arg_0_0) &&
;   ((p1_9 ==> true) && (p2_9 ==> true) &&
;   ((p1_9 ==> true) && (p2_9 ==> true))))))
; [eval] p1_9 ==> true
(set-option :timeout 0)
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not p1_9@685@01)))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1181 | p1_9@685@01 | live]
; [else-branch: 1181 | !(p1_9@685@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1181 | p1_9@685@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
; [eval] p2_9 ==> true
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not p2_9@686@01)))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1182 | p2_9@686@01 | live]
; [else-branch: 1182 | !(p2_9@686@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1182 | p2_9@686@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
; [eval] p1_9 == p2_9
(push) ; 87
(assert (not (= p1_9@685@01 p2_9@686@01)))
(check-sat)
; unsat
(pop) ; 87
; 0.00s
; (get-info :all-statistics)
(assert (= p1_9@685@01 p2_9@686@01))
; [eval] p1_9 && p2_9 ==> thread_arg == thread_arg_9
; [eval] p1_9 && p2_9
(push) ; 87
; [then-branch: 1183 | !(p1_9@685@01) | live]
; [else-branch: 1183 | p1_9@685@01 | live]
(push) ; 88
; [then-branch: 1183 | !(p1_9@685@01)]
(assert (not p1_9@685@01))
(pop) ; 88
(push) ; 88
; [else-branch: 1183 | p1_9@685@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
; Joined path conditions
(assert (or p1_9@685@01 (not p1_9@685@01)))
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not (and p1_9@685@01 p2_9@686@01))))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 88
(set-option :timeout 10)
(assert (not (and p1_9@685@01 p2_9@686@01)))
(check-sat)
; unsat
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1184 | p1_9@685@01 && p2_9@686@01 | live]
; [else-branch: 1184 | !(p1_9@685@01 && p2_9@686@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1184 | p1_9@685@01 && p2_9@686@01]
(assert (and p1_9@685@01 p2_9@686@01))
; [eval] thread_arg == thread_arg_9
(pop) ; 88
(pop) ; 87
; Joined path conditions
(assert (and p1_9@685@01 p2_9@686@01))
(push) ; 87
(assert (not (=> (and p1_9@685@01 p2_9@686@01) (= thread_arg@689@01 thread_arg_9@694@01))))
(check-sat)
; unsat
(pop) ; 87
; 0.00s
; (get-info :all-statistics)
(assert (=> (and p1_9@685@01 p2_9@686@01) (= thread_arg@689@01 thread_arg_9@694@01)))
; [eval] p1_9 && p2_9 ==> thread_arg_0 == thread_arg_0_0
; [eval] p1_9 && p2_9
(push) ; 87
; [then-branch: 1185 | !(p1_9@685@01) | live]
; [else-branch: 1185 | p1_9@685@01 | live]
(push) ; 88
; [then-branch: 1185 | !(p1_9@685@01)]
(assert (not p1_9@685@01))
(pop) ; 88
(push) ; 88
; [else-branch: 1185 | p1_9@685@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
; Joined path conditions
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not (and p1_9@685@01 p2_9@686@01))))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 88
(set-option :timeout 10)
(assert (not (and p1_9@685@01 p2_9@686@01)))
(check-sat)
; unsat
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1186 | p1_9@685@01 && p2_9@686@01 | live]
; [else-branch: 1186 | !(p1_9@685@01 && p2_9@686@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1186 | p1_9@685@01 && p2_9@686@01]
(assert (and p1_9@685@01 p2_9@686@01))
; [eval] thread_arg_0 == thread_arg_0_0
(pop) ; 88
(pop) ; 87
; Joined path conditions
(assert (and p1_9@685@01 p2_9@686@01))
(push) ; 87
(assert (not (=> (and p1_9@685@01 p2_9@686@01) (= thread_arg_0@691@01 thread_arg_0_0@696@01))))
(check-sat)
; unsat
(pop) ; 87
; 0.00s
; (get-info :all-statistics)
(assert (=> (and p1_9@685@01 p2_9@686@01) (= thread_arg_0@691@01 thread_arg_0_0@696@01)))
; [eval] p1_9 ==> true
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not p1_9@685@01)))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1187 | p1_9@685@01 | live]
; [else-branch: 1187 | !(p1_9@685@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1187 | p1_9@685@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
; [eval] p2_9 ==> true
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not p2_9@686@01)))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1188 | p2_9@686@01 | live]
; [else-branch: 1188 | !(p2_9@686@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1188 | p2_9@686@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
; [eval] p1_9 ==> true
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not p1_9@685@01)))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1189 | p1_9@685@01 | live]
; [else-branch: 1189 | !(p1_9@685@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1189 | p1_9@685@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
; [eval] p2_9 ==> true
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not p2_9@686@01)))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1190 | p2_9@686@01 | live]
; [else-branch: 1190 | !(p2_9@686@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1190 | p2_9@686@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
(push) ; 87
(set-option :timeout 10)
(assert (not (not p1_9@685@01)))
(check-sat)
; unknown
(pop) ; 87
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1191 | p1_9@685@01 | live]
; [else-branch: 1191 | !(p1_9@685@01) | dead]
(set-option :timeout 0)
(push) ; 87
; [then-branch: 1191 | p1_9@685@01]
; [exec]
; inhale true ==>
;   _joinable(_checkDefined(t1, 12660)) &&
;   acc(_thread_post(_checkDefined(t1, 12660)), write)
(push) ; 88
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1192 | True | live]
; [else-branch: 1192 | False | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1192 | True]
(declare-const $t@699@01 $Snap)
(assert (= $t@699@01 ($Snap.combine ($Snap.first $t@699@01) ($Snap.second $t@699@01))))
(assert (= ($Snap.first $t@699@01) $Snap.unit))
; [eval] _joinable(_checkDefined(t1, 12660))
; [eval] _checkDefined(t1, 12660)
(push) ; 89
; [eval] _isDefined(id)
(push) ; 90
(pop) ; 90
; Joined path conditions
(pop) ; 89
; Joined path conditions
(push) ; 89
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_3@663@01 12660)))
(pop) ; 89
; Joined path conditions
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_3@663@01 12660)))
(assert (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_3@663@01 12660)))
; [eval] _checkDefined(t1, 12660)
(push) ; 89
; [eval] _isDefined(id)
(push) ; 90
(pop) ; 90
; Joined path conditions
(pop) ; 89
; Joined path conditions
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 89
(set-option :timeout 10)
(assert (not (not p2_9@686@01)))
(check-sat)
; unknown
(pop) ; 89
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1193 | p2_9@686@01 | live]
; [else-branch: 1193 | !(p2_9@686@01) | dead]
(set-option :timeout 0)
(push) ; 89
; [then-branch: 1193 | p2_9@686@01]
; [exec]
; inhale true ==> _joinable(t1_14) && acc(_thread_post_0(t1_14), write)
(push) ; 90
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 90
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1194 | True | live]
; [else-branch: 1194 | False | dead]
(set-option :timeout 0)
(push) ; 90
; [then-branch: 1194 | True]
(declare-const $t@700@01 $Snap)
(assert (= $t@700@01 ($Snap.combine ($Snap.first $t@700@01) ($Snap.second $t@700@01))))
(assert (= ($Snap.first $t@700@01) $Snap.unit))
; [eval] _joinable(t1_14)
(push) ; 91
(assert (_joinable%precondition $Snap.unit tmp_3@663@01))
(pop) ; 91
; Joined path conditions
(assert (_joinable%precondition $Snap.unit tmp_3@663@01))
(assert (_joinable $Snap.unit tmp_3@663@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 91
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 91
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1195 | p1_7@479@01 | live]
; [else-branch: 1195 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 91
; [then-branch: 1195 | p1_7@479@01]
; [exec]
; inhale (forperm
;     _r_19: Ref [_r_19.MustReleaseBounded] :: Level(_r_19) <
;     Level(_checkDefined(t1, 12660))) &&
;   ((forperm
;     _r_19: Ref [_r_19.MustReleaseUnbounded] :: Level(_r_19) <
;     Level(_checkDefined(t1, 12660))) &&
;   _residue_166 < Level(_checkDefined(t1, 12660)))
(declare-const $t@701@01 $Snap)
(assert (= $t@701@01 ($Snap.combine ($Snap.first $t@701@01) ($Snap.second $t@701@01))))
(assert (= ($Snap.first $t@701@01) $Snap.unit))
; [eval] (forperm _r_19: Ref [_r_19.MustReleaseBounded] :: Level(_r_19) < Level(_checkDefined(t1, 12660)))
(assert (=
  ($Snap.second $t@701@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@701@01))
    ($Snap.second ($Snap.second $t@701@01)))))
(assert (= ($Snap.first ($Snap.second $t@701@01)) $Snap.unit))
; [eval] (forperm _r_19: Ref [_r_19.MustReleaseUnbounded] :: Level(_r_19) < Level(_checkDefined(t1, 12660)))
(assert (= ($Snap.second ($Snap.second $t@701@01)) $Snap.unit))
; [eval] _residue_166 < Level(_checkDefined(t1, 12660))
; [eval] Level(_checkDefined(t1, 12660))
; [eval] _checkDefined(t1, 12660)
(push) ; 92
; [eval] _isDefined(id)
(push) ; 93
(pop) ; 93
; Joined path conditions
(pop) ; 92
; Joined path conditions
(push) ; 92
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_3@663@01 12660)))
(pop) ; 92
; Joined path conditions
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_3@663@01 12660)))
(assert (<
  _residue_166@485@01
  (Level $Snap.unit (_checkDefined $Snap.unit tmp_3@663@01 12660))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; exhale acc(_thread_start(_checkDefined(t2, 12916)), write)
; [eval] _checkDefined(t2, 12916)
(set-option :timeout 0)
(push) ; 92
; [eval] _isDefined(id)
(push) ; 93
(pop) ; 93
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_4@674@01 12916))
(pop) ; 92
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_4@674@01 12916))
(push) ; 92
(set-option :timeout 10)
(assert (not (= tmp_4@674@01 (_checkDefined $Snap.unit tmp_4@674@01 12916))))
(check-sat)
; unsat
(pop) ; 92
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 92
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 92
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1196 | p2_7@480@01 | live]
; [else-branch: 1196 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 92
; [then-branch: 1196 | p2_7@480@01]
; [exec]
; inhale (forperm
;     _r_19: Ref [_r_19.MustReleaseBoundedp] :: Level(_r_19) < Level(t1_14)) &&
;   ((forperm
;     _r_19: Ref [_r_19.MustReleaseUnboundedp] :: Level(_r_19) < Level(t1_14)) &&
;   _residue_166_0 < Level(t1_14))
(declare-const $t@702@01 $Snap)
(assert (= $t@702@01 ($Snap.combine ($Snap.first $t@702@01) ($Snap.second $t@702@01))))
(assert (= ($Snap.first $t@702@01) $Snap.unit))
; [eval] (forperm _r_19: Ref [_r_19.MustReleaseBoundedp] :: Level(_r_19) < Level(t1_14))
(assert (=
  ($Snap.second $t@702@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@702@01))
    ($Snap.second ($Snap.second $t@702@01)))))
(assert (= ($Snap.first ($Snap.second $t@702@01)) $Snap.unit))
; [eval] (forperm _r_19: Ref [_r_19.MustReleaseUnboundedp] :: Level(_r_19) < Level(t1_14))
(assert (= ($Snap.second ($Snap.second $t@702@01)) $Snap.unit))
; [eval] _residue_166_0 < Level(t1_14)
; [eval] Level(t1_14)
(push) ; 93
(assert (Level%precondition $Snap.unit tmp_3@663@01))
(pop) ; 93
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_3@663@01))
(assert (< _residue_166_0@486@01 (Level $Snap.unit tmp_3@663@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; exhale acc(_thread_start_0(t2_14), write)
; [exec]
; assert (p1_7 ==>
;   false || getMethod(_checkDefined(t2, 12916)) == printTwice_threading()) &&
;   (p2_7 ==> false || getMethod_0(t2_14) == printTwice_threading())
; [eval] p1_7 ==> false || getMethod(_checkDefined(t2, 12916)) == printTwice_threading()
(set-option :timeout 0)
(push) ; 93
(push) ; 94
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 94
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1197 | p1_7@479@01 | live]
; [else-branch: 1197 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 94
; [then-branch: 1197 | p1_7@479@01]
; [eval] false || getMethod(_checkDefined(t2, 12916)) == printTwice_threading()
(push) ; 95
; [then-branch: 1198 | False | live]
; [else-branch: 1198 | True | live]
(push) ; 96
; [then-branch: 1198 | False]
(assert false)
(pop) ; 96
(push) ; 96
; [else-branch: 1198 | True]
; [eval] getMethod(_checkDefined(t2, 12916)) == printTwice_threading()
; [eval] getMethod(_checkDefined(t2, 12916))
; [eval] _checkDefined(t2, 12916)
(push) ; 97
; [eval] _isDefined(id)
(push) ; 98
(pop) ; 98
; Joined path conditions
(pop) ; 97
; Joined path conditions
; [eval] printTwice_threading()
(pop) ; 96
(pop) ; 95
; Joined path conditions
; Joined path conditions
(pop) ; 94
(pop) ; 93
; Joined path conditions
(push) ; 93
(assert (not (=>
  p1_7@479@01
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_4@674@01 12916))
    (as printTwice_threading<ThreadingID>  ThreadingID)))))
(check-sat)
; unsat
(pop) ; 93
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_4@674@01 12916))
    (as printTwice_threading<ThreadingID>  ThreadingID))))
; [eval] p2_7 ==> false || getMethod_0(t2_14) == printTwice_threading()
(push) ; 93
(push) ; 94
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 94
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1199 | p2_7@480@01 | live]
; [else-branch: 1199 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 94
; [then-branch: 1199 | p2_7@480@01]
; [eval] false || getMethod_0(t2_14) == printTwice_threading()
(push) ; 95
; [then-branch: 1200 | False | live]
; [else-branch: 1200 | True | live]
(push) ; 96
; [then-branch: 1200 | False]
(assert false)
(pop) ; 96
(push) ; 96
; [else-branch: 1200 | True]
; [eval] getMethod_0(t2_14) == printTwice_threading()
; [eval] getMethod_0(t2_14)
; [eval] printTwice_threading()
(pop) ; 96
(pop) ; 95
; Joined path conditions
; Joined path conditions
(pop) ; 94
(pop) ; 93
; Joined path conditions
(push) ; 93
(assert (not (=>
  p2_7@480@01
  (=
    (getMethod_0<ThreadingID> tmp_4@674@01)
    (as printTwice_threading<ThreadingID>  ThreadingID)))))
(check-sat)
; unsat
(pop) ; 93
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (=
    (getMethod_0<ThreadingID> tmp_4@674@01)
    (as printTwice_threading<ThreadingID>  ThreadingID))))
; [exec]
; p1_10 := p1_7 &&
;   getMethod(_checkDefined(t2, 12916)) == printTwice_threading()
; [eval] p1_7 && getMethod(_checkDefined(t2, 12916)) == printTwice_threading()
(push) ; 93
; [then-branch: 1201 | !(p1_7@479@01) | live]
; [else-branch: 1201 | p1_7@479@01 | live]
(push) ; 94
; [then-branch: 1201 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 94
(push) ; 94
; [else-branch: 1201 | p1_7@479@01]
; [eval] getMethod(_checkDefined(t2, 12916)) == printTwice_threading()
; [eval] getMethod(_checkDefined(t2, 12916))
; [eval] _checkDefined(t2, 12916)
(push) ; 95
; [eval] _isDefined(id)
(push) ; 96
(pop) ; 96
; Joined path conditions
(pop) ; 95
; Joined path conditions
; [eval] printTwice_threading()
(pop) ; 94
(pop) ; 93
; Joined path conditions
; Joined path conditions
(declare-const p1_10@703@01 Bool)
(assert (=
  p1_10@703@01
  (and
    p1_7@479@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_4@674@01 12916))
      (as printTwice_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_10 := p2_7 && getMethod_0(t2_14) == printTwice_threading()
; [eval] p2_7 && getMethod_0(t2_14) == printTwice_threading()
(push) ; 93
; [then-branch: 1202 | !(p2_7@480@01) | live]
; [else-branch: 1202 | p2_7@480@01 | live]
(push) ; 94
; [then-branch: 1202 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 94
(push) ; 94
; [else-branch: 1202 | p2_7@480@01]
; [eval] getMethod_0(t2_14) == printTwice_threading()
; [eval] getMethod_0(t2_14)
; [eval] printTwice_threading()
(pop) ; 94
(pop) ; 93
; Joined path conditions
; Joined path conditions
(declare-const p2_10@704@01 Bool)
(assert (=
  p2_10@704@01
  (and
    p2_7@480@01
    (=
      (getMethod_0<ThreadingID> tmp_4@674@01)
      (as printTwice_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_3 := p1_7 &&
;   !(getMethod(_checkDefined(t2, 12916)) == printTwice_threading())
; [eval] p1_7 && !(getMethod(_checkDefined(t2, 12916)) == printTwice_threading())
(push) ; 93
; [then-branch: 1203 | !(p1_7@479@01) | live]
; [else-branch: 1203 | p1_7@479@01 | live]
(push) ; 94
; [then-branch: 1203 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 94
(push) ; 94
; [else-branch: 1203 | p1_7@479@01]
; [eval] !(getMethod(_checkDefined(t2, 12916)) == printTwice_threading())
; [eval] getMethod(_checkDefined(t2, 12916)) == printTwice_threading()
; [eval] getMethod(_checkDefined(t2, 12916))
; [eval] _checkDefined(t2, 12916)
(push) ; 95
; [eval] _isDefined(id)
(push) ; 96
(pop) ; 96
; Joined path conditions
(pop) ; 95
; Joined path conditions
; [eval] printTwice_threading()
(pop) ; 94
(pop) ; 93
; Joined path conditions
; Joined path conditions
(declare-const p3_3@705@01 Bool)
(assert (=
  p3_3@705@01
  (and
    p1_7@479@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_4@674@01 12916))
        (as printTwice_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_3 := p2_7 && !(getMethod_0(t2_14) == printTwice_threading())
; [eval] p2_7 && !(getMethod_0(t2_14) == printTwice_threading())
(push) ; 93
; [then-branch: 1204 | !(p2_7@480@01) | live]
; [else-branch: 1204 | p2_7@480@01 | live]
(push) ; 94
; [then-branch: 1204 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 94
(push) ; 94
; [else-branch: 1204 | p2_7@480@01]
; [eval] !(getMethod_0(t2_14) == printTwice_threading())
; [eval] getMethod_0(t2_14) == printTwice_threading()
; [eval] getMethod_0(t2_14)
; [eval] printTwice_threading()
(pop) ; 94
(pop) ; 93
; Joined path conditions
; Joined path conditions
(declare-const p4_3@706@01 Bool)
(assert (=
  p4_3@706@01
  (and
    p2_7@480@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_4@674@01)
        (as printTwice_threading<ThreadingID>  ThreadingID))))))
(push) ; 93
(set-option :timeout 10)
(assert (not (not p1_10@703@01)))
(check-sat)
; unknown
(pop) ; 93
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 93
(set-option :timeout 10)
(assert (not p1_10@703@01))
(check-sat)
; unsat
(pop) ; 93
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1205 | p1_10@703@01 | live]
; [else-branch: 1205 | !(p1_10@703@01) | dead]
(set-option :timeout 0)
(push) ; 93
; [then-branch: 1205 | p1_10@703@01]
(assert p1_10@703@01)
; [exec]
; thread_arg_1 := getArg(_checkDefined(t2, 12916), 0)
; [eval] getArg(_checkDefined(t2, 12916), 0)
; [eval] _checkDefined(t2, 12916)
(push) ; 94
; [eval] _isDefined(id)
(push) ; 95
(pop) ; 95
; Joined path conditions
(pop) ; 94
; Joined path conditions
(declare-const thread_arg_1@707@01 $Ref)
(assert (=
  thread_arg_1@707@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_4@674@01 12916) 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_1), Lock(Cell()))
(declare-const $t@708@01 $Snap)
(assert (= $t@708@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_1), Lock(Cell()))
; [eval] typeof(thread_arg_1)
; [eval] Lock(Cell())
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_1@707@01) (Lock<PyType> (as Cell<PyType>  PyType))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; thread_arg_2 := getArg(_checkDefined(t2, 12916), 1)
; [eval] getArg(_checkDefined(t2, 12916), 1)
; [eval] _checkDefined(t2, 12916)
(set-option :timeout 0)
(push) ; 94
; [eval] _isDefined(id)
(push) ; 95
(pop) ; 95
; Joined path conditions
(pop) ; 94
; Joined path conditions
(declare-const thread_arg_2@709@01 $Ref)
(assert (=
  thread_arg_2@709@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_4@674@01 12916) 1)))
; [exec]
; inhale issubtype(typeof(thread_arg_2), int())
(declare-const $t@710@01 $Snap)
(assert (= $t@710@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_2), int())
; [eval] typeof(thread_arg_2)
; [eval] int()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_2@709@01) (as int<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@711@01 $Snap)
(assert (= $t@711@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 94
(set-option :timeout 10)
(assert (not (not p2_10@704@01)))
(check-sat)
; unknown
(pop) ; 94
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 94
(set-option :timeout 10)
(assert (not p2_10@704@01))
(check-sat)
; unsat
(pop) ; 94
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1206 | p2_10@704@01 | live]
; [else-branch: 1206 | !(p2_10@704@01) | dead]
(set-option :timeout 0)
(push) ; 94
; [then-branch: 1206 | p2_10@704@01]
(assert p2_10@704@01)
; [exec]
; thread_arg_1_0 := getArg_0(t2_14, 0)
; [eval] getArg_0(t2_14, 0)
(declare-const thread_arg_1_0@712@01 $Ref)
(assert (= thread_arg_1_0@712@01 (getArg_0<Ref> tmp_4@674@01 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_1_0), Lock(Cell()))
(declare-const $t@713@01 $Snap)
(assert (= $t@713@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_1_0), Lock(Cell()))
; [eval] typeof(thread_arg_1_0)
; [eval] Lock(Cell())
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_1_0@712@01) (Lock<PyType> (as Cell<PyType>  PyType))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; thread_arg_2_0 := getArg_0(t2_14, 1)
; [eval] getArg_0(t2_14, 1)
(declare-const thread_arg_2_0@714@01 $Ref)
(assert (= thread_arg_2_0@714@01 (getArg_0<Ref> tmp_4@674@01 1)))
; [exec]
; inhale issubtype(typeof(thread_arg_2_0), int())
(declare-const $t@715@01 $Snap)
(assert (= $t@715@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_2_0), int())
; [eval] typeof(thread_arg_2_0)
; [eval] int()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_2_0@714@01) (as int<PyType>  PyType)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@716@01 $Snap)
(assert (= $t@716@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale (p1_10 ==> true) &&
;   ((p2_10 ==> true) &&
;   (p1_10 == p2_10 &&
;   ((p1_10 && p2_10 ==> thread_arg_1 == thread_arg_1_0) &&
;   (p1_10 && p2_10 ==> thread_arg_2 == thread_arg_2_0) &&
;   ((p1_10 ==> true) && (p2_10 ==> true) &&
;   ((p1_10 ==> true) && (p2_10 ==> true))))))
; [eval] p1_10 ==> true
(set-option :timeout 0)
(push) ; 95
(push) ; 96
(set-option :timeout 10)
(assert (not (not p1_10@703@01)))
(check-sat)
; unknown
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1207 | p1_10@703@01 | live]
; [else-branch: 1207 | !(p1_10@703@01) | dead]
(set-option :timeout 0)
(push) ; 96
; [then-branch: 1207 | p1_10@703@01]
(pop) ; 96
(pop) ; 95
; Joined path conditions
; [eval] p2_10 ==> true
(push) ; 95
(push) ; 96
(set-option :timeout 10)
(assert (not (not p2_10@704@01)))
(check-sat)
; unknown
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1208 | p2_10@704@01 | live]
; [else-branch: 1208 | !(p2_10@704@01) | dead]
(set-option :timeout 0)
(push) ; 96
; [then-branch: 1208 | p2_10@704@01]
(pop) ; 96
(pop) ; 95
; Joined path conditions
; [eval] p1_10 == p2_10
(push) ; 95
(assert (not (= p1_10@703@01 p2_10@704@01)))
(check-sat)
; unsat
(pop) ; 95
; 0.00s
; (get-info :all-statistics)
(assert (= p1_10@703@01 p2_10@704@01))
; [eval] p1_10 && p2_10 ==> thread_arg_1 == thread_arg_1_0
; [eval] p1_10 && p2_10
(push) ; 95
; [then-branch: 1209 | !(p1_10@703@01) | live]
; [else-branch: 1209 | p1_10@703@01 | live]
(push) ; 96
; [then-branch: 1209 | !(p1_10@703@01)]
(assert (not p1_10@703@01))
(pop) ; 96
(push) ; 96
; [else-branch: 1209 | p1_10@703@01]
(pop) ; 96
(pop) ; 95
; Joined path conditions
; Joined path conditions
(assert (or p1_10@703@01 (not p1_10@703@01)))
(push) ; 95
(push) ; 96
(set-option :timeout 10)
(assert (not (not (and p1_10@703@01 p2_10@704@01))))
(check-sat)
; unknown
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 96
(set-option :timeout 10)
(assert (not (and p1_10@703@01 p2_10@704@01)))
(check-sat)
; unsat
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1210 | p1_10@703@01 && p2_10@704@01 | live]
; [else-branch: 1210 | !(p1_10@703@01 && p2_10@704@01) | dead]
(set-option :timeout 0)
(push) ; 96
; [then-branch: 1210 | p1_10@703@01 && p2_10@704@01]
(assert (and p1_10@703@01 p2_10@704@01))
; [eval] thread_arg_1 == thread_arg_1_0
(pop) ; 96
(pop) ; 95
; Joined path conditions
(assert (and p1_10@703@01 p2_10@704@01))
(push) ; 95
(assert (not (=>
  (and p1_10@703@01 p2_10@704@01)
  (= thread_arg_1@707@01 thread_arg_1_0@712@01))))
(check-sat)
; unsat
(pop) ; 95
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_10@703@01 p2_10@704@01)
  (= thread_arg_1@707@01 thread_arg_1_0@712@01)))
; [eval] p1_10 && p2_10 ==> thread_arg_2 == thread_arg_2_0
; [eval] p1_10 && p2_10
(push) ; 95
; [then-branch: 1211 | !(p1_10@703@01) | live]
; [else-branch: 1211 | p1_10@703@01 | live]
(push) ; 96
; [then-branch: 1211 | !(p1_10@703@01)]
(assert (not p1_10@703@01))
(pop) ; 96
(push) ; 96
; [else-branch: 1211 | p1_10@703@01]
(pop) ; 96
(pop) ; 95
; Joined path conditions
; Joined path conditions
(push) ; 95
(push) ; 96
(set-option :timeout 10)
(assert (not (not (and p1_10@703@01 p2_10@704@01))))
(check-sat)
; unknown
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 96
(set-option :timeout 10)
(assert (not (and p1_10@703@01 p2_10@704@01)))
(check-sat)
; unsat
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1212 | p1_10@703@01 && p2_10@704@01 | live]
; [else-branch: 1212 | !(p1_10@703@01 && p2_10@704@01) | dead]
(set-option :timeout 0)
(push) ; 96
; [then-branch: 1212 | p1_10@703@01 && p2_10@704@01]
(assert (and p1_10@703@01 p2_10@704@01))
; [eval] thread_arg_2 == thread_arg_2_0
(pop) ; 96
(pop) ; 95
; Joined path conditions
(assert (and p1_10@703@01 p2_10@704@01))
(push) ; 95
(assert (not (=>
  (and p1_10@703@01 p2_10@704@01)
  (= thread_arg_2@709@01 thread_arg_2_0@714@01))))
(check-sat)
; unsat
(pop) ; 95
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_10@703@01 p2_10@704@01)
  (= thread_arg_2@709@01 thread_arg_2_0@714@01)))
; [eval] p1_10 ==> true
(push) ; 95
(push) ; 96
(set-option :timeout 10)
(assert (not (not p1_10@703@01)))
(check-sat)
; unknown
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1213 | p1_10@703@01 | live]
; [else-branch: 1213 | !(p1_10@703@01) | dead]
(set-option :timeout 0)
(push) ; 96
; [then-branch: 1213 | p1_10@703@01]
(pop) ; 96
(pop) ; 95
; Joined path conditions
; [eval] p2_10 ==> true
(push) ; 95
(push) ; 96
(set-option :timeout 10)
(assert (not (not p2_10@704@01)))
(check-sat)
; unknown
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1214 | p2_10@704@01 | live]
; [else-branch: 1214 | !(p2_10@704@01) | dead]
(set-option :timeout 0)
(push) ; 96
; [then-branch: 1214 | p2_10@704@01]
(pop) ; 96
(pop) ; 95
; Joined path conditions
; [eval] p1_10 ==> true
(push) ; 95
(push) ; 96
(set-option :timeout 10)
(assert (not (not p1_10@703@01)))
(check-sat)
; unknown
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1215 | p1_10@703@01 | live]
; [else-branch: 1215 | !(p1_10@703@01) | dead]
(set-option :timeout 0)
(push) ; 96
; [then-branch: 1215 | p1_10@703@01]
(pop) ; 96
(pop) ; 95
; Joined path conditions
; [eval] p2_10 ==> true
(push) ; 95
(push) ; 96
(set-option :timeout 10)
(assert (not (not p2_10@704@01)))
(check-sat)
; unknown
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1216 | p2_10@704@01 | live]
; [else-branch: 1216 | !(p2_10@704@01) | dead]
(set-option :timeout 0)
(push) ; 96
; [then-branch: 1216 | p2_10@704@01]
(pop) ; 96
(pop) ; 95
; Joined path conditions
(push) ; 95
(set-option :timeout 10)
(assert (not (not p1_10@703@01)))
(check-sat)
; unknown
(pop) ; 95
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1217 | p1_10@703@01 | live]
; [else-branch: 1217 | !(p1_10@703@01) | dead]
(set-option :timeout 0)
(push) ; 95
; [then-branch: 1217 | p1_10@703@01]
; [exec]
; inhale true ==>
;   _joinable(_checkDefined(t2, 12916)) &&
;   acc(_thread_post(_checkDefined(t2, 12916)), write)
(push) ; 96
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 96
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1218 | True | live]
; [else-branch: 1218 | False | dead]
(set-option :timeout 0)
(push) ; 96
; [then-branch: 1218 | True]
(declare-const $t@717@01 $Snap)
(assert (= $t@717@01 ($Snap.combine ($Snap.first $t@717@01) ($Snap.second $t@717@01))))
(assert (= ($Snap.first $t@717@01) $Snap.unit))
; [eval] _joinable(_checkDefined(t2, 12916))
; [eval] _checkDefined(t2, 12916)
(push) ; 97
; [eval] _isDefined(id)
(push) ; 98
(pop) ; 98
; Joined path conditions
(pop) ; 97
; Joined path conditions
(push) ; 97
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_4@674@01 12916)))
(pop) ; 97
; Joined path conditions
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_4@674@01 12916)))
(assert (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_4@674@01 12916)))
; [eval] _checkDefined(t2, 12916)
(push) ; 97
; [eval] _isDefined(id)
(push) ; 98
(pop) ; 98
; Joined path conditions
(pop) ; 97
; Joined path conditions
(push) ; 97
(set-option :timeout 10)
(assert (not (=
  (_checkDefined $Snap.unit tmp_3@663@01 12660)
  (_checkDefined $Snap.unit tmp_4@674@01 12916))))
(check-sat)
; unknown
(pop) ; 97
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 97
(set-option :timeout 10)
(assert (not (not p2_10@704@01)))
(check-sat)
; unknown
(pop) ; 97
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1219 | p2_10@704@01 | live]
; [else-branch: 1219 | !(p2_10@704@01) | dead]
(set-option :timeout 0)
(push) ; 97
; [then-branch: 1219 | p2_10@704@01]
; [exec]
; inhale true ==> _joinable(t2_14) && acc(_thread_post_0(t2_14), write)
(push) ; 98
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 98
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1220 | True | live]
; [else-branch: 1220 | False | dead]
(set-option :timeout 0)
(push) ; 98
; [then-branch: 1220 | True]
(declare-const $t@718@01 $Snap)
(assert (= $t@718@01 ($Snap.combine ($Snap.first $t@718@01) ($Snap.second $t@718@01))))
(assert (= ($Snap.first $t@718@01) $Snap.unit))
; [eval] _joinable(t2_14)
(push) ; 99
(assert (_joinable%precondition $Snap.unit tmp_4@674@01))
(pop) ; 99
; Joined path conditions
(assert (_joinable%precondition $Snap.unit tmp_4@674@01))
(assert (_joinable $Snap.unit tmp_4@674@01))
(push) ; 99
(set-option :timeout 10)
(assert (not (= tmp_3@663@01 tmp_4@674@01)))
(check-sat)
; unknown
(pop) ; 99
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 99
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 99
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1221 | p1_7@479@01 | live]
; [else-branch: 1221 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 99
; [then-branch: 1221 | p1_7@479@01]
; [exec]
; inhale (forperm
;     _r_21: Ref [_r_21.MustReleaseBounded] :: Level(_r_21) <
;     Level(_checkDefined(t2, 12916))) &&
;   ((forperm
;     _r_21: Ref [_r_21.MustReleaseUnbounded] :: Level(_r_21) <
;     Level(_checkDefined(t2, 12916))) &&
;   _residue_166 < Level(_checkDefined(t2, 12916)))
(declare-const $t@719@01 $Snap)
(assert (= $t@719@01 ($Snap.combine ($Snap.first $t@719@01) ($Snap.second $t@719@01))))
(assert (= ($Snap.first $t@719@01) $Snap.unit))
; [eval] (forperm _r_21: Ref [_r_21.MustReleaseBounded] :: Level(_r_21) < Level(_checkDefined(t2, 12916)))
(assert (=
  ($Snap.second $t@719@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@719@01))
    ($Snap.second ($Snap.second $t@719@01)))))
(assert (= ($Snap.first ($Snap.second $t@719@01)) $Snap.unit))
; [eval] (forperm _r_21: Ref [_r_21.MustReleaseUnbounded] :: Level(_r_21) < Level(_checkDefined(t2, 12916)))
(assert (= ($Snap.second ($Snap.second $t@719@01)) $Snap.unit))
; [eval] _residue_166 < Level(_checkDefined(t2, 12916))
; [eval] Level(_checkDefined(t2, 12916))
; [eval] _checkDefined(t2, 12916)
(push) ; 100
; [eval] _isDefined(id)
(push) ; 101
(pop) ; 101
; Joined path conditions
(pop) ; 100
; Joined path conditions
(push) ; 100
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_4@674@01 12916)))
(pop) ; 100
; Joined path conditions
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_4@674@01 12916)))
(assert (<
  _residue_166@485@01
  (Level $Snap.unit (_checkDefined $Snap.unit tmp_4@674@01 12916))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 100
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 100
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1222 | p2_7@480@01 | live]
; [else-branch: 1222 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 100
; [then-branch: 1222 | p2_7@480@01]
; [exec]
; inhale (forperm
;     _r_21: Ref [_r_21.MustReleaseBoundedp] :: Level(_r_21) < Level(t2_14)) &&
;   ((forperm
;     _r_21: Ref [_r_21.MustReleaseUnboundedp] :: Level(_r_21) < Level(t2_14)) &&
;   _residue_166_0 < Level(t2_14))
(declare-const $t@720@01 $Snap)
(assert (= $t@720@01 ($Snap.combine ($Snap.first $t@720@01) ($Snap.second $t@720@01))))
(assert (= ($Snap.first $t@720@01) $Snap.unit))
; [eval] (forperm _r_21: Ref [_r_21.MustReleaseBoundedp] :: Level(_r_21) < Level(t2_14))
(assert (=
  ($Snap.second $t@720@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@720@01))
    ($Snap.second ($Snap.second $t@720@01)))))
(assert (= ($Snap.first ($Snap.second $t@720@01)) $Snap.unit))
; [eval] (forperm _r_21: Ref [_r_21.MustReleaseUnboundedp] :: Level(_r_21) < Level(t2_14))
(assert (= ($Snap.second ($Snap.second $t@720@01)) $Snap.unit))
; [eval] _residue_166_0 < Level(t2_14)
; [eval] Level(t2_14)
(push) ; 101
(assert (Level%precondition $Snap.unit tmp_4@674@01))
(pop) ; 101
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_4@674@01))
(assert (< _residue_166_0@486@01 (Level $Snap.unit tmp_4@674@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert true
; [eval] p1_7 ==> true
(set-option :timeout 0)
(push) ; 101
(push) ; 102
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 102
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1223 | p1_7@479@01 | live]
; [else-branch: 1223 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 102
; [then-branch: 1223 | p1_7@479@01]
(pop) ; 102
(pop) ; 101
; Joined path conditions
; [eval] p2_7 ==> true
(push) ; 101
(push) ; 102
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 102
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1224 | p2_7@480@01 | live]
; [else-branch: 1224 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 102
; [then-branch: 1224 | p2_7@480@01]
(pop) ; 102
(pop) ; 101
; Joined path conditions
; [eval] p1_7 ==> (forperm _r_23: Ref [MustInvokeBounded(_r_23)] :: false) && ((forperm _r_23: Ref [MustInvokeUnbounded(_r_23)] :: false) && ((forperm _r_23: Ref [_r_23.MustReleaseBounded] :: false) && (forperm _r_23: Ref [_r_23.MustReleaseUnbounded] :: false)))
(push) ; 101
(push) ; 102
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 102
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1225 | p1_7@479@01 | live]
; [else-branch: 1225 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 102
; [then-branch: 1225 | p1_7@479@01]
; [eval] (forperm _r_23: Ref [MustInvokeBounded(_r_23)] :: false) && ((forperm _r_23: Ref [MustInvokeUnbounded(_r_23)] :: false) && ((forperm _r_23: Ref [_r_23.MustReleaseBounded] :: false) && (forperm _r_23: Ref [_r_23.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_23: Ref [MustInvokeBounded(_r_23)] :: false)
(push) ; 103
; [then-branch: 1226 | False | live]
; [else-branch: 1226 | True | live]
(push) ; 104
; [then-branch: 1226 | False]
(assert false)
(pop) ; 104
(push) ; 104
; [else-branch: 1226 | True]
; [eval] (forperm _r_23: Ref [MustInvokeUnbounded(_r_23)] :: false)
(push) ; 105
; [then-branch: 1227 | False | live]
; [else-branch: 1227 | True | live]
(push) ; 106
; [then-branch: 1227 | False]
(assert false)
(pop) ; 106
(push) ; 106
; [else-branch: 1227 | True]
; [eval] (forperm _r_23: Ref [_r_23.MustReleaseBounded] :: false)
(push) ; 107
; [then-branch: 1228 | False | live]
; [else-branch: 1228 | True | live]
(push) ; 108
; [then-branch: 1228 | False]
(assert false)
(pop) ; 108
(push) ; 108
; [else-branch: 1228 | True]
; [eval] (forperm _r_23: Ref [_r_23.MustReleaseUnbounded] :: false)
(pop) ; 108
(pop) ; 107
; Joined path conditions
; Joined path conditions
(pop) ; 106
(pop) ; 105
; Joined path conditions
; Joined path conditions
(pop) ; 104
(pop) ; 103
; Joined path conditions
; Joined path conditions
(pop) ; 102
(pop) ; 101
; Joined path conditions
; [eval] p2_7 ==> (forperm _r_23: Ref [MustInvokeBounded_0(_r_23)] :: false) && ((forperm _r_23: Ref [MustInvokeUnbounded_0(_r_23)] :: false) && ((forperm _r_23: Ref [_r_23.MustReleaseBoundedp] :: false) && (forperm _r_23: Ref [_r_23.MustReleaseUnboundedp] :: false)))
(push) ; 101
(push) ; 102
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 102
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1229 | p2_7@480@01 | live]
; [else-branch: 1229 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 102
; [then-branch: 1229 | p2_7@480@01]
; [eval] (forperm _r_23: Ref [MustInvokeBounded_0(_r_23)] :: false) && ((forperm _r_23: Ref [MustInvokeUnbounded_0(_r_23)] :: false) && ((forperm _r_23: Ref [_r_23.MustReleaseBoundedp] :: false) && (forperm _r_23: Ref [_r_23.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_23: Ref [MustInvokeBounded_0(_r_23)] :: false)
(push) ; 103
; [then-branch: 1230 | False | live]
; [else-branch: 1230 | True | live]
(push) ; 104
; [then-branch: 1230 | False]
(assert false)
(pop) ; 104
(push) ; 104
; [else-branch: 1230 | True]
; [eval] (forperm _r_23: Ref [MustInvokeUnbounded_0(_r_23)] :: false)
(push) ; 105
; [then-branch: 1231 | False | live]
; [else-branch: 1231 | True | live]
(push) ; 106
; [then-branch: 1231 | False]
(assert false)
(pop) ; 106
(push) ; 106
; [else-branch: 1231 | True]
; [eval] (forperm _r_23: Ref [_r_23.MustReleaseBoundedp] :: false)
(push) ; 107
; [then-branch: 1232 | False | live]
; [else-branch: 1232 | True | live]
(push) ; 108
; [then-branch: 1232 | False]
(assert false)
(pop) ; 108
(push) ; 108
; [else-branch: 1232 | True]
; [eval] (forperm _r_23: Ref [_r_23.MustReleaseUnboundedp] :: false)
(pop) ; 108
(pop) ; 107
; Joined path conditions
; Joined path conditions
(pop) ; 106
(pop) ; 105
; Joined path conditions
; Joined path conditions
(pop) ; 104
(pop) ; 103
; Joined path conditions
; Joined path conditions
(pop) ; 102
(pop) ; 101
; Joined path conditions
(pop) ; 100
; [eval] !p2_7
; [then-branch: 1233 | !(p2_7@480@01) | dead]
; [else-branch: 1233 | p2_7@480@01 | live]
(push) ; 100
; [else-branch: 1233 | p2_7@480@01]
(pop) ; 100
(pop) ; 99
; [eval] !p1_7
; [then-branch: 1234 | !(p1_7@479@01) | dead]
; [else-branch: 1234 | p1_7@479@01 | live]
(push) ; 99
; [else-branch: 1234 | p1_7@479@01]
(pop) ; 99
(pop) ; 98
(pop) ; 97
; [eval] !p2_10
; [then-branch: 1235 | !(p2_10@704@01) | dead]
; [else-branch: 1235 | p2_10@704@01 | live]
(push) ; 97
; [else-branch: 1235 | p2_10@704@01]
(pop) ; 97
(pop) ; 96
(pop) ; 95
; [eval] !p1_10
; [then-branch: 1236 | !(p1_10@703@01) | dead]
; [else-branch: 1236 | p1_10@703@01 | live]
(push) ; 95
; [else-branch: 1236 | p1_10@703@01]
(pop) ; 95
(pop) ; 94
; [eval] !p2_10
(push) ; 94
(set-option :timeout 10)
(assert (not p2_10@704@01))
(check-sat)
; unsat
(pop) ; 94
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1237 | !(p2_10@704@01) | dead]
; [else-branch: 1237 | p2_10@704@01 | live]
(set-option :timeout 0)
(push) ; 94
; [else-branch: 1237 | p2_10@704@01]
(assert p2_10@704@01)
(pop) ; 94
(pop) ; 93
; [eval] !p1_10
(push) ; 93
(set-option :timeout 10)
(assert (not p1_10@703@01))
(check-sat)
; unsat
(pop) ; 93
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1238 | !(p1_10@703@01) | dead]
; [else-branch: 1238 | p1_10@703@01 | live]
(set-option :timeout 0)
(push) ; 93
; [else-branch: 1238 | p1_10@703@01]
(assert p1_10@703@01)
(pop) ; 93
(pop) ; 92
; [eval] !p2_7
; [then-branch: 1239 | !(p2_7@480@01) | dead]
; [else-branch: 1239 | p2_7@480@01 | live]
(push) ; 92
; [else-branch: 1239 | p2_7@480@01]
(pop) ; 92
(pop) ; 91
; [eval] !p1_7
; [then-branch: 1240 | !(p1_7@479@01) | dead]
; [else-branch: 1240 | p1_7@479@01 | live]
(push) ; 91
; [else-branch: 1240 | p1_7@479@01]
(pop) ; 91
(pop) ; 90
(pop) ; 89
; [eval] !p2_9
; [then-branch: 1241 | !(p2_9@686@01) | dead]
; [else-branch: 1241 | p2_9@686@01 | live]
(push) ; 89
; [else-branch: 1241 | p2_9@686@01]
(pop) ; 89
(pop) ; 88
(pop) ; 87
; [eval] !p1_9
; [then-branch: 1242 | !(p1_9@685@01) | dead]
; [else-branch: 1242 | p1_9@685@01 | live]
(push) ; 87
; [else-branch: 1242 | p1_9@685@01]
(pop) ; 87
(pop) ; 86
; [eval] !p2_9
(push) ; 86
(set-option :timeout 10)
(assert (not p2_9@686@01))
(check-sat)
; unsat
(pop) ; 86
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1243 | !(p2_9@686@01) | dead]
; [else-branch: 1243 | p2_9@686@01 | live]
(set-option :timeout 0)
(push) ; 86
; [else-branch: 1243 | p2_9@686@01]
(assert p2_9@686@01)
(pop) ; 86
(pop) ; 85
; [eval] !p1_9
(push) ; 85
(set-option :timeout 10)
(assert (not p1_9@685@01))
(check-sat)
; unsat
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1244 | !(p1_9@685@01) | dead]
; [else-branch: 1244 | p1_9@685@01 | live]
(set-option :timeout 0)
(push) ; 85
; [else-branch: 1244 | p1_9@685@01]
(assert p1_9@685@01)
(pop) ; 85
(pop) ; 84
; [eval] !p2_7
; [then-branch: 1245 | !(p2_7@480@01) | dead]
; [else-branch: 1245 | p2_7@480@01 | live]
(push) ; 84
; [else-branch: 1245 | p2_7@480@01]
(pop) ; 84
(pop) ; 83
; [eval] !p1_7
; [then-branch: 1246 | !(p1_7@479@01) | dead]
; [else-branch: 1246 | p1_7@479@01 | live]
(push) ; 83
; [else-branch: 1246 | p1_7@479@01]
(pop) ; 83
(pop) ; 82
; [eval] !p2_7
; [then-branch: 1247 | !(p2_7@480@01) | dead]
; [else-branch: 1247 | p2_7@480@01 | live]
(push) ; 82
; [else-branch: 1247 | p2_7@480@01]
(pop) ; 82
(pop) ; 81
; [eval] !p1_7
; [then-branch: 1248 | !(p1_7@479@01) | dead]
; [else-branch: 1248 | p1_7@479@01 | live]
(push) ; 81
; [else-branch: 1248 | p1_7@479@01]
(pop) ; 81
(pop) ; 80
; [eval] !p2_7
; [then-branch: 1249 | !(p2_7@480@01) | dead]
; [else-branch: 1249 | p2_7@480@01 | live]
(push) ; 80
; [else-branch: 1249 | p2_7@480@01]
(pop) ; 80
(pop) ; 79
; [eval] !p1_7
; [then-branch: 1250 | !(p1_7@479@01) | dead]
; [else-branch: 1250 | p1_7@479@01 | live]
(push) ; 79
; [else-branch: 1250 | p1_7@479@01]
(pop) ; 79
(pop) ; 78
; [eval] !p2_7
; [then-branch: 1251 | !(p2_7@480@01) | dead]
; [else-branch: 1251 | p2_7@480@01 | live]
(push) ; 78
; [else-branch: 1251 | p2_7@480@01]
(pop) ; 78
(pop) ; 77
; [eval] !p1_7
; [then-branch: 1252 | !(p1_7@479@01) | dead]
; [else-branch: 1252 | p1_7@479@01 | live]
(push) ; 77
; [else-branch: 1252 | p1_7@479@01]
(pop) ; 77
(pop) ; 76
; [eval] !p2_7
; [then-branch: 1253 | !(p2_7@480@01) | dead]
; [else-branch: 1253 | p2_7@480@01 | live]
(push) ; 76
; [else-branch: 1253 | p2_7@480@01]
(pop) ; 76
(pop) ; 75
; [eval] !p1_7
; [then-branch: 1254 | !(p1_7@479@01) | dead]
; [else-branch: 1254 | p1_7@479@01 | live]
(push) ; 75
; [else-branch: 1254 | p1_7@479@01]
(pop) ; 75
(pop) ; 74
; [eval] !p2_7
; [then-branch: 1255 | !(p2_7@480@01) | dead]
; [else-branch: 1255 | p2_7@480@01 | live]
(push) ; 74
; [else-branch: 1255 | p2_7@480@01]
(pop) ; 74
(pop) ; 73
; [eval] !p1_7
; [then-branch: 1256 | !(p1_7@479@01) | dead]
; [else-branch: 1256 | p1_7@479@01 | live]
(push) ; 73
; [else-branch: 1256 | p1_7@479@01]
(pop) ; 73
(pop) ; 72
(pop) ; 71
(pop) ; 70
(push) ; 70
; [else-branch: 1150 | !(p2_8@657@01)]
(assert (not p2_8@657@01))
(pop) ; 70
; [eval] !p2_8
(push) ; 70
(set-option :timeout 10)
(assert (not p2_8@657@01))
(check-sat)
; unknown
(pop) ; 70
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 70
(set-option :timeout 10)
(assert (not (not p2_8@657@01)))
(check-sat)
; unknown
(pop) ; 70
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1257 | !(p2_8@657@01) | live]
; [else-branch: 1257 | p2_8@657@01 | live]
(set-option :timeout 0)
(push) ; 70
; [then-branch: 1257 | !(p2_8@657@01)]
(assert (not p2_8@657@01))
(push) ; 71
(set-option :timeout 10)
(assert (not (not p3_1@658@01)))
(check-sat)
; unsat
(pop) ; 71
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1258 | p3_1@658@01 | dead]
; [else-branch: 1258 | !(p3_1@658@01) | live]
(set-option :timeout 0)
(push) ; 71
; [else-branch: 1258 | !(p3_1@658@01)]
(assert (not p3_1@658@01))
(pop) ; 71
; [eval] !p3_1
(push) ; 71
(set-option :timeout 10)
(assert (not p3_1@658@01))
(check-sat)
; unknown
(pop) ; 71
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 71
(set-option :timeout 10)
(assert (not (not p3_1@658@01)))
(check-sat)
; unsat
(pop) ; 71
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1259 | !(p3_1@658@01) | live]
; [else-branch: 1259 | p3_1@658@01 | dead]
(set-option :timeout 0)
(push) ; 71
; [then-branch: 1259 | !(p3_1@658@01)]
(assert (not p3_1@658@01))
(push) ; 72
(set-option :timeout 10)
(assert (not (not p4_1@659@01)))
(check-sat)
; unknown
(pop) ; 72
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 72
(set-option :timeout 10)
(assert (not p4_1@659@01))
(check-sat)
; unsat
(pop) ; 72
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1260 | p4_1@659@01 | live]
; [else-branch: 1260 | !(p4_1@659@01) | dead]
(set-option :timeout 0)
(push) ; 72
; [then-branch: 1260 | p4_1@659@01]
(assert p4_1@659@01)
; [exec]
; x_2_0 := l2_0
; [exec]
; inhale true
(declare-const $t@721@01 $Snap)
(assert (= $t@721@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; tmp_3 := new()
(declare-const tmp_3@722@01 $Ref)
(assert (not (= tmp_3@722@01 $Ref.null)))
(assert (not (= tmp_3@722@01 secret_7@488@01)))
(assert (not (= tmp_3@722@01 t2_14@508@01)))
(assert (not (= tmp_3@722@01 thread_arg_2@529@01)))
(assert (not (= tmp_3@722@01 threadingVar_6@520@01)))
(assert (not (= tmp_3@722@01 tmp1_38@597@01)))
(assert (not (= tmp_3@722@01 threadingVar_0@521@01)))
(assert (not (= tmp_3@722@01 secret@487@01)))
(assert (not (= tmp_3@722@01 tmp_3@543@01)))
(assert (not (= tmp_3@722@01 tmp_0@574@01)))
(assert (not (= tmp_3@722@01 thread_arg_9@524@01)))
(assert (not (= tmp_3@722@01 thread_arg_0_0@526@01)))
(assert (not (= tmp_3@722@01 tmp@554@01)))
(assert (not (= tmp_3@722@01 thread_arg_2_0@530@01)))
(assert (not (= tmp_3@722@01 _cthread_166_0@482@01)))
(assert (not (= tmp_3@722@01 tmp_1@605@01)))
(assert (not (= tmp_3@722@01 x_2@660@01)))
(assert (not (= tmp_3@722@01 thread_arg_1_0@528@01)))
(assert (not (= tmp_3@722@01 tmp1_51@648@01)))
(assert (not (= tmp_3@722@01 threadingVar@519@01)))
(assert (not (= tmp_3@722@01 threadingVar_0_0@522@01)))
(assert (not (= tmp_3@722@01 t2@507@01)))
(assert (not (= tmp_3@722@01 tmp_2@625@01)))
(assert (not (= tmp_3@722@01 _cthread_166@481@01)))
(assert (not (= tmp_3@722@01 tmp_4@544@01)))
(assert (not (= tmp_3@722@01 thread_arg@523@01)))
(assert (not (= tmp_3@722@01 thread_arg_1@527@01)))
(assert (not (= tmp_3@722@01 thread_arg_0@525@01)))
(assert (not (= tmp_3@722@01 t1_14@506@01)))
(assert (not (= tmp_3@722@01 t1@505@01)))
(set-option :timeout 0)
(push) ; 73
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 73
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1261 | p1_7@479@01 | live]
; [else-branch: 1261 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 73
; [then-branch: 1261 | p1_7@479@01]
; [exec]
; threadingVar := tmp_3
(push) ; 74
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 74
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1262 | p2_7@480@01 | live]
; [else-branch: 1262 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 74
; [then-branch: 1262 | p2_7@480@01]
; [exec]
; threadingVar_6 := tmp_3
(push) ; 75
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 75
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1263 | p1_7@479@01 | live]
; [else-branch: 1263 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 75
; [then-branch: 1263 | p1_7@479@01]
; [exec]
; inhale issubtype(typeof(threadingVar), Thread_0())
(declare-const $t@723@01 $Snap)
(assert (= $t@723@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar), Thread_0())
; [eval] typeof(threadingVar)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_3@722@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod(threadingVar) == printTwice_threading()
(declare-const $t@724@01 $Snap)
(assert (= $t@724@01 $Snap.unit))
; [eval] getMethod(threadingVar) == printTwice_threading()
; [eval] getMethod(threadingVar)
; [eval] printTwice_threading()
(assert (=
  (getMethod<ThreadingID> tmp_3@722@01)
  (as printTwice_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 76
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 76
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1264 | p2_7@480@01 | live]
; [else-branch: 1264 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 76
; [then-branch: 1264 | p2_7@480@01]
; [exec]
; inhale issubtype(typeof(threadingVar_6), Thread_0())
(declare-const $t@725@01 $Snap)
(assert (= $t@725@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_6), Thread_0())
; [eval] typeof(threadingVar_6)
; [eval] Thread_0()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod_0(threadingVar_6) == printTwice_threading()
(declare-const $t@726@01 $Snap)
(assert (= $t@726@01 $Snap.unit))
; [eval] getMethod_0(threadingVar_6) == printTwice_threading()
; [eval] getMethod_0(threadingVar_6)
; [eval] printTwice_threading()
(assert (=
  (getMethod_0<ThreadingID> tmp_3@722@01)
  (as printTwice_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; assert (p1_7 ==>
;   (true == issubtype(typeof(_checkDefined(x_2, 3301240)), Lock(Cell()))) ==
;   issubtype(typeof(__prim__int___box__(1)), int())) &&
;   (p2_7 ==>
;   (true == issubtype(typeof(x_2_0), Lock(Cell()))) ==
;   issubtype(typeof(__prim__int___box__(1)), int()))
; [eval] p1_7 ==> (true == issubtype(typeof(_checkDefined(x_2, 3301240)), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(1)), int())
(set-option :timeout 0)
(push) ; 77
(push) ; 78
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 78
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1265 | p1_7@479@01 | live]
; [else-branch: 1265 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 78
; [then-branch: 1265 | p1_7@479@01]
; [eval] (true == issubtype(typeof(_checkDefined(x_2, 3301240)), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(1)), int())
; [eval] true == issubtype(typeof(_checkDefined(x_2, 3301240)), Lock(Cell()))
; [eval] issubtype(typeof(_checkDefined(x_2, 3301240)), Lock(Cell()))
; [eval] typeof(_checkDefined(x_2, 3301240))
; [eval] _checkDefined(x_2, 3301240)
(push) ; 79
; [eval] _isDefined(id)
(push) ; 80
(pop) ; 80
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit x_2@660@01 3301240))
(pop) ; 79
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit x_2@660@01 3301240))
; [eval] Lock(Cell())
; [eval] Cell()
; [eval] issubtype(typeof(__prim__int___box__(1)), int())
; [eval] typeof(__prim__int___box__(1))
; [eval] __prim__int___box__(1)
(push) ; 79
(assert (__prim__int___box__%precondition $Snap.unit 1))
(pop) ; 79
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 1))
; [eval] int()
(pop) ; 78
(pop) ; 77
; Joined path conditions
(assert (=>
  p1_7@479@01
  (and
    (_checkDefined%precondition $Snap.unit x_2@660@01 3301240)
    (__prim__int___box__%precondition $Snap.unit 1))))
(push) ; 77
(assert (not (=>
  p1_7@479@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit x_2@660@01 3301240)) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 1)) (as int<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 77
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit x_2@660@01 3301240)) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 1)) (as int<PyType>  PyType)))))
; [eval] p2_7 ==> (true == issubtype(typeof(x_2_0), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(1)), int())
(push) ; 77
(push) ; 78
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 78
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1266 | p2_7@480@01 | live]
; [else-branch: 1266 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 78
; [then-branch: 1266 | p2_7@480@01]
; [eval] (true == issubtype(typeof(x_2_0), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(1)), int())
; [eval] true == issubtype(typeof(x_2_0), Lock(Cell()))
; [eval] issubtype(typeof(x_2_0), Lock(Cell()))
; [eval] typeof(x_2_0)
; [eval] Lock(Cell())
; [eval] Cell()
; [eval] issubtype(typeof(__prim__int___box__(1)), int())
; [eval] typeof(__prim__int___box__(1))
; [eval] __prim__int___box__(1)
(push) ; 79
(assert (__prim__int___box__%precondition $Snap.unit 1))
(pop) ; 79
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 1))
; [eval] int()
(pop) ; 78
(pop) ; 77
; Joined path conditions
(assert (=> p2_7@480@01 (__prim__int___box__%precondition $Snap.unit 1)))
(push) ; 77
(assert (not (=>
  p2_7@480@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 1)) (as int<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 77
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 1)) (as int<PyType>  PyType)))))
(push) ; 77
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 77
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1267 | p1_7@479@01 | live]
; [else-branch: 1267 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 77
; [then-branch: 1267 | p1_7@479@01]
; [exec]
; inhale true &&
;   (getArg(threadingVar, 0) == _checkDefined(x_2, 3301240) &&
;   getArg(threadingVar, 1) == __prim__int___box__(1))
(declare-const $t@727@01 $Snap)
(assert (= $t@727@01 ($Snap.combine ($Snap.first $t@727@01) ($Snap.second $t@727@01))))
(assert (= ($Snap.first $t@727@01) $Snap.unit))
(assert (=
  ($Snap.second $t@727@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@727@01))
    ($Snap.second ($Snap.second $t@727@01)))))
(assert (= ($Snap.first ($Snap.second $t@727@01)) $Snap.unit))
; [eval] getArg(threadingVar, 0) == _checkDefined(x_2, 3301240)
; [eval] getArg(threadingVar, 0)
; [eval] _checkDefined(x_2, 3301240)
(push) ; 78
; [eval] _isDefined(id)
(push) ; 79
(pop) ; 79
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit x_2@660@01 3301240))
(pop) ; 78
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit x_2@660@01 3301240))
(assert (= (getArg<Ref> tmp_3@722@01 0) (_checkDefined $Snap.unit x_2@660@01 3301240)))
(assert (= ($Snap.second ($Snap.second $t@727@01)) $Snap.unit))
; [eval] getArg(threadingVar, 1) == __prim__int___box__(1)
; [eval] getArg(threadingVar, 1)
; [eval] __prim__int___box__(1)
(push) ; 78
(assert (__prim__int___box__%precondition $Snap.unit 1))
(pop) ; 78
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 1))
(assert (= (getArg<Ref> tmp_3@722@01 1) (__prim__int___box__ $Snap.unit 1)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start(threadingVar), write)
(declare-const $t@728@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t1 := threadingVar
; [exec]
; inhale _isDefined(12660)
(declare-const $t@729@01 $Snap)
(assert (= $t@729@01 $Snap.unit))
; [eval] _isDefined(12660)
(set-option :timeout 0)
(push) ; 78
(assert (_isDefined%precondition $Snap.unit 12660))
(pop) ; 78
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 12660))
(assert (_isDefined $Snap.unit 12660))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 78
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 78
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1268 | p2_7@480@01 | live]
; [else-branch: 1268 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 78
; [then-branch: 1268 | p2_7@480@01]
; [exec]
; inhale true &&
;   (getArg_0(threadingVar_6, 0) == x_2_0 &&
;   getArg_0(threadingVar_6, 1) == __prim__int___box__(1))
(declare-const $t@730@01 $Snap)
(assert (= $t@730@01 ($Snap.combine ($Snap.first $t@730@01) ($Snap.second $t@730@01))))
(assert (= ($Snap.first $t@730@01) $Snap.unit))
(assert (=
  ($Snap.second $t@730@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@730@01))
    ($Snap.second ($Snap.second $t@730@01)))))
(assert (= ($Snap.first ($Snap.second $t@730@01)) $Snap.unit))
; [eval] getArg_0(threadingVar_6, 0) == x_2_0
; [eval] getArg_0(threadingVar_6, 0)
(assert (= (getArg_0<Ref> tmp_3@722@01 0) tmp_2@625@01))
(assert (= ($Snap.second ($Snap.second $t@730@01)) $Snap.unit))
; [eval] getArg_0(threadingVar_6, 1) == __prim__int___box__(1)
; [eval] getArg_0(threadingVar_6, 1)
; [eval] __prim__int___box__(1)
(push) ; 79
(pop) ; 79
; Joined path conditions
(assert (= (getArg_0<Ref> tmp_3@722@01 1) (__prim__int___box__ $Snap.unit 1)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start_0(threadingVar_6), write)
(declare-const $t@731@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t1_14 := threadingVar_6
; [exec]
; inhale true
(declare-const $t@732@01 $Snap)
(assert (= $t@732@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; tmp_4 := new()
(declare-const tmp_4@733@01 $Ref)
(assert (not (= tmp_4@733@01 $Ref.null)))
(assert (not (= tmp_4@733@01 secret_7@488@01)))
(assert (not (= tmp_4@733@01 t2_14@508@01)))
(assert (not (= tmp_4@733@01 thread_arg_2@529@01)))
(assert (not (= tmp_4@733@01 tmp1_38@597@01)))
(assert (not (= tmp_4@733@01 threadingVar_0@521@01)))
(assert (not (= tmp_4@733@01 secret@487@01)))
(assert (not (= tmp_4@733@01 tmp_0@574@01)))
(assert (not (= tmp_4@733@01 thread_arg_9@524@01)))
(assert (not (= tmp_4@733@01 tmp_3@722@01)))
(assert (not (= tmp_4@733@01 thread_arg_0_0@526@01)))
(assert (not (= tmp_4@733@01 tmp@554@01)))
(assert (not (= tmp_4@733@01 thread_arg_2_0@530@01)))
(assert (not (= tmp_4@733@01 _cthread_166_0@482@01)))
(assert (not (= tmp_4@733@01 tmp_1@605@01)))
(assert (not (= tmp_4@733@01 x_2@660@01)))
(assert (not (= tmp_4@733@01 thread_arg_1_0@528@01)))
(assert (not (= tmp_4@733@01 tmp1_51@648@01)))
(assert (not (= tmp_4@733@01 threadingVar_0_0@522@01)))
(assert (not (= tmp_4@733@01 t2@507@01)))
(assert (not (= tmp_4@733@01 tmp_2@625@01)))
(assert (not (= tmp_4@733@01 _cthread_166@481@01)))
(assert (not (= tmp_4@733@01 tmp_4@544@01)))
(assert (not (= tmp_4@733@01 thread_arg@523@01)))
(assert (not (= tmp_4@733@01 thread_arg_1@527@01)))
(assert (not (= tmp_4@733@01 thread_arg_0@525@01)))
(set-option :timeout 0)
(push) ; 79
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 79
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1269 | p1_7@479@01 | live]
; [else-branch: 1269 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 79
; [then-branch: 1269 | p1_7@479@01]
; [exec]
; threadingVar_0 := tmp_4
(push) ; 80
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 80
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1270 | p2_7@480@01 | live]
; [else-branch: 1270 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 80
; [then-branch: 1270 | p2_7@480@01]
; [exec]
; threadingVar_0_0 := tmp_4
(push) ; 81
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 81
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1271 | p1_7@479@01 | live]
; [else-branch: 1271 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 81
; [then-branch: 1271 | p1_7@479@01]
; [exec]
; inhale issubtype(typeof(threadingVar_0), Thread_0())
(declare-const $t@734@01 $Snap)
(assert (= $t@734@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_0), Thread_0())
; [eval] typeof(threadingVar_0)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_4@733@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod(threadingVar_0) == printTwice_threading()
(declare-const $t@735@01 $Snap)
(assert (= $t@735@01 $Snap.unit))
; [eval] getMethod(threadingVar_0) == printTwice_threading()
; [eval] getMethod(threadingVar_0)
; [eval] printTwice_threading()
(assert (=
  (getMethod<ThreadingID> tmp_4@733@01)
  (as printTwice_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 82
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 82
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1272 | p2_7@480@01 | live]
; [else-branch: 1272 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 82
; [then-branch: 1272 | p2_7@480@01]
; [exec]
; inhale issubtype(typeof(threadingVar_0_0), Thread_0())
(declare-const $t@736@01 $Snap)
(assert (= $t@736@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_0_0), Thread_0())
; [eval] typeof(threadingVar_0_0)
; [eval] Thread_0()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod_0(threadingVar_0_0) == printTwice_threading()
(declare-const $t@737@01 $Snap)
(assert (= $t@737@01 $Snap.unit))
; [eval] getMethod_0(threadingVar_0_0) == printTwice_threading()
; [eval] getMethod_0(threadingVar_0_0)
; [eval] printTwice_threading()
(assert (=
  (getMethod_0<ThreadingID> tmp_4@733@01)
  (as printTwice_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; assert (p1_7 ==>
;   (true == issubtype(typeof(_checkDefined(l2, 12908)), Lock(Cell()))) ==
;   issubtype(typeof(__prim__int___box__(2)), int())) &&
;   (p2_7 ==>
;   (true == issubtype(typeof(l2_0), Lock(Cell()))) ==
;   issubtype(typeof(__prim__int___box__(2)), int()))
; [eval] p1_7 ==> (true == issubtype(typeof(_checkDefined(l2, 12908)), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(2)), int())
(set-option :timeout 0)
(push) ; 83
(push) ; 84
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1273 | p1_7@479@01 | live]
; [else-branch: 1273 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 84
; [then-branch: 1273 | p1_7@479@01]
; [eval] (true == issubtype(typeof(_checkDefined(l2, 12908)), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(2)), int())
; [eval] true == issubtype(typeof(_checkDefined(l2, 12908)), Lock(Cell()))
; [eval] issubtype(typeof(_checkDefined(l2, 12908)), Lock(Cell()))
; [eval] typeof(_checkDefined(l2, 12908))
; [eval] _checkDefined(l2, 12908)
(push) ; 85
; [eval] _isDefined(id)
(push) ; 86
(pop) ; 86
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_2@625@01 12908))
(pop) ; 85
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_2@625@01 12908))
; [eval] Lock(Cell())
; [eval] Cell()
; [eval] issubtype(typeof(__prim__int___box__(2)), int())
; [eval] typeof(__prim__int___box__(2))
; [eval] __prim__int___box__(2)
(push) ; 85
(assert (__prim__int___box__%precondition $Snap.unit 2))
(pop) ; 85
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 2))
; [eval] int()
(pop) ; 84
(pop) ; 83
; Joined path conditions
(assert (=>
  p1_7@479@01
  (and
    (_checkDefined%precondition $Snap.unit tmp_2@625@01 12908)
    (__prim__int___box__%precondition $Snap.unit 2))))
(push) ; 83
(assert (not (=>
  p1_7@479@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit tmp_2@625@01 12908)) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 2)) (as int<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 83
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit tmp_2@625@01 12908)) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 2)) (as int<PyType>  PyType)))))
; [eval] p2_7 ==> (true == issubtype(typeof(l2_0), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(2)), int())
(push) ; 83
(push) ; 84
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1274 | p2_7@480@01 | live]
; [else-branch: 1274 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 84
; [then-branch: 1274 | p2_7@480@01]
; [eval] (true == issubtype(typeof(l2_0), Lock(Cell()))) == issubtype(typeof(__prim__int___box__(2)), int())
; [eval] true == issubtype(typeof(l2_0), Lock(Cell()))
; [eval] issubtype(typeof(l2_0), Lock(Cell()))
; [eval] typeof(l2_0)
; [eval] Lock(Cell())
; [eval] Cell()
; [eval] issubtype(typeof(__prim__int___box__(2)), int())
; [eval] typeof(__prim__int___box__(2))
; [eval] __prim__int___box__(2)
(push) ; 85
(assert (__prim__int___box__%precondition $Snap.unit 2))
(pop) ; 85
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 2))
; [eval] int()
(pop) ; 84
(pop) ; 83
; Joined path conditions
(assert (=> p2_7@480@01 (__prim__int___box__%precondition $Snap.unit 2)))
(push) ; 83
(assert (not (=>
  p2_7@480@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 2)) (as int<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 83
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (=
    (=
      true
      (issubtype<Bool> (typeof<PyType> tmp_2@625@01) (Lock<PyType> (as Cell<PyType>  PyType))))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 2)) (as int<PyType>  PyType)))))
(push) ; 83
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 83
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1275 | p1_7@479@01 | live]
; [else-branch: 1275 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 83
; [then-branch: 1275 | p1_7@479@01]
; [exec]
; inhale true &&
;   (getArg(threadingVar_0, 0) == _checkDefined(l2, 12908) &&
;   getArg(threadingVar_0, 1) == __prim__int___box__(2))
(declare-const $t@738@01 $Snap)
(assert (= $t@738@01 ($Snap.combine ($Snap.first $t@738@01) ($Snap.second $t@738@01))))
(assert (= ($Snap.first $t@738@01) $Snap.unit))
(assert (=
  ($Snap.second $t@738@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@738@01))
    ($Snap.second ($Snap.second $t@738@01)))))
(assert (= ($Snap.first ($Snap.second $t@738@01)) $Snap.unit))
; [eval] getArg(threadingVar_0, 0) == _checkDefined(l2, 12908)
; [eval] getArg(threadingVar_0, 0)
; [eval] _checkDefined(l2, 12908)
(push) ; 84
; [eval] _isDefined(id)
(push) ; 85
(pop) ; 85
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_2@625@01 12908))
(pop) ; 84
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_2@625@01 12908))
(assert (= (getArg<Ref> tmp_4@733@01 0) (_checkDefined $Snap.unit tmp_2@625@01 12908)))
(assert (= ($Snap.second ($Snap.second $t@738@01)) $Snap.unit))
; [eval] getArg(threadingVar_0, 1) == __prim__int___box__(2)
; [eval] getArg(threadingVar_0, 1)
; [eval] __prim__int___box__(2)
(push) ; 84
(assert (__prim__int___box__%precondition $Snap.unit 2))
(pop) ; 84
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 2))
(assert (= (getArg<Ref> tmp_4@733@01 1) (__prim__int___box__ $Snap.unit 2)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start(threadingVar_0), write)
(declare-const $t@739@01 $Snap)
(set-option :timeout 0)
(push) ; 84
(set-option :timeout 10)
(assert (not (= tmp_3@722@01 tmp_4@733@01)))
(check-sat)
; unknown
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; t2 := threadingVar_0
; [exec]
; inhale _isDefined(12916)
(declare-const $t@740@01 $Snap)
(assert (= $t@740@01 $Snap.unit))
; [eval] _isDefined(12916)
(set-option :timeout 0)
(push) ; 84
(assert (_isDefined%precondition $Snap.unit 12916))
(pop) ; 84
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 12916))
(assert (_isDefined $Snap.unit 12916))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; exhale acc(_thread_start(_checkDefined(t1, 12660)), write)
; [eval] _checkDefined(t1, 12660)
(set-option :timeout 0)
(push) ; 84
; [eval] _isDefined(id)
(push) ; 85
(pop) ; 85
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_3@722@01 12660))
(pop) ; 84
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_3@722@01 12660))
(push) ; 84
(set-option :timeout 10)
(assert (not (= tmp_4@733@01 (_checkDefined $Snap.unit tmp_3@722@01 12660))))
(check-sat)
; unknown
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 84
(set-option :timeout 10)
(assert (not (= tmp_3@722@01 (_checkDefined $Snap.unit tmp_3@722@01 12660))))
(check-sat)
; unsat
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 84
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 84
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1276 | p2_7@480@01 | live]
; [else-branch: 1276 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 84
; [then-branch: 1276 | p2_7@480@01]
; [exec]
; inhale true &&
;   (getArg_0(threadingVar_0_0, 0) == l2_0 &&
;   getArg_0(threadingVar_0_0, 1) == __prim__int___box__(2))
(declare-const $t@741@01 $Snap)
(assert (= $t@741@01 ($Snap.combine ($Snap.first $t@741@01) ($Snap.second $t@741@01))))
(assert (= ($Snap.first $t@741@01) $Snap.unit))
(assert (=
  ($Snap.second $t@741@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@741@01))
    ($Snap.second ($Snap.second $t@741@01)))))
(assert (= ($Snap.first ($Snap.second $t@741@01)) $Snap.unit))
; [eval] getArg_0(threadingVar_0_0, 0) == l2_0
; [eval] getArg_0(threadingVar_0_0, 0)
(assert (= (getArg_0<Ref> tmp_4@733@01 0) tmp_2@625@01))
(assert (= ($Snap.second ($Snap.second $t@741@01)) $Snap.unit))
; [eval] getArg_0(threadingVar_0_0, 1) == __prim__int___box__(2)
; [eval] getArg_0(threadingVar_0_0, 1)
; [eval] __prim__int___box__(2)
(push) ; 85
(pop) ; 85
; Joined path conditions
(assert (= (getArg_0<Ref> tmp_4@733@01 1) (__prim__int___box__ $Snap.unit 2)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start_0(threadingVar_0_0), write)
(declare-const $t@742@01 $Snap)
(set-option :timeout 0)
(push) ; 85
(set-option :timeout 10)
(assert (not (= tmp_3@722@01 tmp_4@733@01)))
(check-sat)
; unknown
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; t2_14 := threadingVar_0_0
; [exec]
; inhale true
(declare-const $t@743@01 $Snap)
(assert (= $t@743@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale acc(_thread_start_0(t1_14), write)
; [exec]
; assert (p1_7 ==>
;   false || getMethod(_checkDefined(t1, 12660)) == printTwice_threading()) &&
;   (p2_7 ==> false || getMethod_0(t1_14) == printTwice_threading())
; [eval] p1_7 ==> false || getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
(set-option :timeout 0)
(push) ; 85
(push) ; 86
(set-option :timeout 10)
(assert (not (not p1_7@479@01)))
(check-sat)
; unknown
(pop) ; 86
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1277 | p1_7@479@01 | live]
; [else-branch: 1277 | !(p1_7@479@01) | dead]
(set-option :timeout 0)
(push) ; 86
; [then-branch: 1277 | p1_7@479@01]
; [eval] false || getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
(push) ; 87
; [then-branch: 1278 | False | live]
; [else-branch: 1278 | True | live]
(push) ; 88
; [then-branch: 1278 | False]
(assert false)
(pop) ; 88
(push) ; 88
; [else-branch: 1278 | True]
; [eval] getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
; [eval] getMethod(_checkDefined(t1, 12660))
; [eval] _checkDefined(t1, 12660)
(push) ; 89
; [eval] _isDefined(id)
(push) ; 90
(pop) ; 90
; Joined path conditions
(pop) ; 89
; Joined path conditions
; [eval] printTwice_threading()
(pop) ; 88
(pop) ; 87
; Joined path conditions
; Joined path conditions
(pop) ; 86
(pop) ; 85
; Joined path conditions
(push) ; 85
(assert (not (=>
  p1_7@479@01
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_3@722@01 12660))
    (as printTwice_threading<ThreadingID>  ThreadingID)))))
(check-sat)
; unsat
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_7@479@01
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_3@722@01 12660))
    (as printTwice_threading<ThreadingID>  ThreadingID))))
; [eval] p2_7 ==> false || getMethod_0(t1_14) == printTwice_threading()
(push) ; 85
(push) ; 86
(set-option :timeout 10)
(assert (not (not p2_7@480@01)))
(check-sat)
; unknown
(pop) ; 86
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1279 | p2_7@480@01 | live]
; [else-branch: 1279 | !(p2_7@480@01) | dead]
(set-option :timeout 0)
(push) ; 86
; [then-branch: 1279 | p2_7@480@01]
; [eval] false || getMethod_0(t1_14) == printTwice_threading()
(push) ; 87
; [then-branch: 1280 | False | live]
; [else-branch: 1280 | True | live]
(push) ; 88
; [then-branch: 1280 | False]
(assert false)
(pop) ; 88
(push) ; 88
; [else-branch: 1280 | True]
; [eval] getMethod_0(t1_14) == printTwice_threading()
; [eval] getMethod_0(t1_14)
; [eval] printTwice_threading()
(pop) ; 88
(pop) ; 87
; Joined path conditions
; Joined path conditions
(pop) ; 86
(pop) ; 85
; Joined path conditions
(push) ; 85
(assert (not (=>
  p2_7@480@01
  (=
    (getMethod_0<ThreadingID> tmp_3@722@01)
    (as printTwice_threading<ThreadingID>  ThreadingID)))))
(check-sat)
; unsat
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_7@480@01
  (=
    (getMethod_0<ThreadingID> tmp_3@722@01)
    (as printTwice_threading<ThreadingID>  ThreadingID))))
; [exec]
; p1_9 := p1_7 &&
;   getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
; [eval] p1_7 && getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
(push) ; 85
; [then-branch: 1281 | !(p1_7@479@01) | live]
; [else-branch: 1281 | p1_7@479@01 | live]
(push) ; 86
; [then-branch: 1281 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 86
(push) ; 86
; [else-branch: 1281 | p1_7@479@01]
; [eval] getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
; [eval] getMethod(_checkDefined(t1, 12660))
; [eval] _checkDefined(t1, 12660)
(push) ; 87
; [eval] _isDefined(id)
(push) ; 88
(pop) ; 88
; Joined path conditions
(pop) ; 87
; Joined path conditions
; [eval] printTwice_threading()
(pop) ; 86
(pop) ; 85
; Joined path conditions
; Joined path conditions
(declare-const p1_9@744@01 Bool)
(assert (=
  p1_9@744@01
  (and
    p1_7@479@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_3@722@01 12660))
      (as printTwice_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_9 := p2_7 && getMethod_0(t1_14) == printTwice_threading()
; [eval] p2_7 && getMethod_0(t1_14) == printTwice_threading()
(push) ; 85
; [then-branch: 1282 | !(p2_7@480@01) | live]
; [else-branch: 1282 | p2_7@480@01 | live]
(push) ; 86
; [then-branch: 1282 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 86
(push) ; 86
; [else-branch: 1282 | p2_7@480@01]
; [eval] getMethod_0(t1_14) == printTwice_threading()
; [eval] getMethod_0(t1_14)
; [eval] printTwice_threading()
(pop) ; 86
(pop) ; 85
; Joined path conditions
; Joined path conditions
(declare-const p2_9@745@01 Bool)
(assert (=
  p2_9@745@01
  (and
    p2_7@480@01
    (=
      (getMethod_0<ThreadingID> tmp_3@722@01)
      (as printTwice_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_2 := p1_7 &&
;   !(getMethod(_checkDefined(t1, 12660)) == printTwice_threading())
; [eval] p1_7 && !(getMethod(_checkDefined(t1, 12660)) == printTwice_threading())
(push) ; 85
; [then-branch: 1283 | !(p1_7@479@01) | live]
; [else-branch: 1283 | p1_7@479@01 | live]
(push) ; 86
; [then-branch: 1283 | !(p1_7@479@01)]
(assert (not p1_7@479@01))
(pop) ; 86
(push) ; 86
; [else-branch: 1283 | p1_7@479@01]
; [eval] !(getMethod(_checkDefined(t1, 12660)) == printTwice_threading())
; [eval] getMethod(_checkDefined(t1, 12660)) == printTwice_threading()
; [eval] getMethod(_checkDefined(t1, 12660))
; [eval] _checkDefined(t1, 12660)
(push) ; 87
; [eval] _isDefined(id)
(push) ; 88
(pop) ; 88
; Joined path conditions
(pop) ; 87
; Joined path conditions
; [eval] printTwice_threading()
(pop) ; 86
(pop) ; 85
; Joined path conditions
; Joined path conditions
(declare-const p3_2@746@01 Bool)
(assert (=
  p3_2@746@01
  (and
    p1_7@479@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_3@722@01 12660))
        (as printTwice_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_2 := p2_7 && !(getMethod_0(t1_14) == printTwice_threading())
; [eval] p2_7 && !(getMethod_0(t1_14) == printTwice_threading())
(push) ; 85
; [then-branch: 1284 | !(p2_7@480@01) | live]
; [else-branch: 1284 | p2_7@480@01 | live]
(push) ; 86
; [then-branch: 1284 | !(p2_7@480@01)]
(assert (not p2_7@480@01))
(pop) ; 86
(push) ; 86
; [else-branch: 1284 | p2_7@480@01]
; [eval] !(getMethod_0(t1_14) == printTwice_threading())
; [eval] getMethod_0(t1_14) == printTwice_threading()
; [eval] getMethod_0(t1_14)
; [eval] printTwice_threading()
(pop) ; 86
(pop) ; 85
; Joined path conditions
; Joined path conditions
(declare-const p4_2@747@01 Bool)
(assert (=
  p4_2@747@01
  (and
    p2_7@480@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_3@722@01)
        (as printTwice_threading<ThreadingID>  ThreadingID))))))
(push) ; 85
(set-option :timeout 10)
(assert (not (not p1_9@744@01)))
(check-sat)
; unknown
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 85
(set-option :timeout 10)
(assert (not p1_9@744@01))
(check-sat)
; unsat
(pop) ; 85
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1285 | p1_9@744@01 | live]
; [else-branch: 1285 | !(p1_9@744@01) | dead]
(set-option :timeout 0)
(push) ; 85
; [then-branch: 1285 | p1_9@744@01]
(assert p1_9@744@01)
; [exec]
; thread_arg := getArg(_checkDefined(t1, 12660), 0)
; [eval] getArg(_checkDefined(t1, 12660), 0)
; [eval] _checkDefined(t1, 12660)
(push) ; 86
; [eval] _isDefined(id)
(push) ; 87
(pop) ; 87
; Joined path conditions
(pop) ; 86
; Joined path conditions
(declare-const thread_arg@748@01 $Ref)
(assert (=
  thread_arg@748@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_3@722@01 12660) 0)))
; [exec]
; inhale issubtype(typeof(thread_arg), Lock(Cell()))
(declare-const $t@749@01 $Snap)
(assert (= $t@749@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg), Lock(Cell()))
; [eval] typeof(thread_arg)
; [eval] Lock(Cell())
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg@748@01) (Lock<PyType> (as Cell<PyType>  PyType))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; thread_arg_0 := getArg(_checkDefined(t1, 12660), 1)
; [eval] getArg(_checkDefined(t1, 12660), 1)
; [eval] _checkDefined(t1, 12660)
(set-option :timeout 0)
(push) ; 86
; [eval] _isDefined(id)
(push) ; 87
(pop) ; 87
; Joined path conditions
(pop) ; 86
; Joined path conditions
(declare-const thread_arg_0@750@01 $Ref)
(assert (=
  thread_arg_0@750@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_3@722@01 12660) 1)))
; [exec]
; inhale issubtype(typeof(thread_arg_0), int())
(declare-const $t@751@01 $Snap)
(assert (= $t@751@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_0), int())
; [eval] typeof(thread_arg_0)
; [eval] int()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_0@750@01) (as int<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@752@01 $Snap)
(assert (= $t@752@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 86
(set-option :timeout 10)
(assert (not (not p2_9@745@01)))
(check-sat)
; unknown
(pop) ; 86
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 86
(set-option :timeout 10)
(assert (not p2_9@745@01))
(check-sat)
; unsat
(pop) ; 86
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1286 | p2_9@745@01 | live]
; [else-branch: 1286 | !(p2_9@745@01) | dead]
(set-option :timeout 0)
(push) ; 86
; [then-branch: 1286 | p2_9@745@01]
(assert p2_9@745@01)
; [exec]
; thread_arg_9 := getArg_0(t1_14, 0)
; [eval] getArg_0(t1_14, 0)
(declare-const thread_arg_9@753@01 $Ref)
(assert (= thread_arg_9@753@01 (getArg_0<Ref> tmp_3@722@01 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_9), Lock(Cell()))
(declare-const $t@754@01 $Snap)
(assert (= $t@754@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_9), Lock(Cell()))
; [eval] typeof(thread_arg_9)
; [eval] Lock(Cell())
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_9@753@01) (Lock<PyType> (as Cell<PyType>  PyType))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; thread_arg_0_0 := getArg_0(t1_14, 1)
; [eval] getArg_0(t1_14, 1)
(declare-const thread_arg_0_0@755@01 $Ref)
(assert (= thread_arg_0_0@755@01 (getArg_0<Ref> tmp_3@722@01 1)))
; [exec]
; inhale issubtype(typeof(thread_arg_0_0), int())
(declare-const $t@756@01 $Snap)
(assert (= $t@756@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_0_0), int())
; [eval] typeof(thread_arg_0_0)
; [eval] int()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_0_0@755@01) (as int<PyType>  PyType)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@757@01 $Snap)
(assert (= $t@757@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale (p1_9 ==> true) &&
;   ((p2_9 ==> true) &&
;   (p1_9 == p2_9 &&
;   ((p1_9 && p2_9 ==> thread_arg == thread_arg_9) &&
;   (p1_9 && p2_9 ==> thread_arg_0 == thread_arg_0_0) &&
;   ((p1_9 ==> true) && (p2_9 ==> true) &&
;   ((p1_9 ==> true) && (p2_9 ==> true))))))
; [eval] p1_9 ==> true
(set-option :timeout 0)
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not p1_9@744@01)))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1287 | p1_9@744@01 | live]
; [else-branch: 1287 | !(p1_9@744@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1287 | p1_9@744@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
; [eval] p2_9 ==> true
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not p2_9@745@01)))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1288 | p2_9@745@01 | live]
; [else-branch: 1288 | !(p2_9@745@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1288 | p2_9@745@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
; [eval] p1_9 == p2_9
(push) ; 87
(assert (not (= p1_9@744@01 p2_9@745@01)))
(check-sat)
; unsat
(pop) ; 87
; 0.00s
; (get-info :all-statistics)
(assert (= p1_9@744@01 p2_9@745@01))
; [eval] p1_9 && p2_9 ==> thread_arg == thread_arg_9
; [eval] p1_9 && p2_9
(push) ; 87
; [then-branch: 1289 | !(p1_9@744@01) | live]
; [else-branch: 1289 | p1_9@744@01 | live]
(push) ; 88
; [then-branch: 1289 | !(p1_9@744@01)]
(assert (not p1_9@744@01))
(pop) ; 88
(push) ; 88
; [else-branch: 1289 | p1_9@744@01]
(pop) ; 88
(pop) ; 87
; Joined path conditions
; Joined path conditions
(assert (or p1_9@744@01 (not p1_9@744@01)))
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not (and p1_9@744@01 p2_9@745@01))))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 88
(set-option :timeout 10)
(assert (not (and p1_9@744@01 p2_9@745@01)))
(check-sat)
; unsat
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1290 | p1_9@744@01 && p2_9@745@01 | live]
; [else-branch: 1290 | !(p1_9@744@01 && p2_9@745@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1290 | p1_9@744@01 && p2_9@745@01]
(assert (and p1_9@744@01 p2_9@745@01))
; [eval] thread_arg == thread_arg_9
(pop) ; 88
(pop) ; 87
; Joined path conditions
(assert (and p1_9@744@01 p2_9@745@01))
(push) ; 87
(assert (not (=> (and p1_9@744@01 p2_9@745@01) (= thread_arg@748@01 thread_arg_9@753@01))))
(check-sat)
; unknown
(pop) ; 87
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_9 && p2_9 ==> thread_arg == thread_arg_9
; [eval] p1_9 && p2_9
(set-option :timeout 0)
(push) ; 87
; [then-branch: 1291 | !(p1_9@744@01) | live]
; [else-branch: 1291 | p1_9@744@01 | live]
(push) ; 88
; [then-branch: 1291 | !(p1_9@744@01)]
(assert (not p1_9@744@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unsat
(pop) ; 88
(set-option :timeout 0)
(push) ; 88
; [else-branch: 1291 | p1_9@744@01]
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 88
(pop) ; 87
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not (and p1_9@744@01 p2_9@745@01))))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 88
(set-option :timeout 10)
(assert (not (and p1_9@744@01 p2_9@745@01)))
(check-sat)
; unsat
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1292 | p1_9@744@01 && p2_9@745@01 | live]
; [else-branch: 1292 | !(p1_9@744@01 && p2_9@745@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1292 | p1_9@744@01 && p2_9@745@01]
(assert (and p1_9@744@01 p2_9@745@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] thread_arg == thread_arg_9
(pop) ; 88
(pop) ; 87
; Joined path conditions
(assert (and p1_9@744@01 p2_9@745@01))
(set-option :timeout 0)
(push) ; 87
(assert (not (=> (and p1_9@744@01 p2_9@745@01) (= thread_arg@748@01 thread_arg_9@753@01))))
(check-sat)
; unknown
(pop) ; 87
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_9 && p2_9 ==> thread_arg == thread_arg_9
; [eval] p1_9 && p2_9
(set-option :timeout 0)
(push) ; 87
; [then-branch: 1293 | !(p1_9@744@01) | live]
; [else-branch: 1293 | p1_9@744@01 | live]
(push) ; 88
; [then-branch: 1293 | !(p1_9@744@01)]
(assert (not p1_9@744@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unsat
(pop) ; 88
(set-option :timeout 0)
(push) ; 88
; [else-branch: 1293 | p1_9@744@01]
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 88
(pop) ; 87
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not (and p1_9@744@01 p2_9@745@01))))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 88
(set-option :timeout 10)
(assert (not (and p1_9@744@01 p2_9@745@01)))
(check-sat)
; unsat
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1294 | p1_9@744@01 && p2_9@745@01 | live]
; [else-branch: 1294 | !(p1_9@744@01 && p2_9@745@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1294 | p1_9@744@01 && p2_9@745@01]
(assert (and p1_9@744@01 p2_9@745@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] thread_arg == thread_arg_9
(pop) ; 88
(pop) ; 87
; Joined path conditions
(assert (and p1_9@744@01 p2_9@745@01))
(set-option :timeout 0)
(push) ; 87
(assert (not (=> (and p1_9@744@01 p2_9@745@01) (= thread_arg@748@01 thread_arg_9@753@01))))
(check-sat)
; unknown
(pop) ; 87
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_9 && p2_9 ==> thread_arg == thread_arg_9
; [eval] p1_9 && p2_9
(set-option :timeout 0)
(push) ; 87
; [then-branch: 1295 | !(p1_9@744@01) | live]
; [else-branch: 1295 | p1_9@744@01 | live]
(push) ; 88
; [then-branch: 1295 | !(p1_9@744@01)]
(assert (not p1_9@744@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unsat
(pop) ; 88
(set-option :timeout 0)
(push) ; 88
; [else-branch: 1295 | p1_9@744@01]
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 88
(pop) ; 87
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 87
(push) ; 88
(set-option :timeout 10)
(assert (not (not (and p1_9@744@01 p2_9@745@01))))
(check-sat)
; unknown
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 88
(set-option :timeout 10)
(assert (not (and p1_9@744@01 p2_9@745@01)))
(check-sat)
; unsat
(pop) ; 88
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1296 | p1_9@744@01 && p2_9@745@01 | live]
; [else-branch: 1296 | !(p1_9@744@01 && p2_9@745@01) | dead]
(set-option :timeout 0)
(push) ; 88
; [then-branch: 1296 | p1_9@744@01 && p2_9@745@01]
(assert (and p1_9@744@01 p2_9@745@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] thread_arg == thread_arg_9
(pop) ; 88
(pop) ; 87
; Joined path conditions
(assert (and p1_9@744@01 p2_9@745@01))
(set-option :timeout 0)
(push) ; 87
(assert (not (=> (and p1_9@744@01 p2_9@745@01) (= thread_arg@748@01 thread_arg_9@753@01))))
(check-sat)
; unknown
(pop) ; 87
; 0.00s
; (get-info :all-statistics)
(pop) ; 86
(pop) ; 85
(pop) ; 84
(pop) ; 83
(pop) ; 82
(pop) ; 81
(pop) ; 80
(pop) ; 79
(pop) ; 78
(pop) ; 77
(pop) ; 76
(pop) ; 75
(pop) ; 74
(pop) ; 73
(pop) ; 72
(pop) ; 71
(pop) ; 70
(pop) ; 69
(pop) ; 68
(pop) ; 67
(pop) ; 66
(pop) ; 65
(pop) ; 64
(pop) ; 63
(pop) ; 62
(pop) ; 61
(pop) ; 60
(pop) ; 59
(pop) ; 58
(pop) ; 57
(pop) ; 56
(pop) ; 55
(pop) ; 54
(pop) ; 53
(pop) ; 52
(pop) ; 51
(pop) ; 50
(pop) ; 49
(pop) ; 48
(pop) ; 47
(pop) ; 46
(pop) ; 45
(pop) ; 44
(pop) ; 43
(pop) ; 42
(pop) ; 41
(pop) ; 40
(pop) ; 39
(pop) ; 38
(pop) ; 37
(pop) ; 36
(pop) ; 35
(pop) ; 34
(pop) ; 33
(pop) ; 32
(pop) ; 31
(pop) ; 30
(pop) ; 29
(pop) ; 28
(pop) ; 27
(pop) ; 26
(pop) ; 25
(pop) ; 24
(pop) ; 23
(pop) ; 22
(pop) ; 21
(pop) ; 20
(pop) ; 19
(pop) ; 18
(pop) ; 17
(pop) ; 16
(pop) ; 15
(pop) ; 14
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- fork_lowevent ----------
(declare-const p1_11@758@01 Bool)
(declare-const p2_11@759@01 Bool)
(declare-const _cthread_167@760@01 $Ref)
(declare-const _cthread_167_0@761@01 $Ref)
(declare-const _caller_measures_167@762@01 Seq<Measure$>)
(declare-const _caller_measures_167_0@763@01 Seq<Measure$>)
(declare-const _residue_167@764@01 $Perm)
(declare-const _residue_167_0@765@01 $Perm)
(declare-const secret_0@766@01 $Ref)
(declare-const secret_0_0@767@01 $Ref)
(declare-const _current_wait_level_167@768@01 $Perm)
(declare-const _current_wait_level_167_0@769@01 $Perm)
(declare-const p1_11@770@01 Bool)
(declare-const p2_11@771@01 Bool)
(declare-const _cthread_167@772@01 $Ref)
(declare-const _cthread_167_0@773@01 $Ref)
(declare-const _caller_measures_167@774@01 Seq<Measure$>)
(declare-const _caller_measures_167_0@775@01 Seq<Measure$>)
(declare-const _residue_167@776@01 $Perm)
(declare-const _residue_167_0@777@01 $Perm)
(declare-const secret_0@778@01 $Ref)
(declare-const secret_0_0@779@01 $Ref)
(declare-const _current_wait_level_167@780@01 $Perm)
(declare-const _current_wait_level_167_0@781@01 $Perm)
(push) ; 1
(declare-const $t@782@01 $Snap)
(assert (= $t@782@01 ($Snap.combine ($Snap.first $t@782@01) ($Snap.second $t@782@01))))
(assert (= ($Snap.first $t@782@01) $Snap.unit))
; [eval] p1_11 ==> _cthread_167 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_11@770@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1297 | p1_11@770@01 | live]
; [else-branch: 1297 | !(p1_11@770@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1297 | p1_11@770@01]
(assert p1_11@770@01)
; [eval] _cthread_167 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1297 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_11@770@01) p1_11@770@01))
(assert (=> p1_11@770@01 (not (= _cthread_167@772@01 $Ref.null))))
(assert (=
  ($Snap.second $t@782@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@782@01))
    ($Snap.second ($Snap.second $t@782@01)))))
(assert (= ($Snap.first ($Snap.second $t@782@01)) $Snap.unit))
; [eval] p2_11 ==> _cthread_167_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_11@771@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1298 | p2_11@771@01 | live]
; [else-branch: 1298 | !(p2_11@771@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1298 | p2_11@771@01]
(assert p2_11@771@01)
; [eval] _cthread_167_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1298 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_11@771@01) p2_11@771@01))
(assert (=> p2_11@771@01 (not (= _cthread_167_0@773@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@782@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@782@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@782@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@782@01))) $Snap.unit))
; [eval] p1_11 ==> issubtype(typeof(_cthread_167), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_11@770@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1299 | p1_11@770@01 | live]
; [else-branch: 1299 | !(p1_11@770@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1299 | p1_11@770@01]
(assert p1_11@770@01)
; [eval] issubtype(typeof(_cthread_167), Thread_0())
; [eval] typeof(_cthread_167)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1299 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_11@770@01
  (issubtype<Bool> (typeof<PyType> _cthread_167@772@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@782@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@782@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@782@01))))
  $Snap.unit))
; [eval] p2_11 ==> issubtype(typeof(_cthread_167_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_11@771@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1300 | p2_11@771@01 | live]
; [else-branch: 1300 | !(p2_11@771@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1300 | p2_11@771@01]
(assert p2_11@771@01)
; [eval] issubtype(typeof(_cthread_167_0), Thread_0())
; [eval] typeof(_cthread_167_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1300 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_11@771@01
  (issubtype<Bool> (typeof<PyType> _cthread_167_0@773@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01)))))
  $Snap.unit))
; [eval] p1_11 ==> issubtype(typeof(secret_0), bool())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_11@770@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1301 | p1_11@770@01 | live]
; [else-branch: 1301 | !(p1_11@770@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1301 | p1_11@770@01]
(assert p1_11@770@01)
; [eval] issubtype(typeof(secret_0), bool())
; [eval] typeof(secret_0)
; [eval] bool()
(pop) ; 3
(push) ; 3
; [else-branch: 1301 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_11@770@01
  (issubtype<Bool> (typeof<PyType> secret_0@778@01) (as bool<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01))))))
  $Snap.unit))
; [eval] p2_11 ==> issubtype(typeof(secret_0_0), bool())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_11@771@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1302 | p2_11@771@01 | live]
; [else-branch: 1302 | !(p2_11@771@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1302 | p2_11@771@01]
(assert p2_11@771@01)
; [eval] issubtype(typeof(secret_0_0), bool())
; [eval] typeof(secret_0_0)
; [eval] bool()
(pop) ; 3
(push) ; 3
; [else-branch: 1302 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_11@771@01
  (issubtype<Bool> (typeof<PyType> secret_0_0@779@01) (as bool<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01)))))))
  $Snap.unit))
; [eval] p1_11 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_11@770@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1303 | p1_11@770@01 | live]
; [else-branch: 1303 | !(p1_11@770@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1303 | p1_11@770@01]
(assert p1_11@770@01)
(pop) ; 3
(push) ; 3
; [else-branch: 1303 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@782@01)))))))
  $Snap.unit))
; [eval] p2_11 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_11@771@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1304 | p2_11@771@01 | live]
; [else-branch: 1304 | !(p2_11@771@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1304 | p2_11@771@01]
(assert p2_11@771@01)
(pop) ; 3
(push) ; 3
; [else-branch: 1304 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@783@01 $Snap)
(assert (= $t@783@01 ($Snap.combine ($Snap.first $t@783@01) ($Snap.second $t@783@01))))
(assert (= ($Snap.first $t@783@01) $Snap.unit))
; [eval] p1_11 ==> (forperm _r_26: Ref [_r_26.MustReleaseBounded] :: Level(_r_26) <= _current_wait_level_167) && ((forperm _r_26: Ref [_r_26.MustReleaseUnbounded] :: Level(_r_26) <= _current_wait_level_167) && _residue_167 <= _current_wait_level_167)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_11@770@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1305 | p1_11@770@01 | live]
; [else-branch: 1305 | !(p1_11@770@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1305 | p1_11@770@01]
(assert p1_11@770@01)
; [eval] (forperm _r_26: Ref [_r_26.MustReleaseBounded] :: Level(_r_26) <= _current_wait_level_167) && ((forperm _r_26: Ref [_r_26.MustReleaseUnbounded] :: Level(_r_26) <= _current_wait_level_167) && _residue_167 <= _current_wait_level_167)
; [eval] (forperm _r_26: Ref [_r_26.MustReleaseBounded] :: Level(_r_26) <= _current_wait_level_167)
(push) ; 5
; [then-branch: 1306 | False | live]
; [else-branch: 1306 | True | live]
(push) ; 6
; [then-branch: 1306 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 1306 | True]
; [eval] (forperm _r_26: Ref [_r_26.MustReleaseUnbounded] :: Level(_r_26) <= _current_wait_level_167)
(push) ; 7
; [then-branch: 1307 | False | live]
; [else-branch: 1307 | True | live]
(push) ; 8
; [then-branch: 1307 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1307 | True]
; [eval] _residue_167 <= _current_wait_level_167
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1305 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p1_11@770@01 (<= _residue_167@776@01 _current_wait_level_167@780@01)))
(assert (=
  ($Snap.second $t@783@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@783@01))
    ($Snap.second ($Snap.second $t@783@01)))))
(assert (= ($Snap.first ($Snap.second $t@783@01)) $Snap.unit))
; [eval] p2_11 ==> (forperm _r_26: Ref [_r_26.MustReleaseBoundedp] :: Level(_r_26) <= _current_wait_level_167_0) && ((forperm _r_26: Ref [_r_26.MustReleaseUnboundedp] :: Level(_r_26) <= _current_wait_level_167_0) && _residue_167_0 <= _current_wait_level_167_0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_11@771@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1308 | p2_11@771@01 | live]
; [else-branch: 1308 | !(p2_11@771@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1308 | p2_11@771@01]
(assert p2_11@771@01)
; [eval] (forperm _r_26: Ref [_r_26.MustReleaseBoundedp] :: Level(_r_26) <= _current_wait_level_167_0) && ((forperm _r_26: Ref [_r_26.MustReleaseUnboundedp] :: Level(_r_26) <= _current_wait_level_167_0) && _residue_167_0 <= _current_wait_level_167_0)
; [eval] (forperm _r_26: Ref [_r_26.MustReleaseBoundedp] :: Level(_r_26) <= _current_wait_level_167_0)
(push) ; 5
; [then-branch: 1309 | False | live]
; [else-branch: 1309 | True | live]
(push) ; 6
; [then-branch: 1309 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 1309 | True]
; [eval] (forperm _r_26: Ref [_r_26.MustReleaseUnboundedp] :: Level(_r_26) <= _current_wait_level_167_0)
(push) ; 7
; [then-branch: 1310 | False | live]
; [else-branch: 1310 | True | live]
(push) ; 8
; [then-branch: 1310 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1310 | True]
; [eval] _residue_167_0 <= _current_wait_level_167_0
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1308 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p2_11@771@01 (<= _residue_167_0@777@01 _current_wait_level_167_0@781@01)))
(assert (=
  ($Snap.second ($Snap.second $t@783@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@783@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@783@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@783@01))) $Snap.unit))
; [eval] p1_11 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_11@770@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1311 | p1_11@770@01 | live]
; [else-branch: 1311 | !(p1_11@770@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1311 | p1_11@770@01]
(assert p1_11@770@01)
(pop) ; 4
(push) ; 4
; [else-branch: 1311 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@783@01))) $Snap.unit))
; [eval] p2_11 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_11@771@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1312 | p2_11@771@01 | live]
; [else-branch: 1312 | !(p2_11@771@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1312 | p2_11@771@01]
(assert p2_11@771@01)
(pop) ; 4
(push) ; 4
; [else-branch: 1312 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
(push) ; 2
; [exec]
; var _err: Ref
(declare-const _err@784@01 $Ref)
; [exec]
; var _err_7: Ref
(declare-const _err_7@785@01 $Ref)
; [exec]
; var t_0: Ref
(declare-const t_0@786@01 $Ref)
; [exec]
; var t_0_0: Ref
(declare-const t_0_0@787@01 $Ref)
; [exec]
; var secret_4: Ref
(declare-const secret_4@788@01 $Ref)
; [exec]
; var secret_4_0: Ref
(declare-const secret_4_0@789@01 $Ref)
; [exec]
; var threadingVar_1: Ref
(declare-const threadingVar_1@790@01 $Ref)
; [exec]
; var threadingVar_1_0: Ref
(declare-const threadingVar_1_0@791@01 $Ref)
; [exec]
; var threadingVar_2: Ref
(declare-const threadingVar_2@792@01 $Ref)
; [exec]
; var threadingVar_2_0: Ref
(declare-const threadingVar_2_0@793@01 $Ref)
; [exec]
; var _cwl_167: Perm
(declare-const _cwl_167@794@01 $Perm)
; [exec]
; var _cwl_167_0: Perm
(declare-const _cwl_167_0@795@01 $Perm)
; [exec]
; var _method_measures_167: Seq[Measure$]
(declare-const _method_measures_167@796@01 Seq<Measure$>)
; [exec]
; var _method_measures_167_0: Seq[Measure$]
(declare-const _method_measures_167_0@797@01 Seq<Measure$>)
; [exec]
; var p1_12: Bool
(declare-const p1_12@798@01 Bool)
; [exec]
; var p2_12: Bool
(declare-const p2_12@799@01 Bool)
; [exec]
; var p3_4: Bool
(declare-const p3_4@800@01 Bool)
; [exec]
; var p4_4: Bool
(declare-const p4_4@801@01 Bool)
; [exec]
; var tmp_5: Ref
(declare-const tmp_5@802@01 $Ref)
; [exec]
; var tmp_6: Ref
(declare-const tmp_6@803@01 $Ref)
; [exec]
; var p1_13: Bool
(declare-const p1_13@804@01 Bool)
; [exec]
; var p2_13: Bool
(declare-const p2_13@805@01 Bool)
; [exec]
; var p3_5: Bool
(declare-const p3_5@806@01 Bool)
; [exec]
; var p4_5: Bool
(declare-const p4_5@807@01 Bool)
; [exec]
; var p1_14: Bool
(declare-const p1_14@808@01 Bool)
; [exec]
; var p2_14: Bool
(declare-const p2_14@809@01 Bool)
; [exec]
; var p3_6: Bool
(declare-const p3_6@810@01 Bool)
; [exec]
; var p4_6: Bool
(declare-const p4_6@811@01 Bool)
; [exec]
; inhale p1_11
(declare-const $t@812@01 $Snap)
(assert (= $t@812@01 $Snap.unit))
(assert p1_11@770@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1313 | p1_11@770@01 | live]
; [else-branch: 1313 | !(p1_11@770@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1313 | p1_11@770@01]
; [exec]
; _method_measures_167 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err := null
; [exec]
; secret_4 := secret_0
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_11@771@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1314 | p2_11@771@01 | live]
; [else-branch: 1314 | !(p2_11@771@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1314 | p2_11@771@01]
(assert p2_11@771@01)
; [exec]
; _method_measures_167_0 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err_7 := null
; [exec]
; secret_4_0 := secret_0_0
; [exec]
; p1_12 := p1_11 && bool___unbox__(secret_4)
; [eval] p1_11 && bool___unbox__(secret_4)
(push) ; 5
; [then-branch: 1315 | !(p1_11@770@01) | live]
; [else-branch: 1315 | p1_11@770@01 | live]
(push) ; 6
; [then-branch: 1315 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 6
(push) ; 6
; [else-branch: 1315 | p1_11@770@01]
; [eval] bool___unbox__(secret_4)
(push) ; 7
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 8
(assert (not (issubtype<Bool> (typeof<PyType> secret_0@778@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_0@778@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_0@778@01))
(pop) ; 7
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_0@778@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_0@778@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_11@770@01
  (and
    (issubtype<Bool> (typeof<PyType> secret_0@778@01) (as bool<PyType>  PyType))
    (bool___unbox__%precondition $Snap.unit secret_0@778@01))))
(assert (or p1_11@770@01 (not p1_11@770@01)))
(declare-const p1_12@813@01 Bool)
(assert (= p1_12@813@01 (and p1_11@770@01 (bool___unbox__ $Snap.unit secret_0@778@01))))
; [exec]
; p2_12 := p2_11 && bool___unbox__(secret_4_0)
; [eval] p2_11 && bool___unbox__(secret_4_0)
(push) ; 5
; [then-branch: 1316 | !(p2_11@771@01) | live]
; [else-branch: 1316 | p2_11@771@01 | live]
(push) ; 6
; [then-branch: 1316 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 6
(push) ; 6
; [else-branch: 1316 | p2_11@771@01]
; [eval] bool___unbox__(secret_4_0)
(push) ; 7
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 8
(assert (not (issubtype<Bool> (typeof<PyType> secret_0_0@779@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_0_0@779@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_0_0@779@01))
(pop) ; 7
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_0_0@779@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_0_0@779@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_11@771@01
  (and
    (issubtype<Bool> (typeof<PyType> secret_0_0@779@01) (as bool<PyType>  PyType))
    (bool___unbox__%precondition $Snap.unit secret_0_0@779@01))))
(assert (or p2_11@771@01 (not p2_11@771@01)))
(declare-const p2_12@814@01 Bool)
(assert (= p2_12@814@01 (and p2_11@771@01 (bool___unbox__ $Snap.unit secret_0_0@779@01))))
; [exec]
; p3_4 := p1_11 && !bool___unbox__(secret_4)
; [eval] p1_11 && !bool___unbox__(secret_4)
(push) ; 5
; [then-branch: 1317 | !(p1_11@770@01) | live]
; [else-branch: 1317 | p1_11@770@01 | live]
(push) ; 6
; [then-branch: 1317 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 6
(push) ; 6
; [else-branch: 1317 | p1_11@770@01]
; [eval] !bool___unbox__(secret_4)
; [eval] bool___unbox__(secret_4)
(push) ; 7
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 8
(assert (not (issubtype<Bool> (typeof<PyType> secret_0@778@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_0@778@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_0@778@01))
(pop) ; 7
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_0@778@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_0@778@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(declare-const p3_4@815@01 Bool)
(assert (=
  p3_4@815@01
  (and p1_11@770@01 (not (bool___unbox__ $Snap.unit secret_0@778@01)))))
; [exec]
; p4_4 := p2_11 && !bool___unbox__(secret_4_0)
; [eval] p2_11 && !bool___unbox__(secret_4_0)
(push) ; 5
; [then-branch: 1318 | !(p2_11@771@01) | live]
; [else-branch: 1318 | p2_11@771@01 | live]
(push) ; 6
; [then-branch: 1318 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 6
(push) ; 6
; [else-branch: 1318 | p2_11@771@01]
; [eval] !bool___unbox__(secret_4_0)
; [eval] bool___unbox__(secret_4_0)
(push) ; 7
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 8
(assert (not (issubtype<Bool> (typeof<PyType> secret_0_0@779@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_0_0@779@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_0_0@779@01))
(pop) ; 7
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_0_0@779@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_0_0@779@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(declare-const p4_4@816@01 Bool)
(assert (=
  p4_4@816@01
  (and p2_11@771@01 (not (bool___unbox__ $Snap.unit secret_0_0@779@01)))))
; [exec]
; tmp_5 := new()
(declare-const tmp_5@817@01 $Ref)
(assert (not (= tmp_5@817@01 $Ref.null)))
(assert (not (= tmp_5@817@01 threadingVar_1@790@01)))
(assert (not (= tmp_5@817@01 tmp_6@803@01)))
(assert (not (= tmp_5@817@01 _cthread_167_0@773@01)))
(assert (not (= tmp_5@817@01 threadingVar_2@792@01)))
(assert (not (= tmp_5@817@01 threadingVar_2_0@793@01)))
(assert (not (= tmp_5@817@01 threadingVar_1_0@791@01)))
(assert (not (= tmp_5@817@01 t_0@786@01)))
(assert (not (= tmp_5@817@01 tmp_5@802@01)))
(assert (not (= tmp_5@817@01 _cthread_167@772@01)))
(assert (not (= tmp_5@817@01 secret_0@778@01)))
(assert (not (= tmp_5@817@01 t_0_0@787@01)))
(assert (not (= tmp_5@817@01 secret_0_0@779@01)))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_12@813@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not p1_12@813@01))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1319 | p1_12@813@01 | live]
; [else-branch: 1319 | !(p1_12@813@01) | live]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1319 | p1_12@813@01]
(assert p1_12@813@01)
; [exec]
; threadingVar_1 := tmp_5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_12@814@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not p2_12@814@01))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1320 | p2_12@814@01 | live]
; [else-branch: 1320 | !(p2_12@814@01) | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1320 | p2_12@814@01]
(assert p2_12@814@01)
; [exec]
; threadingVar_1_0 := tmp_5
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_12@813@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1321 | p1_12@813@01 | live]
; [else-branch: 1321 | !(p1_12@813@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 1321 | p1_12@813@01]
; [exec]
; inhale issubtype(typeof(threadingVar_1), Thread_0())
(declare-const $t@818@01 $Snap)
(assert (= $t@818@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_1), Thread_0())
; [eval] typeof(threadingVar_1)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_5@817@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod(threadingVar_1) == printZero_threading()
(declare-const $t@819@01 $Snap)
(assert (= $t@819@01 $Snap.unit))
; [eval] getMethod(threadingVar_1) == printZero_threading()
; [eval] getMethod(threadingVar_1)
; [eval] printZero_threading()
(assert (=
  (getMethod<ThreadingID> tmp_5@817@01)
  (as printZero_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@820@01 $Snap)
(assert (= $t@820@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start(threadingVar_1), write)
(declare-const $t@821@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t_0 := threadingVar_1
; [exec]
; inhale _isDefined(3170164)
(declare-const $t@822@01 $Snap)
(assert (= $t@822@01 $Snap.unit))
; [eval] _isDefined(3170164)
(set-option :timeout 0)
(push) ; 8
(assert (_isDefined%precondition $Snap.unit 3170164))
(pop) ; 8
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 3170164))
(assert (_isDefined $Snap.unit 3170164))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_12@814@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1322 | p2_12@814@01 | live]
; [else-branch: 1322 | !(p2_12@814@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1322 | p2_12@814@01]
; [exec]
; inhale issubtype(typeof(threadingVar_1_0), Thread_0())
(declare-const $t@823@01 $Snap)
(assert (= $t@823@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_1_0), Thread_0())
; [eval] typeof(threadingVar_1_0)
; [eval] Thread_0()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod_0(threadingVar_1_0) == printZero_threading()
(declare-const $t@824@01 $Snap)
(assert (= $t@824@01 $Snap.unit))
; [eval] getMethod_0(threadingVar_1_0) == printZero_threading()
; [eval] getMethod_0(threadingVar_1_0)
; [eval] printZero_threading()
(assert (=
  (getMethod_0<ThreadingID> tmp_5@817@01)
  (as printZero_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@825@01 $Snap)
(assert (= $t@825@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start_0(threadingVar_1_0), write)
(declare-const $t@826@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t_0_0 := threadingVar_1_0
; [exec]
; inhale true
(declare-const $t@827@01 $Snap)
(assert (= $t@827@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; tmp_6 := new()
(declare-const tmp_6@828@01 $Ref)
(assert (not (= tmp_6@828@01 $Ref.null)))
(assert (not (= tmp_6@828@01 tmp_6@803@01)))
(assert (not (= tmp_6@828@01 _cthread_167_0@773@01)))
(assert (not (= tmp_6@828@01 threadingVar_2@792@01)))
(assert (not (= tmp_6@828@01 threadingVar_2_0@793@01)))
(assert (not (= tmp_6@828@01 _cthread_167@772@01)))
(assert (not (= tmp_6@828@01 secret_0@778@01)))
(assert (not (= tmp_6@828@01 secret_0_0@779@01)))
(assert (not (= tmp_6@828@01 tmp_5@817@01)))
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not p3_4@815@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1323 | p3_4@815@01 | dead]
; [else-branch: 1323 | !(p3_4@815@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 1323 | !(p3_4@815@01)]
(assert (not p3_4@815@01))
(pop) ; 9
; [eval] !p3_4
(push) ; 9
(set-option :timeout 10)
(assert (not p3_4@815@01))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not p3_4@815@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1324 | !(p3_4@815@01) | live]
; [else-branch: 1324 | p3_4@815@01 | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 1324 | !(p3_4@815@01)]
(assert (not p3_4@815@01))
(push) ; 10
(set-option :timeout 10)
(assert (not (not p4_4@816@01)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1325 | p4_4@816@01 | dead]
; [else-branch: 1325 | !(p4_4@816@01) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 1325 | !(p4_4@816@01)]
(assert (not p4_4@816@01))
(pop) ; 10
; [eval] !p4_4
(push) ; 10
(set-option :timeout 10)
(assert (not p4_4@816@01))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not p4_4@816@01)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1326 | !(p4_4@816@01) | live]
; [else-branch: 1326 | p4_4@816@01 | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 1326 | !(p4_4@816@01)]
(assert (not p4_4@816@01))
; [then-branch: 1327 | p3_4@815@01 | dead]
; [else-branch: 1327 | !(p3_4@815@01) | live]
(push) ; 11
; [else-branch: 1327 | !(p3_4@815@01)]
(pop) ; 11
; [eval] !p3_4
(push) ; 11
(set-option :timeout 10)
(assert (not p3_4@815@01))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1328 | !(p3_4@815@01) | live]
; [else-branch: 1328 | p3_4@815@01 | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 1328 | !(p3_4@815@01)]
; [then-branch: 1329 | p4_4@816@01 | dead]
; [else-branch: 1329 | !(p4_4@816@01) | live]
(push) ; 12
; [else-branch: 1329 | !(p4_4@816@01)]
(pop) ; 12
; [eval] !p4_4
(push) ; 12
(set-option :timeout 10)
(assert (not p4_4@816@01))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1330 | !(p4_4@816@01) | live]
; [else-branch: 1330 | p4_4@816@01 | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 1330 | !(p4_4@816@01)]
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1331 | p1_11@770@01 | live]
; [else-branch: 1331 | !(p1_11@770@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 1331 | p1_11@770@01]
; [exec]
; exhale acc(_thread_start(_checkDefined(t_0, 3170164)), write)
; [eval] _checkDefined(t_0, 3170164)
(push) ; 14
; [eval] _isDefined(id)
(push) ; 15
(pop) ; 15
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_5@817@01 3170164))
(pop) ; 14
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_5@817@01 3170164))
(push) ; 14
(set-option :timeout 10)
(assert (not (= tmp_5@817@01 (_checkDefined $Snap.unit tmp_5@817@01 3170164))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1332 | p2_11@771@01 | live]
; [else-branch: 1332 | !(p2_11@771@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1332 | p2_11@771@01]
; [exec]
; exhale acc(_thread_start_0(t_0_0), write)
; [exec]
; assert (p1_11 ==>
;   false ||
;   (getMethod(_checkDefined(t_0, 3170164)) == printZero_threading() ||
;   getMethod(_checkDefined(t_0, 3170164)) == printOne_threading())) &&
;   (p2_11 ==>
;   false ||
;   (getMethod_0(t_0_0) == printZero_threading() ||
;   getMethod_0(t_0_0) == printOne_threading()))
; [eval] p1_11 ==> false || (getMethod(_checkDefined(t_0, 3170164)) == printZero_threading() || getMethod(_checkDefined(t_0, 3170164)) == printOne_threading())
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1333 | p1_11@770@01 | live]
; [else-branch: 1333 | !(p1_11@770@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 1333 | p1_11@770@01]
; [eval] false || (getMethod(_checkDefined(t_0, 3170164)) == printZero_threading() || getMethod(_checkDefined(t_0, 3170164)) == printOne_threading())
(push) ; 17
; [then-branch: 1334 | False | live]
; [else-branch: 1334 | True | live]
(push) ; 18
; [then-branch: 1334 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 1334 | True]
; [eval] getMethod(_checkDefined(t_0, 3170164)) == printZero_threading()
; [eval] getMethod(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 19
; [eval] _isDefined(id)
(push) ; 20
(pop) ; 20
; Joined path conditions
(pop) ; 19
; Joined path conditions
; [eval] printZero_threading()
(push) ; 19
; [then-branch: 1335 | getMethod[ThreadingID](_checkDefined(_, tmp_5@817@01, 3170164)) == printZero_threading[ThreadingID] | live]
; [else-branch: 1335 | getMethod[ThreadingID](_checkDefined(_, tmp_5@817@01, 3170164)) != printZero_threading[ThreadingID] | live]
(push) ; 20
; [then-branch: 1335 | getMethod[ThreadingID](_checkDefined(_, tmp_5@817@01, 3170164)) == printZero_threading[ThreadingID]]
(assert (=
  (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
  (as printZero_threading<ThreadingID>  ThreadingID)))
(pop) ; 20
(push) ; 20
; [else-branch: 1335 | getMethod[ThreadingID](_checkDefined(_, tmp_5@817@01, 3170164)) != printZero_threading[ThreadingID]]
(assert (not
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
    (as printZero_threading<ThreadingID>  ThreadingID))))
; [eval] getMethod(_checkDefined(t_0, 3170164)) == printOne_threading()
; [eval] getMethod(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 21
; [eval] _isDefined(id)
(push) ; 22
(pop) ; 22
; Joined path conditions
(pop) ; 21
; Joined path conditions
; [eval] printOne_threading()
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
    (as printZero_threading<ThreadingID>  ThreadingID))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
    (as printZero_threading<ThreadingID>  ThreadingID))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (=>
  p1_11@770@01
  (or
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
        (as printZero_threading<ThreadingID>  ThreadingID)))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID)))))
(push) ; 15
(assert (not (=>
  p1_11@770@01
  (or
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printOne_threading<ThreadingID>  ThreadingID))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_11@770@01
  (or
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printOne_threading<ThreadingID>  ThreadingID)))))
; [eval] p2_11 ==> false || (getMethod_0(t_0_0) == printZero_threading() || getMethod_0(t_0_0) == printOne_threading())
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1336 | p2_11@771@01 | live]
; [else-branch: 1336 | !(p2_11@771@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 1336 | p2_11@771@01]
; [eval] false || (getMethod_0(t_0_0) == printZero_threading() || getMethod_0(t_0_0) == printOne_threading())
(push) ; 17
; [then-branch: 1337 | False | live]
; [else-branch: 1337 | True | live]
(push) ; 18
; [then-branch: 1337 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 1337 | True]
; [eval] getMethod_0(t_0_0) == printZero_threading()
; [eval] getMethod_0(t_0_0)
; [eval] printZero_threading()
(push) ; 19
; [then-branch: 1338 | getMethod_0[ThreadingID](tmp_5@817@01) == printZero_threading[ThreadingID] | live]
; [else-branch: 1338 | getMethod_0[ThreadingID](tmp_5@817@01) != printZero_threading[ThreadingID] | live]
(push) ; 20
; [then-branch: 1338 | getMethod_0[ThreadingID](tmp_5@817@01) == printZero_threading[ThreadingID]]
(pop) ; 20
(push) ; 20
; [else-branch: 1338 | getMethod_0[ThreadingID](tmp_5@817@01) != printZero_threading[ThreadingID]]
(assert (not
  (=
    (getMethod_0<ThreadingID> tmp_5@817@01)
    (as printZero_threading<ThreadingID>  ThreadingID))))
; [eval] getMethod_0(t_0_0) == printOne_threading()
; [eval] getMethod_0(t_0_0)
; [eval] printOne_threading()
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod_0<ThreadingID> tmp_5@817@01)
      (as printZero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod_0<ThreadingID> tmp_5@817@01)
    (as printZero_threading<ThreadingID>  ThreadingID))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod_0<ThreadingID> tmp_5@817@01)
      (as printZero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod_0<ThreadingID> tmp_5@817@01)
    (as printZero_threading<ThreadingID>  ThreadingID))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (=>
  p2_11@771@01
  (or
    (not
      (=
        (getMethod_0<ThreadingID> tmp_5@817@01)
        (as printZero_threading<ThreadingID>  ThreadingID)))
    (=
      (getMethod_0<ThreadingID> tmp_5@817@01)
      (as printZero_threading<ThreadingID>  ThreadingID)))))
(push) ; 15
(assert (not (=>
  p2_11@771@01
  (or
    (=
      (getMethod_0<ThreadingID> tmp_5@817@01)
      (as printZero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod_0<ThreadingID> tmp_5@817@01)
      (as printOne_threading<ThreadingID>  ThreadingID))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_11@771@01
  (or
    (=
      (getMethod_0<ThreadingID> tmp_5@817@01)
      (as printZero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod_0<ThreadingID> tmp_5@817@01)
      (as printOne_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p1_13 := p1_11 &&
;   getMethod(_checkDefined(t_0, 3170164)) == printZero_threading()
; [eval] p1_11 && getMethod(_checkDefined(t_0, 3170164)) == printZero_threading()
(push) ; 15
; [then-branch: 1339 | !(p1_11@770@01) | live]
; [else-branch: 1339 | p1_11@770@01 | live]
(push) ; 16
; [then-branch: 1339 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 16
(push) ; 16
; [else-branch: 1339 | p1_11@770@01]
; [eval] getMethod(_checkDefined(t_0, 3170164)) == printZero_threading()
; [eval] getMethod(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 17
; [eval] _isDefined(id)
(push) ; 18
(pop) ; 18
; Joined path conditions
(pop) ; 17
; Joined path conditions
; [eval] printZero_threading()
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(declare-const p1_13@829@01 Bool)
(assert (=
  p1_13@829@01
  (and
    p1_11@770@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_13 := p2_11 && getMethod_0(t_0_0) == printZero_threading()
; [eval] p2_11 && getMethod_0(t_0_0) == printZero_threading()
(push) ; 15
; [then-branch: 1340 | !(p2_11@771@01) | live]
; [else-branch: 1340 | p2_11@771@01 | live]
(push) ; 16
; [then-branch: 1340 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 16
(push) ; 16
; [else-branch: 1340 | p2_11@771@01]
; [eval] getMethod_0(t_0_0) == printZero_threading()
; [eval] getMethod_0(t_0_0)
; [eval] printZero_threading()
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(declare-const p2_13@830@01 Bool)
(assert (=
  p2_13@830@01
  (and
    p2_11@771@01
    (=
      (getMethod_0<ThreadingID> tmp_5@817@01)
      (as printZero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_5 := p1_11 &&
;   !(getMethod(_checkDefined(t_0, 3170164)) == printZero_threading())
; [eval] p1_11 && !(getMethod(_checkDefined(t_0, 3170164)) == printZero_threading())
(push) ; 15
; [then-branch: 1341 | !(p1_11@770@01) | live]
; [else-branch: 1341 | p1_11@770@01 | live]
(push) ; 16
; [then-branch: 1341 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 16
(push) ; 16
; [else-branch: 1341 | p1_11@770@01]
; [eval] !(getMethod(_checkDefined(t_0, 3170164)) == printZero_threading())
; [eval] getMethod(_checkDefined(t_0, 3170164)) == printZero_threading()
; [eval] getMethod(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 17
; [eval] _isDefined(id)
(push) ; 18
(pop) ; 18
; Joined path conditions
(pop) ; 17
; Joined path conditions
; [eval] printZero_threading()
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(declare-const p3_5@831@01 Bool)
(assert (=
  p3_5@831@01
  (and
    p1_11@770@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
        (as printZero_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_5 := p2_11 && !(getMethod_0(t_0_0) == printZero_threading())
; [eval] p2_11 && !(getMethod_0(t_0_0) == printZero_threading())
(push) ; 15
; [then-branch: 1342 | !(p2_11@771@01) | live]
; [else-branch: 1342 | p2_11@771@01 | live]
(push) ; 16
; [then-branch: 1342 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 16
(push) ; 16
; [else-branch: 1342 | p2_11@771@01]
; [eval] !(getMethod_0(t_0_0) == printZero_threading())
; [eval] getMethod_0(t_0_0) == printZero_threading()
; [eval] getMethod_0(t_0_0)
; [eval] printZero_threading()
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(declare-const p4_5@832@01 Bool)
(assert (=
  p4_5@832@01
  (and
    p2_11@771@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_5@817@01)
        (as printZero_threading<ThreadingID>  ThreadingID))))))
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_13@829@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not p1_13@829@01))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1343 | p1_13@829@01 | live]
; [else-branch: 1343 | !(p1_13@829@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1343 | p1_13@829@01]
(assert p1_13@829@01)
; [exec]
; inhale true
(declare-const $t@833@01 $Snap)
(assert (= $t@833@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_13@830@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not p2_13@830@01))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1344 | p2_13@830@01 | live]
; [else-branch: 1344 | !(p2_13@830@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 1344 | p2_13@830@01]
(assert p2_13@830@01)
; [exec]
; inhale true
(declare-const $t@834@01 $Snap)
(assert (= $t@834@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; exhale (p1_13 ==> true) && ((p2_13 ==> true) && p1_13 == p2_13)
; [eval] p1_13 ==> true
(set-option :timeout 0)
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p1_13@829@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1345 | p1_13@829@01 | live]
; [else-branch: 1345 | !(p1_13@829@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 1345 | p1_13@829@01]
(pop) ; 18
(pop) ; 17
; Joined path conditions
; [eval] p2_13 ==> true
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p2_13@830@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1346 | p2_13@830@01 | live]
; [else-branch: 1346 | !(p2_13@830@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 1346 | p2_13@830@01]
(pop) ; 18
(pop) ; 17
; Joined path conditions
; [eval] p1_13 == p2_13
(push) ; 17
(assert (not (= p1_13@829@01 p2_13@830@01)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (= p1_13@829@01 p2_13@830@01))
(push) ; 17
(set-option :timeout 10)
(assert (not (not p1_13@829@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1347 | p1_13@829@01 | live]
; [else-branch: 1347 | !(p1_13@829@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 1347 | p1_13@829@01]
; [exec]
; inhale false ==>
;   _joinable(_checkDefined(t_0, 3170164)) &&
;   acc(_thread_post(_checkDefined(t_0, 3170164)), write)
; [then-branch: 1348 | False | dead]
; [else-branch: 1348 | True | live]
(push) ; 18
; [else-branch: 1348 | True]
(declare-const $t@835@01 $Snap)
(assert (= $t@835@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (not p2_13@830@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1349 | p2_13@830@01 | live]
; [else-branch: 1349 | !(p2_13@830@01) | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 1349 | p2_13@830@01]
; [exec]
; inhale false ==> _joinable(t_0_0) && acc(_thread_post_0(t_0_0), write)
; [then-branch: 1350 | False | dead]
; [else-branch: 1350 | True | live]
(push) ; 20
; [else-branch: 1350 | True]
(declare-const $t@836@01 $Snap)
(assert (= $t@836@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; p1_14 := p1_11 &&
;   getMethod(_checkDefined(t_0, 3170164)) == printOne_threading()
; [eval] p1_11 && getMethod(_checkDefined(t_0, 3170164)) == printOne_threading()
(set-option :timeout 0)
(push) ; 21
; [then-branch: 1351 | !(p1_11@770@01) | live]
; [else-branch: 1351 | p1_11@770@01 | live]
(push) ; 22
; [then-branch: 1351 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 22
(push) ; 22
; [else-branch: 1351 | p1_11@770@01]
; [eval] getMethod(_checkDefined(t_0, 3170164)) == printOne_threading()
; [eval] getMethod(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 23
; [eval] _isDefined(id)
(push) ; 24
(pop) ; 24
; Joined path conditions
(pop) ; 23
; Joined path conditions
; [eval] printOne_threading()
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(declare-const p1_14@837@01 Bool)
(assert (=
  p1_14@837@01
  (and
    p1_11@770@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printOne_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_14 := p2_11 && getMethod_0(t_0_0) == printOne_threading()
; [eval] p2_11 && getMethod_0(t_0_0) == printOne_threading()
(push) ; 21
; [then-branch: 1352 | !(p2_11@771@01) | live]
; [else-branch: 1352 | p2_11@771@01 | live]
(push) ; 22
; [then-branch: 1352 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 22
(push) ; 22
; [else-branch: 1352 | p2_11@771@01]
; [eval] getMethod_0(t_0_0) == printOne_threading()
; [eval] getMethod_0(t_0_0)
; [eval] printOne_threading()
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(declare-const p2_14@838@01 Bool)
(assert (=
  p2_14@838@01
  (and
    p2_11@771@01
    (=
      (getMethod_0<ThreadingID> tmp_5@817@01)
      (as printOne_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_6 := p1_11 &&
;   !(getMethod(_checkDefined(t_0, 3170164)) == printOne_threading())
; [eval] p1_11 && !(getMethod(_checkDefined(t_0, 3170164)) == printOne_threading())
(push) ; 21
; [then-branch: 1353 | !(p1_11@770@01) | live]
; [else-branch: 1353 | p1_11@770@01 | live]
(push) ; 22
; [then-branch: 1353 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 22
(push) ; 22
; [else-branch: 1353 | p1_11@770@01]
; [eval] !(getMethod(_checkDefined(t_0, 3170164)) == printOne_threading())
; [eval] getMethod(_checkDefined(t_0, 3170164)) == printOne_threading()
; [eval] getMethod(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 23
; [eval] _isDefined(id)
(push) ; 24
(pop) ; 24
; Joined path conditions
(pop) ; 23
; Joined path conditions
; [eval] printOne_threading()
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(declare-const p3_6@839@01 Bool)
(assert (=
  p3_6@839@01
  (and
    p1_11@770@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
        (as printOne_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_6 := p2_11 && !(getMethod_0(t_0_0) == printOne_threading())
; [eval] p2_11 && !(getMethod_0(t_0_0) == printOne_threading())
(push) ; 21
; [then-branch: 1354 | !(p2_11@771@01) | live]
; [else-branch: 1354 | p2_11@771@01 | live]
(push) ; 22
; [then-branch: 1354 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 22
(push) ; 22
; [else-branch: 1354 | p2_11@771@01]
; [eval] !(getMethod_0(t_0_0) == printOne_threading())
; [eval] getMethod_0(t_0_0) == printOne_threading()
; [eval] getMethod_0(t_0_0)
; [eval] printOne_threading()
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(declare-const p4_6@840@01 Bool)
(assert (=
  p4_6@840@01
  (and
    p2_11@771@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_5@817@01)
        (as printOne_threading<ThreadingID>  ThreadingID))))))
(push) ; 21
(set-option :timeout 10)
(assert (not (not p1_14@837@01)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1355 | p1_14@837@01 | dead]
; [else-branch: 1355 | !(p1_14@837@01) | live]
(set-option :timeout 0)
(push) ; 21
; [else-branch: 1355 | !(p1_14@837@01)]
(assert (not p1_14@837@01))
(pop) ; 21
; [eval] !p1_14
(push) ; 21
(set-option :timeout 10)
(assert (not p1_14@837@01))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not p1_14@837@01)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1356 | !(p1_14@837@01) | live]
; [else-branch: 1356 | p1_14@837@01 | dead]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 1356 | !(p1_14@837@01)]
(assert (not p1_14@837@01))
(push) ; 22
(set-option :timeout 10)
(assert (not (not p2_14@838@01)))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1357 | p2_14@838@01 | dead]
; [else-branch: 1357 | !(p2_14@838@01) | live]
(set-option :timeout 0)
(push) ; 22
; [else-branch: 1357 | !(p2_14@838@01)]
(assert (not p2_14@838@01))
(pop) ; 22
; [eval] !p2_14
(push) ; 22
(set-option :timeout 10)
(assert (not p2_14@838@01))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not (not p2_14@838@01)))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1358 | !(p2_14@838@01) | live]
; [else-branch: 1358 | p2_14@838@01 | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 1358 | !(p2_14@838@01)]
(assert (not p2_14@838@01))
; [exec]
; exhale (p1_14 ==> true) && ((p2_14 ==> true) && p1_14 == p2_14)
; [eval] p1_14 ==> true
(push) ; 23
; [then-branch: 1359 | p1_14@837@01 | dead]
; [else-branch: 1359 | !(p1_14@837@01) | live]
(push) ; 24
; [else-branch: 1359 | !(p1_14@837@01)]
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p2_14 ==> true
(push) ; 23
; [then-branch: 1360 | p2_14@838@01 | dead]
; [else-branch: 1360 | !(p2_14@838@01) | live]
(push) ; 24
; [else-branch: 1360 | !(p2_14@838@01)]
(pop) ; 24
(pop) ; 23
; Joined path conditions
; [eval] p1_14 == p2_14
(push) ; 23
(assert (not (= p1_14@837@01 p2_14@838@01)))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (= p1_14@837@01 p2_14@838@01))
; [then-branch: 1361 | p1_14@837@01 | dead]
; [else-branch: 1361 | !(p1_14@837@01) | live]
(push) ; 23
; [else-branch: 1361 | !(p1_14@837@01)]
(pop) ; 23
; [eval] !p1_14
(push) ; 23
(set-option :timeout 10)
(assert (not p1_14@837@01))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1362 | !(p1_14@837@01) | live]
; [else-branch: 1362 | p1_14@837@01 | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 1362 | !(p1_14@837@01)]
; [then-branch: 1363 | p2_14@838@01 | dead]
; [else-branch: 1363 | !(p2_14@838@01) | live]
(push) ; 24
; [else-branch: 1363 | !(p2_14@838@01)]
(pop) ; 24
; [eval] !p2_14
(push) ; 24
(set-option :timeout 10)
(assert (not p2_14@838@01))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1364 | !(p2_14@838@01) | live]
; [else-branch: 1364 | p2_14@838@01 | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 1364 | !(p2_14@838@01)]
(push) ; 25
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1365 | p1_11@770@01 | live]
; [else-branch: 1365 | !(p1_11@770@01) | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 1365 | p1_11@770@01]
; [exec]
; inhale (forperm
;     _r_25: Ref [_r_25.MustReleaseBounded] :: Level(_r_25) <
;     Level(_checkDefined(t_0, 3170164))) &&
;   ((forperm
;     _r_25: Ref [_r_25.MustReleaseUnbounded] :: Level(_r_25) <
;     Level(_checkDefined(t_0, 3170164))) &&
;   _residue_167 < Level(_checkDefined(t_0, 3170164)))
(declare-const $t@841@01 $Snap)
(assert (= $t@841@01 ($Snap.combine ($Snap.first $t@841@01) ($Snap.second $t@841@01))))
(assert (= ($Snap.first $t@841@01) $Snap.unit))
; [eval] (forperm _r_25: Ref [_r_25.MustReleaseBounded] :: Level(_r_25) < Level(_checkDefined(t_0, 3170164)))
(assert (=
  ($Snap.second $t@841@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@841@01))
    ($Snap.second ($Snap.second $t@841@01)))))
(assert (= ($Snap.first ($Snap.second $t@841@01)) $Snap.unit))
; [eval] (forperm _r_25: Ref [_r_25.MustReleaseUnbounded] :: Level(_r_25) < Level(_checkDefined(t_0, 3170164)))
(assert (= ($Snap.second ($Snap.second $t@841@01)) $Snap.unit))
; [eval] _residue_167 < Level(_checkDefined(t_0, 3170164))
; [eval] Level(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 26
; [eval] _isDefined(id)
(push) ; 27
(pop) ; 27
; Joined path conditions
(pop) ; 26
; Joined path conditions
(push) ; 26
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_5@817@01 3170164)))
(pop) ; 26
; Joined path conditions
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_5@817@01 3170164)))
(assert (<
  _residue_167@776@01
  (Level $Snap.unit (_checkDefined $Snap.unit tmp_5@817@01 3170164))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1366 | p2_11@771@01 | live]
; [else-branch: 1366 | !(p2_11@771@01) | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 1366 | p2_11@771@01]
; [exec]
; inhale (forperm
;     _r_25: Ref [_r_25.MustReleaseBoundedp] :: Level(_r_25) < Level(t_0_0)) &&
;   ((forperm
;     _r_25: Ref [_r_25.MustReleaseUnboundedp] :: Level(_r_25) < Level(t_0_0)) &&
;   _residue_167_0 < Level(t_0_0))
(declare-const $t@842@01 $Snap)
(assert (= $t@842@01 ($Snap.combine ($Snap.first $t@842@01) ($Snap.second $t@842@01))))
(assert (= ($Snap.first $t@842@01) $Snap.unit))
; [eval] (forperm _r_25: Ref [_r_25.MustReleaseBoundedp] :: Level(_r_25) < Level(t_0_0))
(assert (=
  ($Snap.second $t@842@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@842@01))
    ($Snap.second ($Snap.second $t@842@01)))))
(assert (= ($Snap.first ($Snap.second $t@842@01)) $Snap.unit))
; [eval] (forperm _r_25: Ref [_r_25.MustReleaseUnboundedp] :: Level(_r_25) < Level(t_0_0))
(assert (= ($Snap.second ($Snap.second $t@842@01)) $Snap.unit))
; [eval] _residue_167_0 < Level(t_0_0)
; [eval] Level(t_0_0)
(push) ; 27
(assert (Level%precondition $Snap.unit tmp_5@817@01))
(pop) ; 27
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_5@817@01))
(assert (< _residue_167_0@777@01 (Level $Snap.unit tmp_5@817@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert true
; [eval] p1_11 ==> true
(set-option :timeout 0)
(push) ; 27
(push) ; 28
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1367 | p1_11@770@01 | live]
; [else-branch: 1367 | !(p1_11@770@01) | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 1367 | p1_11@770@01]
(pop) ; 28
(pop) ; 27
; Joined path conditions
; [eval] p2_11 ==> true
(push) ; 27
(push) ; 28
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1368 | p2_11@771@01 | live]
; [else-branch: 1368 | !(p2_11@771@01) | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 1368 | p2_11@771@01]
(pop) ; 28
(pop) ; 27
; Joined path conditions
; [eval] p1_11 ==> (forperm _r_27: Ref [MustInvokeBounded(_r_27)] :: false) && ((forperm _r_27: Ref [MustInvokeUnbounded(_r_27)] :: false) && ((forperm _r_27: Ref [_r_27.MustReleaseBounded] :: false) && (forperm _r_27: Ref [_r_27.MustReleaseUnbounded] :: false)))
(push) ; 27
(push) ; 28
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1369 | p1_11@770@01 | live]
; [else-branch: 1369 | !(p1_11@770@01) | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 1369 | p1_11@770@01]
; [eval] (forperm _r_27: Ref [MustInvokeBounded(_r_27)] :: false) && ((forperm _r_27: Ref [MustInvokeUnbounded(_r_27)] :: false) && ((forperm _r_27: Ref [_r_27.MustReleaseBounded] :: false) && (forperm _r_27: Ref [_r_27.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_27: Ref [MustInvokeBounded(_r_27)] :: false)
(push) ; 29
; [then-branch: 1370 | False | live]
; [else-branch: 1370 | True | live]
(push) ; 30
; [then-branch: 1370 | False]
(assert false)
(pop) ; 30
(push) ; 30
; [else-branch: 1370 | True]
; [eval] (forperm _r_27: Ref [MustInvokeUnbounded(_r_27)] :: false)
(push) ; 31
; [then-branch: 1371 | False | live]
; [else-branch: 1371 | True | live]
(push) ; 32
; [then-branch: 1371 | False]
(assert false)
(pop) ; 32
(push) ; 32
; [else-branch: 1371 | True]
; [eval] (forperm _r_27: Ref [_r_27.MustReleaseBounded] :: false)
(push) ; 33
; [then-branch: 1372 | False | live]
; [else-branch: 1372 | True | live]
(push) ; 34
; [then-branch: 1372 | False]
(assert false)
(pop) ; 34
(push) ; 34
; [else-branch: 1372 | True]
; [eval] (forperm _r_27: Ref [_r_27.MustReleaseUnbounded] :: false)
(pop) ; 34
(pop) ; 33
; Joined path conditions
; Joined path conditions
(pop) ; 32
(pop) ; 31
; Joined path conditions
; Joined path conditions
(pop) ; 30
(pop) ; 29
; Joined path conditions
; Joined path conditions
(pop) ; 28
(pop) ; 27
; Joined path conditions
; [eval] p2_11 ==> (forperm _r_27: Ref [MustInvokeBounded_0(_r_27)] :: false) && ((forperm _r_27: Ref [MustInvokeUnbounded_0(_r_27)] :: false) && ((forperm _r_27: Ref [_r_27.MustReleaseBoundedp] :: false) && (forperm _r_27: Ref [_r_27.MustReleaseUnboundedp] :: false)))
(push) ; 27
(push) ; 28
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1373 | p2_11@771@01 | live]
; [else-branch: 1373 | !(p2_11@771@01) | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 1373 | p2_11@771@01]
; [eval] (forperm _r_27: Ref [MustInvokeBounded_0(_r_27)] :: false) && ((forperm _r_27: Ref [MustInvokeUnbounded_0(_r_27)] :: false) && ((forperm _r_27: Ref [_r_27.MustReleaseBoundedp] :: false) && (forperm _r_27: Ref [_r_27.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_27: Ref [MustInvokeBounded_0(_r_27)] :: false)
(push) ; 29
; [then-branch: 1374 | False | live]
; [else-branch: 1374 | True | live]
(push) ; 30
; [then-branch: 1374 | False]
(assert false)
(pop) ; 30
(push) ; 30
; [else-branch: 1374 | True]
; [eval] (forperm _r_27: Ref [MustInvokeUnbounded_0(_r_27)] :: false)
(push) ; 31
; [then-branch: 1375 | False | live]
; [else-branch: 1375 | True | live]
(push) ; 32
; [then-branch: 1375 | False]
(assert false)
(pop) ; 32
(push) ; 32
; [else-branch: 1375 | True]
; [eval] (forperm _r_27: Ref [_r_27.MustReleaseBoundedp] :: false)
(push) ; 33
; [then-branch: 1376 | False | live]
; [else-branch: 1376 | True | live]
(push) ; 34
; [then-branch: 1376 | False]
(assert false)
(pop) ; 34
(push) ; 34
; [else-branch: 1376 | True]
; [eval] (forperm _r_27: Ref [_r_27.MustReleaseUnboundedp] :: false)
(pop) ; 34
(pop) ; 33
; Joined path conditions
; Joined path conditions
(pop) ; 32
(pop) ; 31
; Joined path conditions
; Joined path conditions
(pop) ; 30
(pop) ; 29
; Joined path conditions
; Joined path conditions
(pop) ; 28
(pop) ; 27
; Joined path conditions
(pop) ; 26
; [eval] !p2_11
; [then-branch: 1377 | !(p2_11@771@01) | dead]
; [else-branch: 1377 | p2_11@771@01 | live]
(push) ; 26
; [else-branch: 1377 | p2_11@771@01]
(pop) ; 26
(pop) ; 25
; [eval] !p1_11
; [then-branch: 1378 | !(p1_11@770@01) | dead]
; [else-branch: 1378 | p1_11@770@01 | live]
(push) ; 25
; [else-branch: 1378 | p1_11@770@01]
(pop) ; 25
(pop) ; 24
(pop) ; 23
(pop) ; 22
(pop) ; 21
(pop) ; 20
(pop) ; 19
; [eval] !p2_13
; [then-branch: 1379 | !(p2_13@830@01) | dead]
; [else-branch: 1379 | p2_13@830@01 | live]
(push) ; 19
; [else-branch: 1379 | p2_13@830@01]
(pop) ; 19
(pop) ; 18
(pop) ; 17
; [eval] !p1_13
; [then-branch: 1380 | !(p1_13@829@01) | dead]
; [else-branch: 1380 | p1_13@829@01 | live]
(push) ; 17
; [else-branch: 1380 | p1_13@829@01]
(pop) ; 17
(pop) ; 16
; [eval] !p2_13
(push) ; 16
(set-option :timeout 10)
(assert (not p2_13@830@01))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1381 | !(p2_13@830@01) | dead]
; [else-branch: 1381 | p2_13@830@01 | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 1381 | p2_13@830@01]
(assert p2_13@830@01)
(pop) ; 16
(pop) ; 15
; [eval] !p1_13
(push) ; 15
(set-option :timeout 10)
(assert (not p1_13@829@01))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1382 | !(p1_13@829@01) | dead]
; [else-branch: 1382 | p1_13@829@01 | live]
(set-option :timeout 0)
(push) ; 15
; [else-branch: 1382 | p1_13@829@01]
(assert p1_13@829@01)
(pop) ; 15
(pop) ; 14
; [eval] !p2_11
; [then-branch: 1383 | !(p2_11@771@01) | dead]
; [else-branch: 1383 | p2_11@771@01 | live]
(push) ; 14
; [else-branch: 1383 | p2_11@771@01]
(pop) ; 14
(pop) ; 13
; [eval] !p1_11
; [then-branch: 1384 | !(p1_11@770@01) | dead]
; [else-branch: 1384 | p1_11@770@01 | live]
(push) ; 13
; [else-branch: 1384 | p1_11@770@01]
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
; [eval] !p2_12
; [then-branch: 1385 | !(p2_12@814@01) | dead]
; [else-branch: 1385 | p2_12@814@01 | live]
(push) ; 8
; [else-branch: 1385 | p2_12@814@01]
(pop) ; 8
(pop) ; 7
; [eval] !p1_12
; [then-branch: 1386 | !(p1_12@813@01) | dead]
; [else-branch: 1386 | p1_12@813@01 | live]
(push) ; 7
; [else-branch: 1386 | p1_12@813@01]
(pop) ; 7
(pop) ; 6
(push) ; 6
; [else-branch: 1320 | !(p2_12@814@01)]
(assert (not p2_12@814@01))
(pop) ; 6
; [eval] !p2_12
(push) ; 6
(set-option :timeout 10)
(assert (not p2_12@814@01))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_12@814@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1387 | !(p2_12@814@01) | live]
; [else-branch: 1387 | p2_12@814@01 | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1387 | !(p2_12@814@01)]
(assert (not p2_12@814@01))
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_12@813@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1388 | p1_12@813@01 | live]
; [else-branch: 1388 | !(p1_12@813@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 1388 | p1_12@813@01]
; [exec]
; inhale issubtype(typeof(threadingVar_1), Thread_0())
(declare-const $t@843@01 $Snap)
(assert (= $t@843@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_1), Thread_0())
; [eval] typeof(threadingVar_1)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_5@817@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod(threadingVar_1) == printZero_threading()
(declare-const $t@844@01 $Snap)
(assert (= $t@844@01 $Snap.unit))
; [eval] getMethod(threadingVar_1) == printZero_threading()
; [eval] getMethod(threadingVar_1)
; [eval] printZero_threading()
(assert (=
  (getMethod<ThreadingID> tmp_5@817@01)
  (as printZero_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@845@01 $Snap)
(assert (= $t@845@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start(threadingVar_1), write)
(declare-const $t@846@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t_0 := threadingVar_1
; [exec]
; inhale _isDefined(3170164)
(declare-const $t@847@01 $Snap)
(assert (= $t@847@01 $Snap.unit))
; [eval] _isDefined(3170164)
(set-option :timeout 0)
(push) ; 8
(assert (_isDefined%precondition $Snap.unit 3170164))
(pop) ; 8
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 3170164))
(assert (_isDefined $Snap.unit 3170164))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [then-branch: 1389 | p2_12@814@01 | dead]
; [else-branch: 1389 | !(p2_12@814@01) | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 1389 | !(p2_12@814@01)]
(pop) ; 8
; [eval] !p2_12
(push) ; 8
(set-option :timeout 10)
(assert (not p2_12@814@01))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1390 | !(p2_12@814@01) | live]
; [else-branch: 1390 | p2_12@814@01 | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1390 | !(p2_12@814@01)]
; [exec]
; tmp_6 := new()
(declare-const tmp_6@848@01 $Ref)
(assert (not (= tmp_6@848@01 $Ref.null)))
(assert (not (= tmp_6@848@01 tmp_6@803@01)))
(assert (not (= tmp_6@848@01 _cthread_167_0@773@01)))
(assert (not (= tmp_6@848@01 threadingVar_2@792@01)))
(assert (not (= tmp_6@848@01 threadingVar_2_0@793@01)))
(assert (not (= tmp_6@848@01 tmp_5@817@01)))
(assert (not (= tmp_6@848@01 threadingVar_1_0@791@01)))
(assert (not (= tmp_6@848@01 _cthread_167@772@01)))
(assert (not (= tmp_6@848@01 secret_0@778@01)))
(assert (not (= tmp_6@848@01 t_0_0@787@01)))
(assert (not (= tmp_6@848@01 secret_0_0@779@01)))
(push) ; 9
(set-option :timeout 10)
(assert (not (not p3_4@815@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1391 | p3_4@815@01 | dead]
; [else-branch: 1391 | !(p3_4@815@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 1391 | !(p3_4@815@01)]
(assert (not p3_4@815@01))
(pop) ; 9
; [eval] !p3_4
(push) ; 9
(set-option :timeout 10)
(assert (not p3_4@815@01))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not p3_4@815@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1392 | !(p3_4@815@01) | live]
; [else-branch: 1392 | p3_4@815@01 | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 1392 | !(p3_4@815@01)]
(assert (not p3_4@815@01))
(push) ; 10
(set-option :timeout 10)
(assert (not (not p4_4@816@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not p4_4@816@01))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1393 | p4_4@816@01 | live]
; [else-branch: 1393 | !(p4_4@816@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 1393 | p4_4@816@01]
(assert p4_4@816@01)
; [exec]
; threadingVar_2_0 := tmp_6
; [then-branch: 1394 | p3_4@815@01 | dead]
; [else-branch: 1394 | !(p3_4@815@01) | live]
(push) ; 11
; [else-branch: 1394 | !(p3_4@815@01)]
(pop) ; 11
; [eval] !p3_4
(push) ; 11
(set-option :timeout 10)
(assert (not p3_4@815@01))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1395 | !(p3_4@815@01) | live]
; [else-branch: 1395 | p3_4@815@01 | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 1395 | !(p3_4@815@01)]
(push) ; 12
(set-option :timeout 10)
(assert (not (not p4_4@816@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1396 | p4_4@816@01 | live]
; [else-branch: 1396 | !(p4_4@816@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 1396 | p4_4@816@01]
; [exec]
; inhale issubtype(typeof(threadingVar_2_0), Thread_0())
(declare-const $t@849@01 $Snap)
(assert (= $t@849@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_2_0), Thread_0())
; [eval] typeof(threadingVar_2_0)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_6@848@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod_0(threadingVar_2_0) == printOne_threading()
(declare-const $t@850@01 $Snap)
(assert (= $t@850@01 $Snap.unit))
; [eval] getMethod_0(threadingVar_2_0) == printOne_threading()
; [eval] getMethod_0(threadingVar_2_0)
; [eval] printOne_threading()
(assert (=
  (getMethod_0<ThreadingID> tmp_6@848@01)
  (as printOne_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@851@01 $Snap)
(assert (= $t@851@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start_0(threadingVar_2_0), write)
(declare-const $t@852@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t_0_0 := threadingVar_2_0
; [exec]
; inhale true
(declare-const $t@853@01 $Snap)
(assert (= $t@853@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1397 | p1_11@770@01 | live]
; [else-branch: 1397 | !(p1_11@770@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 1397 | p1_11@770@01]
; [exec]
; exhale acc(_thread_start(_checkDefined(t_0, 3170164)), write)
; [eval] _checkDefined(t_0, 3170164)
(push) ; 14
; [eval] _isDefined(id)
(push) ; 15
(pop) ; 15
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_5@817@01 3170164))
(pop) ; 14
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_5@817@01 3170164))
(push) ; 14
(set-option :timeout 10)
(assert (not (= tmp_5@817@01 (_checkDefined $Snap.unit tmp_5@817@01 3170164))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1398 | p2_11@771@01 | live]
; [else-branch: 1398 | !(p2_11@771@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1398 | p2_11@771@01]
; [exec]
; exhale acc(_thread_start_0(t_0_0), write)
; [exec]
; assert (p1_11 ==>
;   false ||
;   (getMethod(_checkDefined(t_0, 3170164)) == printZero_threading() ||
;   getMethod(_checkDefined(t_0, 3170164)) == printOne_threading())) &&
;   (p2_11 ==>
;   false ||
;   (getMethod_0(t_0_0) == printZero_threading() ||
;   getMethod_0(t_0_0) == printOne_threading()))
; [eval] p1_11 ==> false || (getMethod(_checkDefined(t_0, 3170164)) == printZero_threading() || getMethod(_checkDefined(t_0, 3170164)) == printOne_threading())
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_11@770@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1399 | p1_11@770@01 | live]
; [else-branch: 1399 | !(p1_11@770@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 1399 | p1_11@770@01]
; [eval] false || (getMethod(_checkDefined(t_0, 3170164)) == printZero_threading() || getMethod(_checkDefined(t_0, 3170164)) == printOne_threading())
(push) ; 17
; [then-branch: 1400 | False | live]
; [else-branch: 1400 | True | live]
(push) ; 18
; [then-branch: 1400 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 1400 | True]
; [eval] getMethod(_checkDefined(t_0, 3170164)) == printZero_threading()
; [eval] getMethod(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 19
; [eval] _isDefined(id)
(push) ; 20
(pop) ; 20
; Joined path conditions
(pop) ; 19
; Joined path conditions
; [eval] printZero_threading()
(push) ; 19
; [then-branch: 1401 | getMethod[ThreadingID](_checkDefined(_, tmp_5@817@01, 3170164)) == printZero_threading[ThreadingID] | live]
; [else-branch: 1401 | getMethod[ThreadingID](_checkDefined(_, tmp_5@817@01, 3170164)) != printZero_threading[ThreadingID] | live]
(push) ; 20
; [then-branch: 1401 | getMethod[ThreadingID](_checkDefined(_, tmp_5@817@01, 3170164)) == printZero_threading[ThreadingID]]
(assert (=
  (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
  (as printZero_threading<ThreadingID>  ThreadingID)))
(pop) ; 20
(push) ; 20
; [else-branch: 1401 | getMethod[ThreadingID](_checkDefined(_, tmp_5@817@01, 3170164)) != printZero_threading[ThreadingID]]
(assert (not
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
    (as printZero_threading<ThreadingID>  ThreadingID))))
; [eval] getMethod(_checkDefined(t_0, 3170164)) == printOne_threading()
; [eval] getMethod(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 21
; [eval] _isDefined(id)
(push) ; 22
(pop) ; 22
; Joined path conditions
(pop) ; 21
; Joined path conditions
; [eval] printOne_threading()
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
    (as printZero_threading<ThreadingID>  ThreadingID))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
    (as printZero_threading<ThreadingID>  ThreadingID))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (=>
  p1_11@770@01
  (or
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
        (as printZero_threading<ThreadingID>  ThreadingID)))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID)))))
(push) ; 15
(assert (not (=>
  p1_11@770@01
  (or
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printOne_threading<ThreadingID>  ThreadingID))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_11@770@01
  (or
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printOne_threading<ThreadingID>  ThreadingID)))))
; [eval] p2_11 ==> false || (getMethod_0(t_0_0) == printZero_threading() || getMethod_0(t_0_0) == printOne_threading())
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_11@771@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1402 | p2_11@771@01 | live]
; [else-branch: 1402 | !(p2_11@771@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 1402 | p2_11@771@01]
; [eval] false || (getMethod_0(t_0_0) == printZero_threading() || getMethod_0(t_0_0) == printOne_threading())
(push) ; 17
; [then-branch: 1403 | False | live]
; [else-branch: 1403 | True | live]
(push) ; 18
; [then-branch: 1403 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 1403 | True]
; [eval] getMethod_0(t_0_0) == printZero_threading()
; [eval] getMethod_0(t_0_0)
; [eval] printZero_threading()
(push) ; 19
; [then-branch: 1404 | getMethod_0[ThreadingID](tmp_6@848@01) == printZero_threading[ThreadingID] | live]
; [else-branch: 1404 | getMethod_0[ThreadingID](tmp_6@848@01) != printZero_threading[ThreadingID] | live]
(push) ; 20
; [then-branch: 1404 | getMethod_0[ThreadingID](tmp_6@848@01) == printZero_threading[ThreadingID]]
(assert (=
  (getMethod_0<ThreadingID> tmp_6@848@01)
  (as printZero_threading<ThreadingID>  ThreadingID)))
(pop) ; 20
(push) ; 20
; [else-branch: 1404 | getMethod_0[ThreadingID](tmp_6@848@01) != printZero_threading[ThreadingID]]
(assert (not
  (=
    (getMethod_0<ThreadingID> tmp_6@848@01)
    (as printZero_threading<ThreadingID>  ThreadingID))))
; [eval] getMethod_0(t_0_0) == printOne_threading()
; [eval] getMethod_0(t_0_0)
; [eval] printOne_threading()
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod_0<ThreadingID> tmp_6@848@01)
      (as printZero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod_0<ThreadingID> tmp_6@848@01)
    (as printZero_threading<ThreadingID>  ThreadingID))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod_0<ThreadingID> tmp_6@848@01)
      (as printZero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod_0<ThreadingID> tmp_6@848@01)
    (as printZero_threading<ThreadingID>  ThreadingID))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (=>
  p2_11@771@01
  (or
    (not
      (=
        (getMethod_0<ThreadingID> tmp_6@848@01)
        (as printZero_threading<ThreadingID>  ThreadingID)))
    (=
      (getMethod_0<ThreadingID> tmp_6@848@01)
      (as printZero_threading<ThreadingID>  ThreadingID)))))
(push) ; 15
(assert (not (=>
  p2_11@771@01
  (or
    (=
      (getMethod_0<ThreadingID> tmp_6@848@01)
      (as printZero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod_0<ThreadingID> tmp_6@848@01)
      (as printOne_threading<ThreadingID>  ThreadingID))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_11@771@01
  (or
    (=
      (getMethod_0<ThreadingID> tmp_6@848@01)
      (as printZero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod_0<ThreadingID> tmp_6@848@01)
      (as printOne_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p1_13 := p1_11 &&
;   getMethod(_checkDefined(t_0, 3170164)) == printZero_threading()
; [eval] p1_11 && getMethod(_checkDefined(t_0, 3170164)) == printZero_threading()
(push) ; 15
; [then-branch: 1405 | !(p1_11@770@01) | live]
; [else-branch: 1405 | p1_11@770@01 | live]
(push) ; 16
; [then-branch: 1405 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 16
(push) ; 16
; [else-branch: 1405 | p1_11@770@01]
; [eval] getMethod(_checkDefined(t_0, 3170164)) == printZero_threading()
; [eval] getMethod(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 17
; [eval] _isDefined(id)
(push) ; 18
(pop) ; 18
; Joined path conditions
(pop) ; 17
; Joined path conditions
; [eval] printZero_threading()
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(declare-const p1_13@854@01 Bool)
(assert (=
  p1_13@854@01
  (and
    p1_11@770@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
      (as printZero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_13 := p2_11 && getMethod_0(t_0_0) == printZero_threading()
; [eval] p2_11 && getMethod_0(t_0_0) == printZero_threading()
(push) ; 15
; [then-branch: 1406 | !(p2_11@771@01) | live]
; [else-branch: 1406 | p2_11@771@01 | live]
(push) ; 16
; [then-branch: 1406 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 16
(push) ; 16
; [else-branch: 1406 | p2_11@771@01]
; [eval] getMethod_0(t_0_0) == printZero_threading()
; [eval] getMethod_0(t_0_0)
; [eval] printZero_threading()
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(declare-const p2_13@855@01 Bool)
(assert (=
  p2_13@855@01
  (and
    p2_11@771@01
    (=
      (getMethod_0<ThreadingID> tmp_6@848@01)
      (as printZero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_5 := p1_11 &&
;   !(getMethod(_checkDefined(t_0, 3170164)) == printZero_threading())
; [eval] p1_11 && !(getMethod(_checkDefined(t_0, 3170164)) == printZero_threading())
(push) ; 15
; [then-branch: 1407 | !(p1_11@770@01) | live]
; [else-branch: 1407 | p1_11@770@01 | live]
(push) ; 16
; [then-branch: 1407 | !(p1_11@770@01)]
(assert (not p1_11@770@01))
(pop) ; 16
(push) ; 16
; [else-branch: 1407 | p1_11@770@01]
; [eval] !(getMethod(_checkDefined(t_0, 3170164)) == printZero_threading())
; [eval] getMethod(_checkDefined(t_0, 3170164)) == printZero_threading()
; [eval] getMethod(_checkDefined(t_0, 3170164))
; [eval] _checkDefined(t_0, 3170164)
(push) ; 17
; [eval] _isDefined(id)
(push) ; 18
(pop) ; 18
; Joined path conditions
(pop) ; 17
; Joined path conditions
; [eval] printZero_threading()
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(declare-const p3_5@856@01 Bool)
(assert (=
  p3_5@856@01
  (and
    p1_11@770@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_5@817@01 3170164))
        (as printZero_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_5 := p2_11 && !(getMethod_0(t_0_0) == printZero_threading())
; [eval] p2_11 && !(getMethod_0(t_0_0) == printZero_threading())
(push) ; 15
; [then-branch: 1408 | !(p2_11@771@01) | live]
; [else-branch: 1408 | p2_11@771@01 | live]
(push) ; 16
; [then-branch: 1408 | !(p2_11@771@01)]
(assert (not p2_11@771@01))
(pop) ; 16
(push) ; 16
; [else-branch: 1408 | p2_11@771@01]
; [eval] !(getMethod_0(t_0_0) == printZero_threading())
; [eval] getMethod_0(t_0_0) == printZero_threading()
; [eval] getMethod_0(t_0_0)
; [eval] printZero_threading()
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(declare-const p4_5@857@01 Bool)
(assert (=
  p4_5@857@01
  (and
    p2_11@771@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_6@848@01)
        (as printZero_threading<ThreadingID>  ThreadingID))))))
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_13@854@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not p1_13@854@01))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1409 | p1_13@854@01 | live]
; [else-branch: 1409 | !(p1_13@854@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1409 | p1_13@854@01]
(assert p1_13@854@01)
; [exec]
; inhale true
(declare-const $t@858@01 $Snap)
(assert (= $t@858@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_13@855@01)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1410 | p2_13@855@01 | dead]
; [else-branch: 1410 | !(p2_13@855@01) | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 1410 | !(p2_13@855@01)]
(assert (not p2_13@855@01))
(pop) ; 16
; [eval] !p2_13
(push) ; 16
(set-option :timeout 10)
(assert (not p2_13@855@01))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_13@855@01)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1411 | !(p2_13@855@01) | live]
; [else-branch: 1411 | p2_13@855@01 | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 1411 | !(p2_13@855@01)]
(assert (not p2_13@855@01))
; [exec]
; exhale (p1_13 ==> true) && ((p2_13 ==> true) && p1_13 == p2_13)
; [eval] p1_13 ==> true
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p1_13@854@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1412 | p1_13@854@01 | live]
; [else-branch: 1412 | !(p1_13@854@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 1412 | p1_13@854@01]
(pop) ; 18
(pop) ; 17
; Joined path conditions
; [eval] p2_13 ==> true
(push) ; 17
; [then-branch: 1413 | p2_13@855@01 | dead]
; [else-branch: 1413 | !(p2_13@855@01) | live]
(push) ; 18
; [else-branch: 1413 | !(p2_13@855@01)]
(pop) ; 18
(pop) ; 17
; Joined path conditions
; [eval] p1_13 == p2_13
(push) ; 17
(assert (not (= p1_13@854@01 p2_13@855@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_13 == p2_13
(set-option :timeout 0)
(push) ; 17
(assert (not (= p1_13@854@01 p2_13@855@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_13 == p2_13
(set-option :timeout 0)
(push) ; 17
(assert (not (= p1_13@854@01 p2_13@855@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_13 == p2_13
(set-option :timeout 0)
(push) ; 17
(assert (not (= p1_13@854@01 p2_13@855@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(pop) ; 16
(pop) ; 15
(pop) ; 14
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- join_low ----------
(declare-const p1_15@859@01 Bool)
(declare-const p2_15@860@01 Bool)
(declare-const _cthread_168@861@01 $Ref)
(declare-const _cthread_168_0@862@01 $Ref)
(declare-const _caller_measures_168@863@01 Seq<Measure$>)
(declare-const _caller_measures_168_0@864@01 Seq<Measure$>)
(declare-const _residue_168@865@01 $Perm)
(declare-const _residue_168_0@866@01 $Perm)
(declare-const secret_1@867@01 $Ref)
(declare-const secret_1_0@868@01 $Ref)
(declare-const _current_wait_level_168@869@01 $Perm)
(declare-const _current_wait_level_168_0@870@01 $Perm)
(declare-const p1_15@871@01 Bool)
(declare-const p2_15@872@01 Bool)
(declare-const _cthread_168@873@01 $Ref)
(declare-const _cthread_168_0@874@01 $Ref)
(declare-const _caller_measures_168@875@01 Seq<Measure$>)
(declare-const _caller_measures_168_0@876@01 Seq<Measure$>)
(declare-const _residue_168@877@01 $Perm)
(declare-const _residue_168_0@878@01 $Perm)
(declare-const secret_1@879@01 $Ref)
(declare-const secret_1_0@880@01 $Ref)
(declare-const _current_wait_level_168@881@01 $Perm)
(declare-const _current_wait_level_168_0@882@01 $Perm)
(push) ; 1
(declare-const $t@883@01 $Snap)
(assert (= $t@883@01 ($Snap.combine ($Snap.first $t@883@01) ($Snap.second $t@883@01))))
(assert (= ($Snap.first $t@883@01) $Snap.unit))
; [eval] p1_15 ==> _cthread_168 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_15@871@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1414 | p1_15@871@01 | live]
; [else-branch: 1414 | !(p1_15@871@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1414 | p1_15@871@01]
(assert p1_15@871@01)
; [eval] _cthread_168 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1414 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_15@871@01) p1_15@871@01))
(assert (=> p1_15@871@01 (not (= _cthread_168@873@01 $Ref.null))))
(assert (=
  ($Snap.second $t@883@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@883@01))
    ($Snap.second ($Snap.second $t@883@01)))))
(assert (= ($Snap.first ($Snap.second $t@883@01)) $Snap.unit))
; [eval] p2_15 ==> _cthread_168_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1415 | p2_15@872@01 | live]
; [else-branch: 1415 | !(p2_15@872@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1415 | p2_15@872@01]
(assert p2_15@872@01)
; [eval] _cthread_168_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1415 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_15@872@01) p2_15@872@01))
(assert (=> p2_15@872@01 (not (= _cthread_168_0@874@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@883@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@883@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@883@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@883@01))) $Snap.unit))
; [eval] p1_15 ==> issubtype(typeof(_cthread_168), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_15@871@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1416 | p1_15@871@01 | live]
; [else-branch: 1416 | !(p1_15@871@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1416 | p1_15@871@01]
(assert p1_15@871@01)
; [eval] issubtype(typeof(_cthread_168), Thread_0())
; [eval] typeof(_cthread_168)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1416 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_15@871@01
  (issubtype<Bool> (typeof<PyType> _cthread_168@873@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@883@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@883@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@883@01))))
  $Snap.unit))
; [eval] p2_15 ==> issubtype(typeof(_cthread_168_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1417 | p2_15@872@01 | live]
; [else-branch: 1417 | !(p2_15@872@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1417 | p2_15@872@01]
(assert p2_15@872@01)
; [eval] issubtype(typeof(_cthread_168_0), Thread_0())
; [eval] typeof(_cthread_168_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1417 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_15@872@01
  (issubtype<Bool> (typeof<PyType> _cthread_168_0@874@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01)))))
  $Snap.unit))
; [eval] p1_15 ==> issubtype(typeof(secret_1), bool())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_15@871@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1418 | p1_15@871@01 | live]
; [else-branch: 1418 | !(p1_15@871@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1418 | p1_15@871@01]
(assert p1_15@871@01)
; [eval] issubtype(typeof(secret_1), bool())
; [eval] typeof(secret_1)
; [eval] bool()
(pop) ; 3
(push) ; 3
; [else-branch: 1418 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_15@871@01
  (issubtype<Bool> (typeof<PyType> secret_1@879@01) (as bool<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01))))))
  $Snap.unit))
; [eval] p2_15 ==> issubtype(typeof(secret_1_0), bool())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1419 | p2_15@872@01 | live]
; [else-branch: 1419 | !(p2_15@872@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1419 | p2_15@872@01]
(assert p2_15@872@01)
; [eval] issubtype(typeof(secret_1_0), bool())
; [eval] typeof(secret_1_0)
; [eval] bool()
(pop) ; 3
(push) ; 3
; [else-branch: 1419 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_15@872@01
  (issubtype<Bool> (typeof<PyType> secret_1_0@880@01) (as bool<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01)))))))
  $Snap.unit))
; [eval] p1_15 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_15@871@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1420 | p1_15@871@01 | live]
; [else-branch: 1420 | !(p1_15@871@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1420 | p1_15@871@01]
(assert p1_15@871@01)
(pop) ; 3
(push) ; 3
; [else-branch: 1420 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@883@01)))))))
  $Snap.unit))
; [eval] p2_15 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1421 | p2_15@872@01 | live]
; [else-branch: 1421 | !(p2_15@872@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1421 | p2_15@872@01]
(assert p2_15@872@01)
(pop) ; 3
(push) ; 3
; [else-branch: 1421 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@884@01 $Snap)
(assert (= $t@884@01 ($Snap.combine ($Snap.first $t@884@01) ($Snap.second $t@884@01))))
(assert (= ($Snap.first $t@884@01) $Snap.unit))
; [eval] p1_15 ==> (forperm _r_31: Ref [_r_31.MustReleaseBounded] :: Level(_r_31) <= _current_wait_level_168) && ((forperm _r_31: Ref [_r_31.MustReleaseUnbounded] :: Level(_r_31) <= _current_wait_level_168) && _residue_168 <= _current_wait_level_168)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_15@871@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1422 | p1_15@871@01 | live]
; [else-branch: 1422 | !(p1_15@871@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1422 | p1_15@871@01]
(assert p1_15@871@01)
; [eval] (forperm _r_31: Ref [_r_31.MustReleaseBounded] :: Level(_r_31) <= _current_wait_level_168) && ((forperm _r_31: Ref [_r_31.MustReleaseUnbounded] :: Level(_r_31) <= _current_wait_level_168) && _residue_168 <= _current_wait_level_168)
; [eval] (forperm _r_31: Ref [_r_31.MustReleaseBounded] :: Level(_r_31) <= _current_wait_level_168)
(push) ; 5
; [then-branch: 1423 | False | live]
; [else-branch: 1423 | True | live]
(push) ; 6
; [then-branch: 1423 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 1423 | True]
; [eval] (forperm _r_31: Ref [_r_31.MustReleaseUnbounded] :: Level(_r_31) <= _current_wait_level_168)
(push) ; 7
; [then-branch: 1424 | False | live]
; [else-branch: 1424 | True | live]
(push) ; 8
; [then-branch: 1424 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1424 | True]
; [eval] _residue_168 <= _current_wait_level_168
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1422 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p1_15@871@01 (<= _residue_168@877@01 _current_wait_level_168@881@01)))
(assert (=
  ($Snap.second $t@884@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@884@01))
    ($Snap.second ($Snap.second $t@884@01)))))
(assert (= ($Snap.first ($Snap.second $t@884@01)) $Snap.unit))
; [eval] p2_15 ==> (forperm _r_31: Ref [_r_31.MustReleaseBoundedp] :: Level(_r_31) <= _current_wait_level_168_0) && ((forperm _r_31: Ref [_r_31.MustReleaseUnboundedp] :: Level(_r_31) <= _current_wait_level_168_0) && _residue_168_0 <= _current_wait_level_168_0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1425 | p2_15@872@01 | live]
; [else-branch: 1425 | !(p2_15@872@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1425 | p2_15@872@01]
(assert p2_15@872@01)
; [eval] (forperm _r_31: Ref [_r_31.MustReleaseBoundedp] :: Level(_r_31) <= _current_wait_level_168_0) && ((forperm _r_31: Ref [_r_31.MustReleaseUnboundedp] :: Level(_r_31) <= _current_wait_level_168_0) && _residue_168_0 <= _current_wait_level_168_0)
; [eval] (forperm _r_31: Ref [_r_31.MustReleaseBoundedp] :: Level(_r_31) <= _current_wait_level_168_0)
(push) ; 5
; [then-branch: 1426 | False | live]
; [else-branch: 1426 | True | live]
(push) ; 6
; [then-branch: 1426 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 1426 | True]
; [eval] (forperm _r_31: Ref [_r_31.MustReleaseUnboundedp] :: Level(_r_31) <= _current_wait_level_168_0)
(push) ; 7
; [then-branch: 1427 | False | live]
; [else-branch: 1427 | True | live]
(push) ; 8
; [then-branch: 1427 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1427 | True]
; [eval] _residue_168_0 <= _current_wait_level_168_0
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1425 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p2_15@872@01 (<= _residue_168_0@878@01 _current_wait_level_168_0@882@01)))
(assert (=
  ($Snap.second ($Snap.second $t@884@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@884@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@884@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@884@01))) $Snap.unit))
; [eval] p1_15 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_15@871@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1428 | p1_15@871@01 | live]
; [else-branch: 1428 | !(p1_15@871@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1428 | p1_15@871@01]
(assert p1_15@871@01)
(pop) ; 4
(push) ; 4
; [else-branch: 1428 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@884@01))) $Snap.unit))
; [eval] p2_15 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1429 | p2_15@872@01 | live]
; [else-branch: 1429 | !(p2_15@872@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1429 | p2_15@872@01]
(assert p2_15@872@01)
(pop) ; 4
(push) ; 4
; [else-branch: 1429 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
(push) ; 2
; [exec]
; var _err: Ref
(declare-const _err@885@01 $Ref)
; [exec]
; var _err_8: Ref
(declare-const _err_8@886@01 $Ref)
; [exec]
; var c_1: Ref
(declare-const c_1@887@01 $Ref)
; [exec]
; var c_1_0: Ref
(declare-const c_1_0@888@01 $Ref)
; [exec]
; var t_1: Ref
(declare-const t_1@889@01 $Ref)
; [exec]
; var t_1_0: Ref
(declare-const t_1_0@890@01 $Ref)
; [exec]
; var secret_5: Ref
(declare-const secret_5@891@01 $Ref)
; [exec]
; var secret_5_0: Ref
(declare-const secret_5_0@892@01 $Ref)
; [exec]
; var Cell_res_1: Ref
(declare-const Cell_res_1@893@01 $Ref)
; [exec]
; var Cell_res_1_0: Ref
(declare-const Cell_res_1_0@894@01 $Ref)
; [exec]
; var threadingVar_3: Ref
(declare-const threadingVar_3@895@01 $Ref)
; [exec]
; var threadingVar_3_0: Ref
(declare-const threadingVar_3_0@896@01 $Ref)
; [exec]
; var threadingVar_4: Ref
(declare-const threadingVar_4@897@01 $Ref)
; [exec]
; var threadingVar_4_0: Ref
(declare-const threadingVar_4_0@898@01 $Ref)
; [exec]
; var thread_arg_3: Ref
(declare-const thread_arg_3@899@01 $Ref)
; [exec]
; var thread_arg_3_0: Ref
(declare-const thread_arg_3_0@900@01 $Ref)
; [exec]
; var thread_arg_4: Ref
(declare-const thread_arg_4@901@01 $Ref)
; [exec]
; var thread_arg_4_0: Ref
(declare-const thread_arg_4_0@902@01 $Ref)
; [exec]
; var join_result: Ref
(declare-const join_result@903@01 $Ref)
; [exec]
; var join_result_1: Ref
(declare-const join_result_1@904@01 $Ref)
; [exec]
; var thread_arg_5: Ref
(declare-const thread_arg_5@905@01 $Ref)
; [exec]
; var thread_arg_5_0: Ref
(declare-const thread_arg_5_0@906@01 $Ref)
; [exec]
; var thread_arg_6: Ref
(declare-const thread_arg_6@907@01 $Ref)
; [exec]
; var thread_arg_6_0: Ref
(declare-const thread_arg_6_0@908@01 $Ref)
; [exec]
; var _cwl_168: Perm
(declare-const _cwl_168@909@01 $Perm)
; [exec]
; var _cwl_168_0: Perm
(declare-const _cwl_168_0@910@01 $Perm)
; [exec]
; var _method_measures_168: Seq[Measure$]
(declare-const _method_measures_168@911@01 Seq<Measure$>)
; [exec]
; var _method_measures_168_0: Seq[Measure$]
(declare-const _method_measures_168_0@912@01 Seq<Measure$>)
; [exec]
; var tmp_7: Ref
(declare-const tmp_7@913@01 $Ref)
; [exec]
; var p1_16: Bool
(declare-const p1_16@914@01 Bool)
; [exec]
; var p2_16: Bool
(declare-const p2_16@915@01 Bool)
; [exec]
; var p3_7: Bool
(declare-const p3_7@916@01 Bool)
; [exec]
; var p4_7: Bool
(declare-const p4_7@917@01 Bool)
; [exec]
; var tmp_8: Ref
(declare-const tmp_8@918@01 $Ref)
; [exec]
; var tmp_9: Ref
(declare-const tmp_9@919@01 $Ref)
; [exec]
; var p1_17: Bool
(declare-const p1_17@920@01 Bool)
; [exec]
; var p2_17: Bool
(declare-const p2_17@921@01 Bool)
; [exec]
; var p3_8: Bool
(declare-const p3_8@922@01 Bool)
; [exec]
; var p4_8: Bool
(declare-const p4_8@923@01 Bool)
; [exec]
; var p1_18: Bool
(declare-const p1_18@924@01 Bool)
; [exec]
; var p2_18: Bool
(declare-const p2_18@925@01 Bool)
; [exec]
; var p3_9: Bool
(declare-const p3_9@926@01 Bool)
; [exec]
; var p4_9: Bool
(declare-const p4_9@927@01 Bool)
; [exec]
; var p1_19: Bool
(declare-const p1_19@928@01 Bool)
; [exec]
; var p2_19: Bool
(declare-const p2_19@929@01 Bool)
; [exec]
; var p3_10: Bool
(declare-const p3_10@930@01 Bool)
; [exec]
; var p4_10: Bool
(declare-const p4_10@931@01 Bool)
; [exec]
; var p1_20: Bool
(declare-const p1_20@932@01 Bool)
; [exec]
; var p2_20: Bool
(declare-const p2_20@933@01 Bool)
; [exec]
; var p3_11: Bool
(declare-const p3_11@934@01 Bool)
; [exec]
; var p4_11: Bool
(declare-const p4_11@935@01 Bool)
; [exec]
; inhale p1_15
(declare-const $t@936@01 $Snap)
(assert (= $t@936@01 $Snap.unit))
(assert p1_15@871@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1430 | p1_15@871@01 | live]
; [else-branch: 1430 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1430 | p1_15@871@01]
; [exec]
; _method_measures_168 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err := null
; [exec]
; secret_5 := secret_1
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1431 | p2_15@872@01 | live]
; [else-branch: 1431 | !(p2_15@872@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1431 | p2_15@872@01]
(assert p2_15@872@01)
; [exec]
; _method_measures_168_0 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err_8 := null
; [exec]
; secret_5_0 := secret_1_0
; [exec]
; tmp_7 := new()
(declare-const tmp_7@937@01 $Ref)
(assert (not (= tmp_7@937@01 $Ref.null)))
(assert (not (= tmp_7@937@01 threadingVar_3_0@896@01)))
(assert (not (= tmp_7@937@01 join_result_1@904@01)))
(assert (not (= tmp_7@937@01 threadingVar_3@895@01)))
(assert (not (= tmp_7@937@01 Cell_res_1_0@894@01)))
(assert (not (= tmp_7@937@01 thread_arg_6@907@01)))
(assert (not (= tmp_7@937@01 threadingVar_4@897@01)))
(assert (not (= tmp_7@937@01 secret_1_0@880@01)))
(assert (not (= tmp_7@937@01 Cell_res_1@893@01)))
(assert (not (= tmp_7@937@01 c_1_0@888@01)))
(assert (not (= tmp_7@937@01 tmp_8@918@01)))
(assert (not (= tmp_7@937@01 thread_arg_6_0@908@01)))
(assert (not (= tmp_7@937@01 _cthread_168_0@874@01)))
(assert (not (= tmp_7@937@01 t_1_0@890@01)))
(assert (not (= tmp_7@937@01 thread_arg_3@899@01)))
(assert (not (= tmp_7@937@01 t_1@889@01)))
(assert (not (= tmp_7@937@01 thread_arg_5_0@906@01)))
(assert (not (= tmp_7@937@01 thread_arg_4_0@902@01)))
(assert (not (= tmp_7@937@01 join_result@903@01)))
(assert (not (= tmp_7@937@01 thread_arg_4@901@01)))
(assert (not (= tmp_7@937@01 thread_arg_5@905@01)))
(assert (not (= tmp_7@937@01 threadingVar_4_0@898@01)))
(assert (not (= tmp_7@937@01 thread_arg_3_0@900@01)))
(assert (not (= tmp_7@937@01 tmp_9@919@01)))
(assert (not (= tmp_7@937@01 c_1@887@01)))
(assert (not (= tmp_7@937@01 secret_1@879@01)))
(assert (not (= tmp_7@937@01 _cthread_168@873@01)))
(assert (not (= tmp_7@937@01 tmp_7@913@01)))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1432 | p1_15@871@01 | live]
; [else-branch: 1432 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1432 | p1_15@871@01]
; [exec]
; Cell_res_1 := tmp_7
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1433 | p2_15@872@01 | live]
; [else-branch: 1433 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1433 | p2_15@872@01]
; [exec]
; Cell_res_1_0 := tmp_7
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1434 | p1_15@871@01 | live]
; [else-branch: 1434 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 1434 | p1_15@871@01]
; [exec]
; inhale typeof(Cell_res_1) == Cell()
(declare-const $t@938@01 $Snap)
(assert (= $t@938@01 $Snap.unit))
; [eval] typeof(Cell_res_1) == Cell()
; [eval] typeof(Cell_res_1)
; [eval] Cell()
(assert (= (typeof<PyType> tmp_7@937@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_MaySet(Cell_res_1, 7809653381050164547), write)
(declare-const $t@939@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1435 | p2_15@872@01 | live]
; [else-branch: 1435 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1435 | p2_15@872@01]
; [exec]
; inhale typeof(Cell_res_1_0) == Cell()
(declare-const $t@940@01 $Snap)
(assert (= $t@940@01 $Snap.unit))
; [eval] typeof(Cell_res_1_0) == Cell()
; [eval] typeof(Cell_res_1_0)
; [eval] Cell()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_MaySet_0(Cell_res_1_0, 7809653381050164547), write)
(declare-const $t@941@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [eval] p1_15 || p2_15
(set-option :timeout 0)
(push) ; 9
; [then-branch: 1436 | p1_15@871@01 | live]
; [else-branch: 1436 | !(p1_15@871@01) | live]
(push) ; 10
; [then-branch: 1436 | p1_15@871@01]
(pop) ; 10
(push) ; 10
; [else-branch: 1436 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
(set-option :timeout 10)
(assert (not (not (or p1_15@871@01 p2_15@872@01))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (or p1_15@871@01 p2_15@872@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1437 | p1_15@871@01 || p2_15@872@01 | live]
; [else-branch: 1437 | !(p1_15@871@01 || p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 1437 | p1_15@871@01 || p2_15@872@01]
(assert (or p1_15@871@01 p2_15@872@01))
; [exec]
; var tmp1_55: Ref
(declare-const tmp1_55@942@01 $Ref)
; [exec]
; var tmp2_55: Ref
(declare-const tmp2_55@943@01 $Ref)
; [exec]
; var tmp1_56: Seq[Measure$]
(declare-const tmp1_56@944@01 Seq<Measure$>)
; [exec]
; var tmp2_56: Seq[Measure$]
(declare-const tmp2_56@945@01 Seq<Measure$>)
; [exec]
; var tmp1_57: Perm
(declare-const tmp1_57@946@01 $Perm)
; [exec]
; var tmp2_57: Perm
(declare-const tmp2_57@947@01 $Perm)
; [exec]
; var tmp1_58: Ref
(declare-const tmp1_58@948@01 $Ref)
; [exec]
; var tmp2_58: Ref
(declare-const tmp2_58@949@01 $Ref)
; [exec]
; var tmp1_59: Perm
(declare-const tmp1_59@950@01 $Perm)
; [exec]
; var tmp2_59: Perm
(declare-const tmp2_59@951@01 $Perm)
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1438 | p1_15@871@01 | live]
; [else-branch: 1438 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 1438 | p1_15@871@01]
; [exec]
; tmp1_55 := _cthread_168
; [exec]
; tmp1_56 := _method_measures_168
; [exec]
; tmp1_57 := _residue_168
; [exec]
; tmp1_58 := Cell_res_1
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1439 | p2_15@872@01 | live]
; [else-branch: 1439 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 1439 | p2_15@872@01]
; [exec]
; tmp2_55 := _cthread_168_0
; [exec]
; tmp2_56 := _method_measures_168_0
; [exec]
; tmp2_57 := _residue_168_0
; [exec]
; tmp2_58 := Cell_res_1_0
; [exec]
; tmp1_59, tmp2_59 := Cell___init__(p1_15, p2_15, tmp1_55, tmp2_55, tmp1_56, tmp2_56,
;   tmp1_57, tmp2_57, tmp1_58, tmp2_58)
; [eval] p1_25 ==> _cthread_156 != null
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1440 | p1_15@871@01 | live]
; [else-branch: 1440 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 1440 | p1_15@871@01]
; [eval] _cthread_156 != null
(pop) ; 13
(pop) ; 12
; Joined path conditions
; [eval] p2_25 ==> _cthread_156_0 != null
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1441 | p2_15@872@01 | live]
; [else-branch: 1441 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 1441 | p2_15@872@01]
; [eval] _cthread_156_0 != null
(pop) ; 13
(pop) ; 12
; Joined path conditions
; [eval] p1_25 ==> issubtype(typeof(_cthread_156), Thread_0())
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1442 | p1_15@871@01 | live]
; [else-branch: 1442 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 1442 | p1_15@871@01]
; [eval] issubtype(typeof(_cthread_156), Thread_0())
; [eval] typeof(_cthread_156)
; [eval] Thread_0()
(pop) ; 13
(pop) ; 12
; Joined path conditions
; [eval] p2_25 ==> issubtype(typeof(_cthread_156_0), Thread_0())
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1443 | p2_15@872@01 | live]
; [else-branch: 1443 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 1443 | p2_15@872@01]
; [eval] issubtype(typeof(_cthread_156_0), Thread_0())
; [eval] typeof(_cthread_156_0)
; [eval] Thread_0()
(pop) ; 13
(pop) ; 12
; Joined path conditions
; [eval] p1_25 ==> self != null
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1444 | p1_15@871@01 | live]
; [else-branch: 1444 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 1444 | p1_15@871@01]
; [eval] self != null
(pop) ; 13
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (=> p1_15@871@01 (not (= tmp_7@937@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_15@871@01 (not (= tmp_7@937@01 $Ref.null))))
; [eval] p2_25 ==> self_0 != null
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1445 | p2_15@872@01 | live]
; [else-branch: 1445 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 1445 | p2_15@872@01]
; [eval] self_0 != null
(pop) ; 13
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (=> p2_15@872@01 (not (= tmp_7@937@01 $Ref.null)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_15@872@01 (not (= tmp_7@937@01 $Ref.null))))
(push) ; 12
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1446 | p1_15@871@01 | live]
; [else-branch: 1446 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 1446 | p1_15@871@01]
(push) ; 13
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1447 | p2_15@872@01 | live]
; [else-branch: 1447 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 1447 | p2_15@872@01]
; [eval] p1_25 ==> issubtype(typeof(self), Cell())
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1448 | p1_15@871@01 | live]
; [else-branch: 1448 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1448 | p1_15@871@01]
; [eval] issubtype(typeof(self), Cell())
; [eval] typeof(self)
; [eval] Cell()
(pop) ; 15
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (=>
  p1_15@871@01
  (issubtype<Bool> (typeof<PyType> tmp_7@937@01) (as Cell<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_15@871@01
  (issubtype<Bool> (typeof<PyType> tmp_7@937@01) (as Cell<PyType>  PyType))))
; [eval] p2_25 ==> issubtype(typeof(self_0), Cell())
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1449 | p2_15@872@01 | live]
; [else-branch: 1449 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1449 | p2_15@872@01]
; [eval] issubtype(typeof(self_0), Cell())
; [eval] typeof(self_0)
; [eval] Cell()
(pop) ; 15
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (=>
  p2_15@872@01
  (issubtype<Bool> (typeof<PyType> tmp_7@937@01) (as Cell<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_15@872@01
  (issubtype<Bool> (typeof<PyType> tmp_7@937@01) (as Cell<PyType>  PyType))))
; [eval] p1_25 ==> self != null
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1450 | p1_15@871@01 | live]
; [else-branch: 1450 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1450 | p1_15@871@01]
; [eval] self != null
(pop) ; 15
(pop) ; 14
; Joined path conditions
; [eval] p2_25 ==> self_0 != null
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1451 | p2_15@872@01 | live]
; [else-branch: 1451 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1451 | p2_15@872@01]
; [eval] self_0 != null
(pop) ; 15
(pop) ; 14
; Joined path conditions
; [eval] p1_25 ==> perm(MustTerminate(_cthread_156)) == none && ((forperm _r_41: Ref [MustInvokeBounded(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBounded] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnbounded] :: false))))
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1452 | p1_15@871@01 | live]
; [else-branch: 1452 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1452 | p1_15@871@01]
; [eval] perm(MustTerminate(_cthread_156)) == none && ((forperm _r_41: Ref [MustInvokeBounded(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBounded] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_156)) == none
; [eval] perm(MustTerminate(_cthread_156))
(push) ; 16
; [then-branch: 1453 | False | live]
; [else-branch: 1453 | True | live]
(push) ; 17
; [then-branch: 1453 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 1453 | True]
; [eval] (forperm _r_41: Ref [MustInvokeBounded(_r_41)] :: false)
(push) ; 18
; [then-branch: 1454 | False | live]
; [else-branch: 1454 | True | live]
(push) ; 19
; [then-branch: 1454 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 1454 | True]
; [eval] (forperm _r_41: Ref [MustInvokeUnbounded(_r_41)] :: false)
(push) ; 20
; [then-branch: 1455 | False | live]
; [else-branch: 1455 | True | live]
(push) ; 21
; [then-branch: 1455 | False]
(assert false)
(pop) ; 21
(push) ; 21
; [else-branch: 1455 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseBounded] :: false)
(push) ; 22
; [then-branch: 1456 | False | live]
; [else-branch: 1456 | True | live]
(push) ; 23
; [then-branch: 1456 | False]
(assert false)
(pop) ; 23
(push) ; 23
; [else-branch: 1456 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseUnbounded] :: false)
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; [eval] p2_25 ==> perm(MustTerminate_0(_cthread_156_0)) == none && ((forperm _r_41: Ref [MustInvokeBounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBoundedp] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnboundedp] :: false))))
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1457 | p2_15@872@01 | live]
; [else-branch: 1457 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1457 | p2_15@872@01]
; [eval] perm(MustTerminate_0(_cthread_156_0)) == none && ((forperm _r_41: Ref [MustInvokeBounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [MustInvokeUnbounded_0(_r_41)] :: false) && ((forperm _r_41: Ref [_r_41.MustReleaseBoundedp] :: false) && (forperm _r_41: Ref [_r_41.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_156_0)) == none
; [eval] perm(MustTerminate_0(_cthread_156_0))
(push) ; 16
; [then-branch: 1458 | False | live]
; [else-branch: 1458 | True | live]
(push) ; 17
; [then-branch: 1458 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 1458 | True]
; [eval] (forperm _r_41: Ref [MustInvokeBounded_0(_r_41)] :: false)
(push) ; 18
; [then-branch: 1459 | False | live]
; [else-branch: 1459 | True | live]
(push) ; 19
; [then-branch: 1459 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 1459 | True]
; [eval] (forperm _r_41: Ref [MustInvokeUnbounded_0(_r_41)] :: false)
(push) ; 20
; [then-branch: 1460 | False | live]
; [else-branch: 1460 | True | live]
(push) ; 21
; [then-branch: 1460 | False]
(assert false)
(pop) ; 21
(push) ; 21
; [else-branch: 1460 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseBoundedp] :: false)
(push) ; 22
; [then-branch: 1461 | False | live]
; [else-branch: 1461 | True | live]
(push) ; 23
; [then-branch: 1461 | False]
(assert false)
(pop) ; 23
(push) ; 23
; [else-branch: 1461 | True]
; [eval] (forperm _r_41: Ref [_r_41.MustReleaseUnboundedp] :: false)
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
(declare-const _current_wait_level_156@952@01 $Perm)
(declare-const _current_wait_level_156_0@953@01 $Perm)
(declare-const $t@954@01 $Snap)
(assert (= $t@954@01 ($Snap.combine ($Snap.first $t@954@01) ($Snap.second $t@954@01))))
(assert (= ($Snap.first $t@954@01) $Snap.unit))
; [eval] p1_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1462 | p1_15@871@01 | live]
; [else-branch: 1462 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1462 | p1_15@871@01]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156)
(push) ; 16
; [then-branch: 1463 | False | live]
; [else-branch: 1463 | True | live]
(push) ; 17
; [then-branch: 1463 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 1463 | True]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156)
(push) ; 18
; [then-branch: 1464 | False | live]
; [else-branch: 1464 | True | live]
(push) ; 19
; [then-branch: 1464 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 1464 | True]
; [eval] _residue_156 <= _current_wait_level_156
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (=> p1_15@871@01 (<= _residue_168@877@01 _current_wait_level_156@952@01)))
(assert (=
  ($Snap.second $t@954@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@954@01))
    ($Snap.second ($Snap.second $t@954@01)))))
(assert (= ($Snap.first ($Snap.second $t@954@01)) $Snap.unit))
; [eval] p2_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
(push) ; 14
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1465 | p2_15@872@01 | live]
; [else-branch: 1465 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1465 | p2_15@872@01]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0)
(push) ; 16
; [then-branch: 1466 | False | live]
; [else-branch: 1466 | True | live]
(push) ; 17
; [then-branch: 1466 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 1466 | True]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0)
(push) ; 18
; [then-branch: 1467 | False | live]
; [else-branch: 1467 | True | live]
(push) ; 19
; [then-branch: 1467 | False]
(assert false)
(pop) ; 19
(push) ; 19
; [else-branch: 1467 | True]
; [eval] _residue_156_0 <= _current_wait_level_156_0
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (=> p2_15@872@01 (<= _residue_168_0@878@01 _current_wait_level_156_0@953@01)))
(assert (=
  ($Snap.second ($Snap.second $t@954@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@954@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1468 | p1_15@871@01 | live]
; [else-branch: 1468 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1468 | p1_15@871@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@954@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))))
(push) ; 15
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1469 | p2_15@872@01 | live]
; [else-branch: 1469 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1469 | p2_15@872@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self.Cell_val), int())
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1470 | p1_15@871@01 | live]
; [else-branch: 1470 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 1470 | p1_15@871@01]
; [eval] issubtype(typeof(self.Cell_val), int())
; [eval] typeof(self.Cell_val)
; [eval] int()
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=>
  p1_15@871@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0.Cell_valp), int())
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1471 | p2_15@872@01 | live]
; [else-branch: 1471 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 1471 | p2_15@872@01]
; [eval] issubtype(typeof(self_0.Cell_valp), int())
; [eval] typeof(self_0.Cell_valp)
; [eval] int()
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=>
  p2_15@872@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))))
  $Snap.unit))
; [eval] p1_25 ==> int___eq__(self.Cell_val, __prim__int___box__(0))
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1472 | p1_15@871@01 | live]
; [else-branch: 1472 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 1472 | p1_15@871@01]
; [eval] int___eq__(self.Cell_val, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 18
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 18
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(push) ; 18
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 19
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01))))) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 19
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01)))) (__prim__int___box__ $Snap.unit 0)))
(pop) ; 18
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01))))) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01)))) (__prim__int___box__ $Snap.unit 0))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=>
  p1_15@871@01
  (and
    (__prim__int___box__%precondition $Snap.unit 0)
    (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01))))) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01)))) (__prim__int___box__ $Snap.unit 0)))))
(assert (=>
  p1_15@871@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01)))) (__prim__int___box__ $Snap.unit 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))))
  $Snap.unit))
; [eval] p2_25 ==> int___eq__(self_0.Cell_valp, __prim__int___box__(0))
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1473 | p2_15@872@01 | live]
; [else-branch: 1473 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 1473 | p2_15@872@01]
; [eval] int___eq__(self_0.Cell_valp, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 18
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 18
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(push) ; 18
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 19
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 19
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01))))) (__prim__int___box__ $Snap.unit 0)))
(pop) ; 18
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01))))) (__prim__int___box__ $Snap.unit 0))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=>
  p2_15@872@01
  (and
    (__prim__int___box__%precondition $Snap.unit 0)
    (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01))))) (__prim__int___box__ $Snap.unit 0)))))
(assert (=>
  p2_15@872@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01))))) (__prim__int___box__ $Snap.unit 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1474 | p1_15@871@01 | live]
; [else-branch: 1474 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 1474 | p1_15@871@01]
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 16
(push) ; 17
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1475 | p2_15@872@01 | live]
; [else-branch: 1475 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 1475 | p2_15@872@01]
(pop) ; 17
(pop) ; 16
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1476 | p1_15@871@01 | live]
; [else-branch: 1476 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 1476 | p1_15@871@01]
; [exec]
; _cwl_168 := tmp1_59
(push) ; 17
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1477 | p2_15@872@01 | live]
; [else-branch: 1477 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 1477 | p2_15@872@01]
; [exec]
; _cwl_168_0 := tmp2_59
(push) ; 18
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1478 | p1_15@871@01 | live]
; [else-branch: 1478 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 1478 | p1_15@871@01]
; [exec]
; c_1 := Cell_res_1
; [exec]
; inhale _isDefined(3235683)
(declare-const $t@955@01 $Snap)
(assert (= $t@955@01 $Snap.unit))
; [eval] _isDefined(3235683)
(push) ; 19
(assert (_isDefined%precondition $Snap.unit 3235683))
(pop) ; 19
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 3235683))
(assert (_isDefined $Snap.unit 3235683))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1479 | p2_15@872@01 | live]
; [else-branch: 1479 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 1479 | p2_15@872@01]
; [exec]
; c_1_0 := Cell_res_1_0
; [exec]
; inhale true
(declare-const $t@956@01 $Snap)
(assert (= $t@956@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; p1_16 := p1_15 && bool___unbox__(secret_5)
; [eval] p1_15 && bool___unbox__(secret_5)
(set-option :timeout 0)
(push) ; 20
; [then-branch: 1480 | !(p1_15@871@01) | live]
; [else-branch: 1480 | p1_15@871@01 | live]
(push) ; 21
; [then-branch: 1480 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 21
(push) ; 21
; [else-branch: 1480 | p1_15@871@01]
; [eval] bool___unbox__(secret_5)
(push) ; 22
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 23
(assert (not (issubtype<Bool> (typeof<PyType> secret_1@879@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_1@879@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_1@879@01))
(pop) ; 22
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_1@879@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_1@879@01)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_15@871@01
  (and
    (issubtype<Bool> (typeof<PyType> secret_1@879@01) (as bool<PyType>  PyType))
    (bool___unbox__%precondition $Snap.unit secret_1@879@01))))
(assert (or p1_15@871@01 (not p1_15@871@01)))
(declare-const p1_16@957@01 Bool)
(assert (= p1_16@957@01 (and p1_15@871@01 (bool___unbox__ $Snap.unit secret_1@879@01))))
; [exec]
; p2_16 := p2_15 && bool___unbox__(secret_5_0)
; [eval] p2_15 && bool___unbox__(secret_5_0)
(push) ; 20
; [then-branch: 1481 | !(p2_15@872@01) | live]
; [else-branch: 1481 | p2_15@872@01 | live]
(push) ; 21
; [then-branch: 1481 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 21
(push) ; 21
; [else-branch: 1481 | p2_15@872@01]
; [eval] bool___unbox__(secret_5_0)
(push) ; 22
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 23
(assert (not (issubtype<Bool> (typeof<PyType> secret_1_0@880@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_1_0@880@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_1_0@880@01))
(pop) ; 22
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_1_0@880@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_1_0@880@01)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_15@872@01
  (and
    (issubtype<Bool> (typeof<PyType> secret_1_0@880@01) (as bool<PyType>  PyType))
    (bool___unbox__%precondition $Snap.unit secret_1_0@880@01))))
(assert (or p2_15@872@01 (not p2_15@872@01)))
(declare-const p2_16@958@01 Bool)
(assert (= p2_16@958@01 (and p2_15@872@01 (bool___unbox__ $Snap.unit secret_1_0@880@01))))
; [exec]
; p3_7 := p1_15 && !bool___unbox__(secret_5)
; [eval] p1_15 && !bool___unbox__(secret_5)
(push) ; 20
; [then-branch: 1482 | !(p1_15@871@01) | live]
; [else-branch: 1482 | p1_15@871@01 | live]
(push) ; 21
; [then-branch: 1482 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 21
(push) ; 21
; [else-branch: 1482 | p1_15@871@01]
; [eval] !bool___unbox__(secret_5)
; [eval] bool___unbox__(secret_5)
(push) ; 22
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 23
(assert (not (issubtype<Bool> (typeof<PyType> secret_1@879@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_1@879@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_1@879@01))
(pop) ; 22
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_1@879@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_1@879@01)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(declare-const p3_7@959@01 Bool)
(assert (=
  p3_7@959@01
  (and p1_15@871@01 (not (bool___unbox__ $Snap.unit secret_1@879@01)))))
; [exec]
; p4_7 := p2_15 && !bool___unbox__(secret_5_0)
; [eval] p2_15 && !bool___unbox__(secret_5_0)
(push) ; 20
; [then-branch: 1483 | !(p2_15@872@01) | live]
; [else-branch: 1483 | p2_15@872@01 | live]
(push) ; 21
; [then-branch: 1483 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 21
(push) ; 21
; [else-branch: 1483 | p2_15@872@01]
; [eval] !bool___unbox__(secret_5_0)
; [eval] bool___unbox__(secret_5_0)
(push) ; 22
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 23
(assert (not (issubtype<Bool> (typeof<PyType> secret_1_0@880@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_1_0@880@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_1_0@880@01))
(pop) ; 22
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_1_0@880@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_1_0@880@01)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(declare-const p4_7@960@01 Bool)
(assert (=
  p4_7@960@01
  (and p2_15@872@01 (not (bool___unbox__ $Snap.unit secret_1_0@880@01)))))
; [exec]
; tmp_8 := new()
(declare-const tmp_8@961@01 $Ref)
(assert (not (= tmp_8@961@01 $Ref.null)))
(assert (not (= tmp_8@961@01 threadingVar_3_0@896@01)))
(assert (not (= tmp_8@961@01 join_result_1@904@01)))
(assert (not (= tmp_8@961@01 threadingVar_3@895@01)))
(assert (not (= tmp_8@961@01 thread_arg_6@907@01)))
(assert (not (= tmp_8@961@01 threadingVar_4@897@01)))
(assert (not (= tmp_8@961@01 secret_1_0@880@01)))
(assert (not (= tmp_8@961@01 tmp_8@918@01)))
(assert (not (= tmp_8@961@01 thread_arg_6_0@908@01)))
(assert (not (= tmp_8@961@01 _cthread_168_0@874@01)))
(assert (not (= tmp_8@961@01 tmp_7@937@01)))
(assert (not (= tmp_8@961@01 t_1_0@890@01)))
(assert (not (= tmp_8@961@01 thread_arg_3@899@01)))
(assert (not (= tmp_8@961@01 t_1@889@01)))
(assert (not (= tmp_8@961@01 thread_arg_5_0@906@01)))
(assert (not (= tmp_8@961@01 thread_arg_4_0@902@01)))
(assert (not (= tmp_8@961@01 join_result@903@01)))
(assert (not (= tmp_8@961@01 thread_arg_4@901@01)))
(assert (not (= tmp_8@961@01 thread_arg_5@905@01)))
(assert (not (= tmp_8@961@01 threadingVar_4_0@898@01)))
(assert (not
  (=
    tmp_8@961@01
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))))
(assert (not
  (=
    tmp_8@961@01
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01)))))))
(assert (not (= tmp_8@961@01 thread_arg_3_0@900@01)))
(assert (not (= tmp_8@961@01 tmp_9@919@01)))
(assert (not (= tmp_8@961@01 secret_1@879@01)))
(assert (not (= tmp_8@961@01 _cthread_168@873@01)))
(push) ; 20
(set-option :timeout 10)
(assert (not (not p1_16@957@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not p1_16@957@01))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1484 | p1_16@957@01 | live]
; [else-branch: 1484 | !(p1_16@957@01) | live]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 1484 | p1_16@957@01]
(assert p1_16@957@01)
; [exec]
; threadingVar_3 := tmp_8
(push) ; 21
(set-option :timeout 10)
(assert (not (not p2_16@958@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not p2_16@958@01))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1485 | p2_16@958@01 | live]
; [else-branch: 1485 | !(p2_16@958@01) | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 1485 | p2_16@958@01]
(assert p2_16@958@01)
; [exec]
; threadingVar_3_0 := tmp_8
(push) ; 22
(set-option :timeout 10)
(assert (not (not p1_16@957@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1486 | p1_16@957@01 | live]
; [else-branch: 1486 | !(p1_16@957@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 1486 | p1_16@957@01]
; [exec]
; inhale issubtype(typeof(threadingVar_3), Thread_0())
(declare-const $t@962@01 $Snap)
(assert (= $t@962@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_3), Thread_0())
; [eval] typeof(threadingVar_3)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_8@961@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod(threadingVar_3) == zero_threading()
(declare-const $t@963@01 $Snap)
(assert (= $t@963@01 $Snap.unit))
; [eval] getMethod(threadingVar_3) == zero_threading()
; [eval] getMethod(threadingVar_3)
; [eval] zero_threading()
(assert (=
  (getMethod<ThreadingID> tmp_8@961@01)
  (as zero_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not p2_16@958@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1487 | p2_16@958@01 | live]
; [else-branch: 1487 | !(p2_16@958@01) | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 1487 | p2_16@958@01]
; [exec]
; inhale issubtype(typeof(threadingVar_3_0), Thread_0())
(declare-const $t@964@01 $Snap)
(assert (= $t@964@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_3_0), Thread_0())
; [eval] typeof(threadingVar_3_0)
; [eval] Thread_0()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod_0(threadingVar_3_0) == zero_threading()
(declare-const $t@965@01 $Snap)
(assert (= $t@965@01 $Snap.unit))
; [eval] getMethod_0(threadingVar_3_0) == zero_threading()
; [eval] getMethod_0(threadingVar_3_0)
; [eval] zero_threading()
(assert (=
  (getMethod_0<ThreadingID> tmp_8@961@01)
  (as zero_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; assert (p1_16 ==>
;   true == issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())) &&
;   (p2_16 ==> true == issubtype(typeof(c_1_0), Cell()))
; [eval] p1_16 ==> true == issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())
(set-option :timeout 0)
(push) ; 24
(push) ; 25
(set-option :timeout 10)
(assert (not (not p1_16@957@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1488 | p1_16@957@01 | live]
; [else-branch: 1488 | !(p1_16@957@01) | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 1488 | p1_16@957@01]
; [eval] true == issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())
; [eval] issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())
; [eval] typeof(_checkDefined(c_1, 3235683))
; [eval] _checkDefined(c_1, 3235683)
(push) ; 26
; [eval] _isDefined(id)
(push) ; 27
(pop) ; 27
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_7@937@01 3235683))
(pop) ; 26
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_7@937@01 3235683))
; [eval] Cell()
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (=> p1_16@957@01 (_checkDefined%precondition $Snap.unit tmp_7@937@01 3235683)))
(push) ; 24
(assert (not (=>
  p1_16@957@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit tmp_7@937@01 3235683)) (as Cell<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_16@957@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit tmp_7@937@01 3235683)) (as Cell<PyType>  PyType)))))
; [eval] p2_16 ==> true == issubtype(typeof(c_1_0), Cell())
(push) ; 24
(push) ; 25
(set-option :timeout 10)
(assert (not (not p2_16@958@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1489 | p2_16@958@01 | live]
; [else-branch: 1489 | !(p2_16@958@01) | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 1489 | p2_16@958@01]
; [eval] true == issubtype(typeof(c_1_0), Cell())
; [eval] issubtype(typeof(c_1_0), Cell())
; [eval] typeof(c_1_0)
; [eval] Cell()
(pop) ; 25
(pop) ; 24
; Joined path conditions
(push) ; 24
(assert (not (=>
  p2_16@958@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> tmp_7@937@01) (as Cell<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_16@958@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> tmp_7@937@01) (as Cell<PyType>  PyType)))))
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_16@957@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1490 | p1_16@957@01 | live]
; [else-branch: 1490 | !(p1_16@957@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 1490 | p1_16@957@01]
; [exec]
; inhale true && getArg(threadingVar_3, 0) == _checkDefined(c_1, 3235683)
(declare-const $t@966@01 $Snap)
(assert (= $t@966@01 ($Snap.combine ($Snap.first $t@966@01) ($Snap.second $t@966@01))))
(assert (= ($Snap.first $t@966@01) $Snap.unit))
(assert (= ($Snap.second $t@966@01) $Snap.unit))
; [eval] getArg(threadingVar_3, 0) == _checkDefined(c_1, 3235683)
; [eval] getArg(threadingVar_3, 0)
; [eval] _checkDefined(c_1, 3235683)
(push) ; 25
; [eval] _isDefined(id)
(push) ; 26
(pop) ; 26
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_7@937@01 3235683))
(pop) ; 25
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_7@937@01 3235683))
(assert (= (getArg<Ref> tmp_8@961@01 0) (_checkDefined $Snap.unit tmp_7@937@01 3235683)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start(threadingVar_3), write)
(declare-const $t@967@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t_1 := threadingVar_3
; [exec]
; inhale _isDefined(3235700)
(declare-const $t@968@01 $Snap)
(assert (= $t@968@01 $Snap.unit))
; [eval] _isDefined(3235700)
(set-option :timeout 0)
(push) ; 25
(assert (_isDefined%precondition $Snap.unit 3235700))
(pop) ; 25
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 3235700))
(assert (_isDefined $Snap.unit 3235700))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (not p2_16@958@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1491 | p2_16@958@01 | live]
; [else-branch: 1491 | !(p2_16@958@01) | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 1491 | p2_16@958@01]
; [exec]
; inhale true && getArg_0(threadingVar_3_0, 0) == c_1_0
(declare-const $t@969@01 $Snap)
(assert (= $t@969@01 ($Snap.combine ($Snap.first $t@969@01) ($Snap.second $t@969@01))))
(assert (= ($Snap.first $t@969@01) $Snap.unit))
(assert (= ($Snap.second $t@969@01) $Snap.unit))
; [eval] getArg_0(threadingVar_3_0, 0) == c_1_0
; [eval] getArg_0(threadingVar_3_0, 0)
(assert (= (getArg_0<Ref> tmp_8@961@01 0) tmp_7@937@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start_0(threadingVar_3_0), write)
(declare-const $t@970@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t_1_0 := threadingVar_3_0
; [exec]
; inhale true
(declare-const $t@971@01 $Snap)
(assert (= $t@971@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; tmp_9 := new()
(declare-const tmp_9@972@01 $Ref)
(assert (not (= tmp_9@972@01 $Ref.null)))
(assert (not (= tmp_9@972@01 tmp_7@937@01)))
(assert (not (= tmp_9@972@01 join_result_1@904@01)))
(assert (not (= tmp_9@972@01 thread_arg_3@899@01)))
(assert (not (= tmp_9@972@01 thread_arg_5_0@906@01)))
(assert (not (= tmp_9@972@01 thread_arg_4_0@902@01)))
(assert (not (= tmp_9@972@01 join_result@903@01)))
(assert (not (= tmp_9@972@01 thread_arg_4@901@01)))
(assert (not (= tmp_9@972@01 thread_arg_5@905@01)))
(assert (not (= tmp_9@972@01 threadingVar_4_0@898@01)))
(assert (not (= tmp_9@972@01 thread_arg_6@907@01)))
(assert (not (= tmp_9@972@01 tmp_8@961@01)))
(assert (not (= tmp_9@972@01 threadingVar_4@897@01)))
(assert (not (= tmp_9@972@01 secret_1_0@880@01)))
(assert (not
  (=
    tmp_9@972@01
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))))
(assert (not
  (=
    tmp_9@972@01
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01)))))))
(assert (not (= tmp_9@972@01 thread_arg_3_0@900@01)))
(assert (not (= tmp_9@972@01 tmp_9@919@01)))
(assert (not (= tmp_9@972@01 thread_arg_6_0@908@01)))
(assert (not (= tmp_9@972@01 secret_1@879@01)))
(assert (not (= tmp_9@972@01 _cthread_168_0@874@01)))
(assert (not (= tmp_9@972@01 _cthread_168@873@01)))
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not p3_7@959@01)))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1492 | p3_7@959@01 | dead]
; [else-branch: 1492 | !(p3_7@959@01) | live]
(set-option :timeout 0)
(push) ; 26
; [else-branch: 1492 | !(p3_7@959@01)]
(assert (not p3_7@959@01))
(pop) ; 26
; [eval] !p3_7
(push) ; 26
(set-option :timeout 10)
(assert (not p3_7@959@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not p3_7@959@01)))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1493 | !(p3_7@959@01) | live]
; [else-branch: 1493 | p3_7@959@01 | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 1493 | !(p3_7@959@01)]
(assert (not p3_7@959@01))
(push) ; 27
(set-option :timeout 10)
(assert (not (not p4_7@960@01)))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1494 | p4_7@960@01 | dead]
; [else-branch: 1494 | !(p4_7@960@01) | live]
(set-option :timeout 0)
(push) ; 27
; [else-branch: 1494 | !(p4_7@960@01)]
(assert (not p4_7@960@01))
(pop) ; 27
; [eval] !p4_7
(push) ; 27
(set-option :timeout 10)
(assert (not p4_7@960@01))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (not p4_7@960@01)))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1495 | !(p4_7@960@01) | live]
; [else-branch: 1495 | p4_7@960@01 | dead]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 1495 | !(p4_7@960@01)]
(assert (not p4_7@960@01))
; [then-branch: 1496 | p3_7@959@01 | dead]
; [else-branch: 1496 | !(p3_7@959@01) | live]
(push) ; 28
; [else-branch: 1496 | !(p3_7@959@01)]
(pop) ; 28
; [eval] !p3_7
(push) ; 28
(set-option :timeout 10)
(assert (not p3_7@959@01))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1497 | !(p3_7@959@01) | live]
; [else-branch: 1497 | p3_7@959@01 | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 1497 | !(p3_7@959@01)]
; [then-branch: 1498 | p4_7@960@01 | dead]
; [else-branch: 1498 | !(p4_7@960@01) | live]
(push) ; 29
; [else-branch: 1498 | !(p4_7@960@01)]
(pop) ; 29
; [eval] !p4_7
(push) ; 29
(set-option :timeout 10)
(assert (not p4_7@960@01))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1499 | !(p4_7@960@01) | live]
; [else-branch: 1499 | p4_7@960@01 | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 1499 | !(p4_7@960@01)]
; [exec]
; assert (p3_7 ==>
;   true == issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())) &&
;   (p4_7 ==> true == issubtype(typeof(c_1_0), Cell()))
; [eval] p3_7 ==> true == issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())
(push) ; 30
; [then-branch: 1500 | p3_7@959@01 | dead]
; [else-branch: 1500 | !(p3_7@959@01) | live]
(push) ; 31
; [else-branch: 1500 | !(p3_7@959@01)]
(pop) ; 31
(pop) ; 30
; Joined path conditions
; [eval] p4_7 ==> true == issubtype(typeof(c_1_0), Cell())
(push) ; 30
; [then-branch: 1501 | p4_7@960@01 | dead]
; [else-branch: 1501 | !(p4_7@960@01) | live]
(push) ; 31
; [else-branch: 1501 | !(p4_7@960@01)]
(pop) ; 31
(pop) ; 30
; Joined path conditions
; [then-branch: 1502 | p3_7@959@01 | dead]
; [else-branch: 1502 | !(p3_7@959@01) | live]
(push) ; 30
; [else-branch: 1502 | !(p3_7@959@01)]
(pop) ; 30
; [eval] !p3_7
(push) ; 30
(set-option :timeout 10)
(assert (not p3_7@959@01))
(check-sat)
; unknown
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1503 | !(p3_7@959@01) | live]
; [else-branch: 1503 | p3_7@959@01 | dead]
(set-option :timeout 0)
(push) ; 30
; [then-branch: 1503 | !(p3_7@959@01)]
; [then-branch: 1504 | p4_7@960@01 | dead]
; [else-branch: 1504 | !(p4_7@960@01) | live]
(push) ; 31
; [else-branch: 1504 | !(p4_7@960@01)]
(pop) ; 31
; [eval] !p4_7
(push) ; 31
(set-option :timeout 10)
(assert (not p4_7@960@01))
(check-sat)
; unknown
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1505 | !(p4_7@960@01) | live]
; [else-branch: 1505 | p4_7@960@01 | dead]
(set-option :timeout 0)
(push) ; 31
; [then-branch: 1505 | !(p4_7@960@01)]
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1506 | p1_15@871@01 | live]
; [else-branch: 1506 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 1506 | p1_15@871@01]
; [exec]
; exhale acc(_thread_start(_checkDefined(t_1, 3235700)), write)
; [eval] _checkDefined(t_1, 3235700)
(push) ; 33
; [eval] _isDefined(id)
(push) ; 34
(pop) ; 34
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_8@961@01 3235700))
(pop) ; 33
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_8@961@01 3235700))
(push) ; 33
(set-option :timeout 10)
(assert (not (= tmp_8@961@01 (_checkDefined $Snap.unit tmp_8@961@01 3235700))))
(check-sat)
; unsat
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 33
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1507 | p2_15@872@01 | live]
; [else-branch: 1507 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 33
; [then-branch: 1507 | p2_15@872@01]
; [exec]
; exhale acc(_thread_start_0(t_1_0), write)
; [exec]
; assert (p1_15 ==>
;   false ||
;   (getMethod(_checkDefined(t_1, 3235700)) == zero_threading() ||
;   getMethod(_checkDefined(t_1, 3235700)) == one_threading())) &&
;   (p2_15 ==>
;   false ||
;   (getMethod_0(t_1_0) == zero_threading() ||
;   getMethod_0(t_1_0) == one_threading()))
; [eval] p1_15 ==> false || (getMethod(_checkDefined(t_1, 3235700)) == zero_threading() || getMethod(_checkDefined(t_1, 3235700)) == one_threading())
(push) ; 34
(push) ; 35
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1508 | p1_15@871@01 | live]
; [else-branch: 1508 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 1508 | p1_15@871@01]
; [eval] false || (getMethod(_checkDefined(t_1, 3235700)) == zero_threading() || getMethod(_checkDefined(t_1, 3235700)) == one_threading())
(push) ; 36
; [then-branch: 1509 | False | live]
; [else-branch: 1509 | True | live]
(push) ; 37
; [then-branch: 1509 | False]
(assert false)
(pop) ; 37
(push) ; 37
; [else-branch: 1509 | True]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 38
; [eval] _isDefined(id)
(push) ; 39
(pop) ; 39
; Joined path conditions
(pop) ; 38
; Joined path conditions
; [eval] zero_threading()
(push) ; 38
; [then-branch: 1510 | getMethod[ThreadingID](_checkDefined(_, tmp_8@961@01, 3235700)) == zero_threading[ThreadingID] | live]
; [else-branch: 1510 | getMethod[ThreadingID](_checkDefined(_, tmp_8@961@01, 3235700)) != zero_threading[ThreadingID] | live]
(push) ; 39
; [then-branch: 1510 | getMethod[ThreadingID](_checkDefined(_, tmp_8@961@01, 3235700)) == zero_threading[ThreadingID]]
(assert (=
  (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
  (as zero_threading<ThreadingID>  ThreadingID)))
(pop) ; 39
(push) ; 39
; [else-branch: 1510 | getMethod[ThreadingID](_checkDefined(_, tmp_8@961@01, 3235700)) != zero_threading[ThreadingID]]
(assert (not
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
    (as zero_threading<ThreadingID>  ThreadingID))))
; [eval] getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 40
; [eval] _isDefined(id)
(push) ; 41
(pop) ; 41
; Joined path conditions
(pop) ; 40
; Joined path conditions
; [eval] one_threading()
(pop) ; 39
(pop) ; 38
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
    (as zero_threading<ThreadingID>  ThreadingID))))
(pop) ; 37
(pop) ; 36
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
    (as zero_threading<ThreadingID>  ThreadingID))))
(pop) ; 35
(pop) ; 34
; Joined path conditions
(assert (=>
  p1_15@871@01
  (or
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
        (as zero_threading<ThreadingID>  ThreadingID)))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID)))))
(push) ; 34
(assert (not (=>
  p1_15@871@01
  (or
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as one_threading<ThreadingID>  ThreadingID))))))
(check-sat)
; unsat
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_15@871@01
  (or
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as one_threading<ThreadingID>  ThreadingID)))))
; [eval] p2_15 ==> false || (getMethod_0(t_1_0) == zero_threading() || getMethod_0(t_1_0) == one_threading())
(push) ; 34
(push) ; 35
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1511 | p2_15@872@01 | live]
; [else-branch: 1511 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 1511 | p2_15@872@01]
; [eval] false || (getMethod_0(t_1_0) == zero_threading() || getMethod_0(t_1_0) == one_threading())
(push) ; 36
; [then-branch: 1512 | False | live]
; [else-branch: 1512 | True | live]
(push) ; 37
; [then-branch: 1512 | False]
(assert false)
(pop) ; 37
(push) ; 37
; [else-branch: 1512 | True]
; [eval] getMethod_0(t_1_0) == zero_threading()
; [eval] getMethod_0(t_1_0)
; [eval] zero_threading()
(push) ; 38
; [then-branch: 1513 | getMethod_0[ThreadingID](tmp_8@961@01) == zero_threading[ThreadingID] | live]
; [else-branch: 1513 | getMethod_0[ThreadingID](tmp_8@961@01) != zero_threading[ThreadingID] | live]
(push) ; 39
; [then-branch: 1513 | getMethod_0[ThreadingID](tmp_8@961@01) == zero_threading[ThreadingID]]
(pop) ; 39
(push) ; 39
; [else-branch: 1513 | getMethod_0[ThreadingID](tmp_8@961@01) != zero_threading[ThreadingID]]
(assert (not
  (=
    (getMethod_0<ThreadingID> tmp_8@961@01)
    (as zero_threading<ThreadingID>  ThreadingID))))
; [eval] getMethod_0(t_1_0) == one_threading()
; [eval] getMethod_0(t_1_0)
; [eval] one_threading()
(pop) ; 39
(pop) ; 38
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as zero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod_0<ThreadingID> tmp_8@961@01)
    (as zero_threading<ThreadingID>  ThreadingID))))
(pop) ; 37
(pop) ; 36
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as zero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod_0<ThreadingID> tmp_8@961@01)
    (as zero_threading<ThreadingID>  ThreadingID))))
(pop) ; 35
(pop) ; 34
; Joined path conditions
(assert (=>
  p2_15@872@01
  (or
    (not
      (=
        (getMethod_0<ThreadingID> tmp_8@961@01)
        (as zero_threading<ThreadingID>  ThreadingID)))
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as zero_threading<ThreadingID>  ThreadingID)))))
(push) ; 34
(assert (not (=>
  p2_15@872@01
  (or
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as zero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as one_threading<ThreadingID>  ThreadingID))))))
(check-sat)
; unsat
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_15@872@01
  (or
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as zero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as one_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p1_17 := p1_15 &&
;   getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] p1_15 && getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
(push) ; 34
; [then-branch: 1514 | !(p1_15@871@01) | live]
; [else-branch: 1514 | p1_15@871@01 | live]
(push) ; 35
; [then-branch: 1514 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 35
(push) ; 35
; [else-branch: 1514 | p1_15@871@01]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 36
; [eval] _isDefined(id)
(push) ; 37
(pop) ; 37
; Joined path conditions
(pop) ; 36
; Joined path conditions
; [eval] zero_threading()
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(declare-const p1_17@973@01 Bool)
(assert (=
  p1_17@973@01
  (and
    p1_15@871@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_17 := p2_15 && getMethod_0(t_1_0) == zero_threading()
; [eval] p2_15 && getMethod_0(t_1_0) == zero_threading()
(push) ; 34
; [then-branch: 1515 | !(p2_15@872@01) | live]
; [else-branch: 1515 | p2_15@872@01 | live]
(push) ; 35
; [then-branch: 1515 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 35
(push) ; 35
; [else-branch: 1515 | p2_15@872@01]
; [eval] getMethod_0(t_1_0) == zero_threading()
; [eval] getMethod_0(t_1_0)
; [eval] zero_threading()
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(declare-const p2_17@974@01 Bool)
(assert (=
  p2_17@974@01
  (and
    p2_15@872@01
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as zero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_8 := p1_15 &&
;   !(getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
; [eval] p1_15 && !(getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
(push) ; 34
; [then-branch: 1516 | !(p1_15@871@01) | live]
; [else-branch: 1516 | p1_15@871@01 | live]
(push) ; 35
; [then-branch: 1516 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 35
(push) ; 35
; [else-branch: 1516 | p1_15@871@01]
; [eval] !(getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
; [eval] getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 36
; [eval] _isDefined(id)
(push) ; 37
(pop) ; 37
; Joined path conditions
(pop) ; 36
; Joined path conditions
; [eval] zero_threading()
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(declare-const p3_8@975@01 Bool)
(assert (=
  p3_8@975@01
  (and
    p1_15@871@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
        (as zero_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_8 := p2_15 && !(getMethod_0(t_1_0) == zero_threading())
; [eval] p2_15 && !(getMethod_0(t_1_0) == zero_threading())
(push) ; 34
; [then-branch: 1517 | !(p2_15@872@01) | live]
; [else-branch: 1517 | p2_15@872@01 | live]
(push) ; 35
; [then-branch: 1517 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 35
(push) ; 35
; [else-branch: 1517 | p2_15@872@01]
; [eval] !(getMethod_0(t_1_0) == zero_threading())
; [eval] getMethod_0(t_1_0) == zero_threading()
; [eval] getMethod_0(t_1_0)
; [eval] zero_threading()
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(declare-const p4_8@976@01 Bool)
(assert (=
  p4_8@976@01
  (and
    p2_15@872@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_8@961@01)
        (as zero_threading<ThreadingID>  ThreadingID))))))
(push) ; 34
(set-option :timeout 10)
(assert (not (not p1_17@973@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 34
(set-option :timeout 10)
(assert (not p1_17@973@01))
(check-sat)
; unsat
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1518 | p1_17@973@01 | live]
; [else-branch: 1518 | !(p1_17@973@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 1518 | p1_17@973@01]
(assert p1_17@973@01)
; [exec]
; thread_arg_3 := getArg(_checkDefined(t_1, 3235700), 0)
; [eval] getArg(_checkDefined(t_1, 3235700), 0)
; [eval] _checkDefined(t_1, 3235700)
(push) ; 35
; [eval] _isDefined(id)
(push) ; 36
(pop) ; 36
; Joined path conditions
(pop) ; 35
; Joined path conditions
(declare-const thread_arg_3@977@01 $Ref)
(assert (=
  thread_arg_3@977@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_8@961@01 3235700) 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_3), Cell())
(declare-const $t@978@01 $Snap)
(assert (= $t@978@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_3), Cell())
; [eval] typeof(thread_arg_3)
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_3@977@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@979@01 $Snap)
(assert (= $t@979@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale true &&
;   (true &&
;   (acc(thread_arg_3.Cell_val, write) &&
;   issubtype(typeof(thread_arg_3.Cell_val), int())))
(set-option :timeout 0)
(push) ; 35
(set-option :timeout 10)
(assert (not (= tmp_7@937@01 thread_arg_3@977@01)))
(check-sat)
; unsat
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [eval] issubtype(typeof(thread_arg_3.Cell_val), int())
; [eval] typeof(thread_arg_3.Cell_val)
(set-option :timeout 0)
(push) ; 35
(set-option :timeout 10)
(assert (not (= tmp_7@937@01 thread_arg_3@977@01)))
(check-sat)
; unsat
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [eval] int()
(set-option :timeout 0)
(push) ; 35
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01))))) (as int<PyType>  PyType)))
; [exec]
; inhale true ==>
;   _joinable(_checkDefined(t_1, 3235700)) &&
;   acc(_thread_post(_checkDefined(t_1, 3235700)), write)
(push) ; 35
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1519 | True | live]
; [else-branch: 1519 | False | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 1519 | True]
(declare-const $t@980@01 $Snap)
(assert (= $t@980@01 ($Snap.combine ($Snap.first $t@980@01) ($Snap.second $t@980@01))))
(assert (= ($Snap.first $t@980@01) $Snap.unit))
; [eval] _joinable(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 36
; [eval] _isDefined(id)
(push) ; 37
(pop) ; 37
; Joined path conditions
(pop) ; 36
; Joined path conditions
(push) ; 36
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))
(pop) ; 36
; Joined path conditions
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))
(assert (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 36
; [eval] _isDefined(id)
(push) ; 37
(pop) ; 37
; Joined path conditions
(pop) ; 36
; Joined path conditions
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 36
(set-option :timeout 10)
(assert (not (not p2_17@974@01)))
(check-sat)
; unknown
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 36
(set-option :timeout 10)
(assert (not p2_17@974@01))
(check-sat)
; unsat
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1520 | p2_17@974@01 | live]
; [else-branch: 1520 | !(p2_17@974@01) | dead]
(set-option :timeout 0)
(push) ; 36
; [then-branch: 1520 | p2_17@974@01]
(assert p2_17@974@01)
; [exec]
; thread_arg_3_0 := getArg_0(t_1_0, 0)
; [eval] getArg_0(t_1_0, 0)
(declare-const thread_arg_3_0@981@01 $Ref)
(assert (= thread_arg_3_0@981@01 (getArg_0<Ref> tmp_8@961@01 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_3_0), Cell())
(declare-const $t@982@01 $Snap)
(assert (= $t@982@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_3_0), Cell())
; [eval] typeof(thread_arg_3_0)
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_3_0@981@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@983@01 $Snap)
(assert (= $t@983@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale true &&
;   (true &&
;   (acc(thread_arg_3_0.Cell_valp, write) &&
;   issubtype(typeof(thread_arg_3_0.Cell_valp), int())))
(set-option :timeout 0)
(push) ; 37
(set-option :timeout 10)
(assert (not (= tmp_7@937@01 thread_arg_3_0@981@01)))
(check-sat)
; unsat
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
; [eval] issubtype(typeof(thread_arg_3_0.Cell_valp), int())
; [eval] typeof(thread_arg_3_0.Cell_valp)
(set-option :timeout 0)
(push) ; 37
(set-option :timeout 10)
(assert (not (= tmp_7@937@01 thread_arg_3_0@981@01)))
(check-sat)
; unsat
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
; [eval] int()
(set-option :timeout 0)
(push) ; 37
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))) (as int<PyType>  PyType)))
; [exec]
; inhale true ==> _joinable(t_1_0) && acc(_thread_post_0(t_1_0), write)
(push) ; 37
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1521 | True | live]
; [else-branch: 1521 | False | dead]
(set-option :timeout 0)
(push) ; 37
; [then-branch: 1521 | True]
(declare-const $t@984@01 $Snap)
(assert (= $t@984@01 ($Snap.combine ($Snap.first $t@984@01) ($Snap.second $t@984@01))))
(assert (= ($Snap.first $t@984@01) $Snap.unit))
; [eval] _joinable(t_1_0)
(push) ; 38
(assert (_joinable%precondition $Snap.unit tmp_8@961@01))
(pop) ; 38
; Joined path conditions
(assert (_joinable%precondition $Snap.unit tmp_8@961@01))
(assert (_joinable $Snap.unit tmp_8@961@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; p1_18 := p1_15 && getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] p1_15 && getMethod(_checkDefined(t_1, 3235700)) == one_threading()
(set-option :timeout 0)
(push) ; 38
; [then-branch: 1522 | !(p1_15@871@01) | live]
; [else-branch: 1522 | p1_15@871@01 | live]
(push) ; 39
; [then-branch: 1522 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 39
(push) ; 39
; [else-branch: 1522 | p1_15@871@01]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 40
; [eval] _isDefined(id)
(push) ; 41
(pop) ; 41
; Joined path conditions
(pop) ; 40
; Joined path conditions
; [eval] one_threading()
(pop) ; 39
(pop) ; 38
; Joined path conditions
; Joined path conditions
(declare-const p1_18@985@01 Bool)
(assert (=
  p1_18@985@01
  (and
    p1_15@871@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as one_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_18 := p2_15 && getMethod_0(t_1_0) == one_threading()
; [eval] p2_15 && getMethod_0(t_1_0) == one_threading()
(push) ; 38
; [then-branch: 1523 | !(p2_15@872@01) | live]
; [else-branch: 1523 | p2_15@872@01 | live]
(push) ; 39
; [then-branch: 1523 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 39
(push) ; 39
; [else-branch: 1523 | p2_15@872@01]
; [eval] getMethod_0(t_1_0) == one_threading()
; [eval] getMethod_0(t_1_0)
; [eval] one_threading()
(pop) ; 39
(pop) ; 38
; Joined path conditions
; Joined path conditions
(declare-const p2_18@986@01 Bool)
(assert (=
  p2_18@986@01
  (and
    p2_15@872@01
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as one_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_9 := p1_15 &&
;   !(getMethod(_checkDefined(t_1, 3235700)) == one_threading())
; [eval] p1_15 && !(getMethod(_checkDefined(t_1, 3235700)) == one_threading())
(push) ; 38
; [then-branch: 1524 | !(p1_15@871@01) | live]
; [else-branch: 1524 | p1_15@871@01 | live]
(push) ; 39
; [then-branch: 1524 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 39
(push) ; 39
; [else-branch: 1524 | p1_15@871@01]
; [eval] !(getMethod(_checkDefined(t_1, 3235700)) == one_threading())
; [eval] getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 40
; [eval] _isDefined(id)
(push) ; 41
(pop) ; 41
; Joined path conditions
(pop) ; 40
; Joined path conditions
; [eval] one_threading()
(pop) ; 39
(pop) ; 38
; Joined path conditions
; Joined path conditions
(declare-const p3_9@987@01 Bool)
(assert (=
  p3_9@987@01
  (and
    p1_15@871@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
        (as one_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_9 := p2_15 && !(getMethod_0(t_1_0) == one_threading())
; [eval] p2_15 && !(getMethod_0(t_1_0) == one_threading())
(push) ; 38
; [then-branch: 1525 | !(p2_15@872@01) | live]
; [else-branch: 1525 | p2_15@872@01 | live]
(push) ; 39
; [then-branch: 1525 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 39
(push) ; 39
; [else-branch: 1525 | p2_15@872@01]
; [eval] !(getMethod_0(t_1_0) == one_threading())
; [eval] getMethod_0(t_1_0) == one_threading()
; [eval] getMethod_0(t_1_0)
; [eval] one_threading()
(pop) ; 39
(pop) ; 38
; Joined path conditions
; Joined path conditions
(declare-const p4_9@988@01 Bool)
(assert (=
  p4_9@988@01
  (and
    p2_15@872@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_8@961@01)
        (as one_threading<ThreadingID>  ThreadingID))))))
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_18@985@01)))
(check-sat)
; unsat
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1526 | p1_18@985@01 | dead]
; [else-branch: 1526 | !(p1_18@985@01) | live]
(set-option :timeout 0)
(push) ; 38
; [else-branch: 1526 | !(p1_18@985@01)]
(assert (not p1_18@985@01))
(pop) ; 38
; [eval] !p1_18
(push) ; 38
(set-option :timeout 10)
(assert (not p1_18@985@01))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 38
(set-option :timeout 10)
(assert (not (not p1_18@985@01)))
(check-sat)
; unsat
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1527 | !(p1_18@985@01) | live]
; [else-branch: 1527 | p1_18@985@01 | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 1527 | !(p1_18@985@01)]
(assert (not p1_18@985@01))
(push) ; 39
(set-option :timeout 10)
(assert (not (not p2_18@986@01)))
(check-sat)
; unsat
(pop) ; 39
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1528 | p2_18@986@01 | dead]
; [else-branch: 1528 | !(p2_18@986@01) | live]
(set-option :timeout 0)
(push) ; 39
; [else-branch: 1528 | !(p2_18@986@01)]
(assert (not p2_18@986@01))
(pop) ; 39
; [eval] !p2_18
(push) ; 39
(set-option :timeout 10)
(assert (not p2_18@986@01))
(check-sat)
; unknown
(pop) ; 39
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 39
(set-option :timeout 10)
(assert (not (not p2_18@986@01)))
(check-sat)
; unsat
(pop) ; 39
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1529 | !(p2_18@986@01) | live]
; [else-branch: 1529 | p2_18@986@01 | dead]
(set-option :timeout 0)
(push) ; 39
; [then-branch: 1529 | !(p2_18@986@01)]
(assert (not p2_18@986@01))
(push) ; 40
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 40
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1530 | p1_15@871@01 | live]
; [else-branch: 1530 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 40
; [then-branch: 1530 | p1_15@871@01]
; [exec]
; inhale (forperm
;     _r_29: Ref [_r_29.MustReleaseBounded] :: Level(_r_29) <
;     Level(_checkDefined(t_1, 3235700))) &&
;   ((forperm
;     _r_29: Ref [_r_29.MustReleaseUnbounded] :: Level(_r_29) <
;     Level(_checkDefined(t_1, 3235700))) &&
;   _residue_168 < Level(_checkDefined(t_1, 3235700)))
(declare-const $t@989@01 $Snap)
(assert (= $t@989@01 ($Snap.combine ($Snap.first $t@989@01) ($Snap.second $t@989@01))))
(assert (= ($Snap.first $t@989@01) $Snap.unit))
; [eval] (forperm _r_29: Ref [_r_29.MustReleaseBounded] :: Level(_r_29) < Level(_checkDefined(t_1, 3235700)))
(assert (=
  ($Snap.second $t@989@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@989@01))
    ($Snap.second ($Snap.second $t@989@01)))))
(assert (= ($Snap.first ($Snap.second $t@989@01)) $Snap.unit))
; [eval] (forperm _r_29: Ref [_r_29.MustReleaseUnbounded] :: Level(_r_29) < Level(_checkDefined(t_1, 3235700)))
(assert (= ($Snap.second ($Snap.second $t@989@01)) $Snap.unit))
; [eval] _residue_168 < Level(_checkDefined(t_1, 3235700))
; [eval] Level(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 41
; [eval] _isDefined(id)
(push) ; 42
(pop) ; 42
; Joined path conditions
(pop) ; 41
; Joined path conditions
(push) ; 41
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))
(pop) ; 41
; Joined path conditions
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))
(assert (<
  _residue_168@877@01
  (Level $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 41
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 41
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1531 | p2_15@872@01 | live]
; [else-branch: 1531 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 41
; [then-branch: 1531 | p2_15@872@01]
; [exec]
; inhale (forperm
;     _r_29: Ref [_r_29.MustReleaseBoundedp] :: Level(_r_29) < Level(t_1_0)) &&
;   ((forperm
;     _r_29: Ref [_r_29.MustReleaseUnboundedp] :: Level(_r_29) < Level(t_1_0)) &&
;   _residue_168_0 < Level(t_1_0))
(declare-const $t@990@01 $Snap)
(assert (= $t@990@01 ($Snap.combine ($Snap.first $t@990@01) ($Snap.second $t@990@01))))
(assert (= ($Snap.first $t@990@01) $Snap.unit))
; [eval] (forperm _r_29: Ref [_r_29.MustReleaseBoundedp] :: Level(_r_29) < Level(t_1_0))
(assert (=
  ($Snap.second $t@990@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@990@01))
    ($Snap.second ($Snap.second $t@990@01)))))
(assert (= ($Snap.first ($Snap.second $t@990@01)) $Snap.unit))
; [eval] (forperm _r_29: Ref [_r_29.MustReleaseUnboundedp] :: Level(_r_29) < Level(t_1_0))
(assert (= ($Snap.second ($Snap.second $t@990@01)) $Snap.unit))
; [eval] _residue_168_0 < Level(t_1_0)
; [eval] Level(t_1_0)
(push) ; 42
(assert (Level%precondition $Snap.unit tmp_8@961@01))
(pop) ; 42
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_8@961@01))
(assert (< _residue_168_0@878@01 (Level $Snap.unit tmp_8@961@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert (p1_15 ==> _joinable(_checkDefined(t_1, 3235700))) &&
;   (p2_15 ==> _joinable(t_1_0))
; [eval] p1_15 ==> _joinable(_checkDefined(t_1, 3235700))
(set-option :timeout 0)
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1532 | p1_15@871@01 | live]
; [else-branch: 1532 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1532 | p1_15@871@01]
; [eval] _joinable(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 44
; [eval] _isDefined(id)
(push) ; 45
(pop) ; 45
; Joined path conditions
(pop) ; 44
; Joined path conditions
(push) ; 44
(pop) ; 44
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
(push) ; 42
(assert (not (=>
  p1_15@871@01
  (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_15@871@01
  (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700))))
; [eval] p2_15 ==> _joinable(t_1_0)
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1533 | p2_15@872@01 | live]
; [else-branch: 1533 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1533 | p2_15@872@01]
; [eval] _joinable(t_1_0)
(push) ; 44
(pop) ; 44
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
(push) ; 42
(assert (not (=> p2_15@872@01 (_joinable $Snap.unit tmp_8@961@01))))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_15@872@01 (_joinable $Snap.unit tmp_8@961@01)))
; [exec]
; assert (p1_15 ==>
;   (forperm
;     _r_30: Ref [_r_30.MustReleaseBounded] :: Level(_r_30) <
;     Level(_checkDefined(t_1, 3235700)))) &&
;   ((p2_15 ==>
;   (forperm
;     _r_30: Ref [_r_30.MustReleaseBoundedp] :: Level(_r_30) < Level(t_1_0))) &&
;   ((p1_15 ==>
;   (forperm
;     _r_30: Ref [_r_30.MustReleaseUnbounded] :: Level(_r_30) <
;     Level(_checkDefined(t_1, 3235700)))) &&
;   ((p2_15 ==>
;   (forperm
;     _r_30: Ref [_r_30.MustReleaseUnboundedp] :: Level(_r_30) < Level(t_1_0))) &&
;   ((p1_15 ==> _residue_168 < Level(_checkDefined(t_1, 3235700))) &&
;   (p2_15 ==> _residue_168_0 < Level(t_1_0))))))
; [eval] p1_15 ==> (forperm _r_30: Ref [_r_30.MustReleaseBounded] :: Level(_r_30) < Level(_checkDefined(t_1, 3235700)))
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1534 | p1_15@871@01 | live]
; [else-branch: 1534 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1534 | p1_15@871@01]
; [eval] (forperm _r_30: Ref [_r_30.MustReleaseBounded] :: Level(_r_30) < Level(_checkDefined(t_1, 3235700)))
(pop) ; 43
(pop) ; 42
; Joined path conditions
; [eval] p2_15 ==> (forperm _r_30: Ref [_r_30.MustReleaseBoundedp] :: Level(_r_30) < Level(t_1_0))
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1535 | p2_15@872@01 | live]
; [else-branch: 1535 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1535 | p2_15@872@01]
; [eval] (forperm _r_30: Ref [_r_30.MustReleaseBoundedp] :: Level(_r_30) < Level(t_1_0))
(pop) ; 43
(pop) ; 42
; Joined path conditions
; [eval] p1_15 ==> (forperm _r_30: Ref [_r_30.MustReleaseUnbounded] :: Level(_r_30) < Level(_checkDefined(t_1, 3235700)))
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1536 | p1_15@871@01 | live]
; [else-branch: 1536 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1536 | p1_15@871@01]
; [eval] (forperm _r_30: Ref [_r_30.MustReleaseUnbounded] :: Level(_r_30) < Level(_checkDefined(t_1, 3235700)))
(pop) ; 43
(pop) ; 42
; Joined path conditions
; [eval] p2_15 ==> (forperm _r_30: Ref [_r_30.MustReleaseUnboundedp] :: Level(_r_30) < Level(t_1_0))
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1537 | p2_15@872@01 | live]
; [else-branch: 1537 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1537 | p2_15@872@01]
; [eval] (forperm _r_30: Ref [_r_30.MustReleaseUnboundedp] :: Level(_r_30) < Level(t_1_0))
(pop) ; 43
(pop) ; 42
; Joined path conditions
; [eval] p1_15 ==> _residue_168 < Level(_checkDefined(t_1, 3235700))
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1538 | p1_15@871@01 | live]
; [else-branch: 1538 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1538 | p1_15@871@01]
; [eval] _residue_168 < Level(_checkDefined(t_1, 3235700))
; [eval] Level(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 44
; [eval] _isDefined(id)
(push) ; 45
(pop) ; 45
; Joined path conditions
(pop) ; 44
; Joined path conditions
(push) ; 44
(pop) ; 44
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
(push) ; 42
(assert (not (=>
  p1_15@871@01
  (<
    _residue_168@877@01
    (Level $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700))))))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_15@871@01
  (<
    _residue_168@877@01
    (Level $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))))
; [eval] p2_15 ==> _residue_168_0 < Level(t_1_0)
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1539 | p2_15@872@01 | live]
; [else-branch: 1539 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1539 | p2_15@872@01]
; [eval] _residue_168_0 < Level(t_1_0)
; [eval] Level(t_1_0)
(push) ; 44
(pop) ; 44
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
(push) ; 42
(assert (not (=> p2_15@872@01 (< _residue_168_0@878@01 (Level $Snap.unit tmp_8@961@01)))))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_15@872@01 (< _residue_168_0@878@01 (Level $Snap.unit tmp_8@961@01))))
; [exec]
; p1_19 := p1_15 &&
;   (perm(_thread_post(_checkDefined(t_1, 3235700))) > none &&
;   getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
; [eval] p1_15 && (perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
(push) ; 42
; [then-branch: 1540 | !(p1_15@871@01) | live]
; [else-branch: 1540 | p1_15@871@01 | live]
(push) ; 43
; [then-branch: 1540 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 43
(push) ; 43
; [else-branch: 1540 | p1_15@871@01]
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 44
; [eval] _isDefined(id)
(push) ; 45
(pop) ; 45
; Joined path conditions
(pop) ; 44
; Joined path conditions
(push) ; 44
; [then-branch: 1541 | False | live]
; [else-branch: 1541 | True | live]
(push) ; 45
; [then-branch: 1541 | False]
(assert false)
(pop) ; 45
(push) ; 45
; [else-branch: 1541 | True]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 46
; [eval] _isDefined(id)
(push) ; 47
(pop) ; 47
; Joined path conditions
(pop) ; 46
; Joined path conditions
; [eval] zero_threading()
(pop) ; 45
(pop) ; 44
; Joined path conditions
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
; Joined path conditions
(declare-const p1_19@991@01 Bool)
(assert (=
  p1_19@991@01
  (and
    p1_15@871@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_19 := p2_15 &&
;   (perm(_thread_post_0(t_1_0)) > none &&
;   getMethod_0(t_1_0) == zero_threading())
; [eval] p2_15 && (perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == zero_threading())
(push) ; 42
; [then-branch: 1542 | !(p2_15@872@01) | live]
; [else-branch: 1542 | p2_15@872@01 | live]
(push) ; 43
; [then-branch: 1542 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 43
(push) ; 43
; [else-branch: 1542 | p2_15@872@01]
; [eval] perm(_thread_post_0(t_1_0)) > none
; [eval] perm(_thread_post_0(t_1_0))
(push) ; 44
; [then-branch: 1543 | False | live]
; [else-branch: 1543 | True | live]
(push) ; 45
; [then-branch: 1543 | False]
(assert false)
(pop) ; 45
(push) ; 45
; [else-branch: 1543 | True]
; [eval] getMethod_0(t_1_0) == zero_threading()
; [eval] getMethod_0(t_1_0)
; [eval] zero_threading()
(pop) ; 45
(pop) ; 44
; Joined path conditions
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
; Joined path conditions
(declare-const p2_19@992@01 Bool)
(assert (=
  p2_19@992@01
  (and
    p2_15@872@01
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as zero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_10 := p1_15 &&
;   !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none &&
;   getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
; [eval] p1_15 && !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
(push) ; 42
; [then-branch: 1544 | !(p1_15@871@01) | live]
; [else-branch: 1544 | p1_15@871@01 | live]
(push) ; 43
; [then-branch: 1544 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 43
(push) ; 43
; [else-branch: 1544 | p1_15@871@01]
; [eval] !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 44
; [eval] _isDefined(id)
(push) ; 45
(pop) ; 45
; Joined path conditions
(pop) ; 44
; Joined path conditions
(push) ; 44
; [then-branch: 1545 | False | live]
; [else-branch: 1545 | True | live]
(push) ; 45
; [then-branch: 1545 | False]
(assert false)
(pop) ; 45
(push) ; 45
; [else-branch: 1545 | True]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 46
; [eval] _isDefined(id)
(push) ; 47
(pop) ; 47
; Joined path conditions
(pop) ; 46
; Joined path conditions
; [eval] zero_threading()
(pop) ; 45
(pop) ; 44
; Joined path conditions
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
; Joined path conditions
(declare-const p3_10@993@01 Bool)
(assert (=
  p3_10@993@01
  (and
    p1_15@871@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
        (as zero_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_10 := p2_15 &&
;   !(perm(_thread_post_0(t_1_0)) > none &&
;   getMethod_0(t_1_0) == zero_threading())
; [eval] p2_15 && !(perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == zero_threading())
(push) ; 42
; [then-branch: 1546 | !(p2_15@872@01) | live]
; [else-branch: 1546 | p2_15@872@01 | live]
(push) ; 43
; [then-branch: 1546 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 43
(push) ; 43
; [else-branch: 1546 | p2_15@872@01]
; [eval] !(perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == zero_threading())
; [eval] perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == zero_threading()
; [eval] perm(_thread_post_0(t_1_0)) > none
; [eval] perm(_thread_post_0(t_1_0))
(push) ; 44
; [then-branch: 1547 | False | live]
; [else-branch: 1547 | True | live]
(push) ; 45
; [then-branch: 1547 | False]
(assert false)
(pop) ; 45
(push) ; 45
; [else-branch: 1547 | True]
; [eval] getMethod_0(t_1_0) == zero_threading()
; [eval] getMethod_0(t_1_0)
; [eval] zero_threading()
(pop) ; 45
(pop) ; 44
; Joined path conditions
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
; Joined path conditions
(declare-const p4_10@994@01 Bool)
(assert (=
  p4_10@994@01
  (and
    p2_15@872@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_8@961@01)
        (as zero_threading<ThreadingID>  ThreadingID))))))
(push) ; 42
(set-option :timeout 10)
(assert (not (not p1_19@991@01)))
(check-sat)
; unknown
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 42
(set-option :timeout 10)
(assert (not p1_19@991@01))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1548 | p1_19@991@01 | live]
; [else-branch: 1548 | !(p1_19@991@01) | dead]
(set-option :timeout 0)
(push) ; 42
; [then-branch: 1548 | p1_19@991@01]
(assert p1_19@991@01)
; [exec]
; thread_arg_5 := getArg(_checkDefined(t_1, 3235700), 0)
; [eval] getArg(_checkDefined(t_1, 3235700), 0)
; [eval] _checkDefined(t_1, 3235700)
(push) ; 43
; [eval] _isDefined(id)
(push) ; 44
(pop) ; 44
; Joined path conditions
(pop) ; 43
; Joined path conditions
(declare-const thread_arg_5@995@01 $Ref)
(assert (=
  thread_arg_5@995@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_8@961@01 3235700) 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_5), Cell())
(declare-const $t@996@01 $Snap)
(assert (= $t@996@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_5), Cell())
; [eval] typeof(thread_arg_5)
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_5@995@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_19@992@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 43
(set-option :timeout 10)
(assert (not p2_19@992@01))
(check-sat)
; unsat
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1549 | p2_19@992@01 | live]
; [else-branch: 1549 | !(p2_19@992@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1549 | p2_19@992@01]
(assert p2_19@992@01)
; [exec]
; thread_arg_5_0 := getArg_0(t_1_0, 0)
; [eval] getArg_0(t_1_0, 0)
(declare-const thread_arg_5_0@997@01 $Ref)
(assert (= thread_arg_5_0@997@01 (getArg_0<Ref> tmp_8@961@01 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_5_0), Cell())
(declare-const $t@998@01 $Snap)
(assert (= $t@998@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_5_0), Cell())
; [eval] typeof(thread_arg_5_0)
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_5_0@997@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (p1_19 ==> true) &&
;   ((p2_19 ==> true) &&
;   ((p1_19 ==>
;   acc(thread_arg_5.Cell_val, write *
;   perm(_thread_post(_checkDefined(t_1, 3235700))))) &&
;   ((p2_19 ==>
;   acc(thread_arg_5_0.Cell_valp, write * perm(_thread_post_0(t_1_0)))) &&
;   ((p1_19 ==> issubtype(typeof(thread_arg_5.Cell_val), int())) &&
;   (p2_19 ==> issubtype(typeof(thread_arg_5_0.Cell_valp), int())))) &&
;   (p1_19 && p2_19 ==> thread_arg_5.Cell_val == thread_arg_5_0.Cell_valp)))
(declare-const $t@999@01 $Snap)
(assert (= $t@999@01 ($Snap.combine ($Snap.first $t@999@01) ($Snap.second $t@999@01))))
(assert (= ($Snap.first $t@999@01) $Snap.unit))
; [eval] p1_19 ==> true
(set-option :timeout 0)
(push) ; 44
(push) ; 45
(set-option :timeout 10)
(assert (not (not p1_19@991@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1550 | p1_19@991@01 | live]
; [else-branch: 1550 | !(p1_19@991@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1550 | p1_19@991@01]
(pop) ; 45
(pop) ; 44
; Joined path conditions
(assert (=
  ($Snap.second $t@999@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@999@01))
    ($Snap.second ($Snap.second $t@999@01)))))
(assert (= ($Snap.first ($Snap.second $t@999@01)) $Snap.unit))
; [eval] p2_19 ==> true
(push) ; 44
(push) ; 45
(set-option :timeout 10)
(assert (not (not p2_19@992@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1551 | p2_19@992@01 | live]
; [else-branch: 1551 | !(p2_19@992@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1551 | p2_19@992@01]
(pop) ; 45
(pop) ; 44
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@999@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@999@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@999@01))))))
(push) ; 44
(set-option :timeout 10)
(assert (not (not p1_19@991@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1552 | p1_19@991@01 | live]
; [else-branch: 1552 | !(p1_19@991@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 1552 | p1_19@991@01]
; [eval] write * perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 45
; [eval] _isDefined(id)
(push) ; 46
(pop) ; 46
; Joined path conditions
(pop) ; 45
; Joined path conditions
(assert (not (= thread_arg_5@995@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@999@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@999@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@999@01)))))))
(push) ; 45
(set-option :timeout 10)
(assert (not (not p2_19@992@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1553 | p2_19@992@01 | live]
; [else-branch: 1553 | !(p2_19@992@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1553 | p2_19@992@01]
; [eval] write * perm(_thread_post_0(t_1_0))
; [eval] perm(_thread_post_0(t_1_0))
(assert (not (= thread_arg_5_0@997@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@999@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@999@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@999@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@999@01)))))
  $Snap.unit))
; [eval] p1_19 ==> issubtype(typeof(thread_arg_5.Cell_val), int())
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p1_19@991@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1554 | p1_19@991@01 | live]
; [else-branch: 1554 | !(p1_19@991@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1554 | p1_19@991@01]
; [eval] issubtype(typeof(thread_arg_5.Cell_val), int())
; [eval] typeof(thread_arg_5.Cell_val)
; [eval] int()
(pop) ; 47
(pop) ; 46
; Joined path conditions
(assert (=>
  p1_19@991@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@999@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@999@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@999@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@999@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@999@01))))))
  $Snap.unit))
; [eval] p2_19 ==> issubtype(typeof(thread_arg_5_0.Cell_valp), int())
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p2_19@992@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1555 | p2_19@992@01 | live]
; [else-branch: 1555 | !(p2_19@992@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1555 | p2_19@992@01]
; [eval] issubtype(typeof(thread_arg_5_0.Cell_valp), int())
; [eval] typeof(thread_arg_5_0.Cell_valp)
; [eval] int()
(pop) ; 47
(pop) ; 46
; Joined path conditions
(assert (=>
  p2_19@992@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@999@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@999@01))))))
  $Snap.unit))
; [eval] p1_19 && p2_19 ==> thread_arg_5.Cell_val == thread_arg_5_0.Cell_valp
; [eval] p1_19 && p2_19
(push) ; 46
; [then-branch: 1556 | !(p1_19@991@01) | live]
; [else-branch: 1556 | p1_19@991@01 | live]
(push) ; 47
; [then-branch: 1556 | !(p1_19@991@01)]
(assert (not p1_19@991@01))
(pop) ; 47
(push) ; 47
; [else-branch: 1556 | p1_19@991@01]
(pop) ; 47
(pop) ; 46
; Joined path conditions
; Joined path conditions
(assert (or p1_19@991@01 (not p1_19@991@01)))
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not (and p1_19@991@01 p2_19@992@01))))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 47
(set-option :timeout 10)
(assert (not (and p1_19@991@01 p2_19@992@01)))
(check-sat)
; unsat
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1557 | p1_19@991@01 && p2_19@992@01 | live]
; [else-branch: 1557 | !(p1_19@991@01 && p2_19@992@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1557 | p1_19@991@01 && p2_19@992@01]
(assert (and p1_19@991@01 p2_19@992@01))
; [eval] thread_arg_5.Cell_val == thread_arg_5_0.Cell_valp
(pop) ; 47
(pop) ; 46
; Joined path conditions
(assert (and p1_19@991@01 p2_19@992@01))
(assert (=>
  (and p1_19@991@01 p2_19@992@01)
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@999@01))))
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@999@01))))))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; p1_20 := p1_15 &&
;   (perm(_thread_post(_checkDefined(t_1, 3235700))) > none &&
;   getMethod(_checkDefined(t_1, 3235700)) == one_threading())
; [eval] p1_15 && (perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == one_threading())
(set-option :timeout 0)
(push) ; 46
; [then-branch: 1558 | !(p1_15@871@01) | live]
; [else-branch: 1558 | p1_15@871@01 | live]
(push) ; 47
; [then-branch: 1558 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 47
(push) ; 47
; [else-branch: 1558 | p1_15@871@01]
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 48
; [eval] _isDefined(id)
(push) ; 49
(pop) ; 49
; Joined path conditions
(pop) ; 48
; Joined path conditions
(push) ; 48
; [then-branch: 1559 | False | live]
; [else-branch: 1559 | True | live]
(push) ; 49
; [then-branch: 1559 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1559 | True]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 50
; [eval] _isDefined(id)
(push) ; 51
(pop) ; 51
; Joined path conditions
(pop) ; 50
; Joined path conditions
; [eval] one_threading()
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
; Joined path conditions
(declare-const p1_20@1000@01 Bool)
(assert (=
  p1_20@1000@01
  (and
    p1_15@871@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as one_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_20 := p2_15 &&
;   (perm(_thread_post_0(t_1_0)) > none &&
;   getMethod_0(t_1_0) == one_threading())
; [eval] p2_15 && (perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == one_threading())
(push) ; 46
; [then-branch: 1560 | !(p2_15@872@01) | live]
; [else-branch: 1560 | p2_15@872@01 | live]
(push) ; 47
; [then-branch: 1560 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 47
(push) ; 47
; [else-branch: 1560 | p2_15@872@01]
; [eval] perm(_thread_post_0(t_1_0)) > none
; [eval] perm(_thread_post_0(t_1_0))
(push) ; 48
; [then-branch: 1561 | False | live]
; [else-branch: 1561 | True | live]
(push) ; 49
; [then-branch: 1561 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1561 | True]
; [eval] getMethod_0(t_1_0) == one_threading()
; [eval] getMethod_0(t_1_0)
; [eval] one_threading()
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
; Joined path conditions
(declare-const p2_20@1001@01 Bool)
(assert (=
  p2_20@1001@01
  (and
    p2_15@872@01
    (=
      (getMethod_0<ThreadingID> tmp_8@961@01)
      (as one_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_11 := p1_15 &&
;   !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none &&
;   getMethod(_checkDefined(t_1, 3235700)) == one_threading())
; [eval] p1_15 && !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == one_threading())
(push) ; 46
; [then-branch: 1562 | !(p1_15@871@01) | live]
; [else-branch: 1562 | p1_15@871@01 | live]
(push) ; 47
; [then-branch: 1562 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 47
(push) ; 47
; [else-branch: 1562 | p1_15@871@01]
; [eval] !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == one_threading())
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 48
; [eval] _isDefined(id)
(push) ; 49
(pop) ; 49
; Joined path conditions
(pop) ; 48
; Joined path conditions
(push) ; 48
; [then-branch: 1563 | False | live]
; [else-branch: 1563 | True | live]
(push) ; 49
; [then-branch: 1563 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1563 | True]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 50
; [eval] _isDefined(id)
(push) ; 51
(pop) ; 51
; Joined path conditions
(pop) ; 50
; Joined path conditions
; [eval] one_threading()
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
; Joined path conditions
(declare-const p3_11@1002@01 Bool)
(assert (=
  p3_11@1002@01
  (and
    p1_15@871@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
        (as one_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_11 := p2_15 &&
;   !(perm(_thread_post_0(t_1_0)) > none &&
;   getMethod_0(t_1_0) == one_threading())
; [eval] p2_15 && !(perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == one_threading())
(push) ; 46
; [then-branch: 1564 | !(p2_15@872@01) | live]
; [else-branch: 1564 | p2_15@872@01 | live]
(push) ; 47
; [then-branch: 1564 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 47
(push) ; 47
; [else-branch: 1564 | p2_15@872@01]
; [eval] !(perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == one_threading())
; [eval] perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == one_threading()
; [eval] perm(_thread_post_0(t_1_0)) > none
; [eval] perm(_thread_post_0(t_1_0))
(push) ; 48
; [then-branch: 1565 | False | live]
; [else-branch: 1565 | True | live]
(push) ; 49
; [then-branch: 1565 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1565 | True]
; [eval] getMethod_0(t_1_0) == one_threading()
; [eval] getMethod_0(t_1_0)
; [eval] one_threading()
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
; Joined path conditions
(declare-const p4_11@1003@01 Bool)
(assert (=
  p4_11@1003@01
  (and
    p2_15@872@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_8@961@01)
        (as one_threading<ThreadingID>  ThreadingID))))))
(push) ; 46
(set-option :timeout 10)
(assert (not (not p1_20@1000@01)))
(check-sat)
; unsat
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1566 | p1_20@1000@01 | dead]
; [else-branch: 1566 | !(p1_20@1000@01) | live]
(set-option :timeout 0)
(push) ; 46
; [else-branch: 1566 | !(p1_20@1000@01)]
(assert (not p1_20@1000@01))
(pop) ; 46
; [eval] !p1_20
(push) ; 46
(set-option :timeout 10)
(assert (not p1_20@1000@01))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 46
(set-option :timeout 10)
(assert (not (not p1_20@1000@01)))
(check-sat)
; unsat
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1567 | !(p1_20@1000@01) | live]
; [else-branch: 1567 | p1_20@1000@01 | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 1567 | !(p1_20@1000@01)]
(assert (not p1_20@1000@01))
(push) ; 47
(set-option :timeout 10)
(assert (not (not p2_20@1001@01)))
(check-sat)
; unsat
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1568 | p2_20@1001@01 | dead]
; [else-branch: 1568 | !(p2_20@1001@01) | live]
(set-option :timeout 0)
(push) ; 47
; [else-branch: 1568 | !(p2_20@1001@01)]
(assert (not p2_20@1001@01))
(pop) ; 47
; [eval] !p2_20
(push) ; 47
(set-option :timeout 10)
(assert (not p2_20@1001@01))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 47
(set-option :timeout 10)
(assert (not (not p2_20@1001@01)))
(check-sat)
; unsat
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1569 | !(p2_20@1001@01) | live]
; [else-branch: 1569 | p2_20@1001@01 | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1569 | !(p2_20@1001@01)]
(assert (not p2_20@1001@01))
; [exec]
; inhale (p1_20 ==> true) &&
;   ((p2_20 ==> true) &&
;   ((p1_20 ==>
;   acc(thread_arg_6.Cell_val, write *
;   perm(_thread_post(_checkDefined(t_1, 3235700))))) &&
;   ((p2_20 ==>
;   acc(thread_arg_6_0.Cell_valp, write * perm(_thread_post_0(t_1_0)))) &&
;   ((p1_20 ==> issubtype(typeof(thread_arg_6.Cell_val), int())) &&
;   (p2_20 ==> issubtype(typeof(thread_arg_6_0.Cell_valp), int())))) &&
;   (p1_20 && p2_20 ==> thread_arg_6.Cell_val == thread_arg_6_0.Cell_valp)))
(declare-const $t@1004@01 $Snap)
(assert (= $t@1004@01 ($Snap.combine ($Snap.first $t@1004@01) ($Snap.second $t@1004@01))))
(assert (= ($Snap.first $t@1004@01) $Snap.unit))
; [eval] p1_20 ==> true
(push) ; 48
; [then-branch: 1570 | p1_20@1000@01 | dead]
; [else-branch: 1570 | !(p1_20@1000@01) | live]
(push) ; 49
; [else-branch: 1570 | !(p1_20@1000@01)]
(pop) ; 49
(pop) ; 48
; Joined path conditions
(assert (=
  ($Snap.second $t@1004@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1004@01))
    ($Snap.second ($Snap.second $t@1004@01)))))
(assert (= ($Snap.first ($Snap.second $t@1004@01)) $Snap.unit))
; [eval] p2_20 ==> true
(push) ; 48
; [then-branch: 1571 | p2_20@1001@01 | dead]
; [else-branch: 1571 | !(p2_20@1001@01) | live]
(push) ; 49
; [else-branch: 1571 | !(p2_20@1001@01)]
(pop) ; 49
(pop) ; 48
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1004@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1004@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1004@01))))))
; [then-branch: 1572 | p1_20@1000@01 | dead]
; [else-branch: 1572 | !(p1_20@1000@01) | live]
(push) ; 48
; [else-branch: 1572 | !(p1_20@1000@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1004@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1004@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1004@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1004@01)))))))
; [then-branch: 1573 | p2_20@1001@01 | dead]
; [else-branch: 1573 | !(p2_20@1001@01) | live]
(push) ; 49
; [else-branch: 1573 | !(p2_20@1001@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1004@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1004@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1004@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1004@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1004@01)))))
  $Snap.unit))
; [eval] p1_20 ==> issubtype(typeof(thread_arg_6.Cell_val), int())
(push) ; 50
; [then-branch: 1574 | p1_20@1000@01 | dead]
; [else-branch: 1574 | !(p1_20@1000@01) | live]
(push) ; 51
; [else-branch: 1574 | !(p1_20@1000@01)]
(pop) ; 51
(pop) ; 50
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1004@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1004@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1004@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1004@01))))))
  $Snap.unit))
; [eval] p2_20 ==> issubtype(typeof(thread_arg_6_0.Cell_valp), int())
(push) ; 50
; [then-branch: 1575 | p2_20@1001@01 | dead]
; [else-branch: 1575 | !(p2_20@1001@01) | live]
(push) ; 51
; [else-branch: 1575 | !(p2_20@1001@01)]
(pop) ; 51
(pop) ; 50
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1004@01))))))
  $Snap.unit))
; [eval] p1_20 && p2_20 ==> thread_arg_6.Cell_val == thread_arg_6_0.Cell_valp
; [eval] p1_20 && p2_20
(push) ; 50
; [then-branch: 1576 | !(p1_20@1000@01) | live]
; [else-branch: 1576 | p1_20@1000@01 | live]
(push) ; 51
; [then-branch: 1576 | !(p1_20@1000@01)]
(pop) ; 51
(push) ; 51
; [else-branch: 1576 | p1_20@1000@01]
(assert p1_20@1000@01)
(pop) ; 51
(pop) ; 50
; Joined path conditions
; Joined path conditions
(assert (or p1_20@1000@01 (not p1_20@1000@01)))
(push) ; 50
(push) ; 51
(set-option :timeout 10)
(assert (not (not (and p1_20@1000@01 p2_20@1001@01))))
(check-sat)
; unsat
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1577 | p1_20@1000@01 && p2_20@1001@01 | dead]
; [else-branch: 1577 | !(p1_20@1000@01 && p2_20@1001@01) | live]
(set-option :timeout 0)
(push) ; 51
; [else-branch: 1577 | !(p1_20@1000@01 && p2_20@1001@01)]
(assert (not (and p1_20@1000@01 p2_20@1001@01)))
(pop) ; 51
(pop) ; 50
; Joined path conditions
(assert (not (and p1_20@1000@01 p2_20@1001@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 50
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 50
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1578 | p1_15@871@01 | live]
; [else-branch: 1578 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 50
; [then-branch: 1578 | p1_15@871@01]
; [exec]
; exhale acc(_thread_post(_checkDefined(t_1, 3235700)), perm(_thread_post(_checkDefined(t_1,
;   3235700))))
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 51
; [eval] _isDefined(id)
(push) ; 52
(pop) ; 52
; Joined path conditions
(pop) ; 51
; Joined path conditions
; [eval] _checkDefined(t_1, 3235700)
(push) ; 51
; [eval] _isDefined(id)
(push) ; 52
(pop) ; 52
; Joined path conditions
(pop) ; 51
; Joined path conditions
(push) ; 51
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1579 | p2_15@872@01 | live]
; [else-branch: 1579 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 51
; [then-branch: 1579 | p2_15@872@01]
; [exec]
; exhale acc(_thread_post_0(t_1_0), perm(_thread_post_0(t_1_0)))
; [eval] perm(_thread_post_0(t_1_0))
; [exec]
; assert p1_15 && p2_15 ==>
;   _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] p1_15 && p2_15 ==> _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] p1_15 && p2_15
(push) ; 52
; [then-branch: 1580 | !(p1_15@871@01) | live]
; [else-branch: 1580 | p1_15@871@01 | live]
(push) ; 53
; [then-branch: 1580 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 53
(push) ; 53
; [else-branch: 1580 | p1_15@871@01]
(pop) ; 53
(pop) ; 52
; Joined path conditions
; Joined path conditions
(push) ; 52
(push) ; 53
(set-option :timeout 10)
(assert (not (not (and p1_15@871@01 p2_15@872@01))))
(check-sat)
; unknown
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 53
(set-option :timeout 10)
(assert (not (and p1_15@871@01 p2_15@872@01)))
(check-sat)
; unsat
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1581 | p1_15@871@01 && p2_15@872@01 | live]
; [else-branch: 1581 | !(p1_15@871@01 && p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 53
; [then-branch: 1581 | p1_15@871@01 && p2_15@872@01]
(assert (and p1_15@871@01 p2_15@872@01))
; [eval] _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] _checkDefined(c_1, 3235683)
(push) ; 54
; [eval] _isDefined(id)
(push) ; 55
(pop) ; 55
; Joined path conditions
(pop) ; 54
; Joined path conditions
(push) ; 54
(set-option :timeout 10)
(assert (not (= thread_arg_5@995@01 (_checkDefined $Snap.unit tmp_7@937@01 3235683))))
(check-sat)
; unsat
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 54
(set-option :timeout 10)
(assert (not (= thread_arg_5_0@997@01 tmp_7@937@01)))
(check-sat)
; unsat
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
(pop) ; 53
(pop) ; 52
; Joined path conditions
(assert (and p1_15@871@01 p2_15@872@01))
(set-option :timeout 0)
(push) ; 52
(assert (not (=>
  (and p1_15@871@01 p2_15@872@01)
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@999@01))))
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@999@01)))))))))
(check-sat)
; unsat
(pop) ; 52
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (and p1_15@871@01 p2_15@872@01)
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@999@01))))
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@999@01))))))))
; [exec]
; assert true
; [eval] p1_15 ==> true
(push) ; 52
(push) ; 53
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1582 | p1_15@871@01 | live]
; [else-branch: 1582 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 53
; [then-branch: 1582 | p1_15@871@01]
(pop) ; 53
(pop) ; 52
; Joined path conditions
; [eval] p2_15 ==> true
(push) ; 52
(push) ; 53
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1583 | p2_15@872@01 | live]
; [else-branch: 1583 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 53
; [then-branch: 1583 | p2_15@872@01]
(pop) ; 53
(pop) ; 52
; Joined path conditions
; [eval] p1_15 ==> (forperm _r_32: Ref [MustInvokeBounded(_r_32)] :: false) && ((forperm _r_32: Ref [MustInvokeUnbounded(_r_32)] :: false) && ((forperm _r_32: Ref [_r_32.MustReleaseBounded] :: false) && (forperm _r_32: Ref [_r_32.MustReleaseUnbounded] :: false)))
(push) ; 52
(push) ; 53
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1584 | p1_15@871@01 | live]
; [else-branch: 1584 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 53
; [then-branch: 1584 | p1_15@871@01]
; [eval] (forperm _r_32: Ref [MustInvokeBounded(_r_32)] :: false) && ((forperm _r_32: Ref [MustInvokeUnbounded(_r_32)] :: false) && ((forperm _r_32: Ref [_r_32.MustReleaseBounded] :: false) && (forperm _r_32: Ref [_r_32.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_32: Ref [MustInvokeBounded(_r_32)] :: false)
(push) ; 54
; [then-branch: 1585 | False | live]
; [else-branch: 1585 | True | live]
(push) ; 55
; [then-branch: 1585 | False]
(assert false)
(pop) ; 55
(push) ; 55
; [else-branch: 1585 | True]
; [eval] (forperm _r_32: Ref [MustInvokeUnbounded(_r_32)] :: false)
(push) ; 56
; [then-branch: 1586 | False | live]
; [else-branch: 1586 | True | live]
(push) ; 57
; [then-branch: 1586 | False]
(assert false)
(pop) ; 57
(push) ; 57
; [else-branch: 1586 | True]
; [eval] (forperm _r_32: Ref [_r_32.MustReleaseBounded] :: false)
(push) ; 58
; [then-branch: 1587 | False | live]
; [else-branch: 1587 | True | live]
(push) ; 59
; [then-branch: 1587 | False]
(assert false)
(pop) ; 59
(push) ; 59
; [else-branch: 1587 | True]
; [eval] (forperm _r_32: Ref [_r_32.MustReleaseUnbounded] :: false)
(pop) ; 59
(pop) ; 58
; Joined path conditions
; Joined path conditions
(pop) ; 57
(pop) ; 56
; Joined path conditions
; Joined path conditions
(pop) ; 55
(pop) ; 54
; Joined path conditions
; Joined path conditions
(pop) ; 53
(pop) ; 52
; Joined path conditions
; [eval] p2_15 ==> (forperm _r_32: Ref [MustInvokeBounded_0(_r_32)] :: false) && ((forperm _r_32: Ref [MustInvokeUnbounded_0(_r_32)] :: false) && ((forperm _r_32: Ref [_r_32.MustReleaseBoundedp] :: false) && (forperm _r_32: Ref [_r_32.MustReleaseUnboundedp] :: false)))
(push) ; 52
(push) ; 53
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1588 | p2_15@872@01 | live]
; [else-branch: 1588 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 53
; [then-branch: 1588 | p2_15@872@01]
; [eval] (forperm _r_32: Ref [MustInvokeBounded_0(_r_32)] :: false) && ((forperm _r_32: Ref [MustInvokeUnbounded_0(_r_32)] :: false) && ((forperm _r_32: Ref [_r_32.MustReleaseBoundedp] :: false) && (forperm _r_32: Ref [_r_32.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_32: Ref [MustInvokeBounded_0(_r_32)] :: false)
(push) ; 54
; [then-branch: 1589 | False | live]
; [else-branch: 1589 | True | live]
(push) ; 55
; [then-branch: 1589 | False]
(assert false)
(pop) ; 55
(push) ; 55
; [else-branch: 1589 | True]
; [eval] (forperm _r_32: Ref [MustInvokeUnbounded_0(_r_32)] :: false)
(push) ; 56
; [then-branch: 1590 | False | live]
; [else-branch: 1590 | True | live]
(push) ; 57
; [then-branch: 1590 | False]
(assert false)
(pop) ; 57
(push) ; 57
; [else-branch: 1590 | True]
; [eval] (forperm _r_32: Ref [_r_32.MustReleaseBoundedp] :: false)
(push) ; 58
; [then-branch: 1591 | False | live]
; [else-branch: 1591 | True | live]
(push) ; 59
; [then-branch: 1591 | False]
(assert false)
(pop) ; 59
(push) ; 59
; [else-branch: 1591 | True]
; [eval] (forperm _r_32: Ref [_r_32.MustReleaseUnboundedp] :: false)
(pop) ; 59
(pop) ; 58
; Joined path conditions
; Joined path conditions
(pop) ; 57
(pop) ; 56
; Joined path conditions
; Joined path conditions
(pop) ; 55
(pop) ; 54
; Joined path conditions
; Joined path conditions
(pop) ; 53
(pop) ; 52
; Joined path conditions
(pop) ; 51
; [eval] !p2_15
(push) ; 51
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unsat
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1592 | !(p2_15@872@01) | dead]
; [else-branch: 1592 | p2_15@872@01 | live]
(set-option :timeout 0)
(push) ; 51
; [else-branch: 1592 | p2_15@872@01]
(assert p2_15@872@01)
(pop) ; 51
(pop) ; 50
; [eval] !p1_15
(push) ; 50
(set-option :timeout 10)
(assert (not p1_15@871@01))
(check-sat)
; unsat
(pop) ; 50
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1593 | !(p1_15@871@01) | dead]
; [else-branch: 1593 | p1_15@871@01 | live]
(set-option :timeout 0)
(push) ; 50
; [else-branch: 1593 | p1_15@871@01]
(assert p1_15@871@01)
(pop) ; 50
(pop) ; 49
(pop) ; 48
(pop) ; 47
(pop) ; 46
(pop) ; 45
(pop) ; 44
(pop) ; 43
; [eval] !p2_19
(push) ; 43
(set-option :timeout 10)
(assert (not p2_19@992@01))
(check-sat)
; unsat
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1594 | !(p2_19@992@01) | dead]
; [else-branch: 1594 | p2_19@992@01 | live]
(set-option :timeout 0)
(push) ; 43
; [else-branch: 1594 | p2_19@992@01]
(assert p2_19@992@01)
(pop) ; 43
(pop) ; 42
; [eval] !p1_19
(push) ; 42
(set-option :timeout 10)
(assert (not p1_19@991@01))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1595 | !(p1_19@991@01) | dead]
; [else-branch: 1595 | p1_19@991@01 | live]
(set-option :timeout 0)
(push) ; 42
; [else-branch: 1595 | p1_19@991@01]
(assert p1_19@991@01)
(pop) ; 42
(pop) ; 41
; [eval] !p2_15
(push) ; 41
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unsat
(pop) ; 41
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1596 | !(p2_15@872@01) | dead]
; [else-branch: 1596 | p2_15@872@01 | live]
(set-option :timeout 0)
(push) ; 41
; [else-branch: 1596 | p2_15@872@01]
(assert p2_15@872@01)
(pop) ; 41
(pop) ; 40
; [eval] !p1_15
(push) ; 40
(set-option :timeout 10)
(assert (not p1_15@871@01))
(check-sat)
; unsat
(pop) ; 40
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1597 | !(p1_15@871@01) | dead]
; [else-branch: 1597 | p1_15@871@01 | live]
(set-option :timeout 0)
(push) ; 40
; [else-branch: 1597 | p1_15@871@01]
(assert p1_15@871@01)
(pop) ; 40
(pop) ; 39
(pop) ; 38
(pop) ; 37
(pop) ; 36
; [eval] !p2_17
(push) ; 36
(set-option :timeout 10)
(assert (not p2_17@974@01))
(check-sat)
; unsat
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1598 | !(p2_17@974@01) | dead]
; [else-branch: 1598 | p2_17@974@01 | live]
(set-option :timeout 0)
(push) ; 36
; [else-branch: 1598 | p2_17@974@01]
(assert p2_17@974@01)
(pop) ; 36
(pop) ; 35
(pop) ; 34
; [eval] !p1_17
(push) ; 34
(set-option :timeout 10)
(assert (not p1_17@973@01))
(check-sat)
; unsat
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1599 | !(p1_17@973@01) | dead]
; [else-branch: 1599 | p1_17@973@01 | live]
(set-option :timeout 0)
(push) ; 34
; [else-branch: 1599 | p1_17@973@01]
(assert p1_17@973@01)
(pop) ; 34
(pop) ; 33
; [eval] !p2_15
(push) ; 33
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unsat
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1600 | !(p2_15@872@01) | dead]
; [else-branch: 1600 | p2_15@872@01 | live]
(set-option :timeout 0)
(push) ; 33
; [else-branch: 1600 | p2_15@872@01]
(assert p2_15@872@01)
(pop) ; 33
(pop) ; 32
; [eval] !p1_15
(push) ; 32
(set-option :timeout 10)
(assert (not p1_15@871@01))
(check-sat)
; unsat
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1601 | !(p1_15@871@01) | dead]
; [else-branch: 1601 | p1_15@871@01 | live]
(set-option :timeout 0)
(push) ; 32
; [else-branch: 1601 | p1_15@871@01]
(assert p1_15@871@01)
(pop) ; 32
(pop) ; 31
(pop) ; 30
(pop) ; 29
(pop) ; 28
(pop) ; 27
(pop) ; 26
(pop) ; 25
; [eval] !p2_16
; [then-branch: 1602 | !(p2_16@958@01) | dead]
; [else-branch: 1602 | p2_16@958@01 | live]
(push) ; 25
; [else-branch: 1602 | p2_16@958@01]
(pop) ; 25
(pop) ; 24
; [eval] !p1_16
; [then-branch: 1603 | !(p1_16@957@01) | dead]
; [else-branch: 1603 | p1_16@957@01 | live]
(push) ; 24
; [else-branch: 1603 | p1_16@957@01]
(pop) ; 24
(pop) ; 23
; [eval] !p2_16
; [then-branch: 1604 | !(p2_16@958@01) | dead]
; [else-branch: 1604 | p2_16@958@01 | live]
(push) ; 23
; [else-branch: 1604 | p2_16@958@01]
(pop) ; 23
(pop) ; 22
; [eval] !p1_16
; [then-branch: 1605 | !(p1_16@957@01) | dead]
; [else-branch: 1605 | p1_16@957@01 | live]
(push) ; 22
; [else-branch: 1605 | p1_16@957@01]
(pop) ; 22
(pop) ; 21
(push) ; 21
; [else-branch: 1485 | !(p2_16@958@01)]
(assert (not p2_16@958@01))
(pop) ; 21
; [eval] !p2_16
(push) ; 21
(set-option :timeout 10)
(assert (not p2_16@958@01))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not p2_16@958@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1606 | !(p2_16@958@01) | live]
; [else-branch: 1606 | p2_16@958@01 | live]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 1606 | !(p2_16@958@01)]
(assert (not p2_16@958@01))
(push) ; 22
(set-option :timeout 10)
(assert (not (not p1_16@957@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1607 | p1_16@957@01 | live]
; [else-branch: 1607 | !(p1_16@957@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 1607 | p1_16@957@01]
; [exec]
; inhale issubtype(typeof(threadingVar_3), Thread_0())
(declare-const $t@1005@01 $Snap)
(assert (= $t@1005@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_3), Thread_0())
; [eval] typeof(threadingVar_3)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_8@961@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod(threadingVar_3) == zero_threading()
(declare-const $t@1006@01 $Snap)
(assert (= $t@1006@01 $Snap.unit))
; [eval] getMethod(threadingVar_3) == zero_threading()
; [eval] getMethod(threadingVar_3)
; [eval] zero_threading()
(assert (=
  (getMethod<ThreadingID> tmp_8@961@01)
  (as zero_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [then-branch: 1608 | p2_16@958@01 | dead]
; [else-branch: 1608 | !(p2_16@958@01) | live]
(set-option :timeout 0)
(push) ; 23
; [else-branch: 1608 | !(p2_16@958@01)]
(pop) ; 23
; [eval] !p2_16
(push) ; 23
(set-option :timeout 10)
(assert (not p2_16@958@01))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1609 | !(p2_16@958@01) | live]
; [else-branch: 1609 | p2_16@958@01 | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 1609 | !(p2_16@958@01)]
; [exec]
; assert (p1_16 ==>
;   true == issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())) &&
;   (p2_16 ==> true == issubtype(typeof(c_1_0), Cell()))
; [eval] p1_16 ==> true == issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())
(push) ; 24
(push) ; 25
(set-option :timeout 10)
(assert (not (not p1_16@957@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1610 | p1_16@957@01 | live]
; [else-branch: 1610 | !(p1_16@957@01) | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 1610 | p1_16@957@01]
; [eval] true == issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())
; [eval] issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())
; [eval] typeof(_checkDefined(c_1, 3235683))
; [eval] _checkDefined(c_1, 3235683)
(push) ; 26
; [eval] _isDefined(id)
(push) ; 27
(pop) ; 27
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_7@937@01 3235683))
(pop) ; 26
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_7@937@01 3235683))
; [eval] Cell()
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (=> p1_16@957@01 (_checkDefined%precondition $Snap.unit tmp_7@937@01 3235683)))
(push) ; 24
(assert (not (=>
  p1_16@957@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit tmp_7@937@01 3235683)) (as Cell<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_16@957@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit tmp_7@937@01 3235683)) (as Cell<PyType>  PyType)))))
; [eval] p2_16 ==> true == issubtype(typeof(c_1_0), Cell())
(push) ; 24
; [then-branch: 1611 | p2_16@958@01 | dead]
; [else-branch: 1611 | !(p2_16@958@01) | live]
(push) ; 25
; [else-branch: 1611 | !(p2_16@958@01)]
(pop) ; 25
(pop) ; 24
; Joined path conditions
(push) ; 24
(set-option :timeout 10)
(assert (not (not p1_16@957@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1612 | p1_16@957@01 | live]
; [else-branch: 1612 | !(p1_16@957@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 1612 | p1_16@957@01]
; [exec]
; inhale true && getArg(threadingVar_3, 0) == _checkDefined(c_1, 3235683)
(declare-const $t@1007@01 $Snap)
(assert (= $t@1007@01 ($Snap.combine ($Snap.first $t@1007@01) ($Snap.second $t@1007@01))))
(assert (= ($Snap.first $t@1007@01) $Snap.unit))
(assert (= ($Snap.second $t@1007@01) $Snap.unit))
; [eval] getArg(threadingVar_3, 0) == _checkDefined(c_1, 3235683)
; [eval] getArg(threadingVar_3, 0)
; [eval] _checkDefined(c_1, 3235683)
(push) ; 25
; [eval] _isDefined(id)
(push) ; 26
(pop) ; 26
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_7@937@01 3235683))
(pop) ; 25
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_7@937@01 3235683))
(assert (= (getArg<Ref> tmp_8@961@01 0) (_checkDefined $Snap.unit tmp_7@937@01 3235683)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start(threadingVar_3), write)
(declare-const $t@1008@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t_1 := threadingVar_3
; [exec]
; inhale _isDefined(3235700)
(declare-const $t@1009@01 $Snap)
(assert (= $t@1009@01 $Snap.unit))
; [eval] _isDefined(3235700)
(set-option :timeout 0)
(push) ; 25
(assert (_isDefined%precondition $Snap.unit 3235700))
(pop) ; 25
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 3235700))
(assert (_isDefined $Snap.unit 3235700))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [then-branch: 1613 | p2_16@958@01 | dead]
; [else-branch: 1613 | !(p2_16@958@01) | live]
(set-option :timeout 0)
(push) ; 25
; [else-branch: 1613 | !(p2_16@958@01)]
(pop) ; 25
; [eval] !p2_16
(push) ; 25
(set-option :timeout 10)
(assert (not p2_16@958@01))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1614 | !(p2_16@958@01) | live]
; [else-branch: 1614 | p2_16@958@01 | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 1614 | !(p2_16@958@01)]
; [exec]
; tmp_9 := new()
(declare-const tmp_9@1010@01 $Ref)
(assert (not (= tmp_9@1010@01 $Ref.null)))
(assert (not (= tmp_9@1010@01 threadingVar_3_0@896@01)))
(assert (not (= tmp_9@1010@01 join_result_1@904@01)))
(assert (not (= tmp_9@1010@01 thread_arg_6@907@01)))
(assert (not (= tmp_9@1010@01 threadingVar_4@897@01)))
(assert (not (= tmp_9@1010@01 secret_1_0@880@01)))
(assert (not (= tmp_9@1010@01 thread_arg_6_0@908@01)))
(assert (not (= tmp_9@1010@01 _cthread_168_0@874@01)))
(assert (not (= tmp_9@1010@01 tmp_7@937@01)))
(assert (not (= tmp_9@1010@01 t_1_0@890@01)))
(assert (not (= tmp_9@1010@01 thread_arg_3@899@01)))
(assert (not (= tmp_9@1010@01 thread_arg_5_0@906@01)))
(assert (not (= tmp_9@1010@01 thread_arg_4_0@902@01)))
(assert (not (= tmp_9@1010@01 join_result@903@01)))
(assert (not (= tmp_9@1010@01 thread_arg_4@901@01)))
(assert (not (= tmp_9@1010@01 thread_arg_5@905@01)))
(assert (not (= tmp_9@1010@01 threadingVar_4_0@898@01)))
(assert (not (= tmp_9@1010@01 tmp_8@961@01)))
(assert (not
  (=
    tmp_9@1010@01
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01))))))))
(assert (not
  (=
    tmp_9@1010@01
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01)))))))
(assert (not (= tmp_9@1010@01 thread_arg_3_0@900@01)))
(assert (not (= tmp_9@1010@01 tmp_9@919@01)))
(assert (not (= tmp_9@1010@01 secret_1@879@01)))
(assert (not (= tmp_9@1010@01 _cthread_168@873@01)))
(push) ; 26
(set-option :timeout 10)
(assert (not (not p3_7@959@01)))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1615 | p3_7@959@01 | dead]
; [else-branch: 1615 | !(p3_7@959@01) | live]
(set-option :timeout 0)
(push) ; 26
; [else-branch: 1615 | !(p3_7@959@01)]
(assert (not p3_7@959@01))
(pop) ; 26
; [eval] !p3_7
(push) ; 26
(set-option :timeout 10)
(assert (not p3_7@959@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not p3_7@959@01)))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1616 | !(p3_7@959@01) | live]
; [else-branch: 1616 | p3_7@959@01 | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 1616 | !(p3_7@959@01)]
(assert (not p3_7@959@01))
(push) ; 27
(set-option :timeout 10)
(assert (not (not p4_7@960@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not p4_7@960@01))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1617 | p4_7@960@01 | live]
; [else-branch: 1617 | !(p4_7@960@01) | dead]
(set-option :timeout 0)
(push) ; 27
; [then-branch: 1617 | p4_7@960@01]
(assert p4_7@960@01)
; [exec]
; threadingVar_4_0 := tmp_9
; [then-branch: 1618 | p3_7@959@01 | dead]
; [else-branch: 1618 | !(p3_7@959@01) | live]
(push) ; 28
; [else-branch: 1618 | !(p3_7@959@01)]
(pop) ; 28
; [eval] !p3_7
(push) ; 28
(set-option :timeout 10)
(assert (not p3_7@959@01))
(check-sat)
; unknown
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1619 | !(p3_7@959@01) | live]
; [else-branch: 1619 | p3_7@959@01 | dead]
(set-option :timeout 0)
(push) ; 28
; [then-branch: 1619 | !(p3_7@959@01)]
(push) ; 29
(set-option :timeout 10)
(assert (not (not p4_7@960@01)))
(check-sat)
; unknown
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1620 | p4_7@960@01 | live]
; [else-branch: 1620 | !(p4_7@960@01) | dead]
(set-option :timeout 0)
(push) ; 29
; [then-branch: 1620 | p4_7@960@01]
; [exec]
; inhale issubtype(typeof(threadingVar_4_0), Thread_0())
(declare-const $t@1011@01 $Snap)
(assert (= $t@1011@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_4_0), Thread_0())
; [eval] typeof(threadingVar_4_0)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_9@1010@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod_0(threadingVar_4_0) == one_threading()
(declare-const $t@1012@01 $Snap)
(assert (= $t@1012@01 $Snap.unit))
; [eval] getMethod_0(threadingVar_4_0) == one_threading()
; [eval] getMethod_0(threadingVar_4_0)
; [eval] one_threading()
(assert (=
  (getMethod_0<ThreadingID> tmp_9@1010@01)
  (as one_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; assert (p3_7 ==>
;   true == issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())) &&
;   (p4_7 ==> true == issubtype(typeof(c_1_0), Cell()))
; [eval] p3_7 ==> true == issubtype(typeof(_checkDefined(c_1, 3235683)), Cell())
(set-option :timeout 0)
(push) ; 30
; [then-branch: 1621 | p3_7@959@01 | dead]
; [else-branch: 1621 | !(p3_7@959@01) | live]
(push) ; 31
; [else-branch: 1621 | !(p3_7@959@01)]
(pop) ; 31
(pop) ; 30
; Joined path conditions
; [eval] p4_7 ==> true == issubtype(typeof(c_1_0), Cell())
(push) ; 30
(push) ; 31
(set-option :timeout 10)
(assert (not (not p4_7@960@01)))
(check-sat)
; unknown
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1622 | p4_7@960@01 | live]
; [else-branch: 1622 | !(p4_7@960@01) | dead]
(set-option :timeout 0)
(push) ; 31
; [then-branch: 1622 | p4_7@960@01]
; [eval] true == issubtype(typeof(c_1_0), Cell())
; [eval] issubtype(typeof(c_1_0), Cell())
; [eval] typeof(c_1_0)
; [eval] Cell()
(pop) ; 31
(pop) ; 30
; Joined path conditions
(push) ; 30
(assert (not (=>
  p4_7@960@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> tmp_7@937@01) (as Cell<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p4_7@960@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> tmp_7@937@01) (as Cell<PyType>  PyType)))))
; [then-branch: 1623 | p3_7@959@01 | dead]
; [else-branch: 1623 | !(p3_7@959@01) | live]
(push) ; 30
; [else-branch: 1623 | !(p3_7@959@01)]
(pop) ; 30
; [eval] !p3_7
(push) ; 30
(set-option :timeout 10)
(assert (not p3_7@959@01))
(check-sat)
; unknown
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1624 | !(p3_7@959@01) | live]
; [else-branch: 1624 | p3_7@959@01 | dead]
(set-option :timeout 0)
(push) ; 30
; [then-branch: 1624 | !(p3_7@959@01)]
(push) ; 31
(set-option :timeout 10)
(assert (not (not p4_7@960@01)))
(check-sat)
; unknown
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1625 | p4_7@960@01 | live]
; [else-branch: 1625 | !(p4_7@960@01) | dead]
(set-option :timeout 0)
(push) ; 31
; [then-branch: 1625 | p4_7@960@01]
; [exec]
; inhale true && getArg_0(threadingVar_4_0, 0) == c_1_0
(declare-const $t@1013@01 $Snap)
(assert (= $t@1013@01 ($Snap.combine ($Snap.first $t@1013@01) ($Snap.second $t@1013@01))))
(assert (= ($Snap.first $t@1013@01) $Snap.unit))
(assert (= ($Snap.second $t@1013@01) $Snap.unit))
; [eval] getArg_0(threadingVar_4_0, 0) == c_1_0
; [eval] getArg_0(threadingVar_4_0, 0)
(assert (= (getArg_0<Ref> tmp_9@1010@01 0) tmp_7@937@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start_0(threadingVar_4_0), write)
(declare-const $t@1014@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t_1_0 := threadingVar_4_0
; [exec]
; inhale true
(declare-const $t@1015@01 $Snap)
(assert (= $t@1015@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 32
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 32
(set-option :timeout 10)
(assert (not p1_15@871@01))
(check-sat)
; unsat
(pop) ; 32
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1626 | p1_15@871@01 | live]
; [else-branch: 1626 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 32
; [then-branch: 1626 | p1_15@871@01]
(assert p1_15@871@01)
; [exec]
; exhale acc(_thread_start(_checkDefined(t_1, 3235700)), write)
; [eval] _checkDefined(t_1, 3235700)
(push) ; 33
; [eval] _isDefined(id)
(push) ; 34
(pop) ; 34
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_8@961@01 3235700))
(pop) ; 33
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_8@961@01 3235700))
(push) ; 33
(set-option :timeout 10)
(assert (not (= tmp_8@961@01 (_checkDefined $Snap.unit tmp_8@961@01 3235700))))
(check-sat)
; unsat
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 33
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 33
(set-option :timeout 10)
(assert (not p2_15@872@01))
(check-sat)
; unsat
(pop) ; 33
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1627 | p2_15@872@01 | live]
; [else-branch: 1627 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 33
; [then-branch: 1627 | p2_15@872@01]
(assert p2_15@872@01)
; [exec]
; exhale acc(_thread_start_0(t_1_0), write)
; [exec]
; assert (p1_15 ==>
;   false ||
;   (getMethod(_checkDefined(t_1, 3235700)) == zero_threading() ||
;   getMethod(_checkDefined(t_1, 3235700)) == one_threading())) &&
;   (p2_15 ==>
;   false ||
;   (getMethod_0(t_1_0) == zero_threading() ||
;   getMethod_0(t_1_0) == one_threading()))
; [eval] p1_15 ==> false || (getMethod(_checkDefined(t_1, 3235700)) == zero_threading() || getMethod(_checkDefined(t_1, 3235700)) == one_threading())
(push) ; 34
(push) ; 35
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1628 | p1_15@871@01 | live]
; [else-branch: 1628 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 1628 | p1_15@871@01]
; [eval] false || (getMethod(_checkDefined(t_1, 3235700)) == zero_threading() || getMethod(_checkDefined(t_1, 3235700)) == one_threading())
(push) ; 36
; [then-branch: 1629 | False | live]
; [else-branch: 1629 | True | live]
(push) ; 37
; [then-branch: 1629 | False]
(assert false)
(pop) ; 37
(push) ; 37
; [else-branch: 1629 | True]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 38
; [eval] _isDefined(id)
(push) ; 39
(pop) ; 39
; Joined path conditions
(pop) ; 38
; Joined path conditions
; [eval] zero_threading()
(push) ; 38
; [then-branch: 1630 | getMethod[ThreadingID](_checkDefined(_, tmp_8@961@01, 3235700)) == zero_threading[ThreadingID] | live]
; [else-branch: 1630 | getMethod[ThreadingID](_checkDefined(_, tmp_8@961@01, 3235700)) != zero_threading[ThreadingID] | live]
(push) ; 39
; [then-branch: 1630 | getMethod[ThreadingID](_checkDefined(_, tmp_8@961@01, 3235700)) == zero_threading[ThreadingID]]
(assert (=
  (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
  (as zero_threading<ThreadingID>  ThreadingID)))
(pop) ; 39
(push) ; 39
; [else-branch: 1630 | getMethod[ThreadingID](_checkDefined(_, tmp_8@961@01, 3235700)) != zero_threading[ThreadingID]]
(assert (not
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
    (as zero_threading<ThreadingID>  ThreadingID))))
; [eval] getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 40
; [eval] _isDefined(id)
(push) ; 41
(pop) ; 41
; Joined path conditions
(pop) ; 40
; Joined path conditions
; [eval] one_threading()
(pop) ; 39
(pop) ; 38
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
    (as zero_threading<ThreadingID>  ThreadingID))))
(pop) ; 37
(pop) ; 36
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
    (as zero_threading<ThreadingID>  ThreadingID))))
(pop) ; 35
(pop) ; 34
; Joined path conditions
(assert (=>
  p1_15@871@01
  (or
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
        (as zero_threading<ThreadingID>  ThreadingID)))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID)))))
(push) ; 34
(assert (not (=>
  p1_15@871@01
  (or
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as one_threading<ThreadingID>  ThreadingID))))))
(check-sat)
; unsat
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_15@871@01
  (or
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as one_threading<ThreadingID>  ThreadingID)))))
; [eval] p2_15 ==> false || (getMethod_0(t_1_0) == zero_threading() || getMethod_0(t_1_0) == one_threading())
(push) ; 34
(push) ; 35
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1631 | p2_15@872@01 | live]
; [else-branch: 1631 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 1631 | p2_15@872@01]
; [eval] false || (getMethod_0(t_1_0) == zero_threading() || getMethod_0(t_1_0) == one_threading())
(push) ; 36
; [then-branch: 1632 | False | live]
; [else-branch: 1632 | True | live]
(push) ; 37
; [then-branch: 1632 | False]
(assert false)
(pop) ; 37
(push) ; 37
; [else-branch: 1632 | True]
; [eval] getMethod_0(t_1_0) == zero_threading()
; [eval] getMethod_0(t_1_0)
; [eval] zero_threading()
(push) ; 38
; [then-branch: 1633 | getMethod_0[ThreadingID](tmp_9@1010@01) == zero_threading[ThreadingID] | live]
; [else-branch: 1633 | getMethod_0[ThreadingID](tmp_9@1010@01) != zero_threading[ThreadingID] | live]
(push) ; 39
; [then-branch: 1633 | getMethod_0[ThreadingID](tmp_9@1010@01) == zero_threading[ThreadingID]]
(assert (=
  (getMethod_0<ThreadingID> tmp_9@1010@01)
  (as zero_threading<ThreadingID>  ThreadingID)))
(pop) ; 39
(push) ; 39
; [else-branch: 1633 | getMethod_0[ThreadingID](tmp_9@1010@01) != zero_threading[ThreadingID]]
(assert (not
  (=
    (getMethod_0<ThreadingID> tmp_9@1010@01)
    (as zero_threading<ThreadingID>  ThreadingID))))
; [eval] getMethod_0(t_1_0) == one_threading()
; [eval] getMethod_0(t_1_0)
; [eval] one_threading()
(pop) ; 39
(pop) ; 38
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as zero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod_0<ThreadingID> tmp_9@1010@01)
    (as zero_threading<ThreadingID>  ThreadingID))))
(pop) ; 37
(pop) ; 36
; Joined path conditions
; Joined path conditions
(assert (or
  (not
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as zero_threading<ThreadingID>  ThreadingID)))
  (=
    (getMethod_0<ThreadingID> tmp_9@1010@01)
    (as zero_threading<ThreadingID>  ThreadingID))))
(pop) ; 35
(pop) ; 34
; Joined path conditions
(assert (=>
  p2_15@872@01
  (or
    (not
      (=
        (getMethod_0<ThreadingID> tmp_9@1010@01)
        (as zero_threading<ThreadingID>  ThreadingID)))
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as zero_threading<ThreadingID>  ThreadingID)))))
(push) ; 34
(assert (not (=>
  p2_15@872@01
  (or
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as zero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as one_threading<ThreadingID>  ThreadingID))))))
(check-sat)
; unsat
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_15@872@01
  (or
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as zero_threading<ThreadingID>  ThreadingID))
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as one_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p1_17 := p1_15 &&
;   getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] p1_15 && getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
(push) ; 34
; [then-branch: 1634 | !(p1_15@871@01) | live]
; [else-branch: 1634 | p1_15@871@01 | live]
(push) ; 35
; [then-branch: 1634 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 35
(push) ; 35
; [else-branch: 1634 | p1_15@871@01]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 36
; [eval] _isDefined(id)
(push) ; 37
(pop) ; 37
; Joined path conditions
(pop) ; 36
; Joined path conditions
; [eval] zero_threading()
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(declare-const p1_17@1016@01 Bool)
(assert (=
  p1_17@1016@01
  (and
    p1_15@871@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_17 := p2_15 && getMethod_0(t_1_0) == zero_threading()
; [eval] p2_15 && getMethod_0(t_1_0) == zero_threading()
(push) ; 34
; [then-branch: 1635 | !(p2_15@872@01) | live]
; [else-branch: 1635 | p2_15@872@01 | live]
(push) ; 35
; [then-branch: 1635 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 35
(push) ; 35
; [else-branch: 1635 | p2_15@872@01]
; [eval] getMethod_0(t_1_0) == zero_threading()
; [eval] getMethod_0(t_1_0)
; [eval] zero_threading()
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(declare-const p2_17@1017@01 Bool)
(assert (=
  p2_17@1017@01
  (and
    p2_15@872@01
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as zero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_8 := p1_15 &&
;   !(getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
; [eval] p1_15 && !(getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
(push) ; 34
; [then-branch: 1636 | !(p1_15@871@01) | live]
; [else-branch: 1636 | p1_15@871@01 | live]
(push) ; 35
; [then-branch: 1636 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 35
(push) ; 35
; [else-branch: 1636 | p1_15@871@01]
; [eval] !(getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
; [eval] getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 36
; [eval] _isDefined(id)
(push) ; 37
(pop) ; 37
; Joined path conditions
(pop) ; 36
; Joined path conditions
; [eval] zero_threading()
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(declare-const p3_8@1018@01 Bool)
(assert (=
  p3_8@1018@01
  (and
    p1_15@871@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
        (as zero_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_8 := p2_15 && !(getMethod_0(t_1_0) == zero_threading())
; [eval] p2_15 && !(getMethod_0(t_1_0) == zero_threading())
(push) ; 34
; [then-branch: 1637 | !(p2_15@872@01) | live]
; [else-branch: 1637 | p2_15@872@01 | live]
(push) ; 35
; [then-branch: 1637 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 35
(push) ; 35
; [else-branch: 1637 | p2_15@872@01]
; [eval] !(getMethod_0(t_1_0) == zero_threading())
; [eval] getMethod_0(t_1_0) == zero_threading()
; [eval] getMethod_0(t_1_0)
; [eval] zero_threading()
(pop) ; 35
(pop) ; 34
; Joined path conditions
; Joined path conditions
(declare-const p4_8@1019@01 Bool)
(assert (=
  p4_8@1019@01
  (and
    p2_15@872@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_9@1010@01)
        (as zero_threading<ThreadingID>  ThreadingID))))))
(push) ; 34
(set-option :timeout 10)
(assert (not (not p1_17@1016@01)))
(check-sat)
; unknown
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 34
(set-option :timeout 10)
(assert (not p1_17@1016@01))
(check-sat)
; unsat
(pop) ; 34
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1638 | p1_17@1016@01 | live]
; [else-branch: 1638 | !(p1_17@1016@01) | dead]
(set-option :timeout 0)
(push) ; 34
; [then-branch: 1638 | p1_17@1016@01]
(assert p1_17@1016@01)
; [exec]
; thread_arg_3 := getArg(_checkDefined(t_1, 3235700), 0)
; [eval] getArg(_checkDefined(t_1, 3235700), 0)
; [eval] _checkDefined(t_1, 3235700)
(push) ; 35
; [eval] _isDefined(id)
(push) ; 36
(pop) ; 36
; Joined path conditions
(pop) ; 35
; Joined path conditions
(declare-const thread_arg_3@1020@01 $Ref)
(assert (=
  thread_arg_3@1020@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_8@961@01 3235700) 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_3), Cell())
(declare-const $t@1021@01 $Snap)
(assert (= $t@1021@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_3), Cell())
; [eval] typeof(thread_arg_3)
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_3@1020@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@1022@01 $Snap)
(assert (= $t@1022@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale true &&
;   (true &&
;   (acc(thread_arg_3.Cell_val, write) &&
;   issubtype(typeof(thread_arg_3.Cell_val), int())))
(set-option :timeout 0)
(push) ; 35
(set-option :timeout 10)
(assert (not (= tmp_7@937@01 thread_arg_3@1020@01)))
(check-sat)
; unsat
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [eval] issubtype(typeof(thread_arg_3.Cell_val), int())
; [eval] typeof(thread_arg_3.Cell_val)
(set-option :timeout 0)
(push) ; 35
(set-option :timeout 10)
(assert (not (= tmp_7@937@01 thread_arg_3@1020@01)))
(check-sat)
; unsat
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [eval] int()
(set-option :timeout 0)
(push) ; 35
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@954@01))))) (as int<PyType>  PyType)))
; [exec]
; inhale true ==>
;   _joinable(_checkDefined(t_1, 3235700)) &&
;   acc(_thread_post(_checkDefined(t_1, 3235700)), write)
(push) ; 35
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 35
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1639 | True | live]
; [else-branch: 1639 | False | dead]
(set-option :timeout 0)
(push) ; 35
; [then-branch: 1639 | True]
(declare-const $t@1023@01 $Snap)
(assert (= $t@1023@01 ($Snap.combine ($Snap.first $t@1023@01) ($Snap.second $t@1023@01))))
(assert (= ($Snap.first $t@1023@01) $Snap.unit))
; [eval] _joinable(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 36
; [eval] _isDefined(id)
(push) ; 37
(pop) ; 37
; Joined path conditions
(pop) ; 36
; Joined path conditions
(push) ; 36
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))
(pop) ; 36
; Joined path conditions
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))
(assert (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 36
; [eval] _isDefined(id)
(push) ; 37
(pop) ; 37
; Joined path conditions
(pop) ; 36
; Joined path conditions
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 36
(set-option :timeout 10)
(assert (not (not p2_17@1017@01)))
(check-sat)
; unsat
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1640 | p2_17@1017@01 | dead]
; [else-branch: 1640 | !(p2_17@1017@01) | live]
(set-option :timeout 0)
(push) ; 36
; [else-branch: 1640 | !(p2_17@1017@01)]
(assert (not p2_17@1017@01))
(pop) ; 36
; [eval] !p2_17
(push) ; 36
(set-option :timeout 10)
(assert (not p2_17@1017@01))
(check-sat)
; unknown
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 36
(set-option :timeout 10)
(assert (not (not p2_17@1017@01)))
(check-sat)
; unsat
(pop) ; 36
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1641 | !(p2_17@1017@01) | live]
; [else-branch: 1641 | p2_17@1017@01 | dead]
(set-option :timeout 0)
(push) ; 36
; [then-branch: 1641 | !(p2_17@1017@01)]
(assert (not p2_17@1017@01))
; [exec]
; p1_18 := p1_15 && getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] p1_15 && getMethod(_checkDefined(t_1, 3235700)) == one_threading()
(push) ; 37
; [then-branch: 1642 | !(p1_15@871@01) | live]
; [else-branch: 1642 | p1_15@871@01 | live]
(push) ; 38
; [then-branch: 1642 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 38
(push) ; 38
; [else-branch: 1642 | p1_15@871@01]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 39
; [eval] _isDefined(id)
(push) ; 40
(pop) ; 40
; Joined path conditions
(pop) ; 39
; Joined path conditions
; [eval] one_threading()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; Joined path conditions
(declare-const p1_18@1024@01 Bool)
(assert (=
  p1_18@1024@01
  (and
    p1_15@871@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as one_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_18 := p2_15 && getMethod_0(t_1_0) == one_threading()
; [eval] p2_15 && getMethod_0(t_1_0) == one_threading()
(push) ; 37
; [then-branch: 1643 | !(p2_15@872@01) | live]
; [else-branch: 1643 | p2_15@872@01 | live]
(push) ; 38
; [then-branch: 1643 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 38
(push) ; 38
; [else-branch: 1643 | p2_15@872@01]
; [eval] getMethod_0(t_1_0) == one_threading()
; [eval] getMethod_0(t_1_0)
; [eval] one_threading()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; Joined path conditions
(declare-const p2_18@1025@01 Bool)
(assert (=
  p2_18@1025@01
  (and
    p2_15@872@01
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as one_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_9 := p1_15 &&
;   !(getMethod(_checkDefined(t_1, 3235700)) == one_threading())
; [eval] p1_15 && !(getMethod(_checkDefined(t_1, 3235700)) == one_threading())
(push) ; 37
; [then-branch: 1644 | !(p1_15@871@01) | live]
; [else-branch: 1644 | p1_15@871@01 | live]
(push) ; 38
; [then-branch: 1644 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 38
(push) ; 38
; [else-branch: 1644 | p1_15@871@01]
; [eval] !(getMethod(_checkDefined(t_1, 3235700)) == one_threading())
; [eval] getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 39
; [eval] _isDefined(id)
(push) ; 40
(pop) ; 40
; Joined path conditions
(pop) ; 39
; Joined path conditions
; [eval] one_threading()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; Joined path conditions
(declare-const p3_9@1026@01 Bool)
(assert (=
  p3_9@1026@01
  (and
    p1_15@871@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
        (as one_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_9 := p2_15 && !(getMethod_0(t_1_0) == one_threading())
; [eval] p2_15 && !(getMethod_0(t_1_0) == one_threading())
(push) ; 37
; [then-branch: 1645 | !(p2_15@872@01) | live]
; [else-branch: 1645 | p2_15@872@01 | live]
(push) ; 38
; [then-branch: 1645 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 38
(push) ; 38
; [else-branch: 1645 | p2_15@872@01]
; [eval] !(getMethod_0(t_1_0) == one_threading())
; [eval] getMethod_0(t_1_0) == one_threading()
; [eval] getMethod_0(t_1_0)
; [eval] one_threading()
(pop) ; 38
(pop) ; 37
; Joined path conditions
; Joined path conditions
(declare-const p4_9@1027@01 Bool)
(assert (=
  p4_9@1027@01
  (and
    p2_15@872@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_9@1010@01)
        (as one_threading<ThreadingID>  ThreadingID))))))
(push) ; 37
(set-option :timeout 10)
(assert (not (not p1_18@1024@01)))
(check-sat)
; unsat
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1646 | p1_18@1024@01 | dead]
; [else-branch: 1646 | !(p1_18@1024@01) | live]
(set-option :timeout 0)
(push) ; 37
; [else-branch: 1646 | !(p1_18@1024@01)]
(assert (not p1_18@1024@01))
(pop) ; 37
; [eval] !p1_18
(push) ; 37
(set-option :timeout 10)
(assert (not p1_18@1024@01))
(check-sat)
; unknown
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 37
(set-option :timeout 10)
(assert (not (not p1_18@1024@01)))
(check-sat)
; unsat
(pop) ; 37
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1647 | !(p1_18@1024@01) | live]
; [else-branch: 1647 | p1_18@1024@01 | dead]
(set-option :timeout 0)
(push) ; 37
; [then-branch: 1647 | !(p1_18@1024@01)]
(assert (not p1_18@1024@01))
(push) ; 38
(set-option :timeout 10)
(assert (not (not p2_18@1025@01)))
(check-sat)
; unknown
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 38
(set-option :timeout 10)
(assert (not p2_18@1025@01))
(check-sat)
; unsat
(pop) ; 38
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1648 | p2_18@1025@01 | live]
; [else-branch: 1648 | !(p2_18@1025@01) | dead]
(set-option :timeout 0)
(push) ; 38
; [then-branch: 1648 | p2_18@1025@01]
(assert p2_18@1025@01)
; [exec]
; thread_arg_4_0 := getArg_0(t_1_0, 0)
; [eval] getArg_0(t_1_0, 0)
(declare-const thread_arg_4_0@1028@01 $Ref)
(assert (= thread_arg_4_0@1028@01 (getArg_0<Ref> tmp_9@1010@01 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_4_0), Cell())
(declare-const $t@1029@01 $Snap)
(assert (= $t@1029@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_4_0), Cell())
; [eval] typeof(thread_arg_4_0)
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_4_0@1028@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@1030@01 $Snap)
(assert (= $t@1030@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale true &&
;   (true &&
;   (acc(thread_arg_4_0.Cell_valp, write) &&
;   issubtype(typeof(thread_arg_4_0.Cell_valp), int())))
(set-option :timeout 0)
(push) ; 39
(set-option :timeout 10)
(assert (not (= tmp_7@937@01 thread_arg_4_0@1028@01)))
(check-sat)
; unsat
(pop) ; 39
; 0.00s
; (get-info :all-statistics)
; [eval] issubtype(typeof(thread_arg_4_0.Cell_valp), int())
; [eval] typeof(thread_arg_4_0.Cell_valp)
(set-option :timeout 0)
(push) ; 39
(set-option :timeout 10)
(assert (not (= tmp_7@937@01 thread_arg_4_0@1028@01)))
(check-sat)
; unsat
(pop) ; 39
; 0.00s
; (get-info :all-statistics)
; [eval] int()
(set-option :timeout 0)
(push) ; 39
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 39
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@954@01)))))) (as int<PyType>  PyType)))
; [exec]
; inhale true ==> _joinable(t_1_0) && acc(_thread_post_0(t_1_0), write)
(push) ; 39
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 39
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1649 | True | live]
; [else-branch: 1649 | False | dead]
(set-option :timeout 0)
(push) ; 39
; [then-branch: 1649 | True]
(declare-const $t@1031@01 $Snap)
(assert (= $t@1031@01 ($Snap.combine ($Snap.first $t@1031@01) ($Snap.second $t@1031@01))))
(assert (= ($Snap.first $t@1031@01) $Snap.unit))
; [eval] _joinable(t_1_0)
(push) ; 40
(assert (_joinable%precondition $Snap.unit tmp_9@1010@01))
(pop) ; 40
; Joined path conditions
(assert (_joinable%precondition $Snap.unit tmp_9@1010@01))
(assert (_joinable $Snap.unit tmp_9@1010@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 40
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 40
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1650 | p1_15@871@01 | live]
; [else-branch: 1650 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 40
; [then-branch: 1650 | p1_15@871@01]
; [exec]
; inhale (forperm
;     _r_29: Ref [_r_29.MustReleaseBounded] :: Level(_r_29) <
;     Level(_checkDefined(t_1, 3235700))) &&
;   ((forperm
;     _r_29: Ref [_r_29.MustReleaseUnbounded] :: Level(_r_29) <
;     Level(_checkDefined(t_1, 3235700))) &&
;   _residue_168 < Level(_checkDefined(t_1, 3235700)))
(declare-const $t@1032@01 $Snap)
(assert (= $t@1032@01 ($Snap.combine ($Snap.first $t@1032@01) ($Snap.second $t@1032@01))))
(assert (= ($Snap.first $t@1032@01) $Snap.unit))
; [eval] (forperm _r_29: Ref [_r_29.MustReleaseBounded] :: Level(_r_29) < Level(_checkDefined(t_1, 3235700)))
(assert (=
  ($Snap.second $t@1032@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1032@01))
    ($Snap.second ($Snap.second $t@1032@01)))))
(assert (= ($Snap.first ($Snap.second $t@1032@01)) $Snap.unit))
; [eval] (forperm _r_29: Ref [_r_29.MustReleaseUnbounded] :: Level(_r_29) < Level(_checkDefined(t_1, 3235700)))
(assert (= ($Snap.second ($Snap.second $t@1032@01)) $Snap.unit))
; [eval] _residue_168 < Level(_checkDefined(t_1, 3235700))
; [eval] Level(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 41
; [eval] _isDefined(id)
(push) ; 42
(pop) ; 42
; Joined path conditions
(pop) ; 41
; Joined path conditions
(push) ; 41
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))
(pop) ; 41
; Joined path conditions
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))
(assert (<
  _residue_168@877@01
  (Level $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 41
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 41
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1651 | p2_15@872@01 | live]
; [else-branch: 1651 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 41
; [then-branch: 1651 | p2_15@872@01]
; [exec]
; inhale (forperm
;     _r_29: Ref [_r_29.MustReleaseBoundedp] :: Level(_r_29) < Level(t_1_0)) &&
;   ((forperm
;     _r_29: Ref [_r_29.MustReleaseUnboundedp] :: Level(_r_29) < Level(t_1_0)) &&
;   _residue_168_0 < Level(t_1_0))
(declare-const $t@1033@01 $Snap)
(assert (= $t@1033@01 ($Snap.combine ($Snap.first $t@1033@01) ($Snap.second $t@1033@01))))
(assert (= ($Snap.first $t@1033@01) $Snap.unit))
; [eval] (forperm _r_29: Ref [_r_29.MustReleaseBoundedp] :: Level(_r_29) < Level(t_1_0))
(assert (=
  ($Snap.second $t@1033@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1033@01))
    ($Snap.second ($Snap.second $t@1033@01)))))
(assert (= ($Snap.first ($Snap.second $t@1033@01)) $Snap.unit))
; [eval] (forperm _r_29: Ref [_r_29.MustReleaseUnboundedp] :: Level(_r_29) < Level(t_1_0))
(assert (= ($Snap.second ($Snap.second $t@1033@01)) $Snap.unit))
; [eval] _residue_168_0 < Level(t_1_0)
; [eval] Level(t_1_0)
(push) ; 42
(assert (Level%precondition $Snap.unit tmp_9@1010@01))
(pop) ; 42
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_9@1010@01))
(assert (< _residue_168_0@878@01 (Level $Snap.unit tmp_9@1010@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert (p1_15 ==> _joinable(_checkDefined(t_1, 3235700))) &&
;   (p2_15 ==> _joinable(t_1_0))
; [eval] p1_15 ==> _joinable(_checkDefined(t_1, 3235700))
(set-option :timeout 0)
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1652 | p1_15@871@01 | live]
; [else-branch: 1652 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1652 | p1_15@871@01]
; [eval] _joinable(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 44
; [eval] _isDefined(id)
(push) ; 45
(pop) ; 45
; Joined path conditions
(pop) ; 44
; Joined path conditions
(push) ; 44
(pop) ; 44
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
(push) ; 42
(assert (not (=>
  p1_15@871@01
  (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_15@871@01
  (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700))))
; [eval] p2_15 ==> _joinable(t_1_0)
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1653 | p2_15@872@01 | live]
; [else-branch: 1653 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1653 | p2_15@872@01]
; [eval] _joinable(t_1_0)
(push) ; 44
(pop) ; 44
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
(push) ; 42
(assert (not (=> p2_15@872@01 (_joinable $Snap.unit tmp_9@1010@01))))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_15@872@01 (_joinable $Snap.unit tmp_9@1010@01)))
; [exec]
; assert (p1_15 ==>
;   (forperm
;     _r_30: Ref [_r_30.MustReleaseBounded] :: Level(_r_30) <
;     Level(_checkDefined(t_1, 3235700)))) &&
;   ((p2_15 ==>
;   (forperm
;     _r_30: Ref [_r_30.MustReleaseBoundedp] :: Level(_r_30) < Level(t_1_0))) &&
;   ((p1_15 ==>
;   (forperm
;     _r_30: Ref [_r_30.MustReleaseUnbounded] :: Level(_r_30) <
;     Level(_checkDefined(t_1, 3235700)))) &&
;   ((p2_15 ==>
;   (forperm
;     _r_30: Ref [_r_30.MustReleaseUnboundedp] :: Level(_r_30) < Level(t_1_0))) &&
;   ((p1_15 ==> _residue_168 < Level(_checkDefined(t_1, 3235700))) &&
;   (p2_15 ==> _residue_168_0 < Level(t_1_0))))))
; [eval] p1_15 ==> (forperm _r_30: Ref [_r_30.MustReleaseBounded] :: Level(_r_30) < Level(_checkDefined(t_1, 3235700)))
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1654 | p1_15@871@01 | live]
; [else-branch: 1654 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1654 | p1_15@871@01]
; [eval] (forperm _r_30: Ref [_r_30.MustReleaseBounded] :: Level(_r_30) < Level(_checkDefined(t_1, 3235700)))
(pop) ; 43
(pop) ; 42
; Joined path conditions
; [eval] p2_15 ==> (forperm _r_30: Ref [_r_30.MustReleaseBoundedp] :: Level(_r_30) < Level(t_1_0))
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1655 | p2_15@872@01 | live]
; [else-branch: 1655 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1655 | p2_15@872@01]
; [eval] (forperm _r_30: Ref [_r_30.MustReleaseBoundedp] :: Level(_r_30) < Level(t_1_0))
(pop) ; 43
(pop) ; 42
; Joined path conditions
; [eval] p1_15 ==> (forperm _r_30: Ref [_r_30.MustReleaseUnbounded] :: Level(_r_30) < Level(_checkDefined(t_1, 3235700)))
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1656 | p1_15@871@01 | live]
; [else-branch: 1656 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1656 | p1_15@871@01]
; [eval] (forperm _r_30: Ref [_r_30.MustReleaseUnbounded] :: Level(_r_30) < Level(_checkDefined(t_1, 3235700)))
(pop) ; 43
(pop) ; 42
; Joined path conditions
; [eval] p2_15 ==> (forperm _r_30: Ref [_r_30.MustReleaseUnboundedp] :: Level(_r_30) < Level(t_1_0))
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1657 | p2_15@872@01 | live]
; [else-branch: 1657 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1657 | p2_15@872@01]
; [eval] (forperm _r_30: Ref [_r_30.MustReleaseUnboundedp] :: Level(_r_30) < Level(t_1_0))
(pop) ; 43
(pop) ; 42
; Joined path conditions
; [eval] p1_15 ==> _residue_168 < Level(_checkDefined(t_1, 3235700))
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1658 | p1_15@871@01 | live]
; [else-branch: 1658 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1658 | p1_15@871@01]
; [eval] _residue_168 < Level(_checkDefined(t_1, 3235700))
; [eval] Level(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 44
; [eval] _isDefined(id)
(push) ; 45
(pop) ; 45
; Joined path conditions
(pop) ; 44
; Joined path conditions
(push) ; 44
(pop) ; 44
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
(push) ; 42
(assert (not (=>
  p1_15@871@01
  (<
    _residue_168@877@01
    (Level $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700))))))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_15@871@01
  (<
    _residue_168@877@01
    (Level $Snap.unit (_checkDefined $Snap.unit tmp_8@961@01 3235700)))))
; [eval] p2_15 ==> _residue_168_0 < Level(t_1_0)
(push) ; 42
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1659 | p2_15@872@01 | live]
; [else-branch: 1659 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1659 | p2_15@872@01]
; [eval] _residue_168_0 < Level(t_1_0)
; [eval] Level(t_1_0)
(push) ; 44
(pop) ; 44
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
(push) ; 42
(assert (not (=> p2_15@872@01 (< _residue_168_0@878@01 (Level $Snap.unit tmp_9@1010@01)))))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_15@872@01 (< _residue_168_0@878@01 (Level $Snap.unit tmp_9@1010@01))))
; [exec]
; p1_19 := p1_15 &&
;   (perm(_thread_post(_checkDefined(t_1, 3235700))) > none &&
;   getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
; [eval] p1_15 && (perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
(push) ; 42
; [then-branch: 1660 | !(p1_15@871@01) | live]
; [else-branch: 1660 | p1_15@871@01 | live]
(push) ; 43
; [then-branch: 1660 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 43
(push) ; 43
; [else-branch: 1660 | p1_15@871@01]
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 44
; [eval] _isDefined(id)
(push) ; 45
(pop) ; 45
; Joined path conditions
(pop) ; 44
; Joined path conditions
(push) ; 44
; [then-branch: 1661 | False | live]
; [else-branch: 1661 | True | live]
(push) ; 45
; [then-branch: 1661 | False]
(assert false)
(pop) ; 45
(push) ; 45
; [else-branch: 1661 | True]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 46
; [eval] _isDefined(id)
(push) ; 47
(pop) ; 47
; Joined path conditions
(pop) ; 46
; Joined path conditions
; [eval] zero_threading()
(pop) ; 45
(pop) ; 44
; Joined path conditions
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
; Joined path conditions
(declare-const p1_19@1034@01 Bool)
(assert (=
  p1_19@1034@01
  (and
    p1_15@871@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as zero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_19 := p2_15 &&
;   (perm(_thread_post_0(t_1_0)) > none &&
;   getMethod_0(t_1_0) == zero_threading())
; [eval] p2_15 && (perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == zero_threading())
(push) ; 42
; [then-branch: 1662 | !(p2_15@872@01) | live]
; [else-branch: 1662 | p2_15@872@01 | live]
(push) ; 43
; [then-branch: 1662 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 43
(push) ; 43
; [else-branch: 1662 | p2_15@872@01]
; [eval] perm(_thread_post_0(t_1_0)) > none
; [eval] perm(_thread_post_0(t_1_0))
(push) ; 44
; [then-branch: 1663 | False | live]
; [else-branch: 1663 | True | live]
(push) ; 45
; [then-branch: 1663 | False]
(assert false)
(pop) ; 45
(push) ; 45
; [else-branch: 1663 | True]
; [eval] getMethod_0(t_1_0) == zero_threading()
; [eval] getMethod_0(t_1_0)
; [eval] zero_threading()
(pop) ; 45
(pop) ; 44
; Joined path conditions
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
; Joined path conditions
(declare-const p2_19@1035@01 Bool)
(assert (=
  p2_19@1035@01
  (and
    p2_15@872@01
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as zero_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_10 := p1_15 &&
;   !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none &&
;   getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
; [eval] p1_15 && !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
(push) ; 42
; [then-branch: 1664 | !(p1_15@871@01) | live]
; [else-branch: 1664 | p1_15@871@01 | live]
(push) ; 43
; [then-branch: 1664 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 43
(push) ; 43
; [else-branch: 1664 | p1_15@871@01]
; [eval] !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == zero_threading())
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 44
; [eval] _isDefined(id)
(push) ; 45
(pop) ; 45
; Joined path conditions
(pop) ; 44
; Joined path conditions
(push) ; 44
; [then-branch: 1665 | False | live]
; [else-branch: 1665 | True | live]
(push) ; 45
; [then-branch: 1665 | False]
(assert false)
(pop) ; 45
(push) ; 45
; [else-branch: 1665 | True]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == zero_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 46
; [eval] _isDefined(id)
(push) ; 47
(pop) ; 47
; Joined path conditions
(pop) ; 46
; Joined path conditions
; [eval] zero_threading()
(pop) ; 45
(pop) ; 44
; Joined path conditions
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
; Joined path conditions
(declare-const p3_10@1036@01 Bool)
(assert (=
  p3_10@1036@01
  (and
    p1_15@871@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
        (as zero_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_10 := p2_15 &&
;   !(perm(_thread_post_0(t_1_0)) > none &&
;   getMethod_0(t_1_0) == zero_threading())
; [eval] p2_15 && !(perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == zero_threading())
(push) ; 42
; [then-branch: 1666 | !(p2_15@872@01) | live]
; [else-branch: 1666 | p2_15@872@01 | live]
(push) ; 43
; [then-branch: 1666 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 43
(push) ; 43
; [else-branch: 1666 | p2_15@872@01]
; [eval] !(perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == zero_threading())
; [eval] perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == zero_threading()
; [eval] perm(_thread_post_0(t_1_0)) > none
; [eval] perm(_thread_post_0(t_1_0))
(push) ; 44
; [then-branch: 1667 | False | live]
; [else-branch: 1667 | True | live]
(push) ; 45
; [then-branch: 1667 | False]
(assert false)
(pop) ; 45
(push) ; 45
; [else-branch: 1667 | True]
; [eval] getMethod_0(t_1_0) == zero_threading()
; [eval] getMethod_0(t_1_0)
; [eval] zero_threading()
(pop) ; 45
(pop) ; 44
; Joined path conditions
; Joined path conditions
(pop) ; 43
(pop) ; 42
; Joined path conditions
; Joined path conditions
(declare-const p4_10@1037@01 Bool)
(assert (=
  p4_10@1037@01
  (and
    p2_15@872@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_9@1010@01)
        (as zero_threading<ThreadingID>  ThreadingID))))))
(push) ; 42
(set-option :timeout 10)
(assert (not (not p1_19@1034@01)))
(check-sat)
; unknown
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 42
(set-option :timeout 10)
(assert (not p1_19@1034@01))
(check-sat)
; unsat
(pop) ; 42
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1668 | p1_19@1034@01 | live]
; [else-branch: 1668 | !(p1_19@1034@01) | dead]
(set-option :timeout 0)
(push) ; 42
; [then-branch: 1668 | p1_19@1034@01]
(assert p1_19@1034@01)
; [exec]
; thread_arg_5 := getArg(_checkDefined(t_1, 3235700), 0)
; [eval] getArg(_checkDefined(t_1, 3235700), 0)
; [eval] _checkDefined(t_1, 3235700)
(push) ; 43
; [eval] _isDefined(id)
(push) ; 44
(pop) ; 44
; Joined path conditions
(pop) ; 43
; Joined path conditions
(declare-const thread_arg_5@1038@01 $Ref)
(assert (=
  thread_arg_5@1038@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_8@961@01 3235700) 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_5), Cell())
(declare-const $t@1039@01 $Snap)
(assert (= $t@1039@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_5), Cell())
; [eval] typeof(thread_arg_5)
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_5@1038@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_19@1035@01)))
(check-sat)
; unsat
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1669 | p2_19@1035@01 | dead]
; [else-branch: 1669 | !(p2_19@1035@01) | live]
(set-option :timeout 0)
(push) ; 43
; [else-branch: 1669 | !(p2_19@1035@01)]
(assert (not p2_19@1035@01))
(pop) ; 43
; [eval] !p2_19
(push) ; 43
(set-option :timeout 10)
(assert (not p2_19@1035@01))
(check-sat)
; unknown
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 43
(set-option :timeout 10)
(assert (not (not p2_19@1035@01)))
(check-sat)
; unsat
(pop) ; 43
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1670 | !(p2_19@1035@01) | live]
; [else-branch: 1670 | p2_19@1035@01 | dead]
(set-option :timeout 0)
(push) ; 43
; [then-branch: 1670 | !(p2_19@1035@01)]
(assert (not p2_19@1035@01))
; [exec]
; inhale (p1_19 ==> true) &&
;   ((p2_19 ==> true) &&
;   ((p1_19 ==>
;   acc(thread_arg_5.Cell_val, write *
;   perm(_thread_post(_checkDefined(t_1, 3235700))))) &&
;   ((p2_19 ==>
;   acc(thread_arg_5_0.Cell_valp, write * perm(_thread_post_0(t_1_0)))) &&
;   ((p1_19 ==> issubtype(typeof(thread_arg_5.Cell_val), int())) &&
;   (p2_19 ==> issubtype(typeof(thread_arg_5_0.Cell_valp), int())))) &&
;   (p1_19 && p2_19 ==> thread_arg_5.Cell_val == thread_arg_5_0.Cell_valp)))
(declare-const $t@1040@01 $Snap)
(assert (= $t@1040@01 ($Snap.combine ($Snap.first $t@1040@01) ($Snap.second $t@1040@01))))
(assert (= ($Snap.first $t@1040@01) $Snap.unit))
; [eval] p1_19 ==> true
(push) ; 44
(push) ; 45
(set-option :timeout 10)
(assert (not (not p1_19@1034@01)))
(check-sat)
; unknown
(pop) ; 45
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1671 | p1_19@1034@01 | live]
; [else-branch: 1671 | !(p1_19@1034@01) | dead]
(set-option :timeout 0)
(push) ; 45
; [then-branch: 1671 | p1_19@1034@01]
(pop) ; 45
(pop) ; 44
; Joined path conditions
(assert (=
  ($Snap.second $t@1040@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1040@01))
    ($Snap.second ($Snap.second $t@1040@01)))))
(assert (= ($Snap.first ($Snap.second $t@1040@01)) $Snap.unit))
; [eval] p2_19 ==> true
(push) ; 44
; [then-branch: 1672 | p2_19@1035@01 | dead]
; [else-branch: 1672 | !(p2_19@1035@01) | live]
(push) ; 45
; [else-branch: 1672 | !(p2_19@1035@01)]
(pop) ; 45
(pop) ; 44
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1040@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1040@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1040@01))))))
(push) ; 44
(set-option :timeout 10)
(assert (not (not p1_19@1034@01)))
(check-sat)
; unknown
(pop) ; 44
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1673 | p1_19@1034@01 | live]
; [else-branch: 1673 | !(p1_19@1034@01) | dead]
(set-option :timeout 0)
(push) ; 44
; [then-branch: 1673 | p1_19@1034@01]
; [eval] write * perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 45
; [eval] _isDefined(id)
(push) ; 46
(pop) ; 46
; Joined path conditions
(pop) ; 45
; Joined path conditions
(assert (not (= thread_arg_5@1038@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1040@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1040@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1040@01)))))))
; [then-branch: 1674 | p2_19@1035@01 | dead]
; [else-branch: 1674 | !(p2_19@1035@01) | live]
(push) ; 45
; [else-branch: 1674 | !(p2_19@1035@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1040@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1040@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1040@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1040@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1040@01)))))
  $Snap.unit))
; [eval] p1_19 ==> issubtype(typeof(thread_arg_5.Cell_val), int())
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not p1_19@1034@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1675 | p1_19@1034@01 | live]
; [else-branch: 1675 | !(p1_19@1034@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1675 | p1_19@1034@01]
; [eval] issubtype(typeof(thread_arg_5.Cell_val), int())
; [eval] typeof(thread_arg_5.Cell_val)
; [eval] int()
(pop) ; 47
(pop) ; 46
; Joined path conditions
(assert (=>
  p1_19@1034@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1040@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1040@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1040@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1040@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1040@01))))))
  $Snap.unit))
; [eval] p2_19 ==> issubtype(typeof(thread_arg_5_0.Cell_valp), int())
(push) ; 46
; [then-branch: 1676 | p2_19@1035@01 | dead]
; [else-branch: 1676 | !(p2_19@1035@01) | live]
(push) ; 47
; [else-branch: 1676 | !(p2_19@1035@01)]
(pop) ; 47
(pop) ; 46
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1040@01))))))
  $Snap.unit))
; [eval] p1_19 && p2_19 ==> thread_arg_5.Cell_val == thread_arg_5_0.Cell_valp
; [eval] p1_19 && p2_19
(push) ; 46
; [then-branch: 1677 | !(p1_19@1034@01) | live]
; [else-branch: 1677 | p1_19@1034@01 | live]
(push) ; 47
; [then-branch: 1677 | !(p1_19@1034@01)]
(assert (not p1_19@1034@01))
(pop) ; 47
(push) ; 47
; [else-branch: 1677 | p1_19@1034@01]
(pop) ; 47
(pop) ; 46
; Joined path conditions
; Joined path conditions
(assert (or p1_19@1034@01 (not p1_19@1034@01)))
(push) ; 46
(push) ; 47
(set-option :timeout 10)
(assert (not (not (and p1_19@1034@01 p2_19@1035@01))))
(check-sat)
; unsat
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1678 | p1_19@1034@01 && p2_19@1035@01 | dead]
; [else-branch: 1678 | !(p1_19@1034@01 && p2_19@1035@01) | live]
(set-option :timeout 0)
(push) ; 47
; [else-branch: 1678 | !(p1_19@1034@01 && p2_19@1035@01)]
(assert (not (and p1_19@1034@01 p2_19@1035@01)))
(pop) ; 47
(pop) ; 46
; Joined path conditions
(assert (not (and p1_19@1034@01 p2_19@1035@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; p1_20 := p1_15 &&
;   (perm(_thread_post(_checkDefined(t_1, 3235700))) > none &&
;   getMethod(_checkDefined(t_1, 3235700)) == one_threading())
; [eval] p1_15 && (perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == one_threading())
(set-option :timeout 0)
(push) ; 46
; [then-branch: 1679 | !(p1_15@871@01) | live]
; [else-branch: 1679 | p1_15@871@01 | live]
(push) ; 47
; [then-branch: 1679 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 47
(push) ; 47
; [else-branch: 1679 | p1_15@871@01]
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 48
; [eval] _isDefined(id)
(push) ; 49
(pop) ; 49
; Joined path conditions
(pop) ; 48
; Joined path conditions
(push) ; 48
; [then-branch: 1680 | False | live]
; [else-branch: 1680 | True | live]
(push) ; 49
; [then-branch: 1680 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1680 | True]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 50
; [eval] _isDefined(id)
(push) ; 51
(pop) ; 51
; Joined path conditions
(pop) ; 50
; Joined path conditions
; [eval] one_threading()
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
; Joined path conditions
(declare-const p1_20@1041@01 Bool)
(assert (=
  p1_20@1041@01
  (and
    p1_15@871@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
      (as one_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_20 := p2_15 &&
;   (perm(_thread_post_0(t_1_0)) > none &&
;   getMethod_0(t_1_0) == one_threading())
; [eval] p2_15 && (perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == one_threading())
(push) ; 46
; [then-branch: 1681 | !(p2_15@872@01) | live]
; [else-branch: 1681 | p2_15@872@01 | live]
(push) ; 47
; [then-branch: 1681 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 47
(push) ; 47
; [else-branch: 1681 | p2_15@872@01]
; [eval] perm(_thread_post_0(t_1_0)) > none
; [eval] perm(_thread_post_0(t_1_0))
(push) ; 48
; [then-branch: 1682 | False | live]
; [else-branch: 1682 | True | live]
(push) ; 49
; [then-branch: 1682 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1682 | True]
; [eval] getMethod_0(t_1_0) == one_threading()
; [eval] getMethod_0(t_1_0)
; [eval] one_threading()
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
; Joined path conditions
(declare-const p2_20@1042@01 Bool)
(assert (=
  p2_20@1042@01
  (and
    p2_15@872@01
    (=
      (getMethod_0<ThreadingID> tmp_9@1010@01)
      (as one_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_11 := p1_15 &&
;   !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none &&
;   getMethod(_checkDefined(t_1, 3235700)) == one_threading())
; [eval] p1_15 && !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == one_threading())
(push) ; 46
; [then-branch: 1683 | !(p1_15@871@01) | live]
; [else-branch: 1683 | p1_15@871@01 | live]
(push) ; 47
; [then-branch: 1683 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 47
(push) ; 47
; [else-branch: 1683 | p1_15@871@01]
; [eval] !(perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == one_threading())
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none && getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700))) > none
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 48
; [eval] _isDefined(id)
(push) ; 49
(pop) ; 49
; Joined path conditions
(pop) ; 48
; Joined path conditions
(push) ; 48
; [then-branch: 1684 | False | live]
; [else-branch: 1684 | True | live]
(push) ; 49
; [then-branch: 1684 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1684 | True]
; [eval] getMethod(_checkDefined(t_1, 3235700)) == one_threading()
; [eval] getMethod(_checkDefined(t_1, 3235700))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 50
; [eval] _isDefined(id)
(push) ; 51
(pop) ; 51
; Joined path conditions
(pop) ; 50
; Joined path conditions
; [eval] one_threading()
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
; Joined path conditions
(declare-const p3_11@1043@01 Bool)
(assert (=
  p3_11@1043@01
  (and
    p1_15@871@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_8@961@01 3235700))
        (as one_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_11 := p2_15 &&
;   !(perm(_thread_post_0(t_1_0)) > none &&
;   getMethod_0(t_1_0) == one_threading())
; [eval] p2_15 && !(perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == one_threading())
(push) ; 46
; [then-branch: 1685 | !(p2_15@872@01) | live]
; [else-branch: 1685 | p2_15@872@01 | live]
(push) ; 47
; [then-branch: 1685 | !(p2_15@872@01)]
(assert (not p2_15@872@01))
(pop) ; 47
(push) ; 47
; [else-branch: 1685 | p2_15@872@01]
; [eval] !(perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == one_threading())
; [eval] perm(_thread_post_0(t_1_0)) > none && getMethod_0(t_1_0) == one_threading()
; [eval] perm(_thread_post_0(t_1_0)) > none
; [eval] perm(_thread_post_0(t_1_0))
(push) ; 48
; [then-branch: 1686 | False | live]
; [else-branch: 1686 | True | live]
(push) ; 49
; [then-branch: 1686 | False]
(assert false)
(pop) ; 49
(push) ; 49
; [else-branch: 1686 | True]
; [eval] getMethod_0(t_1_0) == one_threading()
; [eval] getMethod_0(t_1_0)
; [eval] one_threading()
(pop) ; 49
(pop) ; 48
; Joined path conditions
; Joined path conditions
(pop) ; 47
(pop) ; 46
; Joined path conditions
; Joined path conditions
(declare-const p4_11@1044@01 Bool)
(assert (=
  p4_11@1044@01
  (and
    p2_15@872@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_9@1010@01)
        (as one_threading<ThreadingID>  ThreadingID))))))
(push) ; 46
(set-option :timeout 10)
(assert (not (not p1_20@1041@01)))
(check-sat)
; unsat
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1687 | p1_20@1041@01 | dead]
; [else-branch: 1687 | !(p1_20@1041@01) | live]
(set-option :timeout 0)
(push) ; 46
; [else-branch: 1687 | !(p1_20@1041@01)]
(assert (not p1_20@1041@01))
(pop) ; 46
; [eval] !p1_20
(push) ; 46
(set-option :timeout 10)
(assert (not p1_20@1041@01))
(check-sat)
; unknown
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 46
(set-option :timeout 10)
(assert (not (not p1_20@1041@01)))
(check-sat)
; unsat
(pop) ; 46
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1688 | !(p1_20@1041@01) | live]
; [else-branch: 1688 | p1_20@1041@01 | dead]
(set-option :timeout 0)
(push) ; 46
; [then-branch: 1688 | !(p1_20@1041@01)]
(assert (not p1_20@1041@01))
(push) ; 47
(set-option :timeout 10)
(assert (not (not p2_20@1042@01)))
(check-sat)
; unknown
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 47
(set-option :timeout 10)
(assert (not p2_20@1042@01))
(check-sat)
; unsat
(pop) ; 47
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1689 | p2_20@1042@01 | live]
; [else-branch: 1689 | !(p2_20@1042@01) | dead]
(set-option :timeout 0)
(push) ; 47
; [then-branch: 1689 | p2_20@1042@01]
(assert p2_20@1042@01)
; [exec]
; thread_arg_6_0 := getArg_0(t_1_0, 0)
; [eval] getArg_0(t_1_0, 0)
(declare-const thread_arg_6_0@1045@01 $Ref)
(assert (= thread_arg_6_0@1045@01 (getArg_0<Ref> tmp_9@1010@01 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_6_0), Cell())
(declare-const $t@1046@01 $Snap)
(assert (= $t@1046@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_6_0), Cell())
; [eval] typeof(thread_arg_6_0)
; [eval] Cell()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_6_0@1045@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (p1_20 ==> true) &&
;   ((p2_20 ==> true) &&
;   ((p1_20 ==>
;   acc(thread_arg_6.Cell_val, write *
;   perm(_thread_post(_checkDefined(t_1, 3235700))))) &&
;   ((p2_20 ==>
;   acc(thread_arg_6_0.Cell_valp, write * perm(_thread_post_0(t_1_0)))) &&
;   ((p1_20 ==> issubtype(typeof(thread_arg_6.Cell_val), int())) &&
;   (p2_20 ==> issubtype(typeof(thread_arg_6_0.Cell_valp), int())))) &&
;   (p1_20 && p2_20 ==> thread_arg_6.Cell_val == thread_arg_6_0.Cell_valp)))
(declare-const $t@1047@01 $Snap)
(assert (= $t@1047@01 ($Snap.combine ($Snap.first $t@1047@01) ($Snap.second $t@1047@01))))
(assert (= ($Snap.first $t@1047@01) $Snap.unit))
; [eval] p1_20 ==> true
(set-option :timeout 0)
(push) ; 48
; [then-branch: 1690 | p1_20@1041@01 | dead]
; [else-branch: 1690 | !(p1_20@1041@01) | live]
(push) ; 49
; [else-branch: 1690 | !(p1_20@1041@01)]
(pop) ; 49
(pop) ; 48
; Joined path conditions
(assert (=
  ($Snap.second $t@1047@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1047@01))
    ($Snap.second ($Snap.second $t@1047@01)))))
(assert (= ($Snap.first ($Snap.second $t@1047@01)) $Snap.unit))
; [eval] p2_20 ==> true
(push) ; 48
(push) ; 49
(set-option :timeout 10)
(assert (not (not p2_20@1042@01)))
(check-sat)
; unknown
(pop) ; 49
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1691 | p2_20@1042@01 | live]
; [else-branch: 1691 | !(p2_20@1042@01) | dead]
(set-option :timeout 0)
(push) ; 49
; [then-branch: 1691 | p2_20@1042@01]
(pop) ; 49
(pop) ; 48
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1047@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1047@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1047@01))))))
; [then-branch: 1692 | p1_20@1041@01 | dead]
; [else-branch: 1692 | !(p1_20@1041@01) | live]
(push) ; 48
; [else-branch: 1692 | !(p1_20@1041@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1047@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1047@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))))))
(push) ; 49
(set-option :timeout 10)
(assert (not (not p2_20@1042@01)))
(check-sat)
; unknown
(pop) ; 49
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1693 | p2_20@1042@01 | live]
; [else-branch: 1693 | !(p2_20@1042@01) | dead]
(set-option :timeout 0)
(push) ; 49
; [then-branch: 1693 | p2_20@1042@01]
; [eval] write * perm(_thread_post_0(t_1_0))
; [eval] perm(_thread_post_0(t_1_0))
(assert (not (= thread_arg_6_0@1045@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1047@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1047@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))))
  $Snap.unit))
; [eval] p1_20 ==> issubtype(typeof(thread_arg_6.Cell_val), int())
(push) ; 50
; [then-branch: 1694 | p1_20@1041@01 | dead]
; [else-branch: 1694 | !(p1_20@1041@01) | live]
(push) ; 51
; [else-branch: 1694 | !(p1_20@1041@01)]
(pop) ; 51
(pop) ; 50
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1047@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1047@01))))))
  $Snap.unit))
; [eval] p2_20 ==> issubtype(typeof(thread_arg_6_0.Cell_valp), int())
(push) ; 50
(push) ; 51
(set-option :timeout 10)
(assert (not (not p2_20@1042@01)))
(check-sat)
; unknown
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1695 | p2_20@1042@01 | live]
; [else-branch: 1695 | !(p2_20@1042@01) | dead]
(set-option :timeout 0)
(push) ; 51
; [then-branch: 1695 | p2_20@1042@01]
; [eval] issubtype(typeof(thread_arg_6_0.Cell_valp), int())
; [eval] typeof(thread_arg_6_0.Cell_valp)
; [eval] int()
(pop) ; 51
(pop) ; 50
; Joined path conditions
(assert (=>
  p2_20@1042@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1047@01))))))
  $Snap.unit))
; [eval] p1_20 && p2_20 ==> thread_arg_6.Cell_val == thread_arg_6_0.Cell_valp
; [eval] p1_20 && p2_20
(push) ; 50
; [then-branch: 1696 | !(p1_20@1041@01) | live]
; [else-branch: 1696 | p1_20@1041@01 | live]
(push) ; 51
; [then-branch: 1696 | !(p1_20@1041@01)]
(pop) ; 51
(push) ; 51
; [else-branch: 1696 | p1_20@1041@01]
(assert p1_20@1041@01)
(pop) ; 51
(pop) ; 50
; Joined path conditions
; Joined path conditions
(assert (or p1_20@1041@01 (not p1_20@1041@01)))
(push) ; 50
(push) ; 51
(set-option :timeout 10)
(assert (not (not (and p1_20@1041@01 p2_20@1042@01))))
(check-sat)
; unsat
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1697 | p1_20@1041@01 && p2_20@1042@01 | dead]
; [else-branch: 1697 | !(p1_20@1041@01 && p2_20@1042@01) | live]
(set-option :timeout 0)
(push) ; 51
; [else-branch: 1697 | !(p1_20@1041@01 && p2_20@1042@01)]
(assert (not (and p1_20@1041@01 p2_20@1042@01)))
(pop) ; 51
(pop) ; 50
; Joined path conditions
(assert (not (and p1_20@1041@01 p2_20@1042@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 50
(set-option :timeout 10)
(assert (not (not p1_15@871@01)))
(check-sat)
; unknown
(pop) ; 50
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1698 | p1_15@871@01 | live]
; [else-branch: 1698 | !(p1_15@871@01) | dead]
(set-option :timeout 0)
(push) ; 50
; [then-branch: 1698 | p1_15@871@01]
; [exec]
; exhale acc(_thread_post(_checkDefined(t_1, 3235700)), perm(_thread_post(_checkDefined(t_1,
;   3235700))))
; [eval] perm(_thread_post(_checkDefined(t_1, 3235700)))
; [eval] _checkDefined(t_1, 3235700)
(push) ; 51
; [eval] _isDefined(id)
(push) ; 52
(pop) ; 52
; Joined path conditions
(pop) ; 51
; Joined path conditions
; [eval] _checkDefined(t_1, 3235700)
(push) ; 51
; [eval] _isDefined(id)
(push) ; 52
(pop) ; 52
; Joined path conditions
(pop) ; 51
; Joined path conditions
(push) ; 51
(set-option :timeout 10)
(assert (not (not p2_15@872@01)))
(check-sat)
; unknown
(pop) ; 51
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1699 | p2_15@872@01 | live]
; [else-branch: 1699 | !(p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 51
; [then-branch: 1699 | p2_15@872@01]
; [exec]
; exhale acc(_thread_post_0(t_1_0), perm(_thread_post_0(t_1_0)))
; [eval] perm(_thread_post_0(t_1_0))
; [exec]
; assert p1_15 && p2_15 ==>
;   _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] p1_15 && p2_15 ==> _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] p1_15 && p2_15
(push) ; 52
; [then-branch: 1700 | !(p1_15@871@01) | live]
; [else-branch: 1700 | p1_15@871@01 | live]
(push) ; 53
; [then-branch: 1700 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
(pop) ; 53
(push) ; 53
; [else-branch: 1700 | p1_15@871@01]
(pop) ; 53
(pop) ; 52
; Joined path conditions
; Joined path conditions
(push) ; 52
(push) ; 53
(set-option :timeout 10)
(assert (not (not (and p1_15@871@01 p2_15@872@01))))
(check-sat)
; unknown
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 53
(set-option :timeout 10)
(assert (not (and p1_15@871@01 p2_15@872@01)))
(check-sat)
; unsat
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1701 | p1_15@871@01 && p2_15@872@01 | live]
; [else-branch: 1701 | !(p1_15@871@01 && p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 53
; [then-branch: 1701 | p1_15@871@01 && p2_15@872@01]
(assert (and p1_15@871@01 p2_15@872@01))
; [eval] _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] _checkDefined(c_1, 3235683)
(push) ; 54
; [eval] _isDefined(id)
(push) ; 55
(pop) ; 55
; Joined path conditions
(pop) ; 54
; Joined path conditions
(push) ; 54
(set-option :timeout 10)
(assert (not (= thread_arg_5@1038@01 (_checkDefined $Snap.unit tmp_7@937@01 3235683))))
(check-sat)
; unsat
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 54
(set-option :timeout 10)
(assert (not (= thread_arg_6_0@1045@01 tmp_7@937@01)))
(check-sat)
; unsat
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
(pop) ; 53
(pop) ; 52
; Joined path conditions
(assert (and p1_15@871@01 p2_15@872@01))
(set-option :timeout 0)
(push) ; 52
(assert (not (=>
  (and p1_15@871@01 p2_15@872@01)
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1040@01))))
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))))))))
(check-sat)
; unknown
(pop) ; 52
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_15 && p2_15 ==> _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] p1_15 && p2_15
(set-option :timeout 0)
(push) ; 52
; [then-branch: 1702 | !(p1_15@871@01) | live]
; [else-branch: 1702 | p1_15@871@01 | live]
(push) ; 53
; [then-branch: 1702 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unsat
(pop) ; 53
(set-option :timeout 0)
(push) ; 53
; [else-branch: 1702 | p1_15@871@01]
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 53
(pop) ; 52
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 52
(push) ; 53
(set-option :timeout 10)
(assert (not (not (and p1_15@871@01 p2_15@872@01))))
(check-sat)
; unknown
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 53
(set-option :timeout 10)
(assert (not (and p1_15@871@01 p2_15@872@01)))
(check-sat)
; unsat
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1703 | p1_15@871@01 && p2_15@872@01 | live]
; [else-branch: 1703 | !(p1_15@871@01 && p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 53
; [then-branch: 1703 | p1_15@871@01 && p2_15@872@01]
(assert (and p1_15@871@01 p2_15@872@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] _checkDefined(c_1, 3235683)
(set-option :timeout 0)
(push) ; 54
; [eval] _isDefined(id)
(push) ; 55
(pop) ; 55
; Joined path conditions
(pop) ; 54
; Joined path conditions
(push) ; 54
(set-option :timeout 10)
(assert (not (= thread_arg_5@1038@01 (_checkDefined $Snap.unit tmp_7@937@01 3235683))))
(check-sat)
; unsat
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 54
(set-option :timeout 10)
(assert (not (= thread_arg_6_0@1045@01 tmp_7@937@01)))
(check-sat)
; unsat
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
(pop) ; 53
(pop) ; 52
; Joined path conditions
(assert (and p1_15@871@01 p2_15@872@01))
(set-option :timeout 0)
(push) ; 52
(assert (not (=>
  (and p1_15@871@01 p2_15@872@01)
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1040@01))))
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))))))))
(check-sat)
; unknown
(pop) ; 52
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_15 && p2_15 ==> _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] p1_15 && p2_15
(set-option :timeout 0)
(push) ; 52
; [then-branch: 1704 | !(p1_15@871@01) | live]
; [else-branch: 1704 | p1_15@871@01 | live]
(push) ; 53
; [then-branch: 1704 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unsat
(pop) ; 53
(set-option :timeout 0)
(push) ; 53
; [else-branch: 1704 | p1_15@871@01]
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 53
(pop) ; 52
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 52
(push) ; 53
(set-option :timeout 10)
(assert (not (not (and p1_15@871@01 p2_15@872@01))))
(check-sat)
; unknown
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 53
(set-option :timeout 10)
(assert (not (and p1_15@871@01 p2_15@872@01)))
(check-sat)
; unsat
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1705 | p1_15@871@01 && p2_15@872@01 | live]
; [else-branch: 1705 | !(p1_15@871@01 && p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 53
; [then-branch: 1705 | p1_15@871@01 && p2_15@872@01]
(assert (and p1_15@871@01 p2_15@872@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] _checkDefined(c_1, 3235683)
(set-option :timeout 0)
(push) ; 54
; [eval] _isDefined(id)
(push) ; 55
(pop) ; 55
; Joined path conditions
(pop) ; 54
; Joined path conditions
(push) ; 54
(set-option :timeout 10)
(assert (not (= thread_arg_5@1038@01 (_checkDefined $Snap.unit tmp_7@937@01 3235683))))
(check-sat)
; unsat
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 54
(set-option :timeout 10)
(assert (not (= thread_arg_6_0@1045@01 tmp_7@937@01)))
(check-sat)
; unsat
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
(pop) ; 53
(pop) ; 52
; Joined path conditions
(assert (and p1_15@871@01 p2_15@872@01))
(set-option :timeout 0)
(push) ; 52
(assert (not (=>
  (and p1_15@871@01 p2_15@872@01)
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1040@01))))
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))))))))
(check-sat)
; unknown
(pop) ; 52
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_15 && p2_15 ==> _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] p1_15 && p2_15
(set-option :timeout 0)
(push) ; 52
; [then-branch: 1706 | !(p1_15@871@01) | live]
; [else-branch: 1706 | p1_15@871@01 | live]
(push) ; 53
; [then-branch: 1706 | !(p1_15@871@01)]
(assert (not p1_15@871@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unsat
(pop) ; 53
(set-option :timeout 0)
(push) ; 53
; [else-branch: 1706 | p1_15@871@01]
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 53
(pop) ; 52
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 52
(push) ; 53
(set-option :timeout 10)
(assert (not (not (and p1_15@871@01 p2_15@872@01))))
(check-sat)
; unknown
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 53
(set-option :timeout 10)
(assert (not (and p1_15@871@01 p2_15@872@01)))
(check-sat)
; unsat
(pop) ; 53
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1707 | p1_15@871@01 && p2_15@872@01 | live]
; [else-branch: 1707 | !(p1_15@871@01 && p2_15@872@01) | dead]
(set-option :timeout 0)
(push) ; 53
; [then-branch: 1707 | p1_15@871@01 && p2_15@872@01]
(assert (and p1_15@871@01 p2_15@872@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] _checkDefined(c_1, 3235683).Cell_val == c_1_0.Cell_valp
; [eval] _checkDefined(c_1, 3235683)
(set-option :timeout 0)
(push) ; 54
; [eval] _isDefined(id)
(push) ; 55
(pop) ; 55
; Joined path conditions
(pop) ; 54
; Joined path conditions
(push) ; 54
(set-option :timeout 10)
(assert (not (= thread_arg_5@1038@01 (_checkDefined $Snap.unit tmp_7@937@01 3235683))))
(check-sat)
; unsat
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 54
(set-option :timeout 10)
(assert (not (= thread_arg_6_0@1045@01 tmp_7@937@01)))
(check-sat)
; unsat
(pop) ; 54
; 0.00s
; (get-info :all-statistics)
(pop) ; 53
(pop) ; 52
; Joined path conditions
(assert (and p1_15@871@01 p2_15@872@01))
(set-option :timeout 0)
(push) ; 52
(assert (not (=>
  (and p1_15@871@01 p2_15@872@01)
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1040@01))))
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1047@01)))))))))
(check-sat)
; unknown
(pop) ; 52
; 0.00s
; (get-info :all-statistics)
(pop) ; 51
(pop) ; 50
(pop) ; 49
(pop) ; 48
(pop) ; 47
(pop) ; 46
(pop) ; 45
(pop) ; 44
(pop) ; 43
(pop) ; 42
(pop) ; 41
(pop) ; 40
(pop) ; 39
(pop) ; 38
(pop) ; 37
(pop) ; 36
(pop) ; 35
(pop) ; 34
(pop) ; 33
(pop) ; 32
(pop) ; 31
(pop) ; 30
(pop) ; 29
(pop) ; 28
(pop) ; 27
(pop) ; 26
(pop) ; 25
(pop) ; 24
(pop) ; 23
(pop) ; 22
(pop) ; 21
(pop) ; 20
(pop) ; 19
(pop) ; 18
(pop) ; 17
(pop) ; 16
(pop) ; 15
(pop) ; 14
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- join_low_dyn_bound ----------
(declare-const p1_21@1048@01 Bool)
(declare-const p2_21@1049@01 Bool)
(declare-const _cthread_169@1050@01 $Ref)
(declare-const _cthread_169_0@1051@01 $Ref)
(declare-const _caller_measures_169@1052@01 Seq<Measure$>)
(declare-const _caller_measures_169_0@1053@01 Seq<Measure$>)
(declare-const _residue_169@1054@01 $Perm)
(declare-const _residue_169_0@1055@01 $Perm)
(declare-const secret_2@1056@01 $Ref)
(declare-const secret_2_0@1057@01 $Ref)
(declare-const _current_wait_level_169@1058@01 $Perm)
(declare-const _current_wait_level_169_0@1059@01 $Perm)
(declare-const p1_21@1060@01 Bool)
(declare-const p2_21@1061@01 Bool)
(declare-const _cthread_169@1062@01 $Ref)
(declare-const _cthread_169_0@1063@01 $Ref)
(declare-const _caller_measures_169@1064@01 Seq<Measure$>)
(declare-const _caller_measures_169_0@1065@01 Seq<Measure$>)
(declare-const _residue_169@1066@01 $Perm)
(declare-const _residue_169_0@1067@01 $Perm)
(declare-const secret_2@1068@01 $Ref)
(declare-const secret_2_0@1069@01 $Ref)
(declare-const _current_wait_level_169@1070@01 $Perm)
(declare-const _current_wait_level_169_0@1071@01 $Perm)
(push) ; 1
(declare-const $t@1072@01 $Snap)
(assert (= $t@1072@01 ($Snap.combine ($Snap.first $t@1072@01) ($Snap.second $t@1072@01))))
(assert (= ($Snap.first $t@1072@01) $Snap.unit))
; [eval] p1_21 ==> _cthread_169 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_21@1060@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1708 | p1_21@1060@01 | live]
; [else-branch: 1708 | !(p1_21@1060@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1708 | p1_21@1060@01]
(assert p1_21@1060@01)
; [eval] _cthread_169 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1708 | !(p1_21@1060@01)]
(assert (not p1_21@1060@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_21@1060@01) p1_21@1060@01))
(assert (=> p1_21@1060@01 (not (= _cthread_169@1062@01 $Ref.null))))
(assert (=
  ($Snap.second $t@1072@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1072@01))
    ($Snap.second ($Snap.second $t@1072@01)))))
(assert (= ($Snap.first ($Snap.second $t@1072@01)) $Snap.unit))
; [eval] p2_21 ==> _cthread_169_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_21@1061@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1709 | p2_21@1061@01 | live]
; [else-branch: 1709 | !(p2_21@1061@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1709 | p2_21@1061@01]
(assert p2_21@1061@01)
; [eval] _cthread_169_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1709 | !(p2_21@1061@01)]
(assert (not p2_21@1061@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_21@1061@01) p2_21@1061@01))
(assert (=> p2_21@1061@01 (not (= _cthread_169_0@1063@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@1072@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1072@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1072@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1072@01))) $Snap.unit))
; [eval] p1_21 ==> issubtype(typeof(_cthread_169), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_21@1060@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1710 | p1_21@1060@01 | live]
; [else-branch: 1710 | !(p1_21@1060@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1710 | p1_21@1060@01]
(assert p1_21@1060@01)
; [eval] issubtype(typeof(_cthread_169), Thread_0())
; [eval] typeof(_cthread_169)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1710 | !(p1_21@1060@01)]
(assert (not p1_21@1060@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_21@1060@01
  (issubtype<Bool> (typeof<PyType> _cthread_169@1062@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1072@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1072@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1072@01))))
  $Snap.unit))
; [eval] p2_21 ==> issubtype(typeof(_cthread_169_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_21@1061@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1711 | p2_21@1061@01 | live]
; [else-branch: 1711 | !(p2_21@1061@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1711 | p2_21@1061@01]
(assert p2_21@1061@01)
; [eval] issubtype(typeof(_cthread_169_0), Thread_0())
; [eval] typeof(_cthread_169_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1711 | !(p2_21@1061@01)]
(assert (not p2_21@1061@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_21@1061@01
  (issubtype<Bool> (typeof<PyType> _cthread_169_0@1063@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01)))))
  $Snap.unit))
; [eval] p1_21 ==> issubtype(typeof(secret_2), bool())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_21@1060@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1712 | p1_21@1060@01 | live]
; [else-branch: 1712 | !(p1_21@1060@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1712 | p1_21@1060@01]
(assert p1_21@1060@01)
; [eval] issubtype(typeof(secret_2), bool())
; [eval] typeof(secret_2)
; [eval] bool()
(pop) ; 3
(push) ; 3
; [else-branch: 1712 | !(p1_21@1060@01)]
(assert (not p1_21@1060@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_21@1060@01
  (issubtype<Bool> (typeof<PyType> secret_2@1068@01) (as bool<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01))))))
  $Snap.unit))
; [eval] p2_21 ==> issubtype(typeof(secret_2_0), bool())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_21@1061@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1713 | p2_21@1061@01 | live]
; [else-branch: 1713 | !(p2_21@1061@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1713 | p2_21@1061@01]
(assert p2_21@1061@01)
; [eval] issubtype(typeof(secret_2_0), bool())
; [eval] typeof(secret_2_0)
; [eval] bool()
(pop) ; 3
(push) ; 3
; [else-branch: 1713 | !(p2_21@1061@01)]
(assert (not p2_21@1061@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_21@1061@01
  (issubtype<Bool> (typeof<PyType> secret_2_0@1069@01) (as bool<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01)))))))
  $Snap.unit))
; [eval] p1_21 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_21@1060@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1714 | p1_21@1060@01 | live]
; [else-branch: 1714 | !(p1_21@1060@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1714 | p1_21@1060@01]
(assert p1_21@1060@01)
(pop) ; 3
(push) ; 3
; [else-branch: 1714 | !(p1_21@1060@01)]
(assert (not p1_21@1060@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1072@01)))))))
  $Snap.unit))
; [eval] p2_21 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_21@1061@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1715 | p2_21@1061@01 | live]
; [else-branch: 1715 | !(p2_21@1061@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1715 | p2_21@1061@01]
(assert p2_21@1061@01)
(pop) ; 3
(push) ; 3
; [else-branch: 1715 | !(p2_21@1061@01)]
(assert (not p2_21@1061@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@1073@01 $Snap)
(assert (= $t@1073@01 ($Snap.combine ($Snap.first $t@1073@01) ($Snap.second $t@1073@01))))
(assert (= ($Snap.first $t@1073@01) $Snap.unit))
; [eval] p1_21 ==> (forperm _r_36: Ref [_r_36.MustReleaseBounded] :: Level(_r_36) <= _current_wait_level_169) && ((forperm _r_36: Ref [_r_36.MustReleaseUnbounded] :: Level(_r_36) <= _current_wait_level_169) && _residue_169 <= _current_wait_level_169)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_21@1060@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1716 | p1_21@1060@01 | live]
; [else-branch: 1716 | !(p1_21@1060@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1716 | p1_21@1060@01]
(assert p1_21@1060@01)
; [eval] (forperm _r_36: Ref [_r_36.MustReleaseBounded] :: Level(_r_36) <= _current_wait_level_169) && ((forperm _r_36: Ref [_r_36.MustReleaseUnbounded] :: Level(_r_36) <= _current_wait_level_169) && _residue_169 <= _current_wait_level_169)
; [eval] (forperm _r_36: Ref [_r_36.MustReleaseBounded] :: Level(_r_36) <= _current_wait_level_169)
(push) ; 5
; [then-branch: 1717 | False | live]
; [else-branch: 1717 | True | live]
(push) ; 6
; [then-branch: 1717 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 1717 | True]
; [eval] (forperm _r_36: Ref [_r_36.MustReleaseUnbounded] :: Level(_r_36) <= _current_wait_level_169)
(push) ; 7
; [then-branch: 1718 | False | live]
; [else-branch: 1718 | True | live]
(push) ; 8
; [then-branch: 1718 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1718 | True]
; [eval] _residue_169 <= _current_wait_level_169
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1716 | !(p1_21@1060@01)]
(assert (not p1_21@1060@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p1_21@1060@01 (<= _residue_169@1066@01 _current_wait_level_169@1070@01)))
(assert (=
  ($Snap.second $t@1073@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1073@01))
    ($Snap.second ($Snap.second $t@1073@01)))))
(assert (= ($Snap.first ($Snap.second $t@1073@01)) $Snap.unit))
; [eval] p2_21 ==> (forperm _r_36: Ref [_r_36.MustReleaseBoundedp] :: Level(_r_36) <= _current_wait_level_169_0) && ((forperm _r_36: Ref [_r_36.MustReleaseUnboundedp] :: Level(_r_36) <= _current_wait_level_169_0) && _residue_169_0 <= _current_wait_level_169_0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_21@1061@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1719 | p2_21@1061@01 | live]
; [else-branch: 1719 | !(p2_21@1061@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1719 | p2_21@1061@01]
(assert p2_21@1061@01)
; [eval] (forperm _r_36: Ref [_r_36.MustReleaseBoundedp] :: Level(_r_36) <= _current_wait_level_169_0) && ((forperm _r_36: Ref [_r_36.MustReleaseUnboundedp] :: Level(_r_36) <= _current_wait_level_169_0) && _residue_169_0 <= _current_wait_level_169_0)
; [eval] (forperm _r_36: Ref [_r_36.MustReleaseBoundedp] :: Level(_r_36) <= _current_wait_level_169_0)
(push) ; 5
; [then-branch: 1720 | False | live]
; [else-branch: 1720 | True | live]
(push) ; 6
; [then-branch: 1720 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 1720 | True]
; [eval] (forperm _r_36: Ref [_r_36.MustReleaseUnboundedp] :: Level(_r_36) <= _current_wait_level_169_0)
(push) ; 7
; [then-branch: 1721 | False | live]
; [else-branch: 1721 | True | live]
(push) ; 8
; [then-branch: 1721 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1721 | True]
; [eval] _residue_169_0 <= _current_wait_level_169_0
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1719 | !(p2_21@1061@01)]
(assert (not p2_21@1061@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p2_21@1061@01 (<= _residue_169_0@1067@01 _current_wait_level_169_0@1071@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1073@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1073@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1073@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1073@01))) $Snap.unit))
; [eval] p1_21 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_21@1060@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1722 | p1_21@1060@01 | live]
; [else-branch: 1722 | !(p1_21@1060@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1722 | p1_21@1060@01]
(assert p1_21@1060@01)
(pop) ; 4
(push) ; 4
; [else-branch: 1722 | !(p1_21@1060@01)]
(assert (not p1_21@1060@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@1073@01))) $Snap.unit))
; [eval] p2_21 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_21@1061@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1723 | p2_21@1061@01 | live]
; [else-branch: 1723 | !(p2_21@1061@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1723 | p2_21@1061@01]
(assert p2_21@1061@01)
(pop) ; 4
(push) ; 4
; [else-branch: 1723 | !(p2_21@1061@01)]
(assert (not p2_21@1061@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
(push) ; 2
; [exec]
; var _err: Ref
(declare-const _err@1074@01 $Ref)
; [exec]
; var _err_9: Ref
(declare-const _err_9@1075@01 $Ref)
; [exec]
; var x_3: Ref
(declare-const x_3@1076@01 $Ref)
; [exec]
; var x_3_0: Ref
(declare-const x_3_0@1077@01 $Ref)
; [exec]
; var t_2: Ref
(declare-const t_2@1078@01 $Ref)
; [exec]
; var t_2_0: Ref
(declare-const t_2_0@1079@01 $Ref)
; [exec]
; var secret_6: Ref
(declare-const secret_6@1080@01 $Ref)
; [exec]
; var secret_6_0: Ref
(declare-const secret_6_0@1081@01 $Ref)
; [exec]
; var A_res: Ref
(declare-const A_res@1082@01 $Ref)
; [exec]
; var A_res_0: Ref
(declare-const A_res_0@1083@01 $Ref)
; [exec]
; var B_res: Ref
(declare-const B_res@1084@01 $Ref)
; [exec]
; var B_res_0: Ref
(declare-const B_res_0@1085@01 $Ref)
; [exec]
; var threadingVar_5: Ref
(declare-const threadingVar_5@1086@01 $Ref)
; [exec]
; var threadingVar_5_0: Ref
(declare-const threadingVar_5_0@1087@01 $Ref)
; [exec]
; var thread_arg_7: Ref
(declare-const thread_arg_7@1088@01 $Ref)
; [exec]
; var thread_arg_7_0: Ref
(declare-const thread_arg_7_0@1089@01 $Ref)
; [exec]
; var join_result_0: Ref
(declare-const join_result_0@1090@01 $Ref)
; [exec]
; var join_result_0_0: Ref
(declare-const join_result_0_0@1091@01 $Ref)
; [exec]
; var thread_arg_8: Ref
(declare-const thread_arg_8@1092@01 $Ref)
; [exec]
; var thread_arg_8_0: Ref
(declare-const thread_arg_8_0@1093@01 $Ref)
; [exec]
; var _cwl_169: Perm
(declare-const _cwl_169@1094@01 $Perm)
; [exec]
; var _cwl_169_0: Perm
(declare-const _cwl_169_0@1095@01 $Perm)
; [exec]
; var _method_measures_169: Seq[Measure$]
(declare-const _method_measures_169@1096@01 Seq<Measure$>)
; [exec]
; var _method_measures_169_0: Seq[Measure$]
(declare-const _method_measures_169_0@1097@01 Seq<Measure$>)
; [exec]
; var p1_22: Bool
(declare-const p1_22@1098@01 Bool)
; [exec]
; var p2_22: Bool
(declare-const p2_22@1099@01 Bool)
; [exec]
; var p3_12: Bool
(declare-const p3_12@1100@01 Bool)
; [exec]
; var p4_12: Bool
(declare-const p4_12@1101@01 Bool)
; [exec]
; var tmp_10: Ref
(declare-const tmp_10@1102@01 $Ref)
; [exec]
; var tmp_11: Ref
(declare-const tmp_11@1103@01 $Ref)
; [exec]
; var tmp_12: Ref
(declare-const tmp_12@1104@01 $Ref)
; [exec]
; var p1_23: Bool
(declare-const p1_23@1105@01 Bool)
; [exec]
; var p2_23: Bool
(declare-const p2_23@1106@01 Bool)
; [exec]
; var p3_13: Bool
(declare-const p3_13@1107@01 Bool)
; [exec]
; var p4_13: Bool
(declare-const p4_13@1108@01 Bool)
; [exec]
; var p1_24: Bool
(declare-const p1_24@1109@01 Bool)
; [exec]
; var p2_24: Bool
(declare-const p2_24@1110@01 Bool)
; [exec]
; var p3_14: Bool
(declare-const p3_14@1111@01 Bool)
; [exec]
; var p4_14: Bool
(declare-const p4_14@1112@01 Bool)
; [exec]
; inhale p1_21
(declare-const $t@1113@01 $Snap)
(assert (= $t@1113@01 $Snap.unit))
(assert p1_21@1060@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1724 | p1_21@1060@01 | live]
; [else-branch: 1724 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1724 | p1_21@1060@01]
; [exec]
; _method_measures_169 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err := null
; [exec]
; secret_6 := secret_2
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_21@1061@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1725 | p2_21@1061@01 | live]
; [else-branch: 1725 | !(p2_21@1061@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1725 | p2_21@1061@01]
(assert p2_21@1061@01)
; [exec]
; _method_measures_169_0 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; _err_9 := null
; [exec]
; secret_6_0 := secret_2_0
; [exec]
; p1_22 := p1_21 && bool___unbox__(secret_6)
; [eval] p1_21 && bool___unbox__(secret_6)
(push) ; 5
; [then-branch: 1726 | !(p1_21@1060@01) | live]
; [else-branch: 1726 | p1_21@1060@01 | live]
(push) ; 6
; [then-branch: 1726 | !(p1_21@1060@01)]
(assert (not p1_21@1060@01))
(pop) ; 6
(push) ; 6
; [else-branch: 1726 | p1_21@1060@01]
; [eval] bool___unbox__(secret_6)
(push) ; 7
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 8
(assert (not (issubtype<Bool> (typeof<PyType> secret_2@1068@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_2@1068@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_2@1068@01))
(pop) ; 7
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_2@1068@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_2@1068@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_21@1060@01
  (and
    (issubtype<Bool> (typeof<PyType> secret_2@1068@01) (as bool<PyType>  PyType))
    (bool___unbox__%precondition $Snap.unit secret_2@1068@01))))
(assert (or p1_21@1060@01 (not p1_21@1060@01)))
(declare-const p1_22@1114@01 Bool)
(assert (=
  p1_22@1114@01
  (and p1_21@1060@01 (bool___unbox__ $Snap.unit secret_2@1068@01))))
; [exec]
; p2_22 := p2_21 && bool___unbox__(secret_6_0)
; [eval] p2_21 && bool___unbox__(secret_6_0)
(push) ; 5
; [then-branch: 1727 | !(p2_21@1061@01) | live]
; [else-branch: 1727 | p2_21@1061@01 | live]
(push) ; 6
; [then-branch: 1727 | !(p2_21@1061@01)]
(assert (not p2_21@1061@01))
(pop) ; 6
(push) ; 6
; [else-branch: 1727 | p2_21@1061@01]
; [eval] bool___unbox__(secret_6_0)
(push) ; 7
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 8
(assert (not (issubtype<Bool> (typeof<PyType> secret_2_0@1069@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_2_0@1069@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_2_0@1069@01))
(pop) ; 7
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_2_0@1069@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_2_0@1069@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_21@1061@01
  (and
    (issubtype<Bool> (typeof<PyType> secret_2_0@1069@01) (as bool<PyType>  PyType))
    (bool___unbox__%precondition $Snap.unit secret_2_0@1069@01))))
(assert (or p2_21@1061@01 (not p2_21@1061@01)))
(declare-const p2_22@1115@01 Bool)
(assert (=
  p2_22@1115@01
  (and p2_21@1061@01 (bool___unbox__ $Snap.unit secret_2_0@1069@01))))
; [exec]
; p3_12 := p1_21 && !bool___unbox__(secret_6)
; [eval] p1_21 && !bool___unbox__(secret_6)
(push) ; 5
; [then-branch: 1728 | !(p1_21@1060@01) | live]
; [else-branch: 1728 | p1_21@1060@01 | live]
(push) ; 6
; [then-branch: 1728 | !(p1_21@1060@01)]
(assert (not p1_21@1060@01))
(pop) ; 6
(push) ; 6
; [else-branch: 1728 | p1_21@1060@01]
; [eval] !bool___unbox__(secret_6)
; [eval] bool___unbox__(secret_6)
(push) ; 7
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 8
(assert (not (issubtype<Bool> (typeof<PyType> secret_2@1068@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_2@1068@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_2@1068@01))
(pop) ; 7
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_2@1068@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_2@1068@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(declare-const p3_12@1116@01 Bool)
(assert (=
  p3_12@1116@01
  (and p1_21@1060@01 (not (bool___unbox__ $Snap.unit secret_2@1068@01)))))
; [exec]
; p4_12 := p2_21 && !bool___unbox__(secret_6_0)
; [eval] p2_21 && !bool___unbox__(secret_6_0)
(push) ; 5
; [then-branch: 1729 | !(p2_21@1061@01) | live]
; [else-branch: 1729 | p2_21@1061@01 | live]
(push) ; 6
; [then-branch: 1729 | !(p2_21@1061@01)]
(assert (not p2_21@1061@01))
(pop) ; 6
(push) ; 6
; [else-branch: 1729 | p2_21@1061@01]
; [eval] !bool___unbox__(secret_6_0)
; [eval] bool___unbox__(secret_6_0)
(push) ; 7
; [eval] issubtype(typeof(box), bool())
; [eval] typeof(box)
; [eval] bool()
(push) ; 8
(assert (not (issubtype<Bool> (typeof<PyType> secret_2_0@1069@01) (as bool<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> secret_2_0@1069@01) (as bool<PyType>  PyType)))
(assert (bool___unbox__%precondition $Snap.unit secret_2_0@1069@01))
(pop) ; 7
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> secret_2_0@1069@01) (as bool<PyType>  PyType))
  (bool___unbox__%precondition $Snap.unit secret_2_0@1069@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(declare-const p4_12@1117@01 Bool)
(assert (=
  p4_12@1117@01
  (and p2_21@1061@01 (not (bool___unbox__ $Snap.unit secret_2_0@1069@01)))))
; [exec]
; tmp_10 := new()
(declare-const tmp_10@1118@01 $Ref)
(assert (not (= tmp_10@1118@01 $Ref.null)))
(assert (not (= tmp_10@1118@01 thread_arg_8@1092@01)))
(assert (not (= tmp_10@1118@01 _cthread_169_0@1063@01)))
(assert (not (= tmp_10@1118@01 B_res_0@1085@01)))
(assert (not (= tmp_10@1118@01 thread_arg_7@1088@01)))
(assert (not (= tmp_10@1118@01 threadingVar_5@1086@01)))
(assert (not (= tmp_10@1118@01 thread_arg_7_0@1089@01)))
(assert (not (= tmp_10@1118@01 x_3@1076@01)))
(assert (not (= tmp_10@1118@01 join_result_0@1090@01)))
(assert (not (= tmp_10@1118@01 A_res@1082@01)))
(assert (not (= tmp_10@1118@01 secret_2@1068@01)))
(assert (not (= tmp_10@1118@01 join_result_0_0@1091@01)))
(assert (not (= tmp_10@1118@01 B_res@1084@01)))
(assert (not (= tmp_10@1118@01 x_3_0@1077@01)))
(assert (not (= tmp_10@1118@01 secret_2_0@1069@01)))
(assert (not (= tmp_10@1118@01 tmp_10@1102@01)))
(assert (not (= tmp_10@1118@01 threadingVar_5_0@1087@01)))
(assert (not (= tmp_10@1118@01 tmp_12@1104@01)))
(assert (not (= tmp_10@1118@01 t_2@1078@01)))
(assert (not (= tmp_10@1118@01 A_res_0@1083@01)))
(assert (not (= tmp_10@1118@01 t_2_0@1079@01)))
(assert (not (= tmp_10@1118@01 _cthread_169@1062@01)))
(assert (not (= tmp_10@1118@01 thread_arg_8_0@1093@01)))
(assert (not (= tmp_10@1118@01 tmp_11@1103@01)))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_22@1114@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not p1_22@1114@01))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1730 | p1_22@1114@01 | live]
; [else-branch: 1730 | !(p1_22@1114@01) | live]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1730 | p1_22@1114@01]
(assert p1_22@1114@01)
; [exec]
; A_res := tmp_10
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_22@1115@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not p2_22@1115@01))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1731 | p2_22@1115@01 | live]
; [else-branch: 1731 | !(p2_22@1115@01) | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1731 | p2_22@1115@01]
(assert p2_22@1115@01)
; [exec]
; A_res_0 := tmp_10
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_22@1114@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1732 | p1_22@1114@01 | live]
; [else-branch: 1732 | !(p1_22@1114@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 1732 | p1_22@1114@01]
; [exec]
; inhale typeof(A_res) == A()
(declare-const $t@1119@01 $Snap)
(assert (= $t@1119@01 $Snap.unit))
; [eval] typeof(A_res) == A()
; [eval] typeof(A_res)
; [eval] A()
(assert (= (typeof<PyType> tmp_10@1118@01) (as A<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; x_3 := A_res
; [exec]
; inhale _isDefined(3366776)
(declare-const $t@1120@01 $Snap)
(assert (= $t@1120@01 $Snap.unit))
; [eval] _isDefined(3366776)
(set-option :timeout 0)
(push) ; 8
(assert (_isDefined%precondition $Snap.unit 3366776))
(pop) ; 8
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 3366776))
(assert (_isDefined $Snap.unit 3366776))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_22@1115@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1733 | p2_22@1115@01 | live]
; [else-branch: 1733 | !(p2_22@1115@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1733 | p2_22@1115@01]
; [exec]
; inhale typeof(A_res_0) == A()
(declare-const $t@1121@01 $Snap)
(assert (= $t@1121@01 $Snap.unit))
; [eval] typeof(A_res_0) == A()
; [eval] typeof(A_res_0)
; [eval] A()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; x_3_0 := A_res_0
; [exec]
; inhale true
(declare-const $t@1122@01 $Snap)
(assert (= $t@1122@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; tmp_11 := new()
(declare-const tmp_11@1123@01 $Ref)
(assert (not (= tmp_11@1123@01 $Ref.null)))
(assert (not (= tmp_11@1123@01 thread_arg_8@1092@01)))
(assert (not (= tmp_11@1123@01 B_res@1084@01)))
(assert (not (= tmp_11@1123@01 _cthread_169_0@1063@01)))
(assert (not (= tmp_11@1123@01 B_res_0@1085@01)))
(assert (not (= tmp_11@1123@01 thread_arg_7@1088@01)))
(assert (not (= tmp_11@1123@01 threadingVar_5@1086@01)))
(assert (not (= tmp_11@1123@01 secret_2_0@1069@01)))
(assert (not (= tmp_11@1123@01 tmp_10@1118@01)))
(assert (not (= tmp_11@1123@01 thread_arg_7_0@1089@01)))
(assert (not (= tmp_11@1123@01 threadingVar_5_0@1087@01)))
(assert (not (= tmp_11@1123@01 tmp_12@1104@01)))
(assert (not (= tmp_11@1123@01 t_2@1078@01)))
(assert (not (= tmp_11@1123@01 join_result_0@1090@01)))
(assert (not (= tmp_11@1123@01 t_2_0@1079@01)))
(assert (not (= tmp_11@1123@01 _cthread_169@1062@01)))
(assert (not (= tmp_11@1123@01 thread_arg_8_0@1093@01)))
(assert (not (= tmp_11@1123@01 tmp_11@1103@01)))
(assert (not (= tmp_11@1123@01 secret_2@1068@01)))
(assert (not (= tmp_11@1123@01 join_result_0_0@1091@01)))
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not p3_12@1116@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1734 | p3_12@1116@01 | dead]
; [else-branch: 1734 | !(p3_12@1116@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 1734 | !(p3_12@1116@01)]
(assert (not p3_12@1116@01))
(pop) ; 9
; [eval] !p3_12
(push) ; 9
(set-option :timeout 10)
(assert (not p3_12@1116@01))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not p3_12@1116@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1735 | !(p3_12@1116@01) | live]
; [else-branch: 1735 | p3_12@1116@01 | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 1735 | !(p3_12@1116@01)]
(assert (not p3_12@1116@01))
(push) ; 10
(set-option :timeout 10)
(assert (not (not p4_12@1117@01)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1736 | p4_12@1117@01 | dead]
; [else-branch: 1736 | !(p4_12@1117@01) | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 1736 | !(p4_12@1117@01)]
(assert (not p4_12@1117@01))
(pop) ; 10
; [eval] !p4_12
(push) ; 10
(set-option :timeout 10)
(assert (not p4_12@1117@01))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not p4_12@1117@01)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1737 | !(p4_12@1117@01) | live]
; [else-branch: 1737 | p4_12@1117@01 | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 1737 | !(p4_12@1117@01)]
(assert (not p4_12@1117@01))
; [then-branch: 1738 | p3_12@1116@01 | dead]
; [else-branch: 1738 | !(p3_12@1116@01) | live]
(push) ; 11
; [else-branch: 1738 | !(p3_12@1116@01)]
(pop) ; 11
; [eval] !p3_12
(push) ; 11
(set-option :timeout 10)
(assert (not p3_12@1116@01))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1739 | !(p3_12@1116@01) | live]
; [else-branch: 1739 | p3_12@1116@01 | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 1739 | !(p3_12@1116@01)]
; [then-branch: 1740 | p4_12@1117@01 | dead]
; [else-branch: 1740 | !(p4_12@1117@01) | live]
(push) ; 12
; [else-branch: 1740 | !(p4_12@1117@01)]
(pop) ; 12
; [eval] !p4_12
(push) ; 12
(set-option :timeout 10)
(assert (not p4_12@1117@01))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1741 | !(p4_12@1117@01) | live]
; [else-branch: 1741 | p4_12@1117@01 | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 1741 | !(p4_12@1117@01)]
; [exec]
; tmp_12 := new()
(declare-const tmp_12@1124@01 $Ref)
(assert (not (= tmp_12@1124@01 $Ref.null)))
(assert (not (= tmp_12@1124@01 thread_arg_8@1092@01)))
(assert (not (= tmp_12@1124@01 B_res@1084@01)))
(assert (not (= tmp_12@1124@01 _cthread_169_0@1063@01)))
(assert (not (= tmp_12@1124@01 B_res_0@1085@01)))
(assert (not (= tmp_12@1124@01 thread_arg_7@1088@01)))
(assert (not (= tmp_12@1124@01 threadingVar_5@1086@01)))
(assert (not (= tmp_12@1124@01 secret_2_0@1069@01)))
(assert (not (= tmp_12@1124@01 tmp_11@1123@01)))
(assert (not (= tmp_12@1124@01 tmp_10@1118@01)))
(assert (not (= tmp_12@1124@01 thread_arg_7_0@1089@01)))
(assert (not (= tmp_12@1124@01 threadingVar_5_0@1087@01)))
(assert (not (= tmp_12@1124@01 tmp_12@1104@01)))
(assert (not (= tmp_12@1124@01 t_2@1078@01)))
(assert (not (= tmp_12@1124@01 join_result_0@1090@01)))
(assert (not (= tmp_12@1124@01 t_2_0@1079@01)))
(assert (not (= tmp_12@1124@01 _cthread_169@1062@01)))
(assert (not (= tmp_12@1124@01 thread_arg_8_0@1093@01)))
(assert (not (= tmp_12@1124@01 secret_2@1068@01)))
(assert (not (= tmp_12@1124@01 join_result_0_0@1091@01)))
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1742 | p1_21@1060@01 | live]
; [else-branch: 1742 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 1742 | p1_21@1060@01]
; [exec]
; threadingVar_5 := tmp_12
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1743 | p2_21@1061@01 | live]
; [else-branch: 1743 | !(p2_21@1061@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1743 | p2_21@1061@01]
; [exec]
; threadingVar_5_0 := tmp_12
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1744 | p1_21@1060@01 | live]
; [else-branch: 1744 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 1744 | p1_21@1060@01]
; [exec]
; inhale issubtype(typeof(threadingVar_5), Thread_0())
(declare-const $t@1125@01 $Snap)
(assert (= $t@1125@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_5), Thread_0())
; [eval] typeof(threadingVar_5)
; [eval] Thread_0()
(assert (issubtype<Bool> (typeof<PyType> tmp_12@1124@01) (as Thread_0<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod(threadingVar_5) == foo_threading()
(declare-const $t@1126@01 $Snap)
(assert (= $t@1126@01 $Snap.unit))
; [eval] getMethod(threadingVar_5) == foo_threading()
; [eval] getMethod(threadingVar_5)
; [eval] foo_threading()
(assert (=
  (getMethod<ThreadingID> tmp_12@1124@01)
  (as foo_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1745 | p2_21@1061@01 | live]
; [else-branch: 1745 | !(p2_21@1061@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 1745 | p2_21@1061@01]
; [exec]
; inhale issubtype(typeof(threadingVar_5_0), Thread_0())
(declare-const $t@1127@01 $Snap)
(assert (= $t@1127@01 $Snap.unit))
; [eval] issubtype(typeof(threadingVar_5_0), Thread_0())
; [eval] typeof(threadingVar_5_0)
; [eval] Thread_0()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale getMethod_0(threadingVar_5_0) == foo_threading()
(declare-const $t@1128@01 $Snap)
(assert (= $t@1128@01 $Snap.unit))
; [eval] getMethod_0(threadingVar_5_0) == foo_threading()
; [eval] getMethod_0(threadingVar_5_0)
; [eval] foo_threading()
(assert (=
  (getMethod_0<ThreadingID> tmp_12@1124@01)
  (as foo_threading<ThreadingID>  ThreadingID)))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; assert (p1_21 ==>
;   true == issubtype(typeof(_checkDefined(x_3, 3366776)), A())) &&
;   (p2_21 ==> true == issubtype(typeof(x_3_0), A()))
; [eval] p1_21 ==> true == issubtype(typeof(_checkDefined(x_3, 3366776)), A())
(set-option :timeout 0)
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1746 | p1_21@1060@01 | live]
; [else-branch: 1746 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 1746 | p1_21@1060@01]
; [eval] true == issubtype(typeof(_checkDefined(x_3, 3366776)), A())
; [eval] issubtype(typeof(_checkDefined(x_3, 3366776)), A())
; [eval] typeof(_checkDefined(x_3, 3366776))
; [eval] _checkDefined(x_3, 3366776)
(push) ; 19
; [eval] _isDefined(id)
(push) ; 20
(pop) ; 20
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_10@1118@01 3366776))
(pop) ; 19
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_10@1118@01 3366776))
; [eval] A()
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (=> p1_21@1060@01 (_checkDefined%precondition $Snap.unit tmp_10@1118@01 3366776)))
(push) ; 17
(assert (not (=>
  p1_21@1060@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit tmp_10@1118@01 3366776)) (as A<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_21@1060@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> (_checkDefined $Snap.unit tmp_10@1118@01 3366776)) (as A<PyType>  PyType)))))
; [eval] p2_21 ==> true == issubtype(typeof(x_3_0), A())
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1747 | p2_21@1061@01 | live]
; [else-branch: 1747 | !(p2_21@1061@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 1747 | p2_21@1061@01]
; [eval] true == issubtype(typeof(x_3_0), A())
; [eval] issubtype(typeof(x_3_0), A())
; [eval] typeof(x_3_0)
; [eval] A()
(pop) ; 18
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (=>
  p2_21@1061@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> tmp_10@1118@01) (as A<PyType>  PyType))))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_21@1061@01
  (=
    true
    (issubtype<Bool> (typeof<PyType> tmp_10@1118@01) (as A<PyType>  PyType)))))
(push) ; 17
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1748 | p1_21@1060@01 | live]
; [else-branch: 1748 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 1748 | p1_21@1060@01]
; [exec]
; inhale true && getArg(threadingVar_5, 0) == _checkDefined(x_3, 3366776)
(declare-const $t@1129@01 $Snap)
(assert (= $t@1129@01 ($Snap.combine ($Snap.first $t@1129@01) ($Snap.second $t@1129@01))))
(assert (= ($Snap.first $t@1129@01) $Snap.unit))
(assert (= ($Snap.second $t@1129@01) $Snap.unit))
; [eval] getArg(threadingVar_5, 0) == _checkDefined(x_3, 3366776)
; [eval] getArg(threadingVar_5, 0)
; [eval] _checkDefined(x_3, 3366776)
(push) ; 18
; [eval] _isDefined(id)
(push) ; 19
(pop) ; 19
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_10@1118@01 3366776))
(pop) ; 18
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_10@1118@01 3366776))
(assert (=
  (getArg<Ref> tmp_12@1124@01 0)
  (_checkDefined $Snap.unit tmp_10@1118@01 3366776)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start(threadingVar_5), write)
(declare-const $t@1130@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t_2 := threadingVar_5
; [exec]
; inhale _isDefined(3301236)
(declare-const $t@1131@01 $Snap)
(assert (= $t@1131@01 $Snap.unit))
; [eval] _isDefined(3301236)
(set-option :timeout 0)
(push) ; 18
(assert (_isDefined%precondition $Snap.unit 3301236))
(pop) ; 18
; Joined path conditions
(assert (_isDefined%precondition $Snap.unit 3301236))
(assert (_isDefined $Snap.unit 3301236))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; exhale acc(_thread_start(_checkDefined(t_2, 3301236)), write)
; [eval] _checkDefined(t_2, 3301236)
(set-option :timeout 0)
(push) ; 18
; [eval] _isDefined(id)
(push) ; 19
(pop) ; 19
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_12@1124@01 3301236))
(pop) ; 18
; Joined path conditions
(assert (_checkDefined%precondition $Snap.unit tmp_12@1124@01 3301236))
(push) ; 18
(set-option :timeout 10)
(assert (not (= tmp_12@1124@01 (_checkDefined $Snap.unit tmp_12@1124@01 3301236))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 18
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1749 | p2_21@1061@01 | live]
; [else-branch: 1749 | !(p2_21@1061@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 1749 | p2_21@1061@01]
; [exec]
; inhale true && getArg_0(threadingVar_5_0, 0) == x_3_0
(declare-const $t@1132@01 $Snap)
(assert (= $t@1132@01 ($Snap.combine ($Snap.first $t@1132@01) ($Snap.second $t@1132@01))))
(assert (= ($Snap.first $t@1132@01) $Snap.unit))
(assert (= ($Snap.second $t@1132@01) $Snap.unit))
; [eval] getArg_0(threadingVar_5_0, 0) == x_3_0
; [eval] getArg_0(threadingVar_5_0, 0)
(assert (= (getArg_0<Ref> tmp_12@1124@01 0) tmp_10@1118@01))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(_thread_start_0(threadingVar_5_0), write)
(declare-const $t@1133@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; t_2_0 := threadingVar_5_0
; [exec]
; inhale true
(declare-const $t@1134@01 $Snap)
(assert (= $t@1134@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale acc(_thread_start_0(t_2_0), write)
; [exec]
; assert (p1_21 ==>
;   false || getMethod(_checkDefined(t_2, 3301236)) == foo_threading()) &&
;   (p2_21 ==> false || getMethod_0(t_2_0) == foo_threading())
; [eval] p1_21 ==> false || getMethod(_checkDefined(t_2, 3301236)) == foo_threading()
(set-option :timeout 0)
(push) ; 19
(push) ; 20
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1750 | p1_21@1060@01 | live]
; [else-branch: 1750 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 1750 | p1_21@1060@01]
; [eval] false || getMethod(_checkDefined(t_2, 3301236)) == foo_threading()
(push) ; 21
; [then-branch: 1751 | False | live]
; [else-branch: 1751 | True | live]
(push) ; 22
; [then-branch: 1751 | False]
(assert false)
(pop) ; 22
(push) ; 22
; [else-branch: 1751 | True]
; [eval] getMethod(_checkDefined(t_2, 3301236)) == foo_threading()
; [eval] getMethod(_checkDefined(t_2, 3301236))
; [eval] _checkDefined(t_2, 3301236)
(push) ; 23
; [eval] _isDefined(id)
(push) ; 24
(pop) ; 24
; Joined path conditions
(pop) ; 23
; Joined path conditions
; [eval] foo_threading()
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(pop) ; 19
; Joined path conditions
(push) ; 19
(assert (not (=>
  p1_21@1060@01
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_12@1124@01 3301236))
    (as foo_threading<ThreadingID>  ThreadingID)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_21@1060@01
  (=
    (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_12@1124@01 3301236))
    (as foo_threading<ThreadingID>  ThreadingID))))
; [eval] p2_21 ==> false || getMethod_0(t_2_0) == foo_threading()
(push) ; 19
(push) ; 20
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1752 | p2_21@1061@01 | live]
; [else-branch: 1752 | !(p2_21@1061@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 1752 | p2_21@1061@01]
; [eval] false || getMethod_0(t_2_0) == foo_threading()
(push) ; 21
; [then-branch: 1753 | False | live]
; [else-branch: 1753 | True | live]
(push) ; 22
; [then-branch: 1753 | False]
(assert false)
(pop) ; 22
(push) ; 22
; [else-branch: 1753 | True]
; [eval] getMethod_0(t_2_0) == foo_threading()
; [eval] getMethod_0(t_2_0)
; [eval] foo_threading()
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(pop) ; 19
; Joined path conditions
(push) ; 19
(assert (not (=>
  p2_21@1061@01
  (=
    (getMethod_0<ThreadingID> tmp_12@1124@01)
    (as foo_threading<ThreadingID>  ThreadingID)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_21@1061@01
  (=
    (getMethod_0<ThreadingID> tmp_12@1124@01)
    (as foo_threading<ThreadingID>  ThreadingID))))
; [exec]
; p1_23 := p1_21 && getMethod(_checkDefined(t_2, 3301236)) == foo_threading()
; [eval] p1_21 && getMethod(_checkDefined(t_2, 3301236)) == foo_threading()
(push) ; 19
; [then-branch: 1754 | !(p1_21@1060@01) | live]
; [else-branch: 1754 | p1_21@1060@01 | live]
(push) ; 20
; [then-branch: 1754 | !(p1_21@1060@01)]
(assert (not p1_21@1060@01))
(pop) ; 20
(push) ; 20
; [else-branch: 1754 | p1_21@1060@01]
; [eval] getMethod(_checkDefined(t_2, 3301236)) == foo_threading()
; [eval] getMethod(_checkDefined(t_2, 3301236))
; [eval] _checkDefined(t_2, 3301236)
(push) ; 21
; [eval] _isDefined(id)
(push) ; 22
(pop) ; 22
; Joined path conditions
(pop) ; 21
; Joined path conditions
; [eval] foo_threading()
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(declare-const p1_23@1135@01 Bool)
(assert (=
  p1_23@1135@01
  (and
    p1_21@1060@01
    (=
      (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_12@1124@01 3301236))
      (as foo_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p2_23 := p2_21 && getMethod_0(t_2_0) == foo_threading()
; [eval] p2_21 && getMethod_0(t_2_0) == foo_threading()
(push) ; 19
; [then-branch: 1755 | !(p2_21@1061@01) | live]
; [else-branch: 1755 | p2_21@1061@01 | live]
(push) ; 20
; [then-branch: 1755 | !(p2_21@1061@01)]
(assert (not p2_21@1061@01))
(pop) ; 20
(push) ; 20
; [else-branch: 1755 | p2_21@1061@01]
; [eval] getMethod_0(t_2_0) == foo_threading()
; [eval] getMethod_0(t_2_0)
; [eval] foo_threading()
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(declare-const p2_23@1136@01 Bool)
(assert (=
  p2_23@1136@01
  (and
    p2_21@1061@01
    (=
      (getMethod_0<ThreadingID> tmp_12@1124@01)
      (as foo_threading<ThreadingID>  ThreadingID)))))
; [exec]
; p3_13 := p1_21 &&
;   !(getMethod(_checkDefined(t_2, 3301236)) == foo_threading())
; [eval] p1_21 && !(getMethod(_checkDefined(t_2, 3301236)) == foo_threading())
(push) ; 19
; [then-branch: 1756 | !(p1_21@1060@01) | live]
; [else-branch: 1756 | p1_21@1060@01 | live]
(push) ; 20
; [then-branch: 1756 | !(p1_21@1060@01)]
(assert (not p1_21@1060@01))
(pop) ; 20
(push) ; 20
; [else-branch: 1756 | p1_21@1060@01]
; [eval] !(getMethod(_checkDefined(t_2, 3301236)) == foo_threading())
; [eval] getMethod(_checkDefined(t_2, 3301236)) == foo_threading()
; [eval] getMethod(_checkDefined(t_2, 3301236))
; [eval] _checkDefined(t_2, 3301236)
(push) ; 21
; [eval] _isDefined(id)
(push) ; 22
(pop) ; 22
; Joined path conditions
(pop) ; 21
; Joined path conditions
; [eval] foo_threading()
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(declare-const p3_13@1137@01 Bool)
(assert (=
  p3_13@1137@01
  (and
    p1_21@1060@01
    (not
      (=
        (getMethod<ThreadingID> (_checkDefined $Snap.unit tmp_12@1124@01 3301236))
        (as foo_threading<ThreadingID>  ThreadingID))))))
; [exec]
; p4_13 := p2_21 && !(getMethod_0(t_2_0) == foo_threading())
; [eval] p2_21 && !(getMethod_0(t_2_0) == foo_threading())
(push) ; 19
; [then-branch: 1757 | !(p2_21@1061@01) | live]
; [else-branch: 1757 | p2_21@1061@01 | live]
(push) ; 20
; [then-branch: 1757 | !(p2_21@1061@01)]
(assert (not p2_21@1061@01))
(pop) ; 20
(push) ; 20
; [else-branch: 1757 | p2_21@1061@01]
; [eval] !(getMethod_0(t_2_0) == foo_threading())
; [eval] getMethod_0(t_2_0) == foo_threading()
; [eval] getMethod_0(t_2_0)
; [eval] foo_threading()
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(declare-const p4_13@1138@01 Bool)
(assert (=
  p4_13@1138@01
  (and
    p2_21@1061@01
    (not
      (=
        (getMethod_0<ThreadingID> tmp_12@1124@01)
        (as foo_threading<ThreadingID>  ThreadingID))))))
(push) ; 19
(set-option :timeout 10)
(assert (not (not p1_23@1135@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not p1_23@1135@01))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1758 | p1_23@1135@01 | live]
; [else-branch: 1758 | !(p1_23@1135@01) | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 1758 | p1_23@1135@01]
(assert p1_23@1135@01)
; [exec]
; thread_arg_7 := getArg(_checkDefined(t_2, 3301236), 0)
; [eval] getArg(_checkDefined(t_2, 3301236), 0)
; [eval] _checkDefined(t_2, 3301236)
(push) ; 20
; [eval] _isDefined(id)
(push) ; 21
(pop) ; 21
; Joined path conditions
(pop) ; 20
; Joined path conditions
(declare-const thread_arg_7@1139@01 $Ref)
(assert (=
  thread_arg_7@1139@01
  (getArg<Ref> (_checkDefined $Snap.unit tmp_12@1124@01 3301236) 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_7), A())
(declare-const $t@1140@01 $Snap)
(assert (= $t@1140@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_7), A())
; [eval] typeof(thread_arg_7)
; [eval] A()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_7@1139@01) (as A<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@1141@01 $Snap)
(assert (= $t@1141@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale true
; [exec]
; inhale false ==>
;   _joinable(_checkDefined(t_2, 3301236)) &&
;   acc(_thread_post(_checkDefined(t_2, 3301236)), write)
; [then-branch: 1759 | False | dead]
; [else-branch: 1759 | True | live]
(set-option :timeout 0)
(push) ; 20
; [else-branch: 1759 | True]
(declare-const $t@1142@01 $Snap)
(assert (= $t@1142@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not p2_23@1136@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not p2_23@1136@01))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1760 | p2_23@1136@01 | live]
; [else-branch: 1760 | !(p2_23@1136@01) | dead]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 1760 | p2_23@1136@01]
(assert p2_23@1136@01)
; [exec]
; thread_arg_7_0 := getArg_0(t_2_0, 0)
; [eval] getArg_0(t_2_0, 0)
(declare-const thread_arg_7_0@1143@01 $Ref)
(assert (= thread_arg_7_0@1143@01 (getArg_0<Ref> tmp_12@1124@01 0)))
; [exec]
; inhale issubtype(typeof(thread_arg_7_0), A())
(declare-const $t@1144@01 $Snap)
(assert (= $t@1144@01 $Snap.unit))
; [eval] issubtype(typeof(thread_arg_7_0), A())
; [eval] typeof(thread_arg_7_0)
; [eval] A()
(assert (issubtype<Bool> (typeof<PyType> thread_arg_7_0@1143@01) (as A<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@1145@01 $Snap)
(assert (= $t@1145@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; exhale true
; [exec]
; inhale false ==> _joinable(t_2_0) && acc(_thread_post_0(t_2_0), write)
; [then-branch: 1761 | False | dead]
; [else-branch: 1761 | True | live]
(set-option :timeout 0)
(push) ; 22
; [else-branch: 1761 | True]
(declare-const $t@1146@01 $Snap)
(assert (= $t@1146@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1762 | p1_21@1060@01 | live]
; [else-branch: 1762 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 1762 | p1_21@1060@01]
; [exec]
; inhale (forperm
;     _r_34: Ref [_r_34.MustReleaseBounded] :: Level(_r_34) <
;     Level(_checkDefined(t_2, 3301236))) &&
;   ((forperm
;     _r_34: Ref [_r_34.MustReleaseUnbounded] :: Level(_r_34) <
;     Level(_checkDefined(t_2, 3301236))) &&
;   _residue_169 < Level(_checkDefined(t_2, 3301236)))
(declare-const $t@1147@01 $Snap)
(assert (= $t@1147@01 ($Snap.combine ($Snap.first $t@1147@01) ($Snap.second $t@1147@01))))
(assert (= ($Snap.first $t@1147@01) $Snap.unit))
; [eval] (forperm _r_34: Ref [_r_34.MustReleaseBounded] :: Level(_r_34) < Level(_checkDefined(t_2, 3301236)))
(assert (=
  ($Snap.second $t@1147@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1147@01))
    ($Snap.second ($Snap.second $t@1147@01)))))
(assert (= ($Snap.first ($Snap.second $t@1147@01)) $Snap.unit))
; [eval] (forperm _r_34: Ref [_r_34.MustReleaseUnbounded] :: Level(_r_34) < Level(_checkDefined(t_2, 3301236)))
(assert (= ($Snap.second ($Snap.second $t@1147@01)) $Snap.unit))
; [eval] _residue_169 < Level(_checkDefined(t_2, 3301236))
; [eval] Level(_checkDefined(t_2, 3301236))
; [eval] _checkDefined(t_2, 3301236)
(push) ; 24
; [eval] _isDefined(id)
(push) ; 25
(pop) ; 25
; Joined path conditions
(pop) ; 24
; Joined path conditions
(push) ; 24
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))
(pop) ; 24
; Joined path conditions
(assert (Level%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))
(assert (<
  _residue_169@1066@01
  (Level $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (not p2_21@1061@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1763 | p2_21@1061@01 | live]
; [else-branch: 1763 | !(p2_21@1061@01) | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 1763 | p2_21@1061@01]
; [exec]
; inhale (forperm
;     _r_34: Ref [_r_34.MustReleaseBoundedp] :: Level(_r_34) < Level(t_2_0)) &&
;   ((forperm
;     _r_34: Ref [_r_34.MustReleaseUnboundedp] :: Level(_r_34) < Level(t_2_0)) &&
;   _residue_169_0 < Level(t_2_0))
(declare-const $t@1148@01 $Snap)
(assert (= $t@1148@01 ($Snap.combine ($Snap.first $t@1148@01) ($Snap.second $t@1148@01))))
(assert (= ($Snap.first $t@1148@01) $Snap.unit))
; [eval] (forperm _r_34: Ref [_r_34.MustReleaseBoundedp] :: Level(_r_34) < Level(t_2_0))
(assert (=
  ($Snap.second $t@1148@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1148@01))
    ($Snap.second ($Snap.second $t@1148@01)))))
(assert (= ($Snap.first ($Snap.second $t@1148@01)) $Snap.unit))
; [eval] (forperm _r_34: Ref [_r_34.MustReleaseUnboundedp] :: Level(_r_34) < Level(t_2_0))
(assert (= ($Snap.second ($Snap.second $t@1148@01)) $Snap.unit))
; [eval] _residue_169_0 < Level(t_2_0)
; [eval] Level(t_2_0)
(push) ; 25
(assert (Level%precondition $Snap.unit tmp_12@1124@01))
(pop) ; 25
; Joined path conditions
(assert (Level%precondition $Snap.unit tmp_12@1124@01))
(assert (< _residue_169_0@1067@01 (Level $Snap.unit tmp_12@1124@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert (p1_21 ==> _joinable(_checkDefined(t_2, 3301236))) &&
;   (p2_21 ==> _joinable(t_2_0))
; [eval] p1_21 ==> _joinable(_checkDefined(t_2, 3301236))
(set-option :timeout 0)
(push) ; 25
(push) ; 26
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1764 | p1_21@1060@01 | live]
; [else-branch: 1764 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 1764 | p1_21@1060@01]
; [eval] _joinable(_checkDefined(t_2, 3301236))
; [eval] _checkDefined(t_2, 3301236)
(push) ; 27
; [eval] _isDefined(id)
(push) ; 28
(pop) ; 28
; Joined path conditions
(pop) ; 27
; Joined path conditions
(push) ; 27
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))
(pop) ; 27
; Joined path conditions
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))
(pop) ; 26
(pop) ; 25
; Joined path conditions
(assert (=>
  p1_21@1060@01
  (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236))))
(push) ; 25
(assert (not (=>
  p1_21@1060@01
  (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_21 ==> _joinable(_checkDefined(t_2, 3301236))
(set-option :timeout 0)
(push) ; 25
(push) ; 26
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1765 | p1_21@1060@01 | live]
; [else-branch: 1765 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 1765 | p1_21@1060@01]
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] _joinable(_checkDefined(t_2, 3301236))
; [eval] _checkDefined(t_2, 3301236)
(set-option :timeout 0)
(push) ; 27
; [eval] _isDefined(id)
(push) ; 28
(pop) ; 28
; Joined path conditions
(pop) ; 27
; Joined path conditions
(push) ; 27
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))
(pop) ; 27
; Joined path conditions
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))
(pop) ; 26
(pop) ; 25
; Joined path conditions
(push) ; 25
(assert (not (=>
  p1_21@1060@01
  (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_21 ==> _joinable(_checkDefined(t_2, 3301236))
(set-option :timeout 0)
(push) ; 25
(push) ; 26
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1766 | p1_21@1060@01 | live]
; [else-branch: 1766 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 1766 | p1_21@1060@01]
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] _joinable(_checkDefined(t_2, 3301236))
; [eval] _checkDefined(t_2, 3301236)
(set-option :timeout 0)
(push) ; 27
; [eval] _isDefined(id)
(push) ; 28
(pop) ; 28
; Joined path conditions
(pop) ; 27
; Joined path conditions
(push) ; 27
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))
(pop) ; 27
; Joined path conditions
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))
(pop) ; 26
(pop) ; 25
; Joined path conditions
(push) ; 25
(assert (not (=>
  p1_21@1060@01
  (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] p1_21 ==> _joinable(_checkDefined(t_2, 3301236))
(set-option :timeout 0)
(push) ; 25
(push) ; 26
(set-option :timeout 10)
(assert (not (not p1_21@1060@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1767 | p1_21@1060@01 | live]
; [else-branch: 1767 | !(p1_21@1060@01) | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 1767 | p1_21@1060@01]
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] _joinable(_checkDefined(t_2, 3301236))
; [eval] _checkDefined(t_2, 3301236)
(set-option :timeout 0)
(push) ; 27
; [eval] _isDefined(id)
(push) ; 28
(pop) ; 28
; Joined path conditions
(pop) ; 27
; Joined path conditions
(push) ; 27
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))
(pop) ; 27
; Joined path conditions
(assert (_joinable%precondition $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))
(pop) ; 26
(pop) ; 25
; Joined path conditions
(push) ; 25
(assert (not (=>
  p1_21@1060@01
  (_joinable $Snap.unit (_checkDefined $Snap.unit tmp_12@1124@01 3301236)))))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(pop) ; 24
(pop) ; 23
(pop) ; 22
(pop) ; 21
(pop) ; 20
(pop) ; 19
(pop) ; 18
(pop) ; 17
(pop) ; 16
(pop) ; 15
(pop) ; 14
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- Cell___init__ ----------
(declare-const p1_25@1149@01 Bool)
(declare-const p2_25@1150@01 Bool)
(declare-const _cthread_156@1151@01 $Ref)
(declare-const _cthread_156_0@1152@01 $Ref)
(declare-const _caller_measures_156@1153@01 Seq<Measure$>)
(declare-const _caller_measures_156_0@1154@01 Seq<Measure$>)
(declare-const _residue_156@1155@01 $Perm)
(declare-const _residue_156_0@1156@01 $Perm)
(declare-const self@1157@01 $Ref)
(declare-const self_0@1158@01 $Ref)
(declare-const _current_wait_level_156@1159@01 $Perm)
(declare-const _current_wait_level_156_0@1160@01 $Perm)
(declare-const p1_25@1161@01 Bool)
(declare-const p2_25@1162@01 Bool)
(declare-const _cthread_156@1163@01 $Ref)
(declare-const _cthread_156_0@1164@01 $Ref)
(declare-const _caller_measures_156@1165@01 Seq<Measure$>)
(declare-const _caller_measures_156_0@1166@01 Seq<Measure$>)
(declare-const _residue_156@1167@01 $Perm)
(declare-const _residue_156_0@1168@01 $Perm)
(declare-const self@1169@01 $Ref)
(declare-const self_0@1170@01 $Ref)
(declare-const _current_wait_level_156@1171@01 $Perm)
(declare-const _current_wait_level_156_0@1172@01 $Perm)
(push) ; 1
(declare-const $t@1173@01 $Snap)
(assert (= $t@1173@01 ($Snap.combine ($Snap.first $t@1173@01) ($Snap.second $t@1173@01))))
(assert (= ($Snap.first $t@1173@01) $Snap.unit))
; [eval] p1_25 ==> _cthread_156 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_25@1161@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1768 | p1_25@1161@01 | live]
; [else-branch: 1768 | !(p1_25@1161@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1768 | p1_25@1161@01]
(assert p1_25@1161@01)
; [eval] _cthread_156 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1768 | !(p1_25@1161@01)]
(assert (not p1_25@1161@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_25@1161@01) p1_25@1161@01))
(assert (=> p1_25@1161@01 (not (= _cthread_156@1163@01 $Ref.null))))
(assert (=
  ($Snap.second $t@1173@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1173@01))
    ($Snap.second ($Snap.second $t@1173@01)))))
(assert (= ($Snap.first ($Snap.second $t@1173@01)) $Snap.unit))
; [eval] p2_25 ==> _cthread_156_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_25@1162@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1769 | p2_25@1162@01 | live]
; [else-branch: 1769 | !(p2_25@1162@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1769 | p2_25@1162@01]
(assert p2_25@1162@01)
; [eval] _cthread_156_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1769 | !(p2_25@1162@01)]
(assert (not p2_25@1162@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_25@1162@01) p2_25@1162@01))
(assert (=> p2_25@1162@01 (not (= _cthread_156_0@1164@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@1173@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1173@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1173@01))) $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(_cthread_156), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_25@1161@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1770 | p1_25@1161@01 | live]
; [else-branch: 1770 | !(p1_25@1161@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1770 | p1_25@1161@01]
(assert p1_25@1161@01)
; [eval] issubtype(typeof(_cthread_156), Thread_0())
; [eval] typeof(_cthread_156)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1770 | !(p1_25@1161@01)]
(assert (not p1_25@1161@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_25@1161@01
  (issubtype<Bool> (typeof<PyType> _cthread_156@1163@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(_cthread_156_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_25@1162@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1771 | p2_25@1162@01 | live]
; [else-branch: 1771 | !(p2_25@1162@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1771 | p2_25@1162@01]
(assert p2_25@1162@01)
; [eval] issubtype(typeof(_cthread_156_0), Thread_0())
; [eval] typeof(_cthread_156_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1771 | !(p2_25@1162@01)]
(assert (not p2_25@1162@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_25@1162@01
  (issubtype<Bool> (typeof<PyType> _cthread_156_0@1164@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))
  $Snap.unit))
; [eval] p1_25 ==> self != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_25@1161@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1772 | p1_25@1161@01 | live]
; [else-branch: 1772 | !(p1_25@1161@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1772 | p1_25@1161@01]
(assert p1_25@1161@01)
; [eval] self != null
(pop) ; 3
(push) ; 3
; [else-branch: 1772 | !(p1_25@1161@01)]
(assert (not p1_25@1161@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p1_25@1161@01 (not (= self@1169@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))
  $Snap.unit))
; [eval] p2_25 ==> self_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_25@1162@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1773 | p2_25@1162@01 | live]
; [else-branch: 1773 | !(p2_25@1162@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1773 | p2_25@1162@01]
(assert p2_25@1162@01)
; [eval] self_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1773 | !(p2_25@1162@01)]
(assert (not p2_25@1162@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p2_25@1162@01 (not (= self_0@1170@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
(push) ; 2
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 2
(set-option :timeout 10)
(assert (not p1_25@1161@01))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1774 | p1_25@1161@01 | live]
; [else-branch: 1774 | !(p1_25@1161@01) | live]
(set-option :timeout 0)
(push) ; 2
; [then-branch: 1774 | p1_25@1161@01]
(assert p1_25@1161@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_25@1162@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1775 | p2_25@1162@01 | live]
; [else-branch: 1775 | !(p2_25@1162@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1775 | p2_25@1162@01]
(assert p2_25@1162@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self), Cell())
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1776 | p1_25@1161@01 | live]
; [else-branch: 1776 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1776 | p1_25@1161@01]
; [eval] issubtype(typeof(self), Cell())
; [eval] typeof(self)
; [eval] Cell()
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p1_25@1161@01
  (issubtype<Bool> (typeof<PyType> self@1169@01) (as Cell<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0), Cell())
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1777 | p2_25@1162@01 | live]
; [else-branch: 1777 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1777 | p2_25@1162@01]
; [eval] issubtype(typeof(self_0), Cell())
; [eval] typeof(self_0)
; [eval] Cell()
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p2_25@1162@01
  (issubtype<Bool> (typeof<PyType> self_0@1170@01) (as Cell<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
  $Snap.unit))
; [eval] p1_25 ==> self != null
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1778 | p1_25@1161@01 | live]
; [else-branch: 1778 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1778 | p1_25@1161@01]
; [eval] self != null
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
  $Snap.unit))
; [eval] p2_25 ==> self_0 != null
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1779 | p2_25@1162@01 | live]
; [else-branch: 1779 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1779 | p2_25@1162@01]
; [eval] self_0 != null
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1780 | p1_25@1161@01 | live]
; [else-branch: 1780 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1780 | p1_25@1161@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1781 | p2_25@1162@01 | live]
; [else-branch: 1781 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1781 | p2_25@1162@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(declare-const $t@1174@01 $Snap)
(assert (= $t@1174@01 ($Snap.combine ($Snap.first $t@1174@01) ($Snap.second $t@1174@01))))
(assert (= ($Snap.first $t@1174@01) $Snap.unit))
; [eval] p1_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1782 | p1_25@1161@01 | live]
; [else-branch: 1782 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1782 | p1_25@1161@01]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156)
(push) ; 7
; [then-branch: 1783 | False | live]
; [else-branch: 1783 | True | live]
(push) ; 8
; [then-branch: 1783 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1783 | True]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156)
(push) ; 9
; [then-branch: 1784 | False | live]
; [else-branch: 1784 | True | live]
(push) ; 10
; [then-branch: 1784 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 1784 | True]
; [eval] _residue_156 <= _current_wait_level_156
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=> p1_25@1161@01 (<= _residue_156@1167@01 _current_wait_level_156@1171@01)))
(assert (=
  ($Snap.second $t@1174@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1174@01))
    ($Snap.second ($Snap.second $t@1174@01)))))
(assert (= ($Snap.first ($Snap.second $t@1174@01)) $Snap.unit))
; [eval] p2_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1785 | p2_25@1162@01 | live]
; [else-branch: 1785 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1785 | p2_25@1162@01]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0)
(push) ; 7
; [then-branch: 1786 | False | live]
; [else-branch: 1786 | True | live]
(push) ; 8
; [then-branch: 1786 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1786 | True]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0)
(push) ; 9
; [then-branch: 1787 | False | live]
; [else-branch: 1787 | True | live]
(push) ; 10
; [then-branch: 1787 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 1787 | True]
; [eval] _residue_156_0 <= _current_wait_level_156_0
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=> p2_25@1162@01 (<= _residue_156_0@1168@01 _current_wait_level_156_0@1172@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1174@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1174@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1788 | p1_25@1161@01 | live]
; [else-branch: 1788 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1788 | p1_25@1161@01]
(assert (not (= self@1169@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))))
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1789 | p2_25@1162@01 | live]
; [else-branch: 1789 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1789 | p2_25@1162@01]
(assert (not (= self_0@1170@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self.Cell_val), int())
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1790 | p1_25@1161@01 | live]
; [else-branch: 1790 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1790 | p1_25@1161@01]
; [eval] issubtype(typeof(self.Cell_val), int())
; [eval] typeof(self.Cell_val)
; [eval] int()
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p1_25@1161@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1174@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0.Cell_valp), int())
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1791 | p2_25@1162@01 | live]
; [else-branch: 1791 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1791 | p2_25@1162@01]
; [eval] issubtype(typeof(self_0.Cell_valp), int())
; [eval] typeof(self_0.Cell_valp)
; [eval] int()
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p2_25@1162@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))))
  $Snap.unit))
; [eval] p1_25 ==> int___eq__(self.Cell_val, __prim__int___box__(0))
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1792 | p1_25@1161@01 | live]
; [else-branch: 1792 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1792 | p1_25@1161@01]
; [eval] int___eq__(self.Cell_val, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 9
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 9
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(push) ; 9
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 10
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1174@01))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1174@01))))) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 10
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1174@01)))) (__prim__int___box__ $Snap.unit 0)))
(pop) ; 9
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1174@01))))) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1174@01)))) (__prim__int___box__ $Snap.unit 0))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p1_25@1161@01
  (and
    (__prim__int___box__%precondition $Snap.unit 0)
    (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1174@01))))) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1174@01)))) (__prim__int___box__ $Snap.unit 0)))))
(assert (=>
  p1_25@1161@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1174@01)))) (__prim__int___box__ $Snap.unit 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))))))
  $Snap.unit))
; [eval] p2_25 ==> int___eq__(self_0.Cell_valp, __prim__int___box__(0))
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1793 | p2_25@1162@01 | live]
; [else-branch: 1793 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1793 | p2_25@1162@01]
; [eval] int___eq__(self_0.Cell_valp, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 9
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 9
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(push) ; 9
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 10
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 10
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))) (__prim__int___box__ $Snap.unit 0)))
(pop) ; 9
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))) (__prim__int___box__ $Snap.unit 0))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p2_25@1162@01
  (and
    (__prim__int___box__%precondition $Snap.unit 0)
    (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))) (__prim__int___box__ $Snap.unit 0)))))
(assert (=>
  p2_25@1162@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))) (__prim__int___box__ $Snap.unit 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1794 | p1_25@1161@01 | live]
; [else-branch: 1794 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1794 | p1_25@1161@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1174@01)))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1795 | p2_25@1162@01 | live]
; [else-branch: 1795 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1795 | p2_25@1162@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
(pop) ; 4
(push) ; 4
; [exec]
; var _err: Ref
(declare-const _err@1175@01 $Ref)
; [exec]
; var _err_10: Ref
(declare-const _err_10@1176@01 $Ref)
; [exec]
; var self_8: Ref
(declare-const self_8@1177@01 $Ref)
; [exec]
; var self_8_0: Ref
(declare-const self_8_0@1178@01 $Ref)
; [exec]
; var _cwl_156: Perm
(declare-const _cwl_156@1179@01 $Perm)
; [exec]
; var _cwl_156_0: Perm
(declare-const _cwl_156_0@1180@01 $Perm)
; [exec]
; var _method_measures_156: Seq[Measure$]
(declare-const _method_measures_156@1181@01 Seq<Measure$>)
; [exec]
; var _method_measures_156_0: Seq[Measure$]
(declare-const _method_measures_156_0@1182@01 Seq<Measure$>)
; [exec]
; var p1_26: Bool
(declare-const p1_26@1183@01 Bool)
; [exec]
; var p2_26: Bool
(declare-const p2_26@1184@01 Bool)
; [exec]
; var p3_15: Bool
(declare-const p3_15@1185@01 Bool)
; [exec]
; var p4_15: Bool
(declare-const p4_15@1186@01 Bool)
; [exec]
; inhale p1_25
(declare-const $t@1187@01 $Snap)
(assert (= $t@1187@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1796 | p1_25@1161@01 | live]
; [else-branch: 1796 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1796 | p1_25@1161@01]
; [exec]
; _method_measures_156 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; inhale typeof(self) == Cell()
(declare-const $t@1188@01 $Snap)
(assert (= $t@1188@01 $Snap.unit))
; [eval] typeof(self) == Cell()
; [eval] typeof(self)
; [eval] Cell()
(assert (= (typeof<PyType> self@1169@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _err := null
; [exec]
; self_8 := self
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1797 | p2_25@1162@01 | live]
; [else-branch: 1797 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1797 | p2_25@1162@01]
; [exec]
; _method_measures_156_0 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; inhale typeof(self_0) == Cell()
(declare-const $t@1189@01 $Snap)
(assert (= $t@1189@01 $Snap.unit))
; [eval] typeof(self_0) == Cell()
; [eval] typeof(self_0)
; [eval] Cell()
(assert (= (typeof<PyType> self_0@1170@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _err_10 := null
; [exec]
; self_8_0 := self_0
; [exec]
; p1_26 := p1_25 && perm(_MaySet(self_8, 7809653381050164547)) > none
; [eval] p1_25 && perm(_MaySet(self_8, 7809653381050164547)) > none
(set-option :timeout 0)
(push) ; 7
; [then-branch: 1798 | !(p1_25@1161@01) | live]
; [else-branch: 1798 | p1_25@1161@01 | live]
(push) ; 8
; [then-branch: 1798 | !(p1_25@1161@01)]
(assert (not p1_25@1161@01))
(pop) ; 8
(push) ; 8
; [else-branch: 1798 | p1_25@1161@01]
; [eval] perm(_MaySet(self_8, 7809653381050164547)) > none
; [eval] perm(_MaySet(self_8, 7809653381050164547))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or p1_25@1161@01 (not p1_25@1161@01)))
; [exec]
; p2_26 := p2_25 && perm(_MaySet_0(self_8_0, 7809653381050164547)) > none
; [eval] p2_25 && perm(_MaySet_0(self_8_0, 7809653381050164547)) > none
(push) ; 7
; [then-branch: 1799 | !(p2_25@1162@01) | live]
; [else-branch: 1799 | p2_25@1162@01 | live]
(push) ; 8
; [then-branch: 1799 | !(p2_25@1162@01)]
(assert (not p2_25@1162@01))
(pop) ; 8
(push) ; 8
; [else-branch: 1799 | p2_25@1162@01]
; [eval] perm(_MaySet_0(self_8_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(self_8_0, 7809653381050164547))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or p2_25@1162@01 (not p2_25@1162@01)))
; [exec]
; p3_15 := p1_25 && !(perm(_MaySet(self_8, 7809653381050164547)) > none)
; [eval] p1_25 && !(perm(_MaySet(self_8, 7809653381050164547)) > none)
(push) ; 7
; [then-branch: 1800 | !(p1_25@1161@01) | live]
; [else-branch: 1800 | p1_25@1161@01 | live]
(push) ; 8
; [then-branch: 1800 | !(p1_25@1161@01)]
(assert (not p1_25@1161@01))
(pop) ; 8
(push) ; 8
; [else-branch: 1800 | p1_25@1161@01]
; [eval] !(perm(_MaySet(self_8, 7809653381050164547)) > none)
; [eval] perm(_MaySet(self_8, 7809653381050164547)) > none
; [eval] perm(_MaySet(self_8, 7809653381050164547))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
; [exec]
; p4_15 := p2_25 && !(perm(_MaySet_0(self_8_0, 7809653381050164547)) > none)
; [eval] p2_25 && !(perm(_MaySet_0(self_8_0, 7809653381050164547)) > none)
(push) ; 7
; [then-branch: 1801 | !(p2_25@1162@01) | live]
; [else-branch: 1801 | p2_25@1162@01 | live]
(push) ; 8
; [then-branch: 1801 | !(p2_25@1162@01)]
(assert (not p2_25@1162@01))
(pop) ; 8
(push) ; 8
; [else-branch: 1801 | p2_25@1162@01]
; [eval] !(perm(_MaySet_0(self_8_0, 7809653381050164547)) > none)
; [eval] perm(_MaySet_0(self_8_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(self_8_0, 7809653381050164547))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1802 | p1_25@1161@01 | live]
; [else-branch: 1802 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 1802 | p1_25@1161@01]
; [exec]
; exhale acc(_MaySet(self_8, 7809653381050164547), write)
; [exec]
; inhale acc(self_8.Cell_val, write)
(declare-const $t@1190@01 $Ref)
(assert (not (= self@1169@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1803 | p2_25@1162@01 | live]
; [else-branch: 1803 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1803 | p2_25@1162@01]
; [exec]
; exhale acc(_MaySet_0(self_8_0, 7809653381050164547), write)
; [exec]
; inhale acc(self_8_0.Cell_valp, write)
(declare-const $t@1191@01 $Ref)
(assert (not (= self_0@1170@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1804 | p1_25@1161@01 | live]
; [else-branch: 1804 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 1804 | p1_25@1161@01]
; [exec]
; self_8.Cell_val := __prim__int___box__(0)
; [eval] __prim__int___box__(0)
(push) ; 10
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 10
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(declare-const Cell_val@1192@01 $Ref)
(assert (= Cell_val@1192@01 (__prim__int___box__ $Snap.unit 0)))
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1805 | p2_25@1162@01 | live]
; [else-branch: 1805 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 1805 | p2_25@1162@01]
; [exec]
; self_8_0.Cell_valp := __prim__int___box__(0)
; [eval] __prim__int___box__(0)
(push) ; 11
(pop) ; 11
; Joined path conditions
(declare-const Cell_valp@1193@01 $Ref)
(assert (= Cell_valp@1193@01 (__prim__int___box__ $Snap.unit 0)))
; [exec]
; assert true
; [eval] p1_25 ==> true
(push) ; 11
(push) ; 12
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1806 | p1_25@1161@01 | live]
; [else-branch: 1806 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 1806 | p1_25@1161@01]
(pop) ; 12
(pop) ; 11
; Joined path conditions
; [eval] p2_25 ==> true
(push) ; 11
(push) ; 12
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1807 | p2_25@1162@01 | live]
; [else-branch: 1807 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 1807 | p2_25@1162@01]
(pop) ; 12
(pop) ; 11
; Joined path conditions
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1808 | p1_25@1161@01 | live]
; [else-branch: 1808 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 1808 | p1_25@1161@01]
(push) ; 12
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1809 | p2_25@1162@01 | live]
; [else-branch: 1809 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 1809 | p2_25@1162@01]
; [eval] p1_25 ==> issubtype(typeof(self.Cell_val), int())
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1810 | p1_25@1161@01 | live]
; [else-branch: 1810 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1810 | p1_25@1161@01]
; [eval] issubtype(typeof(self.Cell_val), int())
; [eval] typeof(self.Cell_val)
; [eval] int()
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (=>
  p1_25@1161@01
  (issubtype<Bool> (typeof<PyType> Cell_val@1192@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_25@1161@01
  (issubtype<Bool> (typeof<PyType> Cell_val@1192@01) (as int<PyType>  PyType))))
; [eval] p2_25 ==> issubtype(typeof(self_0.Cell_valp), int())
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1811 | p2_25@1162@01 | live]
; [else-branch: 1811 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1811 | p2_25@1162@01]
; [eval] issubtype(typeof(self_0.Cell_valp), int())
; [eval] typeof(self_0.Cell_valp)
; [eval] int()
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (=>
  p2_25@1162@01
  (issubtype<Bool> (typeof<PyType> Cell_valp@1193@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_25@1162@01
  (issubtype<Bool> (typeof<PyType> Cell_valp@1193@01) (as int<PyType>  PyType))))
; [eval] p1_25 ==> int___eq__(self.Cell_val, __prim__int___box__(0))
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1812 | p1_25@1161@01 | live]
; [else-branch: 1812 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1812 | p1_25@1161@01]
; [eval] int___eq__(self.Cell_val, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 16
(assert (not (issubtype<Bool> (typeof<PyType> Cell_val@1192@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> Cell_val@1192@01) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 16
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) Cell_val@1192@01 (__prim__int___box__ $Snap.unit 0)))
(pop) ; 15
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> Cell_val@1192@01) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) Cell_val@1192@01 (__prim__int___box__ $Snap.unit 0))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (=>
  p1_25@1161@01
  (and
    (issubtype<Bool> (typeof<PyType> Cell_val@1192@01) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) Cell_val@1192@01 (__prim__int___box__ $Snap.unit 0)))))
(push) ; 13
(assert (not (=>
  p1_25@1161@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) Cell_val@1192@01 (__prim__int___box__ $Snap.unit 0)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_25@1161@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) Cell_val@1192@01 (__prim__int___box__ $Snap.unit 0))))
; [eval] p2_25 ==> int___eq__(self_0.Cell_valp, __prim__int___box__(0))
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1813 | p2_25@1162@01 | live]
; [else-branch: 1813 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1813 | p2_25@1162@01]
; [eval] int___eq__(self_0.Cell_valp, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 16
(assert (not (issubtype<Bool> (typeof<PyType> Cell_valp@1193@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> Cell_valp@1193@01) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 16
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) Cell_valp@1193@01 (__prim__int___box__ $Snap.unit 0)))
(pop) ; 15
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> Cell_valp@1193@01) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) Cell_valp@1193@01 (__prim__int___box__ $Snap.unit 0))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (=>
  p2_25@1162@01
  (and
    (issubtype<Bool> (typeof<PyType> Cell_valp@1193@01) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) Cell_valp@1193@01 (__prim__int___box__ $Snap.unit 0)))))
(push) ; 13
(assert (not (=>
  p2_25@1162@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) Cell_valp@1193@01 (__prim__int___box__ $Snap.unit 0)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_25@1162@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) Cell_valp@1193@01 (__prim__int___box__ $Snap.unit 0))))
; [eval] p1_25 ==> (forperm _r_40: Ref [MustInvokeBounded(_r_40)] :: false) && ((forperm _r_40: Ref [MustInvokeUnbounded(_r_40)] :: false) && ((forperm _r_40: Ref [_r_40.MustReleaseBounded] :: false) && (forperm _r_40: Ref [_r_40.MustReleaseUnbounded] :: false)))
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1814 | p1_25@1161@01 | live]
; [else-branch: 1814 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1814 | p1_25@1161@01]
; [eval] (forperm _r_40: Ref [MustInvokeBounded(_r_40)] :: false) && ((forperm _r_40: Ref [MustInvokeUnbounded(_r_40)] :: false) && ((forperm _r_40: Ref [_r_40.MustReleaseBounded] :: false) && (forperm _r_40: Ref [_r_40.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_40: Ref [MustInvokeBounded(_r_40)] :: false)
(push) ; 15
; [then-branch: 1815 | False | live]
; [else-branch: 1815 | True | live]
(push) ; 16
; [then-branch: 1815 | False]
(assert false)
(pop) ; 16
(push) ; 16
; [else-branch: 1815 | True]
; [eval] (forperm _r_40: Ref [MustInvokeUnbounded(_r_40)] :: false)
(push) ; 17
; [then-branch: 1816 | False | live]
; [else-branch: 1816 | True | live]
(push) ; 18
; [then-branch: 1816 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 1816 | True]
; [eval] (forperm _r_40: Ref [_r_40.MustReleaseBounded] :: false)
(push) ; 19
; [then-branch: 1817 | False | live]
; [else-branch: 1817 | True | live]
(push) ; 20
; [then-branch: 1817 | False]
(assert false)
(pop) ; 20
(push) ; 20
; [else-branch: 1817 | True]
; [eval] (forperm _r_40: Ref [_r_40.MustReleaseUnbounded] :: false)
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p2_25 ==> (forperm _r_40: Ref [MustInvokeBounded_0(_r_40)] :: false) && ((forperm _r_40: Ref [MustInvokeUnbounded_0(_r_40)] :: false) && ((forperm _r_40: Ref [_r_40.MustReleaseBoundedp] :: false) && (forperm _r_40: Ref [_r_40.MustReleaseUnboundedp] :: false)))
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1818 | p2_25@1162@01 | live]
; [else-branch: 1818 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1818 | p2_25@1162@01]
; [eval] (forperm _r_40: Ref [MustInvokeBounded_0(_r_40)] :: false) && ((forperm _r_40: Ref [MustInvokeUnbounded_0(_r_40)] :: false) && ((forperm _r_40: Ref [_r_40.MustReleaseBoundedp] :: false) && (forperm _r_40: Ref [_r_40.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_40: Ref [MustInvokeBounded_0(_r_40)] :: false)
(push) ; 15
; [then-branch: 1819 | False | live]
; [else-branch: 1819 | True | live]
(push) ; 16
; [then-branch: 1819 | False]
(assert false)
(pop) ; 16
(push) ; 16
; [else-branch: 1819 | True]
; [eval] (forperm _r_40: Ref [MustInvokeUnbounded_0(_r_40)] :: false)
(push) ; 17
; [then-branch: 1820 | False | live]
; [else-branch: 1820 | True | live]
(push) ; 18
; [then-branch: 1820 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 1820 | True]
; [eval] (forperm _r_40: Ref [_r_40.MustReleaseBoundedp] :: false)
(push) ; 19
; [then-branch: 1821 | False | live]
; [else-branch: 1821 | True | live]
(push) ; 20
; [then-branch: 1821 | False]
(assert false)
(pop) ; 20
(push) ; 20
; [else-branch: 1821 | True]
; [eval] (forperm _r_40: Ref [_r_40.MustReleaseUnboundedp] :: false)
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(pop) ; 14
(pop) ; 13
; Joined path conditions
(pop) ; 12
(pop) ; 11
(pop) ; 10
; [eval] !p2_25
; [then-branch: 1822 | !(p2_25@1162@01) | dead]
; [else-branch: 1822 | p2_25@1162@01 | live]
(push) ; 10
; [else-branch: 1822 | p2_25@1162@01]
(pop) ; 10
(pop) ; 9
; [eval] !p1_25
; [then-branch: 1823 | !(p1_25@1161@01) | dead]
; [else-branch: 1823 | p1_25@1161@01 | live]
(push) ; 9
; [else-branch: 1823 | p1_25@1161@01]
(pop) ; 9
(pop) ; 8
; [eval] !p2_26
; [then-branch: 1824 | !(p2_25@1162@01) | dead]
; [else-branch: 1824 | p2_25@1162@01 | live]
(push) ; 8
; [else-branch: 1824 | p2_25@1162@01]
(pop) ; 8
(pop) ; 7
; [eval] !p1_26
; [then-branch: 1825 | !(p1_25@1161@01) | dead]
; [else-branch: 1825 | p1_25@1161@01 | live]
(push) ; 7
; [else-branch: 1825 | p1_25@1161@01]
(pop) ; 7
(pop) ; 6
; [eval] !p2_25
; [then-branch: 1826 | !(p2_25@1162@01) | dead]
; [else-branch: 1826 | p2_25@1162@01 | live]
(push) ; 6
; [else-branch: 1826 | p2_25@1162@01]
(pop) ; 6
(pop) ; 5
; [eval] !p1_25
; [then-branch: 1827 | !(p1_25@1161@01) | dead]
; [else-branch: 1827 | p1_25@1161@01 | live]
(push) ; 5
; [else-branch: 1827 | p1_25@1161@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 1775 | !(p2_25@1162@01)]
(assert (not p2_25@1162@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self), Cell())
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1828 | p1_25@1161@01 | live]
; [else-branch: 1828 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1828 | p1_25@1161@01]
; [eval] issubtype(typeof(self), Cell())
; [eval] typeof(self)
; [eval] Cell()
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p1_25@1161@01
  (issubtype<Bool> (typeof<PyType> self@1169@01) (as Cell<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0), Cell())
(push) ; 4
; [then-branch: 1829 | p2_25@1162@01 | dead]
; [else-branch: 1829 | !(p2_25@1162@01) | live]
(push) ; 5
; [else-branch: 1829 | !(p2_25@1162@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
  $Snap.unit))
; [eval] p1_25 ==> self != null
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1830 | p1_25@1161@01 | live]
; [else-branch: 1830 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1830 | p1_25@1161@01]
; [eval] self != null
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
  $Snap.unit))
; [eval] p2_25 ==> self_0 != null
(push) ; 4
; [then-branch: 1831 | p2_25@1162@01 | dead]
; [else-branch: 1831 | !(p2_25@1162@01) | live]
(push) ; 5
; [else-branch: 1831 | !(p2_25@1162@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1832 | p1_25@1161@01 | live]
; [else-branch: 1832 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1832 | p1_25@1161@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 4
; [then-branch: 1833 | p2_25@1162@01 | dead]
; [else-branch: 1833 | !(p2_25@1162@01) | live]
(push) ; 5
; [else-branch: 1833 | !(p2_25@1162@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(declare-const $t@1194@01 $Snap)
(assert (= $t@1194@01 ($Snap.combine ($Snap.first $t@1194@01) ($Snap.second $t@1194@01))))
(assert (= ($Snap.first $t@1194@01) $Snap.unit))
; [eval] p1_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1834 | p1_25@1161@01 | live]
; [else-branch: 1834 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1834 | p1_25@1161@01]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156)
(push) ; 7
; [then-branch: 1835 | False | live]
; [else-branch: 1835 | True | live]
(push) ; 8
; [then-branch: 1835 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1835 | True]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156)
(push) ; 9
; [then-branch: 1836 | False | live]
; [else-branch: 1836 | True | live]
(push) ; 10
; [then-branch: 1836 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 1836 | True]
; [eval] _residue_156 <= _current_wait_level_156
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=> p1_25@1161@01 (<= _residue_156@1167@01 _current_wait_level_156@1171@01)))
(assert (=
  ($Snap.second $t@1194@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1194@01))
    ($Snap.second ($Snap.second $t@1194@01)))))
(assert (= ($Snap.first ($Snap.second $t@1194@01)) $Snap.unit))
; [eval] p2_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
(push) ; 5
; [then-branch: 1837 | p2_25@1162@01 | dead]
; [else-branch: 1837 | !(p2_25@1162@01) | live]
(push) ; 6
; [else-branch: 1837 | !(p2_25@1162@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1194@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1194@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1838 | p1_25@1161@01 | live]
; [else-branch: 1838 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1838 | p1_25@1161@01]
(assert (not (= self@1169@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))))
; [then-branch: 1839 | p2_25@1162@01 | dead]
; [else-branch: 1839 | !(p2_25@1162@01) | live]
(push) ; 6
; [else-branch: 1839 | !(p2_25@1162@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self.Cell_val), int())
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1840 | p1_25@1161@01 | live]
; [else-branch: 1840 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1840 | p1_25@1161@01]
; [eval] issubtype(typeof(self.Cell_val), int())
; [eval] typeof(self.Cell_val)
; [eval] int()
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p1_25@1161@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1194@01))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0.Cell_valp), int())
(push) ; 7
; [then-branch: 1841 | p2_25@1162@01 | dead]
; [else-branch: 1841 | !(p2_25@1162@01) | live]
(push) ; 8
; [else-branch: 1841 | !(p2_25@1162@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))))
  $Snap.unit))
; [eval] p1_25 ==> int___eq__(self.Cell_val, __prim__int___box__(0))
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1842 | p1_25@1161@01 | live]
; [else-branch: 1842 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1842 | p1_25@1161@01]
; [eval] int___eq__(self.Cell_val, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 9
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 9
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(push) ; 9
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 10
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1194@01))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1194@01))))) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 10
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1194@01)))) (__prim__int___box__ $Snap.unit 0)))
(pop) ; 9
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1194@01))))) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1194@01)))) (__prim__int___box__ $Snap.unit 0))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p1_25@1161@01
  (and
    (__prim__int___box__%precondition $Snap.unit 0)
    (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1194@01))))) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1194@01)))) (__prim__int___box__ $Snap.unit 0)))))
(assert (=>
  p1_25@1161@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@1194@01)))) (__prim__int___box__ $Snap.unit 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))))))
  $Snap.unit))
; [eval] p2_25 ==> int___eq__(self_0.Cell_valp, __prim__int___box__(0))
(push) ; 7
; [then-branch: 1843 | p2_25@1162@01 | dead]
; [else-branch: 1843 | !(p2_25@1162@01) | live]
(push) ; 8
; [else-branch: 1843 | !(p2_25@1162@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1844 | p1_25@1161@01 | live]
; [else-branch: 1844 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1844 | p1_25@1161@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1194@01)))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 7
; [then-branch: 1845 | p2_25@1162@01 | dead]
; [else-branch: 1845 | !(p2_25@1162@01) | live]
(push) ; 8
; [else-branch: 1845 | !(p2_25@1162@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
(pop) ; 4
(push) ; 4
; [exec]
; var _err: Ref
(declare-const _err@1195@01 $Ref)
; [exec]
; var _err_10: Ref
(declare-const _err_10@1196@01 $Ref)
; [exec]
; var self_8: Ref
(declare-const self_8@1197@01 $Ref)
; [exec]
; var self_8_0: Ref
(declare-const self_8_0@1198@01 $Ref)
; [exec]
; var _cwl_156: Perm
(declare-const _cwl_156@1199@01 $Perm)
; [exec]
; var _cwl_156_0: Perm
(declare-const _cwl_156_0@1200@01 $Perm)
; [exec]
; var _method_measures_156: Seq[Measure$]
(declare-const _method_measures_156@1201@01 Seq<Measure$>)
; [exec]
; var _method_measures_156_0: Seq[Measure$]
(declare-const _method_measures_156_0@1202@01 Seq<Measure$>)
; [exec]
; var p1_26: Bool
(declare-const p1_26@1203@01 Bool)
; [exec]
; var p2_26: Bool
(declare-const p2_26@1204@01 Bool)
; [exec]
; var p3_15: Bool
(declare-const p3_15@1205@01 Bool)
; [exec]
; var p4_15: Bool
(declare-const p4_15@1206@01 Bool)
; [exec]
; inhale p1_25
(declare-const $t@1207@01 $Snap)
(assert (= $t@1207@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1846 | p1_25@1161@01 | live]
; [else-branch: 1846 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1846 | p1_25@1161@01]
; [exec]
; _method_measures_156 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; inhale typeof(self) == Cell()
(declare-const $t@1208@01 $Snap)
(assert (= $t@1208@01 $Snap.unit))
; [eval] typeof(self) == Cell()
; [eval] typeof(self)
; [eval] Cell()
(assert (= (typeof<PyType> self@1169@01) (as Cell<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _err := null
; [exec]
; self_8 := self
; [then-branch: 1847 | p2_25@1162@01 | dead]
; [else-branch: 1847 | !(p2_25@1162@01) | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 1847 | !(p2_25@1162@01)]
(pop) ; 6
; [eval] !p2_25
(push) ; 6
(set-option :timeout 10)
(assert (not p2_25@1162@01))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1848 | !(p2_25@1162@01) | live]
; [else-branch: 1848 | p2_25@1162@01 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1848 | !(p2_25@1162@01)]
; [exec]
; p1_26 := p1_25 && perm(_MaySet(self_8, 7809653381050164547)) > none
; [eval] p1_25 && perm(_MaySet(self_8, 7809653381050164547)) > none
(push) ; 7
; [then-branch: 1849 | !(p1_25@1161@01) | live]
; [else-branch: 1849 | p1_25@1161@01 | live]
(push) ; 8
; [then-branch: 1849 | !(p1_25@1161@01)]
(assert (not p1_25@1161@01))
(pop) ; 8
(push) ; 8
; [else-branch: 1849 | p1_25@1161@01]
; [eval] perm(_MaySet(self_8, 7809653381050164547)) > none
; [eval] perm(_MaySet(self_8, 7809653381050164547))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or p1_25@1161@01 (not p1_25@1161@01)))
; [exec]
; p2_26 := p2_25 && perm(_MaySet_0(self_8_0, 7809653381050164547)) > none
; [eval] p2_25 && perm(_MaySet_0(self_8_0, 7809653381050164547)) > none
(push) ; 7
; [then-branch: 1850 | !(p2_25@1162@01) | live]
; [else-branch: 1850 | p2_25@1162@01 | live]
(push) ; 8
; [then-branch: 1850 | !(p2_25@1162@01)]
(pop) ; 8
(push) ; 8
; [else-branch: 1850 | p2_25@1162@01]
(assert p2_25@1162@01)
; [eval] perm(_MaySet_0(self_8_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(self_8_0, 7809653381050164547))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or p2_25@1162@01 (not p2_25@1162@01)))
; [exec]
; p3_15 := p1_25 && !(perm(_MaySet(self_8, 7809653381050164547)) > none)
; [eval] p1_25 && !(perm(_MaySet(self_8, 7809653381050164547)) > none)
(push) ; 7
; [then-branch: 1851 | !(p1_25@1161@01) | live]
; [else-branch: 1851 | p1_25@1161@01 | live]
(push) ; 8
; [then-branch: 1851 | !(p1_25@1161@01)]
(assert (not p1_25@1161@01))
(pop) ; 8
(push) ; 8
; [else-branch: 1851 | p1_25@1161@01]
; [eval] !(perm(_MaySet(self_8, 7809653381050164547)) > none)
; [eval] perm(_MaySet(self_8, 7809653381050164547)) > none
; [eval] perm(_MaySet(self_8, 7809653381050164547))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
; [exec]
; p4_15 := p2_25 && !(perm(_MaySet_0(self_8_0, 7809653381050164547)) > none)
; [eval] p2_25 && !(perm(_MaySet_0(self_8_0, 7809653381050164547)) > none)
(push) ; 7
; [then-branch: 1852 | !(p2_25@1162@01) | live]
; [else-branch: 1852 | p2_25@1162@01 | live]
(push) ; 8
; [then-branch: 1852 | !(p2_25@1162@01)]
(pop) ; 8
(push) ; 8
; [else-branch: 1852 | p2_25@1162@01]
(assert p2_25@1162@01)
; [eval] !(perm(_MaySet_0(self_8_0, 7809653381050164547)) > none)
; [eval] perm(_MaySet_0(self_8_0, 7809653381050164547)) > none
; [eval] perm(_MaySet_0(self_8_0, 7809653381050164547))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1853 | p1_25@1161@01 | live]
; [else-branch: 1853 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 1853 | p1_25@1161@01]
; [exec]
; exhale acc(_MaySet(self_8, 7809653381050164547), write)
; [exec]
; inhale acc(self_8.Cell_val, write)
(declare-const $t@1209@01 $Ref)
(assert (not (= self@1169@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [then-branch: 1854 | False | dead]
; [else-branch: 1854 | True | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 1854 | True]
(pop) ; 8
; [eval] !p2_26
(push) ; 8
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1855 | True | live]
; [else-branch: 1855 | False | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1855 | True]
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1856 | p1_25@1161@01 | live]
; [else-branch: 1856 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 1856 | p1_25@1161@01]
; [exec]
; self_8.Cell_val := __prim__int___box__(0)
; [eval] __prim__int___box__(0)
(push) ; 10
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 10
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(declare-const Cell_val@1210@01 $Ref)
(assert (= Cell_val@1210@01 (__prim__int___box__ $Snap.unit 0)))
; [then-branch: 1857 | p2_25@1162@01 | dead]
; [else-branch: 1857 | !(p2_25@1162@01) | live]
(push) ; 10
; [else-branch: 1857 | !(p2_25@1162@01)]
(pop) ; 10
; [eval] !p2_25
(push) ; 10
(set-option :timeout 10)
(assert (not p2_25@1162@01))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1858 | !(p2_25@1162@01) | live]
; [else-branch: 1858 | p2_25@1162@01 | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 1858 | !(p2_25@1162@01)]
; [exec]
; assert true
; [eval] p1_25 ==> true
(push) ; 11
(push) ; 12
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1859 | p1_25@1161@01 | live]
; [else-branch: 1859 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 1859 | p1_25@1161@01]
(pop) ; 12
(pop) ; 11
; Joined path conditions
; [eval] p2_25 ==> true
(push) ; 11
; [then-branch: 1860 | p2_25@1162@01 | dead]
; [else-branch: 1860 | !(p2_25@1162@01) | live]
(push) ; 12
; [else-branch: 1860 | !(p2_25@1162@01)]
(pop) ; 12
(pop) ; 11
; Joined path conditions
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1861 | p1_25@1161@01 | live]
; [else-branch: 1861 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 1861 | p1_25@1161@01]
; [then-branch: 1862 | p2_25@1162@01 | dead]
; [else-branch: 1862 | !(p2_25@1162@01) | live]
(push) ; 12
; [else-branch: 1862 | !(p2_25@1162@01)]
; [eval] p1_25 ==> issubtype(typeof(self.Cell_val), int())
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1863 | p1_25@1161@01 | live]
; [else-branch: 1863 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1863 | p1_25@1161@01]
; [eval] issubtype(typeof(self.Cell_val), int())
; [eval] typeof(self.Cell_val)
; [eval] int()
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (=>
  p1_25@1161@01
  (issubtype<Bool> (typeof<PyType> Cell_val@1210@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_25@1161@01
  (issubtype<Bool> (typeof<PyType> Cell_val@1210@01) (as int<PyType>  PyType))))
; [eval] p2_25 ==> issubtype(typeof(self_0.Cell_valp), int())
(push) ; 13
; [then-branch: 1864 | p2_25@1162@01 | dead]
; [else-branch: 1864 | !(p2_25@1162@01) | live]
(push) ; 14
; [else-branch: 1864 | !(p2_25@1162@01)]
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p1_25 ==> int___eq__(self.Cell_val, __prim__int___box__(0))
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1865 | p1_25@1161@01 | live]
; [else-branch: 1865 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1865 | p1_25@1161@01]
; [eval] int___eq__(self.Cell_val, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 16
(assert (not (issubtype<Bool> (typeof<PyType> Cell_val@1210@01) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> Cell_val@1210@01) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 16
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) Cell_val@1210@01 (__prim__int___box__ $Snap.unit 0)))
(pop) ; 15
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> Cell_val@1210@01) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) Cell_val@1210@01 (__prim__int___box__ $Snap.unit 0))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (=>
  p1_25@1161@01
  (and
    (issubtype<Bool> (typeof<PyType> Cell_val@1210@01) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) Cell_val@1210@01 (__prim__int___box__ $Snap.unit 0)))))
(push) ; 13
(assert (not (=>
  p1_25@1161@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) Cell_val@1210@01 (__prim__int___box__ $Snap.unit 0)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_25@1161@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) Cell_val@1210@01 (__prim__int___box__ $Snap.unit 0))))
; [eval] p2_25 ==> int___eq__(self_0.Cell_valp, __prim__int___box__(0))
(push) ; 13
; [then-branch: 1866 | p2_25@1162@01 | dead]
; [else-branch: 1866 | !(p2_25@1162@01) | live]
(push) ; 14
; [else-branch: 1866 | !(p2_25@1162@01)]
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p1_25 ==> (forperm _r_40: Ref [MustInvokeBounded(_r_40)] :: false) && ((forperm _r_40: Ref [MustInvokeUnbounded(_r_40)] :: false) && ((forperm _r_40: Ref [_r_40.MustReleaseBounded] :: false) && (forperm _r_40: Ref [_r_40.MustReleaseUnbounded] :: false)))
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_25@1161@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1867 | p1_25@1161@01 | live]
; [else-branch: 1867 | !(p1_25@1161@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 1867 | p1_25@1161@01]
; [eval] (forperm _r_40: Ref [MustInvokeBounded(_r_40)] :: false) && ((forperm _r_40: Ref [MustInvokeUnbounded(_r_40)] :: false) && ((forperm _r_40: Ref [_r_40.MustReleaseBounded] :: false) && (forperm _r_40: Ref [_r_40.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_40: Ref [MustInvokeBounded(_r_40)] :: false)
(push) ; 15
; [then-branch: 1868 | False | live]
; [else-branch: 1868 | True | live]
(push) ; 16
; [then-branch: 1868 | False]
(assert false)
(pop) ; 16
(push) ; 16
; [else-branch: 1868 | True]
; [eval] (forperm _r_40: Ref [MustInvokeUnbounded(_r_40)] :: false)
(push) ; 17
; [then-branch: 1869 | False | live]
; [else-branch: 1869 | True | live]
(push) ; 18
; [then-branch: 1869 | False]
(assert false)
(pop) ; 18
(push) ; 18
; [else-branch: 1869 | True]
; [eval] (forperm _r_40: Ref [_r_40.MustReleaseBounded] :: false)
(push) ; 19
; [then-branch: 1870 | False | live]
; [else-branch: 1870 | True | live]
(push) ; 20
; [then-branch: 1870 | False]
(assert false)
(pop) ; 20
(push) ; 20
; [else-branch: 1870 | True]
; [eval] (forperm _r_40: Ref [_r_40.MustReleaseUnbounded] :: false)
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p2_25 ==> (forperm _r_40: Ref [MustInvokeBounded_0(_r_40)] :: false) && ((forperm _r_40: Ref [MustInvokeUnbounded_0(_r_40)] :: false) && ((forperm _r_40: Ref [_r_40.MustReleaseBoundedp] :: false) && (forperm _r_40: Ref [_r_40.MustReleaseUnboundedp] :: false)))
(push) ; 13
; [then-branch: 1871 | p2_25@1162@01 | dead]
; [else-branch: 1871 | !(p2_25@1162@01) | live]
(push) ; 14
; [else-branch: 1871 | !(p2_25@1162@01)]
(pop) ; 14
(pop) ; 13
; Joined path conditions
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
; [eval] !p1_25
; [then-branch: 1872 | !(p1_25@1161@01) | dead]
; [else-branch: 1872 | p1_25@1161@01 | live]
(push) ; 9
; [else-branch: 1872 | p1_25@1161@01]
(pop) ; 9
(pop) ; 8
(pop) ; 7
; [eval] !p1_26
; [then-branch: 1873 | !(p1_25@1161@01) | dead]
; [else-branch: 1873 | p1_25@1161@01 | live]
(push) ; 7
; [else-branch: 1873 | p1_25@1161@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
; [eval] !p1_25
; [then-branch: 1874 | !(p1_25@1161@01) | dead]
; [else-branch: 1874 | p1_25@1161@01 | live]
(push) ; 5
; [else-branch: 1874 | p1_25@1161@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [else-branch: 1774 | !(p1_25@1161@01)]
(assert (not p1_25@1161@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_25@1162@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1875 | p2_25@1162@01 | live]
; [else-branch: 1875 | !(p2_25@1162@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1875 | p2_25@1162@01]
(assert p2_25@1162@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self), Cell())
(push) ; 4
; [then-branch: 1876 | p1_25@1161@01 | dead]
; [else-branch: 1876 | !(p1_25@1161@01) | live]
(push) ; 5
; [else-branch: 1876 | !(p1_25@1161@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0), Cell())
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1877 | p2_25@1162@01 | live]
; [else-branch: 1877 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1877 | p2_25@1162@01]
; [eval] issubtype(typeof(self_0), Cell())
; [eval] typeof(self_0)
; [eval] Cell()
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p2_25@1162@01
  (issubtype<Bool> (typeof<PyType> self_0@1170@01) (as Cell<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
  $Snap.unit))
; [eval] p1_25 ==> self != null
(push) ; 4
; [then-branch: 1878 | p1_25@1161@01 | dead]
; [else-branch: 1878 | !(p1_25@1161@01) | live]
(push) ; 5
; [else-branch: 1878 | !(p1_25@1161@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
  $Snap.unit))
; [eval] p2_25 ==> self_0 != null
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1879 | p2_25@1162@01 | live]
; [else-branch: 1879 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1879 | p2_25@1162@01]
; [eval] self_0 != null
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 4
; [then-branch: 1880 | p1_25@1161@01 | dead]
; [else-branch: 1880 | !(p1_25@1161@01) | live]
(push) ; 5
; [else-branch: 1880 | !(p1_25@1161@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1881 | p2_25@1162@01 | live]
; [else-branch: 1881 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 1881 | p2_25@1162@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(declare-const $t@1211@01 $Snap)
(assert (= $t@1211@01 ($Snap.combine ($Snap.first $t@1211@01) ($Snap.second $t@1211@01))))
(assert (= ($Snap.first $t@1211@01) $Snap.unit))
; [eval] p1_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
(push) ; 5
; [then-branch: 1882 | p1_25@1161@01 | dead]
; [else-branch: 1882 | !(p1_25@1161@01) | live]
(push) ; 6
; [else-branch: 1882 | !(p1_25@1161@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second $t@1211@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1211@01))
    ($Snap.second ($Snap.second $t@1211@01)))))
(assert (= ($Snap.first ($Snap.second $t@1211@01)) $Snap.unit))
; [eval] p2_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1883 | p2_25@1162@01 | live]
; [else-branch: 1883 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1883 | p2_25@1162@01]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0)
(push) ; 7
; [then-branch: 1884 | False | live]
; [else-branch: 1884 | True | live]
(push) ; 8
; [then-branch: 1884 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1884 | True]
; [eval] (forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0)
(push) ; 9
; [then-branch: 1885 | False | live]
; [else-branch: 1885 | True | live]
(push) ; 10
; [then-branch: 1885 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 1885 | True]
; [eval] _residue_156_0 <= _current_wait_level_156_0
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=> p2_25@1162@01 (<= _residue_156_0@1168@01 _current_wait_level_156_0@1172@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1211@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1211@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))))
; [then-branch: 1886 | p1_25@1161@01 | dead]
; [else-branch: 1886 | !(p1_25@1161@01) | live]
(push) ; 5
; [else-branch: 1886 | !(p1_25@1161@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1211@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))))
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1887 | p2_25@1162@01 | live]
; [else-branch: 1887 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1887 | p2_25@1162@01]
(assert (not (= self_0@1170@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self.Cell_val), int())
(push) ; 7
; [then-branch: 1888 | p1_25@1161@01 | dead]
; [else-branch: 1888 | !(p1_25@1161@01) | live]
(push) ; 8
; [else-branch: 1888 | !(p1_25@1161@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0.Cell_valp), int())
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1889 | p2_25@1162@01 | live]
; [else-branch: 1889 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1889 | p2_25@1162@01]
; [eval] issubtype(typeof(self_0.Cell_valp), int())
; [eval] typeof(self_0.Cell_valp)
; [eval] int()
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p2_25@1162@01
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))))
  $Snap.unit))
; [eval] p1_25 ==> int___eq__(self.Cell_val, __prim__int___box__(0))
(push) ; 7
; [then-branch: 1890 | p1_25@1161@01 | dead]
; [else-branch: 1890 | !(p1_25@1161@01) | live]
(push) ; 8
; [else-branch: 1890 | !(p1_25@1161@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))))))
  $Snap.unit))
; [eval] p2_25 ==> int___eq__(self_0.Cell_valp, __prim__int___box__(0))
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1891 | p2_25@1162@01 | live]
; [else-branch: 1891 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1891 | p2_25@1162@01]
; [eval] int___eq__(self_0.Cell_valp, __prim__int___box__(0))
; [eval] __prim__int___box__(0)
(push) ; 9
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 9
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(push) ; 9
; [eval] issubtype(typeof(self), int())
; [eval] typeof(self)
; [eval] int()
(push) ; 10
(assert (not (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))) (as int<PyType>  PyType)))
; [eval] issubtype(typeof(other), int())
; [eval] typeof(other)
; [eval] int()
(push) ; 10
(assert (not (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType)))
(assert (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))) (__prim__int___box__ $Snap.unit 0)))
(pop) ; 9
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))) (as int<PyType>  PyType))
  (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
  (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))) (__prim__int___box__ $Snap.unit 0))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p2_25@1162@01
  (and
    (__prim__int___box__%precondition $Snap.unit 0)
    (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))) (as int<PyType>  PyType))
    (issubtype<Bool> (typeof<PyType> (__prim__int___box__ $Snap.unit 0)) (as int<PyType>  PyType))
    (int___eq__%precondition ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))) (__prim__int___box__ $Snap.unit 0)))))
(assert (=>
  p2_25@1162@01
  (int___eq__ ($Snap.combine $Snap.unit $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))) (__prim__int___box__ $Snap.unit 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 7
; [then-branch: 1892 | p1_25@1161@01 | dead]
; [else-branch: 1892 | !(p1_25@1161@01) | live]
(push) ; 8
; [else-branch: 1892 | !(p1_25@1161@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1211@01)))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_25@1162@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1893 | p2_25@1162@01 | live]
; [else-branch: 1893 | !(p2_25@1162@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 1893 | p2_25@1162@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
(pop) ; 4
(push) ; 4
; [exec]
; var _err: Ref
(declare-const _err@1212@01 $Ref)
; [exec]
; var _err_10: Ref
(declare-const _err_10@1213@01 $Ref)
; [exec]
; var self_8: Ref
(declare-const self_8@1214@01 $Ref)
; [exec]
; var self_8_0: Ref
(declare-const self_8_0@1215@01 $Ref)
; [exec]
; var _cwl_156: Perm
(declare-const _cwl_156@1216@01 $Perm)
; [exec]
; var _cwl_156_0: Perm
(declare-const _cwl_156_0@1217@01 $Perm)
; [exec]
; var _method_measures_156: Seq[Measure$]
(declare-const _method_measures_156@1218@01 Seq<Measure$>)
; [exec]
; var _method_measures_156_0: Seq[Measure$]
(declare-const _method_measures_156_0@1219@01 Seq<Measure$>)
; [exec]
; var p1_26: Bool
(declare-const p1_26@1220@01 Bool)
; [exec]
; var p2_26: Bool
(declare-const p2_26@1221@01 Bool)
; [exec]
; var p3_15: Bool
(declare-const p3_15@1222@01 Bool)
; [exec]
; var p4_15: Bool
(declare-const p4_15@1223@01 Bool)
; [exec]
; inhale p1_25
(declare-const $t@1224@01 $Snap)
(assert (= $t@1224@01 $Snap.unit))
(assert p1_25@1161@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 1894 | p1_25@1161@01 | dead]
; [else-branch: 1894 | !(p1_25@1161@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 1894 | !(p1_25@1161@01)]
(pop) ; 5
; [eval] !p1_25
; [then-branch: 1895 | !(p1_25@1161@01) | dead]
; [else-branch: 1895 | p1_25@1161@01 | live]
(push) ; 5
; [else-branch: 1895 | p1_25@1161@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 1875 | !(p2_25@1162@01)]
(assert (not p2_25@1162@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self), Cell())
(push) ; 4
; [then-branch: 1896 | p1_25@1161@01 | dead]
; [else-branch: 1896 | !(p1_25@1161@01) | live]
(push) ; 5
; [else-branch: 1896 | !(p1_25@1161@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0), Cell())
(push) ; 4
; [then-branch: 1897 | p2_25@1162@01 | dead]
; [else-branch: 1897 | !(p2_25@1162@01) | live]
(push) ; 5
; [else-branch: 1897 | !(p2_25@1162@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
  $Snap.unit))
; [eval] p1_25 ==> self != null
(push) ; 4
; [then-branch: 1898 | p1_25@1161@01 | dead]
; [else-branch: 1898 | !(p1_25@1161@01) | live]
(push) ; 5
; [else-branch: 1898 | !(p1_25@1161@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
  $Snap.unit))
; [eval] p2_25 ==> self_0 != null
(push) ; 4
; [then-branch: 1899 | p2_25@1162@01 | dead]
; [else-branch: 1899 | !(p2_25@1162@01) | live]
(push) ; 5
; [else-branch: 1899 | !(p2_25@1162@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 4
; [then-branch: 1900 | p1_25@1161@01 | dead]
; [else-branch: 1900 | !(p1_25@1161@01) | live]
(push) ; 5
; [else-branch: 1900 | !(p1_25@1161@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1173@01)))))))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 4
; [then-branch: 1901 | p2_25@1162@01 | dead]
; [else-branch: 1901 | !(p2_25@1162@01) | live]
(push) ; 5
; [else-branch: 1901 | !(p2_25@1162@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(declare-const $t@1225@01 $Snap)
(assert (= $t@1225@01 ($Snap.combine ($Snap.first $t@1225@01) ($Snap.second $t@1225@01))))
(assert (= ($Snap.first $t@1225@01) $Snap.unit))
; [eval] p1_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBounded] :: Level(_r_39) <= _current_wait_level_156) && ((forperm _r_39: Ref [_r_39.MustReleaseUnbounded] :: Level(_r_39) <= _current_wait_level_156) && _residue_156 <= _current_wait_level_156)
(push) ; 5
; [then-branch: 1902 | p1_25@1161@01 | dead]
; [else-branch: 1902 | !(p1_25@1161@01) | live]
(push) ; 6
; [else-branch: 1902 | !(p1_25@1161@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second $t@1225@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1225@01))
    ($Snap.second ($Snap.second $t@1225@01)))))
(assert (= ($Snap.first ($Snap.second $t@1225@01)) $Snap.unit))
; [eval] p2_25 ==> (forperm _r_39: Ref [_r_39.MustReleaseBoundedp] :: Level(_r_39) <= _current_wait_level_156_0) && ((forperm _r_39: Ref [_r_39.MustReleaseUnboundedp] :: Level(_r_39) <= _current_wait_level_156_0) && _residue_156_0 <= _current_wait_level_156_0)
(push) ; 5
; [then-branch: 1903 | p2_25@1162@01 | dead]
; [else-branch: 1903 | !(p2_25@1162@01) | live]
(push) ; 6
; [else-branch: 1903 | !(p2_25@1162@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1225@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1225@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))))
; [then-branch: 1904 | p1_25@1161@01 | dead]
; [else-branch: 1904 | !(p1_25@1161@01) | live]
(push) ; 5
; [else-branch: 1904 | !(p1_25@1161@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1225@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))))
; [then-branch: 1905 | p2_25@1162@01 | dead]
; [else-branch: 1905 | !(p2_25@1162@01) | live]
(push) ; 6
; [else-branch: 1905 | !(p2_25@1162@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))
  $Snap.unit))
; [eval] p1_25 ==> issubtype(typeof(self.Cell_val), int())
(push) ; 7
; [then-branch: 1906 | p1_25@1161@01 | dead]
; [else-branch: 1906 | !(p1_25@1161@01) | live]
(push) ; 8
; [else-branch: 1906 | !(p1_25@1161@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))))
  $Snap.unit))
; [eval] p2_25 ==> issubtype(typeof(self_0.Cell_valp), int())
(push) ; 7
; [then-branch: 1907 | p2_25@1162@01 | dead]
; [else-branch: 1907 | !(p2_25@1162@01) | live]
(push) ; 8
; [else-branch: 1907 | !(p2_25@1162@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))))
  $Snap.unit))
; [eval] p1_25 ==> int___eq__(self.Cell_val, __prim__int___box__(0))
(push) ; 7
; [then-branch: 1908 | p1_25@1161@01 | dead]
; [else-branch: 1908 | !(p1_25@1161@01) | live]
(push) ; 8
; [else-branch: 1908 | !(p1_25@1161@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))))))
  $Snap.unit))
; [eval] p2_25 ==> int___eq__(self_0.Cell_valp, __prim__int___box__(0))
(push) ; 7
; [then-branch: 1909 | p2_25@1162@01 | dead]
; [else-branch: 1909 | !(p2_25@1162@01) | live]
(push) ; 8
; [else-branch: 1909 | !(p2_25@1162@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))))))
  $Snap.unit))
; [eval] p1_25 ==> true
(push) ; 7
; [then-branch: 1910 | p1_25@1161@01 | dead]
; [else-branch: 1910 | !(p1_25@1161@01) | live]
(push) ; 8
; [else-branch: 1910 | !(p1_25@1161@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1225@01)))))))))
  $Snap.unit))
; [eval] p2_25 ==> true
(push) ; 7
; [then-branch: 1911 | p2_25@1162@01 | dead]
; [else-branch: 1911 | !(p2_25@1162@01) | live]
(push) ; 8
; [else-branch: 1911 | !(p2_25@1162@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
(pop) ; 4
(push) ; 4
; [exec]
; var _err: Ref
(declare-const _err@1226@01 $Ref)
; [exec]
; var _err_10: Ref
(declare-const _err_10@1227@01 $Ref)
; [exec]
; var self_8: Ref
(declare-const self_8@1228@01 $Ref)
; [exec]
; var self_8_0: Ref
(declare-const self_8_0@1229@01 $Ref)
; [exec]
; var _cwl_156: Perm
(declare-const _cwl_156@1230@01 $Perm)
; [exec]
; var _cwl_156_0: Perm
(declare-const _cwl_156_0@1231@01 $Perm)
; [exec]
; var _method_measures_156: Seq[Measure$]
(declare-const _method_measures_156@1232@01 Seq<Measure$>)
; [exec]
; var _method_measures_156_0: Seq[Measure$]
(declare-const _method_measures_156_0@1233@01 Seq<Measure$>)
; [exec]
; var p1_26: Bool
(declare-const p1_26@1234@01 Bool)
; [exec]
; var p2_26: Bool
(declare-const p2_26@1235@01 Bool)
; [exec]
; var p3_15: Bool
(declare-const p3_15@1236@01 Bool)
; [exec]
; var p4_15: Bool
(declare-const p4_15@1237@01 Bool)
; [exec]
; inhale p1_25
(declare-const $t@1238@01 $Snap)
(assert (= $t@1238@01 $Snap.unit))
(assert p1_25@1161@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 1912 | p1_25@1161@01 | dead]
; [else-branch: 1912 | !(p1_25@1161@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 1912 | !(p1_25@1161@01)]
(pop) ; 5
; [eval] !p1_25
; [then-branch: 1913 | !(p1_25@1161@01) | dead]
; [else-branch: 1913 | p1_25@1161@01 | live]
(push) ; 5
; [else-branch: 1913 | p1_25@1161@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- A_foo ----------
(declare-const p1_27@1239@01 Bool)
(declare-const p2_27@1240@01 Bool)
(declare-const _cthread_158@1241@01 $Ref)
(declare-const _cthread_158_0@1242@01 $Ref)
(declare-const _caller_measures_158@1243@01 Seq<Measure$>)
(declare-const _caller_measures_158_0@1244@01 Seq<Measure$>)
(declare-const _residue_158@1245@01 $Perm)
(declare-const _residue_158_0@1246@01 $Perm)
(declare-const self_1@1247@01 $Ref)
(declare-const self_1_0@1248@01 $Ref)
(declare-const _current_wait_level_158@1249@01 $Perm)
(declare-const _current_wait_level_158_0@1250@01 $Perm)
(declare-const _res@1251@01 $Ref)
(declare-const _res_0@1252@01 $Ref)
(declare-const p1_27@1253@01 Bool)
(declare-const p2_27@1254@01 Bool)
(declare-const _cthread_158@1255@01 $Ref)
(declare-const _cthread_158_0@1256@01 $Ref)
(declare-const _caller_measures_158@1257@01 Seq<Measure$>)
(declare-const _caller_measures_158_0@1258@01 Seq<Measure$>)
(declare-const _residue_158@1259@01 $Perm)
(declare-const _residue_158_0@1260@01 $Perm)
(declare-const self_1@1261@01 $Ref)
(declare-const self_1_0@1262@01 $Ref)
(declare-const _current_wait_level_158@1263@01 $Perm)
(declare-const _current_wait_level_158_0@1264@01 $Perm)
(declare-const _res@1265@01 $Ref)
(declare-const _res_0@1266@01 $Ref)
(push) ; 1
(declare-const $t@1267@01 $Snap)
(assert (= $t@1267@01 ($Snap.combine ($Snap.first $t@1267@01) ($Snap.second $t@1267@01))))
(assert (= ($Snap.first $t@1267@01) $Snap.unit))
; [eval] p1_27 ==> _cthread_158 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_27@1253@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1914 | p1_27@1253@01 | live]
; [else-branch: 1914 | !(p1_27@1253@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1914 | p1_27@1253@01]
(assert p1_27@1253@01)
; [eval] _cthread_158 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1914 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_27@1253@01) p1_27@1253@01))
(assert (=> p1_27@1253@01 (not (= _cthread_158@1255@01 $Ref.null))))
(assert (=
  ($Snap.second $t@1267@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1267@01))
    ($Snap.second ($Snap.second $t@1267@01)))))
(assert (= ($Snap.first ($Snap.second $t@1267@01)) $Snap.unit))
; [eval] p2_27 ==> _cthread_158_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_27@1254@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1915 | p2_27@1254@01 | live]
; [else-branch: 1915 | !(p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1915 | p2_27@1254@01]
(assert p2_27@1254@01)
; [eval] _cthread_158_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1915 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_27@1254@01) p2_27@1254@01))
(assert (=> p2_27@1254@01 (not (= _cthread_158_0@1256@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@1267@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1267@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1267@01))) $Snap.unit))
; [eval] p1_27 ==> issubtype(typeof(_cthread_158), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_27@1253@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1916 | p1_27@1253@01 | live]
; [else-branch: 1916 | !(p1_27@1253@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1916 | p1_27@1253@01]
(assert p1_27@1253@01)
; [eval] issubtype(typeof(_cthread_158), Thread_0())
; [eval] typeof(_cthread_158)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1916 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_27@1253@01
  (issubtype<Bool> (typeof<PyType> _cthread_158@1255@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))
  $Snap.unit))
; [eval] p2_27 ==> issubtype(typeof(_cthread_158_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_27@1254@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1917 | p2_27@1254@01 | live]
; [else-branch: 1917 | !(p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1917 | p2_27@1254@01]
(assert p2_27@1254@01)
; [eval] issubtype(typeof(_cthread_158_0), Thread_0())
; [eval] typeof(_cthread_158_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1917 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_27@1254@01
  (issubtype<Bool> (typeof<PyType> _cthread_158_0@1256@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))
  $Snap.unit))
; [eval] p1_27 ==> issubtype(typeof(self_1), A())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_27@1253@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1918 | p1_27@1253@01 | live]
; [else-branch: 1918 | !(p1_27@1253@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1918 | p1_27@1253@01]
(assert p1_27@1253@01)
; [eval] issubtype(typeof(self_1), A())
; [eval] typeof(self_1)
; [eval] A()
(pop) ; 3
(push) ; 3
; [else-branch: 1918 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_27@1253@01
  (issubtype<Bool> (typeof<PyType> self_1@1261@01) (as A<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))))
  $Snap.unit))
; [eval] p2_27 ==> issubtype(typeof(self_1_0), A())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_27@1254@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1919 | p2_27@1254@01 | live]
; [else-branch: 1919 | !(p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1919 | p2_27@1254@01]
(assert p2_27@1254@01)
; [eval] issubtype(typeof(self_1_0), A())
; [eval] typeof(self_1_0)
; [eval] A()
(pop) ; 3
(push) ; 3
; [else-branch: 1919 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_27@1254@01
  (issubtype<Bool> (typeof<PyType> self_1_0@1262@01) (as A<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))))
  $Snap.unit))
; [eval] p1_27 ==> self_1 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_27@1253@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1920 | p1_27@1253@01 | live]
; [else-branch: 1920 | !(p1_27@1253@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1920 | p1_27@1253@01]
(assert p1_27@1253@01)
; [eval] self_1 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1920 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p1_27@1253@01 (not (= self_1@1261@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))))))
  $Snap.unit))
; [eval] p2_27 ==> self_1_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_27@1254@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1921 | p2_27@1254@01 | live]
; [else-branch: 1921 | !(p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1921 | p2_27@1254@01]
(assert p2_27@1254@01)
; [eval] self_1_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1921 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p2_27@1254@01 (not (= self_1_0@1262@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))))))
  $Snap.unit))
; [eval] p1_27 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_27@1253@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1922 | p1_27@1253@01 | live]
; [else-branch: 1922 | !(p1_27@1253@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1922 | p1_27@1253@01]
(assert p1_27@1253@01)
(pop) ; 3
(push) ; 3
; [else-branch: 1922 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1267@01)))))))))
  $Snap.unit))
; [eval] p2_27 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_27@1254@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1923 | p2_27@1254@01 | live]
; [else-branch: 1923 | !(p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1923 | p2_27@1254@01]
(assert p2_27@1254@01)
(pop) ; 3
(push) ; 3
; [else-branch: 1923 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@1268@01 $Snap)
(assert (= $t@1268@01 ($Snap.combine ($Snap.first $t@1268@01) ($Snap.second $t@1268@01))))
(assert (= ($Snap.first $t@1268@01) $Snap.unit))
; [eval] p1_27 ==> (forperm _r_42: Ref [_r_42.MustReleaseBounded] :: Level(_r_42) <= _current_wait_level_158) && ((forperm _r_42: Ref [_r_42.MustReleaseUnbounded] :: Level(_r_42) <= _current_wait_level_158) && _residue_158 <= _current_wait_level_158)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_27@1253@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1924 | p1_27@1253@01 | live]
; [else-branch: 1924 | !(p1_27@1253@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1924 | p1_27@1253@01]
(assert p1_27@1253@01)
; [eval] (forperm _r_42: Ref [_r_42.MustReleaseBounded] :: Level(_r_42) <= _current_wait_level_158) && ((forperm _r_42: Ref [_r_42.MustReleaseUnbounded] :: Level(_r_42) <= _current_wait_level_158) && _residue_158 <= _current_wait_level_158)
; [eval] (forperm _r_42: Ref [_r_42.MustReleaseBounded] :: Level(_r_42) <= _current_wait_level_158)
(push) ; 5
; [then-branch: 1925 | False | live]
; [else-branch: 1925 | True | live]
(push) ; 6
; [then-branch: 1925 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 1925 | True]
; [eval] (forperm _r_42: Ref [_r_42.MustReleaseUnbounded] :: Level(_r_42) <= _current_wait_level_158)
(push) ; 7
; [then-branch: 1926 | False | live]
; [else-branch: 1926 | True | live]
(push) ; 8
; [then-branch: 1926 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1926 | True]
; [eval] _residue_158 <= _current_wait_level_158
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1924 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p1_27@1253@01 (<= _residue_158@1259@01 _current_wait_level_158@1263@01)))
(assert (=
  ($Snap.second $t@1268@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1268@01))
    ($Snap.second ($Snap.second $t@1268@01)))))
(assert (= ($Snap.first ($Snap.second $t@1268@01)) $Snap.unit))
; [eval] p2_27 ==> (forperm _r_42: Ref [_r_42.MustReleaseBoundedp] :: Level(_r_42) <= _current_wait_level_158_0) && ((forperm _r_42: Ref [_r_42.MustReleaseUnboundedp] :: Level(_r_42) <= _current_wait_level_158_0) && _residue_158_0 <= _current_wait_level_158_0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_27@1254@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1927 | p2_27@1254@01 | live]
; [else-branch: 1927 | !(p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1927 | p2_27@1254@01]
(assert p2_27@1254@01)
; [eval] (forperm _r_42: Ref [_r_42.MustReleaseBoundedp] :: Level(_r_42) <= _current_wait_level_158_0) && ((forperm _r_42: Ref [_r_42.MustReleaseUnboundedp] :: Level(_r_42) <= _current_wait_level_158_0) && _residue_158_0 <= _current_wait_level_158_0)
; [eval] (forperm _r_42: Ref [_r_42.MustReleaseBoundedp] :: Level(_r_42) <= _current_wait_level_158_0)
(push) ; 5
; [then-branch: 1928 | False | live]
; [else-branch: 1928 | True | live]
(push) ; 6
; [then-branch: 1928 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 1928 | True]
; [eval] (forperm _r_42: Ref [_r_42.MustReleaseUnboundedp] :: Level(_r_42) <= _current_wait_level_158_0)
(push) ; 7
; [then-branch: 1929 | False | live]
; [else-branch: 1929 | True | live]
(push) ; 8
; [then-branch: 1929 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1929 | True]
; [eval] _residue_158_0 <= _current_wait_level_158_0
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1927 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p2_27@1254@01 (<= _residue_158_0@1260@01 _current_wait_level_158_0@1264@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1268@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1268@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1268@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1268@01))) $Snap.unit))
; [eval] p1_27 ==> issubtype(typeof(_res), int())
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_27@1253@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1930 | p1_27@1253@01 | live]
; [else-branch: 1930 | !(p1_27@1253@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1930 | p1_27@1253@01]
(assert p1_27@1253@01)
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 4
(push) ; 4
; [else-branch: 1930 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_27@1253@01
  (issubtype<Bool> (typeof<PyType> _res@1265@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1268@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1268@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1268@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1268@01))))
  $Snap.unit))
; [eval] p2_27 ==> issubtype(typeof(_res_0), int())
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_27@1254@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1931 | p2_27@1254@01 | live]
; [else-branch: 1931 | !(p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1931 | p2_27@1254@01]
(assert p2_27@1254@01)
; [eval] issubtype(typeof(_res_0), int())
; [eval] typeof(_res_0)
; [eval] int()
(pop) ; 4
(push) ; 4
; [else-branch: 1931 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_27@1254@01
  (issubtype<Bool> (typeof<PyType> _res_0@1266@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1268@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1268@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1268@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1268@01)))))
  $Snap.unit))
; [eval] p1_27 && p2_27 ==> typeof(self_1) == typeof(self_1_0) ==> _res == _res_0
; [eval] p1_27 && p2_27
(push) ; 3
; [then-branch: 1932 | !(p1_27@1253@01) | live]
; [else-branch: 1932 | p1_27@1253@01 | live]
(push) ; 4
; [then-branch: 1932 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 4
(push) ; 4
; [else-branch: 1932 | p1_27@1253@01]
(assert p1_27@1253@01)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or p1_27@1253@01 (not p1_27@1253@01)))
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not (and p1_27@1253@01 p2_27@1254@01))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (and p1_27@1253@01 p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1933 | p1_27@1253@01 && p2_27@1254@01 | live]
; [else-branch: 1933 | !(p1_27@1253@01 && p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1933 | p1_27@1253@01 && p2_27@1254@01]
(assert (and p1_27@1253@01 p2_27@1254@01))
; [eval] typeof(self_1) == typeof(self_1_0) ==> _res == _res_0
; [eval] typeof(self_1) == typeof(self_1_0)
; [eval] typeof(self_1)
; [eval] typeof(self_1_0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not (= (typeof<PyType> self_1@1261@01) (typeof<PyType> self_1_0@1262@01)))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= (typeof<PyType> self_1@1261@01) (typeof<PyType> self_1_0@1262@01))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1934 | typeof[PyType](self_1@1261@01) == typeof[PyType](self_1_0@1262@01) | live]
; [else-branch: 1934 | typeof[PyType](self_1@1261@01) != typeof[PyType](self_1_0@1262@01) | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1934 | typeof[PyType](self_1@1261@01) == typeof[PyType](self_1_0@1262@01)]
(assert (= (typeof<PyType> self_1@1261@01) (typeof<PyType> self_1_0@1262@01)))
; [eval] _res == _res_0
(pop) ; 6
(push) ; 6
; [else-branch: 1934 | typeof[PyType](self_1@1261@01) != typeof[PyType](self_1_0@1262@01)]
(assert (not (= (typeof<PyType> self_1@1261@01) (typeof<PyType> self_1_0@1262@01))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (not (= (typeof<PyType> self_1@1261@01) (typeof<PyType> self_1_0@1262@01)))
  (= (typeof<PyType> self_1@1261@01) (typeof<PyType> self_1_0@1262@01))))
(pop) ; 4
(push) ; 4
; [else-branch: 1933 | !(p1_27@1253@01 && p2_27@1254@01)]
(assert (not (and p1_27@1253@01 p2_27@1254@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=>
  (and p1_27@1253@01 p2_27@1254@01)
  (and
    p1_27@1253@01
    p2_27@1254@01
    (or
      (not (= (typeof<PyType> self_1@1261@01) (typeof<PyType> self_1_0@1262@01)))
      (= (typeof<PyType> self_1@1261@01) (typeof<PyType> self_1_0@1262@01))))))
; Joined path conditions
(assert (or (not (and p1_27@1253@01 p2_27@1254@01)) (and p1_27@1253@01 p2_27@1254@01)))
(assert (=>
  (and
    (and p1_27@1253@01 p2_27@1254@01)
    (= (typeof<PyType> self_1@1261@01) (typeof<PyType> self_1_0@1262@01)))
  (= _res@1265@01 _res_0@1266@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1268@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1268@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1268@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1268@01))))))
  $Snap.unit))
; [eval] p1_27 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_27@1253@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1935 | p1_27@1253@01 | live]
; [else-branch: 1935 | !(p1_27@1253@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1935 | p1_27@1253@01]
(assert p1_27@1253@01)
(pop) ; 4
(push) ; 4
; [else-branch: 1935 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1268@01))))))
  $Snap.unit))
; [eval] p2_27 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_27@1254@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1936 | p2_27@1254@01 | live]
; [else-branch: 1936 | !(p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1936 | p2_27@1254@01]
(assert p2_27@1254@01)
(pop) ; 4
(push) ; 4
; [else-branch: 1936 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
(push) ; 2
; [exec]
; var ret1: Bool
(declare-const ret1@1269@01 Bool)
; [exec]
; var ret2: Bool
(declare-const ret2@1270@01 Bool)
; [exec]
; var _err: Ref
(declare-const _err@1271@01 $Ref)
; [exec]
; var _err_11: Ref
(declare-const _err_11@1272@01 $Ref)
; [exec]
; var self_9: Ref
(declare-const self_9@1273@01 $Ref)
; [exec]
; var self_9_0: Ref
(declare-const self_9_0@1274@01 $Ref)
; [exec]
; var _cwl_158: Perm
(declare-const _cwl_158@1275@01 $Perm)
; [exec]
; var _cwl_158_0: Perm
(declare-const _cwl_158_0@1276@01 $Perm)
; [exec]
; var _method_measures_158: Seq[Measure$]
(declare-const _method_measures_158@1277@01 Seq<Measure$>)
; [exec]
; var _method_measures_158_0: Seq[Measure$]
(declare-const _method_measures_158_0@1278@01 Seq<Measure$>)
; [exec]
; inhale p1_27
(declare-const $t@1279@01 $Snap)
(assert (= $t@1279@01 $Snap.unit))
(assert p1_27@1253@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; ret1 := false
; [exec]
; ret2 := false
; [eval] p1_27 && !ret1
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1937 | !(p1_27@1253@01) | live]
; [else-branch: 1937 | p1_27@1253@01 | live]
(push) ; 4
; [then-branch: 1937 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 4
(push) ; 4
; [else-branch: 1937 | p1_27@1253@01]
; [eval] !ret1
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or p1_27@1253@01 (not p1_27@1253@01)))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1938 | p1_27@1253@01 | live]
; [else-branch: 1938 | !(p1_27@1253@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1938 | p1_27@1253@01]
; [exec]
; _method_measures_158 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; inhale typeof(self_1) == A()
(declare-const $t@1280@01 $Snap)
(assert (= $t@1280@01 $Snap.unit))
; [eval] typeof(self_1) == A()
; [eval] typeof(self_1)
; [eval] A()
(assert (= (typeof<PyType> self_1@1261@01) (as A<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _res := null
; [exec]
; _err := null
; [exec]
; self_9 := self_1
; [exec]
; _res := __prim__int___box__(0)
; [eval] __prim__int___box__(0)
(set-option :timeout 0)
(push) ; 4
(assert (__prim__int___box__%precondition $Snap.unit 0))
(pop) ; 4
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 0))
(declare-const _res@1281@01 $Ref)
(assert (= _res@1281@01 (__prim__int___box__ $Snap.unit 0)))
; [exec]
; ret1 := true
; [eval] p2_27 && !ret2
(push) ; 4
; [then-branch: 1939 | !(p2_27@1254@01) | live]
; [else-branch: 1939 | p2_27@1254@01 | live]
(push) ; 5
; [then-branch: 1939 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 5
(push) ; 5
; [else-branch: 1939 | p2_27@1254@01]
(assert p2_27@1254@01)
; [eval] !ret2
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or p2_27@1254@01 (not p2_27@1254@01)))
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_27@1254@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1940 | p2_27@1254@01 | live]
; [else-branch: 1940 | !(p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1940 | p2_27@1254@01]
(assert p2_27@1254@01)
; [exec]
; _method_measures_158_0 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; inhale typeof(self_1_0) == A()
(declare-const $t@1282@01 $Snap)
(assert (= $t@1282@01 $Snap.unit))
; [eval] typeof(self_1_0) == A()
; [eval] typeof(self_1_0)
; [eval] A()
(assert (= (typeof<PyType> self_1_0@1262@01) (as A<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _res_0 := null
; [exec]
; _err_11 := null
; [exec]
; self_9_0 := self_1_0
; [exec]
; _res_0 := __prim__int___box__(0)
; [eval] __prim__int___box__(0)
(set-option :timeout 0)
(push) ; 5
(pop) ; 5
; Joined path conditions
(declare-const _res_0@1283@01 $Ref)
(assert (= _res_0@1283@01 (__prim__int___box__ $Snap.unit 0)))
; [exec]
; ret2 := true
; [exec]
; assert true
; [eval] p1_27 ==> true
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1941 | p1_27@1253@01 | live]
; [else-branch: 1941 | !(p1_27@1253@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1941 | p1_27@1253@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p2_27 ==> true
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1942 | p2_27@1254@01 | live]
; [else-branch: 1942 | !(p2_27@1254@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1942 | p2_27@1254@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p1_27 ==> issubtype(typeof(_res), int())
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1943 | p1_27@1253@01 | live]
; [else-branch: 1943 | !(p1_27@1253@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1943 | p1_27@1253@01]
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 6
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (=>
  p1_27@1253@01
  (issubtype<Bool> (typeof<PyType> _res@1281@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_27@1253@01
  (issubtype<Bool> (typeof<PyType> _res@1281@01) (as int<PyType>  PyType))))
; [eval] p2_27 ==> issubtype(typeof(_res_0), int())
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1944 | p2_27@1254@01 | live]
; [else-branch: 1944 | !(p2_27@1254@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1944 | p2_27@1254@01]
; [eval] issubtype(typeof(_res_0), int())
; [eval] typeof(_res_0)
; [eval] int()
(pop) ; 6
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (=>
  p2_27@1254@01
  (issubtype<Bool> (typeof<PyType> _res_0@1283@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_27@1254@01
  (issubtype<Bool> (typeof<PyType> _res_0@1283@01) (as int<PyType>  PyType))))
; [eval] p1_27 && p2_27 ==> _res == _res_0
; [eval] p1_27 && p2_27
(push) ; 5
; [then-branch: 1945 | !(p1_27@1253@01) | live]
; [else-branch: 1945 | p1_27@1253@01 | live]
(push) ; 6
; [then-branch: 1945 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 6
(push) ; 6
; [else-branch: 1945 | p1_27@1253@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not (and p1_27@1253@01 p2_27@1254@01))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (and p1_27@1253@01 p2_27@1254@01)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1946 | p1_27@1253@01 && p2_27@1254@01 | live]
; [else-branch: 1946 | !(p1_27@1253@01 && p2_27@1254@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1946 | p1_27@1253@01 && p2_27@1254@01]
(assert (and p1_27@1253@01 p2_27@1254@01))
; [eval] _res == _res_0
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (and p1_27@1253@01 p2_27@1254@01))
(push) ; 5
(assert (not (=> (and p1_27@1253@01 p2_27@1254@01) (= _res@1281@01 _res_0@1283@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=> (and p1_27@1253@01 p2_27@1254@01) (= _res@1281@01 _res_0@1283@01)))
; [eval] p1_27 ==> (forperm _r_43: Ref [MustInvokeBounded(_r_43)] :: false) && ((forperm _r_43: Ref [MustInvokeUnbounded(_r_43)] :: false) && ((forperm _r_43: Ref [_r_43.MustReleaseBounded] :: false) && (forperm _r_43: Ref [_r_43.MustReleaseUnbounded] :: false)))
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1947 | p1_27@1253@01 | live]
; [else-branch: 1947 | !(p1_27@1253@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1947 | p1_27@1253@01]
; [eval] (forperm _r_43: Ref [MustInvokeBounded(_r_43)] :: false) && ((forperm _r_43: Ref [MustInvokeUnbounded(_r_43)] :: false) && ((forperm _r_43: Ref [_r_43.MustReleaseBounded] :: false) && (forperm _r_43: Ref [_r_43.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_43: Ref [MustInvokeBounded(_r_43)] :: false)
(push) ; 7
; [then-branch: 1948 | False | live]
; [else-branch: 1948 | True | live]
(push) ; 8
; [then-branch: 1948 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1948 | True]
; [eval] (forperm _r_43: Ref [MustInvokeUnbounded(_r_43)] :: false)
(push) ; 9
; [then-branch: 1949 | False | live]
; [else-branch: 1949 | True | live]
(push) ; 10
; [then-branch: 1949 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 1949 | True]
; [eval] (forperm _r_43: Ref [_r_43.MustReleaseBounded] :: false)
(push) ; 11
; [then-branch: 1950 | False | live]
; [else-branch: 1950 | True | live]
(push) ; 12
; [then-branch: 1950 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 1950 | True]
; [eval] (forperm _r_43: Ref [_r_43.MustReleaseUnbounded] :: false)
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p2_27 ==> (forperm _r_43: Ref [MustInvokeBounded_0(_r_43)] :: false) && ((forperm _r_43: Ref [MustInvokeUnbounded_0(_r_43)] :: false) && ((forperm _r_43: Ref [_r_43.MustReleaseBoundedp] :: false) && (forperm _r_43: Ref [_r_43.MustReleaseUnboundedp] :: false)))
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1951 | p2_27@1254@01 | live]
; [else-branch: 1951 | !(p2_27@1254@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1951 | p2_27@1254@01]
; [eval] (forperm _r_43: Ref [MustInvokeBounded_0(_r_43)] :: false) && ((forperm _r_43: Ref [MustInvokeUnbounded_0(_r_43)] :: false) && ((forperm _r_43: Ref [_r_43.MustReleaseBoundedp] :: false) && (forperm _r_43: Ref [_r_43.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_43: Ref [MustInvokeBounded_0(_r_43)] :: false)
(push) ; 7
; [then-branch: 1952 | False | live]
; [else-branch: 1952 | True | live]
(push) ; 8
; [then-branch: 1952 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1952 | True]
; [eval] (forperm _r_43: Ref [MustInvokeUnbounded_0(_r_43)] :: false)
(push) ; 9
; [then-branch: 1953 | False | live]
; [else-branch: 1953 | True | live]
(push) ; 10
; [then-branch: 1953 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 1953 | True]
; [eval] (forperm _r_43: Ref [_r_43.MustReleaseBoundedp] :: false)
(push) ; 11
; [then-branch: 1954 | False | live]
; [else-branch: 1954 | True | live]
(push) ; 12
; [then-branch: 1954 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 1954 | True]
; [eval] (forperm _r_43: Ref [_r_43.MustReleaseUnboundedp] :: false)
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1940 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 4
; [eval] !(p2_27 && !ret2)
; [eval] p2_27 && !ret2
(push) ; 4
; [then-branch: 1955 | !(p2_27@1254@01) | live]
; [else-branch: 1955 | p2_27@1254@01 | live]
(push) ; 5
; [then-branch: 1955 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
(pop) ; 5
(push) ; 5
; [else-branch: 1955 | p2_27@1254@01]
(assert p2_27@1254@01)
; [eval] !ret2
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(push) ; 4
(set-option :timeout 10)
(assert (not p2_27@1254@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_27@1254@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1956 | !(p2_27@1254@01) | live]
; [else-branch: 1956 | p2_27@1254@01 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1956 | !(p2_27@1254@01)]
(assert (not p2_27@1254@01))
; [exec]
; assert true
; [eval] p1_27 ==> true
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not p1_27@1253@01))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1957 | p1_27@1253@01 | live]
; [else-branch: 1957 | !(p1_27@1253@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1957 | p1_27@1253@01]
(assert p1_27@1253@01)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert p1_27@1253@01)
; [eval] p2_27 ==> true
(push) ; 5
; [then-branch: 1958 | p2_27@1254@01 | dead]
; [else-branch: 1958 | !(p2_27@1254@01) | live]
(push) ; 6
; [else-branch: 1958 | !(p2_27@1254@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p1_27 ==> issubtype(typeof(_res), int())
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1959 | p1_27@1253@01 | live]
; [else-branch: 1959 | !(p1_27@1253@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1959 | p1_27@1253@01]
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 6
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (=>
  p1_27@1253@01
  (issubtype<Bool> (typeof<PyType> _res@1281@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_27@1253@01
  (issubtype<Bool> (typeof<PyType> _res@1281@01) (as int<PyType>  PyType))))
; [eval] p2_27 ==> issubtype(typeof(_res_0), int())
(push) ; 5
; [then-branch: 1960 | p2_27@1254@01 | dead]
; [else-branch: 1960 | !(p2_27@1254@01) | live]
(push) ; 6
; [else-branch: 1960 | !(p2_27@1254@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p1_27 && p2_27 ==> _res == _res_0
; [eval] p1_27 && p2_27
(push) ; 5
; [then-branch: 1961 | !(p1_27@1253@01) | live]
; [else-branch: 1961 | p1_27@1253@01 | live]
(push) ; 6
; [then-branch: 1961 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 6
(push) ; 6
; [else-branch: 1961 | p1_27@1253@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not (and p1_27@1253@01 p2_27@1254@01))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1962 | p1_27@1253@01 && p2_27@1254@01 | dead]
; [else-branch: 1962 | !(p1_27@1253@01 && p2_27@1254@01) | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 1962 | !(p1_27@1253@01 && p2_27@1254@01)]
(assert (not (and p1_27@1253@01 p2_27@1254@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (not (and p1_27@1253@01 p2_27@1254@01)))
; [eval] p1_27 ==> (forperm _r_43: Ref [MustInvokeBounded(_r_43)] :: false) && ((forperm _r_43: Ref [MustInvokeUnbounded(_r_43)] :: false) && ((forperm _r_43: Ref [_r_43.MustReleaseBounded] :: false) && (forperm _r_43: Ref [_r_43.MustReleaseUnbounded] :: false)))
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_27@1253@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1963 | p1_27@1253@01 | live]
; [else-branch: 1963 | !(p1_27@1253@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1963 | p1_27@1253@01]
; [eval] (forperm _r_43: Ref [MustInvokeBounded(_r_43)] :: false) && ((forperm _r_43: Ref [MustInvokeUnbounded(_r_43)] :: false) && ((forperm _r_43: Ref [_r_43.MustReleaseBounded] :: false) && (forperm _r_43: Ref [_r_43.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_43: Ref [MustInvokeBounded(_r_43)] :: false)
(push) ; 7
; [then-branch: 1964 | False | live]
; [else-branch: 1964 | True | live]
(push) ; 8
; [then-branch: 1964 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1964 | True]
; [eval] (forperm _r_43: Ref [MustInvokeUnbounded(_r_43)] :: false)
(push) ; 9
; [then-branch: 1965 | False | live]
; [else-branch: 1965 | True | live]
(push) ; 10
; [then-branch: 1965 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 1965 | True]
; [eval] (forperm _r_43: Ref [_r_43.MustReleaseBounded] :: false)
(push) ; 11
; [then-branch: 1966 | False | live]
; [else-branch: 1966 | True | live]
(push) ; 12
; [then-branch: 1966 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 1966 | True]
; [eval] (forperm _r_43: Ref [_r_43.MustReleaseUnbounded] :: false)
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p2_27 ==> (forperm _r_43: Ref [MustInvokeBounded_0(_r_43)] :: false) && ((forperm _r_43: Ref [MustInvokeUnbounded_0(_r_43)] :: false) && ((forperm _r_43: Ref [_r_43.MustReleaseBoundedp] :: false) && (forperm _r_43: Ref [_r_43.MustReleaseUnboundedp] :: false)))
(push) ; 5
; [then-branch: 1967 | p2_27@1254@01 | dead]
; [else-branch: 1967 | !(p2_27@1254@01) | live]
(push) ; 6
; [else-branch: 1967 | !(p2_27@1254@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1956 | p2_27@1254@01]
(assert p2_27@1254@01)
(pop) ; 4
(pop) ; 3
; [eval] !(p1_27 && !ret1)
; [eval] p1_27 && !ret1
(push) ; 3
; [then-branch: 1968 | !(p1_27@1253@01) | live]
; [else-branch: 1968 | p1_27@1253@01 | live]
(push) ; 4
; [then-branch: 1968 | !(p1_27@1253@01)]
(assert (not p1_27@1253@01))
(pop) ; 4
(push) ; 4
; [else-branch: 1968 | p1_27@1253@01]
(assert p1_27@1253@01)
; [eval] !ret1
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(assert (not p1_27@1253@01))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1969 | !(p1_27@1253@01) | dead]
; [else-branch: 1969 | p1_27@1253@01 | live]
(set-option :timeout 0)
(push) ; 3
; [else-branch: 1969 | p1_27@1253@01]
(assert p1_27@1253@01)
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- B_foo ----------
(declare-const p1_28@1284@01 Bool)
(declare-const p2_28@1285@01 Bool)
(declare-const _cthread_159@1286@01 $Ref)
(declare-const _cthread_159_0@1287@01 $Ref)
(declare-const _caller_measures_159@1288@01 Seq<Measure$>)
(declare-const _caller_measures_159_0@1289@01 Seq<Measure$>)
(declare-const _residue_159@1290@01 $Perm)
(declare-const _residue_159_0@1291@01 $Perm)
(declare-const self_2@1292@01 $Ref)
(declare-const self_2_0@1293@01 $Ref)
(declare-const _current_wait_level_159@1294@01 $Perm)
(declare-const _current_wait_level_159_0@1295@01 $Perm)
(declare-const _res@1296@01 $Ref)
(declare-const _res_1@1297@01 $Ref)
(declare-const p1_28@1298@01 Bool)
(declare-const p2_28@1299@01 Bool)
(declare-const _cthread_159@1300@01 $Ref)
(declare-const _cthread_159_0@1301@01 $Ref)
(declare-const _caller_measures_159@1302@01 Seq<Measure$>)
(declare-const _caller_measures_159_0@1303@01 Seq<Measure$>)
(declare-const _residue_159@1304@01 $Perm)
(declare-const _residue_159_0@1305@01 $Perm)
(declare-const self_2@1306@01 $Ref)
(declare-const self_2_0@1307@01 $Ref)
(declare-const _current_wait_level_159@1308@01 $Perm)
(declare-const _current_wait_level_159_0@1309@01 $Perm)
(declare-const _res@1310@01 $Ref)
(declare-const _res_1@1311@01 $Ref)
(push) ; 1
(declare-const $t@1312@01 $Snap)
(assert (= $t@1312@01 ($Snap.combine ($Snap.first $t@1312@01) ($Snap.second $t@1312@01))))
(assert (= ($Snap.first $t@1312@01) $Snap.unit))
; [eval] p1_28 ==> _cthread_159 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_28@1298@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1970 | p1_28@1298@01 | live]
; [else-branch: 1970 | !(p1_28@1298@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1970 | p1_28@1298@01]
(assert p1_28@1298@01)
; [eval] _cthread_159 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1970 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_28@1298@01) p1_28@1298@01))
(assert (=> p1_28@1298@01 (not (= _cthread_159@1300@01 $Ref.null))))
(assert (=
  ($Snap.second $t@1312@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1312@01))
    ($Snap.second ($Snap.second $t@1312@01)))))
(assert (= ($Snap.first ($Snap.second $t@1312@01)) $Snap.unit))
; [eval] p2_28 ==> _cthread_159_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_28@1299@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1971 | p2_28@1299@01 | live]
; [else-branch: 1971 | !(p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1971 | p2_28@1299@01]
(assert p2_28@1299@01)
; [eval] _cthread_159_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1971 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_28@1299@01) p2_28@1299@01))
(assert (=> p2_28@1299@01 (not (= _cthread_159_0@1301@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@1312@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1312@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1312@01))) $Snap.unit))
; [eval] p1_28 ==> issubtype(typeof(_cthread_159), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_28@1298@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1972 | p1_28@1298@01 | live]
; [else-branch: 1972 | !(p1_28@1298@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1972 | p1_28@1298@01]
(assert p1_28@1298@01)
; [eval] issubtype(typeof(_cthread_159), Thread_0())
; [eval] typeof(_cthread_159)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1972 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_28@1298@01
  (issubtype<Bool> (typeof<PyType> _cthread_159@1300@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))
  $Snap.unit))
; [eval] p2_28 ==> issubtype(typeof(_cthread_159_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_28@1299@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1973 | p2_28@1299@01 | live]
; [else-branch: 1973 | !(p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1973 | p2_28@1299@01]
(assert p2_28@1299@01)
; [eval] issubtype(typeof(_cthread_159_0), Thread_0())
; [eval] typeof(_cthread_159_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 1973 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_28@1299@01
  (issubtype<Bool> (typeof<PyType> _cthread_159_0@1301@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))
  $Snap.unit))
; [eval] p1_28 ==> issubtype(typeof(self_2), B())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_28@1298@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1974 | p1_28@1298@01 | live]
; [else-branch: 1974 | !(p1_28@1298@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1974 | p1_28@1298@01]
(assert p1_28@1298@01)
; [eval] issubtype(typeof(self_2), B())
; [eval] typeof(self_2)
; [eval] B()
(pop) ; 3
(push) ; 3
; [else-branch: 1974 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_28@1298@01
  (issubtype<Bool> (typeof<PyType> self_2@1306@01) (as B<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))))
  $Snap.unit))
; [eval] p2_28 ==> issubtype(typeof(self_2_0), B())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_28@1299@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1975 | p2_28@1299@01 | live]
; [else-branch: 1975 | !(p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1975 | p2_28@1299@01]
(assert p2_28@1299@01)
; [eval] issubtype(typeof(self_2_0), B())
; [eval] typeof(self_2_0)
; [eval] B()
(pop) ; 3
(push) ; 3
; [else-branch: 1975 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_28@1299@01
  (issubtype<Bool> (typeof<PyType> self_2_0@1307@01) (as B<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))))
  $Snap.unit))
; [eval] p1_28 ==> self_2 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_28@1298@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1976 | p1_28@1298@01 | live]
; [else-branch: 1976 | !(p1_28@1298@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1976 | p1_28@1298@01]
(assert p1_28@1298@01)
; [eval] self_2 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1976 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p1_28@1298@01 (not (= self_2@1306@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))))))
  $Snap.unit))
; [eval] p2_28 ==> self_2_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_28@1299@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1977 | p2_28@1299@01 | live]
; [else-branch: 1977 | !(p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1977 | p2_28@1299@01]
(assert p2_28@1299@01)
; [eval] self_2_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 1977 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p2_28@1299@01 (not (= self_2_0@1307@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))))))
  $Snap.unit))
; [eval] p1_28 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_28@1298@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1978 | p1_28@1298@01 | live]
; [else-branch: 1978 | !(p1_28@1298@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1978 | p1_28@1298@01]
(assert p1_28@1298@01)
(pop) ; 3
(push) ; 3
; [else-branch: 1978 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1312@01)))))))))
  $Snap.unit))
; [eval] p2_28 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_28@1299@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1979 | p2_28@1299@01 | live]
; [else-branch: 1979 | !(p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1979 | p2_28@1299@01]
(assert p2_28@1299@01)
(pop) ; 3
(push) ; 3
; [else-branch: 1979 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@1313@01 $Snap)
(assert (= $t@1313@01 ($Snap.combine ($Snap.first $t@1313@01) ($Snap.second $t@1313@01))))
(assert (= ($Snap.first $t@1313@01) $Snap.unit))
; [eval] p1_28 ==> (forperm _r_45: Ref [_r_45.MustReleaseBounded] :: Level(_r_45) <= _current_wait_level_159) && ((forperm _r_45: Ref [_r_45.MustReleaseUnbounded] :: Level(_r_45) <= _current_wait_level_159) && _residue_159 <= _current_wait_level_159)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_28@1298@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1980 | p1_28@1298@01 | live]
; [else-branch: 1980 | !(p1_28@1298@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1980 | p1_28@1298@01]
(assert p1_28@1298@01)
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseBounded] :: Level(_r_45) <= _current_wait_level_159) && ((forperm _r_45: Ref [_r_45.MustReleaseUnbounded] :: Level(_r_45) <= _current_wait_level_159) && _residue_159 <= _current_wait_level_159)
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseBounded] :: Level(_r_45) <= _current_wait_level_159)
(push) ; 5
; [then-branch: 1981 | False | live]
; [else-branch: 1981 | True | live]
(push) ; 6
; [then-branch: 1981 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 1981 | True]
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseUnbounded] :: Level(_r_45) <= _current_wait_level_159)
(push) ; 7
; [then-branch: 1982 | False | live]
; [else-branch: 1982 | True | live]
(push) ; 8
; [then-branch: 1982 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1982 | True]
; [eval] _residue_159 <= _current_wait_level_159
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1980 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p1_28@1298@01 (<= _residue_159@1304@01 _current_wait_level_159@1308@01)))
(assert (=
  ($Snap.second $t@1313@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1313@01))
    ($Snap.second ($Snap.second $t@1313@01)))))
(assert (= ($Snap.first ($Snap.second $t@1313@01)) $Snap.unit))
; [eval] p2_28 ==> (forperm _r_45: Ref [_r_45.MustReleaseBoundedp] :: Level(_r_45) <= _current_wait_level_159_0) && ((forperm _r_45: Ref [_r_45.MustReleaseUnboundedp] :: Level(_r_45) <= _current_wait_level_159_0) && _residue_159_0 <= _current_wait_level_159_0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_28@1299@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1983 | p2_28@1299@01 | live]
; [else-branch: 1983 | !(p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1983 | p2_28@1299@01]
(assert p2_28@1299@01)
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseBoundedp] :: Level(_r_45) <= _current_wait_level_159_0) && ((forperm _r_45: Ref [_r_45.MustReleaseUnboundedp] :: Level(_r_45) <= _current_wait_level_159_0) && _residue_159_0 <= _current_wait_level_159_0)
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseBoundedp] :: Level(_r_45) <= _current_wait_level_159_0)
(push) ; 5
; [then-branch: 1984 | False | live]
; [else-branch: 1984 | True | live]
(push) ; 6
; [then-branch: 1984 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 1984 | True]
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseUnboundedp] :: Level(_r_45) <= _current_wait_level_159_0)
(push) ; 7
; [then-branch: 1985 | False | live]
; [else-branch: 1985 | True | live]
(push) ; 8
; [then-branch: 1985 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 1985 | True]
; [eval] _residue_159_0 <= _current_wait_level_159_0
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1983 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p2_28@1299@01 (<= _residue_159_0@1305@01 _current_wait_level_159_0@1309@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1313@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1313@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1313@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1313@01))) $Snap.unit))
; [eval] p1_28 ==> issubtype(typeof(_res), int())
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_28@1298@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1986 | p1_28@1298@01 | live]
; [else-branch: 1986 | !(p1_28@1298@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1986 | p1_28@1298@01]
(assert p1_28@1298@01)
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 4
(push) ; 4
; [else-branch: 1986 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_28@1298@01
  (issubtype<Bool> (typeof<PyType> _res@1310@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1313@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1313@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1313@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1313@01))))
  $Snap.unit))
; [eval] p2_28 ==> issubtype(typeof(_res_1), int())
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_28@1299@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1987 | p2_28@1299@01 | live]
; [else-branch: 1987 | !(p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1987 | p2_28@1299@01]
(assert p2_28@1299@01)
; [eval] issubtype(typeof(_res_1), int())
; [eval] typeof(_res_1)
; [eval] int()
(pop) ; 4
(push) ; 4
; [else-branch: 1987 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_28@1299@01
  (issubtype<Bool> (typeof<PyType> _res_1@1311@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1313@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1313@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1313@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1313@01)))))
  $Snap.unit))
; [eval] p1_28 && p2_28 ==> typeof(self_2) == typeof(self_2_0) ==> _res == _res_1
; [eval] p1_28 && p2_28
(push) ; 3
; [then-branch: 1988 | !(p1_28@1298@01) | live]
; [else-branch: 1988 | p1_28@1298@01 | live]
(push) ; 4
; [then-branch: 1988 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 4
(push) ; 4
; [else-branch: 1988 | p1_28@1298@01]
(assert p1_28@1298@01)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or p1_28@1298@01 (not p1_28@1298@01)))
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not (and p1_28@1298@01 p2_28@1299@01))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (and p1_28@1298@01 p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1989 | p1_28@1298@01 && p2_28@1299@01 | live]
; [else-branch: 1989 | !(p1_28@1298@01 && p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1989 | p1_28@1298@01 && p2_28@1299@01]
(assert (and p1_28@1298@01 p2_28@1299@01))
; [eval] typeof(self_2) == typeof(self_2_0) ==> _res == _res_1
; [eval] typeof(self_2) == typeof(self_2_0)
; [eval] typeof(self_2)
; [eval] typeof(self_2_0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not (= (typeof<PyType> self_2@1306@01) (typeof<PyType> self_2_0@1307@01)))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= (typeof<PyType> self_2@1306@01) (typeof<PyType> self_2_0@1307@01))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1990 | typeof[PyType](self_2@1306@01) == typeof[PyType](self_2_0@1307@01) | live]
; [else-branch: 1990 | typeof[PyType](self_2@1306@01) != typeof[PyType](self_2_0@1307@01) | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1990 | typeof[PyType](self_2@1306@01) == typeof[PyType](self_2_0@1307@01)]
(assert (= (typeof<PyType> self_2@1306@01) (typeof<PyType> self_2_0@1307@01)))
; [eval] _res == _res_1
(pop) ; 6
(push) ; 6
; [else-branch: 1990 | typeof[PyType](self_2@1306@01) != typeof[PyType](self_2_0@1307@01)]
(assert (not (= (typeof<PyType> self_2@1306@01) (typeof<PyType> self_2_0@1307@01))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (not (= (typeof<PyType> self_2@1306@01) (typeof<PyType> self_2_0@1307@01)))
  (= (typeof<PyType> self_2@1306@01) (typeof<PyType> self_2_0@1307@01))))
(pop) ; 4
(push) ; 4
; [else-branch: 1989 | !(p1_28@1298@01 && p2_28@1299@01)]
(assert (not (and p1_28@1298@01 p2_28@1299@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=>
  (and p1_28@1298@01 p2_28@1299@01)
  (and
    p1_28@1298@01
    p2_28@1299@01
    (or
      (not (= (typeof<PyType> self_2@1306@01) (typeof<PyType> self_2_0@1307@01)))
      (= (typeof<PyType> self_2@1306@01) (typeof<PyType> self_2_0@1307@01))))))
; Joined path conditions
(assert (or (not (and p1_28@1298@01 p2_28@1299@01)) (and p1_28@1298@01 p2_28@1299@01)))
(assert (=>
  (and
    (and p1_28@1298@01 p2_28@1299@01)
    (= (typeof<PyType> self_2@1306@01) (typeof<PyType> self_2_0@1307@01)))
  (= _res@1310@01 _res_1@1311@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1313@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1313@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1313@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1313@01))))))
  $Snap.unit))
; [eval] p1_28 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_28@1298@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1991 | p1_28@1298@01 | live]
; [else-branch: 1991 | !(p1_28@1298@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1991 | p1_28@1298@01]
(assert p1_28@1298@01)
(pop) ; 4
(push) ; 4
; [else-branch: 1991 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1313@01))))))
  $Snap.unit))
; [eval] p2_28 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_28@1299@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1992 | p2_28@1299@01 | live]
; [else-branch: 1992 | !(p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1992 | p2_28@1299@01]
(assert p2_28@1299@01)
(pop) ; 4
(push) ; 4
; [else-branch: 1992 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
(push) ; 2
; [exec]
; var ret1_0: Bool
(declare-const ret1_0@1314@01 Bool)
; [exec]
; var ret2_0: Bool
(declare-const ret2_0@1315@01 Bool)
; [exec]
; var _err: Ref
(declare-const _err@1316@01 $Ref)
; [exec]
; var _err_12: Ref
(declare-const _err_12@1317@01 $Ref)
; [exec]
; var self_10: Ref
(declare-const self_10@1318@01 $Ref)
; [exec]
; var self_10_0: Ref
(declare-const self_10_0@1319@01 $Ref)
; [exec]
; var _cwl_159: Perm
(declare-const _cwl_159@1320@01 $Perm)
; [exec]
; var _cwl_159_0: Perm
(declare-const _cwl_159_0@1321@01 $Perm)
; [exec]
; var _method_measures_159: Seq[Measure$]
(declare-const _method_measures_159@1322@01 Seq<Measure$>)
; [exec]
; var _method_measures_159_0: Seq[Measure$]
(declare-const _method_measures_159_0@1323@01 Seq<Measure$>)
; [exec]
; inhale p1_28
(declare-const $t@1324@01 $Snap)
(assert (= $t@1324@01 $Snap.unit))
(assert p1_28@1298@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; ret1_0 := false
; [exec]
; ret2_0 := false
; [eval] p1_28 && !ret1_0
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1993 | !(p1_28@1298@01) | live]
; [else-branch: 1993 | p1_28@1298@01 | live]
(push) ; 4
; [then-branch: 1993 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 4
(push) ; 4
; [else-branch: 1993 | p1_28@1298@01]
; [eval] !ret1_0
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or p1_28@1298@01 (not p1_28@1298@01)))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1994 | p1_28@1298@01 | live]
; [else-branch: 1994 | !(p1_28@1298@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1994 | p1_28@1298@01]
; [exec]
; _method_measures_159 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; inhale typeof(self_2) == B()
(declare-const $t@1325@01 $Snap)
(assert (= $t@1325@01 $Snap.unit))
; [eval] typeof(self_2) == B()
; [eval] typeof(self_2)
; [eval] B()
(assert (= (typeof<PyType> self_2@1306@01) (as B<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _res := null
; [exec]
; _err := null
; [exec]
; self_10 := self_2
; [exec]
; _res := __prim__int___box__(1)
; [eval] __prim__int___box__(1)
(set-option :timeout 0)
(push) ; 4
(assert (__prim__int___box__%precondition $Snap.unit 1))
(pop) ; 4
; Joined path conditions
(assert (__prim__int___box__%precondition $Snap.unit 1))
(declare-const _res@1326@01 $Ref)
(assert (= _res@1326@01 (__prim__int___box__ $Snap.unit 1)))
; [exec]
; ret1_0 := true
; [eval] p2_28 && !ret2_0
(push) ; 4
; [then-branch: 1995 | !(p2_28@1299@01) | live]
; [else-branch: 1995 | p2_28@1299@01 | live]
(push) ; 5
; [then-branch: 1995 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 5
(push) ; 5
; [else-branch: 1995 | p2_28@1299@01]
(assert p2_28@1299@01)
; [eval] !ret2_0
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or p2_28@1299@01 (not p2_28@1299@01)))
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_28@1299@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1996 | p2_28@1299@01 | live]
; [else-branch: 1996 | !(p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1996 | p2_28@1299@01]
(assert p2_28@1299@01)
; [exec]
; _method_measures_159_0 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; inhale typeof(self_2_0) == B()
(declare-const $t@1327@01 $Snap)
(assert (= $t@1327@01 $Snap.unit))
; [eval] typeof(self_2_0) == B()
; [eval] typeof(self_2_0)
; [eval] B()
(assert (= (typeof<PyType> self_2_0@1307@01) (as B<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _res_1 := null
; [exec]
; _err_12 := null
; [exec]
; self_10_0 := self_2_0
; [exec]
; _res_1 := __prim__int___box__(1)
; [eval] __prim__int___box__(1)
(set-option :timeout 0)
(push) ; 5
(pop) ; 5
; Joined path conditions
(declare-const _res_1@1328@01 $Ref)
(assert (= _res_1@1328@01 (__prim__int___box__ $Snap.unit 1)))
; [exec]
; ret2_0 := true
; [exec]
; assert true
; [eval] p1_28 ==> true
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1997 | p1_28@1298@01 | live]
; [else-branch: 1997 | !(p1_28@1298@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1997 | p1_28@1298@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p2_28 ==> true
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1998 | p2_28@1299@01 | live]
; [else-branch: 1998 | !(p2_28@1299@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1998 | p2_28@1299@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p1_28 ==> issubtype(typeof(_res), int())
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1999 | p1_28@1298@01 | live]
; [else-branch: 1999 | !(p1_28@1298@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 1999 | p1_28@1298@01]
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 6
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (=>
  p1_28@1298@01
  (issubtype<Bool> (typeof<PyType> _res@1326@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_28@1298@01
  (issubtype<Bool> (typeof<PyType> _res@1326@01) (as int<PyType>  PyType))))
; [eval] p2_28 ==> issubtype(typeof(_res_1), int())
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2000 | p2_28@1299@01 | live]
; [else-branch: 2000 | !(p2_28@1299@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2000 | p2_28@1299@01]
; [eval] issubtype(typeof(_res_1), int())
; [eval] typeof(_res_1)
; [eval] int()
(pop) ; 6
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (=>
  p2_28@1299@01
  (issubtype<Bool> (typeof<PyType> _res_1@1328@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_28@1299@01
  (issubtype<Bool> (typeof<PyType> _res_1@1328@01) (as int<PyType>  PyType))))
; [eval] p1_28 && p2_28 ==> _res == _res_1
; [eval] p1_28 && p2_28
(push) ; 5
; [then-branch: 2001 | !(p1_28@1298@01) | live]
; [else-branch: 2001 | p1_28@1298@01 | live]
(push) ; 6
; [then-branch: 2001 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 6
(push) ; 6
; [else-branch: 2001 | p1_28@1298@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not (and p1_28@1298@01 p2_28@1299@01))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (and p1_28@1298@01 p2_28@1299@01)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2002 | p1_28@1298@01 && p2_28@1299@01 | live]
; [else-branch: 2002 | !(p1_28@1298@01 && p2_28@1299@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2002 | p1_28@1298@01 && p2_28@1299@01]
(assert (and p1_28@1298@01 p2_28@1299@01))
; [eval] _res == _res_1
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (and p1_28@1298@01 p2_28@1299@01))
(push) ; 5
(assert (not (=> (and p1_28@1298@01 p2_28@1299@01) (= _res@1326@01 _res_1@1328@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=> (and p1_28@1298@01 p2_28@1299@01) (= _res@1326@01 _res_1@1328@01)))
; [eval] p1_28 ==> (forperm _r_46: Ref [MustInvokeBounded(_r_46)] :: false) && ((forperm _r_46: Ref [MustInvokeUnbounded(_r_46)] :: false) && ((forperm _r_46: Ref [_r_46.MustReleaseBounded] :: false) && (forperm _r_46: Ref [_r_46.MustReleaseUnbounded] :: false)))
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2003 | p1_28@1298@01 | live]
; [else-branch: 2003 | !(p1_28@1298@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2003 | p1_28@1298@01]
; [eval] (forperm _r_46: Ref [MustInvokeBounded(_r_46)] :: false) && ((forperm _r_46: Ref [MustInvokeUnbounded(_r_46)] :: false) && ((forperm _r_46: Ref [_r_46.MustReleaseBounded] :: false) && (forperm _r_46: Ref [_r_46.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_46: Ref [MustInvokeBounded(_r_46)] :: false)
(push) ; 7
; [then-branch: 2004 | False | live]
; [else-branch: 2004 | True | live]
(push) ; 8
; [then-branch: 2004 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 2004 | True]
; [eval] (forperm _r_46: Ref [MustInvokeUnbounded(_r_46)] :: false)
(push) ; 9
; [then-branch: 2005 | False | live]
; [else-branch: 2005 | True | live]
(push) ; 10
; [then-branch: 2005 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 2005 | True]
; [eval] (forperm _r_46: Ref [_r_46.MustReleaseBounded] :: false)
(push) ; 11
; [then-branch: 2006 | False | live]
; [else-branch: 2006 | True | live]
(push) ; 12
; [then-branch: 2006 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 2006 | True]
; [eval] (forperm _r_46: Ref [_r_46.MustReleaseUnbounded] :: false)
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p2_28 ==> (forperm _r_46: Ref [MustInvokeBounded_0(_r_46)] :: false) && ((forperm _r_46: Ref [MustInvokeUnbounded_0(_r_46)] :: false) && ((forperm _r_46: Ref [_r_46.MustReleaseBoundedp] :: false) && (forperm _r_46: Ref [_r_46.MustReleaseUnboundedp] :: false)))
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2007 | p2_28@1299@01 | live]
; [else-branch: 2007 | !(p2_28@1299@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2007 | p2_28@1299@01]
; [eval] (forperm _r_46: Ref [MustInvokeBounded_0(_r_46)] :: false) && ((forperm _r_46: Ref [MustInvokeUnbounded_0(_r_46)] :: false) && ((forperm _r_46: Ref [_r_46.MustReleaseBoundedp] :: false) && (forperm _r_46: Ref [_r_46.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_46: Ref [MustInvokeBounded_0(_r_46)] :: false)
(push) ; 7
; [then-branch: 2008 | False | live]
; [else-branch: 2008 | True | live]
(push) ; 8
; [then-branch: 2008 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 2008 | True]
; [eval] (forperm _r_46: Ref [MustInvokeUnbounded_0(_r_46)] :: false)
(push) ; 9
; [then-branch: 2009 | False | live]
; [else-branch: 2009 | True | live]
(push) ; 10
; [then-branch: 2009 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 2009 | True]
; [eval] (forperm _r_46: Ref [_r_46.MustReleaseBoundedp] :: false)
(push) ; 11
; [then-branch: 2010 | False | live]
; [else-branch: 2010 | True | live]
(push) ; 12
; [then-branch: 2010 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 2010 | True]
; [eval] (forperm _r_46: Ref [_r_46.MustReleaseUnboundedp] :: false)
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 1996 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 4
; [eval] !(p2_28 && !ret2_0)
; [eval] p2_28 && !ret2_0
(push) ; 4
; [then-branch: 2011 | !(p2_28@1299@01) | live]
; [else-branch: 2011 | p2_28@1299@01 | live]
(push) ; 5
; [then-branch: 2011 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
(pop) ; 5
(push) ; 5
; [else-branch: 2011 | p2_28@1299@01]
(assert p2_28@1299@01)
; [eval] !ret2_0
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(push) ; 4
(set-option :timeout 10)
(assert (not p2_28@1299@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_28@1299@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2012 | !(p2_28@1299@01) | live]
; [else-branch: 2012 | p2_28@1299@01 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2012 | !(p2_28@1299@01)]
(assert (not p2_28@1299@01))
; [exec]
; assert true
; [eval] p1_28 ==> true
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not p1_28@1298@01))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2013 | p1_28@1298@01 | live]
; [else-branch: 2013 | !(p1_28@1298@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2013 | p1_28@1298@01]
(assert p1_28@1298@01)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert p1_28@1298@01)
; [eval] p2_28 ==> true
(push) ; 5
; [then-branch: 2014 | p2_28@1299@01 | dead]
; [else-branch: 2014 | !(p2_28@1299@01) | live]
(push) ; 6
; [else-branch: 2014 | !(p2_28@1299@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p1_28 ==> issubtype(typeof(_res), int())
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2015 | p1_28@1298@01 | live]
; [else-branch: 2015 | !(p1_28@1298@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2015 | p1_28@1298@01]
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 6
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (=>
  p1_28@1298@01
  (issubtype<Bool> (typeof<PyType> _res@1326@01) (as int<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_28@1298@01
  (issubtype<Bool> (typeof<PyType> _res@1326@01) (as int<PyType>  PyType))))
; [eval] p2_28 ==> issubtype(typeof(_res_1), int())
(push) ; 5
; [then-branch: 2016 | p2_28@1299@01 | dead]
; [else-branch: 2016 | !(p2_28@1299@01) | live]
(push) ; 6
; [else-branch: 2016 | !(p2_28@1299@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p1_28 && p2_28 ==> _res == _res_1
; [eval] p1_28 && p2_28
(push) ; 5
; [then-branch: 2017 | !(p1_28@1298@01) | live]
; [else-branch: 2017 | p1_28@1298@01 | live]
(push) ; 6
; [then-branch: 2017 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 6
(push) ; 6
; [else-branch: 2017 | p1_28@1298@01]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not (and p1_28@1298@01 p2_28@1299@01))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2018 | p1_28@1298@01 && p2_28@1299@01 | dead]
; [else-branch: 2018 | !(p1_28@1298@01 && p2_28@1299@01) | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 2018 | !(p1_28@1298@01 && p2_28@1299@01)]
(assert (not (and p1_28@1298@01 p2_28@1299@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (not (and p1_28@1298@01 p2_28@1299@01)))
; [eval] p1_28 ==> (forperm _r_46: Ref [MustInvokeBounded(_r_46)] :: false) && ((forperm _r_46: Ref [MustInvokeUnbounded(_r_46)] :: false) && ((forperm _r_46: Ref [_r_46.MustReleaseBounded] :: false) && (forperm _r_46: Ref [_r_46.MustReleaseUnbounded] :: false)))
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_28@1298@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2019 | p1_28@1298@01 | live]
; [else-branch: 2019 | !(p1_28@1298@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2019 | p1_28@1298@01]
; [eval] (forperm _r_46: Ref [MustInvokeBounded(_r_46)] :: false) && ((forperm _r_46: Ref [MustInvokeUnbounded(_r_46)] :: false) && ((forperm _r_46: Ref [_r_46.MustReleaseBounded] :: false) && (forperm _r_46: Ref [_r_46.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_46: Ref [MustInvokeBounded(_r_46)] :: false)
(push) ; 7
; [then-branch: 2020 | False | live]
; [else-branch: 2020 | True | live]
(push) ; 8
; [then-branch: 2020 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 2020 | True]
; [eval] (forperm _r_46: Ref [MustInvokeUnbounded(_r_46)] :: false)
(push) ; 9
; [then-branch: 2021 | False | live]
; [else-branch: 2021 | True | live]
(push) ; 10
; [then-branch: 2021 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 2021 | True]
; [eval] (forperm _r_46: Ref [_r_46.MustReleaseBounded] :: false)
(push) ; 11
; [then-branch: 2022 | False | live]
; [else-branch: 2022 | True | live]
(push) ; 12
; [then-branch: 2022 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 2022 | True]
; [eval] (forperm _r_46: Ref [_r_46.MustReleaseUnbounded] :: false)
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] p2_28 ==> (forperm _r_46: Ref [MustInvokeBounded_0(_r_46)] :: false) && ((forperm _r_46: Ref [MustInvokeUnbounded_0(_r_46)] :: false) && ((forperm _r_46: Ref [_r_46.MustReleaseBoundedp] :: false) && (forperm _r_46: Ref [_r_46.MustReleaseUnboundedp] :: false)))
(push) ; 5
; [then-branch: 2023 | p2_28@1299@01 | dead]
; [else-branch: 2023 | !(p2_28@1299@01) | live]
(push) ; 6
; [else-branch: 2023 | !(p2_28@1299@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 2012 | p2_28@1299@01]
(assert p2_28@1299@01)
(pop) ; 4
(pop) ; 3
; [eval] !(p1_28 && !ret1_0)
; [eval] p1_28 && !ret1_0
(push) ; 3
; [then-branch: 2024 | !(p1_28@1298@01) | live]
; [else-branch: 2024 | p1_28@1298@01 | live]
(push) ; 4
; [then-branch: 2024 | !(p1_28@1298@01)]
(assert (not p1_28@1298@01))
(pop) ; 4
(push) ; 4
; [else-branch: 2024 | p1_28@1298@01]
(assert p1_28@1298@01)
; [eval] !ret1_0
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(assert (not p1_28@1298@01))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2025 | !(p1_28@1298@01) | dead]
; [else-branch: 2025 | p1_28@1298@01 | live]
(set-option :timeout 0)
(push) ; 3
; [else-branch: 2025 | p1_28@1298@01]
(assert p1_28@1298@01)
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- B_foo_override_check ----------
(declare-const p1_29@1329@01 Bool)
(declare-const p2_29@1330@01 Bool)
(declare-const _cthread_158@1331@01 $Ref)
(declare-const _cthread_158_1@1332@01 $Ref)
(declare-const _caller_measures_158@1333@01 Seq<Measure$>)
(declare-const _caller_measures_158_1@1334@01 Seq<Measure$>)
(declare-const _residue_158@1335@01 $Perm)
(declare-const _residue_158_1@1336@01 $Perm)
(declare-const self_1@1337@01 $Ref)
(declare-const self_1_1@1338@01 $Ref)
(declare-const _current_wait_level_158@1339@01 $Perm)
(declare-const _current_wait_level_158_1@1340@01 $Perm)
(declare-const _res@1341@01 $Ref)
(declare-const _res_2@1342@01 $Ref)
(declare-const p1_29@1343@01 Bool)
(declare-const p2_29@1344@01 Bool)
(declare-const _cthread_158@1345@01 $Ref)
(declare-const _cthread_158_1@1346@01 $Ref)
(declare-const _caller_measures_158@1347@01 Seq<Measure$>)
(declare-const _caller_measures_158_1@1348@01 Seq<Measure$>)
(declare-const _residue_158@1349@01 $Perm)
(declare-const _residue_158_1@1350@01 $Perm)
(declare-const self_1@1351@01 $Ref)
(declare-const self_1_1@1352@01 $Ref)
(declare-const _current_wait_level_158@1353@01 $Perm)
(declare-const _current_wait_level_158_1@1354@01 $Perm)
(declare-const _res@1355@01 $Ref)
(declare-const _res_2@1356@01 $Ref)
(push) ; 1
(declare-const $t@1357@01 $Snap)
(assert (= $t@1357@01 ($Snap.combine ($Snap.first $t@1357@01) ($Snap.second $t@1357@01))))
(assert (= ($Snap.first $t@1357@01) $Snap.unit))
; [eval] p1_29 ==> _cthread_158 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2026 | p1_29@1343@01 | live]
; [else-branch: 2026 | !(p1_29@1343@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2026 | p1_29@1343@01]
(assert p1_29@1343@01)
; [eval] _cthread_158 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2026 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_29@1343@01) p1_29@1343@01))
(assert (=> p1_29@1343@01 (not (= _cthread_158@1345@01 $Ref.null))))
(assert (=
  ($Snap.second $t@1357@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1357@01))
    ($Snap.second ($Snap.second $t@1357@01)))))
(assert (= ($Snap.first ($Snap.second $t@1357@01)) $Snap.unit))
; [eval] p2_29 ==> _cthread_158_1 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2027 | p2_29@1344@01 | live]
; [else-branch: 2027 | !(p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2027 | p2_29@1344@01]
(assert p2_29@1344@01)
; [eval] _cthread_158_1 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2027 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_29@1344@01) p2_29@1344@01))
(assert (=> p2_29@1344@01 (not (= _cthread_158_1@1346@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@1357@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1357@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1357@01))) $Snap.unit))
; [eval] p1_29 ==> issubtype(typeof(_cthread_158), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2028 | p1_29@1343@01 | live]
; [else-branch: 2028 | !(p1_29@1343@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2028 | p1_29@1343@01]
(assert p1_29@1343@01)
; [eval] issubtype(typeof(_cthread_158), Thread_0())
; [eval] typeof(_cthread_158)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2028 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_29@1343@01
  (issubtype<Bool> (typeof<PyType> _cthread_158@1345@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))
  $Snap.unit))
; [eval] p2_29 ==> issubtype(typeof(_cthread_158_1), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2029 | p2_29@1344@01 | live]
; [else-branch: 2029 | !(p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2029 | p2_29@1344@01]
(assert p2_29@1344@01)
; [eval] issubtype(typeof(_cthread_158_1), Thread_0())
; [eval] typeof(_cthread_158_1)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2029 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_29@1344@01
  (issubtype<Bool> (typeof<PyType> _cthread_158_1@1346@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))
  $Snap.unit))
; [eval] p1_29 ==> self_1 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2030 | p1_29@1343@01 | live]
; [else-branch: 2030 | !(p1_29@1343@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2030 | p1_29@1343@01]
(assert p1_29@1343@01)
; [eval] self_1 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2030 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p1_29@1343@01 (not (= self_1@1351@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))
  $Snap.unit))
; [eval] p2_29 ==> self_1_1 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2031 | p2_29@1344@01 | live]
; [else-branch: 2031 | !(p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2031 | p2_29@1344@01]
(assert p2_29@1344@01)
; [eval] self_1_1 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2031 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p2_29@1344@01 (not (= self_1_1@1352@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))
  $Snap.unit))
; [eval] p1_29 ==> issubtype(typeof(self_1), A())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2032 | p1_29@1343@01 | live]
; [else-branch: 2032 | !(p1_29@1343@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2032 | p1_29@1343@01]
(assert p1_29@1343@01)
; [eval] issubtype(typeof(self_1), A())
; [eval] typeof(self_1)
; [eval] A()
(pop) ; 3
(push) ; 3
; [else-branch: 2032 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_29@1343@01
  (issubtype<Bool> (typeof<PyType> self_1@1351@01) (as A<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))))
  $Snap.unit))
; [eval] p2_29 ==> issubtype(typeof(self_1_1), A())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2033 | p2_29@1344@01 | live]
; [else-branch: 2033 | !(p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2033 | p2_29@1344@01]
(assert p2_29@1344@01)
; [eval] issubtype(typeof(self_1_1), A())
; [eval] typeof(self_1_1)
; [eval] A()
(pop) ; 3
(push) ; 3
; [else-branch: 2033 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_29@1344@01
  (issubtype<Bool> (typeof<PyType> self_1_1@1352@01) (as A<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))))
  $Snap.unit))
; [eval] p1_29 ==> self_1 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2034 | p1_29@1343@01 | live]
; [else-branch: 2034 | !(p1_29@1343@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2034 | p1_29@1343@01]
(assert p1_29@1343@01)
; [eval] self_1 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2034 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))))))
  $Snap.unit))
; [eval] p2_29 ==> self_1_1 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2035 | p2_29@1344@01 | live]
; [else-branch: 2035 | !(p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2035 | p2_29@1344@01]
(assert p2_29@1344@01)
; [eval] self_1_1 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2035 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))))))
  $Snap.unit))
; [eval] p1_29 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2036 | p1_29@1343@01 | live]
; [else-branch: 2036 | !(p1_29@1343@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2036 | p1_29@1343@01]
(assert p1_29@1343@01)
(pop) ; 3
(push) ; 3
; [else-branch: 2036 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1357@01)))))))))))
  $Snap.unit))
; [eval] p2_29 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2037 | p2_29@1344@01 | live]
; [else-branch: 2037 | !(p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2037 | p2_29@1344@01]
(assert p2_29@1344@01)
(pop) ; 3
(push) ; 3
; [else-branch: 2037 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@1358@01 $Snap)
(assert (= $t@1358@01 ($Snap.combine ($Snap.first $t@1358@01) ($Snap.second $t@1358@01))))
(assert (= ($Snap.first $t@1358@01) $Snap.unit))
; [eval] p1_29 ==> (forperm _r_48: Ref [_r_48.MustReleaseBounded] :: Level(_r_48) <= _current_wait_level_158) && ((forperm _r_48: Ref [_r_48.MustReleaseUnbounded] :: Level(_r_48) <= _current_wait_level_158) && _residue_158 <= _current_wait_level_158)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2038 | p1_29@1343@01 | live]
; [else-branch: 2038 | !(p1_29@1343@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2038 | p1_29@1343@01]
(assert p1_29@1343@01)
; [eval] (forperm _r_48: Ref [_r_48.MustReleaseBounded] :: Level(_r_48) <= _current_wait_level_158) && ((forperm _r_48: Ref [_r_48.MustReleaseUnbounded] :: Level(_r_48) <= _current_wait_level_158) && _residue_158 <= _current_wait_level_158)
; [eval] (forperm _r_48: Ref [_r_48.MustReleaseBounded] :: Level(_r_48) <= _current_wait_level_158)
(push) ; 5
; [then-branch: 2039 | False | live]
; [else-branch: 2039 | True | live]
(push) ; 6
; [then-branch: 2039 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 2039 | True]
; [eval] (forperm _r_48: Ref [_r_48.MustReleaseUnbounded] :: Level(_r_48) <= _current_wait_level_158)
(push) ; 7
; [then-branch: 2040 | False | live]
; [else-branch: 2040 | True | live]
(push) ; 8
; [then-branch: 2040 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 2040 | True]
; [eval] _residue_158 <= _current_wait_level_158
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 2038 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p1_29@1343@01 (<= _residue_158@1349@01 _current_wait_level_158@1353@01)))
(assert (=
  ($Snap.second $t@1358@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1358@01))
    ($Snap.second ($Snap.second $t@1358@01)))))
(assert (= ($Snap.first ($Snap.second $t@1358@01)) $Snap.unit))
; [eval] p2_29 ==> (forperm _r_48: Ref [_r_48.MustReleaseBoundedp] :: Level(_r_48) <= _current_wait_level_158_1) && ((forperm _r_48: Ref [_r_48.MustReleaseUnboundedp] :: Level(_r_48) <= _current_wait_level_158_1) && _residue_158_1 <= _current_wait_level_158_1)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2041 | p2_29@1344@01 | live]
; [else-branch: 2041 | !(p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2041 | p2_29@1344@01]
(assert p2_29@1344@01)
; [eval] (forperm _r_48: Ref [_r_48.MustReleaseBoundedp] :: Level(_r_48) <= _current_wait_level_158_1) && ((forperm _r_48: Ref [_r_48.MustReleaseUnboundedp] :: Level(_r_48) <= _current_wait_level_158_1) && _residue_158_1 <= _current_wait_level_158_1)
; [eval] (forperm _r_48: Ref [_r_48.MustReleaseBoundedp] :: Level(_r_48) <= _current_wait_level_158_1)
(push) ; 5
; [then-branch: 2042 | False | live]
; [else-branch: 2042 | True | live]
(push) ; 6
; [then-branch: 2042 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 2042 | True]
; [eval] (forperm _r_48: Ref [_r_48.MustReleaseUnboundedp] :: Level(_r_48) <= _current_wait_level_158_1)
(push) ; 7
; [then-branch: 2043 | False | live]
; [else-branch: 2043 | True | live]
(push) ; 8
; [then-branch: 2043 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 2043 | True]
; [eval] _residue_158_1 <= _current_wait_level_158_1
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 2041 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p2_29@1344@01 (<= _residue_158_1@1350@01 _current_wait_level_158_1@1354@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1358@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1358@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1358@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1358@01))) $Snap.unit))
; [eval] p1_29 ==> issubtype(typeof(_res), int())
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2044 | p1_29@1343@01 | live]
; [else-branch: 2044 | !(p1_29@1343@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2044 | p1_29@1343@01]
(assert p1_29@1343@01)
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 4
(push) ; 4
; [else-branch: 2044 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_29@1343@01
  (issubtype<Bool> (typeof<PyType> _res@1355@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1358@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1358@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1358@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1358@01))))
  $Snap.unit))
; [eval] p2_29 ==> issubtype(typeof(_res_2), int())
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2045 | p2_29@1344@01 | live]
; [else-branch: 2045 | !(p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2045 | p2_29@1344@01]
(assert p2_29@1344@01)
; [eval] issubtype(typeof(_res_2), int())
; [eval] typeof(_res_2)
; [eval] int()
(pop) ; 4
(push) ; 4
; [else-branch: 2045 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_29@1344@01
  (issubtype<Bool> (typeof<PyType> _res_2@1356@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1358@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1358@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1358@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1358@01)))))
  $Snap.unit))
; [eval] p1_29 && p2_29 ==> typeof(self_1) == typeof(self_1_1) ==> _res == _res_2
; [eval] p1_29 && p2_29
(push) ; 3
; [then-branch: 2046 | !(p1_29@1343@01) | live]
; [else-branch: 2046 | p1_29@1343@01 | live]
(push) ; 4
; [then-branch: 2046 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 4
(push) ; 4
; [else-branch: 2046 | p1_29@1343@01]
(assert p1_29@1343@01)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or p1_29@1343@01 (not p1_29@1343@01)))
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not (and p1_29@1343@01 p2_29@1344@01))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (and p1_29@1343@01 p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2047 | p1_29@1343@01 && p2_29@1344@01 | live]
; [else-branch: 2047 | !(p1_29@1343@01 && p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2047 | p1_29@1343@01 && p2_29@1344@01]
(assert (and p1_29@1343@01 p2_29@1344@01))
; [eval] typeof(self_1) == typeof(self_1_1) ==> _res == _res_2
; [eval] typeof(self_1) == typeof(self_1_1)
; [eval] typeof(self_1)
; [eval] typeof(self_1_1)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2048 | typeof[PyType](self_1@1351@01) == typeof[PyType](self_1_1@1352@01) | live]
; [else-branch: 2048 | typeof[PyType](self_1@1351@01) != typeof[PyType](self_1_1@1352@01) | live]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2048 | typeof[PyType](self_1@1351@01) == typeof[PyType](self_1_1@1352@01)]
(assert (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))
; [eval] _res == _res_2
(pop) ; 6
(push) ; 6
; [else-branch: 2048 | typeof[PyType](self_1@1351@01) != typeof[PyType](self_1_1@1352@01)]
(assert (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))
  (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))
(pop) ; 4
(push) ; 4
; [else-branch: 2047 | !(p1_29@1343@01 && p2_29@1344@01)]
(assert (not (and p1_29@1343@01 p2_29@1344@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=>
  (and p1_29@1343@01 p2_29@1344@01)
  (and
    p1_29@1343@01
    p2_29@1344@01
    (or
      (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))
      (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))))
; Joined path conditions
(assert (or (not (and p1_29@1343@01 p2_29@1344@01)) (and p1_29@1343@01 p2_29@1344@01)))
(assert (=>
  (and
    (and p1_29@1343@01 p2_29@1344@01)
    (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))
  (= _res@1355@01 _res_2@1356@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1358@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1358@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1358@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1358@01))))))
  $Snap.unit))
; [eval] p1_29 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2049 | p1_29@1343@01 | live]
; [else-branch: 2049 | !(p1_29@1343@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2049 | p1_29@1343@01]
(assert p1_29@1343@01)
(pop) ; 4
(push) ; 4
; [else-branch: 2049 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1358@01))))))
  $Snap.unit))
; [eval] p2_29 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2050 | p2_29@1344@01 | live]
; [else-branch: 2050 | !(p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2050 | p2_29@1344@01]
(assert p2_29@1344@01)
(pop) ; 4
(push) ; 4
; [else-branch: 2050 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
(push) ; 2
; [exec]
; var _cwl_158: Perm
(declare-const _cwl_158@1359@01 $Perm)
; [exec]
; var _cwl_158_1: Perm
(declare-const _cwl_158_1@1360@01 $Perm)
; [exec]
; var _method_measures_158: Seq[Measure$]
(declare-const _method_measures_158@1361@01 Seq<Measure$>)
; [exec]
; var _method_measures_158_1: Seq[Measure$]
(declare-const _method_measures_158_1@1362@01 Seq<Measure$>)
; [exec]
; inhale p1_29
(declare-const $t@1363@01 $Snap)
(assert (= $t@1363@01 $Snap.unit))
(assert p1_29@1343@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2051 | p1_29@1343@01 | live]
; [else-branch: 2051 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2051 | p1_29@1343@01]
; [exec]
; _method_measures_158 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; inhale issubtype(typeof(self_1), B())
(declare-const $t@1364@01 $Snap)
(assert (= $t@1364@01 $Snap.unit))
; [eval] issubtype(typeof(self_1), B())
; [eval] typeof(self_1)
; [eval] B()
(assert (issubtype<Bool> (typeof<PyType> self_1@1351@01) (as B<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2052 | p2_29@1344@01 | live]
; [else-branch: 2052 | !(p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2052 | p2_29@1344@01]
(assert p2_29@1344@01)
; [exec]
; _method_measures_158_1 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; inhale issubtype(typeof(self_1_1), B())
(declare-const $t@1365@01 $Snap)
(assert (= $t@1365@01 $Snap.unit))
; [eval] issubtype(typeof(self_1_1), B())
; [eval] typeof(self_1_1)
; [eval] B()
(assert (issubtype<Bool> (typeof<PyType> self_1_1@1352@01) (as B<PyType>  PyType)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [eval] p1_29 || p2_29
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2053 | p1_29@1343@01 | live]
; [else-branch: 2053 | !(p1_29@1343@01) | live]
(push) ; 6
; [then-branch: 2053 | p1_29@1343@01]
(pop) ; 6
(push) ; 6
; [else-branch: 2053 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (not (or p1_29@1343@01 p2_29@1344@01))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (or p1_29@1343@01 p2_29@1344@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2054 | p1_29@1343@01 || p2_29@1344@01 | live]
; [else-branch: 2054 | !(p1_29@1343@01 || p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2054 | p1_29@1343@01 || p2_29@1344@01]
(assert (or p1_29@1343@01 p2_29@1344@01))
; [exec]
; var tmp1_60: Ref
(declare-const tmp1_60@1366@01 $Ref)
; [exec]
; var tmp2_60: Ref
(declare-const tmp2_60@1367@01 $Ref)
; [exec]
; var tmp1_61: Seq[Measure$]
(declare-const tmp1_61@1368@01 Seq<Measure$>)
; [exec]
; var tmp2_61: Seq[Measure$]
(declare-const tmp2_61@1369@01 Seq<Measure$>)
; [exec]
; var tmp1_62: Perm
(declare-const tmp1_62@1370@01 $Perm)
; [exec]
; var tmp2_62: Perm
(declare-const tmp2_62@1371@01 $Perm)
; [exec]
; var tmp1_63: Ref
(declare-const tmp1_63@1372@01 $Ref)
; [exec]
; var tmp2_63: Ref
(declare-const tmp2_63@1373@01 $Ref)
; [exec]
; var tmp1_64: Perm
(declare-const tmp1_64@1374@01 $Perm)
; [exec]
; var tmp2_64: Perm
(declare-const tmp2_64@1375@01 $Perm)
; [exec]
; var tmp1_65: Ref
(declare-const tmp1_65@1376@01 $Ref)
; [exec]
; var tmp2_65: Ref
(declare-const tmp2_65@1377@01 $Ref)
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2055 | p1_29@1343@01 | live]
; [else-branch: 2055 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2055 | p1_29@1343@01]
; [exec]
; tmp1_60 := _cthread_158
; [exec]
; tmp1_61 := _method_measures_158
; [exec]
; tmp1_62 := _residue_158
; [exec]
; tmp1_63 := self_1
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2056 | p2_29@1344@01 | live]
; [else-branch: 2056 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2056 | p2_29@1344@01]
; [exec]
; tmp2_60 := _cthread_158_1
; [exec]
; tmp2_61 := _method_measures_158_1
; [exec]
; tmp2_62 := _residue_158_1
; [exec]
; tmp2_63 := self_1_1
; [exec]
; tmp1_64, tmp2_64, tmp1_65, tmp2_65 := B_foo(p1_29, p2_29, tmp1_60, tmp2_60,
;   tmp1_61, tmp2_61, tmp1_62, tmp2_62, tmp1_63, tmp2_63)
; [eval] p1_28 ==> _cthread_159 != null
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2057 | p1_29@1343@01 | live]
; [else-branch: 2057 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2057 | p1_29@1343@01]
; [eval] _cthread_159 != null
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2_28 ==> _cthread_159_0 != null
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2058 | p2_29@1344@01 | live]
; [else-branch: 2058 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2058 | p2_29@1344@01]
; [eval] _cthread_159_0 != null
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1_28 ==> issubtype(typeof(_cthread_159), Thread_0())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2059 | p1_29@1343@01 | live]
; [else-branch: 2059 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2059 | p1_29@1343@01]
; [eval] issubtype(typeof(_cthread_159), Thread_0())
; [eval] typeof(_cthread_159)
; [eval] Thread_0()
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2_28 ==> issubtype(typeof(_cthread_159_0), Thread_0())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2060 | p2_29@1344@01 | live]
; [else-branch: 2060 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2060 | p2_29@1344@01]
; [eval] issubtype(typeof(_cthread_159_0), Thread_0())
; [eval] typeof(_cthread_159_0)
; [eval] Thread_0()
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1_28 ==> issubtype(typeof(self_2), B())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2061 | p1_29@1343@01 | live]
; [else-branch: 2061 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2061 | p1_29@1343@01]
; [eval] issubtype(typeof(self_2), B())
; [eval] typeof(self_2)
; [eval] B()
(pop) ; 9
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (=>
  p1_29@1343@01
  (issubtype<Bool> (typeof<PyType> self_1@1351@01) (as B<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_29@1343@01
  (issubtype<Bool> (typeof<PyType> self_1@1351@01) (as B<PyType>  PyType))))
; [eval] p2_28 ==> issubtype(typeof(self_2_0), B())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2062 | p2_29@1344@01 | live]
; [else-branch: 2062 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2062 | p2_29@1344@01]
; [eval] issubtype(typeof(self_2_0), B())
; [eval] typeof(self_2_0)
; [eval] B()
(pop) ; 9
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (=>
  p2_29@1344@01
  (issubtype<Bool> (typeof<PyType> self_1_1@1352@01) (as B<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_29@1344@01
  (issubtype<Bool> (typeof<PyType> self_1_1@1352@01) (as B<PyType>  PyType))))
; [eval] p1_28 ==> self_2 != null
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2063 | p1_29@1343@01 | live]
; [else-branch: 2063 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2063 | p1_29@1343@01]
; [eval] self_2 != null
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2_28 ==> self_2_0 != null
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2064 | p2_29@1344@01 | live]
; [else-branch: 2064 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2064 | p2_29@1344@01]
; [eval] self_2_0 != null
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1_28 ==> perm(MustTerminate(_cthread_159)) == none && ((forperm _r_47: Ref [MustInvokeBounded(_r_47)] :: false) && ((forperm _r_47: Ref [MustInvokeUnbounded(_r_47)] :: false) && ((forperm _r_47: Ref [_r_47.MustReleaseBounded] :: false) && (forperm _r_47: Ref [_r_47.MustReleaseUnbounded] :: false))))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2065 | p1_29@1343@01 | live]
; [else-branch: 2065 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2065 | p1_29@1343@01]
; [eval] perm(MustTerminate(_cthread_159)) == none && ((forperm _r_47: Ref [MustInvokeBounded(_r_47)] :: false) && ((forperm _r_47: Ref [MustInvokeUnbounded(_r_47)] :: false) && ((forperm _r_47: Ref [_r_47.MustReleaseBounded] :: false) && (forperm _r_47: Ref [_r_47.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_159)) == none
; [eval] perm(MustTerminate(_cthread_159))
(push) ; 10
; [then-branch: 2066 | False | live]
; [else-branch: 2066 | True | live]
(push) ; 11
; [then-branch: 2066 | False]
(assert false)
(pop) ; 11
(push) ; 11
; [else-branch: 2066 | True]
; [eval] (forperm _r_47: Ref [MustInvokeBounded(_r_47)] :: false)
(push) ; 12
; [then-branch: 2067 | False | live]
; [else-branch: 2067 | True | live]
(push) ; 13
; [then-branch: 2067 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 2067 | True]
; [eval] (forperm _r_47: Ref [MustInvokeUnbounded(_r_47)] :: false)
(push) ; 14
; [then-branch: 2068 | False | live]
; [else-branch: 2068 | True | live]
(push) ; 15
; [then-branch: 2068 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 2068 | True]
; [eval] (forperm _r_47: Ref [_r_47.MustReleaseBounded] :: false)
(push) ; 16
; [then-branch: 2069 | False | live]
; [else-branch: 2069 | True | live]
(push) ; 17
; [then-branch: 2069 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 2069 | True]
; [eval] (forperm _r_47: Ref [_r_47.MustReleaseUnbounded] :: false)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2_28 ==> perm(MustTerminate_0(_cthread_159_0)) == none && ((forperm _r_47: Ref [MustInvokeBounded_0(_r_47)] :: false) && ((forperm _r_47: Ref [MustInvokeUnbounded_0(_r_47)] :: false) && ((forperm _r_47: Ref [_r_47.MustReleaseBoundedp] :: false) && (forperm _r_47: Ref [_r_47.MustReleaseUnboundedp] :: false))))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2070 | p2_29@1344@01 | live]
; [else-branch: 2070 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2070 | p2_29@1344@01]
; [eval] perm(MustTerminate_0(_cthread_159_0)) == none && ((forperm _r_47: Ref [MustInvokeBounded_0(_r_47)] :: false) && ((forperm _r_47: Ref [MustInvokeUnbounded_0(_r_47)] :: false) && ((forperm _r_47: Ref [_r_47.MustReleaseBoundedp] :: false) && (forperm _r_47: Ref [_r_47.MustReleaseUnboundedp] :: false))))
; [eval] perm(MustTerminate_0(_cthread_159_0)) == none
; [eval] perm(MustTerminate_0(_cthread_159_0))
(push) ; 10
; [then-branch: 2071 | False | live]
; [else-branch: 2071 | True | live]
(push) ; 11
; [then-branch: 2071 | False]
(assert false)
(pop) ; 11
(push) ; 11
; [else-branch: 2071 | True]
; [eval] (forperm _r_47: Ref [MustInvokeBounded_0(_r_47)] :: false)
(push) ; 12
; [then-branch: 2072 | False | live]
; [else-branch: 2072 | True | live]
(push) ; 13
; [then-branch: 2072 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 2072 | True]
; [eval] (forperm _r_47: Ref [MustInvokeUnbounded_0(_r_47)] :: false)
(push) ; 14
; [then-branch: 2073 | False | live]
; [else-branch: 2073 | True | live]
(push) ; 15
; [then-branch: 2073 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 2073 | True]
; [eval] (forperm _r_47: Ref [_r_47.MustReleaseBoundedp] :: false)
(push) ; 16
; [then-branch: 2074 | False | live]
; [else-branch: 2074 | True | live]
(push) ; 17
; [then-branch: 2074 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 2074 | True]
; [eval] (forperm _r_47: Ref [_r_47.MustReleaseUnboundedp] :: false)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
(declare-const _current_wait_level_159@1378@01 $Perm)
(declare-const _current_wait_level_159_0@1379@01 $Perm)
(declare-const _res@1380@01 $Ref)
(declare-const _res_1@1381@01 $Ref)
(declare-const $t@1382@01 $Snap)
(assert (= $t@1382@01 ($Snap.combine ($Snap.first $t@1382@01) ($Snap.second $t@1382@01))))
(assert (= ($Snap.first $t@1382@01) $Snap.unit))
; [eval] p1_28 ==> (forperm _r_45: Ref [_r_45.MustReleaseBounded] :: Level(_r_45) <= _current_wait_level_159) && ((forperm _r_45: Ref [_r_45.MustReleaseUnbounded] :: Level(_r_45) <= _current_wait_level_159) && _residue_159 <= _current_wait_level_159)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2075 | p1_29@1343@01 | live]
; [else-branch: 2075 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2075 | p1_29@1343@01]
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseBounded] :: Level(_r_45) <= _current_wait_level_159) && ((forperm _r_45: Ref [_r_45.MustReleaseUnbounded] :: Level(_r_45) <= _current_wait_level_159) && _residue_159 <= _current_wait_level_159)
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseBounded] :: Level(_r_45) <= _current_wait_level_159)
(push) ; 10
; [then-branch: 2076 | False | live]
; [else-branch: 2076 | True | live]
(push) ; 11
; [then-branch: 2076 | False]
(assert false)
(pop) ; 11
(push) ; 11
; [else-branch: 2076 | True]
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseUnbounded] :: Level(_r_45) <= _current_wait_level_159)
(push) ; 12
; [then-branch: 2077 | False | live]
; [else-branch: 2077 | True | live]
(push) ; 13
; [then-branch: 2077 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 2077 | True]
; [eval] _residue_159 <= _current_wait_level_159
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=> p1_29@1343@01 (<= _residue_158@1349@01 _current_wait_level_159@1378@01)))
(assert (=
  ($Snap.second $t@1382@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1382@01))
    ($Snap.second ($Snap.second $t@1382@01)))))
(assert (= ($Snap.first ($Snap.second $t@1382@01)) $Snap.unit))
; [eval] p2_28 ==> (forperm _r_45: Ref [_r_45.MustReleaseBoundedp] :: Level(_r_45) <= _current_wait_level_159_0) && ((forperm _r_45: Ref [_r_45.MustReleaseUnboundedp] :: Level(_r_45) <= _current_wait_level_159_0) && _residue_159_0 <= _current_wait_level_159_0)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2078 | p2_29@1344@01 | live]
; [else-branch: 2078 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2078 | p2_29@1344@01]
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseBoundedp] :: Level(_r_45) <= _current_wait_level_159_0) && ((forperm _r_45: Ref [_r_45.MustReleaseUnboundedp] :: Level(_r_45) <= _current_wait_level_159_0) && _residue_159_0 <= _current_wait_level_159_0)
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseBoundedp] :: Level(_r_45) <= _current_wait_level_159_0)
(push) ; 10
; [then-branch: 2079 | False | live]
; [else-branch: 2079 | True | live]
(push) ; 11
; [then-branch: 2079 | False]
(assert false)
(pop) ; 11
(push) ; 11
; [else-branch: 2079 | True]
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseUnboundedp] :: Level(_r_45) <= _current_wait_level_159_0)
(push) ; 12
; [then-branch: 2080 | False | live]
; [else-branch: 2080 | True | live]
(push) ; 13
; [then-branch: 2080 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 2080 | True]
; [eval] _residue_159_0 <= _current_wait_level_159_0
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=> p2_29@1344@01 (<= _residue_158_1@1350@01 _current_wait_level_159_0@1379@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1382@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1382@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1382@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1382@01))) $Snap.unit))
; [eval] p1_28 ==> issubtype(typeof(_res), int())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2081 | p1_29@1343@01 | live]
; [else-branch: 2081 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2081 | p1_29@1343@01]
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  p1_29@1343@01
  (issubtype<Bool> (typeof<PyType> _res@1380@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1382@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1382@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1382@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1382@01))))
  $Snap.unit))
; [eval] p2_28 ==> issubtype(typeof(_res_1), int())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2082 | p2_29@1344@01 | live]
; [else-branch: 2082 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2082 | p2_29@1344@01]
; [eval] issubtype(typeof(_res_1), int())
; [eval] typeof(_res_1)
; [eval] int()
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  p2_29@1344@01
  (issubtype<Bool> (typeof<PyType> _res_1@1381@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1382@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1382@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1382@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1382@01)))))
  $Snap.unit))
; [eval] p1_28 && p2_28 ==> typeof(self_2) == typeof(self_2_0) ==> _res == _res_1
; [eval] p1_28 && p2_28
(push) ; 8
; [then-branch: 2083 | !(p1_29@1343@01) | live]
; [else-branch: 2083 | p1_29@1343@01 | live]
(push) ; 9
; [then-branch: 2083 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 9
(push) ; 9
; [else-branch: 2083 | p1_29@1343@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or p1_29@1343@01 (not p1_29@1343@01)))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not (and p1_29@1343@01 p2_29@1344@01))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and p1_29@1343@01 p2_29@1344@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2084 | p1_29@1343@01 && p2_29@1344@01 | live]
; [else-branch: 2084 | !(p1_29@1343@01 && p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2084 | p1_29@1343@01 && p2_29@1344@01]
(assert (and p1_29@1343@01 p2_29@1344@01))
; [eval] typeof(self_2) == typeof(self_2_0) ==> _res == _res_1
; [eval] typeof(self_2) == typeof(self_2_0)
; [eval] typeof(self_2)
; [eval] typeof(self_2_0)
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2085 | typeof[PyType](self_1@1351@01) == typeof[PyType](self_1_1@1352@01) | live]
; [else-branch: 2085 | typeof[PyType](self_1@1351@01) != typeof[PyType](self_1_1@1352@01) | live]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2085 | typeof[PyType](self_1@1351@01) == typeof[PyType](self_1_1@1352@01)]
(assert (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))
; [eval] _res == _res_1
(pop) ; 11
(push) ; 11
; [else-branch: 2085 | typeof[PyType](self_1@1351@01) != typeof[PyType](self_1_1@1352@01)]
(assert (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (or
  (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))
  (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  (and p1_29@1343@01 p2_29@1344@01)
  (and
    p1_29@1343@01
    p2_29@1344@01
    (or
      (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))
      (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))))
(assert (and p1_29@1343@01 p2_29@1344@01))
(assert (=>
  (and
    (and p1_29@1343@01 p2_29@1344@01)
    (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))
  (= _res@1380@01 _res_1@1381@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1382@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1382@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1382@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1382@01))))))
  $Snap.unit))
; [eval] p1_28 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2086 | p1_29@1343@01 | live]
; [else-branch: 2086 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2086 | p1_29@1343@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1382@01))))))
  $Snap.unit))
; [eval] p2_28 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2087 | p2_29@1344@01 | live]
; [else-branch: 2087 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2087 | p2_29@1344@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2088 | p1_29@1343@01 | live]
; [else-branch: 2088 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2088 | p1_29@1343@01]
; [exec]
; _cwl_158 := tmp1_64
; [exec]
; _res := tmp1_65
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2089 | p2_29@1344@01 | live]
; [else-branch: 2089 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2089 | p2_29@1344@01]
; [exec]
; _cwl_158_1 := tmp2_64
; [exec]
; _res_2 := tmp2_65
; [eval] p1_29 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2090 | p1_29@1343@01 | live]
; [else-branch: 2090 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2090 | p1_29@1343@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_29 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2091 | p2_29@1344@01 | live]
; [else-branch: 2091 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2091 | p2_29@1344@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_29 ==> issubtype(typeof(_res), int())
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2092 | p1_29@1343@01 | live]
; [else-branch: 2092 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2092 | p1_29@1343@01]
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_29 ==> issubtype(typeof(_res_2), int())
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2093 | p2_29@1344@01 | live]
; [else-branch: 2093 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2093 | p2_29@1344@01]
; [eval] issubtype(typeof(_res_2), int())
; [eval] typeof(_res_2)
; [eval] int()
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_29 && p2_29 ==> typeof(self_1) == typeof(self_1_1) ==> _res == _res_2
; [eval] p1_29 && p2_29
(push) ; 10
; [then-branch: 2094 | !(p1_29@1343@01) | live]
; [else-branch: 2094 | p1_29@1343@01 | live]
(push) ; 11
; [then-branch: 2094 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 11
(push) ; 11
; [else-branch: 2094 | p1_29@1343@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not (and p1_29@1343@01 p2_29@1344@01))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (and p1_29@1343@01 p2_29@1344@01)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2095 | p1_29@1343@01 && p2_29@1344@01 | live]
; [else-branch: 2095 | !(p1_29@1343@01 && p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2095 | p1_29@1343@01 && p2_29@1344@01]
(assert (and p1_29@1343@01 p2_29@1344@01))
; [eval] typeof(self_1) == typeof(self_1_1) ==> _res == _res_2
; [eval] typeof(self_1) == typeof(self_1_1)
; [eval] typeof(self_1)
; [eval] typeof(self_1_1)
(push) ; 12
(push) ; 13
(set-option :timeout 10)
(assert (not (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2096 | typeof[PyType](self_1@1351@01) == typeof[PyType](self_1_1@1352@01) | live]
; [else-branch: 2096 | typeof[PyType](self_1@1351@01) != typeof[PyType](self_1_1@1352@01) | live]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 2096 | typeof[PyType](self_1@1351@01) == typeof[PyType](self_1_1@1352@01)]
(assert (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))
; [eval] _res == _res_2
(pop) ; 13
(push) ; 13
; [else-branch: 2096 | typeof[PyType](self_1@1351@01) != typeof[PyType](self_1_1@1352@01)]
(assert (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (or
  (not (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01)))
  (= (typeof<PyType> self_1@1351@01) (typeof<PyType> self_1_1@1352@01))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (and p1_29@1343@01 p2_29@1344@01))
; [eval] p1_29 ==> (forperm _r_49: Ref [MustInvokeBounded(_r_49)] :: false) && ((forperm _r_49: Ref [MustInvokeUnbounded(_r_49)] :: false) && ((forperm _r_49: Ref [_r_49.MustReleaseBounded] :: false) && (forperm _r_49: Ref [_r_49.MustReleaseUnbounded] :: false)))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2097 | p1_29@1343@01 | live]
; [else-branch: 2097 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2097 | p1_29@1343@01]
; [eval] (forperm _r_49: Ref [MustInvokeBounded(_r_49)] :: false) && ((forperm _r_49: Ref [MustInvokeUnbounded(_r_49)] :: false) && ((forperm _r_49: Ref [_r_49.MustReleaseBounded] :: false) && (forperm _r_49: Ref [_r_49.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_49: Ref [MustInvokeBounded(_r_49)] :: false)
(push) ; 12
; [then-branch: 2098 | False | live]
; [else-branch: 2098 | True | live]
(push) ; 13
; [then-branch: 2098 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 2098 | True]
; [eval] (forperm _r_49: Ref [MustInvokeUnbounded(_r_49)] :: false)
(push) ; 14
; [then-branch: 2099 | False | live]
; [else-branch: 2099 | True | live]
(push) ; 15
; [then-branch: 2099 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 2099 | True]
; [eval] (forperm _r_49: Ref [_r_49.MustReleaseBounded] :: false)
(push) ; 16
; [then-branch: 2100 | False | live]
; [else-branch: 2100 | True | live]
(push) ; 17
; [then-branch: 2100 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 2100 | True]
; [eval] (forperm _r_49: Ref [_r_49.MustReleaseUnbounded] :: false)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_29 ==> (forperm _r_49: Ref [MustInvokeBounded_0(_r_49)] :: false) && ((forperm _r_49: Ref [MustInvokeUnbounded_0(_r_49)] :: false) && ((forperm _r_49: Ref [_r_49.MustReleaseBoundedp] :: false) && (forperm _r_49: Ref [_r_49.MustReleaseUnboundedp] :: false)))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2101 | p2_29@1344@01 | live]
; [else-branch: 2101 | !(p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2101 | p2_29@1344@01]
; [eval] (forperm _r_49: Ref [MustInvokeBounded_0(_r_49)] :: false) && ((forperm _r_49: Ref [MustInvokeUnbounded_0(_r_49)] :: false) && ((forperm _r_49: Ref [_r_49.MustReleaseBoundedp] :: false) && (forperm _r_49: Ref [_r_49.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_49: Ref [MustInvokeBounded_0(_r_49)] :: false)
(push) ; 12
; [then-branch: 2102 | False | live]
; [else-branch: 2102 | True | live]
(push) ; 13
; [then-branch: 2102 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 2102 | True]
; [eval] (forperm _r_49: Ref [MustInvokeUnbounded_0(_r_49)] :: false)
(push) ; 14
; [then-branch: 2103 | False | live]
; [else-branch: 2103 | True | live]
(push) ; 15
; [then-branch: 2103 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 2103 | True]
; [eval] (forperm _r_49: Ref [_r_49.MustReleaseBoundedp] :: false)
(push) ; 16
; [then-branch: 2104 | False | live]
; [else-branch: 2104 | True | live]
(push) ; 17
; [then-branch: 2104 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 2104 | True]
; [eval] (forperm _r_49: Ref [_r_49.MustReleaseUnboundedp] :: false)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(pop) ; 9
; [eval] !p2_29
(push) ; 9
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2105 | !(p2_29@1344@01) | dead]
; [else-branch: 2105 | p2_29@1344@01 | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2105 | p2_29@1344@01]
(assert p2_29@1344@01)
(pop) ; 9
(pop) ; 8
; [eval] !p1_29
(push) ; 8
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2106 | !(p1_29@1343@01) | dead]
; [else-branch: 2106 | p1_29@1343@01 | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 2106 | p1_29@1343@01]
(assert p1_29@1343@01)
(pop) ; 8
(pop) ; 7
; [eval] !p2_29
(push) ; 7
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2107 | !(p2_29@1344@01) | dead]
; [else-branch: 2107 | p2_29@1344@01 | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 2107 | p2_29@1344@01]
(assert p2_29@1344@01)
(pop) ; 7
(pop) ; 6
; [eval] !p1_29
(push) ; 6
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2108 | !(p1_29@1343@01) | dead]
; [else-branch: 2108 | p1_29@1343@01 | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 2108 | p1_29@1343@01]
(assert p1_29@1343@01)
(pop) ; 6
(pop) ; 5
; [eval] !(p1_29 || p2_29)
; [eval] p1_29 || p2_29
(push) ; 5
; [then-branch: 2109 | p1_29@1343@01 | live]
; [else-branch: 2109 | !(p1_29@1343@01) | live]
(push) ; 6
; [then-branch: 2109 | p1_29@1343@01]
(assert p1_29@1343@01)
(pop) ; 6
(push) ; 6
; [else-branch: 2109 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (or p1_29@1343@01 p2_29@1344@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2110 | !(p1_29@1343@01 || p2_29@1344@01) | dead]
; [else-branch: 2110 | p1_29@1343@01 || p2_29@1344@01 | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2110 | p1_29@1343@01 || p2_29@1344@01]
(assert (or p1_29@1343@01 p2_29@1344@01))
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 2052 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
(pop) ; 4
; [eval] !p2_29
(push) ; 4
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_29@1344@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2111 | !(p2_29@1344@01) | live]
; [else-branch: 2111 | p2_29@1344@01 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2111 | !(p2_29@1344@01)]
(assert (not p2_29@1344@01))
; [eval] p1_29 || p2_29
(push) ; 5
; [then-branch: 2112 | p1_29@1343@01 | live]
; [else-branch: 2112 | !(p1_29@1343@01) | live]
(push) ; 6
; [then-branch: 2112 | p1_29@1343@01]
(assert p1_29@1343@01)
(pop) ; 6
(push) ; 6
; [else-branch: 2112 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (not (or p1_29@1343@01 p2_29@1344@01))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (or p1_29@1343@01 p2_29@1344@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2113 | p1_29@1343@01 || p2_29@1344@01 | live]
; [else-branch: 2113 | !(p1_29@1343@01 || p2_29@1344@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2113 | p1_29@1343@01 || p2_29@1344@01]
(assert (or p1_29@1343@01 p2_29@1344@01))
; [exec]
; var tmp1_60: Ref
(declare-const tmp1_60@1383@01 $Ref)
; [exec]
; var tmp2_60: Ref
(declare-const tmp2_60@1384@01 $Ref)
; [exec]
; var tmp1_61: Seq[Measure$]
(declare-const tmp1_61@1385@01 Seq<Measure$>)
; [exec]
; var tmp2_61: Seq[Measure$]
(declare-const tmp2_61@1386@01 Seq<Measure$>)
; [exec]
; var tmp1_62: Perm
(declare-const tmp1_62@1387@01 $Perm)
; [exec]
; var tmp2_62: Perm
(declare-const tmp2_62@1388@01 $Perm)
; [exec]
; var tmp1_63: Ref
(declare-const tmp1_63@1389@01 $Ref)
; [exec]
; var tmp2_63: Ref
(declare-const tmp2_63@1390@01 $Ref)
; [exec]
; var tmp1_64: Perm
(declare-const tmp1_64@1391@01 $Perm)
; [exec]
; var tmp2_64: Perm
(declare-const tmp2_64@1392@01 $Perm)
; [exec]
; var tmp1_65: Ref
(declare-const tmp1_65@1393@01 $Ref)
; [exec]
; var tmp2_65: Ref
(declare-const tmp2_65@1394@01 $Ref)
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2114 | p1_29@1343@01 | live]
; [else-branch: 2114 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2114 | p1_29@1343@01]
(assert p1_29@1343@01)
; [exec]
; tmp1_60 := _cthread_158
; [exec]
; tmp1_61 := _method_measures_158
; [exec]
; tmp1_62 := _residue_158
; [exec]
; tmp1_63 := self_1
; [then-branch: 2115 | p2_29@1344@01 | dead]
; [else-branch: 2115 | !(p2_29@1344@01) | live]
(push) ; 7
; [else-branch: 2115 | !(p2_29@1344@01)]
(pop) ; 7
; [eval] !p2_29
(push) ; 7
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2116 | !(p2_29@1344@01) | live]
; [else-branch: 2116 | p2_29@1344@01 | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2116 | !(p2_29@1344@01)]
; [exec]
; tmp1_64, tmp2_64, tmp1_65, tmp2_65 := B_foo(p1_29, p2_29, tmp1_60, tmp2_60,
;   tmp1_61, tmp2_61, tmp1_62, tmp2_62, tmp1_63, tmp2_63)
; [eval] p1_28 ==> _cthread_159 != null
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2117 | p1_29@1343@01 | live]
; [else-branch: 2117 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2117 | p1_29@1343@01]
; [eval] _cthread_159 != null
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2_28 ==> _cthread_159_0 != null
(push) ; 8
; [then-branch: 2118 | p2_29@1344@01 | dead]
; [else-branch: 2118 | !(p2_29@1344@01) | live]
(push) ; 9
; [else-branch: 2118 | !(p2_29@1344@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1_28 ==> issubtype(typeof(_cthread_159), Thread_0())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2119 | p1_29@1343@01 | live]
; [else-branch: 2119 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2119 | p1_29@1343@01]
; [eval] issubtype(typeof(_cthread_159), Thread_0())
; [eval] typeof(_cthread_159)
; [eval] Thread_0()
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2_28 ==> issubtype(typeof(_cthread_159_0), Thread_0())
(push) ; 8
; [then-branch: 2120 | p2_29@1344@01 | dead]
; [else-branch: 2120 | !(p2_29@1344@01) | live]
(push) ; 9
; [else-branch: 2120 | !(p2_29@1344@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1_28 ==> issubtype(typeof(self_2), B())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2121 | p1_29@1343@01 | live]
; [else-branch: 2121 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2121 | p1_29@1343@01]
; [eval] issubtype(typeof(self_2), B())
; [eval] typeof(self_2)
; [eval] B()
(pop) ; 9
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (=>
  p1_29@1343@01
  (issubtype<Bool> (typeof<PyType> self_1@1351@01) (as B<PyType>  PyType)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_29@1343@01
  (issubtype<Bool> (typeof<PyType> self_1@1351@01) (as B<PyType>  PyType))))
; [eval] p2_28 ==> issubtype(typeof(self_2_0), B())
(push) ; 8
; [then-branch: 2122 | p2_29@1344@01 | dead]
; [else-branch: 2122 | !(p2_29@1344@01) | live]
(push) ; 9
; [else-branch: 2122 | !(p2_29@1344@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1_28 ==> self_2 != null
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2123 | p1_29@1343@01 | live]
; [else-branch: 2123 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2123 | p1_29@1343@01]
; [eval] self_2 != null
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2_28 ==> self_2_0 != null
(push) ; 8
; [then-branch: 2124 | p2_29@1344@01 | dead]
; [else-branch: 2124 | !(p2_29@1344@01) | live]
(push) ; 9
; [else-branch: 2124 | !(p2_29@1344@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p1_28 ==> perm(MustTerminate(_cthread_159)) == none && ((forperm _r_47: Ref [MustInvokeBounded(_r_47)] :: false) && ((forperm _r_47: Ref [MustInvokeUnbounded(_r_47)] :: false) && ((forperm _r_47: Ref [_r_47.MustReleaseBounded] :: false) && (forperm _r_47: Ref [_r_47.MustReleaseUnbounded] :: false))))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2125 | p1_29@1343@01 | live]
; [else-branch: 2125 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2125 | p1_29@1343@01]
; [eval] perm(MustTerminate(_cthread_159)) == none && ((forperm _r_47: Ref [MustInvokeBounded(_r_47)] :: false) && ((forperm _r_47: Ref [MustInvokeUnbounded(_r_47)] :: false) && ((forperm _r_47: Ref [_r_47.MustReleaseBounded] :: false) && (forperm _r_47: Ref [_r_47.MustReleaseUnbounded] :: false))))
; [eval] perm(MustTerminate(_cthread_159)) == none
; [eval] perm(MustTerminate(_cthread_159))
(push) ; 10
; [then-branch: 2126 | False | live]
; [else-branch: 2126 | True | live]
(push) ; 11
; [then-branch: 2126 | False]
(assert false)
(pop) ; 11
(push) ; 11
; [else-branch: 2126 | True]
; [eval] (forperm _r_47: Ref [MustInvokeBounded(_r_47)] :: false)
(push) ; 12
; [then-branch: 2127 | False | live]
; [else-branch: 2127 | True | live]
(push) ; 13
; [then-branch: 2127 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 2127 | True]
; [eval] (forperm _r_47: Ref [MustInvokeUnbounded(_r_47)] :: false)
(push) ; 14
; [then-branch: 2128 | False | live]
; [else-branch: 2128 | True | live]
(push) ; 15
; [then-branch: 2128 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 2128 | True]
; [eval] (forperm _r_47: Ref [_r_47.MustReleaseBounded] :: false)
(push) ; 16
; [then-branch: 2129 | False | live]
; [else-branch: 2129 | True | live]
(push) ; 17
; [then-branch: 2129 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 2129 | True]
; [eval] (forperm _r_47: Ref [_r_47.MustReleaseUnbounded] :: false)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] p2_28 ==> perm(MustTerminate_0(_cthread_159_0)) == none && ((forperm _r_47: Ref [MustInvokeBounded_0(_r_47)] :: false) && ((forperm _r_47: Ref [MustInvokeUnbounded_0(_r_47)] :: false) && ((forperm _r_47: Ref [_r_47.MustReleaseBoundedp] :: false) && (forperm _r_47: Ref [_r_47.MustReleaseUnboundedp] :: false))))
(push) ; 8
; [then-branch: 2130 | p2_29@1344@01 | dead]
; [else-branch: 2130 | !(p2_29@1344@01) | live]
(push) ; 9
; [else-branch: 2130 | !(p2_29@1344@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(declare-const _current_wait_level_159@1395@01 $Perm)
(declare-const _current_wait_level_159_0@1396@01 $Perm)
(declare-const _res@1397@01 $Ref)
(declare-const _res_1@1398@01 $Ref)
(declare-const $t@1399@01 $Snap)
(assert (= $t@1399@01 ($Snap.combine ($Snap.first $t@1399@01) ($Snap.second $t@1399@01))))
(assert (= ($Snap.first $t@1399@01) $Snap.unit))
; [eval] p1_28 ==> (forperm _r_45: Ref [_r_45.MustReleaseBounded] :: Level(_r_45) <= _current_wait_level_159) && ((forperm _r_45: Ref [_r_45.MustReleaseUnbounded] :: Level(_r_45) <= _current_wait_level_159) && _residue_159 <= _current_wait_level_159)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2131 | p1_29@1343@01 | live]
; [else-branch: 2131 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2131 | p1_29@1343@01]
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseBounded] :: Level(_r_45) <= _current_wait_level_159) && ((forperm _r_45: Ref [_r_45.MustReleaseUnbounded] :: Level(_r_45) <= _current_wait_level_159) && _residue_159 <= _current_wait_level_159)
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseBounded] :: Level(_r_45) <= _current_wait_level_159)
(push) ; 10
; [then-branch: 2132 | False | live]
; [else-branch: 2132 | True | live]
(push) ; 11
; [then-branch: 2132 | False]
(assert false)
(pop) ; 11
(push) ; 11
; [else-branch: 2132 | True]
; [eval] (forperm _r_45: Ref [_r_45.MustReleaseUnbounded] :: Level(_r_45) <= _current_wait_level_159)
(push) ; 12
; [then-branch: 2133 | False | live]
; [else-branch: 2133 | True | live]
(push) ; 13
; [then-branch: 2133 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 2133 | True]
; [eval] _residue_159 <= _current_wait_level_159
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=> p1_29@1343@01 (<= _residue_158@1349@01 _current_wait_level_159@1395@01)))
(assert (=
  ($Snap.second $t@1399@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1399@01))
    ($Snap.second ($Snap.second $t@1399@01)))))
(assert (= ($Snap.first ($Snap.second $t@1399@01)) $Snap.unit))
; [eval] p2_28 ==> (forperm _r_45: Ref [_r_45.MustReleaseBoundedp] :: Level(_r_45) <= _current_wait_level_159_0) && ((forperm _r_45: Ref [_r_45.MustReleaseUnboundedp] :: Level(_r_45) <= _current_wait_level_159_0) && _residue_159_0 <= _current_wait_level_159_0)
(push) ; 8
; [then-branch: 2134 | p2_29@1344@01 | dead]
; [else-branch: 2134 | !(p2_29@1344@01) | live]
(push) ; 9
; [else-branch: 2134 | !(p2_29@1344@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1399@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1399@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1399@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1399@01))) $Snap.unit))
; [eval] p1_28 ==> issubtype(typeof(_res), int())
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2135 | p1_29@1343@01 | live]
; [else-branch: 2135 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2135 | p1_29@1343@01]
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  p1_29@1343@01
  (issubtype<Bool> (typeof<PyType> _res@1397@01) (as int<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1399@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1399@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1399@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1399@01))))
  $Snap.unit))
; [eval] p2_28 ==> issubtype(typeof(_res_1), int())
(push) ; 8
; [then-branch: 2136 | p2_29@1344@01 | dead]
; [else-branch: 2136 | !(p2_29@1344@01) | live]
(push) ; 9
; [else-branch: 2136 | !(p2_29@1344@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1399@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1399@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1399@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1399@01)))))
  $Snap.unit))
; [eval] p1_28 && p2_28 ==> typeof(self_2) == typeof(self_2_0) ==> _res == _res_1
; [eval] p1_28 && p2_28
(push) ; 8
; [then-branch: 2137 | !(p1_29@1343@01) | live]
; [else-branch: 2137 | p1_29@1343@01 | live]
(push) ; 9
; [then-branch: 2137 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 9
(push) ; 9
; [else-branch: 2137 | p1_29@1343@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or p1_29@1343@01 (not p1_29@1343@01)))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not (and p1_29@1343@01 p2_29@1344@01))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2138 | p1_29@1343@01 && p2_29@1344@01 | dead]
; [else-branch: 2138 | !(p1_29@1343@01 && p2_29@1344@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2138 | !(p1_29@1343@01 && p2_29@1344@01)]
(assert (not (and p1_29@1343@01 p2_29@1344@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (not (and p1_29@1343@01 p2_29@1344@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1399@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1399@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1399@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1399@01))))))
  $Snap.unit))
; [eval] p1_28 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2139 | p1_29@1343@01 | live]
; [else-branch: 2139 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2139 | p1_29@1343@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1399@01))))))
  $Snap.unit))
; [eval] p2_28 ==> true
(push) ; 8
; [then-branch: 2140 | p2_29@1344@01 | dead]
; [else-branch: 2140 | !(p2_29@1344@01) | live]
(push) ; 9
; [else-branch: 2140 | !(p2_29@1344@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2141 | p1_29@1343@01 | live]
; [else-branch: 2141 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2141 | p1_29@1343@01]
; [exec]
; _cwl_158 := tmp1_64
; [exec]
; _res := tmp1_65
; [then-branch: 2142 | p2_29@1344@01 | dead]
; [else-branch: 2142 | !(p2_29@1344@01) | live]
(push) ; 9
; [else-branch: 2142 | !(p2_29@1344@01)]
(pop) ; 9
; [eval] !p2_29
(push) ; 9
(set-option :timeout 10)
(assert (not p2_29@1344@01))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2143 | !(p2_29@1344@01) | live]
; [else-branch: 2143 | p2_29@1344@01 | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2143 | !(p2_29@1344@01)]
; [eval] p1_29 ==> true
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2144 | p1_29@1343@01 | live]
; [else-branch: 2144 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2144 | p1_29@1343@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_29 ==> true
(push) ; 10
; [then-branch: 2145 | p2_29@1344@01 | dead]
; [else-branch: 2145 | !(p2_29@1344@01) | live]
(push) ; 11
; [else-branch: 2145 | !(p2_29@1344@01)]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_29 ==> issubtype(typeof(_res), int())
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2146 | p1_29@1343@01 | live]
; [else-branch: 2146 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2146 | p1_29@1343@01]
; [eval] issubtype(typeof(_res), int())
; [eval] typeof(_res)
; [eval] int()
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_29 ==> issubtype(typeof(_res_2), int())
(push) ; 10
; [then-branch: 2147 | p2_29@1344@01 | dead]
; [else-branch: 2147 | !(p2_29@1344@01) | live]
(push) ; 11
; [else-branch: 2147 | !(p2_29@1344@01)]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_29 && p2_29 ==> typeof(self_1) == typeof(self_1_1) ==> _res == _res_2
; [eval] p1_29 && p2_29
(push) ; 10
; [then-branch: 2148 | !(p1_29@1343@01) | live]
; [else-branch: 2148 | p1_29@1343@01 | live]
(push) ; 11
; [then-branch: 2148 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 11
(push) ; 11
; [else-branch: 2148 | p1_29@1343@01]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 2149 | p1_29@1343@01 && p2_29@1344@01 | dead]
; [else-branch: 2149 | !(p1_29@1343@01 && p2_29@1344@01) | live]
(push) ; 11
; [else-branch: 2149 | !(p1_29@1343@01 && p2_29@1344@01)]
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p1_29 ==> (forperm _r_49: Ref [MustInvokeBounded(_r_49)] :: false) && ((forperm _r_49: Ref [MustInvokeUnbounded(_r_49)] :: false) && ((forperm _r_49: Ref [_r_49.MustReleaseBounded] :: false) && (forperm _r_49: Ref [_r_49.MustReleaseUnbounded] :: false)))
(push) ; 10
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_29@1343@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2150 | p1_29@1343@01 | live]
; [else-branch: 2150 | !(p1_29@1343@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2150 | p1_29@1343@01]
; [eval] (forperm _r_49: Ref [MustInvokeBounded(_r_49)] :: false) && ((forperm _r_49: Ref [MustInvokeUnbounded(_r_49)] :: false) && ((forperm _r_49: Ref [_r_49.MustReleaseBounded] :: false) && (forperm _r_49: Ref [_r_49.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_49: Ref [MustInvokeBounded(_r_49)] :: false)
(push) ; 12
; [then-branch: 2151 | False | live]
; [else-branch: 2151 | True | live]
(push) ; 13
; [then-branch: 2151 | False]
(assert false)
(pop) ; 13
(push) ; 13
; [else-branch: 2151 | True]
; [eval] (forperm _r_49: Ref [MustInvokeUnbounded(_r_49)] :: false)
(push) ; 14
; [then-branch: 2152 | False | live]
; [else-branch: 2152 | True | live]
(push) ; 15
; [then-branch: 2152 | False]
(assert false)
(pop) ; 15
(push) ; 15
; [else-branch: 2152 | True]
; [eval] (forperm _r_49: Ref [_r_49.MustReleaseBounded] :: false)
(push) ; 16
; [then-branch: 2153 | False | live]
; [else-branch: 2153 | True | live]
(push) ; 17
; [then-branch: 2153 | False]
(assert false)
(pop) ; 17
(push) ; 17
; [else-branch: 2153 | True]
; [eval] (forperm _r_49: Ref [_r_49.MustReleaseUnbounded] :: false)
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
; [eval] p2_29 ==> (forperm _r_49: Ref [MustInvokeBounded_0(_r_49)] :: false) && ((forperm _r_49: Ref [MustInvokeUnbounded_0(_r_49)] :: false) && ((forperm _r_49: Ref [_r_49.MustReleaseBoundedp] :: false) && (forperm _r_49: Ref [_r_49.MustReleaseUnboundedp] :: false)))
(push) ; 10
; [then-branch: 2154 | p2_29@1344@01 | dead]
; [else-branch: 2154 | !(p2_29@1344@01) | live]
(push) ; 11
; [else-branch: 2154 | !(p2_29@1344@01)]
(pop) ; 11
(pop) ; 10
; Joined path conditions
(pop) ; 9
(pop) ; 8
; [eval] !p1_29
; [then-branch: 2155 | !(p1_29@1343@01) | dead]
; [else-branch: 2155 | p1_29@1343@01 | live]
(push) ; 8
; [else-branch: 2155 | p1_29@1343@01]
(pop) ; 8
(pop) ; 7
(pop) ; 6
; [eval] !p1_29
(push) ; 6
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2156 | !(p1_29@1343@01) | dead]
; [else-branch: 2156 | p1_29@1343@01 | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 2156 | p1_29@1343@01]
(assert p1_29@1343@01)
(pop) ; 6
(pop) ; 5
; [eval] !(p1_29 || p2_29)
; [eval] p1_29 || p2_29
(push) ; 5
; [then-branch: 2157 | p1_29@1343@01 | live]
; [else-branch: 2157 | !(p1_29@1343@01) | live]
(push) ; 6
; [then-branch: 2157 | p1_29@1343@01]
(assert p1_29@1343@01)
(pop) ; 6
(push) ; 6
; [else-branch: 2157 | !(p1_29@1343@01)]
(assert (not p1_29@1343@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (or p1_29@1343@01 p2_29@1344@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2158 | !(p1_29@1343@01 || p2_29@1344@01) | dead]
; [else-branch: 2158 | p1_29@1343@01 || p2_29@1344@01 | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2158 | p1_29@1343@01 || p2_29@1344@01]
(assert (or p1_29@1343@01 p2_29@1344@01))
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 2111 | p2_29@1344@01]
(assert p2_29@1344@01)
(pop) ; 4
(pop) ; 3
; [eval] !p1_29
(push) ; 3
(set-option :timeout 10)
(assert (not p1_29@1343@01))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2159 | !(p1_29@1343@01) | dead]
; [else-branch: 2159 | p1_29@1343@01 | live]
(set-option :timeout 0)
(push) ; 3
; [else-branch: 2159 | p1_29@1343@01]
(assert p1_29@1343@01)
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- Lock___init__ ----------
(declare-const p1_30@1400@01 Bool)
(declare-const p2_30@1401@01 Bool)
(declare-const _cthread_171@1402@01 $Ref)
(declare-const _cthread_171_0@1403@01 $Ref)
(declare-const _caller_measures_171@1404@01 Seq<Measure$>)
(declare-const _caller_measures_171_0@1405@01 Seq<Measure$>)
(declare-const _residue_171@1406@01 $Perm)
(declare-const _residue_171_0@1407@01 $Perm)
(declare-const self_4@1408@01 $Ref)
(declare-const self_4_0@1409@01 $Ref)
(declare-const locked_object@1410@01 $Ref)
(declare-const locked_object_0@1411@01 $Ref)
(declare-const above@1412@01 $Ref)
(declare-const above_0@1413@01 $Ref)
(declare-const below@1414@01 $Ref)
(declare-const below_0@1415@01 $Ref)
(declare-const _current_wait_level_171@1416@01 $Perm)
(declare-const _current_wait_level_171_0@1417@01 $Perm)
(declare-const p1_30@1418@01 Bool)
(declare-const p2_30@1419@01 Bool)
(declare-const _cthread_171@1420@01 $Ref)
(declare-const _cthread_171_0@1421@01 $Ref)
(declare-const _caller_measures_171@1422@01 Seq<Measure$>)
(declare-const _caller_measures_171_0@1423@01 Seq<Measure$>)
(declare-const _residue_171@1424@01 $Perm)
(declare-const _residue_171_0@1425@01 $Perm)
(declare-const self_4@1426@01 $Ref)
(declare-const self_4_0@1427@01 $Ref)
(declare-const locked_object@1428@01 $Ref)
(declare-const locked_object_0@1429@01 $Ref)
(declare-const above@1430@01 $Ref)
(declare-const above_0@1431@01 $Ref)
(declare-const below@1432@01 $Ref)
(declare-const below_0@1433@01 $Ref)
(declare-const _current_wait_level_171@1434@01 $Perm)
(declare-const _current_wait_level_171_0@1435@01 $Perm)
(push) ; 1
(declare-const $t@1436@01 $Snap)
(assert (= $t@1436@01 ($Snap.combine ($Snap.first $t@1436@01) ($Snap.second $t@1436@01))))
(assert (= ($Snap.first $t@1436@01) $Snap.unit))
; [eval] p1_30 ==> _cthread_171 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2160 | p1_30@1418@01 | live]
; [else-branch: 2160 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2160 | p1_30@1418@01]
(assert p1_30@1418@01)
; [eval] _cthread_171 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2160 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_30@1418@01) p1_30@1418@01))
(assert (=> p1_30@1418@01 (not (= _cthread_171@1420@01 $Ref.null))))
(assert (=
  ($Snap.second $t@1436@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1436@01))
    ($Snap.second ($Snap.second $t@1436@01)))))
(assert (= ($Snap.first ($Snap.second $t@1436@01)) $Snap.unit))
; [eval] p2_30 ==> _cthread_171_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2161 | p2_30@1419@01 | live]
; [else-branch: 2161 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2161 | p2_30@1419@01]
(assert p2_30@1419@01)
; [eval] _cthread_171_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2161 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_30@1419@01) p2_30@1419@01))
(assert (=> p2_30@1419@01 (not (= _cthread_171_0@1421@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@1436@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1436@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1436@01))) $Snap.unit))
; [eval] p1_30 ==> issubtype(typeof(_cthread_171), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2162 | p1_30@1418@01 | live]
; [else-branch: 2162 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2162 | p1_30@1418@01]
(assert p1_30@1418@01)
; [eval] issubtype(typeof(_cthread_171), Thread_0())
; [eval] typeof(_cthread_171)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2162 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (issubtype<Bool> (typeof<PyType> _cthread_171@1420@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))
  $Snap.unit))
; [eval] p2_30 ==> issubtype(typeof(_cthread_171_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2163 | p2_30@1419@01 | live]
; [else-branch: 2163 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2163 | p2_30@1419@01]
(assert p2_30@1419@01)
; [eval] issubtype(typeof(_cthread_171_0), Thread_0())
; [eval] typeof(_cthread_171_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2163 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (issubtype<Bool> (typeof<PyType> _cthread_171_0@1421@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))
  $Snap.unit))
; [eval] p1_30 ==> self_4 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2164 | p1_30@1418@01 | live]
; [else-branch: 2164 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2164 | p1_30@1418@01]
(assert p1_30@1418@01)
; [eval] self_4 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2164 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p1_30@1418@01 (not (= self_4@1426@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))
  $Snap.unit))
; [eval] p2_30 ==> self_4_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2165 | p2_30@1419@01 | live]
; [else-branch: 2165 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2165 | p2_30@1419@01]
(assert p2_30@1419@01)
; [eval] self_4_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2165 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p2_30@1419@01 (not (= self_4_0@1427@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))
  $Snap.unit))
; [eval] p1_30 ==> issubtype(typeof(self_4), Lock(Lock_arg(typeof(self_4), 0)))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2166 | p1_30@1418@01 | live]
; [else-branch: 2166 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2166 | p1_30@1418@01]
(assert p1_30@1418@01)
; [eval] issubtype(typeof(self_4), Lock(Lock_arg(typeof(self_4), 0)))
; [eval] typeof(self_4)
; [eval] Lock(Lock_arg(typeof(self_4), 0))
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
(pop) ; 3
(push) ; 3
; [else-branch: 2166 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (issubtype<Bool> (typeof<PyType> self_4@1426@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> self_4@1426@01) 0)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))
  $Snap.unit))
; [eval] p2_30 ==> issubtype(typeof(self_4_0), Lock(Lock_arg(typeof(self_4_0), 0)))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2167 | p2_30@1419@01 | live]
; [else-branch: 2167 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2167 | p2_30@1419@01]
(assert p2_30@1419@01)
; [eval] issubtype(typeof(self_4_0), Lock(Lock_arg(typeof(self_4_0), 0)))
; [eval] typeof(self_4_0)
; [eval] Lock(Lock_arg(typeof(self_4_0), 0))
; [eval] Lock_arg(typeof(self_4_0), 0)
; [eval] typeof(self_4_0)
(pop) ; 3
(push) ; 3
; [else-branch: 2167 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (issubtype<Bool> (typeof<PyType> self_4_0@1427@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> self_4_0@1427@01) 0)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))
  $Snap.unit))
; [eval] p1_30 ==> issubtype(typeof(locked_object), Lock_arg(typeof(self_4), 0))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2168 | p1_30@1418@01 | live]
; [else-branch: 2168 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2168 | p1_30@1418@01]
(assert p1_30@1418@01)
; [eval] issubtype(typeof(locked_object), Lock_arg(typeof(self_4), 0))
; [eval] typeof(locked_object)
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
(pop) ; 3
(push) ; 3
; [else-branch: 2168 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (issubtype<Bool> (typeof<PyType> locked_object@1428@01) (Lock_arg<PyType> (typeof<PyType> self_4@1426@01) 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))
  $Snap.unit))
; [eval] p2_30 ==> issubtype(typeof(locked_object_0), Lock_arg(typeof(self_4_0), 0))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2169 | p2_30@1419@01 | live]
; [else-branch: 2169 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2169 | p2_30@1419@01]
(assert p2_30@1419@01)
; [eval] issubtype(typeof(locked_object_0), Lock_arg(typeof(self_4_0), 0))
; [eval] typeof(locked_object_0)
; [eval] Lock_arg(typeof(self_4_0), 0)
; [eval] typeof(self_4_0)
(pop) ; 3
(push) ; 3
; [else-branch: 2169 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (issubtype<Bool> (typeof<PyType> locked_object_0@1429@01) (Lock_arg<PyType> (typeof<PyType> self_4_0@1427@01) 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))
  $Snap.unit))
; [eval] p1_30 ==> above == null || issubtype(typeof(above), BaseLock())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2170 | p1_30@1418@01 | live]
; [else-branch: 2170 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2170 | p1_30@1418@01]
(assert p1_30@1418@01)
; [eval] above == null || issubtype(typeof(above), BaseLock())
; [eval] above == null
(push) ; 4
; [then-branch: 2171 | above@1430@01 == Null | live]
; [else-branch: 2171 | above@1430@01 != Null | live]
(push) ; 5
; [then-branch: 2171 | above@1430@01 == Null]
(assert (= above@1430@01 $Ref.null))
(pop) ; 5
(push) ; 5
; [else-branch: 2171 | above@1430@01 != Null]
(assert (not (= above@1430@01 $Ref.null)))
; [eval] issubtype(typeof(above), BaseLock())
; [eval] typeof(above)
; [eval] BaseLock()
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (not (= above@1430@01 $Ref.null)) (= above@1430@01 $Ref.null)))
(pop) ; 3
(push) ; 3
; [else-branch: 2170 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    p1_30@1418@01
    (or (not (= above@1430@01 $Ref.null)) (= above@1430@01 $Ref.null)))))
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (or
    (= above@1430@01 $Ref.null)
    (issubtype<Bool> (typeof<PyType> above@1430@01) (as BaseLock<PyType>  PyType)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null || issubtype(typeof(above_0), BaseLock())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2172 | p2_30@1419@01 | live]
; [else-branch: 2172 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2172 | p2_30@1419@01]
(assert p2_30@1419@01)
; [eval] above_0 == null || issubtype(typeof(above_0), BaseLock())
; [eval] above_0 == null
(push) ; 4
; [then-branch: 2173 | above_0@1431@01 == Null | live]
; [else-branch: 2173 | above_0@1431@01 != Null | live]
(push) ; 5
; [then-branch: 2173 | above_0@1431@01 == Null]
(assert (= above_0@1431@01 $Ref.null))
(pop) ; 5
(push) ; 5
; [else-branch: 2173 | above_0@1431@01 != Null]
(assert (not (= above_0@1431@01 $Ref.null)))
; [eval] issubtype(typeof(above_0), BaseLock())
; [eval] typeof(above_0)
; [eval] BaseLock()
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (not (= above_0@1431@01 $Ref.null)) (= above_0@1431@01 $Ref.null)))
(pop) ; 3
(push) ; 3
; [else-branch: 2172 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    p2_30@1419@01
    (or (not (= above_0@1431@01 $Ref.null)) (= above_0@1431@01 $Ref.null)))))
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (or
    (= above_0@1431@01 $Ref.null)
    (issubtype<Bool> (typeof<PyType> above_0@1431@01) (as BaseLock<PyType>  PyType)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> below == null || issubtype(typeof(below), BaseLock())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2174 | p1_30@1418@01 | live]
; [else-branch: 2174 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2174 | p1_30@1418@01]
(assert p1_30@1418@01)
; [eval] below == null || issubtype(typeof(below), BaseLock())
; [eval] below == null
(push) ; 4
; [then-branch: 2175 | below@1432@01 == Null | live]
; [else-branch: 2175 | below@1432@01 != Null | live]
(push) ; 5
; [then-branch: 2175 | below@1432@01 == Null]
(assert (= below@1432@01 $Ref.null))
(pop) ; 5
(push) ; 5
; [else-branch: 2175 | below@1432@01 != Null]
(assert (not (= below@1432@01 $Ref.null)))
; [eval] issubtype(typeof(below), BaseLock())
; [eval] typeof(below)
; [eval] BaseLock()
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (not (= below@1432@01 $Ref.null)) (= below@1432@01 $Ref.null)))
(pop) ; 3
(push) ; 3
; [else-branch: 2174 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    p1_30@1418@01
    (or (not (= below@1432@01 $Ref.null)) (= below@1432@01 $Ref.null)))))
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (or
    (= below@1432@01 $Ref.null)
    (issubtype<Bool> (typeof<PyType> below@1432@01) (as BaseLock<PyType>  PyType)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> below_0 == null || issubtype(typeof(below_0), BaseLock())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2176 | p2_30@1419@01 | live]
; [else-branch: 2176 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2176 | p2_30@1419@01]
(assert p2_30@1419@01)
; [eval] below_0 == null || issubtype(typeof(below_0), BaseLock())
; [eval] below_0 == null
(push) ; 4
; [then-branch: 2177 | below_0@1433@01 == Null | live]
; [else-branch: 2177 | below_0@1433@01 != Null | live]
(push) ; 5
; [then-branch: 2177 | below_0@1433@01 == Null]
(assert (= below_0@1433@01 $Ref.null))
(pop) ; 5
(push) ; 5
; [else-branch: 2177 | below_0@1433@01 != Null]
(assert (not (= below_0@1433@01 $Ref.null)))
; [eval] issubtype(typeof(below_0), BaseLock())
; [eval] typeof(below_0)
; [eval] BaseLock()
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (not (= below_0@1433@01 $Ref.null)) (= below_0@1433@01 $Ref.null)))
(pop) ; 3
(push) ; 3
; [else-branch: 2176 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    p2_30@1419@01
    (or (not (= below_0@1433@01 $Ref.null)) (= below_0@1433@01 $Ref.null)))))
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (or
    (= below_0@1433@01 $Ref.null)
    (issubtype<Bool> (typeof<PyType> below_0@1433@01) (as BaseLock<PyType>  PyType)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> issubtype(Lock_arg(typeof(self_4), 0), object())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2178 | p1_30@1418@01 | live]
; [else-branch: 2178 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2178 | p1_30@1418@01]
(assert p1_30@1418@01)
; [eval] issubtype(Lock_arg(typeof(self_4), 0), object())
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
; [eval] object()
(pop) ; 3
(push) ; 3
; [else-branch: 2178 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> self_4@1426@01) 0) (as object<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> issubtype(Lock_arg(typeof(self_4_0), 0), object())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2179 | p2_30@1419@01 | live]
; [else-branch: 2179 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2179 | p2_30@1419@01]
(assert p2_30@1419@01)
; [eval] issubtype(Lock_arg(typeof(self_4_0), 0), object())
; [eval] Lock_arg(typeof(self_4_0), 0)
; [eval] typeof(self_4_0)
; [eval] object()
(pop) ; 3
(push) ; 3
; [else-branch: 2179 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> self_4_0@1427@01) 0) (as object<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> self_4 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2180 | p1_30@1418@01 | live]
; [else-branch: 2180 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2180 | p1_30@1418@01]
(assert p1_30@1418@01)
; [eval] self_4 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2180 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> self_4_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2181 | p2_30@1419@01 | live]
; [else-branch: 2181 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2181 | p2_30@1419@01]
(assert p2_30@1419@01)
; [eval] self_4_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2181 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
(push) ; 2
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 2
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2182 | p1_30@1418@01 | live]
; [else-branch: 2182 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 2
; [then-branch: 2182 | p1_30@1418@01]
(assert p1_30@1418@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2183 | p2_30@1419@01 | live]
; [else-branch: 2183 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2183 | p2_30@1419@01]
(assert p2_30@1419@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> above == null && below != null ==> _residue_171 < Level(below)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2184 | p1_30@1418@01 | live]
; [else-branch: 2184 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2184 | p1_30@1418@01]
; [eval] above == null && below != null ==> _residue_171 < Level(below)
; [eval] above == null && below != null
; [eval] above == null
(push) ; 6
; [then-branch: 2185 | above@1430@01 != Null | live]
; [else-branch: 2185 | above@1430@01 == Null | live]
(push) ; 7
; [then-branch: 2185 | above@1430@01 != Null]
(assert (not (= above@1430@01 $Ref.null)))
(pop) ; 7
(push) ; 7
; [else-branch: 2185 | above@1430@01 == Null]
(assert (= above@1430@01 $Ref.null))
; [eval] below != null
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (= above@1430@01 $Ref.null) (not (= above@1430@01 $Ref.null))))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2186 | above@1430@01 == Null && below@1432@01 != Null | live]
; [else-branch: 2186 | !(above@1430@01 == Null && below@1432@01 != Null) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2186 | above@1430@01 == Null && below@1432@01 != Null]
(assert (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null))))
; [eval] _residue_171 < Level(below)
; [eval] Level(below)
(push) ; 8
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 7
(push) ; 7
; [else-branch: 2186 | !(above@1430@01 == Null && below@1432@01 != Null)]
(assert (not (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))
  (and
    (= above@1430@01 $Ref.null)
    (not (= below@1432@01 $Ref.null))
    (Level%precondition $Snap.unit below@1432@01))))
; Joined path conditions
(assert (or
  (not (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null))))
  (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    (or (= above@1430@01 $Ref.null) (not (= above@1430@01 $Ref.null)))
    (=>
      (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))
      (and
        (= above@1430@01 $Ref.null)
        (not (= below@1432@01 $Ref.null))
        (Level%precondition $Snap.unit below@1432@01)))
    (or
      (not (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null))))
      (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))))))
(assert (=>
  (and
    p1_30@1418@01
    (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null))))
  (< _residue_171@1424@01 (Level $Snap.unit below@1432@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null && below_0 != null ==> _residue_171_0 < Level(below_0)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
; [then-branch: 2187 | p2_30@1419@01 | live]
; [else-branch: 2187 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2187 | p2_30@1419@01]
; [eval] above_0 == null && below_0 != null ==> _residue_171_0 < Level(below_0)
; [eval] above_0 == null && below_0 != null
; [eval] above_0 == null
(push) ; 6
; [then-branch: 2188 | above_0@1431@01 != Null | live]
; [else-branch: 2188 | above_0@1431@01 == Null | live]
(push) ; 7
; [then-branch: 2188 | above_0@1431@01 != Null]
(assert (not (= above_0@1431@01 $Ref.null)))
(pop) ; 7
(push) ; 7
; [else-branch: 2188 | above_0@1431@01 == Null]
(assert (= above_0@1431@01 $Ref.null))
; [eval] below_0 != null
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (= above_0@1431@01 $Ref.null) (not (= above_0@1431@01 $Ref.null))))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
; [then-branch: 2189 | above_0@1431@01 == Null && below_0@1433@01 != Null | live]
; [else-branch: 2189 | !(above_0@1431@01 == Null && below_0@1433@01 != Null) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2189 | above_0@1431@01 == Null && below_0@1433@01 != Null]
(assert (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))
; [eval] _residue_171_0 < Level(below_0)
; [eval] Level(below_0)
(push) ; 8
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 7
(push) ; 7
; [else-branch: 2189 | !(above_0@1431@01 == Null && below_0@1433@01 != Null)]
(assert (not (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))
  (and
    (= above_0@1431@01 $Ref.null)
    (not (= below_0@1433@01 $Ref.null))
    (Level%precondition $Snap.unit below_0@1433@01))))
; Joined path conditions
(assert (or
  (not (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))
  (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    (or (= above_0@1431@01 $Ref.null) (not (= above_0@1431@01 $Ref.null)))
    (=>
      (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))
      (and
        (= above_0@1431@01 $Ref.null)
        (not (= below_0@1433@01 $Ref.null))
        (Level%precondition $Snap.unit below_0@1433@01)))
    (or
      (not
        (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))
      (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))))))
(assert (=>
  (and
    p2_30@1419@01
    (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))
  (< _residue_171_0@1425@01 (Level $Snap.unit below_0@1433@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> above != null && below != null ==> Level(above) < Level(below)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2190 | p1_30@1418@01 | live]
; [else-branch: 2190 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2190 | p1_30@1418@01]
; [eval] above != null && below != null ==> Level(above) < Level(below)
; [eval] above != null && below != null
; [eval] above != null
(push) ; 6
; [then-branch: 2191 | above@1430@01 == Null | live]
; [else-branch: 2191 | above@1430@01 != Null | live]
(push) ; 7
; [then-branch: 2191 | above@1430@01 == Null]
(assert (= above@1430@01 $Ref.null))
(pop) ; 7
(push) ; 7
; [else-branch: 2191 | above@1430@01 != Null]
(assert (not (= above@1430@01 $Ref.null)))
; [eval] below != null
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (not (= above@1430@01 $Ref.null)) (= above@1430@01 $Ref.null)))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2192 | above@1430@01 != Null && below@1432@01 != Null | live]
; [else-branch: 2192 | !(above@1430@01 != Null && below@1432@01 != Null) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2192 | above@1430@01 != Null && below@1432@01 != Null]
(assert (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null))))
; [eval] Level(above) < Level(below)
; [eval] Level(above)
(push) ; 8
(assert (Level%precondition $Snap.unit above@1430@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit above@1430@01))
; [eval] Level(below)
(push) ; 8
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 7
(push) ; 7
; [else-branch: 2192 | !(above@1430@01 != Null && below@1432@01 != Null)]
(assert (not (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))
  (and
    (not (= above@1430@01 $Ref.null))
    (not (= below@1432@01 $Ref.null))
    (Level%precondition $Snap.unit above@1430@01)
    (Level%precondition $Snap.unit below@1432@01))))
; Joined path conditions
(assert (or
  (not (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null))))
  (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    (or (not (= above@1430@01 $Ref.null)) (= above@1430@01 $Ref.null))
    (=>
      (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))
      (and
        (not (= above@1430@01 $Ref.null))
        (not (= below@1432@01 $Ref.null))
        (Level%precondition $Snap.unit above@1430@01)
        (Level%precondition $Snap.unit below@1432@01)))
    (or
      (not
        (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null))))
      (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))))))
(assert (=>
  (and
    p1_30@1418@01
    (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null))))
  (< (Level $Snap.unit above@1430@01) (Level $Snap.unit below@1432@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 != null && below_0 != null ==> Level(above_0) < Level(below_0)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2193 | p2_30@1419@01 | live]
; [else-branch: 2193 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2193 | p2_30@1419@01]
; [eval] above_0 != null && below_0 != null ==> Level(above_0) < Level(below_0)
; [eval] above_0 != null && below_0 != null
; [eval] above_0 != null
(push) ; 6
; [then-branch: 2194 | above_0@1431@01 == Null | live]
; [else-branch: 2194 | above_0@1431@01 != Null | live]
(push) ; 7
; [then-branch: 2194 | above_0@1431@01 == Null]
(assert (= above_0@1431@01 $Ref.null))
(pop) ; 7
(push) ; 7
; [else-branch: 2194 | above_0@1431@01 != Null]
(assert (not (= above_0@1431@01 $Ref.null)))
; [eval] below_0 != null
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (not (= above_0@1431@01 $Ref.null)) (= above_0@1431@01 $Ref.null)))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2195 | above_0@1431@01 != Null && below_0@1433@01 != Null | live]
; [else-branch: 2195 | !(above_0@1431@01 != Null && below_0@1433@01 != Null) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2195 | above_0@1431@01 != Null && below_0@1433@01 != Null]
(assert (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null))))
; [eval] Level(above_0) < Level(below_0)
; [eval] Level(above_0)
(push) ; 8
(assert (Level%precondition $Snap.unit above_0@1431@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit above_0@1431@01))
; [eval] Level(below_0)
(push) ; 8
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 7
(push) ; 7
; [else-branch: 2195 | !(above_0@1431@01 != Null && below_0@1433@01 != Null)]
(assert (not
  (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null)))
  (and
    (not (= above_0@1431@01 $Ref.null))
    (not (= below_0@1433@01 $Ref.null))
    (Level%precondition $Snap.unit above_0@1431@01)
    (Level%precondition $Snap.unit below_0@1433@01))))
; Joined path conditions
(assert (or
  (not
    (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null))))
  (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    (or (not (= above_0@1431@01 $Ref.null)) (= above_0@1431@01 $Ref.null))
    (=>
      (and
        (not (= above_0@1431@01 $Ref.null))
        (not (= below_0@1433@01 $Ref.null)))
      (and
        (not (= above_0@1431@01 $Ref.null))
        (not (= below_0@1433@01 $Ref.null))
        (Level%precondition $Snap.unit above_0@1431@01)
        (Level%precondition $Snap.unit below_0@1433@01)))
    (or
      (not
        (and
          (not (= above_0@1431@01 $Ref.null))
          (not (= below_0@1433@01 $Ref.null))))
      (and
        (not (= above_0@1431@01 $Ref.null))
        (not (= below_0@1433@01 $Ref.null)))))))
(assert (=>
  (and
    p2_30@1419@01
    (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null))))
  (< (Level $Snap.unit above_0@1431@01) (Level $Snap.unit below_0@1433@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
; [then-branch: 2196 | p1_30@1418@01 | live]
; [else-branch: 2196 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2196 | p1_30@1418@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2197 | p2_30@1419@01 | live]
; [else-branch: 2197 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2197 | p2_30@1419@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 && p2_30 ==> Lock_invariant_low(self_4, self_4_0)
; [eval] p1_30 && p2_30
(push) ; 6
; [then-branch: 2198 | !(p1_30@1418@01) | live]
; [else-branch: 2198 | p1_30@1418@01 | live]
(push) ; 7
; [then-branch: 2198 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 7
(push) ; 7
; [else-branch: 2198 | p1_30@1418@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or p1_30@1418@01 (not p1_30@1418@01)))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not (and p1_30@1418@01 p2_30@1419@01))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and p1_30@1418@01 p2_30@1419@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2199 | p1_30@1418@01 && p2_30@1419@01 | live]
; [else-branch: 2199 | !(p1_30@1418@01 && p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2199 | p1_30@1418@01 && p2_30@1419@01]
(assert (and p1_30@1418@01 p2_30@1419@01))
; [eval] Lock_invariant_low(self_4, self_4_0)
(push) ; 8
(declare-const $k@1437@01 $Perm)
(assert ($Perm.isReadVar $k@1437@01))
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No $k@1437@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(declare-const $k@1438@01 $Perm)
(assert ($Perm.isReadVar $k@1438@01))
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No $k@1438@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))) self_4@1426@01 self_4_0@1427@01))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@1437@01))
(assert ($Perm.isReadVar $k@1438@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))) self_4@1426@01 self_4_0@1427@01))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert ($Perm.isReadVar $k@1437@01))
(assert ($Perm.isReadVar $k@1438@01))
(assert (=>
  (and p1_30@1418@01 p2_30@1419@01)
  (and
    p1_30@1418@01
    p2_30@1419@01
    (Lock_invariant_low%precondition ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))) self_4@1426@01 self_4_0@1427@01))))
(assert (and p1_30@1418@01 p2_30@1419@01))
(assert (=>
  (and p1_30@1418@01 p2_30@1419@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))) self_4@1426@01 self_4_0@1427@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> true
(set-option :timeout 0)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2200 | p1_30@1418@01 | live]
; [else-branch: 2200 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2200 | p1_30@1418@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
; [then-branch: 2201 | p2_30@1419@01 | live]
; [else-branch: 2201 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2201 | p2_30@1419@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
; [then-branch: 2202 | p1_30@1418@01 | live]
; [else-branch: 2202 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2202 | p1_30@1418@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2203 | p2_30@1419@01 | live]
; [else-branch: 2203 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2203 | p2_30@1419@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@1439@01 $Snap)
(assert (= $t@1439@01 ($Snap.combine ($Snap.first $t@1439@01) ($Snap.second $t@1439@01))))
(assert (= ($Snap.first $t@1439@01) $Snap.unit))
; [eval] p1_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171) && ((forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171) && _residue_171 <= _current_wait_level_171)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2204 | p1_30@1418@01 | live]
; [else-branch: 2204 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2204 | p1_30@1418@01]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171) && ((forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171) && _residue_171 <= _current_wait_level_171)
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171)
(push) ; 9
; [then-branch: 2205 | False | live]
; [else-branch: 2205 | True | live]
(push) ; 10
; [then-branch: 2205 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 2205 | True]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171)
(push) ; 11
; [then-branch: 2206 | False | live]
; [else-branch: 2206 | True | live]
(push) ; 12
; [then-branch: 2206 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 2206 | True]
; [eval] _residue_171 <= _current_wait_level_171
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p1_30@1418@01 (<= _residue_171@1424@01 _current_wait_level_171@1434@01)))
(assert (=
  ($Snap.second $t@1439@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1439@01))
    ($Snap.second ($Snap.second $t@1439@01)))))
(assert (= ($Snap.first ($Snap.second $t@1439@01)) $Snap.unit))
; [eval] p2_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0) && ((forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0) && _residue_171_0 <= _current_wait_level_171_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2207 | p2_30@1419@01 | live]
; [else-branch: 2207 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2207 | p2_30@1419@01]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0) && ((forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0) && _residue_171_0 <= _current_wait_level_171_0)
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0)
(push) ; 9
; [then-branch: 2208 | False | live]
; [else-branch: 2208 | True | live]
(push) ; 10
; [then-branch: 2208 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 2208 | True]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0)
(push) ; 11
; [then-branch: 2209 | False | live]
; [else-branch: 2209 | True | live]
(push) ; 12
; [then-branch: 2209 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 2209 | True]
; [eval] _residue_171_0 <= _current_wait_level_171_0
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p2_30@1419@01 (<= _residue_171_0@1425@01 _current_wait_level_171_0@1435@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1439@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1439@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1439@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1439@01))) $Snap.unit))
; [eval] p1_30 ==> above == null ==> _current_wait_level_171 < Level(self_4)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2210 | p1_30@1418@01 | live]
; [else-branch: 2210 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2210 | p1_30@1418@01]
; [eval] above == null ==> _current_wait_level_171 < Level(self_4)
; [eval] above == null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= above@1430@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (= above@1430@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2211 | above@1430@01 == Null | live]
; [else-branch: 2211 | above@1430@01 != Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2211 | above@1430@01 == Null]
(assert (= above@1430@01 $Ref.null))
; [eval] _current_wait_level_171 < Level(self_4)
; [eval] Level(self_4)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4@1426@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4@1426@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2211 | above@1430@01 != Null]
(assert (not (= above@1430@01 $Ref.null)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (= above@1430@01 $Ref.null)
  (and
    (= above@1430@01 $Ref.null)
    (Level%precondition $Snap.unit self_4@1426@01))))
; Joined path conditions
(assert (or (not (= above@1430@01 $Ref.null)) (= above@1430@01 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    (=>
      (= above@1430@01 $Ref.null)
      (and
        (= above@1430@01 $Ref.null)
        (Level%precondition $Snap.unit self_4@1426@01)))
    (or (not (= above@1430@01 $Ref.null)) (= above@1430@01 $Ref.null)))))
(assert (=>
  (and p1_30@1418@01 (= above@1430@01 $Ref.null))
  (< _current_wait_level_171@1434@01 (Level $Snap.unit self_4@1426@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1439@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1439@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1439@01))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null ==> _current_wait_level_171_0 < Level(self_4_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2212 | p2_30@1419@01 | live]
; [else-branch: 2212 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2212 | p2_30@1419@01]
; [eval] above_0 == null ==> _current_wait_level_171_0 < Level(self_4_0)
; [eval] above_0 == null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= above_0@1431@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (= above_0@1431@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2213 | above_0@1431@01 == Null | live]
; [else-branch: 2213 | above_0@1431@01 != Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2213 | above_0@1431@01 == Null]
(assert (= above_0@1431@01 $Ref.null))
; [eval] _current_wait_level_171_0 < Level(self_4_0)
; [eval] Level(self_4_0)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2213 | above_0@1431@01 != Null]
(assert (not (= above_0@1431@01 $Ref.null)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (= above_0@1431@01 $Ref.null)
  (and
    (= above_0@1431@01 $Ref.null)
    (Level%precondition $Snap.unit self_4_0@1427@01))))
; Joined path conditions
(assert (or (not (= above_0@1431@01 $Ref.null)) (= above_0@1431@01 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    (=>
      (= above_0@1431@01 $Ref.null)
      (and
        (= above_0@1431@01 $Ref.null)
        (Level%precondition $Snap.unit self_4_0@1427@01)))
    (or (not (= above_0@1431@01 $Ref.null)) (= above_0@1431@01 $Ref.null)))))
(assert (=>
  (and p2_30@1419@01 (= above_0@1431@01 $Ref.null))
  (< _current_wait_level_171_0@1435@01 (Level $Snap.unit self_4_0@1427@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01)))))
  $Snap.unit))
; [eval] p1_30 ==> above != null ==> Level(above) < Level(self_4)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2214 | p1_30@1418@01 | live]
; [else-branch: 2214 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2214 | p1_30@1418@01]
; [eval] above != null ==> Level(above) < Level(self_4)
; [eval] above != null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (= above@1430@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= above@1430@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2215 | above@1430@01 != Null | live]
; [else-branch: 2215 | above@1430@01 == Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2215 | above@1430@01 != Null]
(assert (not (= above@1430@01 $Ref.null)))
; [eval] Level(above) < Level(self_4)
; [eval] Level(above)
(push) ; 11
(assert (Level%precondition $Snap.unit above@1430@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit above@1430@01))
; [eval] Level(self_4)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4@1426@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4@1426@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2215 | above@1430@01 == Null]
(assert (= above@1430@01 $Ref.null))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (not (= above@1430@01 $Ref.null))
  (and
    (not (= above@1430@01 $Ref.null))
    (Level%precondition $Snap.unit above@1430@01)
    (Level%precondition $Snap.unit self_4@1426@01))))
; Joined path conditions
(assert (or (= above@1430@01 $Ref.null) (not (= above@1430@01 $Ref.null))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    (=>
      (not (= above@1430@01 $Ref.null))
      (and
        (not (= above@1430@01 $Ref.null))
        (Level%precondition $Snap.unit above@1430@01)
        (Level%precondition $Snap.unit self_4@1426@01)))
    (or (= above@1430@01 $Ref.null) (not (= above@1430@01 $Ref.null))))))
(assert (=>
  (and p1_30@1418@01 (not (= above@1430@01 $Ref.null)))
  (< (Level $Snap.unit above@1430@01) (Level $Snap.unit self_4@1426@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 != null ==> Level(above_0) < Level(self_4_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2216 | p2_30@1419@01 | live]
; [else-branch: 2216 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2216 | p2_30@1419@01]
; [eval] above_0 != null ==> Level(above_0) < Level(self_4_0)
; [eval] above_0 != null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (= above_0@1431@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= above_0@1431@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2217 | above_0@1431@01 != Null | live]
; [else-branch: 2217 | above_0@1431@01 == Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2217 | above_0@1431@01 != Null]
(assert (not (= above_0@1431@01 $Ref.null)))
; [eval] Level(above_0) < Level(self_4_0)
; [eval] Level(above_0)
(push) ; 11
(assert (Level%precondition $Snap.unit above_0@1431@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit above_0@1431@01))
; [eval] Level(self_4_0)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2217 | above_0@1431@01 == Null]
(assert (= above_0@1431@01 $Ref.null))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (not (= above_0@1431@01 $Ref.null))
  (and
    (not (= above_0@1431@01 $Ref.null))
    (Level%precondition $Snap.unit above_0@1431@01)
    (Level%precondition $Snap.unit self_4_0@1427@01))))
; Joined path conditions
(assert (or (= above_0@1431@01 $Ref.null) (not (= above_0@1431@01 $Ref.null))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    (=>
      (not (= above_0@1431@01 $Ref.null))
      (and
        (not (= above_0@1431@01 $Ref.null))
        (Level%precondition $Snap.unit above_0@1431@01)
        (Level%precondition $Snap.unit self_4_0@1427@01)))
    (or (= above_0@1431@01 $Ref.null) (not (= above_0@1431@01 $Ref.null))))))
(assert (=>
  (and p2_30@1419@01 (not (= above_0@1431@01 $Ref.null)))
  (< (Level $Snap.unit above_0@1431@01) (Level $Snap.unit self_4_0@1427@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01)))))))
  $Snap.unit))
; [eval] p1_30 ==> below != null ==> Level(self_4) < Level(below)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2218 | p1_30@1418@01 | live]
; [else-branch: 2218 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2218 | p1_30@1418@01]
; [eval] below != null ==> Level(self_4) < Level(below)
; [eval] below != null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (= below@1432@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= below@1432@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2219 | below@1432@01 != Null | live]
; [else-branch: 2219 | below@1432@01 == Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2219 | below@1432@01 != Null]
(assert (not (= below@1432@01 $Ref.null)))
; [eval] Level(self_4) < Level(below)
; [eval] Level(self_4)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4@1426@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4@1426@01))
; [eval] Level(below)
(push) ; 11
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2219 | below@1432@01 == Null]
(assert (= below@1432@01 $Ref.null))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (not (= below@1432@01 $Ref.null))
  (and
    (not (= below@1432@01 $Ref.null))
    (Level%precondition $Snap.unit self_4@1426@01)
    (Level%precondition $Snap.unit below@1432@01))))
; Joined path conditions
(assert (or (= below@1432@01 $Ref.null) (not (= below@1432@01 $Ref.null))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    (=>
      (not (= below@1432@01 $Ref.null))
      (and
        (not (= below@1432@01 $Ref.null))
        (Level%precondition $Snap.unit self_4@1426@01)
        (Level%precondition $Snap.unit below@1432@01)))
    (or (= below@1432@01 $Ref.null) (not (= below@1432@01 $Ref.null))))))
(assert (=>
  (and p1_30@1418@01 (not (= below@1432@01 $Ref.null)))
  (< (Level $Snap.unit self_4@1426@01) (Level $Snap.unit below@1432@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1439@01)))))))
  $Snap.unit))
; [eval] p2_30 ==> below_0 != null ==> Level(self_4_0) < Level(below_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2220 | p2_30@1419@01 | live]
; [else-branch: 2220 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2220 | p2_30@1419@01]
; [eval] below_0 != null ==> Level(self_4_0) < Level(below_0)
; [eval] below_0 != null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (= below_0@1433@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= below_0@1433@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2221 | below_0@1433@01 != Null | live]
; [else-branch: 2221 | below_0@1433@01 == Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2221 | below_0@1433@01 != Null]
(assert (not (= below_0@1433@01 $Ref.null)))
; [eval] Level(self_4_0) < Level(below_0)
; [eval] Level(self_4_0)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
; [eval] Level(below_0)
(push) ; 11
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2221 | below_0@1433@01 == Null]
(assert (= below_0@1433@01 $Ref.null))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (not (= below_0@1433@01 $Ref.null))
  (and
    (not (= below_0@1433@01 $Ref.null))
    (Level%precondition $Snap.unit self_4_0@1427@01)
    (Level%precondition $Snap.unit below_0@1433@01))))
; Joined path conditions
(assert (or (= below_0@1433@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    (=>
      (not (= below_0@1433@01 $Ref.null))
      (and
        (not (= below_0@1433@01 $Ref.null))
        (Level%precondition $Snap.unit self_4_0@1427@01)
        (Level%precondition $Snap.unit below_0@1433@01)))
    (or (= below_0@1433@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))))
(assert (=>
  (and p2_30@1419@01 (not (= below_0@1433@01 $Ref.null)))
  (< (Level $Snap.unit self_4_0@1427@01) (Level $Snap.unit below_0@1433@01))))
(pop) ; 6
(push) ; 6
; [exec]
; var _cwl_171: Perm
(declare-const _cwl_171@1440@01 $Perm)
; [exec]
; var _cwl_171_0: Perm
(declare-const _cwl_171_0@1441@01 $Perm)
; [exec]
; inhale p1_30
(declare-const $t@1442@01 $Snap)
(assert (= $t@1442@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2222 | p1_30@1418@01 | live]
; [else-branch: 2222 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2222 | p1_30@1418@01]
; [exec]
; inhale typeof(self_4) == Lock(Lock_arg(typeof(self_4), 0))
(declare-const $t@1443@01 $Snap)
(assert (= $t@1443@01 $Snap.unit))
; [eval] typeof(self_4) == Lock(Lock_arg(typeof(self_4), 0))
; [eval] typeof(self_4)
; [eval] Lock(Lock_arg(typeof(self_4), 0))
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
(assert (=
  (typeof<PyType> self_4@1426@01)
  (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> self_4@1426@01) 0))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale false
(pop) ; 7
; [eval] !p1_30
; [then-branch: 2223 | !(p1_30@1418@01) | dead]
; [else-branch: 2223 | p1_30@1418@01 | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 2223 | p1_30@1418@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 2183 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> above == null && below != null ==> _residue_171 < Level(below)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not p1_30@1418@01))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2224 | p1_30@1418@01 | live]
; [else-branch: 2224 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2224 | p1_30@1418@01]
(assert p1_30@1418@01)
; [eval] above == null && below != null ==> _residue_171 < Level(below)
; [eval] above == null && below != null
; [eval] above == null
(push) ; 6
; [then-branch: 2225 | above@1430@01 != Null | live]
; [else-branch: 2225 | above@1430@01 == Null | live]
(push) ; 7
; [then-branch: 2225 | above@1430@01 != Null]
(assert (not (= above@1430@01 $Ref.null)))
(pop) ; 7
(push) ; 7
; [else-branch: 2225 | above@1430@01 == Null]
(assert (= above@1430@01 $Ref.null))
; [eval] below != null
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (= above@1430@01 $Ref.null) (not (= above@1430@01 $Ref.null))))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2226 | above@1430@01 == Null && below@1432@01 != Null | live]
; [else-branch: 2226 | !(above@1430@01 == Null && below@1432@01 != Null) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2226 | above@1430@01 == Null && below@1432@01 != Null]
(assert (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null))))
; [eval] _residue_171 < Level(below)
; [eval] Level(below)
(push) ; 8
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 7
(push) ; 7
; [else-branch: 2226 | !(above@1430@01 == Null && below@1432@01 != Null)]
(assert (not (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))
  (and
    (= above@1430@01 $Ref.null)
    (not (= below@1432@01 $Ref.null))
    (Level%precondition $Snap.unit below@1432@01))))
; Joined path conditions
(assert (or
  (not (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null))))
  (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    p1_30@1418@01
    (or (= above@1430@01 $Ref.null) (not (= above@1430@01 $Ref.null)))
    (=>
      (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))
      (and
        (= above@1430@01 $Ref.null)
        (not (= below@1432@01 $Ref.null))
        (Level%precondition $Snap.unit below@1432@01)))
    (or
      (not (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null))))
      (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null)))))))
(assert p1_30@1418@01)
(assert (=>
  (and
    p1_30@1418@01
    (and (= above@1430@01 $Ref.null) (not (= below@1432@01 $Ref.null))))
  (< _residue_171@1424@01 (Level $Snap.unit below@1432@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null && below_0 != null ==> _residue_171_0 < Level(below_0)
(push) ; 4
; [then-branch: 2227 | p2_30@1419@01 | dead]
; [else-branch: 2227 | !(p2_30@1419@01) | live]
(push) ; 5
; [else-branch: 2227 | !(p2_30@1419@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> above != null && below != null ==> Level(above) < Level(below)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2228 | p1_30@1418@01 | live]
; [else-branch: 2228 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2228 | p1_30@1418@01]
; [eval] above != null && below != null ==> Level(above) < Level(below)
; [eval] above != null && below != null
; [eval] above != null
(push) ; 6
; [then-branch: 2229 | above@1430@01 == Null | live]
; [else-branch: 2229 | above@1430@01 != Null | live]
(push) ; 7
; [then-branch: 2229 | above@1430@01 == Null]
(assert (= above@1430@01 $Ref.null))
(pop) ; 7
(push) ; 7
; [else-branch: 2229 | above@1430@01 != Null]
(assert (not (= above@1430@01 $Ref.null)))
; [eval] below != null
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (not (= above@1430@01 $Ref.null)) (= above@1430@01 $Ref.null)))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2230 | above@1430@01 != Null && below@1432@01 != Null | live]
; [else-branch: 2230 | !(above@1430@01 != Null && below@1432@01 != Null) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2230 | above@1430@01 != Null && below@1432@01 != Null]
(assert (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null))))
; [eval] Level(above) < Level(below)
; [eval] Level(above)
(push) ; 8
(assert (Level%precondition $Snap.unit above@1430@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit above@1430@01))
; [eval] Level(below)
(push) ; 8
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 7
(push) ; 7
; [else-branch: 2230 | !(above@1430@01 != Null && below@1432@01 != Null)]
(assert (not (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))
  (and
    (not (= above@1430@01 $Ref.null))
    (not (= below@1432@01 $Ref.null))
    (Level%precondition $Snap.unit above@1430@01)
    (Level%precondition $Snap.unit below@1432@01))))
; Joined path conditions
(assert (or
  (not (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null))))
  (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    (or (not (= above@1430@01 $Ref.null)) (= above@1430@01 $Ref.null))
    (=>
      (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))
      (and
        (not (= above@1430@01 $Ref.null))
        (not (= below@1432@01 $Ref.null))
        (Level%precondition $Snap.unit above@1430@01)
        (Level%precondition $Snap.unit below@1432@01)))
    (or
      (not
        (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null))))
      (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null)))))))
(assert (=>
  (and
    p1_30@1418@01
    (and (not (= above@1430@01 $Ref.null)) (not (= below@1432@01 $Ref.null))))
  (< (Level $Snap.unit above@1430@01) (Level $Snap.unit below@1432@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 != null && below_0 != null ==> Level(above_0) < Level(below_0)
(push) ; 4
; [then-branch: 2231 | p2_30@1419@01 | dead]
; [else-branch: 2231 | !(p2_30@1419@01) | live]
(push) ; 5
; [else-branch: 2231 | !(p2_30@1419@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2232 | p1_30@1418@01 | live]
; [else-branch: 2232 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2232 | p1_30@1418@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
; [then-branch: 2233 | p2_30@1419@01 | dead]
; [else-branch: 2233 | !(p2_30@1419@01) | live]
(push) ; 5
; [else-branch: 2233 | !(p2_30@1419@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 && p2_30 ==> Lock_invariant_low(self_4, self_4_0)
; [eval] p1_30 && p2_30
(push) ; 6
; [then-branch: 2234 | !(p1_30@1418@01) | live]
; [else-branch: 2234 | p1_30@1418@01 | live]
(push) ; 7
; [then-branch: 2234 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(pop) ; 7
(push) ; 7
; [else-branch: 2234 | p1_30@1418@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or p1_30@1418@01 (not p1_30@1418@01)))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not (and p1_30@1418@01 p2_30@1419@01))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2235 | p1_30@1418@01 && p2_30@1419@01 | dead]
; [else-branch: 2235 | !(p1_30@1418@01 && p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 2235 | !(p1_30@1418@01 && p2_30@1419@01)]
(assert (not (and p1_30@1418@01 p2_30@1419@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (not (and p1_30@1418@01 p2_30@1419@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2236 | p1_30@1418@01 | live]
; [else-branch: 2236 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2236 | p1_30@1418@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> true
(push) ; 6
; [then-branch: 2237 | p2_30@1419@01 | dead]
; [else-branch: 2237 | !(p2_30@1419@01) | live]
(push) ; 7
; [else-branch: 2237 | !(p2_30@1419@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2238 | p1_30@1418@01 | live]
; [else-branch: 2238 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2238 | p1_30@1418@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> true
(push) ; 6
; [then-branch: 2239 | p2_30@1419@01 | dead]
; [else-branch: 2239 | !(p2_30@1419@01) | live]
(push) ; 7
; [else-branch: 2239 | !(p2_30@1419@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@1444@01 $Snap)
(assert (= $t@1444@01 ($Snap.combine ($Snap.first $t@1444@01) ($Snap.second $t@1444@01))))
(assert (= ($Snap.first $t@1444@01) $Snap.unit))
; [eval] p1_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171) && ((forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171) && _residue_171 <= _current_wait_level_171)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2240 | p1_30@1418@01 | live]
; [else-branch: 2240 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2240 | p1_30@1418@01]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171) && ((forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171) && _residue_171 <= _current_wait_level_171)
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171)
(push) ; 9
; [then-branch: 2241 | False | live]
; [else-branch: 2241 | True | live]
(push) ; 10
; [then-branch: 2241 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 2241 | True]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171)
(push) ; 11
; [then-branch: 2242 | False | live]
; [else-branch: 2242 | True | live]
(push) ; 12
; [then-branch: 2242 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 2242 | True]
; [eval] _residue_171 <= _current_wait_level_171
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p1_30@1418@01 (<= _residue_171@1424@01 _current_wait_level_171@1434@01)))
(assert (=
  ($Snap.second $t@1444@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1444@01))
    ($Snap.second ($Snap.second $t@1444@01)))))
(assert (= ($Snap.first ($Snap.second $t@1444@01)) $Snap.unit))
; [eval] p2_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0) && ((forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0) && _residue_171_0 <= _current_wait_level_171_0)
(push) ; 7
; [then-branch: 2243 | p2_30@1419@01 | dead]
; [else-branch: 2243 | !(p2_30@1419@01) | live]
(push) ; 8
; [else-branch: 2243 | !(p2_30@1419@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1444@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1444@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1444@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1444@01))) $Snap.unit))
; [eval] p1_30 ==> above == null ==> _current_wait_level_171 < Level(self_4)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2244 | p1_30@1418@01 | live]
; [else-branch: 2244 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2244 | p1_30@1418@01]
; [eval] above == null ==> _current_wait_level_171 < Level(self_4)
; [eval] above == null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= above@1430@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (= above@1430@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2245 | above@1430@01 == Null | live]
; [else-branch: 2245 | above@1430@01 != Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2245 | above@1430@01 == Null]
(assert (= above@1430@01 $Ref.null))
; [eval] _current_wait_level_171 < Level(self_4)
; [eval] Level(self_4)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4@1426@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4@1426@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2245 | above@1430@01 != Null]
(assert (not (= above@1430@01 $Ref.null)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (= above@1430@01 $Ref.null)
  (and
    (= above@1430@01 $Ref.null)
    (Level%precondition $Snap.unit self_4@1426@01))))
; Joined path conditions
(assert (or (not (= above@1430@01 $Ref.null)) (= above@1430@01 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    (=>
      (= above@1430@01 $Ref.null)
      (and
        (= above@1430@01 $Ref.null)
        (Level%precondition $Snap.unit self_4@1426@01)))
    (or (not (= above@1430@01 $Ref.null)) (= above@1430@01 $Ref.null)))))
(assert (=>
  (and p1_30@1418@01 (= above@1430@01 $Ref.null))
  (< _current_wait_level_171@1434@01 (Level $Snap.unit self_4@1426@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1444@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1444@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1444@01))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null ==> _current_wait_level_171_0 < Level(self_4_0)
(push) ; 7
; [then-branch: 2246 | p2_30@1419@01 | dead]
; [else-branch: 2246 | !(p2_30@1419@01) | live]
(push) ; 8
; [else-branch: 2246 | !(p2_30@1419@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01)))))
  $Snap.unit))
; [eval] p1_30 ==> above != null ==> Level(above) < Level(self_4)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2247 | p1_30@1418@01 | live]
; [else-branch: 2247 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2247 | p1_30@1418@01]
; [eval] above != null ==> Level(above) < Level(self_4)
; [eval] above != null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (= above@1430@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= above@1430@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2248 | above@1430@01 != Null | live]
; [else-branch: 2248 | above@1430@01 == Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2248 | above@1430@01 != Null]
(assert (not (= above@1430@01 $Ref.null)))
; [eval] Level(above) < Level(self_4)
; [eval] Level(above)
(push) ; 11
(assert (Level%precondition $Snap.unit above@1430@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit above@1430@01))
; [eval] Level(self_4)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4@1426@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4@1426@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2248 | above@1430@01 == Null]
(assert (= above@1430@01 $Ref.null))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (not (= above@1430@01 $Ref.null))
  (and
    (not (= above@1430@01 $Ref.null))
    (Level%precondition $Snap.unit above@1430@01)
    (Level%precondition $Snap.unit self_4@1426@01))))
; Joined path conditions
(assert (or (= above@1430@01 $Ref.null) (not (= above@1430@01 $Ref.null))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    (=>
      (not (= above@1430@01 $Ref.null))
      (and
        (not (= above@1430@01 $Ref.null))
        (Level%precondition $Snap.unit above@1430@01)
        (Level%precondition $Snap.unit self_4@1426@01)))
    (or (= above@1430@01 $Ref.null) (not (= above@1430@01 $Ref.null))))))
(assert (=>
  (and p1_30@1418@01 (not (= above@1430@01 $Ref.null)))
  (< (Level $Snap.unit above@1430@01) (Level $Snap.unit self_4@1426@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 != null ==> Level(above_0) < Level(self_4_0)
(push) ; 7
; [then-branch: 2249 | p2_30@1419@01 | dead]
; [else-branch: 2249 | !(p2_30@1419@01) | live]
(push) ; 8
; [else-branch: 2249 | !(p2_30@1419@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01)))))))
  $Snap.unit))
; [eval] p1_30 ==> below != null ==> Level(self_4) < Level(below)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2250 | p1_30@1418@01 | live]
; [else-branch: 2250 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2250 | p1_30@1418@01]
; [eval] below != null ==> Level(self_4) < Level(below)
; [eval] below != null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (= below@1432@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= below@1432@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2251 | below@1432@01 != Null | live]
; [else-branch: 2251 | below@1432@01 == Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2251 | below@1432@01 != Null]
(assert (not (= below@1432@01 $Ref.null)))
; [eval] Level(self_4) < Level(below)
; [eval] Level(self_4)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4@1426@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4@1426@01))
; [eval] Level(below)
(push) ; 11
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit below@1432@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2251 | below@1432@01 == Null]
(assert (= below@1432@01 $Ref.null))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (not (= below@1432@01 $Ref.null))
  (and
    (not (= below@1432@01 $Ref.null))
    (Level%precondition $Snap.unit self_4@1426@01)
    (Level%precondition $Snap.unit below@1432@01))))
; Joined path conditions
(assert (or (= below@1432@01 $Ref.null) (not (= below@1432@01 $Ref.null))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p1_30@1418@01
  (and
    (=>
      (not (= below@1432@01 $Ref.null))
      (and
        (not (= below@1432@01 $Ref.null))
        (Level%precondition $Snap.unit self_4@1426@01)
        (Level%precondition $Snap.unit below@1432@01)))
    (or (= below@1432@01 $Ref.null) (not (= below@1432@01 $Ref.null))))))
(assert (=>
  (and p1_30@1418@01 (not (= below@1432@01 $Ref.null)))
  (< (Level $Snap.unit self_4@1426@01) (Level $Snap.unit below@1432@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1444@01)))))))
  $Snap.unit))
; [eval] p2_30 ==> below_0 != null ==> Level(self_4_0) < Level(below_0)
(push) ; 7
; [then-branch: 2252 | p2_30@1419@01 | dead]
; [else-branch: 2252 | !(p2_30@1419@01) | live]
(push) ; 8
; [else-branch: 2252 | !(p2_30@1419@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(pop) ; 6
(push) ; 6
; [exec]
; var _cwl_171: Perm
(declare-const _cwl_171@1445@01 $Perm)
; [exec]
; var _cwl_171_0: Perm
(declare-const _cwl_171_0@1446@01 $Perm)
; [exec]
; inhale p1_30
(declare-const $t@1447@01 $Snap)
(assert (= $t@1447@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_30@1418@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2253 | p1_30@1418@01 | live]
; [else-branch: 2253 | !(p1_30@1418@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2253 | p1_30@1418@01]
; [exec]
; inhale typeof(self_4) == Lock(Lock_arg(typeof(self_4), 0))
(declare-const $t@1448@01 $Snap)
(assert (= $t@1448@01 $Snap.unit))
; [eval] typeof(self_4) == Lock(Lock_arg(typeof(self_4), 0))
; [eval] typeof(self_4)
; [eval] Lock(Lock_arg(typeof(self_4), 0))
; [eval] Lock_arg(typeof(self_4), 0)
; [eval] typeof(self_4)
(assert (=
  (typeof<PyType> self_4@1426@01)
  (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> self_4@1426@01) 0))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale false
(pop) ; 7
; [eval] !p1_30
; [then-branch: 2254 | !(p1_30@1418@01) | dead]
; [else-branch: 2254 | p1_30@1418@01 | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 2254 | p1_30@1418@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [else-branch: 2182 | !(p1_30@1418@01)]
(assert (not p1_30@1418@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_30@1419@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2255 | p2_30@1419@01 | live]
; [else-branch: 2255 | !(p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2255 | p2_30@1419@01]
(assert p2_30@1419@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> above == null && below != null ==> _residue_171 < Level(below)
(push) ; 4
; [then-branch: 2256 | p1_30@1418@01 | dead]
; [else-branch: 2256 | !(p1_30@1418@01) | live]
(push) ; 5
; [else-branch: 2256 | !(p1_30@1418@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null && below_0 != null ==> _residue_171_0 < Level(below_0)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2257 | p2_30@1419@01 | live]
; [else-branch: 2257 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2257 | p2_30@1419@01]
; [eval] above_0 == null && below_0 != null ==> _residue_171_0 < Level(below_0)
; [eval] above_0 == null && below_0 != null
; [eval] above_0 == null
(push) ; 6
; [then-branch: 2258 | above_0@1431@01 != Null | live]
; [else-branch: 2258 | above_0@1431@01 == Null | live]
(push) ; 7
; [then-branch: 2258 | above_0@1431@01 != Null]
(assert (not (= above_0@1431@01 $Ref.null)))
(pop) ; 7
(push) ; 7
; [else-branch: 2258 | above_0@1431@01 == Null]
(assert (= above_0@1431@01 $Ref.null))
; [eval] below_0 != null
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (= above_0@1431@01 $Ref.null) (not (= above_0@1431@01 $Ref.null))))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2259 | above_0@1431@01 == Null && below_0@1433@01 != Null | live]
; [else-branch: 2259 | !(above_0@1431@01 == Null && below_0@1433@01 != Null) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2259 | above_0@1431@01 == Null && below_0@1433@01 != Null]
(assert (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))
; [eval] _residue_171_0 < Level(below_0)
; [eval] Level(below_0)
(push) ; 8
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 7
(push) ; 7
; [else-branch: 2259 | !(above_0@1431@01 == Null && below_0@1433@01 != Null)]
(assert (not (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))
  (and
    (= above_0@1431@01 $Ref.null)
    (not (= below_0@1433@01 $Ref.null))
    (Level%precondition $Snap.unit below_0@1433@01))))
; Joined path conditions
(assert (or
  (not (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))
  (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    (or (= above_0@1431@01 $Ref.null) (not (= above_0@1431@01 $Ref.null)))
    (=>
      (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))
      (and
        (= above_0@1431@01 $Ref.null)
        (not (= below_0@1433@01 $Ref.null))
        (Level%precondition $Snap.unit below_0@1433@01)))
    (or
      (not
        (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))
      (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null)))))))
(assert (=>
  (and
    p2_30@1419@01
    (and (= above_0@1431@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))
  (< _residue_171_0@1425@01 (Level $Snap.unit below_0@1433@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> above != null && below != null ==> Level(above) < Level(below)
(push) ; 4
; [then-branch: 2260 | p1_30@1418@01 | dead]
; [else-branch: 2260 | !(p1_30@1418@01) | live]
(push) ; 5
; [else-branch: 2260 | !(p1_30@1418@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 != null && below_0 != null ==> Level(above_0) < Level(below_0)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2261 | p2_30@1419@01 | live]
; [else-branch: 2261 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2261 | p2_30@1419@01]
; [eval] above_0 != null && below_0 != null ==> Level(above_0) < Level(below_0)
; [eval] above_0 != null && below_0 != null
; [eval] above_0 != null
(push) ; 6
; [then-branch: 2262 | above_0@1431@01 == Null | live]
; [else-branch: 2262 | above_0@1431@01 != Null | live]
(push) ; 7
; [then-branch: 2262 | above_0@1431@01 == Null]
(assert (= above_0@1431@01 $Ref.null))
(pop) ; 7
(push) ; 7
; [else-branch: 2262 | above_0@1431@01 != Null]
(assert (not (= above_0@1431@01 $Ref.null)))
; [eval] below_0 != null
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (not (= above_0@1431@01 $Ref.null)) (= above_0@1431@01 $Ref.null)))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not
  (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2263 | above_0@1431@01 != Null && below_0@1433@01 != Null | live]
; [else-branch: 2263 | !(above_0@1431@01 != Null && below_0@1433@01 != Null) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2263 | above_0@1431@01 != Null && below_0@1433@01 != Null]
(assert (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null))))
; [eval] Level(above_0) < Level(below_0)
; [eval] Level(above_0)
(push) ; 8
(assert (Level%precondition $Snap.unit above_0@1431@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit above_0@1431@01))
; [eval] Level(below_0)
(push) ; 8
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 8
; Joined path conditions
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 7
(push) ; 7
; [else-branch: 2263 | !(above_0@1431@01 != Null && below_0@1433@01 != Null)]
(assert (not
  (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null)))
  (and
    (not (= above_0@1431@01 $Ref.null))
    (not (= below_0@1433@01 $Ref.null))
    (Level%precondition $Snap.unit above_0@1431@01)
    (Level%precondition $Snap.unit below_0@1433@01))))
; Joined path conditions
(assert (or
  (not
    (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null))))
  (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    (or (not (= above_0@1431@01 $Ref.null)) (= above_0@1431@01 $Ref.null))
    (=>
      (and
        (not (= above_0@1431@01 $Ref.null))
        (not (= below_0@1433@01 $Ref.null)))
      (and
        (not (= above_0@1431@01 $Ref.null))
        (not (= below_0@1433@01 $Ref.null))
        (Level%precondition $Snap.unit above_0@1431@01)
        (Level%precondition $Snap.unit below_0@1433@01)))
    (or
      (not
        (and
          (not (= above_0@1431@01 $Ref.null))
          (not (= below_0@1433@01 $Ref.null))))
      (and
        (not (= above_0@1431@01 $Ref.null))
        (not (= below_0@1433@01 $Ref.null)))))))
(assert (=>
  (and
    p2_30@1419@01
    (and (not (= above_0@1431@01 $Ref.null)) (not (= below_0@1433@01 $Ref.null))))
  (< (Level $Snap.unit above_0@1431@01) (Level $Snap.unit below_0@1433@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
; [then-branch: 2264 | p1_30@1418@01 | dead]
; [else-branch: 2264 | !(p1_30@1418@01) | live]
(push) ; 4
; [else-branch: 2264 | !(p1_30@1418@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2265 | p2_30@1419@01 | live]
; [else-branch: 2265 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2265 | p2_30@1419@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 && p2_30 ==> Lock_invariant_low(self_4, self_4_0)
; [eval] p1_30 && p2_30
(push) ; 6
; [then-branch: 2266 | !(p1_30@1418@01) | live]
; [else-branch: 2266 | p1_30@1418@01 | live]
(push) ; 7
; [then-branch: 2266 | !(p1_30@1418@01)]
(pop) ; 7
(push) ; 7
; [else-branch: 2266 | p1_30@1418@01]
(assert p1_30@1418@01)
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or p1_30@1418@01 (not p1_30@1418@01)))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not (and p1_30@1418@01 p2_30@1419@01))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2267 | p1_30@1418@01 && p2_30@1419@01 | dead]
; [else-branch: 2267 | !(p1_30@1418@01 && p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 2267 | !(p1_30@1418@01 && p2_30@1419@01)]
(assert (not (and p1_30@1418@01 p2_30@1419@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (not (and p1_30@1418@01 p2_30@1419@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> true
(push) ; 6
; [then-branch: 2268 | p1_30@1418@01 | dead]
; [else-branch: 2268 | !(p1_30@1418@01) | live]
(push) ; 7
; [else-branch: 2268 | !(p1_30@1418@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2269 | p2_30@1419@01 | live]
; [else-branch: 2269 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2269 | p2_30@1419@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> true
(push) ; 6
; [then-branch: 2270 | p1_30@1418@01 | dead]
; [else-branch: 2270 | !(p1_30@1418@01) | live]
(push) ; 7
; [else-branch: 2270 | !(p1_30@1418@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> true
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2271 | p2_30@1419@01 | live]
; [else-branch: 2271 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2271 | p2_30@1419@01]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@1449@01 $Snap)
(assert (= $t@1449@01 ($Snap.combine ($Snap.first $t@1449@01) ($Snap.second $t@1449@01))))
(assert (= ($Snap.first $t@1449@01) $Snap.unit))
; [eval] p1_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171) && ((forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171) && _residue_171 <= _current_wait_level_171)
(push) ; 7
; [then-branch: 2272 | p1_30@1418@01 | dead]
; [else-branch: 2272 | !(p1_30@1418@01) | live]
(push) ; 8
; [else-branch: 2272 | !(p1_30@1418@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second $t@1449@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1449@01))
    ($Snap.second ($Snap.second $t@1449@01)))))
(assert (= ($Snap.first ($Snap.second $t@1449@01)) $Snap.unit))
; [eval] p2_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0) && ((forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0) && _residue_171_0 <= _current_wait_level_171_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2273 | p2_30@1419@01 | live]
; [else-branch: 2273 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2273 | p2_30@1419@01]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0) && ((forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0) && _residue_171_0 <= _current_wait_level_171_0)
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0)
(push) ; 9
; [then-branch: 2274 | False | live]
; [else-branch: 2274 | True | live]
(push) ; 10
; [then-branch: 2274 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 2274 | True]
; [eval] (forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0)
(push) ; 11
; [then-branch: 2275 | False | live]
; [else-branch: 2275 | True | live]
(push) ; 12
; [then-branch: 2275 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 2275 | True]
; [eval] _residue_171_0 <= _current_wait_level_171_0
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=> p2_30@1419@01 (<= _residue_171_0@1425@01 _current_wait_level_171_0@1435@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1449@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1449@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1449@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1449@01))) $Snap.unit))
; [eval] p1_30 ==> above == null ==> _current_wait_level_171 < Level(self_4)
(push) ; 7
; [then-branch: 2276 | p1_30@1418@01 | dead]
; [else-branch: 2276 | !(p1_30@1418@01) | live]
(push) ; 8
; [else-branch: 2276 | !(p1_30@1418@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1449@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1449@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1449@01))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null ==> _current_wait_level_171_0 < Level(self_4_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2277 | p2_30@1419@01 | live]
; [else-branch: 2277 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2277 | p2_30@1419@01]
; [eval] above_0 == null ==> _current_wait_level_171_0 < Level(self_4_0)
; [eval] above_0 == null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= above_0@1431@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (= above_0@1431@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2278 | above_0@1431@01 == Null | live]
; [else-branch: 2278 | above_0@1431@01 != Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2278 | above_0@1431@01 == Null]
(assert (= above_0@1431@01 $Ref.null))
; [eval] _current_wait_level_171_0 < Level(self_4_0)
; [eval] Level(self_4_0)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2278 | above_0@1431@01 != Null]
(assert (not (= above_0@1431@01 $Ref.null)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (= above_0@1431@01 $Ref.null)
  (and
    (= above_0@1431@01 $Ref.null)
    (Level%precondition $Snap.unit self_4_0@1427@01))))
; Joined path conditions
(assert (or (not (= above_0@1431@01 $Ref.null)) (= above_0@1431@01 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    (=>
      (= above_0@1431@01 $Ref.null)
      (and
        (= above_0@1431@01 $Ref.null)
        (Level%precondition $Snap.unit self_4_0@1427@01)))
    (or (not (= above_0@1431@01 $Ref.null)) (= above_0@1431@01 $Ref.null)))))
(assert (=>
  (and p2_30@1419@01 (= above_0@1431@01 $Ref.null))
  (< _current_wait_level_171_0@1435@01 (Level $Snap.unit self_4_0@1427@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01)))))
  $Snap.unit))
; [eval] p1_30 ==> above != null ==> Level(above) < Level(self_4)
(push) ; 7
; [then-branch: 2279 | p1_30@1418@01 | dead]
; [else-branch: 2279 | !(p1_30@1418@01) | live]
(push) ; 8
; [else-branch: 2279 | !(p1_30@1418@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 != null ==> Level(above_0) < Level(self_4_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2280 | p2_30@1419@01 | live]
; [else-branch: 2280 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2280 | p2_30@1419@01]
; [eval] above_0 != null ==> Level(above_0) < Level(self_4_0)
; [eval] above_0 != null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (= above_0@1431@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= above_0@1431@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2281 | above_0@1431@01 != Null | live]
; [else-branch: 2281 | above_0@1431@01 == Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2281 | above_0@1431@01 != Null]
(assert (not (= above_0@1431@01 $Ref.null)))
; [eval] Level(above_0) < Level(self_4_0)
; [eval] Level(above_0)
(push) ; 11
(assert (Level%precondition $Snap.unit above_0@1431@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit above_0@1431@01))
; [eval] Level(self_4_0)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2281 | above_0@1431@01 == Null]
(assert (= above_0@1431@01 $Ref.null))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (not (= above_0@1431@01 $Ref.null))
  (and
    (not (= above_0@1431@01 $Ref.null))
    (Level%precondition $Snap.unit above_0@1431@01)
    (Level%precondition $Snap.unit self_4_0@1427@01))))
; Joined path conditions
(assert (or (= above_0@1431@01 $Ref.null) (not (= above_0@1431@01 $Ref.null))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    (=>
      (not (= above_0@1431@01 $Ref.null))
      (and
        (not (= above_0@1431@01 $Ref.null))
        (Level%precondition $Snap.unit above_0@1431@01)
        (Level%precondition $Snap.unit self_4_0@1427@01)))
    (or (= above_0@1431@01 $Ref.null) (not (= above_0@1431@01 $Ref.null))))))
(assert (=>
  (and p2_30@1419@01 (not (= above_0@1431@01 $Ref.null)))
  (< (Level $Snap.unit above_0@1431@01) (Level $Snap.unit self_4_0@1427@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01)))))))
  $Snap.unit))
; [eval] p1_30 ==> below != null ==> Level(self_4) < Level(below)
(push) ; 7
; [then-branch: 2282 | p1_30@1418@01 | dead]
; [else-branch: 2282 | !(p1_30@1418@01) | live]
(push) ; 8
; [else-branch: 2282 | !(p1_30@1418@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1449@01)))))))
  $Snap.unit))
; [eval] p2_30 ==> below_0 != null ==> Level(self_4_0) < Level(below_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_30@1419@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2283 | p2_30@1419@01 | live]
; [else-branch: 2283 | !(p2_30@1419@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2283 | p2_30@1419@01]
; [eval] below_0 != null ==> Level(self_4_0) < Level(below_0)
; [eval] below_0 != null
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (= below_0@1433@01 $Ref.null)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (not (= below_0@1433@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2284 | below_0@1433@01 != Null | live]
; [else-branch: 2284 | below_0@1433@01 == Null | live]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2284 | below_0@1433@01 != Null]
(assert (not (= below_0@1433@01 $Ref.null)))
; [eval] Level(self_4_0) < Level(below_0)
; [eval] Level(self_4_0)
(push) ; 11
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit self_4_0@1427@01))
; [eval] Level(below_0)
(push) ; 11
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 11
; Joined path conditions
(assert (Level%precondition $Snap.unit below_0@1433@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2284 | below_0@1433@01 == Null]
(assert (= below_0@1433@01 $Ref.null))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (not (= below_0@1433@01 $Ref.null))
  (and
    (not (= below_0@1433@01 $Ref.null))
    (Level%precondition $Snap.unit self_4_0@1427@01)
    (Level%precondition $Snap.unit below_0@1433@01))))
; Joined path conditions
(assert (or (= below_0@1433@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  p2_30@1419@01
  (and
    (=>
      (not (= below_0@1433@01 $Ref.null))
      (and
        (not (= below_0@1433@01 $Ref.null))
        (Level%precondition $Snap.unit self_4_0@1427@01)
        (Level%precondition $Snap.unit below_0@1433@01)))
    (or (= below_0@1433@01 $Ref.null) (not (= below_0@1433@01 $Ref.null))))))
(assert (=>
  (and p2_30@1419@01 (not (= below_0@1433@01 $Ref.null)))
  (< (Level $Snap.unit self_4_0@1427@01) (Level $Snap.unit below_0@1433@01))))
(pop) ; 6
(push) ; 6
; [exec]
; var _cwl_171: Perm
(declare-const _cwl_171@1450@01 $Perm)
; [exec]
; var _cwl_171_0: Perm
(declare-const _cwl_171_0@1451@01 $Perm)
; [exec]
; inhale p1_30
(declare-const $t@1452@01 $Snap)
(assert (= $t@1452@01 $Snap.unit))
(assert p1_30@1418@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 2285 | p1_30@1418@01 | dead]
; [else-branch: 2285 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 2285 | !(p1_30@1418@01)]
(pop) ; 7
; [eval] !p1_30
; [then-branch: 2286 | !(p1_30@1418@01) | dead]
; [else-branch: 2286 | p1_30@1418@01 | live]
(push) ; 7
; [else-branch: 2286 | p1_30@1418@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 2255 | !(p2_30@1419@01)]
(assert (not p2_30@1419@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> above == null && below != null ==> _residue_171 < Level(below)
(push) ; 4
; [then-branch: 2287 | p1_30@1418@01 | dead]
; [else-branch: 2287 | !(p1_30@1418@01) | live]
(push) ; 5
; [else-branch: 2287 | !(p1_30@1418@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null && below_0 != null ==> _residue_171_0 < Level(below_0)
(push) ; 4
; [then-branch: 2288 | p2_30@1419@01 | dead]
; [else-branch: 2288 | !(p2_30@1419@01) | live]
(push) ; 5
; [else-branch: 2288 | !(p2_30@1419@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> above != null && below != null ==> Level(above) < Level(below)
(push) ; 4
; [then-branch: 2289 | p1_30@1418@01 | dead]
; [else-branch: 2289 | !(p1_30@1418@01) | live]
(push) ; 5
; [else-branch: 2289 | !(p1_30@1418@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 != null && below_0 != null ==> Level(above_0) < Level(below_0)
(push) ; 4
; [then-branch: 2290 | p2_30@1419@01 | dead]
; [else-branch: 2290 | !(p2_30@1419@01) | live]
(push) ; 5
; [else-branch: 2290 | !(p2_30@1419@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
; [then-branch: 2291 | p1_30@1418@01 | dead]
; [else-branch: 2291 | !(p1_30@1418@01) | live]
(push) ; 4
; [else-branch: 2291 | !(p1_30@1418@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
; [then-branch: 2292 | p2_30@1419@01 | dead]
; [else-branch: 2292 | !(p2_30@1419@01) | live]
(push) ; 5
; [else-branch: 2292 | !(p2_30@1419@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 && p2_30 ==> Lock_invariant_low(self_4, self_4_0)
; [eval] p1_30 && p2_30
(push) ; 6
; [then-branch: 2293 | !(p1_30@1418@01) | live]
; [else-branch: 2293 | p1_30@1418@01 | live]
(push) ; 7
; [then-branch: 2293 | !(p1_30@1418@01)]
(pop) ; 7
(push) ; 7
; [else-branch: 2293 | p1_30@1418@01]
(assert p1_30@1418@01)
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or p1_30@1418@01 (not p1_30@1418@01)))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (not (and p1_30@1418@01 p2_30@1419@01))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2294 | p1_30@1418@01 && p2_30@1419@01 | dead]
; [else-branch: 2294 | !(p1_30@1418@01 && p2_30@1419@01) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 2294 | !(p1_30@1418@01 && p2_30@1419@01)]
(assert (not (and p1_30@1418@01 p2_30@1419@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (not (and p1_30@1418@01 p2_30@1419@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> true
(push) ; 6
; [then-branch: 2295 | p1_30@1418@01 | dead]
; [else-branch: 2295 | !(p1_30@1418@01) | live]
(push) ; 7
; [else-branch: 2295 | !(p1_30@1418@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> true
(push) ; 6
; [then-branch: 2296 | p2_30@1419@01 | dead]
; [else-branch: 2296 | !(p2_30@1419@01) | live]
(push) ; 7
; [else-branch: 2296 | !(p2_30@1419@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01)))))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p1_30 ==> true
(push) ; 6
; [then-branch: 2297 | p1_30@1418@01 | dead]
; [else-branch: 2297 | !(p1_30@1418@01) | live]
(push) ; 7
; [else-branch: 2297 | !(p1_30@1418@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1436@01))))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] p2_30 ==> true
(push) ; 6
; [then-branch: 2298 | p2_30@1419@01 | dead]
; [else-branch: 2298 | !(p2_30@1419@01) | live]
(push) ; 7
; [else-branch: 2298 | !(p2_30@1419@01)]
(pop) ; 7
(pop) ; 6
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 6
(declare-const $t@1453@01 $Snap)
(assert (= $t@1453@01 ($Snap.combine ($Snap.first $t@1453@01) ($Snap.second $t@1453@01))))
(assert (= ($Snap.first $t@1453@01) $Snap.unit))
; [eval] p1_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBounded] :: Level(_r_53) <= _current_wait_level_171) && ((forperm _r_53: Ref [_r_53.MustReleaseUnbounded] :: Level(_r_53) <= _current_wait_level_171) && _residue_171 <= _current_wait_level_171)
(push) ; 7
; [then-branch: 2299 | p1_30@1418@01 | dead]
; [else-branch: 2299 | !(p1_30@1418@01) | live]
(push) ; 8
; [else-branch: 2299 | !(p1_30@1418@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second $t@1453@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1453@01))
    ($Snap.second ($Snap.second $t@1453@01)))))
(assert (= ($Snap.first ($Snap.second $t@1453@01)) $Snap.unit))
; [eval] p2_30 ==> (forperm _r_53: Ref [_r_53.MustReleaseBoundedp] :: Level(_r_53) <= _current_wait_level_171_0) && ((forperm _r_53: Ref [_r_53.MustReleaseUnboundedp] :: Level(_r_53) <= _current_wait_level_171_0) && _residue_171_0 <= _current_wait_level_171_0)
(push) ; 7
; [then-branch: 2300 | p2_30@1419@01 | dead]
; [else-branch: 2300 | !(p2_30@1419@01) | live]
(push) ; 8
; [else-branch: 2300 | !(p2_30@1419@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1453@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1453@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1453@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1453@01))) $Snap.unit))
; [eval] p1_30 ==> above == null ==> _current_wait_level_171 < Level(self_4)
(push) ; 7
; [then-branch: 2301 | p1_30@1418@01 | dead]
; [else-branch: 2301 | !(p1_30@1418@01) | live]
(push) ; 8
; [else-branch: 2301 | !(p1_30@1418@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1453@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1453@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1453@01))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 == null ==> _current_wait_level_171_0 < Level(self_4_0)
(push) ; 7
; [then-branch: 2302 | p2_30@1419@01 | dead]
; [else-branch: 2302 | !(p2_30@1419@01) | live]
(push) ; 8
; [else-branch: 2302 | !(p2_30@1419@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01)))))
  $Snap.unit))
; [eval] p1_30 ==> above != null ==> Level(above) < Level(self_4)
(push) ; 7
; [then-branch: 2303 | p1_30@1418@01 | dead]
; [else-branch: 2303 | !(p1_30@1418@01) | live]
(push) ; 8
; [else-branch: 2303 | !(p1_30@1418@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01))))))
  $Snap.unit))
; [eval] p2_30 ==> above_0 != null ==> Level(above_0) < Level(self_4_0)
(push) ; 7
; [then-branch: 2304 | p2_30@1419@01 | dead]
; [else-branch: 2304 | !(p2_30@1419@01) | live]
(push) ; 8
; [else-branch: 2304 | !(p2_30@1419@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01)))))))
  $Snap.unit))
; [eval] p1_30 ==> below != null ==> Level(self_4) < Level(below)
(push) ; 7
; [then-branch: 2305 | p1_30@1418@01 | dead]
; [else-branch: 2305 | !(p1_30@1418@01) | live]
(push) ; 8
; [else-branch: 2305 | !(p1_30@1418@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1453@01)))))))
  $Snap.unit))
; [eval] p2_30 ==> below_0 != null ==> Level(self_4_0) < Level(below_0)
(push) ; 7
; [then-branch: 2306 | p2_30@1419@01 | dead]
; [else-branch: 2306 | !(p2_30@1419@01) | live]
(push) ; 8
; [else-branch: 2306 | !(p2_30@1419@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(pop) ; 6
(push) ; 6
; [exec]
; var _cwl_171: Perm
(declare-const _cwl_171@1454@01 $Perm)
; [exec]
; var _cwl_171_0: Perm
(declare-const _cwl_171_0@1455@01 $Perm)
; [exec]
; inhale p1_30
(declare-const $t@1456@01 $Snap)
(assert (= $t@1456@01 $Snap.unit))
(assert p1_30@1418@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 2307 | p1_30@1418@01 | dead]
; [else-branch: 2307 | !(p1_30@1418@01) | live]
(set-option :timeout 0)
(push) ; 7
; [else-branch: 2307 | !(p1_30@1418@01)]
(pop) ; 7
; [eval] !p1_30
; [then-branch: 2308 | !(p1_30@1418@01) | dead]
; [else-branch: 2308 | p1_30@1418@01 | live]
(push) ; 7
; [else-branch: 2308 | p1_30@1418@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- Lock_acquire ----------
(declare-const p1_31@1457@01 Bool)
(declare-const p2_31@1458@01 Bool)
(declare-const _cthread_172@1459@01 $Ref)
(declare-const _cthread_172_0@1460@01 $Ref)
(declare-const _caller_measures_172@1461@01 Seq<Measure$>)
(declare-const _caller_measures_172_0@1462@01 Seq<Measure$>)
(declare-const _residue_172@1463@01 $Perm)
(declare-const _residue_172_0@1464@01 $Perm)
(declare-const self_5@1465@01 $Ref)
(declare-const self_5_0@1466@01 $Ref)
(declare-const _current_wait_level_172@1467@01 $Perm)
(declare-const _current_wait_level_172_0@1468@01 $Perm)
(declare-const p1_31@1469@01 Bool)
(declare-const p2_31@1470@01 Bool)
(declare-const _cthread_172@1471@01 $Ref)
(declare-const _cthread_172_0@1472@01 $Ref)
(declare-const _caller_measures_172@1473@01 Seq<Measure$>)
(declare-const _caller_measures_172_0@1474@01 Seq<Measure$>)
(declare-const _residue_172@1475@01 $Perm)
(declare-const _residue_172_0@1476@01 $Perm)
(declare-const self_5@1477@01 $Ref)
(declare-const self_5_0@1478@01 $Ref)
(declare-const _current_wait_level_172@1479@01 $Perm)
(declare-const _current_wait_level_172_0@1480@01 $Perm)
(push) ; 1
(declare-const $t@1481@01 $Snap)
(assert (= $t@1481@01 ($Snap.combine ($Snap.first $t@1481@01) ($Snap.second $t@1481@01))))
(assert (= ($Snap.first $t@1481@01) $Snap.unit))
; [eval] p1_31 ==> _cthread_172 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_31@1469@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2309 | p1_31@1469@01 | live]
; [else-branch: 2309 | !(p1_31@1469@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2309 | p1_31@1469@01]
(assert p1_31@1469@01)
; [eval] _cthread_172 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2309 | !(p1_31@1469@01)]
(assert (not p1_31@1469@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_31@1469@01) p1_31@1469@01))
(assert (=> p1_31@1469@01 (not (= _cthread_172@1471@01 $Ref.null))))
(assert (=
  ($Snap.second $t@1481@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1481@01))
    ($Snap.second ($Snap.second $t@1481@01)))))
(assert (= ($Snap.first ($Snap.second $t@1481@01)) $Snap.unit))
; [eval] p2_31 ==> _cthread_172_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_31@1470@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2310 | p2_31@1470@01 | live]
; [else-branch: 2310 | !(p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2310 | p2_31@1470@01]
(assert p2_31@1470@01)
; [eval] _cthread_172_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2310 | !(p2_31@1470@01)]
(assert (not p2_31@1470@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_31@1470@01) p2_31@1470@01))
(assert (=> p2_31@1470@01 (not (= _cthread_172_0@1472@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@1481@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1481@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1481@01))) $Snap.unit))
; [eval] p1_31 ==> issubtype(typeof(_cthread_172), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_31@1469@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2311 | p1_31@1469@01 | live]
; [else-branch: 2311 | !(p1_31@1469@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2311 | p1_31@1469@01]
(assert p1_31@1469@01)
; [eval] issubtype(typeof(_cthread_172), Thread_0())
; [eval] typeof(_cthread_172)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2311 | !(p1_31@1469@01)]
(assert (not p1_31@1469@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_31@1469@01
  (issubtype<Bool> (typeof<PyType> _cthread_172@1471@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))
  $Snap.unit))
; [eval] p2_31 ==> issubtype(typeof(_cthread_172_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_31@1470@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2312 | p2_31@1470@01 | live]
; [else-branch: 2312 | !(p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2312 | p2_31@1470@01]
(assert p2_31@1470@01)
; [eval] issubtype(typeof(_cthread_172_0), Thread_0())
; [eval] typeof(_cthread_172_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2312 | !(p2_31@1470@01)]
(assert (not p2_31@1470@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_31@1470@01
  (issubtype<Bool> (typeof<PyType> _cthread_172_0@1472@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))
  $Snap.unit))
; [eval] p1_31 ==> issubtype(typeof(self_5), Lock(Lock_arg(typeof(self_5), 0)))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_31@1469@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2313 | p1_31@1469@01 | live]
; [else-branch: 2313 | !(p1_31@1469@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2313 | p1_31@1469@01]
(assert p1_31@1469@01)
; [eval] issubtype(typeof(self_5), Lock(Lock_arg(typeof(self_5), 0)))
; [eval] typeof(self_5)
; [eval] Lock(Lock_arg(typeof(self_5), 0))
; [eval] Lock_arg(typeof(self_5), 0)
; [eval] typeof(self_5)
(pop) ; 3
(push) ; 3
; [else-branch: 2313 | !(p1_31@1469@01)]
(assert (not p1_31@1469@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_31@1469@01
  (issubtype<Bool> (typeof<PyType> self_5@1477@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> self_5@1477@01) 0)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))
  $Snap.unit))
; [eval] p2_31 ==> issubtype(typeof(self_5_0), Lock(Lock_arg(typeof(self_5_0), 0)))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_31@1470@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2314 | p2_31@1470@01 | live]
; [else-branch: 2314 | !(p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2314 | p2_31@1470@01]
(assert p2_31@1470@01)
; [eval] issubtype(typeof(self_5_0), Lock(Lock_arg(typeof(self_5_0), 0)))
; [eval] typeof(self_5_0)
; [eval] Lock(Lock_arg(typeof(self_5_0), 0))
; [eval] Lock_arg(typeof(self_5_0), 0)
; [eval] typeof(self_5_0)
(pop) ; 3
(push) ; 3
; [else-branch: 2314 | !(p2_31@1470@01)]
(assert (not p2_31@1470@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_31@1470@01
  (issubtype<Bool> (typeof<PyType> self_5_0@1478@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> self_5_0@1478@01) 0)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))
  $Snap.unit))
; [eval] p1_31 ==> issubtype(Lock_arg(typeof(self_5), 0), object())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_31@1469@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2315 | p1_31@1469@01 | live]
; [else-branch: 2315 | !(p1_31@1469@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2315 | p1_31@1469@01]
(assert p1_31@1469@01)
; [eval] issubtype(Lock_arg(typeof(self_5), 0), object())
; [eval] Lock_arg(typeof(self_5), 0)
; [eval] typeof(self_5)
; [eval] object()
(pop) ; 3
(push) ; 3
; [else-branch: 2315 | !(p1_31@1469@01)]
(assert (not p1_31@1469@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_31@1469@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> self_5@1477@01) 0) (as object<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))
  $Snap.unit))
; [eval] p2_31 ==> issubtype(Lock_arg(typeof(self_5_0), 0), object())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_31@1470@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2316 | p2_31@1470@01 | live]
; [else-branch: 2316 | !(p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2316 | p2_31@1470@01]
(assert p2_31@1470@01)
; [eval] issubtype(Lock_arg(typeof(self_5_0), 0), object())
; [eval] Lock_arg(typeof(self_5_0), 0)
; [eval] typeof(self_5_0)
; [eval] object()
(pop) ; 3
(push) ; 3
; [else-branch: 2316 | !(p2_31@1470@01)]
(assert (not p2_31@1470@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_31@1470@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> self_5_0@1478@01) 0) (as object<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))
  $Snap.unit))
; [eval] p1_31 ==> self_5 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_31@1469@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2317 | p1_31@1469@01 | live]
; [else-branch: 2317 | !(p1_31@1469@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2317 | p1_31@1469@01]
(assert p1_31@1469@01)
; [eval] self_5 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2317 | !(p1_31@1469@01)]
(assert (not p1_31@1469@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p1_31@1469@01 (not (= self_5@1477@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))
  $Snap.unit))
; [eval] p2_31 ==> self_5_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_31@1470@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2318 | p2_31@1470@01 | live]
; [else-branch: 2318 | !(p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2318 | p2_31@1470@01]
(assert p2_31@1470@01)
; [eval] self_5_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2318 | !(p2_31@1470@01)]
(assert (not p2_31@1470@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p2_31@1470@01 (not (= self_5_0@1478@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
(push) ; 2
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 2
(set-option :timeout 10)
(assert (not p1_31@1469@01))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2319 | p1_31@1469@01 | live]
; [else-branch: 2319 | !(p1_31@1469@01) | live]
(set-option :timeout 0)
(push) ; 2
; [then-branch: 2319 | p1_31@1469@01]
(assert p1_31@1469@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_31@1470@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2320 | p2_31@1470@01 | live]
; [else-branch: 2320 | !(p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2320 | p2_31@1470@01]
(assert p2_31@1470@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> _residue_172 < Level(self_5)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2321 | p1_31@1469@01 | live]
; [else-branch: 2321 | !(p1_31@1469@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2321 | p1_31@1469@01]
; [eval] _residue_172 < Level(self_5)
; [eval] Level(self_5)
(push) ; 6
(assert (Level%precondition $Snap.unit self_5@1477@01))
(pop) ; 6
; Joined path conditions
(assert (Level%precondition $Snap.unit self_5@1477@01))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=> p1_31@1469@01 (Level%precondition $Snap.unit self_5@1477@01)))
(assert (=> p1_31@1469@01 (< _residue_172@1475@01 (Level $Snap.unit self_5@1477@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> _residue_172_0 < Level(self_5_0)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2322 | p2_31@1470@01 | live]
; [else-branch: 2322 | !(p2_31@1470@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2322 | p2_31@1470@01]
; [eval] _residue_172_0 < Level(self_5_0)
; [eval] Level(self_5_0)
(push) ; 6
(assert (Level%precondition $Snap.unit self_5_0@1478@01))
(pop) ; 6
; Joined path conditions
(assert (Level%precondition $Snap.unit self_5_0@1478@01))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=> p2_31@1470@01 (Level%precondition $Snap.unit self_5_0@1478@01)))
(assert (=> p2_31@1470@01 (< _residue_172_0@1476@01 (Level $Snap.unit self_5_0@1478@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
  $Snap.unit))
; [eval] p1_31 && p2_31 ==> self_5 == self_5_0
; [eval] p1_31 && p2_31
(push) ; 4
; [then-branch: 2323 | !(p1_31@1469@01) | live]
; [else-branch: 2323 | p1_31@1469@01 | live]
(push) ; 5
; [then-branch: 2323 | !(p1_31@1469@01)]
(assert (not p1_31@1469@01))
(pop) ; 5
(push) ; 5
; [else-branch: 2323 | p1_31@1469@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or p1_31@1469@01 (not p1_31@1469@01)))
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not (and p1_31@1469@01 p2_31@1470@01))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (and p1_31@1469@01 p2_31@1470@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2324 | p1_31@1469@01 && p2_31@1470@01 | live]
; [else-branch: 2324 | !(p1_31@1469@01 && p2_31@1470@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2324 | p1_31@1469@01 && p2_31@1470@01]
(assert (and p1_31@1469@01 p2_31@1470@01))
; [eval] self_5 == self_5_0
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (and p1_31@1469@01 p2_31@1470@01))
(assert (=> (and p1_31@1469@01 p2_31@1470@01) (= self_5@1477@01 self_5_0@1478@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
  $Snap.unit))
; [eval] p1_31 == p2_31
(assert (= p1_31@1469@01 p2_31@1470@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> typeof(self_5) == typeof(self_5_0)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2325 | p1_31@1469@01 | live]
; [else-branch: 2325 | !(p1_31@1469@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2325 | p1_31@1469@01]
; [eval] typeof(self_5) == typeof(self_5_0)
; [eval] typeof(self_5)
; [eval] typeof(self_5_0)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p1_31@1469@01
  (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2326 | p1_31@1469@01 | live]
; [else-branch: 2326 | !(p1_31@1469@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2326 | p1_31@1469@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2327 | p2_31@1470@01 | live]
; [else-branch: 2327 | !(p2_31@1470@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2327 | p2_31@1470@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2328 | p1_31@1469@01 | live]
; [else-branch: 2328 | !(p1_31@1469@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2328 | p1_31@1469@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2329 | p2_31@1470@01 | live]
; [else-branch: 2329 | !(p2_31@1470@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2329 | p2_31@1470@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(declare-const $t@1482@01 $Snap)
(assert (= $t@1482@01 ($Snap.combine ($Snap.first $t@1482@01) ($Snap.second $t@1482@01))))
(assert (= ($Snap.first $t@1482@01) $Snap.unit))
; [eval] p1_31 ==> (forperm _r_56: Ref [_r_56.MustReleaseBounded] :: Level(_r_56) <= _current_wait_level_172) && ((forperm _r_56: Ref [_r_56.MustReleaseUnbounded] :: Level(_r_56) <= _current_wait_level_172) && _residue_172 <= _current_wait_level_172)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2330 | p1_31@1469@01 | live]
; [else-branch: 2330 | !(p1_31@1469@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2330 | p1_31@1469@01]
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseBounded] :: Level(_r_56) <= _current_wait_level_172) && ((forperm _r_56: Ref [_r_56.MustReleaseUnbounded] :: Level(_r_56) <= _current_wait_level_172) && _residue_172 <= _current_wait_level_172)
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseBounded] :: Level(_r_56) <= _current_wait_level_172)
(push) ; 7
; [then-branch: 2331 | False | live]
; [else-branch: 2331 | True | live]
(push) ; 8
; [then-branch: 2331 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 2331 | True]
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseUnbounded] :: Level(_r_56) <= _current_wait_level_172)
(push) ; 9
; [then-branch: 2332 | False | live]
; [else-branch: 2332 | True | live]
(push) ; 10
; [then-branch: 2332 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 2332 | True]
; [eval] _residue_172 <= _current_wait_level_172
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=> p1_31@1469@01 (<= _residue_172@1475@01 _current_wait_level_172@1479@01)))
(assert (=
  ($Snap.second $t@1482@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1482@01))
    ($Snap.second ($Snap.second $t@1482@01)))))
(assert (= ($Snap.first ($Snap.second $t@1482@01)) $Snap.unit))
; [eval] p2_31 ==> (forperm _r_56: Ref [_r_56.MustReleaseBoundedp] :: Level(_r_56) <= _current_wait_level_172_0) && ((forperm _r_56: Ref [_r_56.MustReleaseUnboundedp] :: Level(_r_56) <= _current_wait_level_172_0) && _residue_172_0 <= _current_wait_level_172_0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2333 | p2_31@1470@01 | live]
; [else-branch: 2333 | !(p2_31@1470@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2333 | p2_31@1470@01]
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseBoundedp] :: Level(_r_56) <= _current_wait_level_172_0) && ((forperm _r_56: Ref [_r_56.MustReleaseUnboundedp] :: Level(_r_56) <= _current_wait_level_172_0) && _residue_172_0 <= _current_wait_level_172_0)
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseBoundedp] :: Level(_r_56) <= _current_wait_level_172_0)
(push) ; 7
; [then-branch: 2334 | False | live]
; [else-branch: 2334 | True | live]
(push) ; 8
; [then-branch: 2334 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 2334 | True]
; [eval] (forperm _r_56: Ref [_r_56.MustReleaseUnboundedp] :: Level(_r_56) <= _current_wait_level_172_0)
(push) ; 9
; [then-branch: 2335 | False | live]
; [else-branch: 2335 | True | live]
(push) ; 10
; [then-branch: 2335 | False]
(assert false)
(pop) ; 10
(push) ; 10
; [else-branch: 2335 | True]
; [eval] _residue_172_0 <= _current_wait_level_172_0
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=> p2_31@1470@01 (<= _residue_172_0@1476@01 _current_wait_level_172_0@1480@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1482@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1482@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1482@01))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2336 | p1_31@1469@01 | live]
; [else-branch: 2336 | !(p1_31@1469@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2336 | p1_31@1469@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1482@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1482@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1482@01)))))))
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2337 | p2_31@1470@01 | live]
; [else-branch: 2337 | !(p2_31@1470@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2337 | p2_31@1470@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1482@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1482@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1482@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1482@01)))))
  $Snap.unit))
; [eval] typeof(self_5) == typeof(self_5_0) ==> p1_31 && p2_31 ==> Lock_invariant_low(self_5, self_5_0)
; [eval] typeof(self_5) == typeof(self_5_0)
; [eval] typeof(self_5)
; [eval] typeof(self_5_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01)))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2338 | typeof[PyType](self_5@1477@01) == typeof[PyType](self_5_0@1478@01) | live]
; [else-branch: 2338 | typeof[PyType](self_5@1477@01) != typeof[PyType](self_5_0@1478@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2338 | typeof[PyType](self_5@1477@01) == typeof[PyType](self_5_0@1478@01)]
(assert (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01)))
; [eval] p1_31 && p2_31 ==> Lock_invariant_low(self_5, self_5_0)
; [eval] p1_31 && p2_31
(push) ; 9
; [then-branch: 2339 | !(p1_31@1469@01) | live]
; [else-branch: 2339 | p1_31@1469@01 | live]
(push) ; 10
; [then-branch: 2339 | !(p1_31@1469@01)]
(assert (not p1_31@1469@01))
(pop) ; 10
(push) ; 10
; [else-branch: 2339 | p1_31@1469@01]
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not (and p1_31@1469@01 p2_31@1470@01))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (and p1_31@1469@01 p2_31@1470@01)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2340 | p1_31@1469@01 && p2_31@1470@01 | live]
; [else-branch: 2340 | !(p1_31@1469@01 && p2_31@1470@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2340 | p1_31@1469@01 && p2_31@1470@01]
(assert (and p1_31@1469@01 p2_31@1470@01))
; [eval] Lock_invariant_low(self_5, self_5_0)
(push) ; 11
(declare-const $k@1483@01 $Perm)
(assert ($Perm.isReadVar $k@1483@01))
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No $k@1483@01)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(declare-const $k@1484@01 $Perm)
(assert ($Perm.isReadVar $k@1484@01))
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No $k@1484@01)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second $t@1482@01)))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1482@01))))) self_5@1477@01 self_5_0@1478@01))
(pop) ; 11
; Joined path conditions
(assert ($Perm.isReadVar $k@1483@01))
(assert ($Perm.isReadVar $k@1484@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second $t@1482@01)))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1482@01))))) self_5@1477@01 self_5_0@1478@01))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert ($Perm.isReadVar $k@1483@01))
(assert ($Perm.isReadVar $k@1484@01))
(assert (=>
  (and p1_31@1469@01 p2_31@1470@01)
  (and
    p1_31@1469@01
    p2_31@1470@01
    (Lock_invariant_low%precondition ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second $t@1482@01)))
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1482@01))))) self_5@1477@01 self_5_0@1478@01))))
(assert (and p1_31@1469@01 p2_31@1470@01))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert ($Perm.isReadVar $k@1483@01))
(assert ($Perm.isReadVar $k@1484@01))
(assert (=>
  (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))
  (and
    (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))
    (=>
      (and p1_31@1469@01 p2_31@1470@01)
      (and
        p1_31@1469@01
        p2_31@1470@01
        (Lock_invariant_low%precondition ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second $t@1482@01)))
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1482@01))))) self_5@1477@01 self_5_0@1478@01)))
    p1_31@1469@01
    p2_31@1470@01)))
(assert (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01)))
(assert (=>
  (and
    (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))
    (and p1_31@1469@01 p2_31@1470@01))
  (Lock_invariant_low ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1482@01)))
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1482@01))))) self_5@1477@01 self_5_0@1478@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1482@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1482@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1482@01)))))))))
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not p1_31@1469@01))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2341 | p1_31@1469@01 | live]
; [else-branch: 2341 | !(p1_31@1469@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2341 | p1_31@1469@01]
(assert p1_31@1469@01)
(assert (not (= self_5@1477@01 $Ref.null)))
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not p2_31@1470@01))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2342 | p2_31@1470@01 | live]
; [else-branch: 2342 | !(p2_31@1470@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2342 | p2_31@1470@01]
(assert p2_31@1470@01)
(assert (not (= self_5_0@1478@01 $Ref.null)))
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(push) ; 4
; [exec]
; var _cwl_172: Perm
(declare-const _cwl_172@1485@01 $Perm)
; [exec]
; var _cwl_172_0: Perm
(declare-const _cwl_172_0@1486@01 $Perm)
; [exec]
; inhale p1_31
(declare-const $t@1487@01 $Snap)
(assert (= $t@1487@01 $Snap.unit))
(assert p1_31@1469@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2343 | p1_31@1469@01 | live]
; [else-branch: 2343 | !(p1_31@1469@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2343 | p1_31@1469@01]
; [exec]
; inhale typeof(self_5) == Lock(Lock_arg(typeof(self_5), 0))
(declare-const $t@1488@01 $Snap)
(assert (= $t@1488@01 $Snap.unit))
; [eval] typeof(self_5) == Lock(Lock_arg(typeof(self_5), 0))
; [eval] typeof(self_5)
; [eval] Lock(Lock_arg(typeof(self_5), 0))
; [eval] Lock_arg(typeof(self_5), 0)
; [eval] typeof(self_5)
(assert (=
  (typeof<PyType> self_5@1477@01)
  (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> self_5@1477@01) 0))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale false
(pop) ; 5
; [eval] !p1_31
; [then-branch: 2344 | !(p1_31@1469@01) | dead]
; [else-branch: 2344 | p1_31@1469@01 | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2344 | p1_31@1469@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 2320 | !(p2_31@1470@01)]
(assert (not p2_31@1470@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> _residue_172 < Level(self_5)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not p1_31@1469@01))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2345 | p1_31@1469@01 | live]
; [else-branch: 2345 | !(p1_31@1469@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2345 | p1_31@1469@01]
(assert p1_31@1469@01)
; [eval] _residue_172 < Level(self_5)
; [eval] Level(self_5)
(push) ; 6
(assert (Level%precondition $Snap.unit self_5@1477@01))
(pop) ; 6
; Joined path conditions
(assert (Level%precondition $Snap.unit self_5@1477@01))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  p1_31@1469@01
  (and p1_31@1469@01 (Level%precondition $Snap.unit self_5@1477@01))))
(assert p1_31@1469@01)
(assert (=> p1_31@1469@01 (< _residue_172@1475@01 (Level $Snap.unit self_5@1477@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> _residue_172_0 < Level(self_5_0)
(push) ; 4
; [then-branch: 2346 | p2_31@1470@01 | dead]
; [else-branch: 2346 | !(p2_31@1470@01) | live]
(push) ; 5
; [else-branch: 2346 | !(p2_31@1470@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
  $Snap.unit))
; [eval] p1_31 && p2_31 ==> self_5 == self_5_0
; [eval] p1_31 && p2_31
(push) ; 4
; [then-branch: 2347 | !(p1_31@1469@01) | live]
; [else-branch: 2347 | p1_31@1469@01 | live]
(push) ; 5
; [then-branch: 2347 | !(p1_31@1469@01)]
(assert (not p1_31@1469@01))
(pop) ; 5
(push) ; 5
; [else-branch: 2347 | p1_31@1469@01]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or p1_31@1469@01 (not p1_31@1469@01)))
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not (and p1_31@1469@01 p2_31@1470@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2348 | p1_31@1469@01 && p2_31@1470@01 | dead]
; [else-branch: 2348 | !(p1_31@1469@01 && p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2348 | !(p1_31@1469@01 && p2_31@1470@01)]
(assert (not (and p1_31@1469@01 p2_31@1470@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (not (and p1_31@1469@01 p2_31@1470@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
  $Snap.unit))
; [eval] p1_31 == p2_31
(assert (= p1_31@1469@01 p2_31@1470@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> typeof(self_5) == typeof(self_5_0)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_31@1469@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2349 | p1_31@1469@01 | dead]
; [else-branch: 2349 | !(p1_31@1469@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2349 | !(p1_31@1469@01)]
(assert (not p1_31@1469@01))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (not p1_31@1469@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> true
(push) ; 4
; [then-branch: 2350 | p1_31@1469@01 | dead]
; [else-branch: 2350 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2350 | !(p1_31@1469@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> true
(push) ; 4
; [then-branch: 2351 | p2_31@1470@01 | dead]
; [else-branch: 2351 | !(p2_31@1470@01) | live]
(push) ; 5
; [else-branch: 2351 | !(p2_31@1470@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> true
(push) ; 4
; [then-branch: 2352 | p1_31@1469@01 | dead]
; [else-branch: 2352 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2352 | !(p1_31@1469@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> true
(push) ; 4
; [then-branch: 2353 | p2_31@1470@01 | dead]
; [else-branch: 2353 | !(p2_31@1470@01) | live]
(push) ; 5
; [else-branch: 2353 | !(p2_31@1470@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unsat
(set-option :timeout 0)
(push) ; 4
(declare-const $t@1489@01 $Snap)
(assert (= $t@1489@01 ($Snap.combine ($Snap.first $t@1489@01) ($Snap.second $t@1489@01))))
(assert (= ($Snap.first $t@1489@01) $Snap.unit))
; [eval] p1_31 ==> (forperm _r_56: Ref [_r_56.MustReleaseBounded] :: Level(_r_56) <= _current_wait_level_172) && ((forperm _r_56: Ref [_r_56.MustReleaseUnbounded] :: Level(_r_56) <= _current_wait_level_172) && _residue_172 <= _current_wait_level_172)
(push) ; 5
; [then-branch: 2354 | p1_31@1469@01 | dead]
; [else-branch: 2354 | !(p1_31@1469@01) | live]
(push) ; 6
; [else-branch: 2354 | !(p1_31@1469@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second $t@1489@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1489@01))
    ($Snap.second ($Snap.second $t@1489@01)))))
(assert (= ($Snap.first ($Snap.second $t@1489@01)) $Snap.unit))
; [eval] p2_31 ==> (forperm _r_56: Ref [_r_56.MustReleaseBoundedp] :: Level(_r_56) <= _current_wait_level_172_0) && ((forperm _r_56: Ref [_r_56.MustReleaseUnboundedp] :: Level(_r_56) <= _current_wait_level_172_0) && _residue_172_0 <= _current_wait_level_172_0)
(push) ; 5
; [then-branch: 2355 | p2_31@1470@01 | dead]
; [else-branch: 2355 | !(p2_31@1470@01) | live]
(push) ; 6
; [else-branch: 2355 | !(p2_31@1470@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1489@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1489@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1489@01))))))
; [then-branch: 2356 | p1_31@1469@01 | dead]
; [else-branch: 2356 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2356 | !(p1_31@1469@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1489@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1489@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1489@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1489@01)))))))
; [then-branch: 2357 | p2_31@1470@01 | dead]
; [else-branch: 2357 | !(p2_31@1470@01) | live]
(push) ; 6
; [else-branch: 2357 | !(p2_31@1470@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1489@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1489@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1489@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1489@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1489@01)))))
  $Snap.unit))
; [eval] typeof(self_5) == typeof(self_5_0) ==> p1_31 && p2_31 ==> Lock_invariant_low(self_5, self_5_0)
; [eval] typeof(self_5) == typeof(self_5_0)
; [eval] typeof(self_5)
; [eval] typeof(self_5_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2358 | typeof[PyType](self_5@1477@01) == typeof[PyType](self_5_0@1478@01) | dead]
; [else-branch: 2358 | typeof[PyType](self_5@1477@01) != typeof[PyType](self_5_0@1478@01) | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 2358 | typeof[PyType](self_5@1477@01) != typeof[PyType](self_5_0@1478@01)]
(assert (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1489@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1489@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1489@01)))))))))
; [then-branch: 2359 | p1_31@1469@01 | dead]
; [else-branch: 2359 | !(p1_31@1469@01) | live]
(push) ; 7
; [else-branch: 2359 | !(p1_31@1469@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1489@01))))))
  $Snap.unit))
; [then-branch: 2360 | p2_31@1470@01 | dead]
; [else-branch: 2360 | !(p2_31@1470@01) | live]
(push) ; 8
; [else-branch: 2360 | !(p2_31@1470@01)]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1489@01))))))
  $Snap.unit))
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(push) ; 4
; [exec]
; var _cwl_172: Perm
(declare-const _cwl_172@1490@01 $Perm)
; [exec]
; var _cwl_172_0: Perm
(declare-const _cwl_172_0@1491@01 $Perm)
; [exec]
; inhale p1_31
(declare-const $t@1492@01 $Snap)
(assert (= $t@1492@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 2361 | p1_31@1469@01 | dead]
; [else-branch: 2361 | !(p1_31@1469@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2361 | !(p1_31@1469@01)]
(pop) ; 5
; [eval] !p1_31
; [then-branch: 2362 | !(p1_31@1469@01) | dead]
; [else-branch: 2362 | p1_31@1469@01 | live]
(push) ; 5
; [else-branch: 2362 | p1_31@1469@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [else-branch: 2319 | !(p1_31@1469@01)]
(assert (not p1_31@1469@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_31@1470@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2363 | p2_31@1470@01 | live]
; [else-branch: 2363 | !(p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2363 | p2_31@1470@01]
(assert p2_31@1470@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> _residue_172 < Level(self_5)
(push) ; 4
; [then-branch: 2364 | p1_31@1469@01 | dead]
; [else-branch: 2364 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2364 | !(p1_31@1469@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> _residue_172_0 < Level(self_5_0)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2365 | p2_31@1470@01 | live]
; [else-branch: 2365 | !(p2_31@1470@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2365 | p2_31@1470@01]
; [eval] _residue_172_0 < Level(self_5_0)
; [eval] Level(self_5_0)
(push) ; 6
(assert (Level%precondition $Snap.unit self_5_0@1478@01))
(pop) ; 6
; Joined path conditions
(assert (Level%precondition $Snap.unit self_5_0@1478@01))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=> p2_31@1470@01 (Level%precondition $Snap.unit self_5_0@1478@01)))
(assert (=> p2_31@1470@01 (< _residue_172_0@1476@01 (Level $Snap.unit self_5_0@1478@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
  $Snap.unit))
; [eval] p1_31 && p2_31 ==> self_5 == self_5_0
; [eval] p1_31 && p2_31
(push) ; 4
; [then-branch: 2366 | !(p1_31@1469@01) | live]
; [else-branch: 2366 | p1_31@1469@01 | live]
(push) ; 5
; [then-branch: 2366 | !(p1_31@1469@01)]
(pop) ; 5
(push) ; 5
; [else-branch: 2366 | p1_31@1469@01]
(assert p1_31@1469@01)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or p1_31@1469@01 (not p1_31@1469@01)))
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not (and p1_31@1469@01 p2_31@1470@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2367 | p1_31@1469@01 && p2_31@1470@01 | dead]
; [else-branch: 2367 | !(p1_31@1469@01 && p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2367 | !(p1_31@1469@01 && p2_31@1470@01)]
(assert (not (and p1_31@1469@01 p2_31@1470@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (not (and p1_31@1469@01 p2_31@1470@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
  $Snap.unit))
; [eval] p1_31 == p2_31
(assert (= p1_31@1469@01 p2_31@1470@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> typeof(self_5) == typeof(self_5_0)
(push) ; 4
; [then-branch: 2368 | p1_31@1469@01 | dead]
; [else-branch: 2368 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2368 | !(p1_31@1469@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> true
(push) ; 4
; [then-branch: 2369 | p1_31@1469@01 | dead]
; [else-branch: 2369 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2369 | !(p1_31@1469@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> true
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_31@1470@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2370 | p2_31@1470@01 | dead]
; [else-branch: 2370 | !(p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2370 | !(p2_31@1470@01)]
(assert (not p2_31@1470@01))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (not p2_31@1470@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> true
(push) ; 4
; [then-branch: 2371 | p1_31@1469@01 | dead]
; [else-branch: 2371 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2371 | !(p1_31@1469@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> true
(push) ; 4
; [then-branch: 2372 | p2_31@1470@01 | dead]
; [else-branch: 2372 | !(p2_31@1470@01) | live]
(push) ; 5
; [else-branch: 2372 | !(p2_31@1470@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unsat
(set-option :timeout 0)
(push) ; 4
(declare-const $t@1493@01 $Snap)
(assert (= $t@1493@01 ($Snap.combine ($Snap.first $t@1493@01) ($Snap.second $t@1493@01))))
(assert (= ($Snap.first $t@1493@01) $Snap.unit))
; [eval] p1_31 ==> (forperm _r_56: Ref [_r_56.MustReleaseBounded] :: Level(_r_56) <= _current_wait_level_172) && ((forperm _r_56: Ref [_r_56.MustReleaseUnbounded] :: Level(_r_56) <= _current_wait_level_172) && _residue_172 <= _current_wait_level_172)
(push) ; 5
; [then-branch: 2373 | p1_31@1469@01 | dead]
; [else-branch: 2373 | !(p1_31@1469@01) | live]
(push) ; 6
; [else-branch: 2373 | !(p1_31@1469@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second $t@1493@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1493@01))
    ($Snap.second ($Snap.second $t@1493@01)))))
(assert (= ($Snap.first ($Snap.second $t@1493@01)) $Snap.unit))
; [eval] p2_31 ==> (forperm _r_56: Ref [_r_56.MustReleaseBoundedp] :: Level(_r_56) <= _current_wait_level_172_0) && ((forperm _r_56: Ref [_r_56.MustReleaseUnboundedp] :: Level(_r_56) <= _current_wait_level_172_0) && _residue_172_0 <= _current_wait_level_172_0)
(push) ; 5
; [then-branch: 2374 | p2_31@1470@01 | dead]
; [else-branch: 2374 | !(p2_31@1470@01) | live]
(push) ; 6
; [else-branch: 2374 | !(p2_31@1470@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1493@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1493@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1493@01))))))
; [then-branch: 2375 | p1_31@1469@01 | dead]
; [else-branch: 2375 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2375 | !(p1_31@1469@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1493@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1493@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1493@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1493@01)))))))
; [then-branch: 2376 | p2_31@1470@01 | dead]
; [else-branch: 2376 | !(p2_31@1470@01) | live]
(push) ; 6
; [else-branch: 2376 | !(p2_31@1470@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1493@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1493@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1493@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1493@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1493@01)))))
  $Snap.unit))
; [eval] typeof(self_5) == typeof(self_5_0) ==> p1_31 && p2_31 ==> Lock_invariant_low(self_5, self_5_0)
; [eval] typeof(self_5) == typeof(self_5_0)
; [eval] typeof(self_5)
; [eval] typeof(self_5_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2377 | typeof[PyType](self_5@1477@01) == typeof[PyType](self_5_0@1478@01) | dead]
; [else-branch: 2377 | typeof[PyType](self_5@1477@01) != typeof[PyType](self_5_0@1478@01) | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 2377 | typeof[PyType](self_5@1477@01) != typeof[PyType](self_5_0@1478@01)]
(assert (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1493@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1493@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1493@01)))))))))
; [then-branch: 2378 | p1_31@1469@01 | dead]
; [else-branch: 2378 | !(p1_31@1469@01) | live]
(push) ; 7
; [else-branch: 2378 | !(p1_31@1469@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1493@01))))))
  $Snap.unit))
; [then-branch: 2379 | p2_31@1470@01 | dead]
; [else-branch: 2379 | !(p2_31@1470@01) | live]
(push) ; 8
; [else-branch: 2379 | !(p2_31@1470@01)]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1493@01))))))
  $Snap.unit))
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(push) ; 4
; [exec]
; var _cwl_172: Perm
(declare-const _cwl_172@1494@01 $Perm)
; [exec]
; var _cwl_172_0: Perm
(declare-const _cwl_172_0@1495@01 $Perm)
; [exec]
; inhale p1_31
(declare-const $t@1496@01 $Snap)
(assert (= $t@1496@01 $Snap.unit))
(assert p1_31@1469@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 2380 | p1_31@1469@01 | dead]
; [else-branch: 2380 | !(p1_31@1469@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2380 | !(p1_31@1469@01)]
(pop) ; 5
; [eval] !p1_31
; [then-branch: 2381 | !(p1_31@1469@01) | dead]
; [else-branch: 2381 | p1_31@1469@01 | live]
(push) ; 5
; [else-branch: 2381 | p1_31@1469@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 2363 | !(p2_31@1470@01)]
(assert (not p2_31@1470@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> _residue_172 < Level(self_5)
(push) ; 4
; [then-branch: 2382 | p1_31@1469@01 | dead]
; [else-branch: 2382 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2382 | !(p1_31@1469@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> _residue_172_0 < Level(self_5_0)
(push) ; 4
; [then-branch: 2383 | p2_31@1470@01 | dead]
; [else-branch: 2383 | !(p2_31@1470@01) | live]
(push) ; 5
; [else-branch: 2383 | !(p2_31@1470@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
  $Snap.unit))
; [eval] p1_31 && p2_31 ==> self_5 == self_5_0
; [eval] p1_31 && p2_31
(push) ; 4
; [then-branch: 2384 | !(p1_31@1469@01) | live]
; [else-branch: 2384 | p1_31@1469@01 | live]
(push) ; 5
; [then-branch: 2384 | !(p1_31@1469@01)]
(pop) ; 5
(push) ; 5
; [else-branch: 2384 | p1_31@1469@01]
(assert p1_31@1469@01)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or p1_31@1469@01 (not p1_31@1469@01)))
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not (not (and p1_31@1469@01 p2_31@1470@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2385 | p1_31@1469@01 && p2_31@1470@01 | dead]
; [else-branch: 2385 | !(p1_31@1469@01 && p2_31@1470@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2385 | !(p1_31@1469@01 && p2_31@1470@01)]
(assert (not (and p1_31@1469@01 p2_31@1470@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (not (and p1_31@1469@01 p2_31@1470@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
  $Snap.unit))
; [eval] p1_31 == p2_31
(assert (= p1_31@1469@01 p2_31@1470@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> typeof(self_5) == typeof(self_5_0)
(push) ; 4
; [then-branch: 2386 | p1_31@1469@01 | dead]
; [else-branch: 2386 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2386 | !(p1_31@1469@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> true
(push) ; 4
; [then-branch: 2387 | p1_31@1469@01 | dead]
; [else-branch: 2387 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2387 | !(p1_31@1469@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> true
(push) ; 4
; [then-branch: 2388 | p2_31@1470@01 | dead]
; [else-branch: 2388 | !(p2_31@1470@01) | live]
(push) ; 5
; [else-branch: 2388 | !(p2_31@1470@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
  $Snap.unit))
; [eval] p1_31 ==> true
(push) ; 4
; [then-branch: 2389 | p1_31@1469@01 | dead]
; [else-branch: 2389 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2389 | !(p1_31@1469@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1481@01))))))))))))))))))))
  $Snap.unit))
; [eval] p2_31 ==> true
(push) ; 4
; [then-branch: 2390 | p2_31@1470@01 | dead]
; [else-branch: 2390 | !(p2_31@1470@01) | live]
(push) ; 5
; [else-branch: 2390 | !(p2_31@1470@01)]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 4
(declare-const $t@1497@01 $Snap)
(assert (= $t@1497@01 ($Snap.combine ($Snap.first $t@1497@01) ($Snap.second $t@1497@01))))
(assert (= ($Snap.first $t@1497@01) $Snap.unit))
; [eval] p1_31 ==> (forperm _r_56: Ref [_r_56.MustReleaseBounded] :: Level(_r_56) <= _current_wait_level_172) && ((forperm _r_56: Ref [_r_56.MustReleaseUnbounded] :: Level(_r_56) <= _current_wait_level_172) && _residue_172 <= _current_wait_level_172)
(push) ; 5
; [then-branch: 2391 | p1_31@1469@01 | dead]
; [else-branch: 2391 | !(p1_31@1469@01) | live]
(push) ; 6
; [else-branch: 2391 | !(p1_31@1469@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second $t@1497@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1497@01))
    ($Snap.second ($Snap.second $t@1497@01)))))
(assert (= ($Snap.first ($Snap.second $t@1497@01)) $Snap.unit))
; [eval] p2_31 ==> (forperm _r_56: Ref [_r_56.MustReleaseBoundedp] :: Level(_r_56) <= _current_wait_level_172_0) && ((forperm _r_56: Ref [_r_56.MustReleaseUnboundedp] :: Level(_r_56) <= _current_wait_level_172_0) && _residue_172_0 <= _current_wait_level_172_0)
(push) ; 5
; [then-branch: 2392 | p2_31@1470@01 | dead]
; [else-branch: 2392 | !(p2_31@1470@01) | live]
(push) ; 6
; [else-branch: 2392 | !(p2_31@1470@01)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@1497@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1497@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1497@01))))))
; [then-branch: 2393 | p1_31@1469@01 | dead]
; [else-branch: 2393 | !(p1_31@1469@01) | live]
(push) ; 5
; [else-branch: 2393 | !(p1_31@1469@01)]
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1497@01))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1497@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1497@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1497@01)))))))
; [then-branch: 2394 | p2_31@1470@01 | dead]
; [else-branch: 2394 | !(p2_31@1470@01) | live]
(push) ; 6
; [else-branch: 2394 | !(p2_31@1470@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1497@01))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1497@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1497@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1497@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1497@01)))))
  $Snap.unit))
; [eval] typeof(self_5) == typeof(self_5_0) ==> p1_31 && p2_31 ==> Lock_invariant_low(self_5, self_5_0)
; [eval] typeof(self_5) == typeof(self_5_0)
; [eval] typeof(self_5)
; [eval] typeof(self_5_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01)))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2395 | typeof[PyType](self_5@1477@01) == typeof[PyType](self_5_0@1478@01) | live]
; [else-branch: 2395 | typeof[PyType](self_5@1477@01) != typeof[PyType](self_5_0@1478@01) | live]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2395 | typeof[PyType](self_5@1477@01) == typeof[PyType](self_5_0@1478@01)]
(assert (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01)))
; [eval] p1_31 && p2_31 ==> Lock_invariant_low(self_5, self_5_0)
; [eval] p1_31 && p2_31
(push) ; 9
; [then-branch: 2396 | !(p1_31@1469@01) | live]
; [else-branch: 2396 | p1_31@1469@01 | live]
(push) ; 10
; [then-branch: 2396 | !(p1_31@1469@01)]
(pop) ; 10
(push) ; 10
; [else-branch: 2396 | p1_31@1469@01]
(assert p1_31@1469@01)
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 2397 | p1_31@1469@01 && p2_31@1470@01 | dead]
; [else-branch: 2397 | !(p1_31@1469@01 && p2_31@1470@01) | live]
(push) ; 10
; [else-branch: 2397 | !(p1_31@1469@01 && p2_31@1470@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 2395 | typeof[PyType](self_5@1477@01) != typeof[PyType](self_5_0@1478@01)]
(assert (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (not (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01)))
  (= (typeof<PyType> self_5@1477@01) (typeof<PyType> self_5_0@1478@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1497@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1497@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1497@01)))))))))
; [then-branch: 2398 | p1_31@1469@01 | dead]
; [else-branch: 2398 | !(p1_31@1469@01) | live]
(push) ; 7
; [else-branch: 2398 | !(p1_31@1469@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1497@01))))))
  $Snap.unit))
; [then-branch: 2399 | p2_31@1470@01 | dead]
; [else-branch: 2399 | !(p2_31@1470@01) | live]
(push) ; 8
; [else-branch: 2399 | !(p2_31@1470@01)]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1497@01))))))
  $Snap.unit))
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(push) ; 4
; [exec]
; var _cwl_172: Perm
(declare-const _cwl_172@1498@01 $Perm)
; [exec]
; var _cwl_172_0: Perm
(declare-const _cwl_172_0@1499@01 $Perm)
; [exec]
; inhale p1_31
(declare-const $t@1500@01 $Snap)
(assert (= $t@1500@01 $Snap.unit))
(assert p1_31@1469@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 2400 | p1_31@1469@01 | dead]
; [else-branch: 2400 | !(p1_31@1469@01) | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 2400 | !(p1_31@1469@01)]
(pop) ; 5
; [eval] !p1_31
; [then-branch: 2401 | !(p1_31@1469@01) | dead]
; [else-branch: 2401 | p1_31@1469@01 | live]
(push) ; 5
; [else-branch: 2401 | p1_31@1469@01]
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- Lock_release ----------
(declare-const p1_32@1501@01 Bool)
(declare-const p2_32@1502@01 Bool)
(declare-const _cthread_173@1503@01 $Ref)
(declare-const _cthread_173_0@1504@01 $Ref)
(declare-const _caller_measures_173@1505@01 Seq<Measure$>)
(declare-const _caller_measures_173_0@1506@01 Seq<Measure$>)
(declare-const _residue_173@1507@01 $Perm)
(declare-const _residue_173_0@1508@01 $Perm)
(declare-const self_6@1509@01 $Ref)
(declare-const self_6_0@1510@01 $Ref)
(declare-const _current_wait_level_173@1511@01 $Perm)
(declare-const _current_wait_level_173_0@1512@01 $Perm)
(declare-const p1_32@1513@01 Bool)
(declare-const p2_32@1514@01 Bool)
(declare-const _cthread_173@1515@01 $Ref)
(declare-const _cthread_173_0@1516@01 $Ref)
(declare-const _caller_measures_173@1517@01 Seq<Measure$>)
(declare-const _caller_measures_173_0@1518@01 Seq<Measure$>)
(declare-const _residue_173@1519@01 $Perm)
(declare-const _residue_173_0@1520@01 $Perm)
(declare-const self_6@1521@01 $Ref)
(declare-const self_6_0@1522@01 $Ref)
(declare-const _current_wait_level_173@1523@01 $Perm)
(declare-const _current_wait_level_173_0@1524@01 $Perm)
(push) ; 1
(declare-const $t@1525@01 $Snap)
(assert (= $t@1525@01 ($Snap.combine ($Snap.first $t@1525@01) ($Snap.second $t@1525@01))))
(assert (= ($Snap.first $t@1525@01) $Snap.unit))
; [eval] p1_32 ==> _cthread_173 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_32@1513@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2402 | p1_32@1513@01 | live]
; [else-branch: 2402 | !(p1_32@1513@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2402 | p1_32@1513@01]
(assert p1_32@1513@01)
; [eval] _cthread_173 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2402 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_32@1513@01) p1_32@1513@01))
(assert (=> p1_32@1513@01 (not (= _cthread_173@1515@01 $Ref.null))))
(assert (=
  ($Snap.second $t@1525@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1525@01))
    ($Snap.second ($Snap.second $t@1525@01)))))
(assert (= ($Snap.first ($Snap.second $t@1525@01)) $Snap.unit))
; [eval] p2_32 ==> _cthread_173_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_32@1514@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2403 | p2_32@1514@01 | live]
; [else-branch: 2403 | !(p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2403 | p2_32@1514@01]
(assert p2_32@1514@01)
; [eval] _cthread_173_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2403 | !(p2_32@1514@01)]
(assert (not p2_32@1514@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_32@1514@01) p2_32@1514@01))
(assert (=> p2_32@1514@01 (not (= _cthread_173_0@1516@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@1525@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1525@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1525@01))) $Snap.unit))
; [eval] p1_32 ==> issubtype(typeof(_cthread_173), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_32@1513@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2404 | p1_32@1513@01 | live]
; [else-branch: 2404 | !(p1_32@1513@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2404 | p1_32@1513@01]
(assert p1_32@1513@01)
; [eval] issubtype(typeof(_cthread_173), Thread_0())
; [eval] typeof(_cthread_173)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2404 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_32@1513@01
  (issubtype<Bool> (typeof<PyType> _cthread_173@1515@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))
  $Snap.unit))
; [eval] p2_32 ==> issubtype(typeof(_cthread_173_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_32@1514@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2405 | p2_32@1514@01 | live]
; [else-branch: 2405 | !(p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2405 | p2_32@1514@01]
(assert p2_32@1514@01)
; [eval] issubtype(typeof(_cthread_173_0), Thread_0())
; [eval] typeof(_cthread_173_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2405 | !(p2_32@1514@01)]
(assert (not p2_32@1514@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_32@1514@01
  (issubtype<Bool> (typeof<PyType> _cthread_173_0@1516@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))
  $Snap.unit))
; [eval] p1_32 ==> issubtype(typeof(self_6), Lock(Lock_arg(typeof(self_6), 0)))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_32@1513@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2406 | p1_32@1513@01 | live]
; [else-branch: 2406 | !(p1_32@1513@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2406 | p1_32@1513@01]
(assert p1_32@1513@01)
; [eval] issubtype(typeof(self_6), Lock(Lock_arg(typeof(self_6), 0)))
; [eval] typeof(self_6)
; [eval] Lock(Lock_arg(typeof(self_6), 0))
; [eval] Lock_arg(typeof(self_6), 0)
; [eval] typeof(self_6)
(pop) ; 3
(push) ; 3
; [else-branch: 2406 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_32@1513@01
  (issubtype<Bool> (typeof<PyType> self_6@1521@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> self_6@1521@01) 0)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))
  $Snap.unit))
; [eval] p2_32 ==> issubtype(typeof(self_6_0), Lock(Lock_arg(typeof(self_6_0), 0)))
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_32@1514@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2407 | p2_32@1514@01 | live]
; [else-branch: 2407 | !(p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2407 | p2_32@1514@01]
(assert p2_32@1514@01)
; [eval] issubtype(typeof(self_6_0), Lock(Lock_arg(typeof(self_6_0), 0)))
; [eval] typeof(self_6_0)
; [eval] Lock(Lock_arg(typeof(self_6_0), 0))
; [eval] Lock_arg(typeof(self_6_0), 0)
; [eval] typeof(self_6_0)
(pop) ; 3
(push) ; 3
; [else-branch: 2407 | !(p2_32@1514@01)]
(assert (not p2_32@1514@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_32@1514@01
  (issubtype<Bool> (typeof<PyType> self_6_0@1522@01) (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> self_6_0@1522@01) 0)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))
  $Snap.unit))
; [eval] p1_32 ==> issubtype(Lock_arg(typeof(self_6), 0), object())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_32@1513@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2408 | p1_32@1513@01 | live]
; [else-branch: 2408 | !(p1_32@1513@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2408 | p1_32@1513@01]
(assert p1_32@1513@01)
; [eval] issubtype(Lock_arg(typeof(self_6), 0), object())
; [eval] Lock_arg(typeof(self_6), 0)
; [eval] typeof(self_6)
; [eval] object()
(pop) ; 3
(push) ; 3
; [else-branch: 2408 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_32@1513@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> self_6@1521@01) 0) (as object<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))
  $Snap.unit))
; [eval] p2_32 ==> issubtype(Lock_arg(typeof(self_6_0), 0), object())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_32@1514@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2409 | p2_32@1514@01 | live]
; [else-branch: 2409 | !(p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2409 | p2_32@1514@01]
(assert p2_32@1514@01)
; [eval] issubtype(Lock_arg(typeof(self_6_0), 0), object())
; [eval] Lock_arg(typeof(self_6_0), 0)
; [eval] typeof(self_6_0)
; [eval] object()
(pop) ; 3
(push) ; 3
; [else-branch: 2409 | !(p2_32@1514@01)]
(assert (not p2_32@1514@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_32@1514@01
  (issubtype<Bool> (Lock_arg<PyType> (typeof<PyType> self_6_0@1522@01) 0) (as object<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))
  $Snap.unit))
; [eval] p1_32 ==> self_6 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_32@1513@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2410 | p1_32@1513@01 | live]
; [else-branch: 2410 | !(p1_32@1513@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2410 | p1_32@1513@01]
(assert p1_32@1513@01)
; [eval] self_6 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2410 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p1_32@1513@01 (not (= self_6@1521@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))
  $Snap.unit))
; [eval] p2_32 ==> self_6_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_32@1514@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2411 | p2_32@1514@01 | live]
; [else-branch: 2411 | !(p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2411 | p2_32@1514@01]
(assert p2_32@1514@01)
; [eval] self_6_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2411 | !(p2_32@1514@01)]
(assert (not p2_32@1514@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=> p2_32@1514@01 (not (= self_6_0@1522@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
(push) ; 2
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 2
(set-option :timeout 10)
(assert (not p1_32@1513@01))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2412 | p1_32@1513@01 | live]
; [else-branch: 2412 | !(p1_32@1513@01) | live]
(set-option :timeout 0)
(push) ; 2
; [then-branch: 2412 | p1_32@1513@01]
(assert p1_32@1513@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_32@1514@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2413 | p2_32@1514@01 | live]
; [else-branch: 2413 | !(p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2413 | p2_32@1514@01]
(assert p2_32@1514@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2414 | p1_32@1513@01 | live]
; [else-branch: 2414 | !(p1_32@1513@01) | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2414 | p1_32@1513@01]
(assert (not (= self_6@1521@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2415 | p2_32@1514@01 | live]
; [else-branch: 2415 | !(p2_32@1514@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2415 | p2_32@1514@01]
(assert (not (= self_6_0@1522@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2416 | p1_32@1513@01 | live]
; [else-branch: 2416 | !(p1_32@1513@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2416 | p1_32@1513@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2417 | p2_32@1514@01 | live]
; [else-branch: 2417 | !(p2_32@1514@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2417 | p2_32@1514@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
  $Snap.unit))
; [eval] p1_32 && p2_32 ==> Lock_invariant_low(self_6, self_6_0)
; [eval] p1_32 && p2_32
(push) ; 8
; [then-branch: 2418 | !(p1_32@1513@01) | live]
; [else-branch: 2418 | p1_32@1513@01 | live]
(push) ; 9
; [then-branch: 2418 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(pop) ; 9
(push) ; 9
; [else-branch: 2418 | p1_32@1513@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or p1_32@1513@01 (not p1_32@1513@01)))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not (and p1_32@1513@01 p2_32@1514@01))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and p1_32@1513@01 p2_32@1514@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2419 | p1_32@1513@01 && p2_32@1514@01 | live]
; [else-branch: 2419 | !(p1_32@1513@01 && p2_32@1514@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2419 | p1_32@1513@01 && p2_32@1514@01]
(assert (and p1_32@1513@01 p2_32@1514@01))
; [eval] Lock_invariant_low(self_6, self_6_0)
(push) ; 10
(declare-const $k@1526@01 $Perm)
(assert ($Perm.isReadVar $k@1526@01))
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No $k@1526@01)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(declare-const $k@1527@01 $Perm)
(assert ($Perm.isReadVar $k@1527@01))
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No $k@1527@01)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))) self_6@1521@01 self_6_0@1522@01))
(pop) ; 10
; Joined path conditions
(assert ($Perm.isReadVar $k@1526@01))
(assert ($Perm.isReadVar $k@1527@01))
(assert (Lock_invariant_low%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))) self_6@1521@01 self_6_0@1522@01))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@1526@01))
(assert ($Perm.isReadVar $k@1527@01))
(assert (=>
  (and p1_32@1513@01 p2_32@1514@01)
  (and
    p1_32@1513@01
    p2_32@1514@01
    (Lock_invariant_low%precondition ($Snap.combine
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
      ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))) self_6@1521@01 self_6_0@1522@01))))
(assert (and p1_32@1513@01 p2_32@1514@01))
(assert (=>
  (and p1_32@1513@01 p2_32@1514@01)
  (Lock_invariant_low ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))) self_6@1521@01 self_6_0@1522@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 && p2_32 ==> self_6 == self_6_0
; [eval] p1_32 && p2_32
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2420 | !(p1_32@1513@01) | live]
; [else-branch: 2420 | p1_32@1513@01 | live]
(push) ; 9
; [then-branch: 2420 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(pop) ; 9
(push) ; 9
; [else-branch: 2420 | p1_32@1513@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not (and p1_32@1513@01 p2_32@1514@01))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and p1_32@1513@01 p2_32@1514@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2421 | p1_32@1513@01 && p2_32@1514@01 | live]
; [else-branch: 2421 | !(p1_32@1513@01 && p2_32@1514@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2421 | p1_32@1513@01 && p2_32@1514@01]
(assert (and p1_32@1513@01 p2_32@1514@01))
; [eval] self_6 == self_6_0
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (and p1_32@1513@01 p2_32@1514@01))
(assert (=> (and p1_32@1513@01 p2_32@1514@01) (= self_6@1521@01 self_6_0@1522@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 == p2_32
(assert (= p1_32@1513@01 p2_32@1514@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 ==> typeof(self_6) == typeof(self_6_0)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2422 | p1_32@1513@01 | live]
; [else-branch: 2422 | !(p1_32@1513@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2422 | p1_32@1513@01]
; [eval] typeof(self_6) == typeof(self_6_0)
; [eval] typeof(self_6)
; [eval] typeof(self_6_0)
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  p1_32@1513@01
  (= (typeof<PyType> self_6@1521@01) (typeof<PyType> self_6_0@1522@01))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2423 | p1_32@1513@01 | live]
; [else-branch: 2423 | !(p1_32@1513@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2423 | p1_32@1513@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p2_32 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2424 | p2_32@1514@01 | live]
; [else-branch: 2424 | !(p2_32@1514@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2424 | p2_32@1514@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(declare-const $t@1528@01 $Snap)
(assert (= $t@1528@01 ($Snap.combine ($Snap.first $t@1528@01) ($Snap.second $t@1528@01))))
(assert (= ($Snap.first $t@1528@01) $Snap.unit))
; [eval] p1_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173) && ((forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173) && _residue_173 <= _current_wait_level_173)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2425 | p1_32@1513@01 | live]
; [else-branch: 2425 | !(p1_32@1513@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2425 | p1_32@1513@01]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173) && ((forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173) && _residue_173 <= _current_wait_level_173)
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173)
(push) ; 11
; [then-branch: 2426 | False | live]
; [else-branch: 2426 | True | live]
(push) ; 12
; [then-branch: 2426 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 2426 | True]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173)
(push) ; 13
; [then-branch: 2427 | False | live]
; [else-branch: 2427 | True | live]
(push) ; 14
; [then-branch: 2427 | False]
(assert false)
(pop) ; 14
(push) ; 14
; [else-branch: 2427 | True]
; [eval] _residue_173 <= _current_wait_level_173
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=> p1_32@1513@01 (<= _residue_173@1519@01 _current_wait_level_173@1523@01)))
(assert (= ($Snap.second $t@1528@01) $Snap.unit))
; [eval] p2_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0) && ((forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0) && _residue_173_0 <= _current_wait_level_173_0)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2428 | p2_32@1514@01 | live]
; [else-branch: 2428 | !(p2_32@1514@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2428 | p2_32@1514@01]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0) && ((forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0) && _residue_173_0 <= _current_wait_level_173_0)
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0)
(push) ; 11
; [then-branch: 2429 | False | live]
; [else-branch: 2429 | True | live]
(push) ; 12
; [then-branch: 2429 | False]
(assert false)
(pop) ; 12
(push) ; 12
; [else-branch: 2429 | True]
; [eval] (forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0)
(push) ; 13
; [then-branch: 2430 | False | live]
; [else-branch: 2430 | True | live]
(push) ; 14
; [then-branch: 2430 | False]
(assert false)
(pop) ; 14
(push) ; 14
; [else-branch: 2430 | True]
; [eval] _residue_173_0 <= _current_wait_level_173_0
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=> p2_32@1514@01 (<= _residue_173_0@1520@01 _current_wait_level_173_0@1524@01)))
(pop) ; 8
(push) ; 8
; [exec]
; var _cwl_173: Perm
(declare-const _cwl_173@1529@01 $Perm)
; [exec]
; var _cwl_173_0: Perm
(declare-const _cwl_173_0@1530@01 $Perm)
; [exec]
; inhale p1_32
(declare-const $t@1531@01 $Snap)
(assert (= $t@1531@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2431 | p1_32@1513@01 | live]
; [else-branch: 2431 | !(p1_32@1513@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2431 | p1_32@1513@01]
; [exec]
; inhale typeof(self_6) == Lock(Lock_arg(typeof(self_6), 0))
(declare-const $t@1532@01 $Snap)
(assert (= $t@1532@01 $Snap.unit))
; [eval] typeof(self_6) == Lock(Lock_arg(typeof(self_6), 0))
; [eval] typeof(self_6)
; [eval] Lock(Lock_arg(typeof(self_6), 0))
; [eval] Lock_arg(typeof(self_6), 0)
; [eval] typeof(self_6)
(assert (=
  (typeof<PyType> self_6@1521@01)
  (Lock<PyType> (Lock_arg<PyType> (typeof<PyType> self_6@1521@01) 0))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale false
(pop) ; 9
; [eval] !p1_32
; [then-branch: 2432 | !(p1_32@1513@01) | dead]
; [else-branch: 2432 | p1_32@1513@01 | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2432 | p1_32@1513@01]
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 2413 | !(p2_32@1514@01)]
(assert (not p2_32@1514@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_32@1513@01))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2433 | p1_32@1513@01 | live]
; [else-branch: 2433 | !(p1_32@1513@01) | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2433 | p1_32@1513@01]
(assert p1_32@1513@01)
(assert (not (= self_6@1521@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
; [then-branch: 2434 | p2_32@1514@01 | dead]
; [else-branch: 2434 | !(p2_32@1514@01) | live]
(push) ; 5
; [else-branch: 2434 | !(p2_32@1514@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
(push) ; 6
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2435 | p1_32@1513@01 | live]
; [else-branch: 2435 | !(p1_32@1513@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2435 | p1_32@1513@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
; [then-branch: 2436 | p2_32@1514@01 | dead]
; [else-branch: 2436 | !(p2_32@1514@01) | live]
(push) ; 7
; [else-branch: 2436 | !(p2_32@1514@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
  $Snap.unit))
; [eval] p1_32 && p2_32 ==> Lock_invariant_low(self_6, self_6_0)
; [eval] p1_32 && p2_32
(push) ; 8
; [then-branch: 2437 | !(p1_32@1513@01) | live]
; [else-branch: 2437 | p1_32@1513@01 | live]
(push) ; 9
; [then-branch: 2437 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(pop) ; 9
(push) ; 9
; [else-branch: 2437 | p1_32@1513@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or p1_32@1513@01 (not p1_32@1513@01)))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not (and p1_32@1513@01 p2_32@1514@01))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2438 | p1_32@1513@01 && p2_32@1514@01 | dead]
; [else-branch: 2438 | !(p1_32@1513@01 && p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2438 | !(p1_32@1513@01 && p2_32@1514@01)]
(assert (not (and p1_32@1513@01 p2_32@1514@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (not (and p1_32@1513@01 p2_32@1514@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 && p2_32 ==> self_6 == self_6_0
; [eval] p1_32 && p2_32
(push) ; 8
; [then-branch: 2439 | !(p1_32@1513@01) | live]
; [else-branch: 2439 | p1_32@1513@01 | live]
(push) ; 9
; [then-branch: 2439 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(pop) ; 9
(push) ; 9
; [else-branch: 2439 | p1_32@1513@01]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 2440 | p1_32@1513@01 && p2_32@1514@01 | dead]
; [else-branch: 2440 | !(p1_32@1513@01 && p2_32@1514@01) | live]
(push) ; 9
; [else-branch: 2440 | !(p1_32@1513@01 && p2_32@1514@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 == p2_32
(assert (= p1_32@1513@01 p2_32@1514@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 ==> typeof(self_6) == typeof(self_6_0)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_32@1513@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2441 | p1_32@1513@01 | dead]
; [else-branch: 2441 | !(p1_32@1513@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2441 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (not p1_32@1513@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 ==> true
(push) ; 8
; [then-branch: 2442 | p1_32@1513@01 | dead]
; [else-branch: 2442 | !(p1_32@1513@01) | live]
(push) ; 9
; [else-branch: 2442 | !(p1_32@1513@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p2_32 ==> true
(push) ; 8
; [then-branch: 2443 | p2_32@1514@01 | dead]
; [else-branch: 2443 | !(p2_32@1514@01) | live]
(push) ; 9
; [else-branch: 2443 | !(p2_32@1514@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unsat
(set-option :timeout 0)
(push) ; 8
(declare-const $t@1533@01 $Snap)
(assert (= $t@1533@01 ($Snap.combine ($Snap.first $t@1533@01) ($Snap.second $t@1533@01))))
(assert (= ($Snap.first $t@1533@01) $Snap.unit))
; [eval] p1_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173) && ((forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173) && _residue_173 <= _current_wait_level_173)
(push) ; 9
; [then-branch: 2444 | p1_32@1513@01 | dead]
; [else-branch: 2444 | !(p1_32@1513@01) | live]
(push) ; 10
; [else-branch: 2444 | !(p1_32@1513@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (= ($Snap.second $t@1533@01) $Snap.unit))
; [eval] p2_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0) && ((forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0) && _residue_173_0 <= _current_wait_level_173_0)
(push) ; 9
; [then-branch: 2445 | p2_32@1514@01 | dead]
; [else-branch: 2445 | !(p2_32@1514@01) | live]
(push) ; 10
; [else-branch: 2445 | !(p2_32@1514@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(push) ; 8
; [exec]
; var _cwl_173: Perm
(declare-const _cwl_173@1534@01 $Perm)
; [exec]
; var _cwl_173_0: Perm
(declare-const _cwl_173_0@1535@01 $Perm)
; [exec]
; inhale p1_32
(declare-const $t@1536@01 $Snap)
(assert (= $t@1536@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 2446 | p1_32@1513@01 | dead]
; [else-branch: 2446 | !(p1_32@1513@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2446 | !(p1_32@1513@01)]
(pop) ; 9
; [eval] !p1_32
; [then-branch: 2447 | !(p1_32@1513@01) | dead]
; [else-branch: 2447 | p1_32@1513@01 | live]
(push) ; 9
; [else-branch: 2447 | p1_32@1513@01]
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [else-branch: 2412 | !(p1_32@1513@01)]
(assert (not p1_32@1513@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_32@1514@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2448 | p2_32@1514@01 | live]
; [else-branch: 2448 | !(p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2448 | p2_32@1514@01]
(assert p2_32@1514@01)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
; [then-branch: 2449 | p1_32@1513@01 | dead]
; [else-branch: 2449 | !(p1_32@1513@01) | live]
(push) ; 4
; [else-branch: 2449 | !(p1_32@1513@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2450 | p2_32@1514@01 | live]
; [else-branch: 2450 | !(p2_32@1514@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2450 | p2_32@1514@01]
(assert (not (= self_6_0@1522@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
; [then-branch: 2451 | p1_32@1513@01 | dead]
; [else-branch: 2451 | !(p1_32@1513@01) | live]
(push) ; 6
; [else-branch: 2451 | !(p1_32@1513@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
(push) ; 7
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2452 | p2_32@1514@01 | live]
; [else-branch: 2452 | !(p2_32@1514@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2452 | p2_32@1514@01]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
  $Snap.unit))
; [eval] p1_32 && p2_32 ==> Lock_invariant_low(self_6, self_6_0)
; [eval] p1_32 && p2_32
(push) ; 8
; [then-branch: 2453 | !(p1_32@1513@01) | live]
; [else-branch: 2453 | p1_32@1513@01 | live]
(push) ; 9
; [then-branch: 2453 | !(p1_32@1513@01)]
(pop) ; 9
(push) ; 9
; [else-branch: 2453 | p1_32@1513@01]
(assert p1_32@1513@01)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or p1_32@1513@01 (not p1_32@1513@01)))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not (and p1_32@1513@01 p2_32@1514@01))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2454 | p1_32@1513@01 && p2_32@1514@01 | dead]
; [else-branch: 2454 | !(p1_32@1513@01 && p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2454 | !(p1_32@1513@01 && p2_32@1514@01)]
(assert (not (and p1_32@1513@01 p2_32@1514@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (not (and p1_32@1513@01 p2_32@1514@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 && p2_32 ==> self_6 == self_6_0
; [eval] p1_32 && p2_32
(push) ; 8
; [then-branch: 2455 | !(p1_32@1513@01) | live]
; [else-branch: 2455 | p1_32@1513@01 | live]
(push) ; 9
; [then-branch: 2455 | !(p1_32@1513@01)]
(pop) ; 9
(push) ; 9
; [else-branch: 2455 | p1_32@1513@01]
(assert p1_32@1513@01)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 2456 | p1_32@1513@01 && p2_32@1514@01 | dead]
; [else-branch: 2456 | !(p1_32@1513@01 && p2_32@1514@01) | live]
(push) ; 9
; [else-branch: 2456 | !(p1_32@1513@01 && p2_32@1514@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 == p2_32
(assert (= p1_32@1513@01 p2_32@1514@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 ==> typeof(self_6) == typeof(self_6_0)
(push) ; 8
; [then-branch: 2457 | p1_32@1513@01 | dead]
; [else-branch: 2457 | !(p1_32@1513@01) | live]
(push) ; 9
; [else-branch: 2457 | !(p1_32@1513@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 ==> true
(push) ; 8
; [then-branch: 2458 | p1_32@1513@01 | dead]
; [else-branch: 2458 | !(p1_32@1513@01) | live]
(push) ; 9
; [else-branch: 2458 | !(p1_32@1513@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p2_32 ==> true
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not p2_32@1514@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2459 | p2_32@1514@01 | dead]
; [else-branch: 2459 | !(p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2459 | !(p2_32@1514@01)]
(assert (not p2_32@1514@01))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (not p2_32@1514@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unsat
(set-option :timeout 0)
(push) ; 8
(declare-const $t@1537@01 $Snap)
(assert (= $t@1537@01 ($Snap.combine ($Snap.first $t@1537@01) ($Snap.second $t@1537@01))))
(assert (= ($Snap.first $t@1537@01) $Snap.unit))
; [eval] p1_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173) && ((forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173) && _residue_173 <= _current_wait_level_173)
(push) ; 9
; [then-branch: 2460 | p1_32@1513@01 | dead]
; [else-branch: 2460 | !(p1_32@1513@01) | live]
(push) ; 10
; [else-branch: 2460 | !(p1_32@1513@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (= ($Snap.second $t@1537@01) $Snap.unit))
; [eval] p2_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0) && ((forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0) && _residue_173_0 <= _current_wait_level_173_0)
(push) ; 9
; [then-branch: 2461 | p2_32@1514@01 | dead]
; [else-branch: 2461 | !(p2_32@1514@01) | live]
(push) ; 10
; [else-branch: 2461 | !(p2_32@1514@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(push) ; 8
; [exec]
; var _cwl_173: Perm
(declare-const _cwl_173@1538@01 $Perm)
; [exec]
; var _cwl_173_0: Perm
(declare-const _cwl_173_0@1539@01 $Perm)
; [exec]
; inhale p1_32
(declare-const $t@1540@01 $Snap)
(assert (= $t@1540@01 $Snap.unit))
(assert p1_32@1513@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 2462 | p1_32@1513@01 | dead]
; [else-branch: 2462 | !(p1_32@1513@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2462 | !(p1_32@1513@01)]
(pop) ; 9
; [eval] !p1_32
; [then-branch: 2463 | !(p1_32@1513@01) | dead]
; [else-branch: 2463 | p1_32@1513@01 | live]
(push) ; 9
; [else-branch: 2463 | p1_32@1513@01]
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 2448 | !(p2_32@1514@01)]
(assert (not p2_32@1514@01))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
; [then-branch: 2464 | p1_32@1513@01 | dead]
; [else-branch: 2464 | !(p1_32@1513@01) | live]
(push) ; 4
; [else-branch: 2464 | !(p1_32@1513@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
; [then-branch: 2465 | p2_32@1514@01 | dead]
; [else-branch: 2465 | !(p2_32@1514@01) | live]
(push) ; 5
; [else-branch: 2465 | !(p2_32@1514@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
; [then-branch: 2466 | p1_32@1513@01 | dead]
; [else-branch: 2466 | !(p1_32@1513@01) | live]
(push) ; 6
; [else-branch: 2466 | !(p1_32@1513@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
; [then-branch: 2467 | p2_32@1514@01 | dead]
; [else-branch: 2467 | !(p2_32@1514@01) | live]
(push) ; 7
; [else-branch: 2467 | !(p2_32@1514@01)]
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
  $Snap.unit))
; [eval] p1_32 && p2_32 ==> Lock_invariant_low(self_6, self_6_0)
; [eval] p1_32 && p2_32
(push) ; 8
; [then-branch: 2468 | !(p1_32@1513@01) | live]
; [else-branch: 2468 | p1_32@1513@01 | live]
(push) ; 9
; [then-branch: 2468 | !(p1_32@1513@01)]
(pop) ; 9
(push) ; 9
; [else-branch: 2468 | p1_32@1513@01]
(assert p1_32@1513@01)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or p1_32@1513@01 (not p1_32@1513@01)))
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not (and p1_32@1513@01 p2_32@1514@01))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2469 | p1_32@1513@01 && p2_32@1514@01 | dead]
; [else-branch: 2469 | !(p1_32@1513@01 && p2_32@1514@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2469 | !(p1_32@1513@01 && p2_32@1514@01)]
(assert (not (and p1_32@1513@01 p2_32@1514@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (not (and p1_32@1513@01 p2_32@1514@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 && p2_32 ==> self_6 == self_6_0
; [eval] p1_32 && p2_32
(push) ; 8
; [then-branch: 2470 | !(p1_32@1513@01) | live]
; [else-branch: 2470 | p1_32@1513@01 | live]
(push) ; 9
; [then-branch: 2470 | !(p1_32@1513@01)]
(pop) ; 9
(push) ; 9
; [else-branch: 2470 | p1_32@1513@01]
(assert p1_32@1513@01)
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 2471 | p1_32@1513@01 && p2_32@1514@01 | dead]
; [else-branch: 2471 | !(p1_32@1513@01 && p2_32@1514@01) | live]
(push) ; 9
; [else-branch: 2471 | !(p1_32@1513@01 && p2_32@1514@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 == p2_32
(assert (= p1_32@1513@01 p2_32@1514@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 ==> typeof(self_6) == typeof(self_6_0)
(push) ; 8
; [then-branch: 2472 | p1_32@1513@01 | dead]
; [else-branch: 2472 | !(p1_32@1513@01) | live]
(push) ; 9
; [else-branch: 2472 | !(p1_32@1513@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p1_32 ==> true
(push) ; 8
; [then-branch: 2473 | p1_32@1513@01 | dead]
; [else-branch: 2473 | !(p1_32@1513@01) | live]
(push) ; 9
; [else-branch: 2473 | !(p1_32@1513@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1525@01)))))))))))))))))))))
  $Snap.unit))
; [eval] p2_32 ==> true
(push) ; 8
; [then-branch: 2474 | p2_32@1514@01 | dead]
; [else-branch: 2474 | !(p2_32@1514@01) | live]
(push) ; 9
; [else-branch: 2474 | !(p2_32@1514@01)]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 8
(declare-const $t@1541@01 $Snap)
(assert (= $t@1541@01 ($Snap.combine ($Snap.first $t@1541@01) ($Snap.second $t@1541@01))))
(assert (= ($Snap.first $t@1541@01) $Snap.unit))
; [eval] p1_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBounded] :: Level(_r_58) <= _current_wait_level_173) && ((forperm _r_58: Ref [_r_58.MustReleaseUnbounded] :: Level(_r_58) <= _current_wait_level_173) && _residue_173 <= _current_wait_level_173)
(push) ; 9
; [then-branch: 2475 | p1_32@1513@01 | dead]
; [else-branch: 2475 | !(p1_32@1513@01) | live]
(push) ; 10
; [else-branch: 2475 | !(p1_32@1513@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (= ($Snap.second $t@1541@01) $Snap.unit))
; [eval] p2_32 ==> (forperm _r_58: Ref [_r_58.MustReleaseBoundedp] :: Level(_r_58) <= _current_wait_level_173_0) && ((forperm _r_58: Ref [_r_58.MustReleaseUnboundedp] :: Level(_r_58) <= _current_wait_level_173_0) && _residue_173_0 <= _current_wait_level_173_0)
(push) ; 9
; [then-branch: 2476 | p2_32@1514@01 | dead]
; [else-branch: 2476 | !(p2_32@1514@01) | live]
(push) ; 10
; [else-branch: 2476 | !(p2_32@1514@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(pop) ; 8
(push) ; 8
; [exec]
; var _cwl_173: Perm
(declare-const _cwl_173@1542@01 $Perm)
; [exec]
; var _cwl_173_0: Perm
(declare-const _cwl_173_0@1543@01 $Perm)
; [exec]
; inhale p1_32
(declare-const $t@1544@01 $Snap)
(assert (= $t@1544@01 $Snap.unit))
(assert p1_32@1513@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unsat
; [then-branch: 2477 | p1_32@1513@01 | dead]
; [else-branch: 2477 | !(p1_32@1513@01) | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 2477 | !(p1_32@1513@01)]
(pop) ; 9
; [eval] !p1_32
; [then-branch: 2478 | !(p1_32@1513@01) | dead]
; [else-branch: 2478 | p1_32@1513@01 | live]
(push) ; 9
; [else-branch: 2478 | p1_32@1513@01]
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- main ----------
(declare-const p1_33@1545@01 Bool)
(declare-const p2_33@1546@01 Bool)
(declare-const _cthread_175@1547@01 $Ref)
(declare-const _cthread_175_0@1548@01 $Ref)
(declare-const _caller_measures_175@1549@01 Seq<Measure$>)
(declare-const _caller_measures_175_0@1550@01 Seq<Measure$>)
(declare-const _residue_175@1551@01 $Perm)
(declare-const _residue_175_0@1552@01 $Perm)
(declare-const _current_wait_level_175@1553@01 $Perm)
(declare-const _current_wait_level_175_0@1554@01 $Perm)
(declare-const p1_33@1555@01 Bool)
(declare-const p2_33@1556@01 Bool)
(declare-const _cthread_175@1557@01 $Ref)
(declare-const _cthread_175_0@1558@01 $Ref)
(declare-const _caller_measures_175@1559@01 Seq<Measure$>)
(declare-const _caller_measures_175_0@1560@01 Seq<Measure$>)
(declare-const _residue_175@1561@01 $Perm)
(declare-const _residue_175_0@1562@01 $Perm)
(declare-const _current_wait_level_175@1563@01 $Perm)
(declare-const _current_wait_level_175_0@1564@01 $Perm)
(push) ; 1
(declare-const $t@1565@01 $Snap)
(assert (= $t@1565@01 ($Snap.combine ($Snap.first $t@1565@01) ($Snap.second $t@1565@01))))
(assert (= ($Snap.first $t@1565@01) $Snap.unit))
; [eval] p1_33 ==> _cthread_175 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_33@1555@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2479 | p1_33@1555@01 | live]
; [else-branch: 2479 | !(p1_33@1555@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2479 | p1_33@1555@01]
(assert p1_33@1555@01)
; [eval] _cthread_175 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2479 | !(p1_33@1555@01)]
(assert (not p1_33@1555@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p1_33@1555@01) p1_33@1555@01))
(assert (=> p1_33@1555@01 (not (= _cthread_175@1557@01 $Ref.null))))
(assert (=
  ($Snap.second $t@1565@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1565@01))
    ($Snap.second ($Snap.second $t@1565@01)))))
(assert (= ($Snap.first ($Snap.second $t@1565@01)) $Snap.unit))
; [eval] p2_33 ==> _cthread_175_0 != null
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2480 | p2_33@1556@01 | live]
; [else-branch: 2480 | !(p2_33@1556@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2480 | p2_33@1556@01]
(assert p2_33@1556@01)
; [eval] _cthread_175_0 != null
(pop) ; 3
(push) ; 3
; [else-branch: 2480 | !(p2_33@1556@01)]
(assert (not p2_33@1556@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (or (not p2_33@1556@01) p2_33@1556@01))
(assert (=> p2_33@1556@01 (not (= _cthread_175_0@1558@01 $Ref.null))))
(assert (=
  ($Snap.second ($Snap.second $t@1565@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1565@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1565@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1565@01))) $Snap.unit))
; [eval] p1_33 ==> issubtype(typeof(_cthread_175), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_33@1555@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2481 | p1_33@1555@01 | live]
; [else-branch: 2481 | !(p1_33@1555@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2481 | p1_33@1555@01]
(assert p1_33@1555@01)
; [eval] issubtype(typeof(_cthread_175), Thread_0())
; [eval] typeof(_cthread_175)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2481 | !(p1_33@1555@01)]
(assert (not p1_33@1555@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p1_33@1555@01
  (issubtype<Bool> (typeof<PyType> _cthread_175@1557@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@1565@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1565@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1565@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@1565@01))))
  $Snap.unit))
; [eval] p2_33 ==> issubtype(typeof(_cthread_175_0), Thread_0())
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2482 | p2_33@1556@01 | live]
; [else-branch: 2482 | !(p2_33@1556@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2482 | p2_33@1556@01]
(assert p2_33@1556@01)
; [eval] issubtype(typeof(_cthread_175_0), Thread_0())
; [eval] typeof(_cthread_175_0)
; [eval] Thread_0()
(pop) ; 3
(push) ; 3
; [else-branch: 2482 | !(p2_33@1556@01)]
(assert (not p2_33@1556@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=>
  p2_33@1556@01
  (issubtype<Bool> (typeof<PyType> _cthread_175_0@1558@01) (as Thread_0<PyType>  PyType))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1565@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1565@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1565@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1565@01)))))
  $Snap.unit))
; [eval] p1_33 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p1_33@1555@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2483 | p1_33@1555@01 | live]
; [else-branch: 2483 | !(p1_33@1555@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2483 | p1_33@1555@01]
(assert p1_33@1555@01)
(pop) ; 3
(push) ; 3
; [else-branch: 2483 | !(p1_33@1555@01)]
(assert (not p1_33@1555@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@1565@01)))))
  $Snap.unit))
; [eval] p2_33 ==> true
(push) ; 2
(push) ; 3
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2484 | p2_33@1556@01 | live]
; [else-branch: 2484 | !(p2_33@1556@01) | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2484 | p2_33@1556@01]
(assert p2_33@1556@01)
(pop) ; 3
(push) ; 3
; [else-branch: 2484 | !(p2_33@1556@01)]
(assert (not p2_33@1556@01))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(declare-const $t@1566@01 $Snap)
(assert (= $t@1566@01 ($Snap.combine ($Snap.first $t@1566@01) ($Snap.second $t@1566@01))))
(assert (= ($Snap.first $t@1566@01) $Snap.unit))
; [eval] p1_33 ==> (forperm _r_60: Ref [_r_60.MustReleaseBounded] :: Level(_r_60) <= _current_wait_level_175) && ((forperm _r_60: Ref [_r_60.MustReleaseUnbounded] :: Level(_r_60) <= _current_wait_level_175) && _residue_175 <= _current_wait_level_175)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_33@1555@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2485 | p1_33@1555@01 | live]
; [else-branch: 2485 | !(p1_33@1555@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2485 | p1_33@1555@01]
(assert p1_33@1555@01)
; [eval] (forperm _r_60: Ref [_r_60.MustReleaseBounded] :: Level(_r_60) <= _current_wait_level_175) && ((forperm _r_60: Ref [_r_60.MustReleaseUnbounded] :: Level(_r_60) <= _current_wait_level_175) && _residue_175 <= _current_wait_level_175)
; [eval] (forperm _r_60: Ref [_r_60.MustReleaseBounded] :: Level(_r_60) <= _current_wait_level_175)
(push) ; 5
; [then-branch: 2486 | False | live]
; [else-branch: 2486 | True | live]
(push) ; 6
; [then-branch: 2486 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 2486 | True]
; [eval] (forperm _r_60: Ref [_r_60.MustReleaseUnbounded] :: Level(_r_60) <= _current_wait_level_175)
(push) ; 7
; [then-branch: 2487 | False | live]
; [else-branch: 2487 | True | live]
(push) ; 8
; [then-branch: 2487 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 2487 | True]
; [eval] _residue_175 <= _current_wait_level_175
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 2485 | !(p1_33@1555@01)]
(assert (not p1_33@1555@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p1_33@1555@01 (<= _residue_175@1561@01 _current_wait_level_175@1563@01)))
(assert (=
  ($Snap.second $t@1566@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1566@01))
    ($Snap.second ($Snap.second $t@1566@01)))))
(assert (= ($Snap.first ($Snap.second $t@1566@01)) $Snap.unit))
; [eval] p2_33 ==> (forperm _r_60: Ref [_r_60.MustReleaseBoundedp] :: Level(_r_60) <= _current_wait_level_175_0) && ((forperm _r_60: Ref [_r_60.MustReleaseUnboundedp] :: Level(_r_60) <= _current_wait_level_175_0) && _residue_175_0 <= _current_wait_level_175_0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2488 | p2_33@1556@01 | live]
; [else-branch: 2488 | !(p2_33@1556@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2488 | p2_33@1556@01]
(assert p2_33@1556@01)
; [eval] (forperm _r_60: Ref [_r_60.MustReleaseBoundedp] :: Level(_r_60) <= _current_wait_level_175_0) && ((forperm _r_60: Ref [_r_60.MustReleaseUnboundedp] :: Level(_r_60) <= _current_wait_level_175_0) && _residue_175_0 <= _current_wait_level_175_0)
; [eval] (forperm _r_60: Ref [_r_60.MustReleaseBoundedp] :: Level(_r_60) <= _current_wait_level_175_0)
(push) ; 5
; [then-branch: 2489 | False | live]
; [else-branch: 2489 | True | live]
(push) ; 6
; [then-branch: 2489 | False]
(assert false)
(pop) ; 6
(push) ; 6
; [else-branch: 2489 | True]
; [eval] (forperm _r_60: Ref [_r_60.MustReleaseUnboundedp] :: Level(_r_60) <= _current_wait_level_175_0)
(push) ; 7
; [then-branch: 2490 | False | live]
; [else-branch: 2490 | True | live]
(push) ; 8
; [then-branch: 2490 | False]
(assert false)
(pop) ; 8
(push) ; 8
; [else-branch: 2490 | True]
; [eval] _residue_175_0 <= _current_wait_level_175_0
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 2488 | !(p2_33@1556@01)]
(assert (not p2_33@1556@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=> p2_33@1556@01 (<= _residue_175_0@1562@01 _current_wait_level_175_0@1564@01)))
(assert (=
  ($Snap.second ($Snap.second $t@1566@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1566@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1566@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1566@01))) $Snap.unit))
; [eval] p1_33 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p1_33@1555@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2491 | p1_33@1555@01 | live]
; [else-branch: 2491 | !(p1_33@1555@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2491 | p1_33@1555@01]
(assert p1_33@1555@01)
(pop) ; 4
(push) ; 4
; [else-branch: 2491 | !(p1_33@1555@01)]
(assert (not p1_33@1555@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@1566@01))) $Snap.unit))
; [eval] p2_33 ==> true
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2492 | p2_33@1556@01 | live]
; [else-branch: 2492 | !(p2_33@1556@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2492 | p2_33@1556@01]
(assert p2_33@1556@01)
(pop) ; 4
(push) ; 4
; [else-branch: 2492 | !(p2_33@1556@01)]
(assert (not p2_33@1556@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
(push) ; 2
; [exec]
; var module_defined_0: Bool
(declare-const module_defined_0@1567@01 Bool)
; [exec]
; var module_defined_0_0: Bool
(declare-const module_defined_0_0@1568@01 Bool)
; [exec]
; var module_names_0: Set[_Name]
(declare-const module_names_0@1569@01 Set<_Name>)
; [exec]
; var module_names_0_0: Set[_Name]
(declare-const module_names_0_0@1570@01 Set<_Name>)
; [exec]
; var module_defined_1: Bool
(declare-const module_defined_1@1571@01 Bool)
; [exec]
; var module_defined_1_0: Bool
(declare-const module_defined_1_0@1572@01 Bool)
; [exec]
; var module_names_1: Set[_Name]
(declare-const module_names_1@1573@01 Set<_Name>)
; [exec]
; var module_names_1_0: Set[_Name]
(declare-const module_names_1_0@1574@01 Set<_Name>)
; [exec]
; var _err: Ref
(declare-const _err@1575@01 $Ref)
; [exec]
; var _err_13: Ref
(declare-const _err_13@1576@01 $Ref)
; [exec]
; var _cwl_175: Perm
(declare-const _cwl_175@1577@01 $Perm)
; [exec]
; var _cwl_175_0: Perm
(declare-const _cwl_175_0@1578@01 $Perm)
; [exec]
; var _method_measures_175: Seq[Measure$]
(declare-const _method_measures_175@1579@01 Seq<Measure$>)
; [exec]
; var _method_measures_175_0: Seq[Measure$]
(declare-const _method_measures_175_0@1580@01 Seq<Measure$>)
; [exec]
; var p1_34: Bool
(declare-const p1_34@1581@01 Bool)
; [exec]
; var p2_34: Bool
(declare-const p2_34@1582@01 Bool)
; [exec]
; var p3_16: Bool
(declare-const p3_16@1583@01 Bool)
; [exec]
; var p4_16: Bool
(declare-const p4_16@1584@01 Bool)
; [exec]
; inhale p1_33
(declare-const $t@1585@01 $Snap)
(assert (= $t@1585@01 $Snap.unit))
(assert p1_33@1555@01)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2493 | p1_33@1555@01 | live]
; [else-branch: 2493 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 2493 | p1_33@1555@01]
; [exec]
; _method_measures_175 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; module_defined_0 := true
; [exec]
; module_names_0 := Set[_Name]()
; [eval] Set[_Name]()
; [exec]
; module_names_0 := (module_names_0 union Set(_single(6872323072689856351)))
; [eval] (module_names_0 union Set(_single(6872323072689856351)))
; [eval] Set(_single(6872323072689856351))
; [eval] _single(6872323072689856351)
(declare-const module_names_0@1586@01 Set<_Name>)
(assert (=
  module_names_0@1586@01
  (Set_union (as Set_empty  Set<_Name>) (Set_singleton (_single<_Name> 6872323072689856351)))))
; [exec]
; inhale acc(__file__()._val, 99 / 100) &&
;   (issubtype(typeof(__file__()._val), str()) &&
;   issubtype(typeof(__file__()._val), str()))
(declare-const $t@1587@01 $Snap)
(assert (= $t@1587@01 ($Snap.combine ($Snap.first $t@1587@01) ($Snap.second $t@1587@01))))
; [eval] __file__()
(push) ; 4
(assert (__file__%precondition $Snap.unit))
(pop) ; 4
; Joined path conditions
(assert (__file__%precondition $Snap.unit))
(assert (not (= (__file__ $Snap.unit) $Ref.null)))
(assert (=
  ($Snap.second $t@1587@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1587@01))
    ($Snap.second ($Snap.second $t@1587@01)))))
(assert (= ($Snap.first ($Snap.second $t@1587@01)) $Snap.unit))
; [eval] issubtype(typeof(__file__()._val), str())
; [eval] typeof(__file__()._val)
; [eval] __file__()
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] str()
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1587@01))) (as str<PyType>  PyType)))
(assert (= ($Snap.second ($Snap.second $t@1587@01)) $Snap.unit))
; [eval] issubtype(typeof(__file__()._val), str())
; [eval] typeof(__file__()._val)
; [eval] __file__()
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] str()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; module_names_0 := (module_names_0 union Set(_single(6872323076851130207)))
; [eval] (module_names_0 union Set(_single(6872323076851130207)))
; [eval] Set(_single(6872323076851130207))
; [eval] _single(6872323076851130207)
(declare-const module_names_0@1588@01 Set<_Name>)
(assert (=
  module_names_0@1588@01
  (Set_union module_names_0@1586@01 (Set_singleton (_single<_Name> 6872323076851130207)))))
; [exec]
; inhale acc(__name__()._val, 99 / 100) &&
;   (issubtype(typeof(__name__()._val), str()) &&
;   (issubtype(typeof(__name__()._val), str()) &&
;   str___eq__(str___create__(8, 6872332955275845471), __name__()._val)))
(declare-const $t@1589@01 $Snap)
(assert (= $t@1589@01 ($Snap.combine ($Snap.first $t@1589@01) ($Snap.second $t@1589@01))))
; [eval] __name__()
(set-option :timeout 0)
(push) ; 4
(assert (__name__%precondition $Snap.unit))
(pop) ; 4
; Joined path conditions
(assert (__name__%precondition $Snap.unit))
(push) ; 4
(set-option :timeout 10)
(assert (not (= (__file__ $Snap.unit) (__name__ $Snap.unit))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (not (= (__name__ $Snap.unit) $Ref.null)))
(assert (=
  ($Snap.second $t@1589@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1589@01))
    ($Snap.second ($Snap.second $t@1589@01)))))
(assert (= ($Snap.first ($Snap.second $t@1589@01)) $Snap.unit))
; [eval] issubtype(typeof(__name__()._val), str())
; [eval] typeof(__name__()._val)
; [eval] __name__()
(set-option :timeout 0)
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] str()
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1589@01))) (as str<PyType>  PyType)))
(assert (=
  ($Snap.second ($Snap.second $t@1589@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1589@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1589@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1589@01))) $Snap.unit))
; [eval] issubtype(typeof(__name__()._val), str())
; [eval] typeof(__name__()._val)
; [eval] __name__()
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] str()
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@1589@01))) $Snap.unit))
; [eval] str___eq__(str___create__(8, 6872332955275845471), __name__()._val)
; [eval] str___create__(8, 6872332955275845471)
(push) ; 4
(assert (str___create__%precondition $Snap.unit 8 6872332955275845471))
(pop) ; 4
; Joined path conditions
(assert (str___create__%precondition $Snap.unit 8 6872332955275845471))
; [eval] __name__()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] issubtype(typeof(self), str())
; [eval] typeof(self)
; [eval] str()
(push) ; 5
(assert (not (issubtype<Bool> (typeof<PyType> (str___create__ $Snap.unit 8 6872332955275845471)) (as str<PyType>  PyType))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (issubtype<Bool> (typeof<PyType> (str___create__ $Snap.unit 8 6872332955275845471)) (as str<PyType>  PyType)))
(assert (str___eq__%precondition $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1589@01))))
(pop) ; 4
; Joined path conditions
(assert (and
  (issubtype<Bool> (typeof<PyType> (str___create__ $Snap.unit 8 6872332955275845471)) (as str<PyType>  PyType))
  (str___eq__%precondition $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1589@01)))))
(assert (str___eq__ $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1589@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; module_defined_1 := false
; [exec]
; module_names_1 := Set[_Name]()
; [eval] Set[_Name]()
; [exec]
; module_names_1 := (module_names_1 union Set(_single(6872323072689856351)))
; [eval] (module_names_1 union Set(_single(6872323072689856351)))
; [eval] Set(_single(6872323072689856351))
; [eval] _single(6872323072689856351)
(declare-const module_names_1@1590@01 Set<_Name>)
(assert (=
  module_names_1@1590@01
  (Set_union (as Set_empty  Set<_Name>) (Set_singleton (_single<_Name> 6872323072689856351)))))
; [exec]
; inhale acc(__file___0()._val, 99 / 100) &&
;   (issubtype(typeof(__file___0()._val), str()) &&
;   issubtype(typeof(__file___0()._val), str()))
(declare-const $t@1591@01 $Snap)
(assert (= $t@1591@01 ($Snap.combine ($Snap.first $t@1591@01) ($Snap.second $t@1591@01))))
; [eval] __file___0()
(set-option :timeout 0)
(push) ; 4
(assert (__file___0%precondition $Snap.unit))
(pop) ; 4
; Joined path conditions
(assert (__file___0%precondition $Snap.unit))
(push) ; 4
(set-option :timeout 10)
(assert (not (= (__name__ $Snap.unit) (__file___0 $Snap.unit))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= (__file__ $Snap.unit) (__file___0 $Snap.unit))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (not (= (__file___0 $Snap.unit) $Ref.null)))
(assert (=
  ($Snap.second $t@1591@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1591@01))
    ($Snap.second ($Snap.second $t@1591@01)))))
(assert (= ($Snap.first ($Snap.second $t@1591@01)) $Snap.unit))
; [eval] issubtype(typeof(__file___0()._val), str())
; [eval] typeof(__file___0()._val)
; [eval] __file___0()
(set-option :timeout 0)
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] str()
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1591@01))) (as str<PyType>  PyType)))
(assert (= ($Snap.second ($Snap.second $t@1591@01)) $Snap.unit))
; [eval] issubtype(typeof(__file___0()._val), str())
; [eval] typeof(__file___0()._val)
; [eval] __file___0()
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] str()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; module_names_1 := (module_names_1 union Set(_single(6872323076851130207)))
; [eval] (module_names_1 union Set(_single(6872323076851130207)))
; [eval] Set(_single(6872323076851130207))
; [eval] _single(6872323076851130207)
(declare-const module_names_1@1592@01 Set<_Name>)
(assert (=
  module_names_1@1592@01
  (Set_union module_names_1@1590@01 (Set_singleton (_single<_Name> 6872323076851130207)))))
; [exec]
; inhale acc(__name___0()._val, 99 / 100) &&
;   (issubtype(typeof(__name___0()._val), str()) &&
;   (issubtype(typeof(__name___0()._val), str()) &&
;   !str___eq__(str___create__(8, 6872332955275845471), __name___0()._val)))
(declare-const $t@1593@01 $Snap)
(assert (= $t@1593@01 ($Snap.combine ($Snap.first $t@1593@01) ($Snap.second $t@1593@01))))
; [eval] __name___0()
(set-option :timeout 0)
(push) ; 4
(assert (__name___0%precondition $Snap.unit))
(pop) ; 4
; Joined path conditions
(assert (__name___0%precondition $Snap.unit))
(push) ; 4
(set-option :timeout 10)
(assert (not (= (__file___0 $Snap.unit) (__name___0 $Snap.unit))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= (__name__ $Snap.unit) (__name___0 $Snap.unit))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= (__file__ $Snap.unit) (__name___0 $Snap.unit))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (not (= (__name___0 $Snap.unit) $Ref.null)))
(assert (=
  ($Snap.second $t@1593@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1593@01))
    ($Snap.second ($Snap.second $t@1593@01)))))
(assert (= ($Snap.first ($Snap.second $t@1593@01)) $Snap.unit))
; [eval] issubtype(typeof(__name___0()._val), str())
; [eval] typeof(__name___0()._val)
; [eval] __name___0()
(set-option :timeout 0)
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] str()
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1593@01))) (as str<PyType>  PyType)))
(assert (=
  ($Snap.second ($Snap.second $t@1593@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1593@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1593@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1593@01))) $Snap.unit))
; [eval] issubtype(typeof(__name___0()._val), str())
; [eval] typeof(__name___0()._val)
; [eval] __name___0()
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] str()
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@1593@01))) $Snap.unit))
; [eval] !str___eq__(str___create__(8, 6872332955275845471), __name___0()._val)
; [eval] str___eq__(str___create__(8, 6872332955275845471), __name___0()._val)
; [eval] str___create__(8, 6872332955275845471)
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] __name___0()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] issubtype(typeof(self), str())
; [eval] typeof(self)
; [eval] str()
(assert (str___eq__%precondition $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1593@01))))
(pop) ; 4
; Joined path conditions
(assert (str___eq__%precondition $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1593@01))))
(assert (not
  (str___eq__ $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1593@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _err := null
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2494 | p2_33@1556@01 | live]
; [else-branch: 2494 | !(p2_33@1556@01) | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2494 | p2_33@1556@01]
(assert p2_33@1556@01)
; [exec]
; _method_measures_175_0 := Seq[Measure$]()
; [eval] Seq[Measure$]()
; [exec]
; module_defined_0_0 := true
; [exec]
; module_names_0_0 := Set[_Name]()
; [eval] Set[_Name]()
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(6872323072689856351)))
; [eval] (module_names_0_0 union Set(_single(6872323072689856351)))
; [eval] Set(_single(6872323072689856351))
; [eval] _single(6872323072689856351)
(declare-const module_names_0_0@1594@01 Set<_Name>)
(assert (=
  module_names_0_0@1594@01
  (Set_union (as Set_empty  Set<_Name>) (Set_singleton (_single<_Name> 6872323072689856351)))))
; [exec]
; inhale acc(__file__()._valp, 99 / 100) &&
;   (issubtype(typeof(__file__()._valp), str()) &&
;   issubtype(typeof(__file__()._valp), str()))
(declare-const $t@1595@01 $Snap)
(assert (= $t@1595@01 ($Snap.combine ($Snap.first $t@1595@01) ($Snap.second $t@1595@01))))
; [eval] __file__()
(push) ; 5
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second $t@1595@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1595@01))
    ($Snap.second ($Snap.second $t@1595@01)))))
(assert (= ($Snap.first ($Snap.second $t@1595@01)) $Snap.unit))
; [eval] issubtype(typeof(__file__()._valp), str())
; [eval] typeof(__file__()._valp)
; [eval] __file__()
(push) ; 5
(pop) ; 5
; Joined path conditions
; [eval] str()
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1595@01))) (as str<PyType>  PyType)))
(assert (= ($Snap.second ($Snap.second $t@1595@01)) $Snap.unit))
; [eval] issubtype(typeof(__file__()._valp), str())
; [eval] typeof(__file__()._valp)
; [eval] __file__()
(push) ; 5
(pop) ; 5
; Joined path conditions
; [eval] str()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(6872323076851130207)))
; [eval] (module_names_0_0 union Set(_single(6872323076851130207)))
; [eval] Set(_single(6872323076851130207))
; [eval] _single(6872323076851130207)
(declare-const module_names_0_0@1596@01 Set<_Name>)
(assert (=
  module_names_0_0@1596@01
  (Set_union module_names_0_0@1594@01 (Set_singleton (_single<_Name> 6872323076851130207)))))
; [exec]
; inhale acc(__name__()._valp, 99 / 100) &&
;   (issubtype(typeof(__name__()._valp), str()) &&
;   (issubtype(typeof(__name__()._valp), str()) &&
;   str___eq__(str___create__(8, 6872332955275845471), __name__()._valp)))
(declare-const $t@1597@01 $Snap)
(assert (= $t@1597@01 ($Snap.combine ($Snap.first $t@1597@01) ($Snap.second $t@1597@01))))
; [eval] __name__()
(set-option :timeout 0)
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (= (__file__ $Snap.unit) (__name__ $Snap.unit))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=
  ($Snap.second $t@1597@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1597@01))
    ($Snap.second ($Snap.second $t@1597@01)))))
(assert (= ($Snap.first ($Snap.second $t@1597@01)) $Snap.unit))
; [eval] issubtype(typeof(__name__()._valp), str())
; [eval] typeof(__name__()._valp)
; [eval] __name__()
(set-option :timeout 0)
(push) ; 5
(pop) ; 5
; Joined path conditions
; [eval] str()
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1597@01))) (as str<PyType>  PyType)))
(assert (=
  ($Snap.second ($Snap.second $t@1597@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1597@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1597@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1597@01))) $Snap.unit))
; [eval] issubtype(typeof(__name__()._valp), str())
; [eval] typeof(__name__()._valp)
; [eval] __name__()
(push) ; 5
(pop) ; 5
; Joined path conditions
; [eval] str()
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@1597@01))) $Snap.unit))
; [eval] str___eq__(str___create__(8, 6872332955275845471), __name__()._valp)
; [eval] str___create__(8, 6872332955275845471)
(push) ; 5
(pop) ; 5
; Joined path conditions
; [eval] __name__()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] issubtype(typeof(self), str())
; [eval] typeof(self)
; [eval] str()
(assert (str___eq__%precondition $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1597@01))))
(pop) ; 5
; Joined path conditions
(assert (str___eq__%precondition $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1597@01))))
(assert (str___eq__ $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1597@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; module_defined_1_0 := false
; [exec]
; module_names_1_0 := Set[_Name]()
; [eval] Set[_Name]()
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(6872323072689856351)))
; [eval] (module_names_1_0 union Set(_single(6872323072689856351)))
; [eval] Set(_single(6872323072689856351))
; [eval] _single(6872323072689856351)
(declare-const module_names_1_0@1598@01 Set<_Name>)
(assert (=
  module_names_1_0@1598@01
  (Set_union (as Set_empty  Set<_Name>) (Set_singleton (_single<_Name> 6872323072689856351)))))
; [exec]
; inhale acc(__file___0()._valp, 99 / 100) &&
;   (issubtype(typeof(__file___0()._valp), str()) &&
;   issubtype(typeof(__file___0()._valp), str()))
(declare-const $t@1599@01 $Snap)
(assert (= $t@1599@01 ($Snap.combine ($Snap.first $t@1599@01) ($Snap.second $t@1599@01))))
; [eval] __file___0()
(set-option :timeout 0)
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (= (__name__ $Snap.unit) (__file___0 $Snap.unit))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= (__file__ $Snap.unit) (__file___0 $Snap.unit))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=
  ($Snap.second $t@1599@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1599@01))
    ($Snap.second ($Snap.second $t@1599@01)))))
(assert (= ($Snap.first ($Snap.second $t@1599@01)) $Snap.unit))
; [eval] issubtype(typeof(__file___0()._valp), str())
; [eval] typeof(__file___0()._valp)
; [eval] __file___0()
(set-option :timeout 0)
(push) ; 5
(pop) ; 5
; Joined path conditions
; [eval] str()
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1599@01))) (as str<PyType>  PyType)))
(assert (= ($Snap.second ($Snap.second $t@1599@01)) $Snap.unit))
; [eval] issubtype(typeof(__file___0()._valp), str())
; [eval] typeof(__file___0()._valp)
; [eval] __file___0()
(push) ; 5
(pop) ; 5
; Joined path conditions
; [eval] str()
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(6872323076851130207)))
; [eval] (module_names_1_0 union Set(_single(6872323076851130207)))
; [eval] Set(_single(6872323076851130207))
; [eval] _single(6872323076851130207)
(declare-const module_names_1_0@1600@01 Set<_Name>)
(assert (=
  module_names_1_0@1600@01
  (Set_union module_names_1_0@1598@01 (Set_singleton (_single<_Name> 6872323076851130207)))))
; [exec]
; inhale acc(__name___0()._valp, 99 / 100) &&
;   (issubtype(typeof(__name___0()._valp), str()) &&
;   (issubtype(typeof(__name___0()._valp), str()) &&
;   !str___eq__(str___create__(8, 6872332955275845471), __name___0()._valp)))
(declare-const $t@1601@01 $Snap)
(assert (= $t@1601@01 ($Snap.combine ($Snap.first $t@1601@01) ($Snap.second $t@1601@01))))
; [eval] __name___0()
(set-option :timeout 0)
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (= (__file___0 $Snap.unit) (__name___0 $Snap.unit))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= (__name__ $Snap.unit) (__name___0 $Snap.unit))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= (__file__ $Snap.unit) (__name___0 $Snap.unit))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=
  ($Snap.second $t@1601@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@1601@01))
    ($Snap.second ($Snap.second $t@1601@01)))))
(assert (= ($Snap.first ($Snap.second $t@1601@01)) $Snap.unit))
; [eval] issubtype(typeof(__name___0()._valp), str())
; [eval] typeof(__name___0()._valp)
; [eval] __name___0()
(set-option :timeout 0)
(push) ; 5
(pop) ; 5
; Joined path conditions
; [eval] str()
(assert (issubtype<Bool> (typeof<PyType> ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1601@01))) (as str<PyType>  PyType)))
(assert (=
  ($Snap.second ($Snap.second $t@1601@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@1601@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@1601@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@1601@01))) $Snap.unit))
; [eval] issubtype(typeof(__name___0()._valp), str())
; [eval] typeof(__name___0()._valp)
; [eval] __name___0()
(push) ; 5
(pop) ; 5
; Joined path conditions
; [eval] str()
(assert (= ($Snap.second ($Snap.second ($Snap.second $t@1601@01))) $Snap.unit))
; [eval] !str___eq__(str___create__(8, 6872332955275845471), __name___0()._valp)
; [eval] str___eq__(str___create__(8, 6872332955275845471), __name___0()._valp)
; [eval] str___create__(8, 6872332955275845471)
(push) ; 5
(pop) ; 5
; Joined path conditions
; [eval] __name___0()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] issubtype(typeof(self), str())
; [eval] typeof(self)
; [eval] str()
(assert (str___eq__%precondition $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1601@01))))
(pop) ; 5
; Joined path conditions
(assert (str___eq__%precondition $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1601@01))))
(assert (not
  (str___eq__ $Snap.unit (str___create__ $Snap.unit 8 6872332955275845471) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@1601@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _err_13 := null
; [exec]
; p1_34 := p1_33 && !module_defined_1
; [eval] p1_33 && !module_defined_1
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2495 | !(p1_33@1555@01) | live]
; [else-branch: 2495 | p1_33@1555@01 | live]
(push) ; 6
; [then-branch: 2495 | !(p1_33@1555@01)]
(assert (not p1_33@1555@01))
(pop) ; 6
(push) ; 6
; [else-branch: 2495 | p1_33@1555@01]
; [eval] !module_defined_1
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or p1_33@1555@01 (not p1_33@1555@01)))
; [exec]
; p2_34 := p2_33 && !module_defined_1_0
; [eval] p2_33 && !module_defined_1_0
(push) ; 5
; [then-branch: 2496 | !(p2_33@1556@01) | live]
; [else-branch: 2496 | p2_33@1556@01 | live]
(push) ; 6
; [then-branch: 2496 | !(p2_33@1556@01)]
(assert (not p2_33@1556@01))
(pop) ; 6
(push) ; 6
; [else-branch: 2496 | p2_33@1556@01]
; [eval] !module_defined_1_0
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or p2_33@1556@01 (not p2_33@1556@01)))
; [exec]
; p3_16 := p1_33 && !!module_defined_1
; [eval] p1_33 && !!module_defined_1
(push) ; 5
; [then-branch: 2497 | !(p1_33@1555@01) | live]
; [else-branch: 2497 | p1_33@1555@01 | live]
(push) ; 6
; [then-branch: 2497 | !(p1_33@1555@01)]
(assert (not p1_33@1555@01))
(pop) ; 6
(push) ; 6
; [else-branch: 2497 | p1_33@1555@01]
; [eval] !!module_defined_1
; [eval] !module_defined_1
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
; [exec]
; p4_16 := p2_33 && !!module_defined_1_0
; [eval] p2_33 && !!module_defined_1_0
(push) ; 5
; [then-branch: 2498 | !(p2_33@1556@01) | live]
; [else-branch: 2498 | p2_33@1556@01 | live]
(push) ; 6
; [then-branch: 2498 | !(p2_33@1556@01)]
(assert (not p2_33@1556@01))
(pop) ; 6
(push) ; 6
; [else-branch: 2498 | p2_33@1556@01]
; [eval] !!module_defined_1_0
; [eval] !module_defined_1_0
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2499 | p1_33@1555@01 | live]
; [else-branch: 2499 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2499 | p1_33@1555@01]
; [exec]
; module_defined_1 := true
; [exec]
; module_names_1 := (module_names_1 union Set(_single(27981962743276871)))
; [eval] (module_names_1 union Set(_single(27981962743276871)))
; [eval] Set(_single(27981962743276871))
; [eval] _single(27981962743276871)
(declare-const module_names_1@1602@01 Set<_Name>)
(assert (=
  module_names_1@1602@01
  (Set_union module_names_1@1592@01 (Set_singleton (_single<_Name> 27981962743276871)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(7809644653626814543)))
; [eval] (module_names_1 union Set(_single(7809644653626814543)))
; [eval] Set(_single(7809644653626814543))
; [eval] _single(7809644653626814543)
(declare-const module_names_1@1603@01 Set<_Name>)
(assert (=
  module_names_1@1603@01
  (Set_union module_names_1@1602@01 (Set_singleton (_single<_Name> 7809644653626814543)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(32195171041966420)))
; [eval] (module_names_1 union Set(_single(32195171041966420)))
; [eval] Set(_single(32195171041966420))
; [eval] _single(32195171041966420)
(declare-const module_names_1@1604@01 Set<_Name>)
(assert (=
  module_names_1@1604@01
  (Set_union module_names_1@1603@01 (Set_singleton (_single<_Name> 32195171041966420)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(37578771102893684825896415043)))
; [eval] (module_names_1 union Set(_single(37578771102893684825896415043)))
; [eval] Set(_single(37578771102893684825896415043))
; [eval] _single(37578771102893684825896415043)
(declare-const module_names_1@1605@01 Set<_Name>)
(assert (=
  module_names_1@1605@01
  (Set_union module_names_1@1604@01 (Set_singleton (_single<_Name> 37578771102893684825896415043)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(32481164592901701)))
; [eval] (module_names_1 union Set(_single(32481164592901701)))
; [eval] Set(_single(32481164592901701))
; [eval] _single(32481164592901701)
(declare-const module_names_1@1606@01 Set<_Name>)
(assert (=
  module_names_1@1606@01
  (Set_union module_names_1@1605@01 (Set_singleton (_single<_Name> 32481164592901701)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(32481125787004233)))
; [eval] (module_names_1 union Set(_single(32481125787004233)))
; [eval] Set(_single(32481125787004233))
; [eval] _single(32481125787004233)
(declare-const module_names_1@1607@01 Set<_Name>)
(assert (=
  module_names_1@1607@01
  (Set_union module_names_1@1606@01 (Set_singleton (_single<_Name> 32481125787004233)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(7827276)))
; [eval] (module_names_1 union Set(_single(7827276)))
; [eval] Set(_single(7827276))
; [eval] _single(7827276)
(declare-const module_names_1@1608@01 Set<_Name>)
(assert (=
  module_names_1@1608@01
  (Set_union module_names_1@1607@01 (Set_singleton (_single<_Name> 7827276)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(8389754714483814220)))
; [eval] (module_names_1 union Set(_single(8389754714483814220)))
; [eval] Set(_single(8389754714483814220))
; [eval] _single(8389754714483814220)
(declare-const module_names_1@1609@01 Set<_Name>)
(assert (=
  module_names_1@1609@01
  (Set_union module_names_1@1608@01 (Set_singleton (_single<_Name> 8389754714483814220)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(1871507244730112373328)))
; [eval] (module_names_1 union Set(_single(1871507244730112373328)))
; [eval] Set(_single(1871507244730112373328))
; [eval] _single(1871507244730112373328)
(declare-const module_names_1@1610@01 Set<_Name>)
(assert (=
  module_names_1@1610@01
  (Set_union module_names_1@1609@01 (Set_singleton (_single<_Name> 1871507244730112373328)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(1701999952)))
; [eval] (module_names_1 union Set(_single(1701999952)))
; [eval] Set(_single(1701999952))
; [eval] _single(1701999952)
(declare-const module_names_1@1611@01 Set<_Name>)
(assert (=
  module_names_1@1611@01
  (Set_union module_names_1@1610@01 (Set_singleton (_single<_Name> 1701999952)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(8315178084276987218)))
; [eval] (module_names_1 union Set(_single(8315178084276987218)))
; [eval] Set(_single(8315178084276987218))
; [eval] _single(8315178084276987218)
(declare-const module_names_1@1612@01 Set<_Name>)
(assert (=
  module_names_1@1612@01
  (Set_union module_names_1@1611@01 (Set_singleton (_single<_Name> 8315178084276987218)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(7738150958662902082)))
; [eval] (module_names_1 union Set(_single(7738150958662902082)))
; [eval] Set(_single(7738150958662902082))
; [eval] _single(7738150958662902082)
(declare-const module_names_1@1613@01 Set<_Name>)
(assert (=
  module_names_1@1613@01
  (Set_union module_names_1@1612@01 (Set_singleton (_single<_Name> 7738150958662902082)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(465558725964)))
; [eval] (module_names_1 union Set(_single(465558725964)))
; [eval] Set(_single(465558725964))
; [eval] _single(465558725964)
(declare-const module_names_1@1614@01 Set<_Name>)
(assert (=
  module_names_1@1614@01
  (Set_union module_names_1@1613@01 (Set_singleton (_single<_Name> 465558725964)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(122646376569110405802325325)))
; [eval] (module_names_1 union Set(_single(122646376569110405802325325)))
; [eval] Set(_single(122646376569110405802325325))
; [eval] _single(122646376569110405802325325)
(declare-const module_names_1@1615@01 Set<_Name>)
(assert (=
  module_names_1@1615@01
  (Set_union module_names_1@1614@01 (Set_singleton (_single<_Name> 122646376569110405802325325)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(8038062462289584464661321053517)))
; [eval] (module_names_1 union Set(_single(8038062462289584464661321053517)))
; [eval] Set(_single(8038062462289584464661321053517))
; [eval] _single(8038062462289584464661321053517)
(declare-const module_names_1@1616@01 Set<_Name>)
(assert (=
  module_names_1@1616@01
  (Set_union module_names_1@1615@01 (Set_singleton (_single<_Name> 8038062462289584464661321053517)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(1999559502384759136599)))
; [eval] (module_names_1 union Set(_single(1999559502384759136599)))
; [eval] Set(_single(1999559502384759136599))
; [eval] _single(1999559502384759136599)
(declare-const module_names_1@1617@01 Set<_Name>)
(assert (=
  module_names_1@1617@01
  (Set_union module_names_1@1616@01 (Set_singleton (_single<_Name> 1999559502384759136599)))))
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2500 | p2_33@1556@01 | live]
; [else-branch: 2500 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2500 | p2_33@1556@01]
; [exec]
; module_defined_1_0 := true
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(27981962743276871)))
; [eval] (module_names_1_0 union Set(_single(27981962743276871)))
; [eval] Set(_single(27981962743276871))
; [eval] _single(27981962743276871)
(declare-const module_names_1_0@1618@01 Set<_Name>)
(assert (=
  module_names_1_0@1618@01
  (Set_union module_names_1_0@1600@01 (Set_singleton (_single<_Name> 27981962743276871)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(7809644653626814543)))
; [eval] (module_names_1_0 union Set(_single(7809644653626814543)))
; [eval] Set(_single(7809644653626814543))
; [eval] _single(7809644653626814543)
(declare-const module_names_1_0@1619@01 Set<_Name>)
(assert (=
  module_names_1_0@1619@01
  (Set_union module_names_1_0@1618@01 (Set_singleton (_single<_Name> 7809644653626814543)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(32195171041966420)))
; [eval] (module_names_1_0 union Set(_single(32195171041966420)))
; [eval] Set(_single(32195171041966420))
; [eval] _single(32195171041966420)
(declare-const module_names_1_0@1620@01 Set<_Name>)
(assert (=
  module_names_1_0@1620@01
  (Set_union module_names_1_0@1619@01 (Set_singleton (_single<_Name> 32195171041966420)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(37578771102893684825896415043)))
; [eval] (module_names_1_0 union Set(_single(37578771102893684825896415043)))
; [eval] Set(_single(37578771102893684825896415043))
; [eval] _single(37578771102893684825896415043)
(declare-const module_names_1_0@1621@01 Set<_Name>)
(assert (=
  module_names_1_0@1621@01
  (Set_union module_names_1_0@1620@01 (Set_singleton (_single<_Name> 37578771102893684825896415043)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(32481164592901701)))
; [eval] (module_names_1_0 union Set(_single(32481164592901701)))
; [eval] Set(_single(32481164592901701))
; [eval] _single(32481164592901701)
(declare-const module_names_1_0@1622@01 Set<_Name>)
(assert (=
  module_names_1_0@1622@01
  (Set_union module_names_1_0@1621@01 (Set_singleton (_single<_Name> 32481164592901701)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(32481125787004233)))
; [eval] (module_names_1_0 union Set(_single(32481125787004233)))
; [eval] Set(_single(32481125787004233))
; [eval] _single(32481125787004233)
(declare-const module_names_1_0@1623@01 Set<_Name>)
(assert (=
  module_names_1_0@1623@01
  (Set_union module_names_1_0@1622@01 (Set_singleton (_single<_Name> 32481125787004233)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union Set(_single(7827276)))
; [eval] (module_names_1_0 union Set(_single(7827276)))
; [eval] Set(_single(7827276))
; [eval] _single(7827276)
(declare-const module_names_1_0@1624@01 Set<_Name>)
(assert (=
  module_names_1_0@1624@01
  (Set_union module_names_1_0@1623@01 (Set_singleton (_single<_Name> 7827276)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(8389754714483814220)))
; [eval] (module_names_1_0 union Set(_single(8389754714483814220)))
; [eval] Set(_single(8389754714483814220))
; [eval] _single(8389754714483814220)
(declare-const module_names_1_0@1625@01 Set<_Name>)
(assert (=
  module_names_1_0@1625@01
  (Set_union module_names_1_0@1624@01 (Set_singleton (_single<_Name> 8389754714483814220)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(1871507244730112373328)))
; [eval] (module_names_1_0 union Set(_single(1871507244730112373328)))
; [eval] Set(_single(1871507244730112373328))
; [eval] _single(1871507244730112373328)
(declare-const module_names_1_0@1626@01 Set<_Name>)
(assert (=
  module_names_1_0@1626@01
  (Set_union module_names_1_0@1625@01 (Set_singleton (_single<_Name> 1871507244730112373328)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union Set(_single(1701999952)))
; [eval] (module_names_1_0 union Set(_single(1701999952)))
; [eval] Set(_single(1701999952))
; [eval] _single(1701999952)
(declare-const module_names_1_0@1627@01 Set<_Name>)
(assert (=
  module_names_1_0@1627@01
  (Set_union module_names_1_0@1626@01 (Set_singleton (_single<_Name> 1701999952)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(8315178084276987218)))
; [eval] (module_names_1_0 union Set(_single(8315178084276987218)))
; [eval] Set(_single(8315178084276987218))
; [eval] _single(8315178084276987218)
(declare-const module_names_1_0@1628@01 Set<_Name>)
(assert (=
  module_names_1_0@1628@01
  (Set_union module_names_1_0@1627@01 (Set_singleton (_single<_Name> 8315178084276987218)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(7738150958662902082)))
; [eval] (module_names_1_0 union Set(_single(7738150958662902082)))
; [eval] Set(_single(7738150958662902082))
; [eval] _single(7738150958662902082)
(declare-const module_names_1_0@1629@01 Set<_Name>)
(assert (=
  module_names_1_0@1629@01
  (Set_union module_names_1_0@1628@01 (Set_singleton (_single<_Name> 7738150958662902082)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union Set(_single(465558725964)))
; [eval] (module_names_1_0 union Set(_single(465558725964)))
; [eval] Set(_single(465558725964))
; [eval] _single(465558725964)
(declare-const module_names_1_0@1630@01 Set<_Name>)
(assert (=
  module_names_1_0@1630@01
  (Set_union module_names_1_0@1629@01 (Set_singleton (_single<_Name> 465558725964)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(122646376569110405802325325)))
; [eval] (module_names_1_0 union Set(_single(122646376569110405802325325)))
; [eval] Set(_single(122646376569110405802325325))
; [eval] _single(122646376569110405802325325)
(declare-const module_names_1_0@1631@01 Set<_Name>)
(assert (=
  module_names_1_0@1631@01
  (Set_union module_names_1_0@1630@01 (Set_singleton (_single<_Name> 122646376569110405802325325)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(8038062462289584464661321053517)))
; [eval] (module_names_1_0 union Set(_single(8038062462289584464661321053517)))
; [eval] Set(_single(8038062462289584464661321053517))
; [eval] _single(8038062462289584464661321053517)
(declare-const module_names_1_0@1632@01 Set<_Name>)
(assert (=
  module_names_1_0@1632@01
  (Set_union module_names_1_0@1631@01 (Set_singleton (_single<_Name> 8038062462289584464661321053517)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(1999559502384759136599)))
; [eval] (module_names_1_0 union Set(_single(1999559502384759136599)))
; [eval] Set(_single(1999559502384759136599))
; [eval] _single(1999559502384759136599)
(declare-const module_names_1_0@1633@01 Set<_Name>)
(assert (=
  module_names_1_0@1633@01
  (Set_union module_names_1_0@1632@01 (Set_singleton (_single<_Name> 1999559502384759136599)))))
; [exec]
; assert (p1_34 ==> true) &&
;   ((p2_34 ==> true) &&
;   ((p1_34 ==> (_single(7738150958662902082) in module_names_1)) &&
;   (p2_34 ==> (_single(7738150958662902082) in module_names_1_0)) &&
;   ((p1_34 ==> (_single(7738150958662902082) in module_names_1)) &&
;   (p2_34 ==> (_single(7738150958662902082) in module_names_1_0)))))
; [eval] p1_34 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2501 | p1_33@1555@01 | live]
; [else-branch: 2501 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2501 | p1_33@1555@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p2_34 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2502 | p2_33@1556@01 | live]
; [else-branch: 2502 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2502 | p2_33@1556@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p1_34 ==> (_single(7738150958662902082) in module_names_1)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2503 | p1_33@1555@01 | live]
; [else-branch: 2503 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2503 | p1_33@1555@01]
; [eval] (_single(7738150958662902082) in module_names_1)
; [eval] _single(7738150958662902082)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (=>
  p1_33@1555@01
  (Set_in (_single<_Name> 7738150958662902082) module_names_1@1617@01))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_33@1555@01
  (Set_in (_single<_Name> 7738150958662902082) module_names_1@1617@01)))
; [eval] p2_34 ==> (_single(7738150958662902082) in module_names_1_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2504 | p2_33@1556@01 | live]
; [else-branch: 2504 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2504 | p2_33@1556@01]
; [eval] (_single(7738150958662902082) in module_names_1_0)
; [eval] _single(7738150958662902082)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (=>
  p2_33@1556@01
  (Set_in (_single<_Name> 7738150958662902082) module_names_1_0@1633@01))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p2_33@1556@01
  (Set_in (_single<_Name> 7738150958662902082) module_names_1_0@1633@01)))
; [eval] p1_34 ==> (_single(7738150958662902082) in module_names_1)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2505 | p1_33@1555@01 | live]
; [else-branch: 2505 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2505 | p1_33@1555@01]
; [eval] (_single(7738150958662902082) in module_names_1)
; [eval] _single(7738150958662902082)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p2_34 ==> (_single(7738150958662902082) in module_names_1_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2506 | p2_33@1556@01 | live]
; [else-branch: 2506 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2506 | p2_33@1556@01]
; [eval] (_single(7738150958662902082) in module_names_1_0)
; [eval] _single(7738150958662902082)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [exec]
; assert (p1_34 ==> true) &&
;   ((p2_34 ==> true) &&
;   ((p1_34 ==> (_single(7738150958662902082) in module_names_1)) &&
;   (p2_34 ==> (_single(7738150958662902082) in module_names_1_0))))
; [eval] p1_34 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2507 | p1_33@1555@01 | live]
; [else-branch: 2507 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2507 | p1_33@1555@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p2_34 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2508 | p2_33@1556@01 | live]
; [else-branch: 2508 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2508 | p2_33@1556@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p1_34 ==> (_single(7738150958662902082) in module_names_1)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2509 | p1_33@1555@01 | live]
; [else-branch: 2509 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2509 | p1_33@1555@01]
; [eval] (_single(7738150958662902082) in module_names_1)
; [eval] _single(7738150958662902082)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p2_34 ==> (_single(7738150958662902082) in module_names_1_0)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2510 | p2_33@1556@01 | live]
; [else-branch: 2510 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2510 | p2_33@1556@01]
; [eval] (_single(7738150958662902082) in module_names_1_0)
; [eval] _single(7738150958662902082)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2511 | p1_33@1555@01 | live]
; [else-branch: 2511 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2511 | p1_33@1555@01]
; [exec]
; module_names_1 := (module_names_1 union Set(_single(6872339552563453791)))
; [eval] (module_names_1 union Set(_single(6872339552563453791)))
; [eval] Set(_single(6872339552563453791))
; [eval] _single(6872339552563453791)
(declare-const module_names_1@1634@01 Set<_Name>)
(assert (=
  module_names_1@1634@01
  (Set_union module_names_1@1617@01 (Set_singleton (_single<_Name> 6872339552563453791)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(474107507589505187341671)))
; [eval] (module_names_1 union Set(_single(474107507589505187341671)))
; [eval] Set(_single(474107507589505187341671))
; [eval] _single(474107507589505187341671)
(declare-const module_names_1@1635@01 Set<_Name>)
(assert (=
  module_names_1@1635@01
  (Set_union module_names_1@1634@01 (Set_singleton (_single<_Name> 474107507589505187341671)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(28554769915274081)))
; [eval] (module_names_1 union Set(_single(28554769915274081)))
; [eval] Set(_single(28554769915274081))
; [eval] _single(28554769915274081)
(declare-const module_names_1@1636@01 Set<_Name>)
(assert (=
  module_names_1@1636@01
  (Set_union module_names_1@1635@01 (Set_singleton (_single<_Name> 28554769915274081)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(28555834798400882)))
; [eval] (module_names_1 union Set(_single(28555834798400882)))
; [eval] Set(_single(28555834798400882))
; [eval] _single(28555834798400882)
(declare-const module_names_1@1637@01 Set<_Name>)
(assert (=
  module_names_1@1637@01
  (Set_union module_names_1@1636@01 (Set_singleton (_single<_Name> 28555834798400882)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(1801678668)))
; [eval] (module_names_1 union Set(_single(1801678668)))
; [eval] Set(_single(1801678668))
; [eval] _single(1801678668)
(declare-const module_names_1@1638@01 Set<_Name>)
(assert (=
  module_names_1@1638@01
  (Set_union module_names_1@1637@01 (Set_singleton (_single<_Name> 1801678668)))))
(push) ; 8
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2512 | p2_33@1556@01 | live]
; [else-branch: 2512 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2512 | p2_33@1556@01]
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(6872339552563453791)))
; [eval] (module_names_1_0 union Set(_single(6872339552563453791)))
; [eval] Set(_single(6872339552563453791))
; [eval] _single(6872339552563453791)
(declare-const module_names_1_0@1639@01 Set<_Name>)
(assert (=
  module_names_1_0@1639@01
  (Set_union module_names_1_0@1633@01 (Set_singleton (_single<_Name> 6872339552563453791)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(474107507589505187341671)))
; [eval] (module_names_1_0 union Set(_single(474107507589505187341671)))
; [eval] Set(_single(474107507589505187341671))
; [eval] _single(474107507589505187341671)
(declare-const module_names_1_0@1640@01 Set<_Name>)
(assert (=
  module_names_1_0@1640@01
  (Set_union module_names_1_0@1639@01 (Set_singleton (_single<_Name> 474107507589505187341671)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(28554769915274081)))
; [eval] (module_names_1_0 union Set(_single(28554769915274081)))
; [eval] Set(_single(28554769915274081))
; [eval] _single(28554769915274081)
(declare-const module_names_1_0@1641@01 Set<_Name>)
(assert (=
  module_names_1_0@1641@01
  (Set_union module_names_1_0@1640@01 (Set_singleton (_single<_Name> 28554769915274081)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union
;   Set(_single(28555834798400882)))
; [eval] (module_names_1_0 union Set(_single(28555834798400882)))
; [eval] Set(_single(28555834798400882))
; [eval] _single(28555834798400882)
(declare-const module_names_1_0@1642@01 Set<_Name>)
(assert (=
  module_names_1_0@1642@01
  (Set_union module_names_1_0@1641@01 (Set_singleton (_single<_Name> 28555834798400882)))))
; [exec]
; module_names_1_0 := (module_names_1_0 union Set(_single(1801678668)))
; [eval] (module_names_1_0 union Set(_single(1801678668)))
; [eval] Set(_single(1801678668))
; [eval] _single(1801678668)
(declare-const module_names_1_0@1643@01 Set<_Name>)
(assert (=
  module_names_1_0@1643@01
  (Set_union module_names_1_0@1642@01 (Set_singleton (_single<_Name> 1801678668)))))
; [exec]
; assert (p1_33 ==> (_single(1801678668) in module_names_1)) &&
;   (p2_33 ==> (_single(1801678668) in module_names_1_0))
; [eval] p1_33 ==> (_single(1801678668) in module_names_1)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2513 | p1_33@1555@01 | live]
; [else-branch: 2513 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2513 | p1_33@1555@01]
; [eval] (_single(1801678668) in module_names_1)
; [eval] _single(1801678668)
(pop) ; 10
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_1@1638@01))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_1@1638@01)))
; [eval] p2_33 ==> (_single(1801678668) in module_names_1_0)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2514 | p2_33@1556@01 | live]
; [else-branch: 2514 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2514 | p2_33@1556@01]
; [eval] (_single(1801678668) in module_names_1_0)
; [eval] _single(1801678668)
(pop) ; 10
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (=> p2_33@1556@01 (Set_in (_single<_Name> 1801678668) module_names_1_0@1643@01))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_33@1556@01 (Set_in (_single<_Name> 1801678668) module_names_1_0@1643@01)))
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2515 | p1_33@1555@01 | live]
; [else-branch: 2515 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2515 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union Set(_single(1801678668)))
; [eval] (module_names_0 union Set(_single(1801678668)))
; [eval] Set(_single(1801678668))
; [eval] _single(1801678668)
(declare-const module_names_0@1644@01 Set<_Name>)
(assert (=
  module_names_0@1644@01
  (Set_union module_names_0@1588@01 (Set_singleton (_single<_Name> 1801678668)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(110369476601940)))
; [eval] (module_names_0 union Set(_single(110369476601940)))
; [eval] Set(_single(110369476601940))
; [eval] _single(110369476601940)
(declare-const module_names_0@1645@01 Set<_Name>)
(assert (=
  module_names_0@1645@01
  (Set_union module_names_0@1644@01 (Set_singleton (_single<_Name> 110369476601940)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(8390876207989219661)))
; [eval] (module_names_0 union Set(_single(8390876207989219661)))
; [eval] Set(_single(8390876207989219661))
; [eval] _single(8390876207989219661)
(declare-const module_names_0@1646@01 Set<_Name>)
(assert (=
  module_names_0@1646@01
  (Set_union module_names_0@1645@01 (Set_singleton (_single<_Name> 8390876207989219661)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(113740422079847)))
; [eval] (module_names_0 union Set(_single(113740422079847)))
; [eval] Set(_single(113740422079847))
; [eval] _single(113740422079847)
(declare-const module_names_0@1647@01 Set<_Name>)
(assert (=
  module_names_0@1647@01
  (Set_union module_names_0@1646@01 (Set_singleton (_single<_Name> 113740422079847)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(1852702201685183063399)))
; [eval] (module_names_0 union Set(_single(1852702201685183063399)))
; [eval] Set(_single(1852702201685183063399))
; [eval] _single(1852702201685183063399)
(declare-const module_names_0@1648@01 Set<_Name>)
(assert (=
  module_names_0@1648@01
  (Set_union module_names_0@1647@01 (Set_singleton (_single<_Name> 1852702201685183063399)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(7308324465919225674)))
; [eval] (module_names_0 union Set(_single(7308324465919225674)))
; [eval] Set(_single(7308324465919225674))
; [eval] _single(7308324465919225674)
(declare-const module_names_0@1649@01 Set<_Name>)
(assert (=
  module_names_0@1649@01
  (Set_union module_names_0@1648@01 (Set_singleton (_single<_Name> 7308324465919225674)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(549923908602661266679892)))
; [eval] (module_names_0 union Set(_single(549923908602661266679892)))
; [eval] Set(_single(549923908602661266679892))
; [eval] _single(549923908602661266679892)
(declare-const module_names_0@1650@01 Set<_Name>)
(assert (=
  module_names_0@1650@01
  (Set_union module_names_0@1649@01 (Set_singleton (_single<_Name> 549923908602661266679892)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(110416352273767)))
; [eval] (module_names_0 union Set(_single(110416352273767)))
; [eval] Set(_single(110416352273767))
; [eval] _single(110416352273767)
(declare-const module_names_0@1651@01 Set<_Name>)
(assert (=
  module_names_0@1651@01
  (Set_union module_names_0@1650@01 (Set_singleton (_single<_Name> 110416352273767)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(6779489)))
; [eval] (module_names_0 union Set(_single(6779489)))
; [eval] Set(_single(6779489))
; [eval] _single(6779489)
(declare-const module_names_0@1652@01 Set<_Name>)
(assert (=
  module_names_0@1652@01
  (Set_union module_names_0@1651@01 (Set_singleton (_single<_Name> 6779489)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(8038062462289584464661321053517)))
; [eval] (module_names_0 union Set(_single(8038062462289584464661321053517)))
; [eval] Set(_single(8038062462289584464661321053517))
; [eval] _single(8038062462289584464661321053517)
(declare-const module_names_0@1653@01 Set<_Name>)
(assert (=
  module_names_0@1653@01
  (Set_union module_names_0@1652@01 (Set_singleton (_single<_Name> 8038062462289584464661321053517)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(1999559502384759136599)))
; [eval] (module_names_0 union Set(_single(1999559502384759136599)))
; [eval] Set(_single(1999559502384759136599))
; [eval] _single(1999559502384759136599)
(declare-const module_names_0@1654@01 Set<_Name>)
(assert (=
  module_names_0@1654@01
  (Set_union module_names_0@1653@01 (Set_singleton (_single<_Name> 1999559502384759136599)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(465558725964)))
; [eval] (module_names_0 union Set(_single(465558725964)))
; [eval] Set(_single(465558725964))
; [eval] _single(465558725964)
(declare-const module_names_0@1655@01 Set<_Name>)
(assert (=
  module_names_0@1655@01
  (Set_union module_names_0@1654@01 (Set_singleton (_single<_Name> 465558725964)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(6872339552563453791)))
; [eval] (module_names_0 union Set(_single(6872339552563453791)))
; [eval] Set(_single(6872339552563453791))
; [eval] _single(6872339552563453791)
(declare-const module_names_0@1656@01 Set<_Name>)
(assert (=
  module_names_0@1656@01
  (Set_union module_names_0@1655@01 (Set_singleton (_single<_Name> 6872339552563453791)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(1819043139)))
; [eval] (module_names_0 union Set(_single(1819043139)))
; [eval] Set(_single(1819043139))
; [eval] _single(1819043139)
(declare-const module_names_0@1657@01 Set<_Name>)
(assert (=
  module_names_0@1657@01
  (Set_union module_names_0@1656@01 (Set_singleton (_single<_Name> 1819043139)))))
(push) ; 10
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2516 | p2_33@1556@01 | live]
; [else-branch: 2516 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2516 | p2_33@1556@01]
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(1801678668)))
; [eval] (module_names_0_0 union Set(_single(1801678668)))
; [eval] Set(_single(1801678668))
; [eval] _single(1801678668)
(declare-const module_names_0_0@1658@01 Set<_Name>)
(assert (=
  module_names_0_0@1658@01
  (Set_union module_names_0_0@1596@01 (Set_singleton (_single<_Name> 1801678668)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(110369476601940)))
; [eval] (module_names_0_0 union Set(_single(110369476601940)))
; [eval] Set(_single(110369476601940))
; [eval] _single(110369476601940)
(declare-const module_names_0_0@1659@01 Set<_Name>)
(assert (=
  module_names_0_0@1659@01
  (Set_union module_names_0_0@1658@01 (Set_singleton (_single<_Name> 110369476601940)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(8390876207989219661)))
; [eval] (module_names_0_0 union Set(_single(8390876207989219661)))
; [eval] Set(_single(8390876207989219661))
; [eval] _single(8390876207989219661)
(declare-const module_names_0_0@1660@01 Set<_Name>)
(assert (=
  module_names_0_0@1660@01
  (Set_union module_names_0_0@1659@01 (Set_singleton (_single<_Name> 8390876207989219661)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(113740422079847)))
; [eval] (module_names_0_0 union Set(_single(113740422079847)))
; [eval] Set(_single(113740422079847))
; [eval] _single(113740422079847)
(declare-const module_names_0_0@1661@01 Set<_Name>)
(assert (=
  module_names_0_0@1661@01
  (Set_union module_names_0_0@1660@01 (Set_singleton (_single<_Name> 113740422079847)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(1852702201685183063399)))
; [eval] (module_names_0_0 union Set(_single(1852702201685183063399)))
; [eval] Set(_single(1852702201685183063399))
; [eval] _single(1852702201685183063399)
(declare-const module_names_0_0@1662@01 Set<_Name>)
(assert (=
  module_names_0_0@1662@01
  (Set_union module_names_0_0@1661@01 (Set_singleton (_single<_Name> 1852702201685183063399)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(7308324465919225674)))
; [eval] (module_names_0_0 union Set(_single(7308324465919225674)))
; [eval] Set(_single(7308324465919225674))
; [eval] _single(7308324465919225674)
(declare-const module_names_0_0@1663@01 Set<_Name>)
(assert (=
  module_names_0_0@1663@01
  (Set_union module_names_0_0@1662@01 (Set_singleton (_single<_Name> 7308324465919225674)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(549923908602661266679892)))
; [eval] (module_names_0_0 union Set(_single(549923908602661266679892)))
; [eval] Set(_single(549923908602661266679892))
; [eval] _single(549923908602661266679892)
(declare-const module_names_0_0@1664@01 Set<_Name>)
(assert (=
  module_names_0_0@1664@01
  (Set_union module_names_0_0@1663@01 (Set_singleton (_single<_Name> 549923908602661266679892)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(110416352273767)))
; [eval] (module_names_0_0 union Set(_single(110416352273767)))
; [eval] Set(_single(110416352273767))
; [eval] _single(110416352273767)
(declare-const module_names_0_0@1665@01 Set<_Name>)
(assert (=
  module_names_0_0@1665@01
  (Set_union module_names_0_0@1664@01 (Set_singleton (_single<_Name> 110416352273767)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(6779489)))
; [eval] (module_names_0_0 union Set(_single(6779489)))
; [eval] Set(_single(6779489))
; [eval] _single(6779489)
(declare-const module_names_0_0@1666@01 Set<_Name>)
(assert (=
  module_names_0_0@1666@01
  (Set_union module_names_0_0@1665@01 (Set_singleton (_single<_Name> 6779489)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(8038062462289584464661321053517)))
; [eval] (module_names_0_0 union Set(_single(8038062462289584464661321053517)))
; [eval] Set(_single(8038062462289584464661321053517))
; [eval] _single(8038062462289584464661321053517)
(declare-const module_names_0_0@1667@01 Set<_Name>)
(assert (=
  module_names_0_0@1667@01
  (Set_union module_names_0_0@1666@01 (Set_singleton (_single<_Name> 8038062462289584464661321053517)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(1999559502384759136599)))
; [eval] (module_names_0_0 union Set(_single(1999559502384759136599)))
; [eval] Set(_single(1999559502384759136599))
; [eval] _single(1999559502384759136599)
(declare-const module_names_0_0@1668@01 Set<_Name>)
(assert (=
  module_names_0_0@1668@01
  (Set_union module_names_0_0@1667@01 (Set_singleton (_single<_Name> 1999559502384759136599)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(465558725964)))
; [eval] (module_names_0_0 union Set(_single(465558725964)))
; [eval] Set(_single(465558725964))
; [eval] _single(465558725964)
(declare-const module_names_0_0@1669@01 Set<_Name>)
(assert (=
  module_names_0_0@1669@01
  (Set_union module_names_0_0@1668@01 (Set_singleton (_single<_Name> 465558725964)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(6872339552563453791)))
; [eval] (module_names_0_0 union Set(_single(6872339552563453791)))
; [eval] Set(_single(6872339552563453791))
; [eval] _single(6872339552563453791)
(declare-const module_names_0_0@1670@01 Set<_Name>)
(assert (=
  module_names_0_0@1670@01
  (Set_union module_names_0_0@1669@01 (Set_singleton (_single<_Name> 6872339552563453791)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(1819043139)))
; [eval] (module_names_0_0 union Set(_single(1819043139)))
; [eval] Set(_single(1819043139))
; [eval] _single(1819043139)
(declare-const module_names_0_0@1671@01 Set<_Name>)
(assert (=
  module_names_0_0@1671@01
  (Set_union module_names_0_0@1670@01 (Set_singleton (_single<_Name> 1819043139)))))
; [exec]
; assert (p1_33 ==> true) &&
;   ((p2_33 ==> true) &&
;   ((p1_33 ==> (_single(1801678668) in module_names_0)) &&
;   (p2_33 ==> (_single(1801678668) in module_names_0_0))))
; [eval] p1_33 ==> true
(push) ; 11
(push) ; 12
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2517 | p1_33@1555@01 | live]
; [else-branch: 2517 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 2517 | p1_33@1555@01]
(pop) ; 12
(pop) ; 11
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 11
(push) ; 12
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2518 | p2_33@1556@01 | live]
; [else-branch: 2518 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 2518 | p2_33@1556@01]
(pop) ; 12
(pop) ; 11
; Joined path conditions
; [eval] p1_33 ==> (_single(1801678668) in module_names_0)
(push) ; 11
(push) ; 12
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2519 | p1_33@1555@01 | live]
; [else-branch: 2519 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 2519 | p1_33@1555@01]
; [eval] (_single(1801678668) in module_names_0)
; [eval] _single(1801678668)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_0@1657@01))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_0@1657@01)))
; [eval] p2_33 ==> (_single(1801678668) in module_names_0_0)
(push) ; 11
(push) ; 12
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2520 | p2_33@1556@01 | live]
; [else-branch: 2520 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 2520 | p2_33@1556@01]
; [eval] (_single(1801678668) in module_names_0_0)
; [eval] _single(1801678668)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (=> p2_33@1556@01 (Set_in (_single<_Name> 1801678668) module_names_0_0@1671@01))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_33@1556@01 (Set_in (_single<_Name> 1801678668) module_names_0_0@1671@01)))
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2521 | p1_33@1555@01 | live]
; [else-branch: 2521 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2521 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union Set(_single(7738150958779884867)))
; [eval] (module_names_0 union Set(_single(7738150958779884867)))
; [eval] Set(_single(7738150958779884867))
; [eval] _single(7738150958779884867)
(declare-const module_names_0@1672@01 Set<_Name>)
(assert (=
  module_names_0@1672@01
  (Set_union module_names_0@1657@01 (Set_singleton (_single<_Name> 7738150958779884867)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(2147778328593997130099)))
; [eval] (module_names_0 union Set(_single(2147778328593997130099)))
; [eval] Set(_single(2147778328593997130099))
; [eval] _single(2147778328593997130099)
(declare-const module_names_0@1673@01 Set<_Name>)
(assert (=
  module_names_0@1673@01
  (Set_union module_names_0@1672@01 (Set_singleton (_single<_Name> 2147778328593997130099)))))
(push) ; 12
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2522 | p2_33@1556@01 | live]
; [else-branch: 2522 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 2522 | p2_33@1556@01]
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(7738150958779884867)))
; [eval] (module_names_0_0 union Set(_single(7738150958779884867)))
; [eval] Set(_single(7738150958779884867))
; [eval] _single(7738150958779884867)
(declare-const module_names_0_0@1674@01 Set<_Name>)
(assert (=
  module_names_0_0@1674@01
  (Set_union module_names_0_0@1671@01 (Set_singleton (_single<_Name> 7738150958779884867)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(2147778328593997130099)))
; [eval] (module_names_0_0 union Set(_single(2147778328593997130099)))
; [eval] Set(_single(2147778328593997130099))
; [eval] _single(2147778328593997130099)
(declare-const module_names_0_0@1675@01 Set<_Name>)
(assert (=
  module_names_0_0@1675@01
  (Set_union module_names_0_0@1674@01 (Set_singleton (_single<_Name> 2147778328593997130099)))))
; [exec]
; assert (p1_33 ==> true) &&
;   ((p2_33 ==> true) &&
;   ((p1_33 ==> (_single(1801678668) in module_names_0)) &&
;   (p2_33 ==> (_single(1801678668) in module_names_0_0))))
; [eval] p1_33 ==> true
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2523 | p1_33@1555@01 | live]
; [else-branch: 2523 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 2523 | p1_33@1555@01]
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2524 | p2_33@1556@01 | live]
; [else-branch: 2524 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 2524 | p2_33@1556@01]
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p1_33 ==> (_single(1801678668) in module_names_0)
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2525 | p1_33@1555@01 | live]
; [else-branch: 2525 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 2525 | p1_33@1555@01]
; [eval] (_single(1801678668) in module_names_0)
; [eval] _single(1801678668)
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_0@1673@01))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_0@1673@01)))
; [eval] p2_33 ==> (_single(1801678668) in module_names_0_0)
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2526 | p2_33@1556@01 | live]
; [else-branch: 2526 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 2526 | p2_33@1556@01]
; [eval] (_single(1801678668) in module_names_0_0)
; [eval] _single(1801678668)
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (=> p2_33@1556@01 (Set_in (_single<_Name> 1801678668) module_names_0_0@1675@01))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_33@1556@01 (Set_in (_single<_Name> 1801678668) module_names_0_0@1675@01)))
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2527 | p1_33@1555@01 | live]
; [else-branch: 2527 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 2527 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(478792842068886668538480)))
; [eval] (module_names_0 union Set(_single(478792842068886668538480)))
; [eval] Set(_single(478792842068886668538480))
; [eval] _single(478792842068886668538480)
(declare-const module_names_0@1676@01 Set<_Name>)
(assert (=
  module_names_0@1676@01
  (Set_union module_names_0@1673@01 (Set_singleton (_single<_Name> 478792842068886668538480)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(2055831686330846900848)))
; [eval] (module_names_0 union Set(_single(2055831686330846900848)))
; [eval] Set(_single(2055831686330846900848))
; [eval] _single(2055831686330846900848)
(declare-const module_names_0@1677@01 Set<_Name>)
(assert (=
  module_names_0@1677@01
  (Set_union module_names_0@1676@01 (Set_singleton (_single<_Name> 2055831686330846900848)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(7308866606756098672)))
; [eval] (module_names_0 union Set(_single(7308866606756098672)))
; [eval] Set(_single(7308866606756098672))
; [eval] _single(7308866606756098672)
(declare-const module_names_0@1678@01 Set<_Name>)
(assert (=
  module_names_0@1678@01
  (Set_union module_names_0@1677@01 (Set_singleton (_single<_Name> 7308866606756098672)))))
(push) ; 14
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2528 | p2_33@1556@01 | live]
; [else-branch: 2528 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 2528 | p2_33@1556@01]
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(478792842068886668538480)))
; [eval] (module_names_0_0 union Set(_single(478792842068886668538480)))
; [eval] Set(_single(478792842068886668538480))
; [eval] _single(478792842068886668538480)
(declare-const module_names_0_0@1679@01 Set<_Name>)
(assert (=
  module_names_0_0@1679@01
  (Set_union module_names_0_0@1675@01 (Set_singleton (_single<_Name> 478792842068886668538480)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(2055831686330846900848)))
; [eval] (module_names_0_0 union Set(_single(2055831686330846900848)))
; [eval] Set(_single(2055831686330846900848))
; [eval] _single(2055831686330846900848)
(declare-const module_names_0_0@1680@01 Set<_Name>)
(assert (=
  module_names_0_0@1680@01
  (Set_union module_names_0_0@1679@01 (Set_singleton (_single<_Name> 2055831686330846900848)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(7308866606756098672)))
; [eval] (module_names_0_0 union Set(_single(7308866606756098672)))
; [eval] Set(_single(7308866606756098672))
; [eval] _single(7308866606756098672)
(declare-const module_names_0_0@1681@01 Set<_Name>)
(assert (=
  module_names_0_0@1681@01
  (Set_union module_names_0_0@1680@01 (Set_singleton (_single<_Name> 7308866606756098672)))))
; [exec]
; assert (p1_33 ==> true) &&
;   ((p2_33 ==> true) &&
;   ((p1_33 ==> (_single(1819043139) in module_names_0)) &&
;   (p2_33 ==> (_single(1819043139) in module_names_0_0))))
; [eval] p1_33 ==> true
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2529 | p1_33@1555@01 | live]
; [else-branch: 2529 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 2529 | p1_33@1555@01]
(pop) ; 16
(pop) ; 15
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2530 | p2_33@1556@01 | live]
; [else-branch: 2530 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 2530 | p2_33@1556@01]
(pop) ; 16
(pop) ; 15
; Joined path conditions
; [eval] p1_33 ==> (_single(1819043139) in module_names_0)
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2531 | p1_33@1555@01 | live]
; [else-branch: 2531 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 2531 | p1_33@1555@01]
; [eval] (_single(1819043139) in module_names_0)
; [eval] _single(1819043139)
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 1819043139) module_names_0@1678@01))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 1819043139) module_names_0@1678@01)))
; [eval] p2_33 ==> (_single(1819043139) in module_names_0_0)
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2532 | p2_33@1556@01 | live]
; [else-branch: 2532 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 2532 | p2_33@1556@01]
; [eval] (_single(1819043139) in module_names_0_0)
; [eval] _single(1819043139)
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (=> p2_33@1556@01 (Set_in (_single<_Name> 1819043139) module_names_0_0@1681@01))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_33@1556@01 (Set_in (_single<_Name> 1819043139) module_names_0_0@1681@01)))
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2533 | p1_33@1555@01 | live]
; [else-branch: 2533 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 2533 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union Set(_single(1869768058)))
; [eval] (module_names_0 union Set(_single(1869768058)))
; [eval] Set(_single(1869768058))
; [eval] _single(1869768058)
(declare-const module_names_0@1682@01 Set<_Name>)
(assert (=
  module_names_0@1682@01
  (Set_union module_names_0@1678@01 (Set_singleton (_single<_Name> 1869768058)))))
(push) ; 16
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2534 | p2_33@1556@01 | live]
; [else-branch: 2534 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 2534 | p2_33@1556@01]
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(1869768058)))
; [eval] (module_names_0_0 union Set(_single(1869768058)))
; [eval] Set(_single(1869768058))
; [eval] _single(1869768058)
(declare-const module_names_0_0@1683@01 Set<_Name>)
(assert (=
  module_names_0_0@1683@01
  (Set_union module_names_0_0@1681@01 (Set_singleton (_single<_Name> 1869768058)))))
; [exec]
; assert (p1_33 ==> true) &&
;   ((p2_33 ==> true) &&
;   ((p1_33 ==> (_single(1819043139) in module_names_0)) &&
;   (p2_33 ==> (_single(1819043139) in module_names_0_0))))
; [eval] p1_33 ==> true
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2535 | p1_33@1555@01 | live]
; [else-branch: 2535 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 2535 | p1_33@1555@01]
(pop) ; 18
(pop) ; 17
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2536 | p2_33@1556@01 | live]
; [else-branch: 2536 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 2536 | p2_33@1556@01]
(pop) ; 18
(pop) ; 17
; Joined path conditions
; [eval] p1_33 ==> (_single(1819043139) in module_names_0)
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2537 | p1_33@1555@01 | live]
; [else-branch: 2537 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 2537 | p1_33@1555@01]
; [eval] (_single(1819043139) in module_names_0)
; [eval] _single(1819043139)
(pop) ; 18
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 1819043139) module_names_0@1682@01))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 1819043139) module_names_0@1682@01)))
; [eval] p2_33 ==> (_single(1819043139) in module_names_0_0)
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2538 | p2_33@1556@01 | live]
; [else-branch: 2538 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 2538 | p2_33@1556@01]
; [eval] (_single(1819043139) in module_names_0_0)
; [eval] _single(1819043139)
(pop) ; 18
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (=> p2_33@1556@01 (Set_in (_single<_Name> 1819043139) module_names_0_0@1683@01))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_33@1556@01 (Set_in (_single<_Name> 1819043139) module_names_0_0@1683@01)))
(push) ; 17
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2539 | p1_33@1555@01 | live]
; [else-branch: 2539 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 2539 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union Set(_single(6647407)))
; [eval] (module_names_0 union Set(_single(6647407)))
; [eval] Set(_single(6647407))
; [eval] _single(6647407)
(declare-const module_names_0@1684@01 Set<_Name>)
(assert (=
  module_names_0@1684@01
  (Set_union module_names_0@1682@01 (Set_singleton (_single<_Name> 6647407)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(128017496632419)))
; [eval] (module_names_0 union Set(_single(128017496632419)))
; [eval] Set(_single(128017496632419))
; [eval] _single(128017496632419)
(declare-const module_names_0@1685@01 Set<_Name>)
(assert (=
  module_names_0@1685@01
  (Set_union module_names_0@1684@01 (Set_singleton (_single<_Name> 128017496632419)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(9224632863353764542590278070118)))
; [eval] (module_names_0 union Set(_single(9224632863353764542590278070118)))
; [eval] Set(_single(9224632863353764542590278070118))
; [eval] _single(9224632863353764542590278070118)
(declare-const module_names_0@1686@01 Set<_Name>)
(assert (=
  module_names_0@1686@01
  (Set_union module_names_0@1685@01 (Set_singleton (_single<_Name> 9224632863353764542590278070118)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(8606216570058403690)))
; [eval] (module_names_0 union Set(_single(8606216570058403690)))
; [eval] Set(_single(8606216570058403690))
; [eval] _single(8606216570058403690)
(declare-const module_names_0@1687@01 Set<_Name>)
(assert (=
  module_names_0@1687@01
  (Set_union module_names_0@1686@01 (Set_singleton (_single<_Name> 8606216570058403690)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(7303014)))
; [eval] (module_names_0 union Set(_single(7303014)))
; [eval] Set(_single(7303014))
; [eval] _single(7303014)
(declare-const module_names_0@1688@01 Set<_Name>)
(assert (=
  module_names_0@1688@01
  (Set_union module_names_0@1687@01 (Set_singleton (_single<_Name> 7303014)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(65)))
; [eval] (module_names_0 union Set(_single(65)))
; [eval] Set(_single(65))
; [eval] _single(65)
(declare-const module_names_0@1689@01 Set<_Name>)
(assert (=
  module_names_0@1689@01
  (Set_union module_names_0@1688@01 (Set_singleton (_single<_Name> 65)))))
(push) ; 18
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2540 | p2_33@1556@01 | live]
; [else-branch: 2540 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 2540 | p2_33@1556@01]
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(6647407)))
; [eval] (module_names_0_0 union Set(_single(6647407)))
; [eval] Set(_single(6647407))
; [eval] _single(6647407)
(declare-const module_names_0_0@1690@01 Set<_Name>)
(assert (=
  module_names_0_0@1690@01
  (Set_union module_names_0_0@1683@01 (Set_singleton (_single<_Name> 6647407)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(128017496632419)))
; [eval] (module_names_0_0 union Set(_single(128017496632419)))
; [eval] Set(_single(128017496632419))
; [eval] _single(128017496632419)
(declare-const module_names_0_0@1691@01 Set<_Name>)
(assert (=
  module_names_0_0@1691@01
  (Set_union module_names_0_0@1690@01 (Set_singleton (_single<_Name> 128017496632419)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(9224632863353764542590278070118)))
; [eval] (module_names_0_0 union Set(_single(9224632863353764542590278070118)))
; [eval] Set(_single(9224632863353764542590278070118))
; [eval] _single(9224632863353764542590278070118)
(declare-const module_names_0_0@1692@01 Set<_Name>)
(assert (=
  module_names_0_0@1692@01
  (Set_union module_names_0_0@1691@01 (Set_singleton (_single<_Name> 9224632863353764542590278070118)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(8606216570058403690)))
; [eval] (module_names_0_0 union Set(_single(8606216570058403690)))
; [eval] Set(_single(8606216570058403690))
; [eval] _single(8606216570058403690)
(declare-const module_names_0_0@1693@01 Set<_Name>)
(assert (=
  module_names_0_0@1693@01
  (Set_union module_names_0_0@1692@01 (Set_singleton (_single<_Name> 8606216570058403690)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(7303014)))
; [eval] (module_names_0_0 union Set(_single(7303014)))
; [eval] Set(_single(7303014))
; [eval] _single(7303014)
(declare-const module_names_0_0@1694@01 Set<_Name>)
(assert (=
  module_names_0_0@1694@01
  (Set_union module_names_0_0@1693@01 (Set_singleton (_single<_Name> 7303014)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(65)))
; [eval] (module_names_0_0 union Set(_single(65)))
; [eval] Set(_single(65))
; [eval] _single(65)
(declare-const module_names_0_0@1695@01 Set<_Name>)
(assert (=
  module_names_0_0@1695@01
  (Set_union module_names_0_0@1694@01 (Set_singleton (_single<_Name> 65)))))
; [exec]
; assert (p1_33 ==> true) &&
;   ((p2_33 ==> true) &&
;   ((p1_33 ==> (_single(65) in module_names_0)) &&
;   (p2_33 ==> (_single(65) in module_names_0_0))))
; [eval] p1_33 ==> true
(push) ; 19
(push) ; 20
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2541 | p1_33@1555@01 | live]
; [else-branch: 2541 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 2541 | p1_33@1555@01]
(pop) ; 20
(pop) ; 19
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 19
(push) ; 20
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2542 | p2_33@1556@01 | live]
; [else-branch: 2542 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 2542 | p2_33@1556@01]
(pop) ; 20
(pop) ; 19
; Joined path conditions
; [eval] p1_33 ==> (_single(65) in module_names_0)
(push) ; 19
(push) ; 20
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2543 | p1_33@1555@01 | live]
; [else-branch: 2543 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 2543 | p1_33@1555@01]
; [eval] (_single(65) in module_names_0)
; [eval] _single(65)
(pop) ; 20
(pop) ; 19
; Joined path conditions
(push) ; 19
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 65) module_names_0@1689@01))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 65) module_names_0@1689@01)))
; [eval] p2_33 ==> (_single(65) in module_names_0_0)
(push) ; 19
(push) ; 20
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2544 | p2_33@1556@01 | live]
; [else-branch: 2544 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 2544 | p2_33@1556@01]
; [eval] (_single(65) in module_names_0_0)
; [eval] _single(65)
(pop) ; 20
(pop) ; 19
; Joined path conditions
(push) ; 19
(assert (not (=> p2_33@1556@01 (Set_in (_single<_Name> 65) module_names_0_0@1695@01))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (=> p2_33@1556@01 (Set_in (_single<_Name> 65) module_names_0_0@1695@01)))
(push) ; 19
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2545 | p1_33@1555@01 | live]
; [else-branch: 2545 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 2545 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union Set(_single(7303014)))
; [eval] (module_names_0 union Set(_single(7303014)))
; [eval] Set(_single(7303014))
; [eval] _single(7303014)
(declare-const module_names_0@1696@01 Set<_Name>)
(assert (=
  module_names_0@1696@01
  (Set_union module_names_0@1689@01 (Set_singleton (_single<_Name> 7303014)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(66)))
; [eval] (module_names_0 union Set(_single(66)))
; [eval] Set(_single(66))
; [eval] _single(66)
(declare-const module_names_0@1697@01 Set<_Name>)
(assert (=
  module_names_0@1697@01
  (Set_union module_names_0@1696@01 (Set_singleton (_single<_Name> 66)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(8748815751553023034868178699518350214131562)))
; [eval] (module_names_0 union Set(_single(8748815751553023034868178699518350214131562)))
; [eval] Set(_single(8748815751553023034868178699518350214131562))
; [eval] _single(8748815751553023034868178699518350214131562)
(declare-const module_names_0@1698@01 Set<_Name>)
(assert (=
  module_names_0@1698@01
  (Set_union module_names_0@1697@01 (Set_singleton (_single<_Name> 8748815751553023034868178699518350214131562)))))
(push) ; 20
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2546 | p2_33@1556@01 | live]
; [else-branch: 2546 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 2546 | p2_33@1556@01]
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(7303014)))
; [eval] (module_names_0_0 union Set(_single(7303014)))
; [eval] Set(_single(7303014))
; [eval] _single(7303014)
(declare-const module_names_0_0@1699@01 Set<_Name>)
(assert (=
  module_names_0_0@1699@01
  (Set_union module_names_0_0@1695@01 (Set_singleton (_single<_Name> 7303014)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union Set(_single(66)))
; [eval] (module_names_0_0 union Set(_single(66)))
; [eval] Set(_single(66))
; [eval] _single(66)
(declare-const module_names_0_0@1700@01 Set<_Name>)
(assert (=
  module_names_0_0@1700@01
  (Set_union module_names_0_0@1699@01 (Set_singleton (_single<_Name> 66)))))
; [exec]
; module_names_0_0 := (module_names_0_0 union
;   Set(_single(8748815751553023034868178699518350214131562)))
; [eval] (module_names_0_0 union Set(_single(8748815751553023034868178699518350214131562)))
; [eval] Set(_single(8748815751553023034868178699518350214131562))
; [eval] _single(8748815751553023034868178699518350214131562)
(declare-const module_names_0_0@1701@01 Set<_Name>)
(assert (=
  module_names_0_0@1701@01
  (Set_union module_names_0_0@1700@01 (Set_singleton (_single<_Name> 8748815751553023034868178699518350214131562)))))
; [exec]
; assert true
; [eval] p1_33 ==> true
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2547 | p1_33@1555@01 | live]
; [else-branch: 2547 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 2547 | p1_33@1555@01]
(pop) ; 22
(pop) ; 21
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2548 | p2_33@1556@01 | live]
; [else-branch: 2548 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 2548 | p2_33@1556@01]
(pop) ; 22
(pop) ; 21
; Joined path conditions
; [eval] p1_33 ==> (forperm _r_61: Ref [MustInvokeBounded(_r_61)] :: false) && ((forperm _r_61: Ref [MustInvokeUnbounded(_r_61)] :: false) && ((forperm _r_61: Ref [_r_61.MustReleaseBounded] :: false) && (forperm _r_61: Ref [_r_61.MustReleaseUnbounded] :: false)))
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2549 | p1_33@1555@01 | live]
; [else-branch: 2549 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 2549 | p1_33@1555@01]
; [eval] (forperm _r_61: Ref [MustInvokeBounded(_r_61)] :: false) && ((forperm _r_61: Ref [MustInvokeUnbounded(_r_61)] :: false) && ((forperm _r_61: Ref [_r_61.MustReleaseBounded] :: false) && (forperm _r_61: Ref [_r_61.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_61: Ref [MustInvokeBounded(_r_61)] :: false)
(push) ; 23
; [then-branch: 2550 | False | live]
; [else-branch: 2550 | True | live]
(push) ; 24
; [then-branch: 2550 | False]
(assert false)
(pop) ; 24
(push) ; 24
; [else-branch: 2550 | True]
; [eval] (forperm _r_61: Ref [MustInvokeUnbounded(_r_61)] :: false)
(push) ; 25
; [then-branch: 2551 | False | live]
; [else-branch: 2551 | True | live]
(push) ; 26
; [then-branch: 2551 | False]
(assert false)
(pop) ; 26
(push) ; 26
; [else-branch: 2551 | True]
; [eval] (forperm _r_61: Ref [_r_61.MustReleaseBounded] :: false)
(push) ; 27
; [then-branch: 2552 | False | live]
; [else-branch: 2552 | True | live]
(push) ; 28
; [then-branch: 2552 | False]
(assert false)
(pop) ; 28
(push) ; 28
; [else-branch: 2552 | True]
; [eval] (forperm _r_61: Ref [_r_61.MustReleaseUnbounded] :: false)
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(pop) ; 22
(pop) ; 21
; Joined path conditions
; [eval] p2_33 ==> (forperm _r_61: Ref [MustInvokeBounded_0(_r_61)] :: false) && ((forperm _r_61: Ref [MustInvokeUnbounded_0(_r_61)] :: false) && ((forperm _r_61: Ref [_r_61.MustReleaseBoundedp] :: false) && (forperm _r_61: Ref [_r_61.MustReleaseUnboundedp] :: false)))
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2553 | p2_33@1556@01 | live]
; [else-branch: 2553 | !(p2_33@1556@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 2553 | p2_33@1556@01]
; [eval] (forperm _r_61: Ref [MustInvokeBounded_0(_r_61)] :: false) && ((forperm _r_61: Ref [MustInvokeUnbounded_0(_r_61)] :: false) && ((forperm _r_61: Ref [_r_61.MustReleaseBoundedp] :: false) && (forperm _r_61: Ref [_r_61.MustReleaseUnboundedp] :: false)))
; [eval] (forperm _r_61: Ref [MustInvokeBounded_0(_r_61)] :: false)
(push) ; 23
; [then-branch: 2554 | False | live]
; [else-branch: 2554 | True | live]
(push) ; 24
; [then-branch: 2554 | False]
(assert false)
(pop) ; 24
(push) ; 24
; [else-branch: 2554 | True]
; [eval] (forperm _r_61: Ref [MustInvokeUnbounded_0(_r_61)] :: false)
(push) ; 25
; [then-branch: 2555 | False | live]
; [else-branch: 2555 | True | live]
(push) ; 26
; [then-branch: 2555 | False]
(assert false)
(pop) ; 26
(push) ; 26
; [else-branch: 2555 | True]
; [eval] (forperm _r_61: Ref [_r_61.MustReleaseBoundedp] :: false)
(push) ; 27
; [then-branch: 2556 | False | live]
; [else-branch: 2556 | True | live]
(push) ; 28
; [then-branch: 2556 | False]
(assert false)
(pop) ; 28
(push) ; 28
; [else-branch: 2556 | True]
; [eval] (forperm _r_61: Ref [_r_61.MustReleaseUnboundedp] :: false)
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(pop) ; 22
(pop) ; 21
; Joined path conditions
(pop) ; 20
; [eval] !p2_33
; [then-branch: 2557 | !(p2_33@1556@01) | dead]
; [else-branch: 2557 | p2_33@1556@01 | live]
(push) ; 20
; [else-branch: 2557 | p2_33@1556@01]
(pop) ; 20
(pop) ; 19
; [eval] !p1_33
; [then-branch: 2558 | !(p1_33@1555@01) | dead]
; [else-branch: 2558 | p1_33@1555@01 | live]
(push) ; 19
; [else-branch: 2558 | p1_33@1555@01]
(pop) ; 19
(pop) ; 18
; [eval] !p2_33
; [then-branch: 2559 | !(p2_33@1556@01) | dead]
; [else-branch: 2559 | p2_33@1556@01 | live]
(push) ; 18
; [else-branch: 2559 | p2_33@1556@01]
(pop) ; 18
(pop) ; 17
; [eval] !p1_33
; [then-branch: 2560 | !(p1_33@1555@01) | dead]
; [else-branch: 2560 | p1_33@1555@01 | live]
(push) ; 17
; [else-branch: 2560 | p1_33@1555@01]
(pop) ; 17
(pop) ; 16
; [eval] !p2_33
; [then-branch: 2561 | !(p2_33@1556@01) | dead]
; [else-branch: 2561 | p2_33@1556@01 | live]
(push) ; 16
; [else-branch: 2561 | p2_33@1556@01]
(pop) ; 16
(pop) ; 15
; [eval] !p1_33
; [then-branch: 2562 | !(p1_33@1555@01) | dead]
; [else-branch: 2562 | p1_33@1555@01 | live]
(push) ; 15
; [else-branch: 2562 | p1_33@1555@01]
(pop) ; 15
(pop) ; 14
; [eval] !p2_33
; [then-branch: 2563 | !(p2_33@1556@01) | dead]
; [else-branch: 2563 | p2_33@1556@01 | live]
(push) ; 14
; [else-branch: 2563 | p2_33@1556@01]
(pop) ; 14
(pop) ; 13
; [eval] !p1_33
; [then-branch: 2564 | !(p1_33@1555@01) | dead]
; [else-branch: 2564 | p1_33@1555@01 | live]
(push) ; 13
; [else-branch: 2564 | p1_33@1555@01]
(pop) ; 13
(pop) ; 12
; [eval] !p2_33
; [then-branch: 2565 | !(p2_33@1556@01) | dead]
; [else-branch: 2565 | p2_33@1556@01 | live]
(push) ; 12
; [else-branch: 2565 | p2_33@1556@01]
(pop) ; 12
(pop) ; 11
; [eval] !p1_33
; [then-branch: 2566 | !(p1_33@1555@01) | dead]
; [else-branch: 2566 | p1_33@1555@01 | live]
(push) ; 11
; [else-branch: 2566 | p1_33@1555@01]
(pop) ; 11
(pop) ; 10
; [eval] !p2_33
; [then-branch: 2567 | !(p2_33@1556@01) | dead]
; [else-branch: 2567 | p2_33@1556@01 | live]
(push) ; 10
; [else-branch: 2567 | p2_33@1556@01]
(pop) ; 10
(pop) ; 9
; [eval] !p1_33
; [then-branch: 2568 | !(p1_33@1555@01) | dead]
; [else-branch: 2568 | p1_33@1555@01 | live]
(push) ; 9
; [else-branch: 2568 | p1_33@1555@01]
(pop) ; 9
(pop) ; 8
; [eval] !p2_34
; [then-branch: 2569 | !(p2_33@1556@01) | dead]
; [else-branch: 2569 | p2_33@1556@01 | live]
(push) ; 8
; [else-branch: 2569 | p2_33@1556@01]
(pop) ; 8
(pop) ; 7
; [eval] !p1_34
; [then-branch: 2570 | !(p1_33@1555@01) | dead]
; [else-branch: 2570 | p1_33@1555@01 | live]
(push) ; 7
; [else-branch: 2570 | p1_33@1555@01]
(pop) ; 7
(pop) ; 6
; [eval] !p2_34
; [then-branch: 2571 | !(p2_33@1556@01) | dead]
; [else-branch: 2571 | p2_33@1556@01 | live]
(push) ; 6
; [else-branch: 2571 | p2_33@1556@01]
(pop) ; 6
(pop) ; 5
; [eval] !p1_34
; [then-branch: 2572 | !(p1_33@1555@01) | dead]
; [else-branch: 2572 | p1_33@1555@01 | live]
(push) ; 5
; [else-branch: 2572 | p1_33@1555@01]
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 2494 | !(p2_33@1556@01)]
(assert (not p2_33@1556@01))
(pop) ; 4
; [eval] !p2_33
(push) ; 4
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not p2_33@1556@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2573 | !(p2_33@1556@01) | live]
; [else-branch: 2573 | p2_33@1556@01 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 2573 | !(p2_33@1556@01)]
(assert (not p2_33@1556@01))
; [exec]
; p1_34 := p1_33 && !module_defined_1
; [eval] p1_33 && !module_defined_1
(push) ; 5
; [then-branch: 2574 | !(p1_33@1555@01) | live]
; [else-branch: 2574 | p1_33@1555@01 | live]
(push) ; 6
; [then-branch: 2574 | !(p1_33@1555@01)]
(assert (not p1_33@1555@01))
(pop) ; 6
(push) ; 6
; [else-branch: 2574 | p1_33@1555@01]
; [eval] !module_defined_1
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or p1_33@1555@01 (not p1_33@1555@01)))
; [exec]
; p2_34 := p2_33 && !module_defined_1_0
; [eval] p2_33 && !module_defined_1_0
(push) ; 5
; [then-branch: 2575 | !(p2_33@1556@01) | live]
; [else-branch: 2575 | p2_33@1556@01 | live]
(push) ; 6
; [then-branch: 2575 | !(p2_33@1556@01)]
(pop) ; 6
(push) ; 6
; [else-branch: 2575 | p2_33@1556@01]
(assert p2_33@1556@01)
; [eval] !module_defined_1_0
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or p2_33@1556@01 (not p2_33@1556@01)))
(declare-const p2_34@1702@01 Bool)
(assert (= p2_34@1702@01 (and p2_33@1556@01 (not module_defined_1_0@1572@01))))
; [exec]
; p3_16 := p1_33 && !!module_defined_1
; [eval] p1_33 && !!module_defined_1
(push) ; 5
; [then-branch: 2576 | !(p1_33@1555@01) | live]
; [else-branch: 2576 | p1_33@1555@01 | live]
(push) ; 6
; [then-branch: 2576 | !(p1_33@1555@01)]
(assert (not p1_33@1555@01))
(pop) ; 6
(push) ; 6
; [else-branch: 2576 | p1_33@1555@01]
; [eval] !!module_defined_1
; [eval] !module_defined_1
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
; [exec]
; p4_16 := p2_33 && !!module_defined_1_0
; [eval] p2_33 && !!module_defined_1_0
(push) ; 5
; [then-branch: 2577 | !(p2_33@1556@01) | live]
; [else-branch: 2577 | p2_33@1556@01 | live]
(push) ; 6
; [then-branch: 2577 | !(p2_33@1556@01)]
(pop) ; 6
(push) ; 6
; [else-branch: 2577 | p2_33@1556@01]
(assert p2_33@1556@01)
; [eval] !!module_defined_1_0
; [eval] !module_defined_1_0
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(declare-const p4_16@1703@01 Bool)
(assert (= p4_16@1703@01 (and p2_33@1556@01 module_defined_1_0@1572@01)))
(push) ; 5
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2578 | p1_33@1555@01 | live]
; [else-branch: 2578 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2578 | p1_33@1555@01]
; [exec]
; module_defined_1 := true
; [exec]
; module_names_1 := (module_names_1 union Set(_single(27981962743276871)))
; [eval] (module_names_1 union Set(_single(27981962743276871)))
; [eval] Set(_single(27981962743276871))
; [eval] _single(27981962743276871)
(declare-const module_names_1@1704@01 Set<_Name>)
(assert (=
  module_names_1@1704@01
  (Set_union module_names_1@1592@01 (Set_singleton (_single<_Name> 27981962743276871)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(7809644653626814543)))
; [eval] (module_names_1 union Set(_single(7809644653626814543)))
; [eval] Set(_single(7809644653626814543))
; [eval] _single(7809644653626814543)
(declare-const module_names_1@1705@01 Set<_Name>)
(assert (=
  module_names_1@1705@01
  (Set_union module_names_1@1704@01 (Set_singleton (_single<_Name> 7809644653626814543)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(32195171041966420)))
; [eval] (module_names_1 union Set(_single(32195171041966420)))
; [eval] Set(_single(32195171041966420))
; [eval] _single(32195171041966420)
(declare-const module_names_1@1706@01 Set<_Name>)
(assert (=
  module_names_1@1706@01
  (Set_union module_names_1@1705@01 (Set_singleton (_single<_Name> 32195171041966420)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(37578771102893684825896415043)))
; [eval] (module_names_1 union Set(_single(37578771102893684825896415043)))
; [eval] Set(_single(37578771102893684825896415043))
; [eval] _single(37578771102893684825896415043)
(declare-const module_names_1@1707@01 Set<_Name>)
(assert (=
  module_names_1@1707@01
  (Set_union module_names_1@1706@01 (Set_singleton (_single<_Name> 37578771102893684825896415043)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(32481164592901701)))
; [eval] (module_names_1 union Set(_single(32481164592901701)))
; [eval] Set(_single(32481164592901701))
; [eval] _single(32481164592901701)
(declare-const module_names_1@1708@01 Set<_Name>)
(assert (=
  module_names_1@1708@01
  (Set_union module_names_1@1707@01 (Set_singleton (_single<_Name> 32481164592901701)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(32481125787004233)))
; [eval] (module_names_1 union Set(_single(32481125787004233)))
; [eval] Set(_single(32481125787004233))
; [eval] _single(32481125787004233)
(declare-const module_names_1@1709@01 Set<_Name>)
(assert (=
  module_names_1@1709@01
  (Set_union module_names_1@1708@01 (Set_singleton (_single<_Name> 32481125787004233)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(7827276)))
; [eval] (module_names_1 union Set(_single(7827276)))
; [eval] Set(_single(7827276))
; [eval] _single(7827276)
(declare-const module_names_1@1710@01 Set<_Name>)
(assert (=
  module_names_1@1710@01
  (Set_union module_names_1@1709@01 (Set_singleton (_single<_Name> 7827276)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(8389754714483814220)))
; [eval] (module_names_1 union Set(_single(8389754714483814220)))
; [eval] Set(_single(8389754714483814220))
; [eval] _single(8389754714483814220)
(declare-const module_names_1@1711@01 Set<_Name>)
(assert (=
  module_names_1@1711@01
  (Set_union module_names_1@1710@01 (Set_singleton (_single<_Name> 8389754714483814220)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(1871507244730112373328)))
; [eval] (module_names_1 union Set(_single(1871507244730112373328)))
; [eval] Set(_single(1871507244730112373328))
; [eval] _single(1871507244730112373328)
(declare-const module_names_1@1712@01 Set<_Name>)
(assert (=
  module_names_1@1712@01
  (Set_union module_names_1@1711@01 (Set_singleton (_single<_Name> 1871507244730112373328)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(1701999952)))
; [eval] (module_names_1 union Set(_single(1701999952)))
; [eval] Set(_single(1701999952))
; [eval] _single(1701999952)
(declare-const module_names_1@1713@01 Set<_Name>)
(assert (=
  module_names_1@1713@01
  (Set_union module_names_1@1712@01 (Set_singleton (_single<_Name> 1701999952)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(8315178084276987218)))
; [eval] (module_names_1 union Set(_single(8315178084276987218)))
; [eval] Set(_single(8315178084276987218))
; [eval] _single(8315178084276987218)
(declare-const module_names_1@1714@01 Set<_Name>)
(assert (=
  module_names_1@1714@01
  (Set_union module_names_1@1713@01 (Set_singleton (_single<_Name> 8315178084276987218)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(7738150958662902082)))
; [eval] (module_names_1 union Set(_single(7738150958662902082)))
; [eval] Set(_single(7738150958662902082))
; [eval] _single(7738150958662902082)
(declare-const module_names_1@1715@01 Set<_Name>)
(assert (=
  module_names_1@1715@01
  (Set_union module_names_1@1714@01 (Set_singleton (_single<_Name> 7738150958662902082)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(465558725964)))
; [eval] (module_names_1 union Set(_single(465558725964)))
; [eval] Set(_single(465558725964))
; [eval] _single(465558725964)
(declare-const module_names_1@1716@01 Set<_Name>)
(assert (=
  module_names_1@1716@01
  (Set_union module_names_1@1715@01 (Set_singleton (_single<_Name> 465558725964)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(122646376569110405802325325)))
; [eval] (module_names_1 union Set(_single(122646376569110405802325325)))
; [eval] Set(_single(122646376569110405802325325))
; [eval] _single(122646376569110405802325325)
(declare-const module_names_1@1717@01 Set<_Name>)
(assert (=
  module_names_1@1717@01
  (Set_union module_names_1@1716@01 (Set_singleton (_single<_Name> 122646376569110405802325325)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(8038062462289584464661321053517)))
; [eval] (module_names_1 union Set(_single(8038062462289584464661321053517)))
; [eval] Set(_single(8038062462289584464661321053517))
; [eval] _single(8038062462289584464661321053517)
(declare-const module_names_1@1718@01 Set<_Name>)
(assert (=
  module_names_1@1718@01
  (Set_union module_names_1@1717@01 (Set_singleton (_single<_Name> 8038062462289584464661321053517)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(1999559502384759136599)))
; [eval] (module_names_1 union Set(_single(1999559502384759136599)))
; [eval] Set(_single(1999559502384759136599))
; [eval] _single(1999559502384759136599)
(declare-const module_names_1@1719@01 Set<_Name>)
(assert (=
  module_names_1@1719@01
  (Set_union module_names_1@1718@01 (Set_singleton (_single<_Name> 1999559502384759136599)))))
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_34@1702@01)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2579 | p2_34@1702@01 | dead]
; [else-branch: 2579 | !(p2_34@1702@01) | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 2579 | !(p2_34@1702@01)]
(assert (not p2_34@1702@01))
(pop) ; 6
; [eval] !p2_34
(push) ; 6
(set-option :timeout 10)
(assert (not p2_34@1702@01))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not p2_34@1702@01)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2580 | !(p2_34@1702@01) | live]
; [else-branch: 2580 | p2_34@1702@01 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 2580 | !(p2_34@1702@01)]
(assert (not p2_34@1702@01))
; [exec]
; assert (p1_34 ==> true) &&
;   ((p2_34 ==> true) &&
;   ((p1_34 ==> (_single(7738150958662902082) in module_names_1)) &&
;   (p2_34 ==> (_single(7738150958662902082) in module_names_1_0)) &&
;   ((p1_34 ==> (_single(7738150958662902082) in module_names_1)) &&
;   (p2_34 ==> (_single(7738150958662902082) in module_names_1_0)))))
; [eval] p1_34 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2581 | p1_33@1555@01 | live]
; [else-branch: 2581 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2581 | p1_33@1555@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p2_34 ==> true
(push) ; 7
; [then-branch: 2582 | p2_34@1702@01 | dead]
; [else-branch: 2582 | !(p2_34@1702@01) | live]
(push) ; 8
; [else-branch: 2582 | !(p2_34@1702@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p1_34 ==> (_single(7738150958662902082) in module_names_1)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2583 | p1_33@1555@01 | live]
; [else-branch: 2583 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2583 | p1_33@1555@01]
; [eval] (_single(7738150958662902082) in module_names_1)
; [eval] _single(7738150958662902082)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (=>
  p1_33@1555@01
  (Set_in (_single<_Name> 7738150958662902082) module_names_1@1719@01))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (=>
  p1_33@1555@01
  (Set_in (_single<_Name> 7738150958662902082) module_names_1@1719@01)))
; [eval] p2_34 ==> (_single(7738150958662902082) in module_names_1_0)
(push) ; 7
; [then-branch: 2584 | p2_34@1702@01 | dead]
; [else-branch: 2584 | !(p2_34@1702@01) | live]
(push) ; 8
; [else-branch: 2584 | !(p2_34@1702@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p1_34 ==> (_single(7738150958662902082) in module_names_1)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2585 | p1_33@1555@01 | live]
; [else-branch: 2585 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2585 | p1_33@1555@01]
; [eval] (_single(7738150958662902082) in module_names_1)
; [eval] _single(7738150958662902082)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p2_34 ==> (_single(7738150958662902082) in module_names_1_0)
(push) ; 7
; [then-branch: 2586 | p2_34@1702@01 | dead]
; [else-branch: 2586 | !(p2_34@1702@01) | live]
(push) ; 8
; [else-branch: 2586 | !(p2_34@1702@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [exec]
; assert (p1_34 ==> true) &&
;   ((p2_34 ==> true) &&
;   ((p1_34 ==> (_single(7738150958662902082) in module_names_1)) &&
;   (p2_34 ==> (_single(7738150958662902082) in module_names_1_0))))
; [eval] p1_34 ==> true
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2587 | p1_33@1555@01 | live]
; [else-branch: 2587 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2587 | p1_33@1555@01]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p2_34 ==> true
(push) ; 7
; [then-branch: 2588 | p2_34@1702@01 | dead]
; [else-branch: 2588 | !(p2_34@1702@01) | live]
(push) ; 8
; [else-branch: 2588 | !(p2_34@1702@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p1_34 ==> (_single(7738150958662902082) in module_names_1)
(push) ; 7
(push) ; 8
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2589 | p1_33@1555@01 | live]
; [else-branch: 2589 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2589 | p1_33@1555@01]
; [eval] (_single(7738150958662902082) in module_names_1)
; [eval] _single(7738150958662902082)
(pop) ; 8
(pop) ; 7
; Joined path conditions
; [eval] p2_34 ==> (_single(7738150958662902082) in module_names_1_0)
(push) ; 7
; [then-branch: 2590 | p2_34@1702@01 | dead]
; [else-branch: 2590 | !(p2_34@1702@01) | live]
(push) ; 8
; [else-branch: 2590 | !(p2_34@1702@01)]
(pop) ; 8
(pop) ; 7
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2591 | p1_33@1555@01 | live]
; [else-branch: 2591 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 2591 | p1_33@1555@01]
; [exec]
; module_names_1 := (module_names_1 union Set(_single(6872339552563453791)))
; [eval] (module_names_1 union Set(_single(6872339552563453791)))
; [eval] Set(_single(6872339552563453791))
; [eval] _single(6872339552563453791)
(declare-const module_names_1@1720@01 Set<_Name>)
(assert (=
  module_names_1@1720@01
  (Set_union module_names_1@1719@01 (Set_singleton (_single<_Name> 6872339552563453791)))))
; [exec]
; module_names_1 := (module_names_1 union
;   Set(_single(474107507589505187341671)))
; [eval] (module_names_1 union Set(_single(474107507589505187341671)))
; [eval] Set(_single(474107507589505187341671))
; [eval] _single(474107507589505187341671)
(declare-const module_names_1@1721@01 Set<_Name>)
(assert (=
  module_names_1@1721@01
  (Set_union module_names_1@1720@01 (Set_singleton (_single<_Name> 474107507589505187341671)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(28554769915274081)))
; [eval] (module_names_1 union Set(_single(28554769915274081)))
; [eval] Set(_single(28554769915274081))
; [eval] _single(28554769915274081)
(declare-const module_names_1@1722@01 Set<_Name>)
(assert (=
  module_names_1@1722@01
  (Set_union module_names_1@1721@01 (Set_singleton (_single<_Name> 28554769915274081)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(28555834798400882)))
; [eval] (module_names_1 union Set(_single(28555834798400882)))
; [eval] Set(_single(28555834798400882))
; [eval] _single(28555834798400882)
(declare-const module_names_1@1723@01 Set<_Name>)
(assert (=
  module_names_1@1723@01
  (Set_union module_names_1@1722@01 (Set_singleton (_single<_Name> 28555834798400882)))))
; [exec]
; module_names_1 := (module_names_1 union Set(_single(1801678668)))
; [eval] (module_names_1 union Set(_single(1801678668)))
; [eval] Set(_single(1801678668))
; [eval] _single(1801678668)
(declare-const module_names_1@1724@01 Set<_Name>)
(assert (=
  module_names_1@1724@01
  (Set_union module_names_1@1723@01 (Set_singleton (_single<_Name> 1801678668)))))
; [then-branch: 2592 | p2_34@1702@01 | dead]
; [else-branch: 2592 | !(p2_34@1702@01) | live]
(push) ; 8
; [else-branch: 2592 | !(p2_34@1702@01)]
(pop) ; 8
; [eval] !p2_34
(push) ; 8
(set-option :timeout 10)
(assert (not p2_34@1702@01))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2593 | !(p2_34@1702@01) | live]
; [else-branch: 2593 | p2_34@1702@01 | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 2593 | !(p2_34@1702@01)]
; [exec]
; assert (p1_33 ==> (_single(1801678668) in module_names_1)) &&
;   (p2_33 ==> (_single(1801678668) in module_names_1_0))
; [eval] p1_33 ==> (_single(1801678668) in module_names_1)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2594 | p1_33@1555@01 | live]
; [else-branch: 2594 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2594 | p1_33@1555@01]
; [eval] (_single(1801678668) in module_names_1)
; [eval] _single(1801678668)
(pop) ; 10
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_1@1724@01))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_1@1724@01)))
; [eval] p2_33 ==> (_single(1801678668) in module_names_1_0)
(push) ; 9
; [then-branch: 2595 | p2_33@1556@01 | dead]
; [else-branch: 2595 | !(p2_33@1556@01) | live]
(push) ; 10
; [else-branch: 2595 | !(p2_33@1556@01)]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(push) ; 9
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2596 | p1_33@1555@01 | live]
; [else-branch: 2596 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 2596 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union Set(_single(1801678668)))
; [eval] (module_names_0 union Set(_single(1801678668)))
; [eval] Set(_single(1801678668))
; [eval] _single(1801678668)
(declare-const module_names_0@1725@01 Set<_Name>)
(assert (=
  module_names_0@1725@01
  (Set_union module_names_0@1588@01 (Set_singleton (_single<_Name> 1801678668)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(110369476601940)))
; [eval] (module_names_0 union Set(_single(110369476601940)))
; [eval] Set(_single(110369476601940))
; [eval] _single(110369476601940)
(declare-const module_names_0@1726@01 Set<_Name>)
(assert (=
  module_names_0@1726@01
  (Set_union module_names_0@1725@01 (Set_singleton (_single<_Name> 110369476601940)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(8390876207989219661)))
; [eval] (module_names_0 union Set(_single(8390876207989219661)))
; [eval] Set(_single(8390876207989219661))
; [eval] _single(8390876207989219661)
(declare-const module_names_0@1727@01 Set<_Name>)
(assert (=
  module_names_0@1727@01
  (Set_union module_names_0@1726@01 (Set_singleton (_single<_Name> 8390876207989219661)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(113740422079847)))
; [eval] (module_names_0 union Set(_single(113740422079847)))
; [eval] Set(_single(113740422079847))
; [eval] _single(113740422079847)
(declare-const module_names_0@1728@01 Set<_Name>)
(assert (=
  module_names_0@1728@01
  (Set_union module_names_0@1727@01 (Set_singleton (_single<_Name> 113740422079847)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(1852702201685183063399)))
; [eval] (module_names_0 union Set(_single(1852702201685183063399)))
; [eval] Set(_single(1852702201685183063399))
; [eval] _single(1852702201685183063399)
(declare-const module_names_0@1729@01 Set<_Name>)
(assert (=
  module_names_0@1729@01
  (Set_union module_names_0@1728@01 (Set_singleton (_single<_Name> 1852702201685183063399)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(7308324465919225674)))
; [eval] (module_names_0 union Set(_single(7308324465919225674)))
; [eval] Set(_single(7308324465919225674))
; [eval] _single(7308324465919225674)
(declare-const module_names_0@1730@01 Set<_Name>)
(assert (=
  module_names_0@1730@01
  (Set_union module_names_0@1729@01 (Set_singleton (_single<_Name> 7308324465919225674)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(549923908602661266679892)))
; [eval] (module_names_0 union Set(_single(549923908602661266679892)))
; [eval] Set(_single(549923908602661266679892))
; [eval] _single(549923908602661266679892)
(declare-const module_names_0@1731@01 Set<_Name>)
(assert (=
  module_names_0@1731@01
  (Set_union module_names_0@1730@01 (Set_singleton (_single<_Name> 549923908602661266679892)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(110416352273767)))
; [eval] (module_names_0 union Set(_single(110416352273767)))
; [eval] Set(_single(110416352273767))
; [eval] _single(110416352273767)
(declare-const module_names_0@1732@01 Set<_Name>)
(assert (=
  module_names_0@1732@01
  (Set_union module_names_0@1731@01 (Set_singleton (_single<_Name> 110416352273767)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(6779489)))
; [eval] (module_names_0 union Set(_single(6779489)))
; [eval] Set(_single(6779489))
; [eval] _single(6779489)
(declare-const module_names_0@1733@01 Set<_Name>)
(assert (=
  module_names_0@1733@01
  (Set_union module_names_0@1732@01 (Set_singleton (_single<_Name> 6779489)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(8038062462289584464661321053517)))
; [eval] (module_names_0 union Set(_single(8038062462289584464661321053517)))
; [eval] Set(_single(8038062462289584464661321053517))
; [eval] _single(8038062462289584464661321053517)
(declare-const module_names_0@1734@01 Set<_Name>)
(assert (=
  module_names_0@1734@01
  (Set_union module_names_0@1733@01 (Set_singleton (_single<_Name> 8038062462289584464661321053517)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(1999559502384759136599)))
; [eval] (module_names_0 union Set(_single(1999559502384759136599)))
; [eval] Set(_single(1999559502384759136599))
; [eval] _single(1999559502384759136599)
(declare-const module_names_0@1735@01 Set<_Name>)
(assert (=
  module_names_0@1735@01
  (Set_union module_names_0@1734@01 (Set_singleton (_single<_Name> 1999559502384759136599)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(465558725964)))
; [eval] (module_names_0 union Set(_single(465558725964)))
; [eval] Set(_single(465558725964))
; [eval] _single(465558725964)
(declare-const module_names_0@1736@01 Set<_Name>)
(assert (=
  module_names_0@1736@01
  (Set_union module_names_0@1735@01 (Set_singleton (_single<_Name> 465558725964)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(6872339552563453791)))
; [eval] (module_names_0 union Set(_single(6872339552563453791)))
; [eval] Set(_single(6872339552563453791))
; [eval] _single(6872339552563453791)
(declare-const module_names_0@1737@01 Set<_Name>)
(assert (=
  module_names_0@1737@01
  (Set_union module_names_0@1736@01 (Set_singleton (_single<_Name> 6872339552563453791)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(1819043139)))
; [eval] (module_names_0 union Set(_single(1819043139)))
; [eval] Set(_single(1819043139))
; [eval] _single(1819043139)
(declare-const module_names_0@1738@01 Set<_Name>)
(assert (=
  module_names_0@1738@01
  (Set_union module_names_0@1737@01 (Set_singleton (_single<_Name> 1819043139)))))
; [then-branch: 2597 | p2_33@1556@01 | dead]
; [else-branch: 2597 | !(p2_33@1556@01) | live]
(push) ; 10
; [else-branch: 2597 | !(p2_33@1556@01)]
(pop) ; 10
; [eval] !p2_33
(push) ; 10
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2598 | !(p2_33@1556@01) | live]
; [else-branch: 2598 | p2_33@1556@01 | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 2598 | !(p2_33@1556@01)]
; [exec]
; assert (p1_33 ==> true) &&
;   ((p2_33 ==> true) &&
;   ((p1_33 ==> (_single(1801678668) in module_names_0)) &&
;   (p2_33 ==> (_single(1801678668) in module_names_0_0))))
; [eval] p1_33 ==> true
(push) ; 11
(push) ; 12
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2599 | p1_33@1555@01 | live]
; [else-branch: 2599 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 2599 | p1_33@1555@01]
(pop) ; 12
(pop) ; 11
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 11
; [then-branch: 2600 | p2_33@1556@01 | dead]
; [else-branch: 2600 | !(p2_33@1556@01) | live]
(push) ; 12
; [else-branch: 2600 | !(p2_33@1556@01)]
(pop) ; 12
(pop) ; 11
; Joined path conditions
; [eval] p1_33 ==> (_single(1801678668) in module_names_0)
(push) ; 11
(push) ; 12
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2601 | p1_33@1555@01 | live]
; [else-branch: 2601 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 2601 | p1_33@1555@01]
; [eval] (_single(1801678668) in module_names_0)
; [eval] _single(1801678668)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_0@1738@01))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_0@1738@01)))
; [eval] p2_33 ==> (_single(1801678668) in module_names_0_0)
(push) ; 11
; [then-branch: 2602 | p2_33@1556@01 | dead]
; [else-branch: 2602 | !(p2_33@1556@01) | live]
(push) ; 12
; [else-branch: 2602 | !(p2_33@1556@01)]
(pop) ; 12
(pop) ; 11
; Joined path conditions
(push) ; 11
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2603 | p1_33@1555@01 | live]
; [else-branch: 2603 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 2603 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union Set(_single(7738150958779884867)))
; [eval] (module_names_0 union Set(_single(7738150958779884867)))
; [eval] Set(_single(7738150958779884867))
; [eval] _single(7738150958779884867)
(declare-const module_names_0@1739@01 Set<_Name>)
(assert (=
  module_names_0@1739@01
  (Set_union module_names_0@1738@01 (Set_singleton (_single<_Name> 7738150958779884867)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(2147778328593997130099)))
; [eval] (module_names_0 union Set(_single(2147778328593997130099)))
; [eval] Set(_single(2147778328593997130099))
; [eval] _single(2147778328593997130099)
(declare-const module_names_0@1740@01 Set<_Name>)
(assert (=
  module_names_0@1740@01
  (Set_union module_names_0@1739@01 (Set_singleton (_single<_Name> 2147778328593997130099)))))
; [then-branch: 2604 | p2_33@1556@01 | dead]
; [else-branch: 2604 | !(p2_33@1556@01) | live]
(push) ; 12
; [else-branch: 2604 | !(p2_33@1556@01)]
(pop) ; 12
; [eval] !p2_33
(push) ; 12
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2605 | !(p2_33@1556@01) | live]
; [else-branch: 2605 | p2_33@1556@01 | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 2605 | !(p2_33@1556@01)]
; [exec]
; assert (p1_33 ==> true) &&
;   ((p2_33 ==> true) &&
;   ((p1_33 ==> (_single(1801678668) in module_names_0)) &&
;   (p2_33 ==> (_single(1801678668) in module_names_0_0))))
; [eval] p1_33 ==> true
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2606 | p1_33@1555@01 | live]
; [else-branch: 2606 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 2606 | p1_33@1555@01]
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 13
; [then-branch: 2607 | p2_33@1556@01 | dead]
; [else-branch: 2607 | !(p2_33@1556@01) | live]
(push) ; 14
; [else-branch: 2607 | !(p2_33@1556@01)]
(pop) ; 14
(pop) ; 13
; Joined path conditions
; [eval] p1_33 ==> (_single(1801678668) in module_names_0)
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2608 | p1_33@1555@01 | live]
; [else-branch: 2608 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 2608 | p1_33@1555@01]
; [eval] (_single(1801678668) in module_names_0)
; [eval] _single(1801678668)
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_0@1740@01))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 1801678668) module_names_0@1740@01)))
; [eval] p2_33 ==> (_single(1801678668) in module_names_0_0)
(push) ; 13
; [then-branch: 2609 | p2_33@1556@01 | dead]
; [else-branch: 2609 | !(p2_33@1556@01) | live]
(push) ; 14
; [else-branch: 2609 | !(p2_33@1556@01)]
(pop) ; 14
(pop) ; 13
; Joined path conditions
(push) ; 13
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2610 | p1_33@1555@01 | live]
; [else-branch: 2610 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 2610 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(478792842068886668538480)))
; [eval] (module_names_0 union Set(_single(478792842068886668538480)))
; [eval] Set(_single(478792842068886668538480))
; [eval] _single(478792842068886668538480)
(declare-const module_names_0@1741@01 Set<_Name>)
(assert (=
  module_names_0@1741@01
  (Set_union module_names_0@1740@01 (Set_singleton (_single<_Name> 478792842068886668538480)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(2055831686330846900848)))
; [eval] (module_names_0 union Set(_single(2055831686330846900848)))
; [eval] Set(_single(2055831686330846900848))
; [eval] _single(2055831686330846900848)
(declare-const module_names_0@1742@01 Set<_Name>)
(assert (=
  module_names_0@1742@01
  (Set_union module_names_0@1741@01 (Set_singleton (_single<_Name> 2055831686330846900848)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(7308866606756098672)))
; [eval] (module_names_0 union Set(_single(7308866606756098672)))
; [eval] Set(_single(7308866606756098672))
; [eval] _single(7308866606756098672)
(declare-const module_names_0@1743@01 Set<_Name>)
(assert (=
  module_names_0@1743@01
  (Set_union module_names_0@1742@01 (Set_singleton (_single<_Name> 7308866606756098672)))))
; [then-branch: 2611 | p2_33@1556@01 | dead]
; [else-branch: 2611 | !(p2_33@1556@01) | live]
(push) ; 14
; [else-branch: 2611 | !(p2_33@1556@01)]
(pop) ; 14
; [eval] !p2_33
(push) ; 14
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2612 | !(p2_33@1556@01) | live]
; [else-branch: 2612 | p2_33@1556@01 | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 2612 | !(p2_33@1556@01)]
; [exec]
; assert (p1_33 ==> true) &&
;   ((p2_33 ==> true) &&
;   ((p1_33 ==> (_single(1819043139) in module_names_0)) &&
;   (p2_33 ==> (_single(1819043139) in module_names_0_0))))
; [eval] p1_33 ==> true
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2613 | p1_33@1555@01 | live]
; [else-branch: 2613 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 2613 | p1_33@1555@01]
(pop) ; 16
(pop) ; 15
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 15
; [then-branch: 2614 | p2_33@1556@01 | dead]
; [else-branch: 2614 | !(p2_33@1556@01) | live]
(push) ; 16
; [else-branch: 2614 | !(p2_33@1556@01)]
(pop) ; 16
(pop) ; 15
; Joined path conditions
; [eval] p1_33 ==> (_single(1819043139) in module_names_0)
(push) ; 15
(push) ; 16
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2615 | p1_33@1555@01 | live]
; [else-branch: 2615 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 2615 | p1_33@1555@01]
; [eval] (_single(1819043139) in module_names_0)
; [eval] _single(1819043139)
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 1819043139) module_names_0@1743@01))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 1819043139) module_names_0@1743@01)))
; [eval] p2_33 ==> (_single(1819043139) in module_names_0_0)
(push) ; 15
; [then-branch: 2616 | p2_33@1556@01 | dead]
; [else-branch: 2616 | !(p2_33@1556@01) | live]
(push) ; 16
; [else-branch: 2616 | !(p2_33@1556@01)]
(pop) ; 16
(pop) ; 15
; Joined path conditions
(push) ; 15
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2617 | p1_33@1555@01 | live]
; [else-branch: 2617 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 2617 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union Set(_single(1869768058)))
; [eval] (module_names_0 union Set(_single(1869768058)))
; [eval] Set(_single(1869768058))
; [eval] _single(1869768058)
(declare-const module_names_0@1744@01 Set<_Name>)
(assert (=
  module_names_0@1744@01
  (Set_union module_names_0@1743@01 (Set_singleton (_single<_Name> 1869768058)))))
; [then-branch: 2618 | p2_33@1556@01 | dead]
; [else-branch: 2618 | !(p2_33@1556@01) | live]
(push) ; 16
; [else-branch: 2618 | !(p2_33@1556@01)]
(pop) ; 16
; [eval] !p2_33
(push) ; 16
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2619 | !(p2_33@1556@01) | live]
; [else-branch: 2619 | p2_33@1556@01 | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 2619 | !(p2_33@1556@01)]
; [exec]
; assert (p1_33 ==> true) &&
;   ((p2_33 ==> true) &&
;   ((p1_33 ==> (_single(1819043139) in module_names_0)) &&
;   (p2_33 ==> (_single(1819043139) in module_names_0_0))))
; [eval] p1_33 ==> true
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2620 | p1_33@1555@01 | live]
; [else-branch: 2620 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 2620 | p1_33@1555@01]
(pop) ; 18
(pop) ; 17
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 17
; [then-branch: 2621 | p2_33@1556@01 | dead]
; [else-branch: 2621 | !(p2_33@1556@01) | live]
(push) ; 18
; [else-branch: 2621 | !(p2_33@1556@01)]
(pop) ; 18
(pop) ; 17
; Joined path conditions
; [eval] p1_33 ==> (_single(1819043139) in module_names_0)
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2622 | p1_33@1555@01 | live]
; [else-branch: 2622 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 2622 | p1_33@1555@01]
; [eval] (_single(1819043139) in module_names_0)
; [eval] _single(1819043139)
(pop) ; 18
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 1819043139) module_names_0@1744@01))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 1819043139) module_names_0@1744@01)))
; [eval] p2_33 ==> (_single(1819043139) in module_names_0_0)
(push) ; 17
; [then-branch: 2623 | p2_33@1556@01 | dead]
; [else-branch: 2623 | !(p2_33@1556@01) | live]
(push) ; 18
; [else-branch: 2623 | !(p2_33@1556@01)]
(pop) ; 18
(pop) ; 17
; Joined path conditions
(push) ; 17
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2624 | p1_33@1555@01 | live]
; [else-branch: 2624 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 2624 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union Set(_single(6647407)))
; [eval] (module_names_0 union Set(_single(6647407)))
; [eval] Set(_single(6647407))
; [eval] _single(6647407)
(declare-const module_names_0@1745@01 Set<_Name>)
(assert (=
  module_names_0@1745@01
  (Set_union module_names_0@1744@01 (Set_singleton (_single<_Name> 6647407)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(128017496632419)))
; [eval] (module_names_0 union Set(_single(128017496632419)))
; [eval] Set(_single(128017496632419))
; [eval] _single(128017496632419)
(declare-const module_names_0@1746@01 Set<_Name>)
(assert (=
  module_names_0@1746@01
  (Set_union module_names_0@1745@01 (Set_singleton (_single<_Name> 128017496632419)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(9224632863353764542590278070118)))
; [eval] (module_names_0 union Set(_single(9224632863353764542590278070118)))
; [eval] Set(_single(9224632863353764542590278070118))
; [eval] _single(9224632863353764542590278070118)
(declare-const module_names_0@1747@01 Set<_Name>)
(assert (=
  module_names_0@1747@01
  (Set_union module_names_0@1746@01 (Set_singleton (_single<_Name> 9224632863353764542590278070118)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(8606216570058403690)))
; [eval] (module_names_0 union Set(_single(8606216570058403690)))
; [eval] Set(_single(8606216570058403690))
; [eval] _single(8606216570058403690)
(declare-const module_names_0@1748@01 Set<_Name>)
(assert (=
  module_names_0@1748@01
  (Set_union module_names_0@1747@01 (Set_singleton (_single<_Name> 8606216570058403690)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(7303014)))
; [eval] (module_names_0 union Set(_single(7303014)))
; [eval] Set(_single(7303014))
; [eval] _single(7303014)
(declare-const module_names_0@1749@01 Set<_Name>)
(assert (=
  module_names_0@1749@01
  (Set_union module_names_0@1748@01 (Set_singleton (_single<_Name> 7303014)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(65)))
; [eval] (module_names_0 union Set(_single(65)))
; [eval] Set(_single(65))
; [eval] _single(65)
(declare-const module_names_0@1750@01 Set<_Name>)
(assert (=
  module_names_0@1750@01
  (Set_union module_names_0@1749@01 (Set_singleton (_single<_Name> 65)))))
; [then-branch: 2625 | p2_33@1556@01 | dead]
; [else-branch: 2625 | !(p2_33@1556@01) | live]
(push) ; 18
; [else-branch: 2625 | !(p2_33@1556@01)]
(pop) ; 18
; [eval] !p2_33
(push) ; 18
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2626 | !(p2_33@1556@01) | live]
; [else-branch: 2626 | p2_33@1556@01 | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 2626 | !(p2_33@1556@01)]
; [exec]
; assert (p1_33 ==> true) &&
;   ((p2_33 ==> true) &&
;   ((p1_33 ==> (_single(65) in module_names_0)) &&
;   (p2_33 ==> (_single(65) in module_names_0_0))))
; [eval] p1_33 ==> true
(push) ; 19
(push) ; 20
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2627 | p1_33@1555@01 | live]
; [else-branch: 2627 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 2627 | p1_33@1555@01]
(pop) ; 20
(pop) ; 19
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 19
; [then-branch: 2628 | p2_33@1556@01 | dead]
; [else-branch: 2628 | !(p2_33@1556@01) | live]
(push) ; 20
; [else-branch: 2628 | !(p2_33@1556@01)]
(pop) ; 20
(pop) ; 19
; Joined path conditions
; [eval] p1_33 ==> (_single(65) in module_names_0)
(push) ; 19
(push) ; 20
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2629 | p1_33@1555@01 | live]
; [else-branch: 2629 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 2629 | p1_33@1555@01]
; [eval] (_single(65) in module_names_0)
; [eval] _single(65)
(pop) ; 20
(pop) ; 19
; Joined path conditions
(push) ; 19
(assert (not (=> p1_33@1555@01 (Set_in (_single<_Name> 65) module_names_0@1750@01))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (=> p1_33@1555@01 (Set_in (_single<_Name> 65) module_names_0@1750@01)))
; [eval] p2_33 ==> (_single(65) in module_names_0_0)
(push) ; 19
; [then-branch: 2630 | p2_33@1556@01 | dead]
; [else-branch: 2630 | !(p2_33@1556@01) | live]
(push) ; 20
; [else-branch: 2630 | !(p2_33@1556@01)]
(pop) ; 20
(pop) ; 19
; Joined path conditions
(push) ; 19
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2631 | p1_33@1555@01 | live]
; [else-branch: 2631 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 2631 | p1_33@1555@01]
; [exec]
; module_names_0 := (module_names_0 union Set(_single(7303014)))
; [eval] (module_names_0 union Set(_single(7303014)))
; [eval] Set(_single(7303014))
; [eval] _single(7303014)
(declare-const module_names_0@1751@01 Set<_Name>)
(assert (=
  module_names_0@1751@01
  (Set_union module_names_0@1750@01 (Set_singleton (_single<_Name> 7303014)))))
; [exec]
; module_names_0 := (module_names_0 union Set(_single(66)))
; [eval] (module_names_0 union Set(_single(66)))
; [eval] Set(_single(66))
; [eval] _single(66)
(declare-const module_names_0@1752@01 Set<_Name>)
(assert (=
  module_names_0@1752@01
  (Set_union module_names_0@1751@01 (Set_singleton (_single<_Name> 66)))))
; [exec]
; module_names_0 := (module_names_0 union
;   Set(_single(8748815751553023034868178699518350214131562)))
; [eval] (module_names_0 union Set(_single(8748815751553023034868178699518350214131562)))
; [eval] Set(_single(8748815751553023034868178699518350214131562))
; [eval] _single(8748815751553023034868178699518350214131562)
(declare-const module_names_0@1753@01 Set<_Name>)
(assert (=
  module_names_0@1753@01
  (Set_union module_names_0@1752@01 (Set_singleton (_single<_Name> 8748815751553023034868178699518350214131562)))))
; [then-branch: 2632 | p2_33@1556@01 | dead]
; [else-branch: 2632 | !(p2_33@1556@01) | live]
(push) ; 20
; [else-branch: 2632 | !(p2_33@1556@01)]
(pop) ; 20
; [eval] !p2_33
(push) ; 20
(set-option :timeout 10)
(assert (not p2_33@1556@01))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2633 | !(p2_33@1556@01) | live]
; [else-branch: 2633 | p2_33@1556@01 | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 2633 | !(p2_33@1556@01)]
; [exec]
; assert true
; [eval] p1_33 ==> true
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2634 | p1_33@1555@01 | live]
; [else-branch: 2634 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 2634 | p1_33@1555@01]
(pop) ; 22
(pop) ; 21
; Joined path conditions
; [eval] p2_33 ==> true
(push) ; 21
; [then-branch: 2635 | p2_33@1556@01 | dead]
; [else-branch: 2635 | !(p2_33@1556@01) | live]
(push) ; 22
; [else-branch: 2635 | !(p2_33@1556@01)]
(pop) ; 22
(pop) ; 21
; Joined path conditions
; [eval] p1_33 ==> (forperm _r_61: Ref [MustInvokeBounded(_r_61)] :: false) && ((forperm _r_61: Ref [MustInvokeUnbounded(_r_61)] :: false) && ((forperm _r_61: Ref [_r_61.MustReleaseBounded] :: false) && (forperm _r_61: Ref [_r_61.MustReleaseUnbounded] :: false)))
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not p1_33@1555@01)))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2636 | p1_33@1555@01 | live]
; [else-branch: 2636 | !(p1_33@1555@01) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 2636 | p1_33@1555@01]
; [eval] (forperm _r_61: Ref [MustInvokeBounded(_r_61)] :: false) && ((forperm _r_61: Ref [MustInvokeUnbounded(_r_61)] :: false) && ((forperm _r_61: Ref [_r_61.MustReleaseBounded] :: false) && (forperm _r_61: Ref [_r_61.MustReleaseUnbounded] :: false)))
; [eval] (forperm _r_61: Ref [MustInvokeBounded(_r_61)] :: false)
(push) ; 23
; [then-branch: 2637 | False | live]
; [else-branch: 2637 | True | live]
(push) ; 24
; [then-branch: 2637 | False]
(assert false)
(pop) ; 24
(push) ; 24
; [else-branch: 2637 | True]
; [eval] (forperm _r_61: Ref [MustInvokeUnbounded(_r_61)] :: false)
(push) ; 25
; [then-branch: 2638 | False | live]
; [else-branch: 2638 | True | live]
(push) ; 26
; [then-branch: 2638 | False]
(assert false)
(pop) ; 26
(push) ; 26
; [else-branch: 2638 | True]
; [eval] (forperm _r_61: Ref [_r_61.MustReleaseBounded] :: false)
(push) ; 27
; [then-branch: 2639 | False | live]
; [else-branch: 2639 | True | live]
(push) ; 28
; [then-branch: 2639 | False]
(assert false)
(pop) ; 28
(push) ; 28
; [else-branch: 2639 | True]
; [eval] (forperm _r_61: Ref [_r_61.MustReleaseUnbounded] :: false)
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(pop) ; 22
(pop) ; 21
; Joined path conditions
; [eval] p2_33 ==> (forperm _r_61: Ref [MustInvokeBounded_0(_r_61)] :: false) && ((forperm _r_61: Ref [MustInvokeUnbounded_0(_r_61)] :: false) && ((forperm _r_61: Ref [_r_61.MustReleaseBoundedp] :: false) && (forperm _r_61: Ref [_r_61.MustReleaseUnboundedp] :: false)))
(push) ; 21
; [then-branch: 2640 | p2_33@1556@01 | dead]
; [else-branch: 2640 | !(p2_33@1556@01) | live]
(push) ; 22
; [else-branch: 2640 | !(p2_33@1556@01)]
(pop) ; 22
(pop) ; 21
; Joined path conditions
(pop) ; 20
(pop) ; 19
; [eval] !p1_33
; [then-branch: 2641 | !(p1_33@1555@01) | dead]
; [else-branch: 2641 | p1_33@1555@01 | live]
(push) ; 19
; [else-branch: 2641 | p1_33@1555@01]
(pop) ; 19
(pop) ; 18
(pop) ; 17
; [eval] !p1_33
; [then-branch: 2642 | !(p1_33@1555@01) | dead]
; [else-branch: 2642 | p1_33@1555@01 | live]
(push) ; 17
; [else-branch: 2642 | p1_33@1555@01]
(pop) ; 17
(pop) ; 16
(pop) ; 15
; [eval] !p1_33
; [then-branch: 2643 | !(p1_33@1555@01) | dead]
; [else-branch: 2643 | p1_33@1555@01 | live]
(push) ; 15
; [else-branch: 2643 | p1_33@1555@01]
(pop) ; 15
(pop) ; 14
(pop) ; 13
; [eval] !p1_33
; [then-branch: 2644 | !(p1_33@1555@01) | dead]
; [else-branch: 2644 | p1_33@1555@01 | live]
(push) ; 13
; [else-branch: 2644 | p1_33@1555@01]
(pop) ; 13
(pop) ; 12
(pop) ; 11
; [eval] !p1_33
; [then-branch: 2645 | !(p1_33@1555@01) | dead]
; [else-branch: 2645 | p1_33@1555@01 | live]
(push) ; 11
; [else-branch: 2645 | p1_33@1555@01]
(pop) ; 11
(pop) ; 10
(pop) ; 9
; [eval] !p1_33
; [then-branch: 2646 | !(p1_33@1555@01) | dead]
; [else-branch: 2646 | p1_33@1555@01 | live]
(push) ; 9
; [else-branch: 2646 | p1_33@1555@01]
(pop) ; 9
(pop) ; 8
(pop) ; 7
; [eval] !p1_34
; [then-branch: 2647 | !(p1_33@1555@01) | dead]
; [else-branch: 2647 | p1_33@1555@01 | live]
(push) ; 7
; [else-branch: 2647 | p1_33@1555@01]
(pop) ; 7
(pop) ; 6
(pop) ; 5
; [eval] !p1_34
; [then-branch: 2648 | !(p1_33@1555@01) | dead]
; [else-branch: 2648 | p1_33@1555@01 | live]
(push) ; 5
; [else-branch: 2648 | p1_33@1555@01]
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 2573 | p2_33@1556@01]
(assert p2_33@1556@01)
(pop) ; 4
(pop) ; 3
; [eval] !p1_33
; [then-branch: 2649 | !(p1_33@1555@01) | dead]
; [else-branch: 2649 | p1_33@1555@01 | live]
(push) ; 3
; [else-branch: 2649 | p1_33@1555@01]
(pop) ; 3
(pop) ; 2
(pop) ; 1
