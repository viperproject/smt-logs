(get-info :version)
; (:version "4.12.1")
; Started: 2024-12-26 14:23:54
; Silicon.version: 1.1-SNAPSHOT (457c6eca@(detached))
; Input file: <unknown>
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Necessary for push pop mode
(set-option :auto_config false)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :type_check true)
(set-option :smt.mbqi false)
(set-option :pp.bv_literals false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.arith.solver 2)
(set-option :model.v2 true)
(set-option :smt.qi.max_multi_patterns 1000)
; 
; ; /preamble.smt2
(declare-datatypes (($Snap 0)) ((
    ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM 0)
(declare-sort $PPM 0)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Set<$Ref> 0)
(declare-sort Set<Int> 0)
(declare-sort Set<Bool> 0)
(declare-sort Set<$Snap> 0)
(declare-sort $FVF<val_ref> 0)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<Bool>To$Snap (Set<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Bool> ($Snap) Set<Bool>)
(assert (forall ((x Set<Bool>)) (!
    (= x ($SortWrappers.$SnapToSet<Bool>($SortWrappers.Set<Bool>To$Snap x)))
    :pattern (($SortWrappers.Set<Bool>To$Snap x))
    :qid |$Snap.$SnapToSet<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Bool>To$Snap($SortWrappers.$SnapToSet<Bool> x)))
    :pattern (($SortWrappers.$SnapToSet<Bool> x))
    :qid |$Snap.Set<Bool>To$SnapToSet<Bool>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<val_ref>To$Snap ($FVF<val_ref>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<val_ref> ($Snap) $FVF<val_ref>)
(assert (forall ((x $FVF<val_ref>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<val_ref>($SortWrappers.$FVF<val_ref>To$Snap x)))
    :pattern (($SortWrappers.$FVF<val_ref>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<val_ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<val_ref>To$Snap($SortWrappers.$SnapTo$FVF<val_ref> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<val_ref> x))
    :qid |$Snap.$FVF<val_ref>To$SnapTo$FVF<val_ref>|
    )))
; ////////// Symbols
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_skolem_diff (Set<$Ref> Set<$Ref>) $Ref)
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_skolem_diff (Set<Int> Set<Int>) Int)
(declare-fun Set_card (Set<Bool>) Int)
(declare-const Set_empty Set<Bool>)
(declare-fun Set_in (Bool Set<Bool>) Bool)
(declare-fun Set_singleton (Bool) Set<Bool>)
(declare-fun Set_unionone (Set<Bool> Bool) Set<Bool>)
(declare-fun Set_union (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_intersection (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_difference (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_subset (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_equal (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_skolem_diff (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_skolem_diff (Set<$Snap> Set<$Snap>) $Snap)
; /field_value_functions_declarations.smt2 [val_ref: Ref]
(declare-fun $FVF.domain_val_ref ($FVF<val_ref>) Set<$Ref>)
(declare-fun $FVF.lookup_val_ref ($FVF<val_ref> $Ref) $Ref)
(declare-fun $FVF.after_val_ref ($FVF<val_ref> $FVF<val_ref>) Bool)
(declare-fun $FVF.loc_val_ref ($Ref $Ref) Bool)
(declare-fun $FVF.perm_val_ref ($FPM $Ref) $Perm)
(declare-const $fvfTOP_val_ref $FVF<val_ref>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun read$ ($Snap) $Perm)
(declare-fun read$%limited ($Snap) $Perm)
(declare-const read$%stateless Bool)
(declare-fun read$%precondition ($Snap) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap $Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited ($Snap $Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%stateless ($Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap $Ref) Bool)
(declare-fun builtin$unreach_int__$TY$__$int$ ($Snap) Int)
(declare-fun builtin$unreach_int__$TY$__$int$%limited ($Snap) Int)
(declare-const builtin$unreach_int__$TY$__$int$%stateless Bool)
(declare-fun builtin$unreach_int__$TY$__$int$%precondition ($Snap) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap $Ref) Int)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited ($Snap $Ref) Int)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless ($Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap $Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap $Ref Int) Int)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap $Ref Int) Int)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%stateless ($Ref Int) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap $Ref Int) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap $Ref) Int)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%limited ($Snap $Ref) Int)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless ($Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap $Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap $Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited ($Snap $Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%stateless ($Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap $Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap $Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited ($Snap $Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%stateless ($Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap $Ref) Bool)
(declare-fun builtin$undef_int__$TY$__$int$ ($Snap) Int)
(declare-fun builtin$undef_int__$TY$__$int$%limited ($Snap) Int)
(declare-const builtin$undef_int__$TY$__$int$%stateless Bool)
(declare-fun builtin$undef_int__$TY$__$int$%precondition ($Snap) Bool)
(declare-fun builtin$unreach_bool__$TY$__$bool$ ($Snap) Bool)
(declare-fun builtin$unreach_bool__$TY$__$bool$%limited ($Snap) Bool)
(declare-const builtin$unreach_bool__$TY$__$bool$%stateless Bool)
(declare-fun builtin$unreach_bool__$TY$__$bool$%precondition ($Snap) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap $Ref Int) Int)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap $Ref Int) Int)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%stateless ($Ref Int) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap $Ref Int) Bool)
(declare-fun m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap $Ref) Int)
(declare-fun m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited ($Snap $Ref) Int)
(declare-fun m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless ($Ref) Bool)
(declare-fun m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap $Ref) Bool)
(declare-fun builtin$undef_bool__$TY$__$bool$ ($Snap) Bool)
(declare-fun builtin$undef_bool__$TY$__$bool$%limited ($Snap) Bool)
(declare-const builtin$undef_bool__$TY$__$bool$%stateless Bool)
(declare-fun builtin$undef_bool__$TY$__$bool$%precondition ($Snap) Bool)
(declare-fun m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap $Ref) Int)
(declare-fun m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited ($Snap $Ref) Int)
(declare-fun m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless ($Ref) Bool)
(declare-fun m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap $Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap $Ref) Int)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited ($Snap $Ref) Int)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless ($Ref) Bool)
(declare-fun m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap $Ref) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun DeadBorrowToken$%trigger ($Snap Int) Bool)
(declare-fun bool%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_13$3$285504012641001254%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_14$3$15375066495536163397%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_15$3$2868002597210616443%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_16$3$9316913858590951640%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_17$4$532893136756078670%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_23$3$5372843592026537153%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_24$3$3010475301938644702%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_25$3$3868597211286645367%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_26$4$17874368375826697435%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_27$4$11880881688395209060%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_28$4$2464236529596893172%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_29$5$13550867090471520830%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_30$3$9316913858590951640%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_31$4$10198083371420618695%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_32$3$14146303487322046002%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_33$3$10819110499908836502%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_34$4$18248137411596842664%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_35$3$1800990638667843567%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_36$4$4559978894891083623%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_37$4$8424733456540362922%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_38$3$11417723233936340610%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_39$3$1132657330059599590%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_40$3$7625693188187510870%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_41$3$13640473792123223955%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_42$3$1451880131427103804%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_43$3$17900001731891322914%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_44$3$11711303054302998842%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_45$4$16397435947654686472%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_46$3$5039206468203838448%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_47$3$8565491267176139305%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_48$3$12939604231988721118%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_49$3$2385238782922955094%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_50$4$11829941760534454793%trigger ($Snap $Ref) Bool)
(declare-fun closure$0_1_51$4$13939029741107599013%trigger ($Snap $Ref) Bool)
(declare-fun i32%trigger ($Snap $Ref) Bool)
(declare-fun isize%trigger ($Snap $Ref) Bool)
(declare-fun m_alloc$$boxed$opensqu$0$closesqu$$$Box$opensqu$0$closesqu$$_beg_$m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_More%trigger ($Snap $Ref) Bool)
(declare-fun m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some%trigger ($Snap $Ref) Bool)
(declare-fun never%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_13$3$285504012641001254%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_14$3$15375066495536163397%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_15$3$2868002597210616443%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_16$3$9316913858590951640%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_17$4$532893136756078670%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_23$3$5372843592026537153%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_24$3$3010475301938644702%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_25$3$3868597211286645367%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_26$4$17874368375826697435%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_27$4$11880881688395209060%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_28$4$2464236529596893172%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_29$5$13550867090471520830%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_30$3$9316913858590951640%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_31$4$10198083371420618695%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_32$3$14146303487322046002%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_33$3$10819110499908836502%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_34$4$18248137411596842664%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_35$3$1800990638667843567%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_36$4$4559978894891083623%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_37$4$8424733456540362922%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_38$3$11417723233936340610%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_39$3$1132657330059599590%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_40$3$7625693188187510870%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_41$3$13640473792123223955%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_42$3$1451880131427103804%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_43$3$17900001731891322914%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_44$3$11711303054302998842%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_45$4$16397435947654686472%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_46$3$5039206468203838448%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_47$3$8565491267176139305%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_48$3$12939604231988721118%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_49$3$2385238782922955094%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_50$4$11829941760534454793%trigger ($Snap $Ref) Bool)
(declare-fun ref$closure$0_1_51$4$13939029741107599013%trigger ($Snap $Ref) Bool)
(declare-fun ref$i32%trigger ($Snap $Ref) Bool)
(declare-fun ref$m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun ref$m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun ref$m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun ref$m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun ref$ref$m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun ref$ref$m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun ref$ref$m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap $Ref) Bool)
(declare-fun ref$str%trigger ($Snap $Ref) Bool)
(declare-fun ref$tuple3$ref$str$u32$u32%trigger ($Snap $Ref) Bool)
(declare-fun ref$usize%trigger ($Snap $Ref) Bool)
(declare-fun str%trigger ($Snap $Ref) Bool)
(declare-fun tuple0$%trigger ($Snap $Ref) Bool)
(declare-fun tuple2$usize$bool%trigger ($Snap $Ref) Bool)
(declare-fun tuple3$ref$str$u32$u32%trigger ($Snap $Ref) Bool)
(declare-fun u32%trigger ($Snap $Ref) Bool)
(declare-fun u8%trigger ($Snap $Ref) Bool)
(declare-fun usize%trigger ($Snap $Ref) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Ref)) (!
  (not (Set_in o (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in o (as Set_empty  Set<$Ref>)))
  )))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Ref))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Ref)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Ref) (o $Ref)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Ref)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (o $Ref)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Ref)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o Int)) (!
  (not (Set_in o (as Set_empty  Set<Int>)))
  :pattern ((Set_in o (as Set_empty  Set<Int>)))
  )))
(assert (forall ((s Set<Int>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (=> (not (= (Set_card s) 0)) (exists ((x Int))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r Int)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r Int) (o Int)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r Int)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<Int>) (x Int) (o Int)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<Int>) (x Int)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<Int>) (x Int) (y Int)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<Int>) (x Int)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Int>) (x Int)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (o Int)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (y Int)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (y Int)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (o Int)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (o Int)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (y Int)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (=
    (Set_subset a b)
    (forall ((o Int)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<Bool>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o Bool)) (!
  (not (Set_in o (as Set_empty  Set<Bool>)))
  :pattern ((Set_in o (as Set_empty  Set<Bool>)))
  )))
(assert (forall ((s Set<Bool>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<Bool>)))
    (=> (not (= (Set_card s) 0)) (exists ((x Bool))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r Bool)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r Bool) (o Bool)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r Bool)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<Bool>) (x Bool) (o Bool)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<Bool>) (x Bool)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<Bool>) (x Bool) (y Bool)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<Bool>) (x Bool)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Bool>) (x Bool)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>) (o Bool)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>) (y Bool)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>) (y Bool)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>) (o Bool)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>) (o Bool)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>) (y Bool)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>)) (!
  (=
    (Set_subset a b)
    (forall ((o Bool)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<Bool>) (b Set<Bool>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Snap)) (!
  (not (Set_in o (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in o (as Set_empty  Set<$Snap>)))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Snap))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Snap)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Snap) (o $Snap)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Snap)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (o $Snap)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Snap)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
; /field_value_functions_axioms.smt2 [val_ref: Ref]
(assert (forall ((vs $FVF<val_ref>) (ws $FVF<val_ref>)) (!
    (=>
      (and
        (Set_equal ($FVF.domain_val_ref vs) ($FVF.domain_val_ref ws))
        (forall ((x $Ref)) (!
          (=>
            (Set_in x ($FVF.domain_val_ref vs))
            (= ($FVF.lookup_val_ref vs x) ($FVF.lookup_val_ref ws x)))
          :pattern (($FVF.lookup_val_ref vs x) ($FVF.lookup_val_ref ws x))
          :qid |qp.$FVF<val_ref>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<val_ref>To$Snap vs)
              ($SortWrappers.$FVF<val_ref>To$Snap ws)
              )
    :qid |qp.$FVF<val_ref>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_val_ref pm r))
    :pattern (($FVF.perm_val_ref pm r)))))
(assert (forall ((r $Ref) (f $Ref)) (!
    (= ($FVF.loc_val_ref f r) true)
    :pattern (($FVF.loc_val_ref f r)))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun joined_unfolding@29@00 ($Snap $Ref) Bool)
(declare-fun joined_unfolding@31@00 ($Snap $Ref) Int)
(declare-fun joined_unfolding@36@00 ($Snap $Ref) Bool)
(declare-fun joined_unfolding@38@00 ($Snap $Ref) Bool)
(declare-fun joined_unfolding@41@00 ($Snap $Ref) Int)
(declare-fun joined_unfolding@43@00 ($Snap $Ref) Int)
(declare-fun $unresolved@33@00 () $Snap)
(declare-fun $unresolved@45@00 () $Snap)
(assert (forall ((s@$ $Snap)) (!
  (= (read$%limited s@$) (read$ s@$))
  :pattern ((read$ s@$))
  :qid |quant-u-277|)))
(assert (forall ((s@$ $Snap)) (!
  (as read$%stateless  Bool)
  :pattern ((read$%limited s@$))
  :qid |quant-u-278|)))
(assert (forall ((s@$ $Snap)) (!
  (let ((result@0@00 (read$%limited s@$))) (=>
    (read$%precondition s@$)
    (and (< $Perm.No result@0@00) (< result@0@00 $Perm.Write))))
  :pattern ((read$%limited s@$))
  :qid |quant-u-307|)))
(assert (forall ((s@$ $Snap)) (!
  (let ((result@0@00 (read$%limited s@$))) true)
  :pattern ((read$%limited s@$))
  :qid |quant-u-308|)))
(assert (forall ((s@$ $Snap)) (!
  (let ((result@0@00 (read$%limited s@$))) true)
  :pattern ((read$%limited s@$))
  :qid |quant-u-309|)))
(assert (forall ((s@$ $Snap) (_pure_1@1@00 $Ref)) (!
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@1@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@1@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@1@00))
  :qid |quant-u-279|)))
(assert (forall ((s@$ $Snap) (_pure_1@1@00 $Ref)) (!
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%stateless _pure_1@1@00)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@1@00))
  :qid |quant-u-280|)))
(assert (forall ((s@$ $Snap) (_pure_1@1@00 $Ref)) (!
  (let ((result@2@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@1@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@1@00))
  :qid |quant-u-310|)))
(assert (forall ((s@$ $Snap) (_pure_1@1@00 $Ref)) (!
  (let ((result@2@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@1@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@1@00))
  :qid |quant-u-311|)))
(assert (forall ((s@$ $Snap) (_pure_1@1@00 $Ref)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition s@$ _pure_1@1@00)
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@1@00)
      (= ($SortWrappers.$SnapToInt ($Snap.first ($Snap.first s@$))) 0)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@1@00))
  :qid |quant-u-312|)))
(assert (forall ((s@$ $Snap) (_pure_1@1@00 $Ref)) (!
  true
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@1@00))
  :qid |quant-u-313|)))
(assert (forall ((s@$ $Snap)) (!
  (=
    (builtin$unreach_int__$TY$__$int$%limited s@$)
    (builtin$unreach_int__$TY$__$int$ s@$))
  :pattern ((builtin$unreach_int__$TY$__$int$ s@$))
  :qid |quant-u-281|)))
(assert (forall ((s@$ $Snap)) (!
  (as builtin$unreach_int__$TY$__$int$%stateless  Bool)
  :pattern ((builtin$unreach_int__$TY$__$int$%limited s@$))
  :qid |quant-u-282|)))
(assert (forall ((s@$ $Snap) (_pure_1@4@00 $Ref)) (!
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@4@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@4@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@4@00))
  :qid |quant-u-283|)))
(assert (forall ((s@$ $Snap) (_pure_1@4@00 $Ref)) (!
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless _pure_1@4@00)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@4@00))
  :qid |quant-u-284|)))
(assert (forall ((s@$ $Snap) (_pure_1@4@00 $Ref)) (!
  (let ((result@5@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@4@00))) (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ _pure_1@4@00)
    (and
      (and
        (=>
          (not
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
              ($Snap.first s@$)
              $Snap.unit) _pure_1@4@00))
          (> result@5@00 0))
        (>= result@5@00 0))
      (<= 0 result@5@00))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@4@00))
  :qid |quant-u-314|)))
(assert (forall ((s@$ $Snap) (_pure_1@4@00 $Ref)) (!
  (let ((result@5@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@4@00))) (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ _pure_1@4@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      ($Snap.first s@$)
      $Snap.unit) _pure_1@4@00)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@4@00))
  :qid |quant-u-315|)))
(assert (forall ((s@$ $Snap) (_pure_1@4@00 $Ref)) (!
  (let ((result@5@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@4@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@4@00))
  :qid |quant-u-316|)))
(assert (forall ((s@$ $Snap) (_pure_1@4@00 $Ref)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ _pure_1@4@00)
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@4@00)
      (ite
        (= ($SortWrappers.$SnapToInt ($Snap.first ($Snap.first s@$))) 0)
        0
        (+
          1
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited ($Snap.combine
            ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.first s@$))))))))))
            $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.first s@$))))))))))))))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@4@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless _pure_1@4@00) (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.first s@$) _pure_1@4@00))
  :qid |quant-u-317|)))
(assert (forall ((s@$ $Snap) (_pure_1@4@00 $Ref)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ _pure_1@4@00)
    (ite
      (= ($SortWrappers.$SnapToInt ($Snap.first ($Snap.first s@$))) 0)
      true
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.first s@$))))))))))
        $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.first s@$))))))))))))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@4@00))
  :qid |quant-u-318|)))
(assert (forall ((s@$ $Snap) (_pure_1@6@00 $Ref) (_pure_2@7@00 Int)) (!
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@6@00 _pure_2@7@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ s@$ _pure_1@6@00 _pure_2@7@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ s@$ _pure_1@6@00 _pure_2@7@00))
  :qid |quant-u-285|)))
(assert (forall ((s@$ $Snap) (_pure_1@6@00 $Ref) (_pure_2@7@00 Int)) (!
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%stateless _pure_1@6@00 _pure_2@7@00)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@6@00 _pure_2@7@00))
  :qid |quant-u-286|)))
(assert (forall ((s@$ $Snap) (_pure_1@6@00 $Ref) (_pure_2@7@00 Int)) (!
  (let ((result@8@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@6@00 _pure_2@7@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@6@00 _pure_2@7@00))
  :qid |quant-u-319|)))
(assert (forall ((s@$ $Snap) (_pure_1@6@00 $Ref) (_pure_2@7@00 Int)) (!
  (let ((result@8@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@6@00 _pure_2@7@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@6@00 _pure_2@7@00))
  :qid |quant-u-320|)))
(assert (forall ((s@$ $Snap) (_pure_1@6@00 $Ref) (_pure_2@7@00 Int)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition s@$ _pure_1@6@00 _pure_2@7@00)
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ s@$ _pure_1@6@00 _pure_2@7@00)
      (ite
        (= ($SortWrappers.$SnapToInt ($Snap.first ($Snap.first s@$))) 0)
        (builtin$unreach_int__$TY$__$int$ $unresolved@33@00)
        (ite
          (not (= _pure_2@7@00 0))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
            ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.first s@$))))))))))
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.first s@$))))))))))) (-
            _pure_2@7@00
            1))
          ($SortWrappers.$SnapToInt ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.first s@$))))))))))))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ s@$ _pure_1@6@00 _pure_2@7@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%stateless _pure_1@6@00 _pure_2@7@00) (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.first s@$) _pure_1@6@00))
  :qid |quant-u-321|)))
(assert (forall ((s@$ $Snap) (_pure_1@6@00 $Ref) (_pure_2@7@00 Int)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition s@$ _pure_1@6@00 _pure_2@7@00)
    (ite
      (= ($SortWrappers.$SnapToInt ($Snap.first ($Snap.first s@$))) 0)
      (builtin$unreach_int__$TY$__$int$%precondition $unresolved@33@00)
      (ite
        (not (= _pure_2@7@00 0))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.first s@$))))))))))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.first s@$))))))))))) (-
          _pure_2@7@00
          1))
        true)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ s@$ _pure_1@6@00 _pure_2@7@00))
  :qid |quant-u-322|)))
(assert (forall ((s@$ $Snap) (_pure_1@9@00 $Ref)) (!
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@9@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@9@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@9@00))
  :qid |quant-u-287|)))
(assert (forall ((s@$ $Snap) (_pure_1@9@00 $Ref)) (!
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless _pure_1@9@00)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@9@00))
  :qid |quant-u-288|)))
(assert (forall ((s@$ $Snap) (_pure_1@9@00 $Ref)) (!
  (let ((result@10@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@9@00))) (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ _pure_1@9@00)
    (<= 0 result@10@00)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@9@00))
  :qid |quant-u-323|)))
(assert (forall ((s@$ $Snap) (_pure_1@9@00 $Ref)) (!
  (let ((result@10@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@9@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@9@00))
  :qid |quant-u-324|)))
(assert (forall ((s@$ $Snap) (_pure_1@9@00 $Ref)) (!
  (let ((result@10@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@9@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@9@00))
  :qid |quant-u-325|)))
(assert (forall ((s@$ $Snap) (_pure_1@9@00 $Ref)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ _pure_1@9@00)
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@9@00)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.second ($Snap.first s@$))
        $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first s@$))))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@9@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless _pure_1@9@00) (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.first s@$) _pure_1@9@00))
  :qid |quant-u-326|)))
(assert (forall ((s@$ $Snap) (_pure_1@9@00 $Ref)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ _pure_1@9@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      ($Snap.second ($Snap.first s@$))
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first s@$)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@9@00))
  :qid |quant-u-327|)))
(assert (forall ((s@$ $Snap) (_pure_1@11@00 $Ref)) (!
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@11@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@11@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@11@00))
  :qid |quant-u-289|)))
(assert (forall ((s@$ $Snap) (_pure_1@11@00 $Ref)) (!
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%stateless _pure_1@11@00)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@11@00))
  :qid |quant-u-290|)))
(assert (forall ((s@$ $Snap) (_pure_1@11@00 $Ref)) (!
  (let ((result@12@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@11@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@11@00))
  :qid |quant-u-328|)))
(assert (forall ((s@$ $Snap) (_pure_1@11@00 $Ref)) (!
  (let ((result@12@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@11@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@11@00))
  :qid |quant-u-329|)))
(assert (forall ((s@$ $Snap) (_pure_1@11@00 $Ref)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition s@$ _pure_1@11@00)
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@11@00)
      (= ($SortWrappers.$SnapToInt ($Snap.first ($Snap.first s@$))) 0)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@11@00))
  :qid |quant-u-330|)))
(assert (forall ((s@$ $Snap) (_pure_1@11@00 $Ref)) (!
  true
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@11@00))
  :qid |quant-u-331|)))
(assert (forall ((s@$ $Snap) (_pure_1@13@00 $Ref)) (!
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@13@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@13@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@13@00))
  :qid |quant-u-291|)))
(assert (forall ((s@$ $Snap) (_pure_1@13@00 $Ref)) (!
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%stateless _pure_1@13@00)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@13@00))
  :qid |quant-u-292|)))
(assert (forall ((s@$ $Snap) (_pure_1@13@00 $Ref)) (!
  (let ((result@14@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@13@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@13@00))
  :qid |quant-u-332|)))
(assert (forall ((s@$ $Snap) (_pure_1@13@00 $Ref)) (!
  (let ((result@14@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@13@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%limited s@$ _pure_1@13@00))
  :qid |quant-u-333|)))
(assert (forall ((s@$ $Snap) (_pure_1@13@00 $Ref)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition s@$ _pure_1@13@00)
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@13@00)
      (not (= ($SortWrappers.$SnapToInt ($Snap.first ($Snap.first s@$))) 0))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@13@00))
  :qid |quant-u-334|)))
(assert (forall ((s@$ $Snap) (_pure_1@13@00 $Ref)) (!
  true
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ s@$ _pure_1@13@00))
  :qid |quant-u-335|)))
(assert (forall ((s@$ $Snap)) (!
  (=
    (builtin$undef_int__$TY$__$int$%limited s@$)
    (builtin$undef_int__$TY$__$int$ s@$))
  :pattern ((builtin$undef_int__$TY$__$int$ s@$))
  :qid |quant-u-293|)))
(assert (forall ((s@$ $Snap)) (!
  (as builtin$undef_int__$TY$__$int$%stateless  Bool)
  :pattern ((builtin$undef_int__$TY$__$int$%limited s@$))
  :qid |quant-u-294|)))
(assert (forall ((s@$ $Snap)) (!
  (=
    (builtin$unreach_bool__$TY$__$bool$%limited s@$)
    (builtin$unreach_bool__$TY$__$bool$ s@$))
  :pattern ((builtin$unreach_bool__$TY$__$bool$ s@$))
  :qid |quant-u-295|)))
(assert (forall ((s@$ $Snap)) (!
  (as builtin$unreach_bool__$TY$__$bool$%stateless  Bool)
  :pattern ((builtin$unreach_bool__$TY$__$bool$%limited s@$))
  :qid |quant-u-296|)))
(assert (forall ((s@$ $Snap) (_pure_1@17@00 $Ref) (_pure_2@18@00 Int)) (!
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@17@00 _pure_2@18@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ s@$ _pure_1@17@00 _pure_2@18@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ s@$ _pure_1@17@00 _pure_2@18@00))
  :qid |quant-u-297|)))
(assert (forall ((s@$ $Snap) (_pure_1@17@00 $Ref) (_pure_2@18@00 Int)) (!
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%stateless _pure_1@17@00 _pure_2@18@00)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@17@00 _pure_2@18@00))
  :qid |quant-u-298|)))
(assert (forall ((s@$ $Snap) (_pure_1@17@00 $Ref) (_pure_2@18@00 Int)) (!
  (let ((result@19@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@17@00 _pure_2@18@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@17@00 _pure_2@18@00))
  :qid |quant-u-336|)))
(assert (forall ((s@$ $Snap) (_pure_1@17@00 $Ref) (_pure_2@18@00 Int)) (!
  (let ((result@19@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@17@00 _pure_2@18@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited s@$ _pure_1@17@00 _pure_2@18@00))
  :qid |quant-u-337|)))
(assert (forall ((s@$ $Snap) (_pure_1@17@00 $Ref) (_pure_2@18@00 Int)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition s@$ _pure_1@17@00 _pure_2@18@00)
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ s@$ _pure_1@17@00 _pure_2@18@00)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        ($Snap.second ($Snap.first s@$))
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first s@$))) _pure_2@18@00)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ s@$ _pure_1@17@00 _pure_2@18@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%stateless _pure_1@17@00 _pure_2@18@00) (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.first s@$) _pure_1@17@00))
  :qid |quant-u-338|)))
(assert (forall ((s@$ $Snap) (_pure_1@17@00 $Ref) (_pure_2@18@00 Int)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition s@$ _pure_1@17@00 _pure_2@18@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      ($Snap.second ($Snap.first s@$))
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first s@$))) _pure_2@18@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ s@$ _pure_1@17@00 _pure_2@18@00))
  :qid |quant-u-339|)))
(assert (forall ((s@$ $Snap) (self@20@00 $Ref)) (!
  (=
    (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@20@00)
    (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ self@20@00))
  :pattern ((m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ self@20@00))
  :qid |quant-u-299|)))
(assert (forall ((s@$ $Snap) (self@20@00 $Ref)) (!
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless self@20@00)
  :pattern ((m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@20@00))
  :qid |quant-u-300|)))
(assert (forall ((s@$ $Snap) (self@20@00 $Ref)) (!
  (let ((result@21@00 (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@20@00))) (=>
    (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ self@20@00)
    (and (<= 0 result@21@00) (<= result@21@00 1))))
  :pattern ((m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@20@00))
  :qid |quant-u-340|)))
(assert (forall ((s@$ $Snap) (self@20@00 $Ref)) (!
  (let ((result@21@00 (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@20@00))) true)
  :pattern ((m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@20@00))
  :qid |quant-u-341|)))
(assert (forall ((s@$ $Snap) (self@20@00 $Ref)) (!
  (=>
    (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ self@20@00)
    (=
      (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ self@20@00)
      ($SortWrappers.$SnapToInt ($Snap.first s@$))))
  :pattern ((m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ self@20@00))
  :qid |quant-u-342|)))
(assert (forall ((s@$ $Snap) (self@20@00 $Ref)) (!
  true
  :pattern ((m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ self@20@00))
  :qid |quant-u-343|)))
(assert (forall ((s@$ $Snap)) (!
  (=
    (builtin$undef_bool__$TY$__$bool$%limited s@$)
    (builtin$undef_bool__$TY$__$bool$ s@$))
  :pattern ((builtin$undef_bool__$TY$__$bool$ s@$))
  :qid |quant-u-301|)))
(assert (forall ((s@$ $Snap)) (!
  (as builtin$undef_bool__$TY$__$bool$%stateless  Bool)
  :pattern ((builtin$undef_bool__$TY$__$bool$%limited s@$))
  :qid |quant-u-302|)))
(assert (forall ((s@$ $Snap) (self@23@00 $Ref)) (!
  (=
    (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@23@00)
    (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ self@23@00))
  :pattern ((m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ self@23@00))
  :qid |quant-u-303|)))
(assert (forall ((s@$ $Snap) (self@23@00 $Ref)) (!
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless self@23@00)
  :pattern ((m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@23@00))
  :qid |quant-u-304|)))
(assert (forall ((s@$ $Snap) (self@23@00 $Ref)) (!
  (let ((result@24@00 (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@23@00))) (=>
    (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ self@23@00)
    (and (<= 0 result@24@00) (<= result@24@00 1))))
  :pattern ((m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@23@00))
  :qid |quant-u-344|)))
(assert (forall ((s@$ $Snap) (self@23@00 $Ref)) (!
  (let ((result@24@00 (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@23@00))) true)
  :pattern ((m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ self@23@00))
  :qid |quant-u-345|)))
(assert (forall ((s@$ $Snap) (self@23@00 $Ref)) (!
  (=>
    (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ self@23@00)
    (=
      (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ self@23@00)
      ($SortWrappers.$SnapToInt ($Snap.first s@$))))
  :pattern ((m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ self@23@00))
  :qid |quant-u-346|)))
(assert (forall ((s@$ $Snap) (self@23@00 $Ref)) (!
  true
  :pattern ((m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ self@23@00))
  :qid |quant-u-347|)))
(assert (forall ((s@$ $Snap) (_pure_1@25@00 $Ref)) (!
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@25@00)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@25@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@25@00))
  :qid |quant-u-305|)))
(assert (forall ((s@$ $Snap) (_pure_1@25@00 $Ref)) (!
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless _pure_1@25@00)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@25@00))
  :qid |quant-u-306|)))
(assert (forall ((s@$ $Snap) (_pure_1@25@00 $Ref)) (!
  (let ((result@26@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@25@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@25@00))
  :qid |quant-u-348|)))
(assert (forall ((s@$ $Snap) (_pure_1@25@00 $Ref)) (!
  (let ((result@26@00 (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@25@00))) true)
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%limited s@$ _pure_1@25@00))
  :qid |quant-u-349|)))
(assert (forall ((s@$ $Snap) (_pure_1@25@00 $Ref)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ _pure_1@25@00)
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@25@00)
      (ite
        (= ($SortWrappers.$SnapToInt ($Snap.first ($Snap.first s@$))) 0)
        ($SortWrappers.$SnapToInt ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.first s@$)))))))
        (builtin$unreach_int__$TY$__$int$ $unresolved@45@00))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@25@00))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%stateless _pure_1@25@00) (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.first s@$) _pure_1@25@00))
  :qid |quant-u-350|)))
(assert (forall ((s@$ $Snap) (_pure_1@25@00 $Ref)) (!
  (=>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition s@$ _pure_1@25@00)
    (ite
      (= ($SortWrappers.$SnapToInt ($Snap.first ($Snap.first s@$))) 0)
      true
      (builtin$unreach_int__$TY$__$int$%precondition $unresolved@45@00)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ s@$ _pure_1@25@00))
  :qid |quant-u-351|)))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$push$opensqu$0$closesqu$ ----------
(declare-const _0@0@01 $Ref)
(declare-const _0@1@01 $Ref)
(set-option :timeout 0)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var __t0: Bool
(declare-const __t0@2@01 Bool)
; [exec]
; var __t1: Bool
(declare-const __t1@3@01 Bool)
; [exec]
; var __t2: Bool
(declare-const __t2@4@01 Bool)
; [exec]
; var __t3: Bool
(declare-const __t3@5@01 Bool)
; [exec]
; var __t4: Bool
(declare-const __t4@6@01 Bool)
; [exec]
; var __t5: Bool
(declare-const __t5@7@01 Bool)
; [exec]
; var __t6: Bool
(declare-const __t6@8@01 Bool)
; [exec]
; var __t7: Bool
(declare-const __t7@9@01 Bool)
; [exec]
; var __t8: Bool
(declare-const __t8@10@01 Bool)
; [exec]
; var __t9: Bool
(declare-const __t9@11@01 Bool)
; [exec]
; var __t10: Bool
(declare-const __t10@12@01 Bool)
; [exec]
; var _aux_havoc_m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_: Ref
(declare-const _aux_havoc_m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_@13@01 $Ref)
; [exec]
; var _old$pre$0: Ref
(declare-const _old$pre$0@14@01 $Ref)
; [exec]
; var _1: Ref
(declare-const _1@15@01 $Ref)
; [exec]
; var _2: Ref
(declare-const _2@16@01 $Ref)
; [exec]
; var _3: Int
(declare-const _3@17@01 Int)
; [exec]
; var _4: Ref
(declare-const _4@18@01 $Ref)
; [exec]
; var _5: Ref
(declare-const _5@19@01 $Ref)
; [exec]
; var _6: Ref
(declare-const _6@20@01 $Ref)
; [exec]
; var _7: Ref
(declare-const _7@21@01 $Ref)
; [exec]
; var _8: Ref
(declare-const _8@22@01 $Ref)
; [exec]
; var _9: Ref
(declare-const _9@23@01 $Ref)
; [exec]
; var _10: Ref
(declare-const _10@24@01 $Ref)
; [exec]
; var _11: Ref
(declare-const _11@25@01 $Ref)
; [exec]
; var _12: Ref
(declare-const _12@26@01 $Ref)
; [exec]
; var _13: Ref
(declare-const _13@27@01 $Ref)
; [exec]
; label start
; [exec]
; __t0 := false
; [exec]
; __t1 := false
; [exec]
; __t2 := false
; [exec]
; __t3 := false
; [exec]
; __t4 := false
; [exec]
; __t5 := false
; [exec]
; __t6 := false
; [exec]
; __t7 := false
; [exec]
; __t8 := false
; [exec]
; __t9 := false
; [exec]
; __t10 := false
; [exec]
; inhale acc(_1.val_ref, write) &&
;   (acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write) &&
;   acc(i32(_2), write))
(declare-const $t@28@01 $Snap)
(assert (= $t@28@01 ($Snap.combine ($Snap.first $t@28@01) ($Snap.second $t@28@01))))
(assert (not (= _1@15@01 $Ref.null)))
(assert (=
  ($Snap.second $t@28@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@28@01))
    ($Snap.second ($Snap.second $t@28@01)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@29@01 $Snap)
(assert (= $t@29@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@30@01 $Snap)
(assert (= $t@30@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@31@01 $Snap)
(assert (= $t@31@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; label pre
; [exec]
; label bb0
; [exec]
; __t0 := true
; [exec]
; _4 := builtin$havoc_ref()
(declare-const ret@32@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_4.val_ref, write)
(declare-const $t@33@01 $Ref)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@15@01 ret@32@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@32@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write)
(assert (=
  ($Snap.first ($Snap.second $t@28@01))
  ($Snap.combine
    ($Snap.first ($Snap.first ($Snap.second $t@28@01)))
    ($Snap.second ($Snap.first ($Snap.second $t@28@01))))))
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.first ($Snap.second $t@28@01)) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01))))
; [exec]
; _4.val_ref := _1.val_ref.f$head
(declare-const val_ref@34@01 $Ref)
(assert (=
  val_ref@34@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first ($Snap.second $t@28@01))))))
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@15@01 ret@32@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref.f$head), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(set-option :timeout 0)
(push) ; 3
(assert (read$%precondition $Snap.unit))
(pop) ; 3
; Joined path conditions
(assert (read$%precondition $Snap.unit))
(push) ; 3
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(push) ; 3
(set-option :timeout 10)
(assert (not (=
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (<=
  $Perm.No
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))))
(set-option :timeout 0)
(push) ; 3
(assert (not (or
  (=
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No)
  (<
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_4.val_ref), read$())
; [eval] read$()
(push) ; 3
(pop) ; 3
; Joined path conditions
(push) ; 3
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(declare-const $t@35@01 $Snap)
(push) ; 3
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first ($Snap.second $t@28@01))))
  val_ref@34@01)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(declare-const $t@36@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit)))))
    (= $t@36@01 ($Snap.second ($Snap.first ($Snap.second $t@28@01)))))
  (=> (< $Perm.No (read$ $Snap.unit)) (= $t@36@01 $t@35@01))))
(assert (<=
  $Perm.No
  (+
    (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    (read$ $Snap.unit))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l0
; [exec]
; label l1
; [exec]
; _3 := builtin$havoc_int()
(declare-const ret@37@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale _3 >= 0
(declare-const $t@38@01 $Snap)
(assert (= $t@38@01 $Snap.unit))
; [eval] _3 >= 0
(assert (>= ret@37@01 0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale _3 >= 0
(declare-const $t@39@01 $Snap)
(assert (= $t@39@01 $Snap.unit))
; [eval] _3 >= 0
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale _3 ==
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_4.val_ref)
(declare-const $t@40@01 $Snap)
(assert (= $t@40@01 $Snap.unit))
; [eval] _3 == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_4.val_ref)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_4.val_ref)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first ($Snap.second $t@28@01))))
  val_ref@34@01)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@36@01
  $Snap.unit) val_ref@34@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@36@01
  $Snap.unit) val_ref@34@01))
(assert (=
  ret@37@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@36@01
    $Snap.unit) val_ref@34@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l2
; [eval] __t0 && __t0
(set-option :timeout 0)
(push) ; 3
; [then-branch: 0 | False | live]
; [else-branch: 0 | True | live]
(push) ; 4
; [then-branch: 0 | False]
(assert false)
(pop) ; 4
(push) ; 4
; [else-branch: 0 | True]
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1 | True | live]
; [else-branch: 1 | False | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 1 | True]
; [exec]
; exhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(old[l0](_4.val_ref)), read$())
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] old[l0](_4.val_ref)
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first ($Snap.second $t@28@01))))
  val_ref@34@01)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (<=
  $Perm.No
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))))
(set-option :timeout 0)
(push) ; 4
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref.f$head), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const $t@41@01 $Snap)
(declare-const $t@42@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@42@01 $t@36@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@42@01 $t@41@01))))
(assert (<=
  $Perm.No
  (+
    (-
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    (- $Perm.Write (read$ $Snap.unit)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb2
; [exec]
; __t1 := true
; [exec]
; _7 := builtin$havoc_ref()
(declare-const ret@43@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_7.val_int, write)
(declare-const $t@44@01 Int)
(assert (not (= ret@43@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(i32(_2), write)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@43@01 _2@16@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (not (= _2@16@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (i32%trigger ($Snap.second ($Snap.second $t@28@01)) _2@16@01))
; [exec]
; _7.val_int := _2.val_int
(declare-const val_int@45@01 Int)
(assert (=
  val_int@45@01
  ($SortWrappers.$SnapToInt ($Snap.second ($Snap.second $t@28@01)))))
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _2@16@01 ret@43@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l3
; [exec]
; _10 := builtin$havoc_ref()
(declare-const ret@46@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_10.val_ref, write)
(declare-const $t@47@01 $Ref)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@32@01 ret@46@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _1@15@01 ret@46@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@46@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _10.val_ref := _1.val_ref.f$head
(declare-const val_ref@48@01 $Ref)
(assert (=
  val_ref@48@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first ($Snap.second $t@28@01))))))
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@32@01 ret@46@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _1@15@01 ret@46@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l4
; [exec]
; _9 := builtin$havoc_ref()
(declare-const ret@49@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_9.val_ref, write)
(declare-const $t@50@01 $Ref)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@46@01 ret@49@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@32@01 ret@49@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _1@15@01 ret@49@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@49@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _9.val_ref := _10.val_ref
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@46@01 ret@49@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@32@01 ret@49@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _1@15@01 ret@49@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l5
; [exec]
; _11 := builtin$havoc_ref()
(declare-const ret@51@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_11), write)
(declare-const $t@52@01 $Snap)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first ($Snap.second $t@28@01))))
  ret@51@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_11) ==
;   0
(declare-const $t@53@01 $Snap)
(assert (= $t@53@01 $Snap.unit))
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_11) == 0
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_11)
(set-option :timeout 0)
(push) ; 4
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@52@01 ret@51@01))
(pop) ; 4
; Joined path conditions
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@52@01 ret@51@01))
(assert (=
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@52@01 ret@51@01)
  0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l6
; [exec]
; assert m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(_11)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(_11)
(set-option :timeout 0)
(push) ; 4
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@52@01
  $Snap.unit) ret@51@01))
(pop) ; 4
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@52@01
  $Snap.unit) ret@51@01))
(set-option :timeout 0)
(push) ; 4
(assert (not (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@52@01
  $Snap.unit) ret@51@01)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@52@01
  $Snap.unit) ret@51@01))
; [exec]
; assert true
; [exec]
; exhale acc(_9.val_ref, write) &&
;   (acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_9.val_ref), write) &&
;   acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_11), write))
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@51@01 val_ref@48@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first ($Snap.second $t@28@01))))
  val_ref@48@01)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))
    ($Perm.min
      (+
        (-
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          ($Perm.min
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            (read$ $Snap.unit)))
        (- $Perm.Write (read$ $Snap.unit)))
      $Perm.Write))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (or
  (=
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No)
  (<
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; _8 := builtin$havoc_ref()
(declare-const ret@54@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(old[l6](_9.val_ref)), write)
; [eval] old[l6](_9.val_ref)
(declare-const $t@55@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_8), write)
(declare-const $t@56@01 $Snap)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= val_ref@48@01 ret@54@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@57@01 $Snap)
(assert (= $t@57@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(old[l6](_9.val_ref)) &&
;   (old[l6](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_9.val_ref)) ==
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_8) &&
;   (forall i: Int ::
;     { old[l6](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_9.val_ref,
;     i)) }
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_8,
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_8) ==>
;     old[l6](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_9.val_ref,
;     i)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_8,
;     i)))
(declare-const $t@58@01 $Snap)
(assert (= $t@58@01 ($Snap.combine ($Snap.first $t@58@01) ($Snap.second $t@58@01))))
(assert (= ($Snap.first $t@58@01) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(old[l6](_9.val_ref))
; [eval] old[l6](_9.val_ref)
(set-option :timeout 0)
(push) ; 4
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@55@01
  $Snap.unit) val_ref@48@01))
(pop) ; 4
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@55@01
  $Snap.unit) val_ref@48@01))
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@55@01
  $Snap.unit) val_ref@48@01))
(assert (=
  ($Snap.second $t@58@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@58@01))
    ($Snap.second ($Snap.second $t@58@01)))))
(assert (= ($Snap.first ($Snap.second $t@58@01)) $Snap.unit))
; [eval] old[l6](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_9.val_ref)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_8)
; [eval] old[l6](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_9.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_9.val_ref)
(set-option :timeout 0)
(push) ; 4
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@51@01 val_ref@48@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first ($Snap.second $t@28@01))))
  val_ref@48@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@42@01
  $Snap.unit) val_ref@48@01))
(pop) ; 4
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@42@01
  $Snap.unit) val_ref@48@01))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_8)
(set-option :timeout 0)
(push) ; 4
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@56@01
  $Snap.unit) ret@54@01))
(pop) ; 4
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@56@01
  $Snap.unit) ret@54@01))
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@42@01
    $Snap.unit) val_ref@48@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@56@01
    $Snap.unit) ret@54@01)))
(assert (= ($Snap.second ($Snap.second $t@58@01)) $Snap.unit))
; [eval] (forall i: Int :: { old[l6](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_9.val_ref, i)) } { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_8, i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_8) ==> old[l6](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_9.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_8, i))
(declare-const i@59@01 Int)
(set-option :timeout 0)
(push) ; 4
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_8) ==> old[l6](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_9.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_8, i)
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_8)
; [eval] 0 <= i
(push) ; 5
; [then-branch: 2 | !(0 <= i@59@01) | live]
; [else-branch: 2 | 0 <= i@59@01 | live]
(push) ; 6
; [then-branch: 2 | !(0 <= i@59@01)]
(assert (not (<= 0 i@59@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 2 | 0 <= i@59@01]
(assert (<= 0 i@59@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_8)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_8)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 i@59@01) (not (<= 0 i@59@01))))
(set-option :timeout 0)
(push) ; 5
; [then-branch: 3 | 0 <= i@59@01 && i@59@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@56@01, _), ret@54@01) | live]
; [else-branch: 3 | !(0 <= i@59@01 && i@59@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@56@01, _), ret@54@01)) | live]
(push) ; 6
; [then-branch: 3 | 0 <= i@59@01 && i@59@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@56@01, _), ret@54@01)]
(assert (and
  (<= 0 i@59@01)
  (<
    i@59@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@56@01
      $Snap.unit) ret@54@01))))
; [eval] old[l6](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_9.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_8, i)
; [eval] old[l6](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_9.val_ref, i))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_9.val_ref, i)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@51@01 val_ref@48@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first ($Snap.second $t@28@01))))
  val_ref@48@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@51@01 val_ref@48@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.first ($Snap.second $t@28@01))))
  val_ref@48@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
(set-option :timeout 0)
(push) ; 8
(assert (not (<
  i@59@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@42@01
    $Snap.unit) val_ref@48@01))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (<
  i@59@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@42@01
    $Snap.unit) val_ref@48@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@42@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@48@01 i@59@01))
(pop) ; 7
; Joined path conditions
(assert (and
  (<
    i@59@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@42@01
      $Snap.unit) val_ref@48@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@42@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@48@01 i@59@01)))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_8, i)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@56@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@54@01 i@59@01))
(pop) ; 7
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@56@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@54@01 i@59@01))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 3 | !(0 <= i@59@01 && i@59@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@56@01, _), ret@54@01))]
(assert (not
  (and
    (<= 0 i@59@01)
    (<
      i@59@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@56@01
        $Snap.unit) ret@54@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (and
    (<= 0 i@59@01)
    (<
      i@59@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@56@01
        $Snap.unit) ret@54@01)))
  (and
    (<= 0 i@59@01)
    (<
      i@59@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@56@01
        $Snap.unit) ret@54@01))
    (<
      i@59@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@42@01
        $Snap.unit) val_ref@48@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@42@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@48@01 i@59@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@56@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@54@01 i@59@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 0 i@59@01)
      (<
        i@59@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@56@01
          $Snap.unit) ret@54@01))))
  (and
    (<= 0 i@59@01)
    (<
      i@59@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@56@01
        $Snap.unit) ret@54@01)))))
(pop) ; 4
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@59@01 Int)) (!
  (and
    (or (<= 0 i@59@01) (not (<= 0 i@59@01)))
    (=>
      (and
        (<= 0 i@59@01)
        (<
          i@59@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@56@01
            $Snap.unit) ret@54@01)))
      (and
        (<= 0 i@59@01)
        (<
          i@59@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@56@01
            $Snap.unit) ret@54@01))
        (<
          i@59@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@42@01
            $Snap.unit) val_ref@48@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@42@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@48@01 i@59@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@56@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@54@01 i@59@01)))
    (or
      (not
        (and
          (<= 0 i@59@01)
          (<
            i@59@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@56@01
              $Snap.unit) ret@54@01))))
      (and
        (<= 0 i@59@01)
        (<
          i@59@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@56@01
            $Snap.unit) ret@54@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@42@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@48@01 i@59@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@670@577@670@1171-aux|)))
(assert (forall ((i@59@01 Int)) (!
  (and
    (or (<= 0 i@59@01) (not (<= 0 i@59@01)))
    (=>
      (and
        (<= 0 i@59@01)
        (<
          i@59@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@56@01
            $Snap.unit) ret@54@01)))
      (and
        (<= 0 i@59@01)
        (<
          i@59@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@56@01
            $Snap.unit) ret@54@01))
        (<
          i@59@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@42@01
            $Snap.unit) val_ref@48@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@42@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@48@01 i@59@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@56@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@54@01 i@59@01)))
    (or
      (not
        (and
          (<= 0 i@59@01)
          (<
            i@59@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@56@01
              $Snap.unit) ret@54@01))))
      (and
        (<= 0 i@59@01)
        (<
          i@59@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@56@01
            $Snap.unit) ret@54@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@56@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@54@01 i@59@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@670@577@670@1171-aux|)))
(assert (forall ((i@59@01 Int)) (!
  (=>
    (and
      (<= 0 i@59@01)
      (<
        i@59@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@56@01
          $Snap.unit) ret@54@01)))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@42@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@48@01 i@59@01)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@56@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@54@01 i@59@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@42@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@48@01 i@59@01))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@56@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@54@01 i@59@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@670@577@670@1171|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l7
; [exec]
; label l8
; [exec]
; label bb3
; [exec]
; __t2 := true
; [exec]
; label bb6
; [exec]
; __t3 := true
; [exec]
; _6 := builtin$havoc_ref()
(declare-const ret@60@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_(_6), write)
(declare-const $t@61@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_(_6), write)
(assert (= $t@61@01 ($Snap.combine ($Snap.first $t@61@01) ($Snap.second $t@61@01))))
(assert (not (= ret@60@01 $Ref.null)))
(assert (=
  ($Snap.second $t@61@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@61@01))
    ($Snap.second ($Snap.second $t@61@01)))))
(assert (=
  ($Snap.second ($Snap.second $t@61@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@61@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@61@01))))))
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  ret@54@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@61@01)))))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  val_ref@48@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@61@01)))))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_%trigger $t@61@01 ret@60@01))
; [exec]
; _6.f$elem := _7
; [exec]
; label l9
; [exec]
; _6.f$next := _8
; [exec]
; label l10
; [exec]
; label bb8
; [exec]
; __t4 := true
; [exec]
; _5 := builtin$havoc_ref()
(declare-const ret@62@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_5.val_ref, write)
(declare-const $t@63@01 $Ref)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@46@01 ret@62@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@32@01 ret@62@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _1@15@01 ret@62@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@62@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _aux_havoc_m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_ := builtin$havoc_ref()
(declare-const ret@64@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; _5.val_ref := _aux_havoc_m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@46@01 ret@62@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@32@01 ret@62@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _1@15@01 ret@62@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_(_5.val_ref), write)
(declare-const $t@65@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _5.val_ref := _6
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@46@01 ret@62@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@32@01 ret@62@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _1@15@01 ret@62@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l11
; [exec]
; label bb9
; [exec]
; __t5 := true
; [exec]
; label bb10
; [exec]
; __t6 := true
; [exec]
; _13 := _5
; [exec]
; label l12
; [exec]
; _12 := builtin$havoc_ref()
(declare-const ret@66@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_12), write)
(declare-const $t@67@01 $Snap)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@61@01))))
  ret@66@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@54@01 ret@66@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= val_ref@48@01 ret@66@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_12) ==
;   1
(declare-const $t@68@01 $Snap)
(assert (= $t@68@01 $Snap.unit))
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_12) == 1
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_12)
(set-option :timeout 0)
(push) ; 4
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@67@01 ret@66@01))
(pop) ; 4
; Joined path conditions
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@67@01 ret@66@01))
(assert (=
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@67@01 ret@66@01)
  1))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_12), write)
(assert (= $t@67@01 ($Snap.combine ($Snap.first $t@67@01) ($Snap.second $t@67@01))))
(assert (not (= ret@66@01 $Ref.null)))
(assert (=
  ($Snap.second $t@67@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@67@01))
    ($Snap.second ($Snap.second $t@67@01)))))
(assert (= ($Snap.first ($Snap.second $t@67@01)) $Snap.unit))
; [eval] 0 <= self.discriminant
(assert (<= 0 ($SortWrappers.$SnapToInt ($Snap.first $t@67@01))))
(assert (=
  ($Snap.second ($Snap.second $t@67@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@67@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@67@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@67@01))) $Snap.unit))
; [eval] self.discriminant <= 1
(assert (<= ($SortWrappers.$SnapToInt ($Snap.first $t@67@01)) 1))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@67@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@67@01)))))))
; [eval] self.discriminant == 1
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@67@01)) 1))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@67@01)) 1)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 4 | First:($t@67@01) == 1 | live]
; [else-branch: 4 | First:($t@67@01) != 1 | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 4 | First:($t@67@01) == 1]
(assert (= ($SortWrappers.$SnapToInt ($Snap.first $t@67@01)) 1))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_%trigger $t@67@01 ret@66@01))
; [exec]
; unfold acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_More(_12.enum_More), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@67@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@67@01))))))))
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01)))))
    $Ref.null)))
; State saturation: after unfold
(check-sat)
; unknown
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_More%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@67@01)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01)))))))
; [exec]
; _12.enum_More.f$0 := _13
; [exec]
; label l13
; [exec]
; label bb13
; [exec]
; __t7 := true
; [exec]
; _1.val_ref.f$head := _12
; [exec]
; label l14
; [exec]
; label bb14
; [exec]
; __t8 := true
; [exec]
; label bb15
; [exec]
; __t9 := true
; [exec]
; _0 := builtin$havoc_ref()
(declare-const ret@69@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_0), write)
(declare-const $t@70@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb16
; [exec]
; __t10 := true
; [exec]
; label return
; [exec]
; fold acc(i32(_1.val_ref.f$head.enum_More.f$0.val_ref.f$elem), write)
(assert (i32%trigger ($SortWrappers.IntTo$Snap val_int@45@01) ret@43@01))
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@61@01)) ret@43@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; fold acc(m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref.f$head.enum_More.f$0.val_ref), write)
(assert (m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.combine
  ($SortWrappers.$RefTo$Snap ret@43@01)
  ($Snap.combine
    ($SortWrappers.IntTo$Snap val_int@45@01)
    ($Snap.combine ($SortWrappers.$RefTo$Snap ret@54@01) $t@56@01))) ret@60@01))
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@64@01 ret@60@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; fold acc(m_alloc$$boxed$opensqu$0$closesqu$$$Box$opensqu$0$closesqu$$_beg_$m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_$_end_(_1.val_ref.f$head.enum_More.f$0), write)
(assert (m_alloc$$boxed$opensqu$0$closesqu$$$Box$opensqu$0$closesqu$$_beg_$m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_$_end_%trigger ($Snap.combine
  ($SortWrappers.$RefTo$Snap ret@60@01)
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap ret@43@01)
    ($Snap.combine
      ($SortWrappers.IntTo$Snap val_int@45@01)
      ($Snap.combine ($SortWrappers.$RefTo$Snap ret@54@01) $t@56@01)))) ret@62@01))
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@67@01))))))
  ret@62@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; fold acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_More(_1.val_ref.f$head.enum_More), write)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_More%trigger ($Snap.combine
  ($SortWrappers.$RefTo$Snap ret@62@01)
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap ret@60@01)
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@43@01)
      ($Snap.combine
        ($SortWrappers.IntTo$Snap val_int@45@01)
        ($Snap.combine ($SortWrappers.$RefTo$Snap ret@54@01) $t@56@01))))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01)))))))
; [exec]
; fold acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref.f$head), write)
; [eval] 0 <= self.discriminant
; [eval] self.discriminant <= 1
; [eval] self.discriminant == 1
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@67@01)) 1))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 5 | First:($t@67@01) == 1 | live]
; [else-branch: 5 | First:($t@67@01) != 1 | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 5 | First:($t@67@01) == 1]
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.combine
  ($Snap.first $t@67@01)
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap ret@62@01)
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@60@01)
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@43@01)
              ($Snap.combine
                ($SortWrappers.IntTo$Snap val_int@45@01)
                ($Snap.combine ($SortWrappers.$RefTo$Snap ret@54@01) $t@56@01))))))))) ret@66@01))
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second $t@61@01))))
  ret@66@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= val_ref@48@01 ret@66@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [exec]
; fold acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write)
(assert (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.combine
  ($SortWrappers.$RefTo$Snap ret@66@01)
  ($Snap.combine
    ($Snap.first $t@67@01)
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@62@01)
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@60@01)
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@43@01)
                ($Snap.combine
                  ($SortWrappers.IntTo$Snap val_int@45@01)
                  ($Snap.combine ($SortWrappers.$RefTo$Snap ret@54@01) $t@56@01)))))))))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01))))
; [exec]
; _old$pre$0 := _1.val_ref
(declare-const _old$pre$0@71@01 $Ref)
(assert (= _old$pre$0@71@01 ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01))))
; [exec]
; assert m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==
;   old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) +
;   1 &&
;   (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0,
;   0) ==
;   old[pre]((unfolding acc(i32(_2), write) in _2.val_int)) &&
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0,
;     i) }
;     1 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==>
;     old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref,
;     i - 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0,
;     i)))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) == old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) + 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0)
(set-option :timeout 0)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) _old$pre$0@71@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap ret@66@01)
    ($Snap.combine
      ($Snap.first $t@67@01)
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@62@01)
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@60@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@43@01)
                  ($Snap.combine
                    ($SortWrappers.IntTo$Snap val_int@45@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@54@01)
                      $t@56@01))))))))))
  $Snap.unit) _old$pre$0@71@01))
(pop) ; 6
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap ret@66@01)
    ($Snap.combine
      ($Snap.first $t@67@01)
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@62@01)
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@60@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@43@01)
                  ($Snap.combine
                    ($SortWrappers.IntTo$Snap val_int@45@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@54@01)
                      $t@56@01))))))))))
  $Snap.unit) _old$pre$0@71@01))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) + 1
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(set-option :timeout 0)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.first ($Snap.second $t@28@01))
  $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01))))
(pop) ; 6
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.first ($Snap.second $t@28@01))
  $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01))))
(set-option :timeout 0)
(push) ; 6
(assert (not (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    $Snap.unit) _old$pre$0@71@01)
  (+
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.first ($Snap.second $t@28@01))
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)))
    1))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    $Snap.unit) _old$pre$0@71@01)
  (+
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.first ($Snap.second $t@28@01))
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)))
    1)))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, 0) == old[pre]((unfolding acc(i32(_2), write) in _2.val_int))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, 0)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) _old$pre$0@71@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) _old$pre$0@71@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(pop) ; 7
; Joined path conditions
(set-option :timeout 0)
(push) ; 7
(assert (not (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    $Snap.unit) _old$pre$0@71@01))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    $Snap.unit) _old$pre$0@71@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap ret@66@01)
    ($Snap.combine
      ($Snap.first $t@67@01)
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@62@01)
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@60@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@43@01)
                  ($Snap.combine
                    ($SortWrappers.IntTo$Snap val_int@45@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@54@01)
                      $t@56@01))))))))))
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 0))
(pop) ; 6
; Joined path conditions
(assert (and
  (<
    0
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap ret@66@01)
        ($Snap.combine
          ($Snap.first $t@67@01)
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@62@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@60@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@43@01)
                      ($Snap.combine
                        ($SortWrappers.IntTo$Snap val_int@45@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@54@01)
                          $t@56@01))))))))))
      $Snap.unit) _old$pre$0@71@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 0)))
; [eval] old[pre]((unfolding acc(i32(_2), write) in _2.val_int))
; [eval] (unfolding acc(i32(_2), write) in _2.val_int)
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 0)
  ($SortWrappers.$SnapToInt ($Snap.second ($Snap.second $t@28@01))))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 0)
  ($SortWrappers.$SnapToInt ($Snap.second ($Snap.second $t@28@01)))))
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i) } 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==> old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i))
(declare-const i@72@01 Int)
(push) ; 6
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==> old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i)
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0)
; [eval] 1 <= i
(push) ; 7
; [then-branch: 6 | !(1 <= i@72@01) | live]
; [else-branch: 6 | 1 <= i@72@01 | live]
(push) ; 8
; [then-branch: 6 | !(1 <= i@72@01)]
(assert (not (<= 1 i@72@01)))
(pop) ; 8
(push) ; 8
; [else-branch: 6 | 1 <= i@72@01]
(assert (<= 1 i@72@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) _old$pre$0@71@01)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or (<= 1 i@72@01) (not (<= 1 i@72@01))))
(set-option :timeout 0)
(push) ; 7
; [then-branch: 7 | 1 <= i@72@01 && i@72@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(((ret@66@01, (First:($t@67@01), (_, (_, (First:(Second:(Second:(Second:($t@67@01)))), (ret@62@01, (ret@60@01, (ret@43@01, (val_int@45@01, (ret@54@01, $t@56@01)))))))))), _), _old$pre$0@71@01) | live]
; [else-branch: 7 | !(1 <= i@72@01 && i@72@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(((ret@66@01, (First:($t@67@01), (_, (_, (First:(Second:(Second:(Second:($t@67@01)))), (ret@62@01, (ret@60@01, (ret@43@01, (val_int@45@01, (ret@54@01, $t@56@01)))))))))), _), _old$pre$0@71@01)) | live]
(push) ; 8
; [then-branch: 7 | 1 <= i@72@01 && i@72@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(((ret@66@01, (First:($t@67@01), (_, (_, (First:(Second:(Second:(Second:($t@67@01)))), (ret@62@01, (ret@60@01, (ret@43@01, (val_int@45@01, (ret@54@01, $t@56@01)))))))))), _), _old$pre$0@71@01)]
(assert (and
  (<= 1 i@72@01)
  (<
    i@72@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap ret@66@01)
        ($Snap.combine
          ($Snap.first $t@67@01)
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@62@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@60@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@43@01)
                      ($Snap.combine
                        ($SortWrappers.IntTo$Snap val_int@45@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@54@01)
                          $t@56@01))))))))))
      $Snap.unit) _old$pre$0@71@01))))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i)
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i - 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i - 1)
; [eval] i - 1
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 10
(assert (not (<= 0 (- i@72@01 1))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (- i@72@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (<
  (- i@72@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.first ($Snap.second $t@28@01))
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (<
  (- i@72@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.first ($Snap.second $t@28@01))
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)))))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  ($Snap.first ($Snap.second $t@28@01))
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) (-
  i@72@01
  1)))
(pop) ; 9
; Joined path conditions
(assert (and
  (<= 0 (- i@72@01 1))
  (<
    (- i@72@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.first ($Snap.second $t@28@01))
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01))))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    ($Snap.first ($Snap.second $t@28@01))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) (-
    i@72@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) _old$pre$0@71@01)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 10
(assert (not (<= 0 i@72@01)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 i@72@01))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) _old$pre$0@71@01)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(pop) ; 10
; Joined path conditions
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap ret@66@01)
    ($Snap.combine
      ($Snap.first $t@67@01)
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@62@01)
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@60@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@43@01)
                  ($Snap.combine
                    ($SortWrappers.IntTo$Snap val_int@45@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@54@01)
                      $t@56@01))))))))))
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01))
(pop) ; 9
; Joined path conditions
(assert (and
  (<= 0 i@72@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01)))
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 7 | !(1 <= i@72@01 && i@72@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(((ret@66@01, (First:($t@67@01), (_, (_, (First:(Second:(Second:(Second:($t@67@01)))), (ret@62@01, (ret@60@01, (ret@43@01, (val_int@45@01, (ret@54@01, $t@56@01)))))))))), _), _old$pre$0@71@01))]
(assert (not
  (and
    (<= 1 i@72@01)
    (<
      i@72@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap ret@66@01)
          ($Snap.combine
            ($Snap.first $t@67@01)
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@62@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@60@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@43@01)
                        ($Snap.combine
                          ($SortWrappers.IntTo$Snap val_int@45@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@54@01)
                            $t@56@01))))))))))
        $Snap.unit) _old$pre$0@71@01)))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  (and
    (<= 1 i@72@01)
    (<
      i@72@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap ret@66@01)
          ($Snap.combine
            ($Snap.first $t@67@01)
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@62@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@60@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@43@01)
                        ($Snap.combine
                          ($SortWrappers.IntTo$Snap val_int@45@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@54@01)
                            $t@56@01))))))))))
        $Snap.unit) _old$pre$0@71@01)))
  (and
    (<= 1 i@72@01)
    (<
      i@72@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap ret@66@01)
          ($Snap.combine
            ($Snap.first $t@67@01)
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@62@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@60@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@43@01)
                        ($Snap.combine
                          ($SortWrappers.IntTo$Snap val_int@45@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@54@01)
                            $t@56@01))))))))))
        $Snap.unit) _old$pre$0@71@01))
    (<= 0 (- i@72@01 1))
    (<
      (- i@72@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.first ($Snap.second $t@28@01))
        $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01))))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      ($Snap.first ($Snap.second $t@28@01))
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) (-
      i@72@01
      1))
    (<= 0 i@72@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap ret@66@01)
        ($Snap.combine
          ($Snap.first $t@67@01)
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@62@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@60@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@43@01)
                      ($Snap.combine
                        ($SortWrappers.IntTo$Snap val_int@45@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@54@01)
                          $t@56@01))))))))))
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 1 i@72@01)
      (<
        i@72@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@66@01)
            ($Snap.combine
              ($Snap.first $t@67@01)
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@62@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@60@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@43@01)
                          ($Snap.combine
                            ($SortWrappers.IntTo$Snap val_int@45@01)
                            ($Snap.combine
                              ($SortWrappers.$RefTo$Snap ret@54@01)
                              $t@56@01))))))))))
          $Snap.unit) _old$pre$0@71@01))))
  (and
    (<= 1 i@72@01)
    (<
      i@72@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap ret@66@01)
          ($Snap.combine
            ($Snap.first $t@67@01)
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@62@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@60@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@43@01)
                        ($Snap.combine
                          ($SortWrappers.IntTo$Snap val_int@45@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@54@01)
                            $t@56@01))))))))))
        $Snap.unit) _old$pre$0@71@01)))))
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@72@01 Int)) (!
  (and
    (or (<= 1 i@72@01) (not (<= 1 i@72@01)))
    (=>
      (and
        (<= 1 i@72@01)
        (<
          i@72@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@66@01)
              ($Snap.combine
                ($Snap.first $t@67@01)
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@62@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@60@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@43@01)
                            ($Snap.combine
                              ($SortWrappers.IntTo$Snap val_int@45@01)
                              ($Snap.combine
                                ($SortWrappers.$RefTo$Snap ret@54@01)
                                $t@56@01))))))))))
            $Snap.unit) _old$pre$0@71@01)))
      (and
        (<= 1 i@72@01)
        (<
          i@72@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@66@01)
              ($Snap.combine
                ($Snap.first $t@67@01)
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@62@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@60@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@43@01)
                            ($Snap.combine
                              ($SortWrappers.IntTo$Snap val_int@45@01)
                              ($Snap.combine
                                ($SortWrappers.$RefTo$Snap ret@54@01)
                                $t@56@01))))))))))
            $Snap.unit) _old$pre$0@71@01))
        (<= 0 (- i@72@01 1))
        (<
          (- i@72@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.first ($Snap.second $t@28@01))
            $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01))))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.first ($Snap.second $t@28@01))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) (-
          i@72@01
          1))
        (<= 0 i@72@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@66@01)
            ($Snap.combine
              ($Snap.first $t@67@01)
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@62@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@60@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@43@01)
                          ($Snap.combine
                            ($SortWrappers.IntTo$Snap val_int@45@01)
                            ($Snap.combine
                              ($SortWrappers.$RefTo$Snap ret@54@01)
                              $t@56@01))))))))))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01)))
    (or
      (not
        (and
          (<= 1 i@72@01)
          (<
            i@72@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@66@01)
                ($Snap.combine
                  ($Snap.first $t@67@01)
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@62@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@60@01)
                            ($Snap.combine
                              ($SortWrappers.$RefTo$Snap ret@43@01)
                              ($Snap.combine
                                ($SortWrappers.IntTo$Snap val_int@45@01)
                                ($Snap.combine
                                  ($SortWrappers.$RefTo$Snap ret@54@01)
                                  $t@56@01))))))))))
              $Snap.unit) _old$pre$0@71@01))))
      (and
        (<= 1 i@72@01)
        (<
          i@72@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@66@01)
              ($Snap.combine
                ($Snap.first $t@67@01)
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@62@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@60@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@43@01)
                            ($Snap.combine
                              ($SortWrappers.IntTo$Snap val_int@45@01)
                              ($Snap.combine
                                ($SortWrappers.$RefTo$Snap ret@54@01)
                                $t@56@01))))))))))
            $Snap.unit) _old$pre$0@71@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@779@646@779@1261-aux|)))
(assert (forall ((i@72@01 Int)) (!
  (and
    (=>
      (<= 1 i@72@01)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap ret@66@01)
          ($Snap.combine
            ($Snap.first $t@67@01)
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@62@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@60@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@43@01)
                        ($Snap.combine
                          ($SortWrappers.IntTo$Snap val_int@45@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@54@01)
                            $t@56@01))))))))))
        $Snap.unit) _old$pre$0@71@01))
    (=>
      (and
        (<= 1 i@72@01)
        (<
          i@72@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@66@01)
              ($Snap.combine
                ($Snap.first $t@67@01)
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@62@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@60@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@43@01)
                            ($Snap.combine
                              ($SortWrappers.IntTo$Snap val_int@45@01)
                              ($Snap.combine
                                ($SortWrappers.$RefTo$Snap ret@54@01)
                                $t@56@01))))))))))
            $Snap.unit) _old$pre$0@71@01)))
      (and
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.first ($Snap.second $t@28@01))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) (-
          i@72@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@66@01)
            ($Snap.combine
              ($Snap.first $t@67@01)
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@62@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@60@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@43@01)
                          ($Snap.combine
                            ($SortWrappers.IntTo$Snap val_int@45@01)
                            ($Snap.combine
                              ($SortWrappers.$RefTo$Snap ret@54@01)
                              $t@56@01))))))))))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@779@646@779@1261_precondition|)))
(push) ; 6
(assert (not (forall ((i@72@01 Int)) (!
  (=>
    (and
      (and
        (=>
          (<= 1 i@72@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@66@01)
              ($Snap.combine
                ($Snap.first $t@67@01)
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@62@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@60@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@43@01)
                            ($Snap.combine
                              ($SortWrappers.IntTo$Snap val_int@45@01)
                              ($Snap.combine
                                ($SortWrappers.$RefTo$Snap ret@54@01)
                                $t@56@01))))))))))
            $Snap.unit) _old$pre$0@71@01))
        (=>
          (and
            (<= 1 i@72@01)
            (<
              i@72@01
              (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@66@01)
                  ($Snap.combine
                    ($Snap.first $t@67@01)
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        $Snap.unit
                        ($Snap.combine
                          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@62@01)
                            ($Snap.combine
                              ($SortWrappers.$RefTo$Snap ret@60@01)
                              ($Snap.combine
                                ($SortWrappers.$RefTo$Snap ret@43@01)
                                ($Snap.combine
                                  ($SortWrappers.IntTo$Snap val_int@45@01)
                                  ($Snap.combine
                                    ($SortWrappers.$RefTo$Snap ret@54@01)
                                    $t@56@01))))))))))
                $Snap.unit) _old$pre$0@71@01)))
          (and
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
              ($Snap.first ($Snap.second $t@28@01))
              ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) (-
              i@72@01
              1))
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@66@01)
                ($Snap.combine
                  ($Snap.first $t@67@01)
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      $Snap.unit
                      ($Snap.combine
                        ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@62@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@60@01)
                            ($Snap.combine
                              ($SortWrappers.$RefTo$Snap ret@43@01)
                              ($Snap.combine
                                ($SortWrappers.IntTo$Snap val_int@45@01)
                                ($Snap.combine
                                  ($SortWrappers.$RefTo$Snap ret@54@01)
                                  $t@56@01))))))))))
              ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01))))
      (and
        (<= 1 i@72@01)
        (<
          i@72@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@66@01)
              ($Snap.combine
                ($Snap.first $t@67@01)
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    $Snap.unit
                    ($Snap.combine
                      ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@62@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@60@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@43@01)
                            ($Snap.combine
                              ($SortWrappers.IntTo$Snap val_int@45@01)
                              ($Snap.combine
                                ($SortWrappers.$RefTo$Snap ret@54@01)
                                $t@56@01))))))))))
            $Snap.unit) _old$pre$0@71@01))))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        ($Snap.first ($Snap.second $t@28@01))
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) (-
        i@72@01
        1))
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap ret@66@01)
          ($Snap.combine
            ($Snap.first $t@67@01)
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@62@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@60@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@43@01)
                        ($Snap.combine
                          ($SortWrappers.IntTo$Snap val_int@45@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@54@01)
                            $t@56@01))))))))))
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@779@646@779@1261|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (forall ((i@72@01 Int)) (!
  (=>
    (and
      (<= 1 i@72@01)
      (<
        i@72@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@66@01)
            ($Snap.combine
              ($Snap.first $t@67@01)
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  $Snap.unit
                  ($Snap.combine
                    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@62@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@60@01)
                        ($Snap.combine
                          ($SortWrappers.$RefTo$Snap ret@43@01)
                          ($Snap.combine
                            ($SortWrappers.IntTo$Snap val_int@45@01)
                            ($Snap.combine
                              ($SortWrappers.$RefTo$Snap ret@54@01)
                              $t@56@01))))))))))
          $Snap.unit) _old$pre$0@71@01)))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        ($Snap.first ($Snap.second $t@28@01))
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) (-
        i@72@01
        1))
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap ret@66@01)
          ($Snap.combine
            ($Snap.first $t@67@01)
            ($Snap.combine
              $Snap.unit
              ($Snap.combine
                $Snap.unit
                ($Snap.combine
                  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@62@01)
                    ($Snap.combine
                      ($SortWrappers.$RefTo$Snap ret@60@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@43@01)
                        ($Snap.combine
                          ($SortWrappers.IntTo$Snap val_int@45@01)
                          ($Snap.combine
                            ($SortWrappers.$RefTo$Snap ret@54@01)
                            $t@56@01))))))))))
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap ret@66@01)
      ($Snap.combine
        ($Snap.first $t@67@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@67@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@62@01)
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap ret@60@01)
                  ($Snap.combine
                    ($SortWrappers.$RefTo$Snap ret@43@01)
                    ($Snap.combine
                      ($SortWrappers.IntTo$Snap val_int@45@01)
                      ($Snap.combine
                        ($SortWrappers.$RefTo$Snap ret@54@01)
                        $t@56@01))))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@71@01 i@72@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@779@646@779@1261|)))
; [exec]
; assert true
; [exec]
; exhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_old$pre$0), write)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@28@01)) _old$pre$0@71@01)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(tuple0$(_0), write)
; [exec]
; label end_of_method
(pop) ; 5
(pop) ; 4
(pop) ; 3
; [eval] !(__t0 && __t0)
; [eval] __t0 && __t0
(set-option :timeout 0)
(push) ; 3
; [then-branch: 8 | False | live]
; [else-branch: 8 | True | live]
(push) ; 4
; [then-branch: 8 | False]
(assert false)
(pop) ; 4
(push) ; 4
; [else-branch: 8 | True]
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
; [then-branch: 9 | False | dead]
; [else-branch: 9 | True | live]
(push) ; 3
; [else-branch: 9 | True]
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$pop$opensqu$0$closesqu$ ----------
(declare-const _0@73@01 $Ref)
(declare-const _0@74@01 $Ref)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var __t0: Bool
(declare-const __t0@75@01 Bool)
; [exec]
; var __t1: Bool
(declare-const __t1@76@01 Bool)
; [exec]
; var __t2: Bool
(declare-const __t2@77@01 Bool)
; [exec]
; var __t3: Bool
(declare-const __t3@78@01 Bool)
; [exec]
; var __t4: Bool
(declare-const __t4@79@01 Bool)
; [exec]
; var __t5: Bool
(declare-const __t5@80@01 Bool)
; [exec]
; var __t6: Bool
(declare-const __t6@81@01 Bool)
; [exec]
; var __t7: Bool
(declare-const __t7@82@01 Bool)
; [exec]
; var __t8: Bool
(declare-const __t8@83@01 Bool)
; [exec]
; var __t9: Bool
(declare-const __t9@84@01 Bool)
; [exec]
; var __t10: Bool
(declare-const __t10@85@01 Bool)
; [exec]
; var __t11: Bool
(declare-const __t11@86@01 Bool)
; [exec]
; var __t12: Bool
(declare-const __t12@87@01 Bool)
; [exec]
; var __t13: Int
(declare-const __t13@88@01 Int)
; [exec]
; var _old$pre$0: Ref
(declare-const _old$pre$0@89@01 $Ref)
; [exec]
; var _1: Ref
(declare-const _1@90@01 $Ref)
; [exec]
; var _2: Ref
(declare-const _2@91@01 $Ref)
; [exec]
; var _3: Ref
(declare-const _3@92@01 $Ref)
; [exec]
; var _4: Ref
(declare-const _4@93@01 $Ref)
; [exec]
; var _5: Ref
(declare-const _5@94@01 $Ref)
; [exec]
; var _6: Int
(declare-const _6@95@01 Int)
; [exec]
; var _7: Ref
(declare-const _7@96@01 $Ref)
; [exec]
; var _8: Ref
(declare-const _8@97@01 $Ref)
; [exec]
; var _9: Int
(declare-const _9@98@01 Int)
; [exec]
; var _10: Ref
(declare-const _10@99@01 $Ref)
; [exec]
; var _11: Ref
(declare-const _11@100@01 $Ref)
; [exec]
; label start
; [exec]
; __t0 := false
; [exec]
; __t1 := false
; [exec]
; __t2 := false
; [exec]
; __t3 := false
; [exec]
; __t4 := false
; [exec]
; __t5 := false
; [exec]
; __t6 := false
; [exec]
; __t7 := false
; [exec]
; __t8 := false
; [exec]
; __t9 := false
; [exec]
; __t10 := false
; [exec]
; __t11 := false
; [exec]
; __t12 := false
; [exec]
; inhale acc(_1.val_ref, write) &&
;   acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write)
(declare-const $t@101@01 $Snap)
(assert (= $t@101@01 ($Snap.combine ($Snap.first $t@101@01) ($Snap.second $t@101@01))))
(assert (not (= _1@90@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@102@01 $Snap)
(assert (= $t@102@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@103@01 $Snap)
(assert (= $t@103@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@104@01 $Snap)
(assert (= $t@104@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; label pre
; [exec]
; label bb0
; [exec]
; __t0 := true
; [exec]
; _4 := builtin$havoc_ref()
(declare-const ret@105@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_4.val_ref, write)
(declare-const $t@106@01 $Ref)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@90@01 ret@105@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@105@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write)
(assert (=
  ($Snap.second $t@101@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@101@01))
    ($Snap.second ($Snap.second $t@101@01)))))
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.second $t@101@01) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
; [exec]
; _4.val_ref := _1.val_ref.f$head
(declare-const val_ref@107@01 $Ref)
(assert (=
  val_ref@107@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@101@01)))))
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@90@01 ret@105@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l0
; [exec]
; _3 := builtin$havoc_ref()
(declare-const ret@108@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_3.val_ref, write)
(declare-const $t@109@01 $Ref)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@105@01 ret@108@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@90@01 ret@108@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@108@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _3.val_ref := _4.val_ref
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@105@01 ret@108@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@90@01 ret@108@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l1
; [exec]
; _5 := builtin$havoc_ref()
(declare-const ret@110@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_5), write)
(declare-const $t@111@01 $Snap)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@101@01))) ret@110@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_5) ==
;   0
(declare-const $t@112@01 $Snap)
(assert (= $t@112@01 $Snap.unit))
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_5) == 0
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_5)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(assert (read$%precondition $Snap.unit))
(pop) ; 4
; Joined path conditions
(assert (read$%precondition $Snap.unit))
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@111@01 ret@110@01))
(pop) ; 3
; Joined path conditions
(assert (and
  (read$%precondition $Snap.unit)
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@111@01 ret@110@01)))
(assert (=
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@111@01 ret@110@01)
  0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l2
; [exec]
; assert m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(_5)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(_5)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@111@01
  $Snap.unit) ret@110@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@111@01
  $Snap.unit) ret@110@01))
(set-option :timeout 0)
(push) ; 3
(assert (not (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@111@01
  $Snap.unit) ret@110@01)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@111@01
  $Snap.unit) ret@110@01))
; [exec]
; assert true
; [exec]
; exhale acc(_3.val_ref, write) &&
;   (acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_3.val_ref), write) &&
;   acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_5), write))
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@110@01 val_ref@107@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@101@01)))
  val_ref@107@01)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; _2 := builtin$havoc_ref()
(declare-const ret@113@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(old[l2](_3.val_ref)), write)
; [eval] old[l2](_3.val_ref)
(declare-const $t@114@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write)
(declare-const $t@115@01 $Snap)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= val_ref@107@01 ret@113@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@116@01 $Snap)
(assert (= $t@116@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(old[l2](_3.val_ref)) &&
;   (old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_3.val_ref)) ==
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2) &&
;   (forall i: Int ::
;     { old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref,
;     i)) }
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2,
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2) ==>
;     old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref,
;     i)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2,
;     i)))
(declare-const $t@117@01 $Snap)
(assert (= $t@117@01 ($Snap.combine ($Snap.first $t@117@01) ($Snap.second $t@117@01))))
(assert (= ($Snap.first $t@117@01) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(old[l2](_3.val_ref))
; [eval] old[l2](_3.val_ref)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@114@01
  $Snap.unit) val_ref@107@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@114@01
  $Snap.unit) val_ref@107@01))
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@114@01
  $Snap.unit) val_ref@107@01))
(assert (=
  ($Snap.second $t@117@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@117@01))
    ($Snap.second ($Snap.second $t@117@01)))))
(assert (= ($Snap.first ($Snap.second $t@117@01)) $Snap.unit))
; [eval] old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_3.val_ref)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
; [eval] old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_3.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_3.val_ref)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@110@01 val_ref@107@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@101@01)))
  val_ref@107@01)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.second ($Snap.second $t@101@01))
  $Snap.unit) val_ref@107@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.second ($Snap.second $t@101@01))
  $Snap.unit) val_ref@107@01))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@115@01
  $Snap.unit) ret@113@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@115@01
  $Snap.unit) ret@113@01))
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second ($Snap.second $t@101@01))
    $Snap.unit) val_ref@107@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@115@01
    $Snap.unit) ret@113@01)))
(assert (= ($Snap.second ($Snap.second $t@117@01)) $Snap.unit))
; [eval] (forall i: Int :: { old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i)) } { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2, i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2) ==> old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2, i))
(declare-const i@118@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2) ==> old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2, i)
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
; [eval] 0 <= i
(push) ; 4
; [then-branch: 10 | !(0 <= i@118@01) | live]
; [else-branch: 10 | 0 <= i@118@01 | live]
(push) ; 5
; [then-branch: 10 | !(0 <= i@118@01)]
(assert (not (<= 0 i@118@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 10 | 0 <= i@118@01]
(assert (<= 0 i@118@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 i@118@01) (not (<= 0 i@118@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 11 | 0 <= i@118@01 && i@118@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@115@01, _), ret@113@01) | live]
; [else-branch: 11 | !(0 <= i@118@01 && i@118@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@115@01, _), ret@113@01)) | live]
(push) ; 5
; [then-branch: 11 | 0 <= i@118@01 && i@118@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@115@01, _), ret@113@01)]
(assert (and
  (<= 0 i@118@01)
  (<
    i@118@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@115@01
      $Snap.unit) ret@113@01))))
; [eval] old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2, i)
; [eval] old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@110@01 val_ref@107@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@101@01)))
  val_ref@107@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@110@01 val_ref@107@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@101@01)))
  val_ref@107@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(pop) ; 7
; Joined path conditions
(set-option :timeout 0)
(push) ; 7
(assert (not (<
  i@118@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second ($Snap.second $t@101@01))
    $Snap.unit) val_ref@107@01))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (<
  i@118@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second ($Snap.second $t@101@01))
    $Snap.unit) val_ref@107@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  ($Snap.second ($Snap.second $t@101@01))
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@107@01 i@118@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (<
    i@118@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second ($Snap.second $t@101@01))
      $Snap.unit) val_ref@107@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    ($Snap.second ($Snap.second $t@101@01))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@107@01 i@118@01)))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2, i)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(pop) ; 7
; Joined path conditions
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@115@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@113@01 i@118@01))
(pop) ; 6
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@115@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@113@01 i@118@01))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 11 | !(0 <= i@118@01 && i@118@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@115@01, _), ret@113@01))]
(assert (not
  (and
    (<= 0 i@118@01)
    (<
      i@118@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@115@01
        $Snap.unit) ret@113@01)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and
    (<= 0 i@118@01)
    (<
      i@118@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@115@01
        $Snap.unit) ret@113@01)))
  (and
    (<= 0 i@118@01)
    (<
      i@118@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@115@01
        $Snap.unit) ret@113@01))
    (<
      i@118@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.second ($Snap.second $t@101@01))
        $Snap.unit) val_ref@107@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      ($Snap.second ($Snap.second $t@101@01))
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@107@01 i@118@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@115@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@113@01 i@118@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 0 i@118@01)
      (<
        i@118@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@115@01
          $Snap.unit) ret@113@01))))
  (and
    (<= 0 i@118@01)
    (<
      i@118@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@115@01
        $Snap.unit) ret@113@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@118@01 Int)) (!
  (and
    (or (<= 0 i@118@01) (not (<= 0 i@118@01)))
    (=>
      (and
        (<= 0 i@118@01)
        (<
          i@118@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@115@01
            $Snap.unit) ret@113@01)))
      (and
        (<= 0 i@118@01)
        (<
          i@118@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@115@01
            $Snap.unit) ret@113@01))
        (<
          i@118@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.second ($Snap.second $t@101@01))
            $Snap.unit) val_ref@107@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.second ($Snap.second $t@101@01))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@107@01 i@118@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@115@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@113@01 i@118@01)))
    (or
      (not
        (and
          (<= 0 i@118@01)
          (<
            i@118@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@115@01
              $Snap.unit) ret@113@01))))
      (and
        (<= 0 i@118@01)
        (<
          i@118@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@115@01
            $Snap.unit) ret@113@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.second ($Snap.second $t@101@01))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@107@01 i@118@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@885@577@885@1171-aux|)))
(assert (forall ((i@118@01 Int)) (!
  (and
    (or (<= 0 i@118@01) (not (<= 0 i@118@01)))
    (=>
      (and
        (<= 0 i@118@01)
        (<
          i@118@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@115@01
            $Snap.unit) ret@113@01)))
      (and
        (<= 0 i@118@01)
        (<
          i@118@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@115@01
            $Snap.unit) ret@113@01))
        (<
          i@118@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.second ($Snap.second $t@101@01))
            $Snap.unit) val_ref@107@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.second ($Snap.second $t@101@01))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@107@01 i@118@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@115@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@113@01 i@118@01)))
    (or
      (not
        (and
          (<= 0 i@118@01)
          (<
            i@118@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@115@01
              $Snap.unit) ret@113@01))))
      (and
        (<= 0 i@118@01)
        (<
          i@118@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@115@01
            $Snap.unit) ret@113@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@115@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@113@01 i@118@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@885@577@885@1171-aux|)))
(assert (forall ((i@118@01 Int)) (!
  (=>
    (and
      (<= 0 i@118@01)
      (<
        i@118@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@115@01
          $Snap.unit) ret@113@01)))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        ($Snap.second ($Snap.second $t@101@01))
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@107@01 i@118@01)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@115@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@113@01 i@118@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.second ($Snap.second $t@101@01))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@107@01 i@118@01))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@115@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@113@01 i@118@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@885@577@885@1171|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l3
; [exec]
; label l4
; [exec]
; label bb2
; [exec]
; __t1 := true
; [exec]
; label bb5
; [exec]
; __t2 := true
; [exec]
; _6 := builtin$havoc_int()
(declare-const ret@119@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@120@01 $Snap)
(assert (= $t@120@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _6 := m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@115@01 ret@113@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@115@01 ret@113@01))
(declare-const _6@121@01 Int)
(assert (=
  _6@121@01
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@115@01 ret@113@01)))
; [exec]
; _7 := builtin$havoc_ref()
(declare-const ret@122@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_7.val_ref, write)
(declare-const $t@123@01 $Ref)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@105@01 ret@122@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@90@01 ret@122@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@122@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _7.val_ref := _2
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@105@01 ret@122@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@90@01 ret@122@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(set-option :timeout 0)
(push) ; 3
(pop) ; 3
; Joined path conditions
(push) ; 3
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(push) ; 3
(set-option :timeout 10)
(assert (not (=
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (<=
  $Perm.No
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))))
(set-option :timeout 0)
(push) ; 3
(assert (not (or
  (=
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No)
  (<
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_7.val_ref), read$())
; [eval] read$()
(push) ; 3
(pop) ; 3
; Joined path conditions
(push) ; 3
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(declare-const $t@124@01 $Snap)
(declare-const $t@125@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit)))))
    (= $t@125@01 $t@115@01))
  (=> (< $Perm.No (read$ $Snap.unit)) (= $t@125@01 $t@124@01))))
(assert (<=
  $Perm.No
  (+
    (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    (read$ $Snap.unit))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l5
; [exec]
; _9 := builtin$havoc_int()
(declare-const ret@126@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@127@01 $Snap)
(assert (= $t@127@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _9 := m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@125@01 ret@113@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@125@01 ret@113@01))
(declare-const _9@128@01 Int)
(assert (=
  _9@128@01
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@125@01 ret@113@01)))
; [exec]
; __t13 := _9
; [eval] __t13 == 0
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not (= _9@128@01 0))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _9@128@01 0)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 12 | _9@128@01 == 0 | live]
; [else-branch: 12 | _9@128@01 != 0 | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 12 | _9@128@01 == 0]
(assert (= _9@128@01 0))
; [exec]
; label l7
; [exec]
; label bb7
; [exec]
; __t4 := true
; [exec]
; label l8
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 13 | True | live]
; [else-branch: 13 | False | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 13 | True]
; [exec]
; exhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_7.val_ref), read$())
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (<=
  $Perm.No
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))))
(set-option :timeout 0)
(push) ; 5
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(declare-const $t@129@01 $Snap)
(declare-const $t@130@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@130@01 $t@125@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@130@01 $t@129@01))))
(assert (<=
  $Perm.No
  (+
    (-
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    (- $Perm.Write (read$ $Snap.unit)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb6
; [exec]
; __t9 := true
; [exec]
; _0 := builtin$havoc_ref()
(declare-const ret@131@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_0), write)
(declare-const $t@132@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) ==
;   1
(declare-const $t@133@01 $Snap)
(assert (= $t@133@01 $Snap.unit))
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) == 1
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@132@01 ret@131@01))
(pop) ; 5
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@132@01 ret@131@01))
(assert (=
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@132@01 ret@131@01)
  1))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l15
; [exec]
; label bb12
; [exec]
; __t10 := true
; [exec]
; label bb17
; [exec]
; __t11 := true
; [exec]
; label bb18
; [exec]
; __t12 := true
; [exec]
; label return
; [exec]
; fold acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@113@01 ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@101@01))))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.combine
  ($Snap.first ($Snap.second $t@101@01))
  $t@114@01) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
; [exec]
; _old$pre$0 := _1.val_ref
(declare-const _old$pre$0@134@01 $Ref)
(assert (= _old$pre$0@134@01 ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
; [exec]
; assert (old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_0)) &&
;   ((old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==
;   0) &&
;   ((old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_0)) &&
;   ((old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) ==
;   old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref,
;   0))) &&
;   ((old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==
;   old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref) -
;   1)) &&
;   (old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) >
;   0 ==>
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0,
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==>
;     old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref,
;     i + 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0,
;     i)))))))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_0)
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) == 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.second $t@101@01)
  $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
(pop) ; 5
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.second $t@101@01)
  $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
(set-option :timeout 0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second $t@101@01)
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
  0)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 14 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) == 0 | live]
; [else-branch: 14 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) != 0 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 14 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) == 0]
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second $t@101@01)
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
  0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@132@01
  $Snap.unit) ret@131@01))
(pop) ; 7
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@132@01
  $Snap.unit) ret@131@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (and
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.second $t@101@01)
        $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
      0)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@132@01
      $Snap.unit) ret@131@01))))
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second $t@101@01)
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
  0))
(set-option :timeout 0)
(push) ; 5
(assert (not (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@132@01
    $Snap.unit) ret@131@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@132@01
    $Snap.unit) ret@131@01)))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) == 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) == 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 15 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) == 0 | live]
; [else-branch: 15 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) != 0 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 15 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) == 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) == 0
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) _old$pre$0@134@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine ($Snap.first ($Snap.second $t@101@01)) $t@114@01)
  $Snap.unit) _old$pre$0@134@01))
(pop) ; 7
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine ($Snap.first ($Snap.second $t@101@01)) $t@114@01)
  $Snap.unit) _old$pre$0@134@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    ($Snap.combine ($Snap.first ($Snap.second $t@101@01)) $t@114@01)
    $Snap.unit) _old$pre$0@134@01)))
(set-option :timeout 0)
(push) ; 5
(assert (not (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.combine ($Snap.first ($Snap.second $t@101@01)) $t@114@01)
      $Snap.unit) _old$pre$0@134@01)
    0))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.combine ($Snap.first ($Snap.second $t@101@01)) $t@114@01)
      $Snap.unit) _old$pre$0@134@01)
    0)))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_0)
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 16 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0 | dead]
; [else-branch: 16 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0) | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 16 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0)]
(assert (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) == old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, 0))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
; [then-branch: 17 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0 | dead]
; [else-branch: 17 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0) | live]
(push) ; 6
; [else-branch: 17 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) == old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref) - 1)
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
; [then-branch: 18 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0 | dead]
; [else-branch: 18 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0) | live]
(push) ; 6
; [else-branch: 18 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0 ==> (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==> old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
; [then-branch: 19 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0 | dead]
; [else-branch: 19 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0) | live]
(push) ; 6
; [else-branch: 19 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0)]
(pop) ; 6
(pop) ; 5
; Joined path conditions
; [exec]
; assert true
; [exec]
; exhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_old$pre$0), write)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) _old$pre$0@134@01)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_0), write)
; [exec]
; label end_of_method
(pop) ; 4
; [eval] !__t2
; [then-branch: 20 | False | dead]
; [else-branch: 20 | True | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 20 | True]
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 12 | _9@128@01 != 0]
(assert (not (= _9@128@01 0)))
(pop) ; 3
; [eval] !(__t13 == 0)
; [eval] __t13 == 0
(push) ; 3
(set-option :timeout 10)
(assert (not (= _9@128@01 0)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (not (= _9@128@01 0))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 21 | _9@128@01 != 0 | live]
; [else-branch: 21 | _9@128@01 == 0 | live]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 21 | _9@128@01 != 0]
(assert (not (= _9@128@01 0)))
; [exec]
; label l6
; [exec]
; label bb8
; [exec]
; __t5 := true
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 22 | True | live]
; [else-branch: 22 | False | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 22 | True]
; [exec]
; exhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_7.val_ref), read$())
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (<=
  $Perm.No
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))))
(set-option :timeout 0)
(push) ; 5
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(declare-const $t@135@01 $Snap)
(declare-const $t@136@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@136@01 $t@125@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@136@01 $t@135@01))))
(assert (<=
  $Perm.No
  (+
    (-
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    (- $Perm.Write (read$ $Snap.unit)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb11
; [exec]
; __t6 := true
; [exec]
; unfold acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))
    ($Perm.min
      (+
        (-
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          ($Perm.min
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            (read$ $Snap.unit)))
        (- $Perm.Write (read$ $Snap.unit)))
      $Perm.Write))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(assert (not (or
  (=
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No)
  (<
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (= $t@136@01 ($Snap.combine ($Snap.first $t@136@01) ($Snap.second $t@136@01))))
(assert (not (= ret@113@01 $Ref.null)))
(assert (=
  ($Snap.second $t@136@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@136@01))
    ($Snap.second ($Snap.second $t@136@01)))))
(assert (= ($Snap.first ($Snap.second $t@136@01)) $Snap.unit))
; [eval] 0 <= self.discriminant
(assert (<= 0 ($SortWrappers.$SnapToInt ($Snap.first $t@136@01))))
(assert (=
  ($Snap.second ($Snap.second $t@136@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@136@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@136@01))) $Snap.unit))
; [eval] self.discriminant <= 1
(assert (<= ($SortWrappers.$SnapToInt ($Snap.first $t@136@01)) 1))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@136@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@136@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))
; [eval] self.discriminant == 1
(push) ; 5
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@136@01)) 1))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@136@01)) 1)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 23 | First:($t@136@01) == 1 | live]
; [else-branch: 23 | First:($t@136@01) != 1 | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 23 | First:($t@136@01) == 1]
(assert (= ($SortWrappers.$SnapToInt ($Snap.first $t@136@01)) 1))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_%trigger $t@136@01 ret@113@01))
; [exec]
; unfold acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_More(_2.enum_More), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))
    $Ref.null)))
; State saturation: after unfold
(check-sat)
; unknown
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_More%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))
; [exec]
; _8 := _2.enum_More.f$0
(declare-const _8@137@01 $Ref)
(assert (=
  _8@137@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))
; [exec]
; label l9
; [exec]
; unfold acc(m_alloc$$boxed$opensqu$0$closesqu$$$Box$opensqu$0$closesqu$$_beg_$m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_$_end_(_8), write)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))
  _8@137@01)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))))
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ret@122@01 _8@137@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ret@105@01 _8@137@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= _1@90@01 _8@137@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (not (= _8@137@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_alloc$$boxed$opensqu$0$closesqu$$$Box$opensqu$0$closesqu$$_beg_$m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_$_end_%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))) _8@137@01))
; [exec]
; unfold acc(m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_(_8.val_ref), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))
    $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))))
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  val_ref@107@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))))))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))))
; [exec]
; _10 := _8.val_ref.f$next
(declare-const _10@138@01 $Ref)
(assert (=
  _10@138@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))))
; [exec]
; label l10
; [exec]
; _1.val_ref.f$head := _10
; [exec]
; label l11
; [exec]
; label bb13
; [exec]
; __t7 := true
; [exec]
; label bb16
; [exec]
; __t8 := true
; [exec]
; _11 := builtin$havoc_ref()
(declare-const ret@139@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_11.val_int, write)
(declare-const $t@140@01 Int)
(assert (not (= ret@139@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(i32(_8.val_ref.f$elem), write)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  ret@139@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))
    $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (i32%trigger ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
; [exec]
; _11.val_int := _8.val_ref.f$elem.val_int
(declare-const val_int@141@01 Int)
(assert (=
  val_int@141@01
  ($SortWrappers.$SnapToInt ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))))))
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))
  ret@139@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l12
; [exec]
; _0 := builtin$havoc_ref()
(declare-const ret@142@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_0), write)
(declare-const $t@143@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) ==
;   0
(declare-const $t@144@01 $Snap)
(assert (= $t@144@01 $Snap.unit))
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) == 0
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0)
(set-option :timeout 0)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@143@01 ret@142@01))
(pop) ; 6
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@143@01 ret@142@01))
(assert (=
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@143@01 ret@142@01)
  0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_0), write)
(assert (= $t@143@01 ($Snap.combine ($Snap.first $t@143@01) ($Snap.second $t@143@01))))
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ret@113@01 ret@142@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@142@01 $Ref.null)))
(assert (=
  ($Snap.second $t@143@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@143@01))
    ($Snap.second ($Snap.second $t@143@01)))))
(assert (= ($Snap.first ($Snap.second $t@143@01)) $Snap.unit))
; [eval] 0 <= self.discriminant
(assert (<= 0 ($SortWrappers.$SnapToInt ($Snap.first $t@143@01))))
(assert (=
  ($Snap.second ($Snap.second $t@143@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@143@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@143@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@143@01))) $Snap.unit))
; [eval] self.discriminant <= 1
(assert (<= ($SortWrappers.$SnapToInt ($Snap.first $t@143@01)) 1))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@143@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@143@01)))))))
; [eval] self.discriminant == 0
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@143@01)) 0))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@143@01)) 0)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 24 | First:($t@143@01) == 0 | live]
; [else-branch: 24 | First:($t@143@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 24 | First:($t@143@01) == 0]
(assert (= ($SortWrappers.$SnapToInt ($Snap.first $t@143@01)) 0))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger $t@143@01 ret@142@01))
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some(_0.enum_Some), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@143@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@143@01))))))))
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01)))))
    $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@143@01)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01)))))))
; [exec]
; _0.enum_Some.f$0 := _11
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l13
; [exec]
; label l14
; [exec]
; fold acc(i32(_0.enum_Some.f$0), write)
(assert (i32%trigger ($SortWrappers.IntTo$Snap val_int@141@01) ret@139@01))
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@143@01))))))
  ret@139@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [exec]
; fold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some(_0.enum_Some), write)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some%trigger ($Snap.combine
  ($SortWrappers.$RefTo$Snap ret@139@01)
  ($SortWrappers.IntTo$Snap val_int@141@01)) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01)))))))
; [exec]
; fold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_0), write)
; [eval] 0 <= self.discriminant
; [eval] self.discriminant <= 1
; [eval] self.discriminant == 0
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@143@01)) 0))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 25 | First:($t@143@01) == 0 | live]
; [else-branch: 25 | First:($t@143@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 25 | First:($t@143@01) == 0]
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.combine
  ($Snap.first $t@143@01)
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap ret@139@01)
          ($SortWrappers.IntTo$Snap val_int@141@01)))))) ret@142@01))
; [exec]
; label bb12
; [exec]
; __t10 := true
; [exec]
; label bb17
; [exec]
; __t11 := true
; [exec]
; label bb18
; [exec]
; __t12 := true
; [exec]
; label return
; [exec]
; fold acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write)
(push) ; 8
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
  _10@138@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.combine
  ($SortWrappers.$RefTo$Snap _10@138@01)
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01)))))))))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
; [exec]
; _old$pre$0 := _1.val_ref
(declare-const _old$pre$0@145@01 $Ref)
(assert (= _old$pre$0@145@01 ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
; [exec]
; assert (old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_0)) &&
;   ((old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==
;   0) &&
;   ((old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_0)) &&
;   ((old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) ==
;   old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref,
;   0))) &&
;   ((old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==
;   old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref) -
;   1)) &&
;   (old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) >
;   0 ==>
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0,
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==>
;     old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref,
;     i + 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0,
;     i)))))))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_0)
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) == 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(set-option :timeout 0)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.second $t@101@01)
  $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
(pop) ; 8
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.second $t@101@01)
  $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
(set-option :timeout 0)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 26 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) == 0 | dead]
; [else-branch: 26 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) != 0 | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 26 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) != 0]
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) == 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) == 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
(set-option :timeout 0)
(push) ; 8
; [then-branch: 27 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) == 0 | dead]
; [else-branch: 27 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) != 0 | live]
(push) ; 9
; [else-branch: 27 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) != 0]
(pop) ; 9
(pop) ; 8
; Joined path conditions
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_0)
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
(set-option :timeout 0)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second $t@101@01)
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
  0)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 28 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0 | live]
; [else-branch: 28 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 28 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0]
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second $t@101@01)
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
  0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_0)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  ($Snap.combine
    ($Snap.first $t@143@01)
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@139@01)
            ($SortWrappers.IntTo$Snap val_int@141@01))))))
  $Snap.unit) ret@142@01))
(pop) ; 10
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  ($Snap.combine
    ($Snap.first $t@143@01)
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@139@01)
            ($SortWrappers.IntTo$Snap val_int@141@01))))))
  $Snap.unit) ret@142@01))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (and
    (>
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.second $t@101@01)
        $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
      0)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      ($Snap.combine
        ($Snap.first $t@143@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@139@01)
                ($SortWrappers.IntTo$Snap val_int@141@01))))))
      $Snap.unit) ret@142@01))))
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second $t@101@01)
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
  0))
(set-option :timeout 0)
(push) ; 8
(assert (not (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    ($Snap.combine
      ($Snap.first $t@143@01)
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@139@01)
              ($SortWrappers.IntTo$Snap val_int@141@01))))))
    $Snap.unit) ret@142@01))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    ($Snap.combine
      ($Snap.first $t@143@01)
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@139@01)
              ($SortWrappers.IntTo$Snap val_int@141@01))))))
    $Snap.unit) ret@142@01)))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) == old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, 0))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
(set-option :timeout 0)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 29 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0 | live]
; [else-branch: 29 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 29 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) == old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_0)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_pure_1)
(set-option :timeout 0)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  ($Snap.combine
    ($Snap.first $t@143@01)
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@139@01)
            ($SortWrappers.IntTo$Snap val_int@141@01))))))
  $Snap.unit) ret@142@01))
(pop) ; 11
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  ($Snap.combine
    ($Snap.first $t@143@01)
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@139@01)
            ($SortWrappers.IntTo$Snap val_int@141@01))))))
  $Snap.unit) ret@142@01))
(set-option :timeout 0)
(push) ; 11
(assert (not (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  ($Snap.combine
    ($Snap.first $t@143@01)
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@139@01)
            ($SortWrappers.IntTo$Snap val_int@141@01))))))
  $Snap.unit) ret@142@01)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  ($Snap.combine
    ($Snap.first $t@143@01)
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@139@01)
            ($SortWrappers.IntTo$Snap val_int@141@01))))))
  $Snap.unit) ret@142@01))
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($Snap.first $t@143@01)
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap ret@139@01)
            ($SortWrappers.IntTo$Snap val_int@141@01))))))
  $Snap.unit) ret@142@01))
(pop) ; 10
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
    ($Snap.combine
      ($Snap.first $t@143@01)
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@139@01)
              ($SortWrappers.IntTo$Snap val_int@141@01))))))
    $Snap.unit) ret@142@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    ($Snap.combine
      ($Snap.first $t@143@01)
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@139@01)
              ($SortWrappers.IntTo$Snap val_int@141@01))))))
    $Snap.unit) ret@142@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    ($Snap.combine
      ($Snap.first $t@143@01)
      ($Snap.combine
        $Snap.unit
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap ret@139@01)
              ($SortWrappers.IntTo$Snap val_int@141@01))))))
    $Snap.unit) ret@142@01)))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, 0)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second $t@101@01)
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second $t@101@01)
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  ($Snap.second $t@101@01)
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) 0))
(pop) ; 10
; Joined path conditions
(assert (and
  (<
    0
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    ($Snap.second $t@101@01)
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) 0)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (and
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      ($Snap.combine
        ($Snap.first $t@143@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@139@01)
                ($SortWrappers.IntTo$Snap val_int@141@01))))))
      $Snap.unit) ret@142@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
      ($Snap.combine
        ($Snap.first $t@143@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@139@01)
                ($SortWrappers.IntTo$Snap val_int@141@01))))))
      $Snap.unit) ret@142@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      ($Snap.combine
        ($Snap.first $t@143@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@139@01)
                ($SortWrappers.IntTo$Snap val_int@141@01))))))
      $Snap.unit) ret@142@01)
    (<
      0
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.second $t@101@01)
        $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      ($Snap.second $t@101@01)
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) 0))))
(push) ; 8
(assert (not (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.combine
        ($Snap.first $t@143@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@139@01)
                ($SortWrappers.IntTo$Snap val_int@141@01))))))
      $Snap.unit) ret@142@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) 0)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.combine
        ($Snap.first $t@143@01)
        ($Snap.combine
          $Snap.unit
          ($Snap.combine
            $Snap.unit
            ($Snap.combine
              ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@143@01))))
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap ret@139@01)
                ($SortWrappers.IntTo$Snap val_int@141@01))))))
      $Snap.unit) ret@142@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) 0))))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) == old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref) - 1)
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
(set-option :timeout 0)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 30 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0 | live]
; [else-branch: 30 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 30 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) == old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) _old$pre$0@145@01)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap _10@138@01)
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
  $Snap.unit) _old$pre$0@145@01))
(pop) ; 10
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap _10@138@01)
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
  $Snap.unit) _old$pre$0@145@01))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref) - 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(set-option :timeout 0)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(pop) ; 10
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap _10@138@01)
      ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
    $Snap.unit) _old$pre$0@145@01)))
(set-option :timeout 0)
(push) ; 8
(assert (not (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap _10@138@01)
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
      $Snap.unit) _old$pre$0@145@01)
    (-
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.second $t@101@01)
        $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
      1)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap _10@138@01)
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
      $Snap.unit) _old$pre$0@145@01)
    (-
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.second $t@101@01)
        $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
      1))))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0 ==> (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==> old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)) > 0
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
(set-option :timeout 0)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 31 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0 | live]
; [else-branch: 31 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0) | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 31 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$((Second:($t@101@01), _), First:($t@101@01)) > 0]
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==> old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i))
(declare-const i@146@01 Int)
(push) ; 10
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0) ==> old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i)
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0)
; [eval] 0 <= i
(push) ; 11
; [then-branch: 32 | !(0 <= i@146@01) | live]
; [else-branch: 32 | 0 <= i@146@01 | live]
(push) ; 12
; [then-branch: 32 | !(0 <= i@146@01)]
(assert (not (<= 0 i@146@01)))
(pop) ; 12
(push) ; 12
; [else-branch: 32 | 0 <= i@146@01]
(assert (<= 0 i@146@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_old$pre$0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) _old$pre$0@145@01)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap _10@138@01)
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
  $Snap.unit) _old$pre$0@145@01))
(pop) ; 13
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap _10@138@01)
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
  $Snap.unit) _old$pre$0@145@01))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 i@146@01)
  (and
    (<= 0 i@146@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap _10@138@01)
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
      $Snap.unit) _old$pre$0@145@01))))
(assert (or (<= 0 i@146@01) (not (<= 0 i@146@01))))
(set-option :timeout 0)
(push) ; 11
; [then-branch: 33 | 0 <= i@146@01 && i@146@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(((_10@138@01, Second:(Second:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@136@01)))))))))), _), _old$pre$0@145@01) | live]
; [else-branch: 33 | !(0 <= i@146@01 && i@146@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(((_10@138@01, Second:(Second:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@136@01)))))))))), _), _old$pre$0@145@01)) | live]
(push) ; 12
; [then-branch: 33 | 0 <= i@146@01 && i@146@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(((_10@138@01, Second:(Second:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@136@01)))))))))), _), _old$pre$0@145@01)]
(assert (and
  (<= 0 i@146@01)
  (<
    i@146@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap _10@138@01)
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
      $Snap.unit) _old$pre$0@145@01))))
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i)
; [eval] old[pre](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i + 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_1.val_ref, i + 1)
; [eval] i + 1
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 14
(assert (not (<= 0 (+ i@146@01 1))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (+ i@146@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 14
; [eval] read$()
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(push) ; 15
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(pop) ; 14
; Joined path conditions
(set-option :timeout 0)
(push) ; 14
(assert (not (<
  (+ i@146@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second $t@101@01)
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (<
  (+ i@146@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second $t@101@01)
    $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  ($Snap.second $t@101@01)
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) (+
  i@146@01
  1)))
(pop) ; 13
; Joined path conditions
(assert (and
  (<= 0 (+ i@146@01 1))
  (<
    (+ i@146@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    ($Snap.second $t@101@01)
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) (+
    i@146@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_old$pre$0, i)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) _old$pre$0@145@01)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 14
; [eval] read$()
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(push) ; 15
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) _old$pre$0@145@01)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap _10@138@01)
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
  $Snap.unit) _old$pre$0@145@01))
(pop) ; 14
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap _10@138@01)
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
  $Snap.unit) _old$pre$0@145@01))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  ($Snap.combine
    ($SortWrappers.$RefTo$Snap _10@138@01)
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01))
(pop) ; 13
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap _10@138@01)
      ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
    $Snap.unit) _old$pre$0@145@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap _10@138@01)
      ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01)))
(pop) ; 12
(set-option :timeout 0)
(push) ; 12
; [else-branch: 33 | !(0 <= i@146@01 && i@146@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(((_10@138@01, Second:(Second:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@136@01)))))))))), _), _old$pre$0@145@01))]
(assert (not
  (and
    (<= 0 i@146@01)
    (<
      i@146@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap _10@138@01)
          ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
        $Snap.unit) _old$pre$0@145@01)))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (=>
  (and
    (<= 0 i@146@01)
    (<
      i@146@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap _10@138@01)
          ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
        $Snap.unit) _old$pre$0@145@01)))
  (and
    (<= 0 i@146@01)
    (<
      i@146@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap _10@138@01)
          ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
        $Snap.unit) _old$pre$0@145@01))
    (<= 0 (+ i@146@01 1))
    (<
      (+ i@146@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.second $t@101@01)
        $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      ($Snap.second $t@101@01)
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) (+
      i@146@01
      1))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap _10@138@01)
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
      $Snap.unit) _old$pre$0@145@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap _10@138@01)
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 0 i@146@01)
      (<
        i@146@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap _10@138@01)
            ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
          $Snap.unit) _old$pre$0@145@01))))
  (and
    (<= 0 i@146@01)
    (<
      i@146@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap _10@138@01)
          ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
        $Snap.unit) _old$pre$0@145@01)))))
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@146@01 Int)) (!
  (and
    (=>
      (<= 0 i@146@01)
      (and
        (<= 0 i@146@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap _10@138@01)
            ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
          $Snap.unit) _old$pre$0@145@01)))
    (or (<= 0 i@146@01) (not (<= 0 i@146@01)))
    (=>
      (and
        (<= 0 i@146@01)
        (<
          i@146@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap _10@138@01)
              ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
            $Snap.unit) _old$pre$0@145@01)))
      (and
        (<= 0 i@146@01)
        (<
          i@146@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap _10@138@01)
              ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
            $Snap.unit) _old$pre$0@145@01))
        (<= 0 (+ i@146@01 1))
        (<
          (+ i@146@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.second $t@101@01)
            $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.second $t@101@01)
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) (+
          i@146@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap _10@138@01)
            ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
          $Snap.unit) _old$pre$0@145@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap _10@138@01)
            ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01)))
    (or
      (not
        (and
          (<= 0 i@146@01)
          (<
            i@146@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap _10@138@01)
                ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
              $Snap.unit) _old$pre$0@145@01))))
      (and
        (<= 0 i@146@01)
        (<
          i@146@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap _10@138@01)
              ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
            $Snap.unit) _old$pre$0@145@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.combine
      ($SortWrappers.$RefTo$Snap _10@138@01)
      ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@1150@2552@1150@3167-aux|)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (forall ((i@146@01 Int)) (!
    (and
      (=>
        (<= 0 i@146@01)
        (and
          (<= 0 i@146@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap _10@138@01)
              ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
            $Snap.unit) _old$pre$0@145@01)))
      (or (<= 0 i@146@01) (not (<= 0 i@146@01)))
      (=>
        (and
          (<= 0 i@146@01)
          (<
            i@146@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap _10@138@01)
                ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
              $Snap.unit) _old$pre$0@145@01)))
        (and
          (<= 0 i@146@01)
          (<
            i@146@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap _10@138@01)
                ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
              $Snap.unit) _old$pre$0@145@01))
          (<= 0 (+ i@146@01 1))
          (<
            (+ i@146@01 1)
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              ($Snap.second $t@101@01)
              $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01))))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            ($Snap.second $t@101@01)
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) (+
            i@146@01
            1))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap _10@138@01)
              ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
            $Snap.unit) _old$pre$0@145@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap _10@138@01)
              ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01)))
      (or
        (not
          (and
            (<= 0 i@146@01)
            (<
              i@146@01
              (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap _10@138@01)
                  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
                $Snap.unit) _old$pre$0@145@01))))
        (and
          (<= 0 i@146@01)
          (<
            i@146@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              ($Snap.combine
                ($SortWrappers.$RefTo$Snap _10@138@01)
                ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
              $Snap.unit) _old$pre$0@145@01)))))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap _10@138@01)
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@1150@2552@1150@3167-aux|))))
(push) ; 8
(assert (not (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (forall ((i@146@01 Int)) (!
    (=>
      (and
        (<= 0 i@146@01)
        (<
          i@146@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap _10@138@01)
              ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
            $Snap.unit) _old$pre$0@145@01)))
      (=
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          ($Snap.second $t@101@01)
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) (+
          i@146@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap _10@138@01)
            ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01)))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap _10@138@01)
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@1150@2552@1150@3167|)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second $t@101@01)
      $Snap.unit) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)))
    0)
  (forall ((i@146@01 Int)) (!
    (=>
      (and
        (<= 0 i@146@01)
        (<
          i@146@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap _10@138@01)
              ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
            $Snap.unit) _old$pre$0@145@01)))
      (=
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          ($Snap.second $t@101@01)
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) (+
          i@146@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap _10@138@01)
            ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01)))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      ($Snap.combine
        ($SortWrappers.$RefTo$Snap _10@138@01)
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@136@01))))))))))
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) _old$pre$0@145@01 i@146@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@1150@2552@1150@3167|))))
; [exec]
; assert true
; [exec]
; exhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_old$pre$0), write)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@101@01)) _old$pre$0@145@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_0), write)
; [exec]
; label end_of_method
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
; [eval] !__t2
; [then-branch: 34 | False | dead]
; [else-branch: 34 | True | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 34 | True]
(pop) ; 4
(pop) ; 3
(push) ; 3
; [else-branch: 21 | _9@128@01 == 0]
(assert (= _9@128@01 0))
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$6$closesqu$$$drop$opensqu$0$closesqu$ ----------
(declare-const _0@147@01 $Ref)
(declare-const _0@148@01 $Ref)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var __t0: Bool
(declare-const __t0@149@01 Bool)
; [exec]
; var __t1: Bool
(declare-const __t1@150@01 Bool)
; [exec]
; var __t2: Bool
(declare-const __t2@151@01 Bool)
; [exec]
; var __t3: Bool
(declare-const __t3@152@01 Bool)
; [exec]
; var __t4: Bool
(declare-const __t4@153@01 Bool)
; [exec]
; var __t5: Bool
(declare-const __t5@154@01 Bool)
; [exec]
; var __t6: Bool
(declare-const __t6@155@01 Bool)
; [exec]
; var __t7: Bool
(declare-const __t7@156@01 Bool)
; [exec]
; var __t8: Bool
(declare-const __t8@157@01 Bool)
; [exec]
; var __t9: Bool
(declare-const __t9@158@01 Bool)
; [exec]
; var __t10: Bool
(declare-const __t10@159@01 Bool)
; [exec]
; var __t11: Bool
(declare-const __t11@160@01 Bool)
; [exec]
; var __t12: Bool
(declare-const __t12@161@01 Bool)
; [exec]
; var __t13: Bool
(declare-const __t13@162@01 Bool)
; [exec]
; var __t14: Bool
(declare-const __t14@163@01 Bool)
; [exec]
; var __t15: Bool
(declare-const __t15@164@01 Bool)
; [exec]
; var __t16: Bool
(declare-const __t16@165@01 Bool)
; [exec]
; var __t17: Bool
(declare-const __t17@166@01 Bool)
; [exec]
; var __t18: Int
(declare-const __t18@167@01 Int)
; [exec]
; var __t19: Bool
(declare-const __t19@168@01 Bool)
; [exec]
; var _old$pre$0: Ref
(declare-const _old$pre$0@169@01 $Ref)
; [exec]
; var _1: Ref
(declare-const _1@170@01 $Ref)
; [exec]
; var _2: Ref
(declare-const _2@171@01 $Ref)
; [exec]
; var _3: Ref
(declare-const _3@172@01 $Ref)
; [exec]
; var _4: Ref
(declare-const _4@173@01 $Ref)
; [exec]
; var _5: Ref
(declare-const _5@174@01 $Ref)
; [exec]
; var _6: Ref
(declare-const _6@175@01 $Ref)
; [exec]
; var _7: Ref
(declare-const _7@176@01 $Ref)
; [exec]
; var _8: Ref
(declare-const _8@177@01 $Ref)
; [exec]
; var _9: Int
(declare-const _9@178@01 Int)
; [exec]
; var _10: Ref
(declare-const _10@179@01 $Ref)
; [exec]
; var _11: Ref
(declare-const _11@180@01 $Ref)
; [exec]
; var _12: Int
(declare-const _12@181@01 Int)
; [exec]
; var _13: Ref
(declare-const _13@182@01 $Ref)
; [exec]
; var _14: Ref
(declare-const _14@183@01 $Ref)
; [exec]
; var _15: Ref
(declare-const _15@184@01 $Ref)
; [exec]
; var _16: Ref
(declare-const _16@185@01 $Ref)
; [exec]
; label start
; [exec]
; __t0 := false
; [exec]
; __t1 := false
; [exec]
; __t2 := false
; [exec]
; __t3 := false
; [exec]
; __t4 := false
; [exec]
; __t5 := false
; [exec]
; __t6 := false
; [exec]
; __t7 := false
; [exec]
; __t8 := false
; [exec]
; __t9 := false
; [exec]
; __t10 := false
; [exec]
; __t11 := false
; [exec]
; __t12 := false
; [exec]
; __t13 := false
; [exec]
; __t14 := false
; [exec]
; __t15 := false
; [exec]
; __t16 := false
; [exec]
; inhale acc(_1.val_ref, write) &&
;   acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write)
(declare-const $t@186@01 $Snap)
(assert (= $t@186@01 ($Snap.combine ($Snap.first $t@186@01) ($Snap.second $t@186@01))))
(assert (not (= _1@170@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@187@01 $Snap)
(assert (= $t@187@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@188@01 $Snap)
(assert (= $t@188@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@189@01 $Snap)
(assert (= $t@189@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; label pre
; [exec]
; label bb0
; [exec]
; __t0 := true
; [exec]
; _4 := builtin$havoc_ref()
(declare-const ret@190@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_4.val_ref, write)
(declare-const $t@191@01 $Ref)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@170@01 ret@190@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@190@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write)
(assert (=
  ($Snap.second $t@186@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@186@01))
    ($Snap.second ($Snap.second $t@186@01)))))
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@186@01)) $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.second $t@186@01) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@186@01))))
; [exec]
; _4.val_ref := _1.val_ref.f$head
(declare-const val_ref@192@01 $Ref)
(assert (=
  val_ref@192@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@186@01)))))
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@170@01 ret@190@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l0
; [exec]
; _3 := builtin$havoc_ref()
(declare-const ret@193@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_3.val_ref, write)
(declare-const $t@194@01 $Ref)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@190@01 ret@193@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@170@01 ret@193@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@193@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _3.val_ref := _4.val_ref
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@190@01 ret@193@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= _1@170@01 ret@193@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l1
; [exec]
; _5 := builtin$havoc_ref()
(declare-const ret@195@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_5), write)
(declare-const $t@196@01 $Snap)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@186@01))) ret@195@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_5) ==
;   0
(declare-const $t@197@01 $Snap)
(assert (= $t@197@01 $Snap.unit))
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_5) == 0
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_5)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(assert (read$%precondition $Snap.unit))
(pop) ; 4
; Joined path conditions
(assert (read$%precondition $Snap.unit))
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@196@01 ret@195@01))
(pop) ; 3
; Joined path conditions
(assert (and
  (read$%precondition $Snap.unit)
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@196@01 ret@195@01)))
(assert (=
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@196@01 ret@195@01)
  0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l2
; [exec]
; assert m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(_5)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(_5)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@196@01
  $Snap.unit) ret@195@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@196@01
  $Snap.unit) ret@195@01))
(set-option :timeout 0)
(push) ; 3
(assert (not (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@196@01
  $Snap.unit) ret@195@01)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@196@01
  $Snap.unit) ret@195@01))
; [exec]
; assert true
; [exec]
; exhale acc(_3.val_ref, write) &&
;   (acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_3.val_ref), write) &&
;   acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_5), write))
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@195@01 val_ref@192@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@186@01)))
  val_ref@192@01)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; _2 := builtin$havoc_ref()
(declare-const ret@198@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(old[l2](_3.val_ref)), write)
; [eval] old[l2](_3.val_ref)
(declare-const $t@199@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write)
(declare-const $t@200@01 $Snap)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= val_ref@192@01 ret@198@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@201@01 $Snap)
(assert (= $t@201@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(old[l2](_3.val_ref)) &&
;   (old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_3.val_ref)) ==
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2) &&
;   (forall i: Int ::
;     { old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref,
;     i)) }
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2,
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2) ==>
;     old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref,
;     i)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2,
;     i)))
(declare-const $t@202@01 $Snap)
(assert (= $t@202@01 ($Snap.combine ($Snap.first $t@202@01) ($Snap.second $t@202@01))))
(assert (= ($Snap.first $t@202@01) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(old[l2](_3.val_ref))
; [eval] old[l2](_3.val_ref)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@199@01
  $Snap.unit) val_ref@192@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@199@01
  $Snap.unit) val_ref@192@01))
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@199@01
  $Snap.unit) val_ref@192@01))
(assert (=
  ($Snap.second $t@202@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@202@01))
    ($Snap.second ($Snap.second $t@202@01)))))
(assert (= ($Snap.first ($Snap.second $t@202@01)) $Snap.unit))
; [eval] old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_3.val_ref)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
; [eval] old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_3.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_3.val_ref)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@195@01 val_ref@192@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@186@01)))
  val_ref@192@01)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.second ($Snap.second $t@186@01))
  $Snap.unit) val_ref@192@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.second ($Snap.second $t@186@01))
  $Snap.unit) val_ref@192@01))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@200@01
  $Snap.unit) ret@198@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@200@01
  $Snap.unit) ret@198@01))
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second ($Snap.second $t@186@01))
    $Snap.unit) val_ref@192@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@200@01
    $Snap.unit) ret@198@01)))
(assert (= ($Snap.second ($Snap.second $t@202@01)) $Snap.unit))
; [eval] (forall i: Int :: { old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i)) } { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2, i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2) ==> old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2, i))
(declare-const i@203@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2) ==> old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2, i)
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
; [eval] 0 <= i
(push) ; 4
; [then-branch: 35 | !(0 <= i@203@01) | live]
; [else-branch: 35 | 0 <= i@203@01 | live]
(push) ; 5
; [then-branch: 35 | !(0 <= i@203@01)]
(assert (not (<= 0 i@203@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 35 | 0 <= i@203@01]
(assert (<= 0 i@203@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 i@203@01) (not (<= 0 i@203@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 36 | 0 <= i@203@01 && i@203@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@200@01, _), ret@198@01) | live]
; [else-branch: 36 | !(0 <= i@203@01 && i@203@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@200@01, _), ret@198@01)) | live]
(push) ; 5
; [then-branch: 36 | 0 <= i@203@01 && i@203@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@200@01, _), ret@198@01)]
(assert (and
  (<= 0 i@203@01)
  (<
    i@203@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@200@01
      $Snap.unit) ret@198@01))))
; [eval] old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2, i)
; [eval] old[l2](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_3.val_ref, i)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@195@01 val_ref@192@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@186@01)))
  val_ref@192@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@195@01 val_ref@192@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@186@01)))
  val_ref@192@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(pop) ; 7
; Joined path conditions
(set-option :timeout 0)
(push) ; 7
(assert (not (<
  i@203@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second ($Snap.second $t@186@01))
    $Snap.unit) val_ref@192@01))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (<
  i@203@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second ($Snap.second $t@186@01))
    $Snap.unit) val_ref@192@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  ($Snap.second ($Snap.second $t@186@01))
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@192@01 i@203@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (<
    i@203@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second ($Snap.second $t@186@01))
      $Snap.unit) val_ref@192@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    ($Snap.second ($Snap.second $t@186@01))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@192@01 i@203@01)))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_2, i)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(pop) ; 7
; Joined path conditions
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@200@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@198@01 i@203@01))
(pop) ; 6
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@200@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@198@01 i@203@01))
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 36 | !(0 <= i@203@01 && i@203@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@200@01, _), ret@198@01))]
(assert (not
  (and
    (<= 0 i@203@01)
    (<
      i@203@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@200@01
        $Snap.unit) ret@198@01)))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and
    (<= 0 i@203@01)
    (<
      i@203@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@200@01
        $Snap.unit) ret@198@01)))
  (and
    (<= 0 i@203@01)
    (<
      i@203@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@200@01
        $Snap.unit) ret@198@01))
    (<
      i@203@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.second ($Snap.second $t@186@01))
        $Snap.unit) val_ref@192@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      ($Snap.second ($Snap.second $t@186@01))
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@192@01 i@203@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@200@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@198@01 i@203@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 0 i@203@01)
      (<
        i@203@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@200@01
          $Snap.unit) ret@198@01))))
  (and
    (<= 0 i@203@01)
    (<
      i@203@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@200@01
        $Snap.unit) ret@198@01)))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@203@01 Int)) (!
  (and
    (or (<= 0 i@203@01) (not (<= 0 i@203@01)))
    (=>
      (and
        (<= 0 i@203@01)
        (<
          i@203@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@200@01
            $Snap.unit) ret@198@01)))
      (and
        (<= 0 i@203@01)
        (<
          i@203@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@200@01
            $Snap.unit) ret@198@01))
        (<
          i@203@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.second ($Snap.second $t@186@01))
            $Snap.unit) val_ref@192@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.second ($Snap.second $t@186@01))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@192@01 i@203@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@200@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@198@01 i@203@01)))
    (or
      (not
        (and
          (<= 0 i@203@01)
          (<
            i@203@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@200@01
              $Snap.unit) ret@198@01))))
      (and
        (<= 0 i@203@01)
        (<
          i@203@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@200@01
            $Snap.unit) ret@198@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.second ($Snap.second $t@186@01))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@192@01 i@203@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@1271@577@1271@1171-aux|)))
(assert (forall ((i@203@01 Int)) (!
  (and
    (or (<= 0 i@203@01) (not (<= 0 i@203@01)))
    (=>
      (and
        (<= 0 i@203@01)
        (<
          i@203@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@200@01
            $Snap.unit) ret@198@01)))
      (and
        (<= 0 i@203@01)
        (<
          i@203@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@200@01
            $Snap.unit) ret@198@01))
        (<
          i@203@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.second ($Snap.second $t@186@01))
            $Snap.unit) val_ref@192@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.second ($Snap.second $t@186@01))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@192@01 i@203@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@200@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@198@01 i@203@01)))
    (or
      (not
        (and
          (<= 0 i@203@01)
          (<
            i@203@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@200@01
              $Snap.unit) ret@198@01))))
      (and
        (<= 0 i@203@01)
        (<
          i@203@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@200@01
            $Snap.unit) ret@198@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@200@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@198@01 i@203@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@1271@577@1271@1171-aux|)))
(assert (forall ((i@203@01 Int)) (!
  (=>
    (and
      (<= 0 i@203@01)
      (<
        i@203@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@200@01
          $Snap.unit) ret@198@01)))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        ($Snap.second ($Snap.second $t@186@01))
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@192@01 i@203@01)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@200@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@198@01 i@203@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.second ($Snap.second $t@186@01))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@192@01 i@203@01))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@200@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@198@01 i@203@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@1271@577@1271@1171|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l3
; [exec]
; label l4
; [exec]
; label bb2
; [exec]
; __t1 := true
; [exec]
; label bb4
; [exec]
; __t2 := true
; [exec]
; _6 := builtin$havoc_ref()
(declare-const ret@204@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_6.val_bool, write)
(declare-const $t@205@01 Bool)
(assert (not (= ret@204@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _6.val_bool := true
; [exec]
; label loop5_start
; [exec]
; label loop5_group1_bb5
; [exec]
; __t3 := true
; [exec]
; _7 := builtin$havoc_ref()
(declare-const ret@206@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_7.val_bool, write)
(declare-const $t@207@01 Bool)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@204@01 ret@206@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@206@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _7.val_bool := _6.val_bool
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@204@01 ret@206@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l5
; [exec]
; __t17 := _7.val_bool
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 37 | True | live]
; [else-branch: 37 | False | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 37 | True]
; [exec]
; label l7
; [exec]
; label loop5_inv_pre
; [exec]
; fold acc(bool(_6), write)
(assert (bool%trigger ($SortWrappers.BoolTo$Snap true) ret@204@01))
; [exec]
; exhale acc(bool(_6), write) &&
;   acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write)
; [exec]
; __t10 := builtin$havoc_bool()
(declare-const ret@208@01 Bool)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; __t3 := builtin$havoc_bool()
(declare-const ret@209@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t19 := builtin$havoc_bool()
(declare-const ret@210@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t18 := builtin$havoc_int()
(declare-const ret@211@01 Int)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _14 := builtin$havoc_ref()
(declare-const ret@212@01 $Ref)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t14 := builtin$havoc_bool()
(declare-const ret@213@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t12 := builtin$havoc_bool()
(declare-const ret@214@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t11 := builtin$havoc_bool()
(declare-const ret@215@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t7 := builtin$havoc_bool()
(declare-const ret@216@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _13 := builtin$havoc_ref()
(declare-const ret@217@01 $Ref)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t5 := builtin$havoc_bool()
(declare-const ret@218@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _12 := builtin$havoc_int()
(declare-const ret@219@01 Int)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _7 := builtin$havoc_ref()
(declare-const ret@220@01 $Ref)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _16 := builtin$havoc_ref()
(declare-const ret@221@01 $Ref)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _11 := builtin$havoc_ref()
(declare-const ret@222@01 $Ref)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _2 := builtin$havoc_ref()
(declare-const ret@223@01 $Ref)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _15 := builtin$havoc_ref()
(declare-const ret@224@01 $Ref)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _9 := builtin$havoc_int()
(declare-const ret@225@01 Int)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t4 := builtin$havoc_bool()
(declare-const ret@226@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _8 := builtin$havoc_ref()
(declare-const ret@227@01 $Ref)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t6 := builtin$havoc_bool()
(declare-const ret@228@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t8 := builtin$havoc_bool()
(declare-const ret@229@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t9 := builtin$havoc_bool()
(declare-const ret@230@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; _10 := builtin$havoc_ref()
(declare-const ret@231@01 $Ref)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; __t13 := builtin$havoc_bool()
(declare-const ret@232@01 Bool)
; State saturation: after contract
(check-sat)
; unknown
; [exec]
; label loop5_inv_post
; [exec]
; inhale acc(bool(_6), write) &&
;   acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write)
(declare-const $t@233@01 $Snap)
(assert (= $t@233@01 ($Snap.combine ($Snap.first $t@233@01) ($Snap.second $t@233@01))))
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= val_ref@192@01 ret@223@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@234@01 $Snap)
(assert (= $t@234@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@235@01 $Snap)
(assert (= $t@235@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; label loop5_group3_bb7
; [exec]
; __t4 := true
; [exec]
; _9 := builtin$havoc_int()
(declare-const ret@236@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@237@01 $Snap)
(assert (= $t@237@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _9 := m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_2)
(set-option :timeout 0)
(push) ; 4
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.second $t@233@01) ret@223@01))
(pop) ; 4
; Joined path conditions
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.second $t@233@01) ret@223@01))
(declare-const _9@238@01 Int)
(assert (=
  _9@238@01
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.second $t@233@01) ret@223@01)))
; [exec]
; _10 := builtin$havoc_ref()
(declare-const ret@239@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_10.val_ref, write)
(declare-const $t@240@01 $Ref)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@190@01 ret@239@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _1@170@01 ret@239@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@239@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _10.val_ref := _2
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@190@01 ret@239@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _1@170@01 ret@239@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(set-option :timeout 0)
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (<=
  $Perm.No
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))))
(set-option :timeout 0)
(push) ; 4
(assert (not (or
  (=
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No)
  (<
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_10.val_ref), read$())
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const $t@241@01 $Snap)
(declare-const $t@242@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit)))))
    (= $t@242@01 ($Snap.second $t@233@01)))
  (=> (< $Perm.No (read$ $Snap.unit)) (= $t@242@01 $t@241@01))))
(assert (<=
  $Perm.No
  (+
    (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    (read$ $Snap.unit))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l8
; [exec]
; _12 := builtin$havoc_int()
(declare-const ret@243@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@244@01 $Snap)
(assert (= $t@244@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _12 := m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_10.val_ref)
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_10.val_ref)
(set-option :timeout 0)
(push) ; 4
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@242@01 ret@223@01))
(pop) ; 4
; Joined path conditions
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@242@01 ret@223@01))
(declare-const _12@245@01 Int)
(assert (=
  _12@245@01
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@242@01 ret@223@01)))
; [exec]
; __t18 := _12
; [eval] __t18 == 1
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= _12@245@01 1))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= _12@245@01 1)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 38 | _12@245@01 == 1 | live]
; [else-branch: 38 | _12@245@01 != 1 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 38 | _12@245@01 == 1]
(assert (= _12@245@01 1))
; [exec]
; label l10
; [exec]
; label loop5_group3_bb9
; [exec]
; __t5 := true
; [exec]
; label l11
(push) ; 5
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 39 | True | live]
; [else-branch: 39 | False | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 39 | True]
; [exec]
; exhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_10.val_ref), read$())
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (<=
  $Perm.No
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))))
(set-option :timeout 0)
(push) ; 6
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(declare-const $t@246@01 $Snap)
(declare-const $t@247@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@247@01 $t@242@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@247@01 $t@246@01))))
(assert (<=
  $Perm.No
  (+
    (-
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    (- $Perm.Write (read$ $Snap.unit)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label loop5_group3_bb12
; [exec]
; __t8 := true
; [exec]
; unfold acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))
    ($Perm.min
      (+
        (-
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          ($Perm.min
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            (read$ $Snap.unit)))
        (- $Perm.Write (read$ $Snap.unit)))
      $Perm.Write))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(assert (not (or
  (=
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No)
  (<
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (= $t@247@01 ($Snap.combine ($Snap.first $t@247@01) ($Snap.second $t@247@01))))
(assert (not (= ret@223@01 $Ref.null)))
(assert (=
  ($Snap.second $t@247@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@247@01))
    ($Snap.second ($Snap.second $t@247@01)))))
(assert (= ($Snap.first ($Snap.second $t@247@01)) $Snap.unit))
; [eval] 0 <= self.discriminant
(assert (<= 0 ($SortWrappers.$SnapToInt ($Snap.first $t@247@01))))
(assert (=
  ($Snap.second ($Snap.second $t@247@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@247@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@247@01))) $Snap.unit))
; [eval] self.discriminant <= 1
(assert (<= ($SortWrappers.$SnapToInt ($Snap.first $t@247@01)) 1))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@247@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@247@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))
; [eval] self.discriminant == 1
(push) ; 6
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@247@01)) 1))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@247@01)) 1)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 40 | First:($t@247@01) == 1 | live]
; [else-branch: 40 | First:($t@247@01) != 1 | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 40 | First:($t@247@01) == 1]
(assert (= ($SortWrappers.$SnapToInt ($Snap.first $t@247@01)) 1))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_%trigger $t@247@01 ret@223@01))
; [exec]
; unfold acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_More(_2.enum_More), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))
    $Ref.null)))
; State saturation: after unfold
(check-sat)
; unknown
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_More%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))
; [exec]
; _11 := _2.enum_More.f$0
(declare-const _11@248@01 $Ref)
(assert (=
  _11@248@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))
; [exec]
; label l12
; [exec]
; _15 := builtin$havoc_ref()
(declare-const ret@249@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_15.val_ref, write)
(declare-const $t@250@01 $Ref)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@239@01 ret@249@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@190@01 ret@249@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= _1@170@01 ret@249@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@249@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_alloc$$boxed$opensqu$0$closesqu$$$Box$opensqu$0$closesqu$$_beg_$m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_$_end_(_11), write)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))
  _11@248@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@249@01 _11@248@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@239@01 _11@248@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@190@01 _11@248@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= _1@170@01 _11@248@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (not (= _11@248@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_alloc$$boxed$opensqu$0$closesqu$$$Box$opensqu$0$closesqu$$_beg_$m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_$_end_%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))) _11@248@01))
; [exec]
; unfold acc(m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_(_11.val_ref), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))))
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))
    $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))))))
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  val_ref@192@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$Node$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
; [exec]
; _15.val_ref := _11.val_ref.f$next
(declare-const val_ref@251@01 $Ref)
(assert (=
  val_ref@251@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))))))
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= _11@248@01 ret@249@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@239@01 ret@249@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@190@01 ret@249@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= _1@170@01 ret@249@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l13
; [exec]
; _14 := builtin$havoc_ref()
(declare-const ret@252@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_14.val_ref, write)
(declare-const $t@253@01 $Ref)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@249@01 ret@252@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= _11@248@01 ret@252@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@239@01 ret@252@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@190@01 ret@252@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= _1@170@01 ret@252@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@252@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _14.val_ref := _15.val_ref
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@249@01 ret@252@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= _11@248@01 ret@252@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@239@01 ret@252@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@190@01 ret@252@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= _1@170@01 ret@252@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l14
; [exec]
; _16 := builtin$havoc_ref()
(declare-const ret@254@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_16), write)
(declare-const $t@255@01 $Snap)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))))
  ret@254@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= val_ref@192@01 ret@254@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_16) ==
;   0
(declare-const $t@256@01 $Snap)
(assert (= $t@256@01 $Snap.unit))
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_16) == 0
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_16)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@255@01 ret@254@01))
(pop) ; 7
; Joined path conditions
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@255@01 ret@254@01))
(assert (=
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@255@01 ret@254@01)
  0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l15
; [exec]
; assert m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(_16)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(_16)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@255@01
  $Snap.unit) ret@254@01))
(pop) ; 7
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@255@01
  $Snap.unit) ret@254@01))
(set-option :timeout 0)
(push) ; 7
(assert (not (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@255@01
  $Snap.unit) ret@254@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@255@01
  $Snap.unit) ret@254@01))
; [exec]
; assert true
; [exec]
; exhale acc(_14.val_ref, write) &&
;   (acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_14.val_ref), write) &&
;   acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_16), write))
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@254@01 val_ref@251@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))))
  val_ref@251@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [exec]
; _13 := builtin$havoc_ref()
(declare-const ret@257@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(old[l15](_14.val_ref)), write)
; [eval] old[l15](_14.val_ref)
(declare-const $t@258@01 $Snap)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= val_ref@192@01 val_ref@251@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_13), write)
(declare-const $t@259@01 $Snap)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= val_ref@251@01 ret@257@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= val_ref@192@01 ret@257@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@260@01 $Snap)
(assert (= $t@260@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(old[l15](_14.val_ref)) &&
;   (old[l15](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_14.val_ref)) ==
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_13) &&
;   (forall i: Int ::
;     { old[l15](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_14.val_ref,
;     i)) }
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13,
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_13) ==>
;     old[l15](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_14.val_ref,
;     i)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13,
;     i)))
(declare-const $t@261@01 $Snap)
(assert (= $t@261@01 ($Snap.combine ($Snap.first $t@261@01) ($Snap.second $t@261@01))))
(assert (= ($Snap.first $t@261@01) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$(old[l15](_14.val_ref))
; [eval] old[l15](_14.val_ref)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@258@01
  $Snap.unit) val_ref@251@01))
(pop) ; 7
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@258@01
  $Snap.unit) val_ref@251@01))
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$is_empty$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@258@01
  $Snap.unit) val_ref@251@01))
(assert (=
  ($Snap.second $t@261@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@261@01))
    ($Snap.second ($Snap.second $t@261@01)))))
(assert (= ($Snap.first ($Snap.second $t@261@01)) $Snap.unit))
; [eval] old[l15](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_14.val_ref)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_13)
; [eval] old[l15](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_14.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_14.val_ref)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@254@01 val_ref@251@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))))
  val_ref@251@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
  $Snap.unit) val_ref@251@01))
(pop) ; 7
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
  $Snap.unit) val_ref@251@01))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_13)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@259@01
  $Snap.unit) ret@257@01))
(pop) ; 7
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@259@01
  $Snap.unit) ret@257@01))
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
    $Snap.unit) val_ref@251@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@259@01
    $Snap.unit) ret@257@01)))
(assert (= ($Snap.second ($Snap.second $t@261@01)) $Snap.unit))
; [eval] (forall i: Int :: { old[l15](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_14.val_ref, i)) } { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13, i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_13) ==> old[l15](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_14.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13, i))
(declare-const i@262@01 Int)
(set-option :timeout 0)
(push) ; 7
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_13) ==> old[l15](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_14.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13, i)
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_13)
; [eval] 0 <= i
(push) ; 8
; [then-branch: 41 | !(0 <= i@262@01) | live]
; [else-branch: 41 | 0 <= i@262@01 | live]
(push) ; 9
; [then-branch: 41 | !(0 <= i@262@01)]
(assert (not (<= 0 i@262@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 41 | 0 <= i@262@01]
(assert (<= 0 i@262@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_13)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_13)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(pop) ; 10
; Joined path conditions
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 i@262@01) (not (<= 0 i@262@01))))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 42 | 0 <= i@262@01 && i@262@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@259@01, _), ret@257@01) | live]
; [else-branch: 42 | !(0 <= i@262@01 && i@262@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@259@01, _), ret@257@01)) | live]
(push) ; 9
; [then-branch: 42 | 0 <= i@262@01 && i@262@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@259@01, _), ret@257@01)]
(assert (and
  (<= 0 i@262@01)
  (<
    i@262@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@259@01
      $Snap.unit) ret@257@01))))
; [eval] old[l15](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_14.val_ref, i)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13, i)
; [eval] old[l15](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_14.val_ref, i))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_14.val_ref, i)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (= ret@254@01 val_ref@251@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))))
  val_ref@251@01)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@254@01 val_ref@251@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01))))))))))
  val_ref@251@01)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (<
  i@262@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
    $Snap.unit) val_ref@251@01))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (<
  i@262@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
    $Snap.unit) val_ref@251@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@251@01 i@262@01))
(pop) ; 10
; Joined path conditions
(assert (and
  (<
    i@262@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
      $Snap.unit) val_ref@251@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@251@01 i@262@01)))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13, i)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(pop) ; 11
; Joined path conditions
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@259@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@257@01 i@262@01))
(pop) ; 10
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@259@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@257@01 i@262@01))
(pop) ; 9
(set-option :timeout 0)
(push) ; 9
; [else-branch: 42 | !(0 <= i@262@01 && i@262@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@259@01, _), ret@257@01))]
(assert (not
  (and
    (<= 0 i@262@01)
    (<
      i@262@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@259@01
        $Snap.unit) ret@257@01)))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  (and
    (<= 0 i@262@01)
    (<
      i@262@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@259@01
        $Snap.unit) ret@257@01)))
  (and
    (<= 0 i@262@01)
    (<
      i@262@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@259@01
        $Snap.unit) ret@257@01))
    (<
      i@262@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
        $Snap.unit) val_ref@251@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@251@01 i@262@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@259@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@257@01 i@262@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 0 i@262@01)
      (<
        i@262@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@259@01
          $Snap.unit) ret@257@01))))
  (and
    (<= 0 i@262@01)
    (<
      i@262@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@259@01
        $Snap.unit) ret@257@01)))))
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@262@01 Int)) (!
  (and
    (or (<= 0 i@262@01) (not (<= 0 i@262@01)))
    (=>
      (and
        (<= 0 i@262@01)
        (<
          i@262@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@259@01
            $Snap.unit) ret@257@01)))
      (and
        (<= 0 i@262@01)
        (<
          i@262@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@259@01
            $Snap.unit) ret@257@01))
        (<
          i@262@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
            $Snap.unit) val_ref@251@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@251@01 i@262@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@259@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@257@01 i@262@01)))
    (or
      (not
        (and
          (<= 0 i@262@01)
          (<
            i@262@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@259@01
              $Snap.unit) ret@257@01))))
      (and
        (<= 0 i@262@01)
        (<
          i@262@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@259@01
            $Snap.unit) ret@257@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@251@01 i@262@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@1532@582@1532@1180-aux|)))
(assert (forall ((i@262@01 Int)) (!
  (and
    (or (<= 0 i@262@01) (not (<= 0 i@262@01)))
    (=>
      (and
        (<= 0 i@262@01)
        (<
          i@262@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@259@01
            $Snap.unit) ret@257@01)))
      (and
        (<= 0 i@262@01)
        (<
          i@262@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@259@01
            $Snap.unit) ret@257@01))
        (<
          i@262@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
            $Snap.unit) val_ref@251@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@251@01 i@262@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@259@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@257@01 i@262@01)))
    (or
      (not
        (and
          (<= 0 i@262@01)
          (<
            i@262@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@259@01
              $Snap.unit) ret@257@01))))
      (and
        (<= 0 i@262@01)
        (<
          i@262@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@259@01
            $Snap.unit) ret@257@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@259@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@257@01 i@262@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@1532@582@1532@1180-aux|)))
(assert (forall ((i@262@01 Int)) (!
  (=>
    (and
      (<= 0 i@262@01)
      (<
        i@262@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@259@01
          $Snap.unit) ret@257@01)))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@251@01 i@262@01)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@259@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@257@01 i@262@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@247@01)))))))))
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) val_ref@251@01 i@262@01))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$1$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@259@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@257@01 i@262@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@1532@582@1532@1180|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l16
; [exec]
; label l17
; [exec]
; label loop5_group3_bb14
; [exec]
; __t9 := true
; [exec]
; label loop5_group3_bb19
; [exec]
; __t10 := true
; [exec]
; _2 := _13
; [exec]
; label l18
; [exec]
; label loop5_group3_bb20
; [exec]
; __t11 := true
; [exec]
; label loop5_group3_bb21
; [exec]
; __t12 := true
; [exec]
; _8 := builtin$havoc_ref()
(declare-const ret@263@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_8), write)
(declare-const $t@264@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l22
; [exec]
; unfold acc(bool(_6), write)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@206@01 ret@204@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (bool%trigger ($Snap.first $t@233@01) ret@204@01))
; [exec]
; label loop5_group3_bb13
; [exec]
; __t13 := true
; [exec]
; label loop5_group3_bb22
; [exec]
; __t14 := true
; [exec]
; label loop5_group4_bb5
; [exec]
; __t3 := true
; [exec]
; _7 := builtin$havoc_ref()
(declare-const ret@265@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_7.val_bool, write)
(declare-const $t@266@01 Bool)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@204@01 ret@265@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@206@01 ret@265@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@265@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _7.val_bool := _6.val_bool
(declare-const val_bool@267@01 Bool)
(assert (= val_bool@267@01 ($SortWrappers.$SnapToBool ($Snap.first $t@233@01))))
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@204@01 ret@265@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@206@01 ret@265@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l19
; [exec]
; __t19 := _7.val_bool
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not val_bool@267@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not val_bool@267@01))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 43 | val_bool@267@01 | live]
; [else-branch: 43 | !(val_bool@267@01) | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 43 | val_bool@267@01]
(assert val_bool@267@01)
; [exec]
; label l21
; [exec]
; label loop5_end_body
; [exec]
; fold acc(bool(_6), write)
; [exec]
; exhale acc(bool(_6), write) &&
;   acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write)
; [exec]
; inhale false
(pop) ; 7
(push) ; 7
; [else-branch: 43 | !(val_bool@267@01)]
(assert (not val_bool@267@01))
(pop) ; 7
; [eval] !__t19
(push) ; 7
(set-option :timeout 10)
(assert (not val_bool@267@01))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (not val_bool@267@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 44 | !(val_bool@267@01) | live]
; [else-branch: 44 | val_bool@267@01 | live]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 44 | !(val_bool@267@01)]
(assert (not val_bool@267@01))
; [exec]
; label l20
; [exec]
; label l23
; [exec]
; label bb6
; [exec]
; __t15 := true
; [exec]
; _0 := builtin$havoc_ref()
(declare-const ret@268@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_0), write)
(declare-const $t@269@01 $Snap)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@263@01 ret@268@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb23
; [exec]
; __t16 := true
; [exec]
; label return
; [exec]
; fold acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@257@01 ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@186@01))))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (=
  val_ref@251@01
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@186@01))))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.combine
  ($Snap.first ($Snap.second $t@186@01))
  $t@199@01) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@186@01))))
; [exec]
; _old$pre$0 := _1.val_ref
(declare-const _old$pre$0@270@01 $Ref)
(assert (= _old$pre$0@270@01 ($SortWrappers.$SnapTo$Ref ($Snap.first $t@186@01))))
; [exec]
; assert true
; [exec]
; exhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_old$pre$0), write)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@186@01)) _old$pre$0@270@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(tuple0$(_0), write)
; [exec]
; label end_of_method
(pop) ; 7
(set-option :timeout 0)
(push) ; 7
; [else-branch: 44 | val_bool@267@01]
(assert val_bool@267@01)
(pop) ; 7
(pop) ; 6
(pop) ; 5
; [eval] !__t4
; [then-branch: 45 | False | dead]
; [else-branch: 45 | True | live]
(push) ; 5
; [else-branch: 45 | True]
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 38 | _12@245@01 != 1]
(assert (not (= _12@245@01 1)))
(pop) ; 4
; [eval] !(__t18 == 1)
; [eval] __t18 == 1
(push) ; 4
(set-option :timeout 10)
(assert (not (= _12@245@01 1)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not (= _12@245@01 1))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 46 | _12@245@01 != 1 | live]
; [else-branch: 46 | _12@245@01 == 1 | live]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 46 | _12@245@01 != 1]
(assert (not (= _12@245@01 1)))
; [exec]
; label l9
; [exec]
; label loop5_group3_bb10
; [exec]
; __t6 := true
(push) ; 5
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 47 | True | live]
; [else-branch: 47 | False | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 47 | True]
; [exec]
; exhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_10.val_ref), read$())
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (<=
  $Perm.No
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))))
(set-option :timeout 0)
(push) ; 6
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_2), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(declare-const $t@271@01 $Snap)
(declare-const $t@272@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@272@01 $t@242@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@272@01 $t@271@01))))
(assert (<=
  $Perm.No
  (+
    (-
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    (- $Perm.Write (read$ $Snap.unit)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label loop5_group3_bb8
; [exec]
; __t7 := true
; [exec]
; unfold acc(bool(_6), write)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ret@206@01 ret@204@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (bool%trigger ($Snap.first $t@233@01) ret@204@01))
; [exec]
; _6.val_bool := false
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ret@206@01 ret@204@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [exec]
; _8 := builtin$havoc_ref()
(declare-const ret@273@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_8), write)
(declare-const $t@274@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label loop5_group3_bb13
; [exec]
; __t13 := true
; [exec]
; label loop5_group3_bb22
; [exec]
; __t14 := true
; [exec]
; label loop5_group4_bb5
; [exec]
; __t3 := true
; [exec]
; _7 := builtin$havoc_ref()
(declare-const ret@275@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_7.val_bool, write)
(declare-const $t@276@01 Bool)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ret@204@01 ret@275@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ret@206@01 ret@275@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@275@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _7.val_bool := _6.val_bool
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ret@204@01 ret@275@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (= ret@206@01 ret@275@01)))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l19
; [exec]
; __t19 := _7.val_bool
; [then-branch: 48 | False | dead]
; [else-branch: 48 | True | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 48 | True]
(pop) ; 6
; [eval] !__t19
(push) ; 6
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 49 | True | live]
; [else-branch: 49 | False | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 49 | True]
; [exec]
; label l20
; [exec]
; label l23
; [exec]
; label bb6
; [exec]
; __t15 := true
; [exec]
; _0 := builtin$havoc_ref()
(declare-const ret@277@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_0), write)
(declare-const $t@278@01 $Snap)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@273@01 ret@277@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb23
; [exec]
; __t16 := true
; [exec]
; label return
; [exec]
; fold acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1.val_ref), write)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ret@223@01 ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second $t@186@01))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.combine
  ($Snap.first ($Snap.second $t@186@01))
  $t@199@01) ($SortWrappers.$SnapTo$Ref ($Snap.first $t@186@01))))
; [exec]
; _old$pre$0 := _1.val_ref
(declare-const _old$pre$0@279@01 $Ref)
(assert (= _old$pre$0@279@01 ($SortWrappers.$SnapTo$Ref ($Snap.first $t@186@01))))
; [exec]
; assert true
; [exec]
; exhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_old$pre$0), write)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapTo$Ref ($Snap.first $t@186@01)) _old$pre$0@279@01)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(tuple0$(_0), write)
; [exec]
; label end_of_method
(pop) ; 6
(pop) ; 5
; [eval] !__t4
; [then-branch: 50 | False | dead]
; [else-branch: 50 | True | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 50 | True]
(pop) ; 5
(pop) ; 4
(push) ; 4
; [else-branch: 46 | _12@245@01 == 1]
(assert (= _12@245@01 1))
(pop) ; 4
(pop) ; 3
; [eval] !__t17
; [then-branch: 51 | False | dead]
; [else-branch: 51 | True | live]
(push) ; 3
; [else-branch: 51 | True]
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$new$opensqu$0$closesqu$ ----------
(declare-const _0@280@01 $Ref)
(declare-const _0@281@01 $Ref)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var __t0: Bool
(declare-const __t0@282@01 Bool)
; [exec]
; var __t1: Bool
(declare-const __t1@283@01 Bool)
; [exec]
; var _1: Ref
(declare-const _1@284@01 $Ref)
; [exec]
; label start
; [exec]
; __t0 := false
; [exec]
; __t1 := false
; [exec]
; inhale true
(declare-const $t@285@01 $Snap)
(assert (= $t@285@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@286@01 $Snap)
(assert (= $t@286@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@287@01 $Snap)
(assert (= $t@287@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@288@01 $Snap)
(assert (= $t@288@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; label pre
; [exec]
; label bb0
; [exec]
; __t0 := true
; [exec]
; _1 := builtin$havoc_ref()
(declare-const ret@289@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_(_1), write)
(declare-const $t@290@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_1) ==
;   0
(declare-const $t@291@01 $Snap)
(assert (= $t@291@01 $Snap.unit))
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_1) == 0
; [eval] m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$(_1)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(assert (read$%precondition $Snap.unit))
(pop) ; 4
; Joined path conditions
(assert (read$%precondition $Snap.unit))
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@290@01 ret@289@01))
(pop) ; 3
; Joined path conditions
(assert (and
  (read$%precondition $Snap.unit)
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@290@01 ret@289@01)))
(assert (=
  (m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$Link$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@290@01 ret@289@01)
  0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _0 := builtin$havoc_ref()
(declare-const ret@292@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_0), write)
(declare-const $t@293@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_0), write)
(assert (= $t@293@01 ($Snap.combine ($Snap.first $t@293@01) ($Snap.second $t@293@01))))
(assert (not (= ret@292@01 $Ref.null)))
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (= ret@289@01 ($SortWrappers.$SnapTo$Ref ($Snap.first $t@293@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger $t@293@01 ret@292@01))
; [exec]
; _0.f$head := _1
; [exec]
; label l0
; [exec]
; label bb2
; [exec]
; __t1 := true
; [exec]
; label return
; [exec]
; fold acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_0), write)
(assert (m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_%trigger ($Snap.combine
  ($SortWrappers.$RefTo$Snap ret@289@01)
  $t@290@01) ret@292@01))
; [exec]
; assert m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) ==
;   0
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_0) == 0
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_0)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine ($SortWrappers.$RefTo$Snap ret@289@01) $t@290@01)
  $Snap.unit) ret@292@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  ($Snap.combine ($SortWrappers.$RefTo$Snap ret@289@01) $t@290@01)
  $Snap.unit) ret@292@01))
(set-option :timeout 0)
(push) ; 3
(assert (not (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.combine ($SortWrappers.$RefTo$Snap ret@289@01) $t@290@01)
    $Snap.unit) ret@292@01)
  0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    ($Snap.combine ($SortWrappers.$RefTo$Snap ret@289@01) $t@290@01)
    $Snap.unit) ret@292@01)
  0))
; [exec]
; assert true
; [exec]
; exhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_0), write)
; [exec]
; label end_of_method
(pop) ; 2
(pop) ; 1
; ---------- m_first_final$$test$opensqu$0$closesqu$$$basics$opensqu$0$closesqu$ ----------
(declare-const _0@294@01 $Ref)
(declare-const _0@295@01 $Ref)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var __t0: Bool
(declare-const __t0@296@01 Bool)
; [exec]
; var __t1: Bool
(declare-const __t1@297@01 Bool)
; [exec]
; var __t2: Bool
(declare-const __t2@298@01 Bool)
; [exec]
; var __t3: Bool
(declare-const __t3@299@01 Bool)
; [exec]
; var __t4: Bool
(declare-const __t4@300@01 Bool)
; [exec]
; var __t5: Bool
(declare-const __t5@301@01 Bool)
; [exec]
; var __t6: Bool
(declare-const __t6@302@01 Bool)
; [exec]
; var __t7: Bool
(declare-const __t7@303@01 Bool)
; [exec]
; var __t8: Bool
(declare-const __t8@304@01 Bool)
; [exec]
; var __t9: Bool
(declare-const __t9@305@01 Bool)
; [exec]
; var __t10: Bool
(declare-const __t10@306@01 Bool)
; [exec]
; var __t11: Bool
(declare-const __t11@307@01 Bool)
; [exec]
; var __t12: Bool
(declare-const __t12@308@01 Bool)
; [exec]
; var __t13: Bool
(declare-const __t13@309@01 Bool)
; [exec]
; var __t14: Bool
(declare-const __t14@310@01 Bool)
; [exec]
; var __t15: Bool
(declare-const __t15@311@01 Bool)
; [exec]
; var __t16: Bool
(declare-const __t16@312@01 Bool)
; [exec]
; var __t17: Bool
(declare-const __t17@313@01 Bool)
; [exec]
; var __t18: Bool
(declare-const __t18@314@01 Bool)
; [exec]
; var __t19: Bool
(declare-const __t19@315@01 Bool)
; [exec]
; var __t20: Bool
(declare-const __t20@316@01 Bool)
; [exec]
; var __t21: Bool
(declare-const __t21@317@01 Bool)
; [exec]
; var __t22: Bool
(declare-const __t22@318@01 Bool)
; [exec]
; var __t23: Bool
(declare-const __t23@319@01 Bool)
; [exec]
; var __t24: Bool
(declare-const __t24@320@01 Bool)
; [exec]
; var __t25: Bool
(declare-const __t25@321@01 Bool)
; [exec]
; var __t26: Bool
(declare-const __t26@322@01 Bool)
; [exec]
; var __t27: Bool
(declare-const __t27@323@01 Bool)
; [exec]
; var __t28: Bool
(declare-const __t28@324@01 Bool)
; [exec]
; var __t29: Bool
(declare-const __t29@325@01 Bool)
; [exec]
; var __t30: Bool
(declare-const __t30@326@01 Bool)
; [exec]
; var __t31: Bool
(declare-const __t31@327@01 Bool)
; [exec]
; var __t32: Bool
(declare-const __t32@328@01 Bool)
; [exec]
; var __t33: Bool
(declare-const __t33@329@01 Bool)
; [exec]
; var __t34: Bool
(declare-const __t34@330@01 Bool)
; [exec]
; var __t35: Bool
(declare-const __t35@331@01 Bool)
; [exec]
; var __t36: Bool
(declare-const __t36@332@01 Bool)
; [exec]
; var __t37: Bool
(declare-const __t37@333@01 Bool)
; [exec]
; var __t38: Bool
(declare-const __t38@334@01 Bool)
; [exec]
; var __t39: Bool
(declare-const __t39@335@01 Bool)
; [exec]
; var __t40: Bool
(declare-const __t40@336@01 Bool)
; [exec]
; var __t41: Bool
(declare-const __t41@337@01 Bool)
; [exec]
; var __t42: Bool
(declare-const __t42@338@01 Bool)
; [exec]
; var __t43: Bool
(declare-const __t43@339@01 Bool)
; [exec]
; var __t44: Bool
(declare-const __t44@340@01 Bool)
; [exec]
; var __t45: Bool
(declare-const __t45@341@01 Bool)
; [exec]
; var __t46: Bool
(declare-const __t46@342@01 Bool)
; [exec]
; var __t47: Bool
(declare-const __t47@343@01 Bool)
; [exec]
; var __t48: Bool
(declare-const __t48@344@01 Bool)
; [exec]
; var __t49: Bool
(declare-const __t49@345@01 Bool)
; [exec]
; var __t50: Bool
(declare-const __t50@346@01 Bool)
; [exec]
; var __t51: Bool
(declare-const __t51@347@01 Bool)
; [exec]
; var __t52: Int
(declare-const __t52@348@01 Int)
; [exec]
; var __t53: Bool
(declare-const __t53@349@01 Bool)
; [exec]
; var __t54: Int
(declare-const __t54@350@01 Int)
; [exec]
; var __t55: Bool
(declare-const __t55@351@01 Bool)
; [exec]
; var __t56: Int
(declare-const __t56@352@01 Int)
; [exec]
; var __t57: Bool
(declare-const __t57@353@01 Bool)
; [exec]
; var __t58: Int
(declare-const __t58@354@01 Int)
; [exec]
; var __t59: Bool
(declare-const __t59@355@01 Bool)
; [exec]
; var __t60: Int
(declare-const __t60@356@01 Int)
; [exec]
; var __t61: Bool
(declare-const __t61@357@01 Bool)
; [exec]
; var __t62: Bool
(declare-const __t62@358@01 Bool)
; [exec]
; var _1: Ref
(declare-const _1@359@01 $Ref)
; [exec]
; var _2: Ref
(declare-const _2@360@01 $Ref)
; [exec]
; var _3: Ref
(declare-const _3@361@01 $Ref)
; [exec]
; var _4: Ref
(declare-const _4@362@01 $Ref)
; [exec]
; var _5: Ref
(declare-const _5@363@01 $Ref)
; [exec]
; var _6: Ref
(declare-const _6@364@01 $Ref)
; [exec]
; var _7: Ref
(declare-const _7@365@01 $Ref)
; [exec]
; var _12: Ref
(declare-const _12@366@01 $Ref)
; [exec]
; var _13: Ref
(declare-const _13@367@01 $Ref)
; [exec]
; var _14: Ref
(declare-const _14@368@01 $Ref)
; [exec]
; var _15: Ref
(declare-const _15@369@01 $Ref)
; [exec]
; var _16: Ref
(declare-const _16@370@01 $Ref)
; [exec]
; var _17: Ref
(declare-const _17@371@01 $Ref)
; [exec]
; var _18: Ref
(declare-const _18@372@01 $Ref)
; [exec]
; var _19: Ref
(declare-const _19@373@01 $Ref)
; [exec]
; var _20: Ref
(declare-const _20@374@01 $Ref)
; [exec]
; var _21: Int
(declare-const _21@375@01 Int)
; [exec]
; var _22: Ref
(declare-const _22@376@01 $Ref)
; [exec]
; var _23: Int
(declare-const _23@377@01 Int)
; [exec]
; var _24: Int
(declare-const _24@378@01 Int)
; [exec]
; var _25: Ref
(declare-const _25@379@01 $Ref)
; [exec]
; var _26: Ref
(declare-const _26@380@01 $Ref)
; [exec]
; var _27: Int
(declare-const _27@381@01 Int)
; [exec]
; var _36: Ref
(declare-const _36@382@01 $Ref)
; [exec]
; var _37: Ref
(declare-const _37@383@01 $Ref)
; [exec]
; var _38: Ref
(declare-const _38@384@01 $Ref)
; [exec]
; var _39: Int
(declare-const _39@385@01 Int)
; [exec]
; var _40: Ref
(declare-const _40@386@01 $Ref)
; [exec]
; var _41: Int
(declare-const _41@387@01 Int)
; [exec]
; var _42: Int
(declare-const _42@388@01 Int)
; [exec]
; var _43: Ref
(declare-const _43@389@01 $Ref)
; [exec]
; var _44: Ref
(declare-const _44@390@01 $Ref)
; [exec]
; var _45: Int
(declare-const _45@391@01 Int)
; [exec]
; var _54: Ref
(declare-const _54@392@01 $Ref)
; [exec]
; var _55: Ref
(declare-const _55@393@01 $Ref)
; [exec]
; var _56: Ref
(declare-const _56@394@01 $Ref)
; [exec]
; var _57: Ref
(declare-const _57@395@01 $Ref)
; [exec]
; var _58: Ref
(declare-const _58@396@01 $Ref)
; [exec]
; var _59: Ref
(declare-const _59@397@01 $Ref)
; [exec]
; var _60: Ref
(declare-const _60@398@01 $Ref)
; [exec]
; var _61: Int
(declare-const _61@399@01 Int)
; [exec]
; var _62: Ref
(declare-const _62@400@01 $Ref)
; [exec]
; var _63: Int
(declare-const _63@401@01 Int)
; [exec]
; var _64: Int
(declare-const _64@402@01 Int)
; [exec]
; var _65: Ref
(declare-const _65@403@01 $Ref)
; [exec]
; var _66: Ref
(declare-const _66@404@01 $Ref)
; [exec]
; var _67: Int
(declare-const _67@405@01 Int)
; [exec]
; var _76: Ref
(declare-const _76@406@01 $Ref)
; [exec]
; var _77: Ref
(declare-const _77@407@01 $Ref)
; [exec]
; var _78: Ref
(declare-const _78@408@01 $Ref)
; [exec]
; var _79: Int
(declare-const _79@409@01 Int)
; [exec]
; var _80: Ref
(declare-const _80@410@01 $Ref)
; [exec]
; var _81: Int
(declare-const _81@411@01 Int)
; [exec]
; var _82: Int
(declare-const _82@412@01 Int)
; [exec]
; var _83: Ref
(declare-const _83@413@01 $Ref)
; [exec]
; var _84: Ref
(declare-const _84@414@01 $Ref)
; [exec]
; var _85: Int
(declare-const _85@415@01 Int)
; [exec]
; var _94: Ref
(declare-const _94@416@01 $Ref)
; [exec]
; var _95: Ref
(declare-const _95@417@01 $Ref)
; [exec]
; var _96: Ref
(declare-const _96@418@01 $Ref)
; [exec]
; var _97: Int
(declare-const _97@419@01 Int)
; [exec]
; var _98: Ref
(declare-const _98@420@01 $Ref)
; [exec]
; var _99: Int
(declare-const _99@421@01 Int)
; [exec]
; var _100: Int
(declare-const _100@422@01 Int)
; [exec]
; var _101: Ref
(declare-const _101@423@01 $Ref)
; [exec]
; var _102: Ref
(declare-const _102@424@01 $Ref)
; [exec]
; var _103: Int
(declare-const _103@425@01 Int)
; [exec]
; var _112: Ref
(declare-const _112@426@01 $Ref)
; [exec]
; var _113: Ref
(declare-const _113@427@01 $Ref)
; [exec]
; var _114: Ref
(declare-const _114@428@01 $Ref)
; [exec]
; var _115: Ref
(declare-const _115@429@01 $Ref)
; [exec]
; var _116: Ref
(declare-const _116@430@01 $Ref)
; [exec]
; var _117: Ref
(declare-const _117@431@01 $Ref)
; [exec]
; var _t138: Ref
(declare-const _t138@432@01 $Ref)
; [exec]
; var _t141: Ref
(declare-const _t141@433@01 $Ref)
; [exec]
; var _t144: Ref
(declare-const _t144@434@01 $Ref)
; [exec]
; var _t151: Ref
(declare-const _t151@435@01 $Ref)
; [exec]
; var _t154: Ref
(declare-const _t154@436@01 $Ref)
; [exec]
; label start
; [exec]
; __t0 := false
; [exec]
; __t1 := false
; [exec]
; __t2 := false
; [exec]
; __t3 := false
; [exec]
; __t4 := false
; [exec]
; __t5 := false
; [exec]
; __t6 := false
; [exec]
; __t7 := false
; [exec]
; __t8 := false
; [exec]
; __t9 := false
; [exec]
; __t10 := false
; [exec]
; __t11 := false
; [exec]
; __t12 := false
; [exec]
; __t13 := false
; [exec]
; __t14 := false
; [exec]
; __t15 := false
; [exec]
; __t16 := false
; [exec]
; __t17 := false
; [exec]
; __t18 := false
; [exec]
; __t19 := false
; [exec]
; __t20 := false
; [exec]
; __t21 := false
; [exec]
; __t22 := false
; [exec]
; __t23 := false
; [exec]
; __t24 := false
; [exec]
; __t25 := false
; [exec]
; __t26 := false
; [exec]
; __t27 := false
; [exec]
; __t28 := false
; [exec]
; __t29 := false
; [exec]
; __t30 := false
; [exec]
; __t31 := false
; [exec]
; __t32 := false
; [exec]
; __t33 := false
; [exec]
; __t34 := false
; [exec]
; __t35 := false
; [exec]
; __t36 := false
; [exec]
; __t37 := false
; [exec]
; __t38 := false
; [exec]
; __t39 := false
; [exec]
; __t40 := false
; [exec]
; __t41 := false
; [exec]
; __t42 := false
; [exec]
; __t43 := false
; [exec]
; __t44 := false
; [exec]
; __t45 := false
; [exec]
; __t46 := false
; [exec]
; __t47 := false
; [exec]
; __t48 := false
; [exec]
; __t49 := false
; [exec]
; __t50 := false
; [exec]
; inhale true
(declare-const $t@437@01 $Snap)
(assert (= $t@437@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@438@01 $Snap)
(assert (= $t@438@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@439@01 $Snap)
(assert (= $t@439@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@440@01 $Snap)
(assert (= $t@440@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; label pre
; [exec]
; label bb0
; [exec]
; __t0 := true
; [exec]
; label l0
; [exec]
; _1 := builtin$havoc_ref()
(declare-const ret@441@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@442@01 $Snap)
(assert (= $t@442@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_1), write)
(declare-const $t@443@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@444@01 $Snap)
(assert (= $t@444@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1) ==
;   0
(declare-const $t@445@01 $Snap)
(assert (= $t@445@01 $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1) == 0
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_1)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(assert (read$%precondition $Snap.unit))
(pop) ; 4
; Joined path conditions
(assert (read$%precondition $Snap.unit))
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@443@01
  $Snap.unit) ret@441@01))
(pop) ; 3
; Joined path conditions
(assert (and
  (read$%precondition $Snap.unit)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@443@01
    $Snap.unit) ret@441@01)))
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@443@01
    $Snap.unit) ret@441@01)
  0))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l1
; [exec]
; label bb2
; [exec]
; __t1 := true
; [exec]
; _7 := builtin$havoc_ref()
(declare-const ret@446@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_7.val_ref, write)
(declare-const $t@447@01 $Ref)
(assert (not (= ret@446@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _7.val_ref := _1
; [exec]
; label l2
; [exec]
; label l3
; [exec]
; assert true
; [exec]
; exhale acc(_7.val_ref, write) &&
;   acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_7.val_ref), write)
; [exec]
; _6 := builtin$havoc_ref()
(declare-const ret@448@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l3](_7.val_ref)), write)
; [eval] old[l3](_7.val_ref)
(declare-const $t@449@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_6), write)
(declare-const $t@450@01 $Snap)
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@451@01 $Snap)
(assert (= $t@451@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_6)) &&
;   ((old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l3](_7.val_ref)) ==
;   0) &&
;   ((old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_6)) &&
;   ((old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_6) ==
;   old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_7.val_ref,
;   0))) &&
;   ((old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l3](_7.val_ref)) ==
;   old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref) -
;   1)) &&
;   (old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) >
;   0 ==>
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l3](_7.val_ref),
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l3](_7.val_ref)) ==>
;     old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_7.val_ref,
;     i + 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l3](_7.val_ref),
;     i)))))))
(declare-const $t@452@01 $Snap)
(assert (= $t@452@01 ($Snap.combine ($Snap.first $t@452@01) ($Snap.second $t@452@01))))
(assert (= ($Snap.first $t@452@01) $Snap.unit))
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_6)
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) == 0
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(pop) ; 3
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@443@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 52 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) == 0 | live]
; [else-branch: 52 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 52 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) == 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_6)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@450@01
  $Snap.unit) ret@448@01))
(pop) ; 5
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@450@01
  $Snap.unit) ret@448@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@443@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
    $t@450@01
    $Snap.unit) ret@448@01)))
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@443@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@450@01
    $Snap.unit) ret@448@01)))
(assert (=
  ($Snap.second $t@452@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@452@01))
    ($Snap.second ($Snap.second $t@452@01)))))
(assert (= ($Snap.first ($Snap.second $t@452@01)) $Snap.unit))
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l3](_7.val_ref)) == 0
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) == 0
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(pop) ; 3
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@443@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 53 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) == 0 | live]
; [else-branch: 53 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 53 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) == 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l3](_7.val_ref)) == 0
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l3](_7.val_ref))
; [eval] old[l3](_7.val_ref)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@449@01
  $Snap.unit) ret@441@01))
(pop) ; 5
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@449@01
  $Snap.unit) ret@441@01))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@443@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@449@01
    $Snap.unit) ret@441@01)))
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@443@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@449@01
      $Snap.unit) ret@441@01)
    0)))
(assert (=
  ($Snap.second ($Snap.second $t@452@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@452@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@452@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@452@01))) $Snap.unit))
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_6)
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) > 0
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(pop) ; 3
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@443@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 54 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0 | dead]
; [else-branch: 54 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0) | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 54 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0)]
(assert (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@443@01
      $Snap.unit) ret@441@01)
    0)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@443@01
      $Snap.unit) ret@441@01)
    0)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@452@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@452@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@452@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@452@01))))
  $Snap.unit))
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_6) == old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_7.val_ref, 0))
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) > 0
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(pop) ; 3
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
; [then-branch: 55 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0 | dead]
; [else-branch: 55 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0) | live]
(push) ; 4
; [else-branch: 55 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0)]
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@452@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@452@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@452@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@452@01)))))
  $Snap.unit))
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l3](_7.val_ref)) == old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref) - 1)
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) > 0
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(pop) ; 3
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
; [then-branch: 56 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0 | dead]
; [else-branch: 56 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0) | live]
(push) ; 4
; [else-branch: 56 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0)]
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@452@01)))))
  $Snap.unit))
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) > 0 ==> (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l3](_7.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l3](_7.val_ref)) ==> old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_7.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l3](_7.val_ref), i))
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)) > 0
; [eval] old[l3](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_7.val_ref)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(pop) ; 3
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
; [then-branch: 57 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0 | dead]
; [else-branch: 57 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0) | live]
(push) ; 4
; [else-branch: 57 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@443@01, _), ret@441@01) > 0)]
(pop) ; 4
(pop) ; 3
; Joined path conditions
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l4
; [exec]
; label l5
; [exec]
; label bb3
; [exec]
; __t2 := true
; [exec]
; _5 := builtin$havoc_ref()
(declare-const ret@453@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_5.val_ref, write)
(declare-const $t@454@01 $Ref)
(assert (not (= ret@453@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _5.val_ref := _6
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_6), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(set-option :timeout 0)
(push) ; 3
(pop) ; 3
; Joined path conditions
(push) ; 3
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(push) ; 3
(set-option :timeout 10)
(assert (not (=
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (<=
  $Perm.No
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))))
(set-option :timeout 0)
(push) ; 3
(assert (not (or
  (=
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No)
  (<
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_5.val_ref), read$())
; [eval] read$()
(push) ; 3
(pop) ; 3
; Joined path conditions
(push) ; 3
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(declare-const $t@455@01 $Snap)
(declare-const $t@456@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit)))))
    (= $t@456@01 $t@450@01))
  (=> (< $Perm.No (read$ $Snap.unit)) (= $t@456@01 $t@455@01))))
(assert (<=
  $Perm.No
  (+
    (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    (read$ $Snap.unit))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l6
; [exec]
; label l7
; [exec]
; _4 := builtin$havoc_ref()
(declare-const ret@457@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(bool(_4), write)
(declare-const $t@458@01 Bool)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(bool(_4), write)
(assert (not (= ret@457@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (bool%trigger ($SortWrappers.BoolTo$Snap $t@458@01) ret@457@01))
; [exec]
; inhale _4.val_bool ==
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_5.val_ref)
(declare-const $t@459@01 $Snap)
(assert (= $t@459@01 $Snap.unit))
; [eval] _4.val_bool == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_5.val_ref)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_5.val_ref)
(set-option :timeout 0)
(push) ; 3
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@456@01
  $Snap.unit) ret@448@01))
(pop) ; 3
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@456@01
  $Snap.unit) ret@448@01))
(assert (=
  $t@458@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@456@01
    $Snap.unit) ret@448@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l8
; [eval] __t2 && __t2
(set-option :timeout 0)
(push) ; 3
; [then-branch: 58 | False | live]
; [else-branch: 58 | True | live]
(push) ; 4
; [then-branch: 58 | False]
(assert false)
(pop) ; 4
(push) ; 4
; [else-branch: 58 | True]
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [then-branch: 59 | True | live]
; [else-branch: 59 | False | dead]
(set-option :timeout 0)
(push) ; 3
; [then-branch: 59 | True]
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(old[l6](_5.val_ref)), read$())
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
; [eval] old[l6](_5.val_ref)
(push) ; 4
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(push) ; 4
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (<=
  $Perm.No
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))))
(set-option :timeout 0)
(push) ; 4
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_6), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 4
(pop) ; 4
; Joined path conditions
(push) ; 4
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const $t@460@01 $Snap)
(declare-const $t@461@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@461@01 $t@456@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@461@01 $t@460@01))))
(assert (<=
  $Perm.No
  (+
    (-
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    (- $Perm.Write (read$ $Snap.unit)))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb7
; [exec]
; __t3 := true
; [exec]
; _3 := builtin$havoc_ref()
(declare-const ret@462@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_3.val_bool, write)
(declare-const $t@463@01 Bool)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@462@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@462@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _3.val_bool := !_4.val_bool
; [eval] !_4.val_bool
(declare-const val_bool@464@01 Bool)
(assert (= val_bool@464@01 (not $t@458@01)))
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@462@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [exec]
; __t51 := _3.val_bool
; [eval] !__t51
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not val_bool@464@01))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(set-option :timeout 10)
(assert (not (not val_bool@464@01)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 60 | !(val_bool@464@01) | live]
; [else-branch: 60 | val_bool@464@01 | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 60 | !(val_bool@464@01)]
(assert (not val_bool@464@01))
; [exec]
; label l10
; [exec]
; label bb9
; [exec]
; __t5 := true
; [exec]
; _2 := builtin$havoc_ref()
(declare-const ret@465@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_2), write)
(declare-const $t@466@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _13 := builtin$havoc_ref()
(declare-const ret@467@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_13.val_ref, write)
(declare-const $t@468@01 $Ref)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@467@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@467@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _13.val_ref := _1
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@467@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l11
; [exec]
; label l12
; [exec]
; _t138 := builtin$havoc_ref()
(declare-const ret@469@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(i32(_t138), write)
(declare-const $t@470@01 Int)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert true
; [exec]
; exhale acc(_13.val_ref, write) &&
;   (acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_13.val_ref), write) &&
;   acc(i32(_t138), write))
; [exec]
; _12 := builtin$havoc_ref()
(declare-const ret@471@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l12](_13.val_ref)), write)
; [eval] old[l12](_13.val_ref)
(declare-const $t@472@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_12), write)
(declare-const $t@473@01 $Snap)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@471@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@474@01 $Snap)
(assert (= $t@474@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l12](_13.val_ref)) ==
;   old[l12](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_13.val_ref)) +
;   1 &&
;   (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l12](_13.val_ref),
;   0) ==
;   old[l12](1) &&
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l12](_13.val_ref),
;     i) }
;     1 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l12](_13.val_ref)) ==>
;     old[l12](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13.val_ref,
;     i - 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l12](_13.val_ref),
;     i)))
(declare-const $t@475@01 $Snap)
(assert (= $t@475@01 ($Snap.combine ($Snap.first $t@475@01) ($Snap.second $t@475@01))))
(assert (= ($Snap.first $t@475@01) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l12](_13.val_ref)) == old[l12](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_13.val_ref)) + 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l12](_13.val_ref))
; [eval] old[l12](_13.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@472@01
  $Snap.unit) ret@441@01))
(pop) ; 5
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@472@01
  $Snap.unit) ret@441@01))
; [eval] old[l12](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_13.val_ref)) + 1
; [eval] old[l12](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_13.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_13.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@449@01
  $Snap.unit) ret@441@01))
(pop) ; 5
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@449@01
  $Snap.unit) ret@441@01))
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@472@01
    $Snap.unit) ret@441@01)
  (+
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@449@01
      $Snap.unit) ret@441@01)
    1)))
(assert (=
  ($Snap.second $t@475@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@475@01))
    ($Snap.second ($Snap.second $t@475@01)))))
(assert (= ($Snap.first ($Snap.second $t@475@01)) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l12](_13.val_ref), 0) == old[l12](1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l12](_13.val_ref), 0)
; [eval] old[l12](_13.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(pop) ; 6
; Joined path conditions
(set-option :timeout 0)
(push) ; 6
(assert (not (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@472@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@472@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@472@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))
(pop) ; 5
; Joined path conditions
(assert (and
  (<
    0
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@472@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@472@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)))
; [eval] old[l12](1)
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
    $t@472@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)
  1))
(assert (= ($Snap.second ($Snap.second $t@475@01)) $Snap.unit))
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l12](_13.val_ref), i) } 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l12](_13.val_ref)) ==> old[l12](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l12](_13.val_ref), i))
(declare-const i@476@01 Int)
(push) ; 5
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l12](_13.val_ref)) ==> old[l12](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l12](_13.val_ref), i)
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l12](_13.val_ref))
; [eval] 1 <= i
(push) ; 6
; [then-branch: 61 | !(1 <= i@476@01) | live]
; [else-branch: 61 | 1 <= i@476@01 | live]
(push) ; 7
; [then-branch: 61 | !(1 <= i@476@01)]
(assert (not (<= 1 i@476@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 61 | 1 <= i@476@01]
(assert (<= 1 i@476@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l12](_13.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l12](_13.val_ref))
; [eval] old[l12](_13.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (<= 1 i@476@01) (not (<= 1 i@476@01))))
(set-option :timeout 0)
(push) ; 6
; [then-branch: 62 | 1 <= i@476@01 && i@476@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@472@01, _), ret@441@01) | live]
; [else-branch: 62 | !(1 <= i@476@01 && i@476@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@472@01, _), ret@441@01)) | live]
(push) ; 7
; [then-branch: 62 | 1 <= i@476@01 && i@476@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@472@01, _), ret@441@01)]
(assert (and
  (<= 1 i@476@01)
  (<
    i@476@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@472@01
      $Snap.unit) ret@441@01))))
; [eval] old[l12](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l12](_13.val_ref), i)
; [eval] old[l12](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13.val_ref, i - 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_13.val_ref, i - 1)
; [eval] i - 1
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 9
(assert (not (<= 0 (- i@476@01 1))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (- i@476@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
(set-option :timeout 0)
(push) ; 9
(assert (not (<
  (- i@476@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@449@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (<
  (- i@476@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@449@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@449@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
  i@476@01
  1)))
(pop) ; 8
; Joined path conditions
(assert (and
  (<= 0 (- i@476@01 1))
  (<
    (- i@476@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@449@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@449@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
    i@476@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l12](_13.val_ref), i)
; [eval] old[l12](_13.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 9
(assert (not (<= 0 i@476@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 i@476@01))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@472@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@476@01))
(pop) ; 8
; Joined path conditions
(assert (and
  (<= 0 i@476@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@472@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@476@01)))
(pop) ; 7
(set-option :timeout 0)
(push) ; 7
; [else-branch: 62 | !(1 <= i@476@01 && i@476@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@472@01, _), ret@441@01))]
(assert (not
  (and
    (<= 1 i@476@01)
    (<
      i@476@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@472@01
        $Snap.unit) ret@441@01)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and
    (<= 1 i@476@01)
    (<
      i@476@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@472@01
        $Snap.unit) ret@441@01)))
  (and
    (<= 1 i@476@01)
    (<
      i@476@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@472@01
        $Snap.unit) ret@441@01))
    (<= 0 (- i@476@01 1))
    (<
      (- i@476@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@449@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@449@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
      i@476@01
      1))
    (<= 0 i@476@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@472@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@476@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 1 i@476@01)
      (<
        i@476@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@472@01
          $Snap.unit) ret@441@01))))
  (and
    (<= 1 i@476@01)
    (<
      i@476@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@472@01
        $Snap.unit) ret@441@01)))))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@476@01 Int)) (!
  (and
    (or (<= 1 i@476@01) (not (<= 1 i@476@01)))
    (=>
      (and
        (<= 1 i@476@01)
        (<
          i@476@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@472@01
            $Snap.unit) ret@441@01)))
      (and
        (<= 1 i@476@01)
        (<
          i@476@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@472@01
            $Snap.unit) ret@441@01))
        (<= 0 (- i@476@01 1))
        (<
          (- i@476@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@449@01
            $Snap.unit) ret@441@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@449@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
          i@476@01
          1))
        (<= 0 i@476@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@472@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@476@01)))
    (or
      (not
        (and
          (<= 1 i@476@01)
          (<
            i@476@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@472@01
              $Snap.unit) ret@441@01))))
      (and
        (<= 1 i@476@01)
        (<
          i@476@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@472@01
            $Snap.unit) ret@441@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@472@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@476@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@3228@625@3228@1263-aux|)))
(assert (forall ((i@476@01 Int)) (!
  (=>
    (and
      (<= 1 i@476@01)
      (<
        i@476@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@472@01
          $Snap.unit) ret@441@01)))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@449@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
        i@476@01
        1))
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@472@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@476@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@472@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@476@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@3228@625@3228@1263|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l13
; [exec]
; label l14
; [exec]
; label bb11
; [exec]
; __t6 := true
; [exec]
; _15 := builtin$havoc_ref()
(declare-const ret@477@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_15.val_ref, write)
(declare-const $t@478@01 $Ref)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@477@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@477@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _15.val_ref := _1
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@477@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l15
; [exec]
; label l16
; [exec]
; _t141 := builtin$havoc_ref()
(declare-const ret@479@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(i32(_t141), write)
(declare-const $t@480@01 Int)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert true
; [exec]
; exhale acc(_15.val_ref, write) &&
;   (acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_15.val_ref), write) &&
;   acc(i32(_t141), write))
; [exec]
; _14 := builtin$havoc_ref()
(declare-const ret@481@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l16](_15.val_ref)), write)
; [eval] old[l16](_15.val_ref)
(declare-const $t@482@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_14), write)
(declare-const $t@483@01 $Snap)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@481@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@481@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@484@01 $Snap)
(assert (= $t@484@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l16](_15.val_ref)) ==
;   old[l16](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_15.val_ref)) +
;   1 &&
;   (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l16](_15.val_ref),
;   0) ==
;   old[l16](2) &&
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l16](_15.val_ref),
;     i) }
;     1 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l16](_15.val_ref)) ==>
;     old[l16](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_15.val_ref,
;     i - 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l16](_15.val_ref),
;     i)))
(declare-const $t@485@01 $Snap)
(assert (= $t@485@01 ($Snap.combine ($Snap.first $t@485@01) ($Snap.second $t@485@01))))
(assert (= ($Snap.first $t@485@01) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l16](_15.val_ref)) == old[l16](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_15.val_ref)) + 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l16](_15.val_ref))
; [eval] old[l16](_15.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@482@01
  $Snap.unit) ret@441@01))
(pop) ; 5
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@482@01
  $Snap.unit) ret@441@01))
; [eval] old[l16](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_15.val_ref)) + 1
; [eval] old[l16](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_15.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_15.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@482@01
    $Snap.unit) ret@441@01)
  (+
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@472@01
      $Snap.unit) ret@441@01)
    1)))
(assert (=
  ($Snap.second $t@485@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@485@01))
    ($Snap.second ($Snap.second $t@485@01)))))
(assert (= ($Snap.first ($Snap.second $t@485@01)) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l16](_15.val_ref), 0) == old[l16](2)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l16](_15.val_ref), 0)
; [eval] old[l16](_15.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(pop) ; 6
; Joined path conditions
(set-option :timeout 0)
(push) ; 6
(assert (not (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@482@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@482@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@482@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))
(pop) ; 5
; Joined path conditions
(assert (and
  (<
    0
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@482@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@482@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)))
; [eval] old[l16](2)
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
    $t@482@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)
  2))
(assert (= ($Snap.second ($Snap.second $t@485@01)) $Snap.unit))
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l16](_15.val_ref), i) } 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l16](_15.val_ref)) ==> old[l16](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_15.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l16](_15.val_ref), i))
(declare-const i@486@01 Int)
(push) ; 5
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l16](_15.val_ref)) ==> old[l16](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_15.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l16](_15.val_ref), i)
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l16](_15.val_ref))
; [eval] 1 <= i
(push) ; 6
; [then-branch: 63 | !(1 <= i@486@01) | live]
; [else-branch: 63 | 1 <= i@486@01 | live]
(push) ; 7
; [then-branch: 63 | !(1 <= i@486@01)]
(assert (not (<= 1 i@486@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 63 | 1 <= i@486@01]
(assert (<= 1 i@486@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l16](_15.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l16](_15.val_ref))
; [eval] old[l16](_15.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (<= 1 i@486@01) (not (<= 1 i@486@01))))
(set-option :timeout 0)
(push) ; 6
; [then-branch: 64 | 1 <= i@486@01 && i@486@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@482@01, _), ret@441@01) | live]
; [else-branch: 64 | !(1 <= i@486@01 && i@486@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@482@01, _), ret@441@01)) | live]
(push) ; 7
; [then-branch: 64 | 1 <= i@486@01 && i@486@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@482@01, _), ret@441@01)]
(assert (and
  (<= 1 i@486@01)
  (<
    i@486@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@482@01
      $Snap.unit) ret@441@01))))
; [eval] old[l16](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_15.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l16](_15.val_ref), i)
; [eval] old[l16](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_15.val_ref, i - 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_15.val_ref, i - 1)
; [eval] i - 1
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 9
(assert (not (<= 0 (- i@486@01 1))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (- i@486@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
(set-option :timeout 0)
(push) ; 9
(assert (not (<
  (- i@486@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@472@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (<
  (- i@486@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@472@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@472@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
  i@486@01
  1)))
(pop) ; 8
; Joined path conditions
(assert (and
  (<= 0 (- i@486@01 1))
  (<
    (- i@486@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@472@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@472@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
    i@486@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l16](_15.val_ref), i)
; [eval] old[l16](_15.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 9
(assert (not (<= 0 i@486@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 i@486@01))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@482@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@486@01))
(pop) ; 8
; Joined path conditions
(assert (and
  (<= 0 i@486@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@482@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@486@01)))
(pop) ; 7
(set-option :timeout 0)
(push) ; 7
; [else-branch: 64 | !(1 <= i@486@01 && i@486@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@482@01, _), ret@441@01))]
(assert (not
  (and
    (<= 1 i@486@01)
    (<
      i@486@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@482@01
        $Snap.unit) ret@441@01)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and
    (<= 1 i@486@01)
    (<
      i@486@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@482@01
        $Snap.unit) ret@441@01)))
  (and
    (<= 1 i@486@01)
    (<
      i@486@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@482@01
        $Snap.unit) ret@441@01))
    (<= 0 (- i@486@01 1))
    (<
      (- i@486@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@472@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@472@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
      i@486@01
      1))
    (<= 0 i@486@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@482@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@486@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 1 i@486@01)
      (<
        i@486@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@482@01
          $Snap.unit) ret@441@01))))
  (and
    (<= 1 i@486@01)
    (<
      i@486@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@482@01
        $Snap.unit) ret@441@01)))))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@486@01 Int)) (!
  (and
    (or (<= 1 i@486@01) (not (<= 1 i@486@01)))
    (=>
      (and
        (<= 1 i@486@01)
        (<
          i@486@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@482@01
            $Snap.unit) ret@441@01)))
      (and
        (<= 1 i@486@01)
        (<
          i@486@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@482@01
            $Snap.unit) ret@441@01))
        (<= 0 (- i@486@01 1))
        (<
          (- i@486@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@472@01
            $Snap.unit) ret@441@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@472@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
          i@486@01
          1))
        (<= 0 i@486@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@482@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@486@01)))
    (or
      (not
        (and
          (<= 1 i@486@01)
          (<
            i@486@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@482@01
              $Snap.unit) ret@441@01))))
      (and
        (<= 1 i@486@01)
        (<
          i@486@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@482@01
            $Snap.unit) ret@441@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@482@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@486@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2072@625@2072@1263-aux|)))
(assert (forall ((i@486@01 Int)) (!
  (=>
    (and
      (<= 1 i@486@01)
      (<
        i@486@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@482@01
          $Snap.unit) ret@441@01)))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@472@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
        i@486@01
        1))
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@482@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@486@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@482@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@486@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2072@625@2072@1263|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l17
; [exec]
; label l18
; [exec]
; label bb13
; [exec]
; __t7 := true
; [exec]
; _17 := builtin$havoc_ref()
(declare-const ret@487@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_17.val_ref, write)
(declare-const $t@488@01 $Ref)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@487@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@487@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _17.val_ref := _1
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@487@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l19
; [exec]
; label l20
; [exec]
; _t144 := builtin$havoc_ref()
(declare-const ret@489@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(i32(_t144), write)
(declare-const $t@490@01 Int)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert true
; [exec]
; exhale acc(_17.val_ref, write) &&
;   (acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_17.val_ref), write) &&
;   acc(i32(_t144), write))
; [exec]
; _16 := builtin$havoc_ref()
(declare-const ret@491@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l20](_17.val_ref)), write)
; [eval] old[l20](_17.val_ref)
(declare-const $t@492@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_16), write)
(declare-const $t@493@01 $Snap)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@481@01 ret@491@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@491@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@491@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@494@01 $Snap)
(assert (= $t@494@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l20](_17.val_ref)) ==
;   old[l20](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_17.val_ref)) +
;   1 &&
;   (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l20](_17.val_ref),
;   0) ==
;   old[l20](3) &&
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l20](_17.val_ref),
;     i) }
;     1 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l20](_17.val_ref)) ==>
;     old[l20](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_17.val_ref,
;     i - 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l20](_17.val_ref),
;     i)))
(declare-const $t@495@01 $Snap)
(assert (= $t@495@01 ($Snap.combine ($Snap.first $t@495@01) ($Snap.second $t@495@01))))
(assert (= ($Snap.first $t@495@01) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l20](_17.val_ref)) == old[l20](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_17.val_ref)) + 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l20](_17.val_ref))
; [eval] old[l20](_17.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@492@01
  $Snap.unit) ret@441@01))
(pop) ; 5
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@492@01
  $Snap.unit) ret@441@01))
; [eval] old[l20](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_17.val_ref)) + 1
; [eval] old[l20](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_17.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_17.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@492@01
    $Snap.unit) ret@441@01)
  (+
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@482@01
      $Snap.unit) ret@441@01)
    1)))
(assert (=
  ($Snap.second $t@495@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@495@01))
    ($Snap.second ($Snap.second $t@495@01)))))
(assert (= ($Snap.first ($Snap.second $t@495@01)) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l20](_17.val_ref), 0) == old[l20](3)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l20](_17.val_ref), 0)
; [eval] old[l20](_17.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 6
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(pop) ; 6
; Joined path conditions
(set-option :timeout 0)
(push) ; 6
(assert (not (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@492@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@492@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@492@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))
(pop) ; 5
; Joined path conditions
(assert (and
  (<
    0
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@492@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)))
; [eval] old[l20](3)
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
    $t@492@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)
  3))
(assert (= ($Snap.second ($Snap.second $t@495@01)) $Snap.unit))
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l20](_17.val_ref), i) } 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l20](_17.val_ref)) ==> old[l20](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_17.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l20](_17.val_ref), i))
(declare-const i@496@01 Int)
(push) ; 5
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l20](_17.val_ref)) ==> old[l20](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_17.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l20](_17.val_ref), i)
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l20](_17.val_ref))
; [eval] 1 <= i
(push) ; 6
; [then-branch: 65 | !(1 <= i@496@01) | live]
; [else-branch: 65 | 1 <= i@496@01 | live]
(push) ; 7
; [then-branch: 65 | !(1 <= i@496@01)]
(assert (not (<= 1 i@496@01)))
(pop) ; 7
(push) ; 7
; [else-branch: 65 | 1 <= i@496@01]
(assert (<= 1 i@496@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l20](_17.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l20](_17.val_ref))
; [eval] old[l20](_17.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (or (<= 1 i@496@01) (not (<= 1 i@496@01))))
(set-option :timeout 0)
(push) ; 6
; [then-branch: 66 | 1 <= i@496@01 && i@496@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) | live]
; [else-branch: 66 | !(1 <= i@496@01 && i@496@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01)) | live]
(push) ; 7
; [then-branch: 66 | 1 <= i@496@01 && i@496@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01)]
(assert (and
  (<= 1 i@496@01)
  (<
    i@496@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01))))
; [eval] old[l20](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_17.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l20](_17.val_ref), i)
; [eval] old[l20](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_17.val_ref, i - 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_17.val_ref, i - 1)
; [eval] i - 1
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 9
(assert (not (<= 0 (- i@496@01 1))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (- i@496@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
(set-option :timeout 0)
(push) ; 9
(assert (not (<
  (- i@496@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@482@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (<
  (- i@496@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@482@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@482@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
  i@496@01
  1)))
(pop) ; 8
; Joined path conditions
(assert (and
  (<= 0 (- i@496@01 1))
  (<
    (- i@496@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@482@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@482@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
    i@496@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l20](_17.val_ref), i)
; [eval] old[l20](_17.val_ref)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 9
(assert (not (<= 0 i@496@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 i@496@01))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@492@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@496@01))
(pop) ; 8
; Joined path conditions
(assert (and
  (<= 0 i@496@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@492@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@496@01)))
(pop) ; 7
(set-option :timeout 0)
(push) ; 7
; [else-branch: 66 | !(1 <= i@496@01 && i@496@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01))]
(assert (not
  (and
    (<= 1 i@496@01)
    (<
      i@496@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@492@01
        $Snap.unit) ret@441@01)))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (=>
  (and
    (<= 1 i@496@01)
    (<
      i@496@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@492@01
        $Snap.unit) ret@441@01)))
  (and
    (<= 1 i@496@01)
    (<
      i@496@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@492@01
        $Snap.unit) ret@441@01))
    (<= 0 (- i@496@01 1))
    (<
      (- i@496@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@482@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@482@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
      i@496@01
      1))
    (<= 0 i@496@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@492@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@496@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 1 i@496@01)
      (<
        i@496@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@492@01
          $Snap.unit) ret@441@01))))
  (and
    (<= 1 i@496@01)
    (<
      i@496@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@492@01
        $Snap.unit) ret@441@01)))))
(pop) ; 5
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@496@01 Int)) (!
  (and
    (or (<= 1 i@496@01) (not (<= 1 i@496@01)))
    (=>
      (and
        (<= 1 i@496@01)
        (<
          i@496@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@492@01
            $Snap.unit) ret@441@01)))
      (and
        (<= 1 i@496@01)
        (<
          i@496@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@492@01
            $Snap.unit) ret@441@01))
        (<= 0 (- i@496@01 1))
        (<
          (- i@496@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@482@01
            $Snap.unit) ret@441@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@482@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
          i@496@01
          1))
        (<= 0 i@496@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@492@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@496@01)))
    (or
      (not
        (and
          (<= 1 i@496@01)
          (<
            i@496@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@492@01
              $Snap.unit) ret@441@01))))
      (and
        (<= 1 i@496@01)
        (<
          i@496@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@492@01
            $Snap.unit) ret@441@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@492@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@496@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2102@625@2102@1263-aux|)))
(assert (forall ((i@496@01 Int)) (!
  (=>
    (and
      (<= 1 i@496@01)
      (<
        i@496@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@492@01
          $Snap.unit) ret@441@01)))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@482@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
        i@496@01
        1))
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@492@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@496@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@492@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@496@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2102@625@2102@1263|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l21
; [exec]
; label l22
; [exec]
; label bb15
; [exec]
; __t8 := true
; [exec]
; _20 := builtin$havoc_ref()
(declare-const ret@497@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_20.val_ref, write)
(declare-const $t@498@01 $Ref)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@497@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@497@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _20.val_ref := _1
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@497@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l23
; [exec]
; label l24
; [exec]
; assert true
; [exec]
; exhale acc(_20.val_ref, write) &&
;   acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_20.val_ref), write)
; [exec]
; _19 := builtin$havoc_ref()
(declare-const ret@499@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l24](_20.val_ref)), write)
; [eval] old[l24](_20.val_ref)
(declare-const $t@500@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_19), write)
(declare-const $t@501@01 $Snap)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@448@01 ret@499@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@502@01 $Snap)
(assert (= $t@502@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_19)) &&
;   ((old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref)) ==
;   0) &&
;   ((old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_19)) &&
;   ((old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_19) ==
;   old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref,
;   0))) &&
;   ((old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref)) ==
;   old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref) -
;   1)) &&
;   (old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) >
;   0 ==>
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l24](_20.val_ref),
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref)) ==>
;     old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref,
;     i + 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l24](_20.val_ref),
;     i)))))))
(declare-const $t@503@01 $Snap)
(assert (= $t@503@01 ($Snap.combine ($Snap.first $t@503@01) ($Snap.second $t@503@01))))
(assert (= ($Snap.first $t@503@01) $Snap.unit))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_19)
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) == 0
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 67 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) == 0 | dead]
; [else-branch: 67 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) != 0 | live]
(set-option :timeout 0)
(push) ; 6
; [else-branch: 67 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) != 0]
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0)))
(assert (=
  ($Snap.second $t@503@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@503@01))
    ($Snap.second ($Snap.second $t@503@01)))))
(assert (= ($Snap.first ($Snap.second $t@503@01)) $Snap.unit))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref)) == 0
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) == 0
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
; [then-branch: 68 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) == 0 | dead]
; [else-branch: 68 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) != 0 | live]
(push) ; 6
; [else-branch: 68 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) != 0]
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@503@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@503@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@503@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@503@01))) $Snap.unit))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_19)
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) > 0
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 6
(set-option :timeout 10)
(assert (not (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@492@01
    $Snap.unit) ret@441@01)
  0)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 69 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0 | live]
; [else-branch: 69 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 69 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0]
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@492@01
    $Snap.unit) ret@441@01)
  0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_19)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@501@01
  $Snap.unit) ret@499@01))
(pop) ; 7
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@501@01
  $Snap.unit) ret@499@01))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (>
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@492@01
        $Snap.unit) ret@441@01)
      0)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@501@01
      $Snap.unit) ret@499@01))))
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@492@01
    $Snap.unit) ret@441@01)
  0))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@501@01
    $Snap.unit) ret@499@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@503@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@503@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@503@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@503@01))))
  $Snap.unit))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_19) == old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref, 0))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) > 0
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 70 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0 | live]
; [else-branch: 70 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 70 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_19) == old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_19)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_pure_1)
(set-option :timeout 0)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@501@01
  $Snap.unit) ret@499@01))
(pop) ; 8
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@501@01
  $Snap.unit) ret@499@01))
(set-option :timeout 0)
(push) ; 8
(assert (not (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@501@01
  $Snap.unit) ret@499@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@501@01
  $Snap.unit) ret@499@01))
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@501@01
  $Snap.unit) ret@499@01))
(pop) ; 7
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
    $t@501@01
    $Snap.unit) ret@499@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@501@01
    $Snap.unit) ret@499@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@501@01
    $Snap.unit) ret@499@01)))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref, 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 8
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(pop) ; 8
; Joined path conditions
; [eval] 0 <= _pure_2
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@501@01
      $Snap.unit) ret@499@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
      $t@501@01
      $Snap.unit) ret@499@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@501@01
      $Snap.unit) ret@499@01))))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@501@01
      $Snap.unit) ret@499@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
      $t@492@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@503@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@503@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@503@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@503@01)))))
  $Snap.unit))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref)) == old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref) - 1)
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) > 0
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 71 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0 | live]
; [else-branch: 71 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 71 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref)) == old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref))
; [eval] old[l24](_20.val_ref)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@500@01
  $Snap.unit) ret@441@01))
(pop) ; 7
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@500@01
  $Snap.unit) ret@441@01))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref) - 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)
(set-option :timeout 0)
(push) ; 7
; [eval] read$()
(push) ; 8
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(push) ; 8
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@500@01
    $Snap.unit) ret@441@01)))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    (-
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@492@01
        $Snap.unit) ret@441@01)
      1))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@503@01)))))
  $Snap.unit))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) > 0 ==> (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l24](_20.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref)) ==> old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l24](_20.val_ref), i))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)) > 0
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_20.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(pop) ; 5
; Joined path conditions
(set-option :timeout 0)
(push) ; 5
(push) ; 6
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
; [then-branch: 72 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0 | live]
; [else-branch: 72 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 72 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@492@01, _), ret@441@01) > 0]
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l24](_20.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref)) ==> old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l24](_20.val_ref), i))
(declare-const i@504@01 Int)
(push) ; 7
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref)) ==> old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l24](_20.val_ref), i)
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref))
; [eval] 0 <= i
(push) ; 8
; [then-branch: 73 | !(0 <= i@504@01) | live]
; [else-branch: 73 | 0 <= i@504@01 | live]
(push) ; 9
; [then-branch: 73 | !(0 <= i@504@01)]
(assert (not (<= 0 i@504@01)))
(pop) ; 9
(push) ; 9
; [else-branch: 73 | 0 <= i@504@01]
(assert (<= 0 i@504@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l24](_20.val_ref))
; [eval] old[l24](_20.val_ref)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@500@01
  $Snap.unit) ret@441@01))
(pop) ; 10
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@500@01
  $Snap.unit) ret@441@01))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 i@504@01)
  (and
    (<= 0 i@504@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01))))
(assert (or (<= 0 i@504@01) (not (<= 0 i@504@01))))
(set-option :timeout 0)
(push) ; 8
; [then-branch: 74 | 0 <= i@504@01 && i@504@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) | live]
; [else-branch: 74 | !(0 <= i@504@01 && i@504@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01)) | live]
(push) ; 9
; [then-branch: 74 | 0 <= i@504@01 && i@504@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01)]
(assert (and
  (<= 0 i@504@01)
  (<
    i@504@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01))))
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l24](_20.val_ref), i)
; [eval] old[l24](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref, i + 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_20.val_ref, i + 1)
; [eval] i + 1
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 11
(assert (not (<= 0 (+ i@504@01 1))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (+ i@504@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (<
  (+ i@504@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@492@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (<
  (+ i@504@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@492@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@492@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
  i@504@01
  1)))
(pop) ; 10
; Joined path conditions
(assert (and
  (<= 0 (+ i@504@01 1))
  (<
    (+ i@504@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@492@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
    i@504@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l24](_20.val_ref), i)
; [eval] old[l24](_20.val_ref)
(push) ; 10
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@500@01
  $Snap.unit) ret@441@01))
(pop) ; 11
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@500@01
  $Snap.unit) ret@441@01))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@500@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@504@01))
(pop) ; 10
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@500@01
    $Snap.unit) ret@441@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@500@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@504@01)))
(pop) ; 9
(set-option :timeout 0)
(push) ; 9
; [else-branch: 74 | !(0 <= i@504@01 && i@504@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01))]
(assert (not
  (and
    (<= 0 i@504@01)
    (<
      i@504@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@500@01
        $Snap.unit) ret@441@01)))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (=>
  (and
    (<= 0 i@504@01)
    (<
      i@504@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@500@01
        $Snap.unit) ret@441@01)))
  (and
    (<= 0 i@504@01)
    (<
      i@504@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@500@01
        $Snap.unit) ret@441@01))
    (<= 0 (+ i@504@01 1))
    (<
      (+ i@504@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@492@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@492@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
      i@504@01
      1))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@500@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@504@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 0 i@504@01)
      (<
        i@504@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@500@01
          $Snap.unit) ret@441@01))))
  (and
    (<= 0 i@504@01)
    (<
      i@504@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@500@01
        $Snap.unit) ret@441@01)))))
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@504@01 Int)) (!
  (and
    (=>
      (<= 0 i@504@01)
      (and
        (<= 0 i@504@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          $t@500@01
          $Snap.unit) ret@441@01)))
    (or (<= 0 i@504@01) (not (<= 0 i@504@01)))
    (=>
      (and
        (<= 0 i@504@01)
        (<
          i@504@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@500@01
            $Snap.unit) ret@441@01)))
      (and
        (<= 0 i@504@01)
        (<
          i@504@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@500@01
            $Snap.unit) ret@441@01))
        (<= 0 (+ i@504@01 1))
        (<
          (+ i@504@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@492@01
            $Snap.unit) ret@441@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@492@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
          i@504@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          $t@500@01
          $Snap.unit) ret@441@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@500@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@504@01)))
    (or
      (not
        (and
          (<= 0 i@504@01)
          (<
            i@504@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@500@01
              $Snap.unit) ret@441@01))))
      (and
        (<= 0 i@504@01)
        (<
          i@504@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@500@01
            $Snap.unit) ret@441@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@500@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@504@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2132@2585@2132@3223-aux|)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0)
  (forall ((i@504@01 Int)) (!
    (and
      (=>
        (<= 0 i@504@01)
        (and
          (<= 0 i@504@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            $t@500@01
            $Snap.unit) ret@441@01)))
      (or (<= 0 i@504@01) (not (<= 0 i@504@01)))
      (=>
        (and
          (<= 0 i@504@01)
          (<
            i@504@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@500@01
              $Snap.unit) ret@441@01)))
        (and
          (<= 0 i@504@01)
          (<
            i@504@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@500@01
              $Snap.unit) ret@441@01))
          (<= 0 (+ i@504@01 1))
          (<
            (+ i@504@01 1)
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@492@01
              $Snap.unit) ret@441@01))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            $t@492@01
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
            i@504@01
            1))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            $t@500@01
            $Snap.unit) ret@441@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            $t@500@01
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@504@01)))
      (or
        (not
          (and
            (<= 0 i@504@01)
            (<
              i@504@01
              (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
                $t@500@01
                $Snap.unit) ret@441@01))))
        (and
          (<= 0 i@504@01)
          (<
            i@504@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@500@01
              $Snap.unit) ret@441@01)))))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      $t@500@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@504@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2132@2585@2132@3223-aux|))))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@492@01
      $Snap.unit) ret@441@01)
    0)
  (forall ((i@504@01 Int)) (!
    (=>
      (and
        (<= 0 i@504@01)
        (<
          i@504@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@500@01
            $Snap.unit) ret@441@01)))
      (=
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          $t@492@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
          i@504@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          $t@500@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@504@01)))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      $t@500@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@504@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2132@2585@2132@3223|))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l25
; [exec]
; label l26
; [exec]
; label bb17
; [exec]
; __t9 := true
; [exec]
; _21 := builtin$havoc_int()
(declare-const ret@505@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@506@01 $Snap)
(assert (= $t@506@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _21 := m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_19)
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_19)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@501@01 ret@499@01))
(pop) ; 5
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@501@01 ret@499@01))
(declare-const _21@507@01 Int)
(assert (=
  _21@507@01
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@501@01 ret@499@01)))
; [exec]
; _22 := builtin$havoc_ref()
(declare-const ret@508@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_22.val_ref, write)
(declare-const $t@509@01 $Ref)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@508@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@508@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _22.val_ref := _19
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@508@01)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_19), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(set-option :timeout 0)
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(set-option :timeout 10)
(assert (not (=
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(assert (not (or
  (=
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No)
  (<
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_22.val_ref), read$())
; [eval] read$()
(push) ; 5
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(declare-const $t@510@01 $Snap)
(declare-const $t@511@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit)))))
    (= $t@511@01 $t@501@01))
  (=> (< $Perm.No (read$ $Snap.unit)) (= $t@511@01 $t@510@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l27
; [exec]
; _24 := builtin$havoc_int()
(declare-const ret@512@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@513@01 $Snap)
(assert (= $t@513@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _24 := m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_22.val_ref)
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_22.val_ref)
(set-option :timeout 0)
(push) ; 5
; [eval] read$()
(push) ; 6
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(push) ; 6
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@511@01 ret@499@01))
(pop) ; 5
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@511@01 ret@499@01))
(declare-const _24@514@01 Int)
(assert (=
  _24@514@01
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@511@01 ret@499@01)))
; [exec]
; __t52 := _24
; [eval] __t52 == 0
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (not (= _24@514@01 0))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 5
(set-option :timeout 10)
(assert (not (= _24@514@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 75 | _24@514@01 == 0 | live]
; [else-branch: 75 | _24@514@01 != 0 | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 75 | _24@514@01 == 0]
(assert (= _24@514@01 0))
; [exec]
; label l29
; [exec]
; label bb20
; [exec]
; __t10 := true
; [exec]
; label l30
(push) ; 6
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
; [then-branch: 76 | True | live]
; [else-branch: 76 | False | dead]
(set-option :timeout 0)
(push) ; 6
; [then-branch: 76 | True]
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_22.val_ref), read$())
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_19), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 7
(pop) ; 7
; Joined path conditions
(push) ; 7
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(declare-const $t@515@01 $Snap)
(declare-const $t@516@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@516@01 $t@511@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@516@01 $t@515@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb23
; [exec]
; __t13 := true
; [exec]
; _23 := builtin$havoc_int()
(declare-const ret@517@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@518@01 $Snap)
(assert (= $t@518@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_19), write)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))
    ($Perm.min
      (+
        (-
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          ($Perm.min
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            (read$ $Snap.unit)))
        (- $Perm.Write (read$ $Snap.unit)))
      $Perm.Write))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(assert (not (or
  (=
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No)
  (<
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (= $t@516@01 ($Snap.combine ($Snap.first $t@516@01) ($Snap.second $t@516@01))))
(assert (not (= ret@499@01 $Ref.null)))
(assert (=
  ($Snap.second $t@516@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@516@01))
    ($Snap.second ($Snap.second $t@516@01)))))
(assert (= ($Snap.first ($Snap.second $t@516@01)) $Snap.unit))
; [eval] 0 <= self.discriminant
(assert (<= 0 ($SortWrappers.$SnapToInt ($Snap.first $t@516@01))))
(assert (=
  ($Snap.second ($Snap.second $t@516@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@516@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@516@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@516@01))) $Snap.unit))
; [eval] self.discriminant <= 1
(assert (<= ($SortWrappers.$SnapToInt ($Snap.first $t@516@01)) 1))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@516@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@516@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01)))))))
; [eval] self.discriminant == 0
(push) ; 7
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@516@01)) 0))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@516@01)) 0)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; [then-branch: 77 | First:($t@516@01) == 0 | live]
; [else-branch: 77 | First:($t@516@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 7
; [then-branch: 77 | First:($t@516@01) == 0]
(assert (= ($SortWrappers.$SnapToInt ($Snap.first $t@516@01)) 0))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger $t@516@01 ret@499@01))
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some(_19.enum_Some), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01))))))))
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@516@01)))))
    $Ref.null)))
; State saturation: after unfold
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@516@01)))))))
; [exec]
; unfold acc(i32(_19.enum_Some.f$0), write)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01))))))
    $Ref.null)))
; State saturation: after unfold
(check-sat)
; unknown
(assert (i32%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01))))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01))))))))
; [exec]
; _23 := _19.enum_Some.f$0.val_int
(declare-const _23@519@01 Int)
(assert (=
  _23@519@01
  ($SortWrappers.$SnapToInt ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01))))))))
; [exec]
; label l31
; [exec]
; _27 := builtin$havoc_int()
(declare-const ret@520@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@521@01 $Snap)
(assert (= $t@521@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _27 := _23
; [exec]
; label l32
; [exec]
; _26 := builtin$havoc_ref()
(declare-const ret@522@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_26.val_bool, write)
(declare-const $t@523@01 Bool)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@522@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@522@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@522@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _26.val_bool := _27 == 3
; [eval] _27 == 3
(declare-const val_bool@524@01 Bool)
(assert (= val_bool@524@01 (= _23@519@01 3)))
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@522@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@522@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [exec]
; _25 := builtin$havoc_ref()
(declare-const ret@525@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_25.val_bool, write)
(declare-const $t@526@01 Bool)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@525@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@525@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@525@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@525@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _25.val_bool := !_26.val_bool
; [eval] !_26.val_bool
(declare-const val_bool@527@01 Bool)
(assert (= val_bool@527@01 (not val_bool@524@01)))
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@525@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@525@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@525@01)))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [exec]
; __t53 := _25.val_bool
; [eval] !__t53
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not val_bool@527@01))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 8
(set-option :timeout 10)
(assert (not (not val_bool@527@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 78 | !(val_bool@527@01) | live]
; [else-branch: 78 | val_bool@527@01 | dead]
(set-option :timeout 0)
(push) ; 8
; [then-branch: 78 | !(val_bool@527@01)]
(assert (not val_bool@527@01))
; [exec]
; label l34
; [exec]
; label bb25
; [exec]
; __t15 := true
; [exec]
; _18 := builtin$havoc_ref()
(declare-const ret@528@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_18), write)
(declare-const $t@529@01 $Snap)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@491@01 ret@528@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@481@01 ret@528@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@528@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@528@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _38 := builtin$havoc_ref()
(declare-const ret@530@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_38.val_ref, write)
(declare-const $t@531@01 $Ref)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@530@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@530@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@530@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _38.val_ref := _1
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@530@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@530@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l35
; [exec]
; label l36
; [exec]
; assert true
; [exec]
; exhale acc(_38.val_ref, write) &&
;   acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_38.val_ref), write)
; [exec]
; _37 := builtin$havoc_ref()
(declare-const ret@532@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l36](_38.val_ref)), write)
; [eval] old[l36](_38.val_ref)
(declare-const $t@533@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_37), write)
(declare-const $t@534@01 $Snap)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@448@01 ret@532@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@535@01 $Snap)
(assert (= $t@535@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_37)) &&
;   ((old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref)) ==
;   0) &&
;   ((old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_37)) &&
;   ((old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_37) ==
;   old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref,
;   0))) &&
;   ((old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref)) ==
;   old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref) -
;   1)) &&
;   (old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) >
;   0 ==>
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l36](_38.val_ref),
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref)) ==>
;     old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref,
;     i + 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l36](_38.val_ref),
;     i)))))))
(declare-const $t@536@01 $Snap)
(assert (= $t@536@01 ($Snap.combine ($Snap.first $t@536@01) ($Snap.second $t@536@01))))
(assert (= ($Snap.first $t@536@01) $Snap.unit))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_37)
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) == 0
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)
(set-option :timeout 0)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@500@01
  $Snap.unit) ret@441@01))
(pop) ; 9
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@500@01
  $Snap.unit) ret@441@01))
(set-option :timeout 0)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 79 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) == 0 | dead]
; [else-branch: 79 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) != 0 | live]
(set-option :timeout 0)
(push) ; 10
; [else-branch: 79 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) != 0]
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0)))
(assert (=
  ($Snap.second $t@536@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@536@01))
    ($Snap.second ($Snap.second $t@536@01)))))
(assert (= ($Snap.first ($Snap.second $t@536@01)) $Snap.unit))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref)) == 0
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) == 0
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
(set-option :timeout 0)
(push) ; 9
; [then-branch: 80 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) == 0 | dead]
; [else-branch: 80 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) != 0 | live]
(push) ; 10
; [else-branch: 80 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) != 0]
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@536@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@536@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@536@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@536@01))) $Snap.unit))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_37)
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) > 0
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
(set-option :timeout 0)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 10
(set-option :timeout 10)
(assert (not (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@500@01
    $Snap.unit) ret@441@01)
  0)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 81 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0 | live]
; [else-branch: 81 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 81 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0]
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@500@01
    $Snap.unit) ret@441@01)
  0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_37)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@534@01
  $Snap.unit) ret@532@01))
(pop) ; 11
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@534@01
  $Snap.unit) ret@532@01))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (>
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@500@01
        $Snap.unit) ret@441@01)
      0)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@534@01
      $Snap.unit) ret@532@01))))
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@500@01
    $Snap.unit) ret@441@01)
  0))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@534@01
    $Snap.unit) ret@532@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@536@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@536@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@536@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@536@01))))
  $Snap.unit))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_37) == old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref, 0))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) > 0
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)
(set-option :timeout 0)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
(set-option :timeout 0)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 82 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0 | live]
; [else-branch: 82 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 82 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_37) == old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_37)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_pure_1)
(set-option :timeout 0)
(push) ; 12
; [eval] read$()
(push) ; 13
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(push) ; 13
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@534@01
  $Snap.unit) ret@532@01))
(pop) ; 12
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@534@01
  $Snap.unit) ret@532@01))
(set-option :timeout 0)
(push) ; 12
(assert (not (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@534@01
  $Snap.unit) ret@532@01)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@534@01
  $Snap.unit) ret@532@01))
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@534@01
  $Snap.unit) ret@532@01))
(pop) ; 11
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
    $t@534@01
    $Snap.unit) ret@532@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@534@01
    $Snap.unit) ret@532@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@534@01
    $Snap.unit) ret@532@01)))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref, 0)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 12
; [eval] read$()
(push) ; 13
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(push) ; 13
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(pop) ; 12
; Joined path conditions
(set-option :timeout 0)
(push) ; 12
(assert (not (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@500@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@500@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@500@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))
(pop) ; 11
; Joined path conditions
(assert (and
  (<
    0
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@500@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@534@01
      $Snap.unit) ret@532@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
      $t@534@01
      $Snap.unit) ret@532@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@534@01
      $Snap.unit) ret@532@01)
    (<
      0
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@500@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@500@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@534@01
      $Snap.unit) ret@532@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
      $t@500@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@536@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@536@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@536@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@536@01)))))
  $Snap.unit))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref)) == old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref) - 1)
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) > 0
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
(set-option :timeout 0)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 83 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0 | live]
; [else-branch: 83 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 83 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref)) == old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref))
; [eval] old[l36](_38.val_ref)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@533@01
  $Snap.unit) ret@441@01))
(pop) ; 11
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@533@01
  $Snap.unit) ret@441@01))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref) - 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)
(set-option :timeout 0)
(push) ; 11
; [eval] read$()
(push) ; 12
(pop) ; 12
; Joined path conditions
(push) ; 12
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(push) ; 12
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(pop) ; 11
; Joined path conditions
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@533@01
    $Snap.unit) ret@441@01)))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@533@01
      $Snap.unit) ret@441@01)
    (-
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@500@01
        $Snap.unit) ret@441@01)
      1))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@536@01)))))
  $Snap.unit))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) > 0 ==> (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l36](_38.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref)) ==> old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l36](_38.val_ref), i))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)) > 0
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_38.val_ref)
(set-option :timeout 0)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(pop) ; 9
; Joined path conditions
(set-option :timeout 0)
(push) ; 9
(push) ; 10
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 84 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0 | live]
; [else-branch: 84 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 84 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@500@01, _), ret@441@01) > 0]
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l36](_38.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref)) ==> old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l36](_38.val_ref), i))
(declare-const i@537@01 Int)
(push) ; 11
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref)) ==> old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l36](_38.val_ref), i)
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref))
; [eval] 0 <= i
(push) ; 12
; [then-branch: 85 | !(0 <= i@537@01) | live]
; [else-branch: 85 | 0 <= i@537@01 | live]
(push) ; 13
; [then-branch: 85 | !(0 <= i@537@01)]
(assert (not (<= 0 i@537@01)))
(pop) ; 13
(push) ; 13
; [else-branch: 85 | 0 <= i@537@01]
(assert (<= 0 i@537@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l36](_38.val_ref))
; [eval] old[l36](_38.val_ref)
(push) ; 14
; [eval] read$()
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(push) ; 15
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@533@01
  $Snap.unit) ret@441@01))
(pop) ; 14
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@533@01
  $Snap.unit) ret@441@01))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 i@537@01)
  (and
    (<= 0 i@537@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@533@01
      $Snap.unit) ret@441@01))))
(assert (or (<= 0 i@537@01) (not (<= 0 i@537@01))))
(set-option :timeout 0)
(push) ; 12
; [then-branch: 86 | 0 <= i@537@01 && i@537@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@533@01, _), ret@441@01) | live]
; [else-branch: 86 | !(0 <= i@537@01 && i@537@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@533@01, _), ret@441@01)) | live]
(push) ; 13
; [then-branch: 86 | 0 <= i@537@01 && i@537@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@533@01, _), ret@441@01)]
(assert (and
  (<= 0 i@537@01)
  (<
    i@537@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@533@01
      $Snap.unit) ret@441@01))))
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l36](_38.val_ref), i)
; [eval] old[l36](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref, i + 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_38.val_ref, i + 1)
; [eval] i + 1
(push) ; 14
; [eval] read$()
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(push) ; 15
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 15
(assert (not (<= 0 (+ i@537@01 1))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (+ i@537@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 15
; [eval] read$()
(push) ; 16
(pop) ; 16
; Joined path conditions
(push) ; 16
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(push) ; 16
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(pop) ; 15
; Joined path conditions
(set-option :timeout 0)
(push) ; 15
(assert (not (<
  (+ i@537@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@500@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (<
  (+ i@537@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@500@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@500@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
  i@537@01
  1)))
(pop) ; 14
; Joined path conditions
(assert (and
  (<= 0 (+ i@537@01 1))
  (<
    (+ i@537@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@500@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
    i@537@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l36](_38.val_ref), i)
; [eval] old[l36](_38.val_ref)
(push) ; 14
; [eval] read$()
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(push) ; 15
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 15
; [eval] read$()
(push) ; 16
(pop) ; 16
; Joined path conditions
(push) ; 16
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(push) ; 16
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@533@01
  $Snap.unit) ret@441@01))
(pop) ; 15
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@533@01
  $Snap.unit) ret@441@01))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@533@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@537@01))
(pop) ; 14
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@533@01
    $Snap.unit) ret@441@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@533@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@537@01)))
(pop) ; 13
(set-option :timeout 0)
(push) ; 13
; [else-branch: 86 | !(0 <= i@537@01 && i@537@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@533@01, _), ret@441@01))]
(assert (not
  (and
    (<= 0 i@537@01)
    (<
      i@537@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@533@01
        $Snap.unit) ret@441@01)))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (=>
  (and
    (<= 0 i@537@01)
    (<
      i@537@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@533@01
        $Snap.unit) ret@441@01)))
  (and
    (<= 0 i@537@01)
    (<
      i@537@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@533@01
        $Snap.unit) ret@441@01))
    (<= 0 (+ i@537@01 1))
    (<
      (+ i@537@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@500@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@500@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
      i@537@01
      1))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@533@01
      $Snap.unit) ret@441@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@533@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@537@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 0 i@537@01)
      (<
        i@537@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@533@01
          $Snap.unit) ret@441@01))))
  (and
    (<= 0 i@537@01)
    (<
      i@537@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@533@01
        $Snap.unit) ret@441@01)))))
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@537@01 Int)) (!
  (and
    (=>
      (<= 0 i@537@01)
      (and
        (<= 0 i@537@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          $t@533@01
          $Snap.unit) ret@441@01)))
    (or (<= 0 i@537@01) (not (<= 0 i@537@01)))
    (=>
      (and
        (<= 0 i@537@01)
        (<
          i@537@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@533@01
            $Snap.unit) ret@441@01)))
      (and
        (<= 0 i@537@01)
        (<
          i@537@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@533@01
            $Snap.unit) ret@441@01))
        (<= 0 (+ i@537@01 1))
        (<
          (+ i@537@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@500@01
            $Snap.unit) ret@441@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@500@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
          i@537@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          $t@533@01
          $Snap.unit) ret@441@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@533@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@537@01)))
    (or
      (not
        (and
          (<= 0 i@537@01)
          (<
            i@537@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@533@01
              $Snap.unit) ret@441@01))))
      (and
        (<= 0 i@537@01)
        (<
          i@537@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@533@01
            $Snap.unit) ret@441@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@533@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@537@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2328@2585@2328@3223-aux|)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0)
  (forall ((i@537@01 Int)) (!
    (and
      (=>
        (<= 0 i@537@01)
        (and
          (<= 0 i@537@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            $t@533@01
            $Snap.unit) ret@441@01)))
      (or (<= 0 i@537@01) (not (<= 0 i@537@01)))
      (=>
        (and
          (<= 0 i@537@01)
          (<
            i@537@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@533@01
              $Snap.unit) ret@441@01)))
        (and
          (<= 0 i@537@01)
          (<
            i@537@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@533@01
              $Snap.unit) ret@441@01))
          (<= 0 (+ i@537@01 1))
          (<
            (+ i@537@01 1)
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@500@01
              $Snap.unit) ret@441@01))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            $t@500@01
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
            i@537@01
            1))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            $t@533@01
            $Snap.unit) ret@441@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            $t@533@01
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@537@01)))
      (or
        (not
          (and
            (<= 0 i@537@01)
            (<
              i@537@01
              (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
                $t@533@01
                $Snap.unit) ret@441@01))))
        (and
          (<= 0 i@537@01)
          (<
            i@537@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@533@01
              $Snap.unit) ret@441@01)))))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      $t@533@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@537@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2328@2585@2328@3223-aux|))))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@500@01
      $Snap.unit) ret@441@01)
    0)
  (forall ((i@537@01 Int)) (!
    (=>
      (and
        (<= 0 i@537@01)
        (<
          i@537@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@533@01
            $Snap.unit) ret@441@01)))
      (=
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          $t@500@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
          i@537@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          $t@533@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@537@01)))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      $t@533@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@537@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2328@2585@2328@3223|))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l37
; [exec]
; label l38
; [exec]
; label bb28
; [exec]
; __t16 := true
; [exec]
; _39 := builtin$havoc_int()
(declare-const ret@538@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@539@01 $Snap)
(assert (= $t@539@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _39 := m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_37)
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_37)
(set-option :timeout 0)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@534@01 ret@532@01))
(pop) ; 9
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@534@01 ret@532@01))
(declare-const _39@540@01 Int)
(assert (=
  _39@540@01
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@534@01 ret@532@01)))
; [exec]
; _40 := builtin$havoc_ref()
(declare-const ret@541@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_40.val_ref, write)
(declare-const $t@542@01 $Ref)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@541@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@541@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@541@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _40.val_ref := _37
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@541@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@541@01)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_37), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(set-option :timeout 0)
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(push) ; 9
(set-option :timeout 10)
(assert (not (=
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(assert (not (or
  (=
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No)
  (<
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_40.val_ref), read$())
; [eval] read$()
(push) ; 9
(pop) ; 9
; Joined path conditions
(push) ; 9
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(declare-const $t@543@01 $Snap)
(declare-const $t@544@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit)))))
    (= $t@544@01 $t@534@01))
  (=> (< $Perm.No (read$ $Snap.unit)) (= $t@544@01 $t@543@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l39
; [exec]
; _42 := builtin$havoc_int()
(declare-const ret@545@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@546@01 $Snap)
(assert (= $t@546@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _42 := m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_40.val_ref)
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_40.val_ref)
(set-option :timeout 0)
(push) ; 9
; [eval] read$()
(push) ; 10
(pop) ; 10
; Joined path conditions
(push) ; 10
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(push) ; 10
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@544@01 ret@532@01))
(pop) ; 9
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@544@01 ret@532@01))
(declare-const _42@547@01 Int)
(assert (=
  _42@547@01
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@544@01 ret@532@01)))
; [exec]
; __t54 := _42
; [eval] __t54 == 0
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (not (= _42@547@01 0))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= _42@547@01 0)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 87 | _42@547@01 == 0 | live]
; [else-branch: 87 | _42@547@01 != 0 | dead]
(set-option :timeout 0)
(push) ; 9
; [then-branch: 87 | _42@547@01 == 0]
(assert (= _42@547@01 0))
; [exec]
; label l41
; [exec]
; label bb31
; [exec]
; __t17 := true
; [exec]
; label l42
(push) ; 10
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
; [then-branch: 88 | True | live]
; [else-branch: 88 | False | dead]
(set-option :timeout 0)
(push) ; 10
; [then-branch: 88 | True]
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_40.val_ref), read$())
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(push) ; 11
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_37), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 11
(pop) ; 11
; Joined path conditions
(push) ; 11
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(declare-const $t@548@01 $Snap)
(declare-const $t@549@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@549@01 $t@544@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@549@01 $t@548@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb34
; [exec]
; __t20 := true
; [exec]
; _41 := builtin$havoc_int()
(declare-const ret@550@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@551@01 $Snap)
(assert (= $t@551@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_37), write)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))
    ($Perm.min
      (+
        (-
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          ($Perm.min
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            (read$ $Snap.unit)))
        (- $Perm.Write (read$ $Snap.unit)))
      $Perm.Write))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(assert (not (or
  (=
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No)
  (<
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (= $t@549@01 ($Snap.combine ($Snap.first $t@549@01) ($Snap.second $t@549@01))))
(push) ; 11
(set-option :timeout 10)
(assert (not (= ret@499@01 ret@532@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@532@01 $Ref.null)))
(assert (=
  ($Snap.second $t@549@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@549@01))
    ($Snap.second ($Snap.second $t@549@01)))))
(assert (= ($Snap.first ($Snap.second $t@549@01)) $Snap.unit))
; [eval] 0 <= self.discriminant
(assert (<= 0 ($SortWrappers.$SnapToInt ($Snap.first $t@549@01))))
(assert (=
  ($Snap.second ($Snap.second $t@549@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@549@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@549@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@549@01))) $Snap.unit))
; [eval] self.discriminant <= 1
(assert (<= ($SortWrappers.$SnapToInt ($Snap.first $t@549@01)) 1))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@549@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@549@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01)))))))
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (= ret@499@01 ret@532@01)))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [eval] self.discriminant == 0
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@549@01)) 0))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 11
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@549@01)) 0)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
; [then-branch: 89 | First:($t@549@01) == 0 | live]
; [else-branch: 89 | First:($t@549@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 11
; [then-branch: 89 | First:($t@549@01) == 0]
(assert (= ($SortWrappers.$SnapToInt ($Snap.first $t@549@01)) 0))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger $t@549@01 ret@532@01))
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some(_37.enum_Some), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01))))))))
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@516@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@549@01))))))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@549@01)))))
    $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@549@01)))))))
; [exec]
; unfold acc(i32(_37.enum_Some.f$0), write)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01))))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01)))))))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01))))))
    $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (i32%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01))))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01))))))))
; [exec]
; _41 := _37.enum_Some.f$0.val_int
(declare-const _41@552@01 Int)
(assert (=
  _41@552@01
  ($SortWrappers.$SnapToInt ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01))))))))
; [exec]
; label l43
; [exec]
; _45 := builtin$havoc_int()
(declare-const ret@553@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@554@01 $Snap)
(assert (= $t@554@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _45 := _41
; [exec]
; label l44
; [exec]
; _44 := builtin$havoc_ref()
(declare-const ret@555@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_44.val_bool, write)
(declare-const $t@556@01 Bool)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@555@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _44.val_bool := _45 == 2
; [eval] _45 == 2
(declare-const val_bool@557@01 Bool)
(assert (= val_bool@557@01 (= _41@552@01 2)))
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@555@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [exec]
; _43 := builtin$havoc_ref()
(declare-const ret@558@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_43.val_bool, write)
(declare-const $t@559@01 Bool)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@558@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@558@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@558@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@558@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@558@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@558@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _43.val_bool := !_44.val_bool
; [eval] !_44.val_bool
(declare-const val_bool@560@01 Bool)
(assert (= val_bool@560@01 (not val_bool@557@01)))
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@558@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@558@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@558@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@558@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@558@01)))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [exec]
; __t55 := _43.val_bool
; [eval] !__t55
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not val_bool@560@01))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 12
(set-option :timeout 10)
(assert (not (not val_bool@560@01)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 90 | !(val_bool@560@01) | live]
; [else-branch: 90 | val_bool@560@01 | dead]
(set-option :timeout 0)
(push) ; 12
; [then-branch: 90 | !(val_bool@560@01)]
(assert (not val_bool@560@01))
; [exec]
; label l46
; [exec]
; label bb36
; [exec]
; __t22 := true
; [exec]
; _36 := builtin$havoc_ref()
(declare-const ret@561@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_36), write)
(declare-const $t@562@01 $Snap)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@528@01 ret@561@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@491@01 ret@561@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@481@01 ret@561@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@561@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@561@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _55 := builtin$havoc_ref()
(declare-const ret@563@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_55.val_ref, write)
(declare-const $t@564@01 $Ref)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@563@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@563@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@563@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@563@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _55.val_ref := _1
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@563@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@563@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@563@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l47
; [exec]
; label l48
; [exec]
; _t151 := builtin$havoc_ref()
(declare-const ret@565@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(i32(_t151), write)
(declare-const $t@566@01 Int)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert true
; [exec]
; exhale acc(_55.val_ref, write) &&
;   (acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_55.val_ref), write) &&
;   acc(i32(_t151), write))
; [exec]
; _54 := builtin$havoc_ref()
(declare-const ret@567@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l48](_55.val_ref)), write)
; [eval] old[l48](_55.val_ref)
(declare-const $t@568@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_54), write)
(declare-const $t@569@01 $Snap)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@561@01 ret@567@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@528@01 ret@567@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@491@01 ret@567@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@481@01 ret@567@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@567@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@567@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@570@01 $Snap)
(assert (= $t@570@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l48](_55.val_ref)) ==
;   old[l48](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_55.val_ref)) +
;   1 &&
;   (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l48](_55.val_ref),
;   0) ==
;   old[l48](4) &&
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l48](_55.val_ref),
;     i) }
;     1 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l48](_55.val_ref)) ==>
;     old[l48](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_55.val_ref,
;     i - 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l48](_55.val_ref),
;     i)))
(declare-const $t@571@01 $Snap)
(assert (= $t@571@01 ($Snap.combine ($Snap.first $t@571@01) ($Snap.second $t@571@01))))
(assert (= ($Snap.first $t@571@01) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l48](_55.val_ref)) == old[l48](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_55.val_ref)) + 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l48](_55.val_ref))
; [eval] old[l48](_55.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@568@01
  $Snap.unit) ret@441@01))
(pop) ; 13
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@568@01
  $Snap.unit) ret@441@01))
; [eval] old[l48](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_55.val_ref)) + 1
; [eval] old[l48](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_55.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_55.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@533@01
  $Snap.unit) ret@441@01))
(pop) ; 13
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@533@01
  $Snap.unit) ret@441@01))
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@568@01
    $Snap.unit) ret@441@01)
  (+
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@533@01
      $Snap.unit) ret@441@01)
    1)))
(assert (=
  ($Snap.second $t@571@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@571@01))
    ($Snap.second ($Snap.second $t@571@01)))))
(assert (= ($Snap.first ($Snap.second $t@571@01)) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l48](_55.val_ref), 0) == old[l48](4)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l48](_55.val_ref), 0)
; [eval] old[l48](_55.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 14
; [eval] read$()
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(push) ; 15
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(pop) ; 14
; Joined path conditions
(set-option :timeout 0)
(push) ; 14
(assert (not (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@568@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@568@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@568@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))
(pop) ; 13
; Joined path conditions
(assert (and
  (<
    0
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@568@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@568@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)))
; [eval] old[l48](4)
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
    $t@568@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)
  4))
(assert (= ($Snap.second ($Snap.second $t@571@01)) $Snap.unit))
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l48](_55.val_ref), i) } 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l48](_55.val_ref)) ==> old[l48](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_55.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l48](_55.val_ref), i))
(declare-const i@572@01 Int)
(push) ; 13
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l48](_55.val_ref)) ==> old[l48](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_55.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l48](_55.val_ref), i)
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l48](_55.val_ref))
; [eval] 1 <= i
(push) ; 14
; [then-branch: 91 | !(1 <= i@572@01) | live]
; [else-branch: 91 | 1 <= i@572@01 | live]
(push) ; 15
; [then-branch: 91 | !(1 <= i@572@01)]
(assert (not (<= 1 i@572@01)))
(pop) ; 15
(push) ; 15
; [else-branch: 91 | 1 <= i@572@01]
(assert (<= 1 i@572@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l48](_55.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l48](_55.val_ref))
; [eval] old[l48](_55.val_ref)
(push) ; 16
; [eval] read$()
(push) ; 17
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(push) ; 17
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(pop) ; 16
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (or (<= 1 i@572@01) (not (<= 1 i@572@01))))
(set-option :timeout 0)
(push) ; 14
; [then-branch: 92 | 1 <= i@572@01 && i@572@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@568@01, _), ret@441@01) | live]
; [else-branch: 92 | !(1 <= i@572@01 && i@572@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@568@01, _), ret@441@01)) | live]
(push) ; 15
; [then-branch: 92 | 1 <= i@572@01 && i@572@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@568@01, _), ret@441@01)]
(assert (and
  (<= 1 i@572@01)
  (<
    i@572@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@568@01
      $Snap.unit) ret@441@01))))
; [eval] old[l48](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_55.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l48](_55.val_ref), i)
; [eval] old[l48](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_55.val_ref, i - 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_55.val_ref, i - 1)
; [eval] i - 1
(push) ; 16
; [eval] read$()
(push) ; 17
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(push) ; 17
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 17
(assert (not (<= 0 (- i@572@01 1))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (- i@572@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(pop) ; 17
; Joined path conditions
(set-option :timeout 0)
(push) ; 17
(assert (not (<
  (- i@572@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@533@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (<
  (- i@572@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@533@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@533@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
  i@572@01
  1)))
(pop) ; 16
; Joined path conditions
(assert (and
  (<= 0 (- i@572@01 1))
  (<
    (- i@572@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@533@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@533@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
    i@572@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l48](_55.val_ref), i)
; [eval] old[l48](_55.val_ref)
(push) ; 16
; [eval] read$()
(push) ; 17
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(push) ; 17
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 17
(assert (not (<= 0 i@572@01)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 i@572@01))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(pop) ; 17
; Joined path conditions
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@568@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@572@01))
(pop) ; 16
; Joined path conditions
(assert (and
  (<= 0 i@572@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@568@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@572@01)))
(pop) ; 15
(set-option :timeout 0)
(push) ; 15
; [else-branch: 92 | !(1 <= i@572@01 && i@572@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@568@01, _), ret@441@01))]
(assert (not
  (and
    (<= 1 i@572@01)
    (<
      i@572@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@568@01
        $Snap.unit) ret@441@01)))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (=>
  (and
    (<= 1 i@572@01)
    (<
      i@572@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@568@01
        $Snap.unit) ret@441@01)))
  (and
    (<= 1 i@572@01)
    (<
      i@572@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@568@01
        $Snap.unit) ret@441@01))
    (<= 0 (- i@572@01 1))
    (<
      (- i@572@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@533@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@533@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
      i@572@01
      1))
    (<= 0 i@572@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@568@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@572@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 1 i@572@01)
      (<
        i@572@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@568@01
          $Snap.unit) ret@441@01))))
  (and
    (<= 1 i@572@01)
    (<
      i@572@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@568@01
        $Snap.unit) ret@441@01)))))
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@572@01 Int)) (!
  (and
    (or (<= 1 i@572@01) (not (<= 1 i@572@01)))
    (=>
      (and
        (<= 1 i@572@01)
        (<
          i@572@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@568@01
            $Snap.unit) ret@441@01)))
      (and
        (<= 1 i@572@01)
        (<
          i@572@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@568@01
            $Snap.unit) ret@441@01))
        (<= 0 (- i@572@01 1))
        (<
          (- i@572@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@533@01
            $Snap.unit) ret@441@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@533@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
          i@572@01
          1))
        (<= 0 i@572@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@568@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@572@01)))
    (or
      (not
        (and
          (<= 1 i@572@01)
          (<
            i@572@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@568@01
              $Snap.unit) ret@441@01))))
      (and
        (<= 1 i@572@01)
        (<
          i@572@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@568@01
            $Snap.unit) ret@441@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@568@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@572@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2518@625@2518@1263-aux|)))
(assert (forall ((i@572@01 Int)) (!
  (=>
    (and
      (<= 1 i@572@01)
      (<
        i@572@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@568@01
          $Snap.unit) ret@441@01)))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@533@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
        i@572@01
        1))
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@568@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@572@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@568@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@572@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2518@625@2518@1263|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l49
; [exec]
; label l50
; [exec]
; label bb39
; [exec]
; __t23 := true
; [exec]
; _57 := builtin$havoc_ref()
(declare-const ret@573@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_57.val_ref, write)
(declare-const $t@574@01 $Ref)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@573@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@573@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@573@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@573@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _57.val_ref := _1
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@573@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@573@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@573@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l51
; [exec]
; label l52
; [exec]
; _t154 := builtin$havoc_ref()
(declare-const ret@575@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(i32(_t154), write)
(declare-const $t@576@01 Int)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert true
; [exec]
; exhale acc(_57.val_ref, write) &&
;   (acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_57.val_ref), write) &&
;   acc(i32(_t154), write))
; [exec]
; _56 := builtin$havoc_ref()
(declare-const ret@577@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l52](_57.val_ref)), write)
; [eval] old[l52](_57.val_ref)
(declare-const $t@578@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_56), write)
(declare-const $t@579@01 $Snap)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@567@01 ret@577@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@561@01 ret@577@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@528@01 ret@577@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@491@01 ret@577@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@481@01 ret@577@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@577@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@577@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@580@01 $Snap)
(assert (= $t@580@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l52](_57.val_ref)) ==
;   old[l52](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_57.val_ref)) +
;   1 &&
;   (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l52](_57.val_ref),
;   0) ==
;   old[l52](5) &&
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l52](_57.val_ref),
;     i) }
;     1 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l52](_57.val_ref)) ==>
;     old[l52](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_57.val_ref,
;     i - 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l52](_57.val_ref),
;     i)))
(declare-const $t@581@01 $Snap)
(assert (= $t@581@01 ($Snap.combine ($Snap.first $t@581@01) ($Snap.second $t@581@01))))
(assert (= ($Snap.first $t@581@01) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l52](_57.val_ref)) == old[l52](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_57.val_ref)) + 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l52](_57.val_ref))
; [eval] old[l52](_57.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@578@01
  $Snap.unit) ret@441@01))
(pop) ; 13
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@578@01
  $Snap.unit) ret@441@01))
; [eval] old[l52](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_57.val_ref)) + 1
; [eval] old[l52](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_57.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_57.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(pop) ; 13
; Joined path conditions
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@578@01
    $Snap.unit) ret@441@01)
  (+
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@568@01
      $Snap.unit) ret@441@01)
    1)))
(assert (=
  ($Snap.second $t@581@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@581@01))
    ($Snap.second ($Snap.second $t@581@01)))))
(assert (= ($Snap.first ($Snap.second $t@581@01)) $Snap.unit))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l52](_57.val_ref), 0) == old[l52](5)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l52](_57.val_ref), 0)
; [eval] old[l52](_57.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 14
; [eval] read$()
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(push) ; 15
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(pop) ; 14
; Joined path conditions
(set-option :timeout 0)
(push) ; 14
(assert (not (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@578@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@578@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@578@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))
(pop) ; 13
; Joined path conditions
(assert (and
  (<
    0
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@578@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)))
; [eval] old[l52](5)
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
    $t@578@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)
  5))
(assert (= ($Snap.second ($Snap.second $t@581@01)) $Snap.unit))
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l52](_57.val_ref), i) } 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l52](_57.val_ref)) ==> old[l52](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_57.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l52](_57.val_ref), i))
(declare-const i@582@01 Int)
(push) ; 13
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l52](_57.val_ref)) ==> old[l52](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_57.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l52](_57.val_ref), i)
; [eval] 1 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l52](_57.val_ref))
; [eval] 1 <= i
(push) ; 14
; [then-branch: 93 | !(1 <= i@582@01) | live]
; [else-branch: 93 | 1 <= i@582@01 | live]
(push) ; 15
; [then-branch: 93 | !(1 <= i@582@01)]
(assert (not (<= 1 i@582@01)))
(pop) ; 15
(push) ; 15
; [else-branch: 93 | 1 <= i@582@01]
(assert (<= 1 i@582@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l52](_57.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l52](_57.val_ref))
; [eval] old[l52](_57.val_ref)
(push) ; 16
; [eval] read$()
(push) ; 17
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(push) ; 17
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(pop) ; 16
; Joined path conditions
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (or (<= 1 i@582@01) (not (<= 1 i@582@01))))
(set-option :timeout 0)
(push) ; 14
; [then-branch: 94 | 1 <= i@582@01 && i@582@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) | live]
; [else-branch: 94 | !(1 <= i@582@01 && i@582@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01)) | live]
(push) ; 15
; [then-branch: 94 | 1 <= i@582@01 && i@582@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01)]
(assert (and
  (<= 1 i@582@01)
  (<
    i@582@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01))))
; [eval] old[l52](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_57.val_ref, i - 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l52](_57.val_ref), i)
; [eval] old[l52](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_57.val_ref, i - 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_57.val_ref, i - 1)
; [eval] i - 1
(push) ; 16
; [eval] read$()
(push) ; 17
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(push) ; 17
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 17
(assert (not (<= 0 (- i@582@01 1))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (- i@582@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(pop) ; 17
; Joined path conditions
(set-option :timeout 0)
(push) ; 17
(assert (not (<
  (- i@582@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@568@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (<
  (- i@582@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@568@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@568@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
  i@582@01
  1)))
(pop) ; 16
; Joined path conditions
(assert (and
  (<= 0 (- i@582@01 1))
  (<
    (- i@582@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@568@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@568@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
    i@582@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l52](_57.val_ref), i)
; [eval] old[l52](_57.val_ref)
(push) ; 16
; [eval] read$()
(push) ; 17
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(push) ; 17
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 17
(assert (not (<= 0 i@582@01)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 i@582@01))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(pop) ; 17
; Joined path conditions
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@578@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@582@01))
(pop) ; 16
; Joined path conditions
(assert (and
  (<= 0 i@582@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@578@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@582@01)))
(pop) ; 15
(set-option :timeout 0)
(push) ; 15
; [else-branch: 94 | !(1 <= i@582@01 && i@582@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01))]
(assert (not
  (and
    (<= 1 i@582@01)
    (<
      i@582@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@578@01
        $Snap.unit) ret@441@01)))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (=>
  (and
    (<= 1 i@582@01)
    (<
      i@582@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@578@01
        $Snap.unit) ret@441@01)))
  (and
    (<= 1 i@582@01)
    (<
      i@582@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@578@01
        $Snap.unit) ret@441@01))
    (<= 0 (- i@582@01 1))
    (<
      (- i@582@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@568@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@568@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
      i@582@01
      1))
    (<= 0 i@582@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@578@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@582@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 1 i@582@01)
      (<
        i@582@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@578@01
          $Snap.unit) ret@441@01))))
  (and
    (<= 1 i@582@01)
    (<
      i@582@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@578@01
        $Snap.unit) ret@441@01)))))
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@582@01 Int)) (!
  (and
    (or (<= 1 i@582@01) (not (<= 1 i@582@01)))
    (=>
      (and
        (<= 1 i@582@01)
        (<
          i@582@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@578@01
            $Snap.unit) ret@441@01)))
      (and
        (<= 1 i@582@01)
        (<
          i@582@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@578@01
            $Snap.unit) ret@441@01))
        (<= 0 (- i@582@01 1))
        (<
          (- i@582@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@568@01
            $Snap.unit) ret@441@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@568@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
          i@582@01
          1))
        (<= 0 i@582@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@578@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@582@01)))
    (or
      (not
        (and
          (<= 1 i@582@01)
          (<
            i@582@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@578@01
              $Snap.unit) ret@441@01))))
      (and
        (<= 1 i@582@01)
        (<
          i@582@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@578@01
            $Snap.unit) ret@441@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@578@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@582@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2548@625@2548@1263-aux|)))
(assert (forall ((i@582@01 Int)) (!
  (=>
    (and
      (<= 1 i@582@01)
      (<
        i@582@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@578@01
          $Snap.unit) ret@441@01)))
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@568@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (-
        i@582@01
        1))
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
        $t@578@01
        ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@582@01)))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@578@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@582@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2548@625@2548@1263|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l53
; [exec]
; label l54
; [exec]
; label bb41
; [exec]
; __t24 := true
; [exec]
; _60 := builtin$havoc_ref()
(declare-const ret@583@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_60.val_ref, write)
(declare-const $t@584@01 $Ref)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@583@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@583@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@583@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@583@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _60.val_ref := _1
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@583@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@583@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@583@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l55
; [exec]
; label l56
; [exec]
; assert true
; [exec]
; exhale acc(_60.val_ref, write) &&
;   acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_60.val_ref), write)
; [exec]
; _59 := builtin$havoc_ref()
(declare-const ret@585@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l56](_60.val_ref)), write)
; [eval] old[l56](_60.val_ref)
(declare-const $t@586@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_59), write)
(declare-const $t@587@01 $Snap)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@448@01 ret@585@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@588@01 $Snap)
(assert (= $t@588@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_59)) &&
;   ((old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref)) ==
;   0) &&
;   ((old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_59)) &&
;   ((old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_59) ==
;   old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref,
;   0))) &&
;   ((old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref)) ==
;   old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref) -
;   1)) &&
;   (old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) >
;   0 ==>
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l56](_60.val_ref),
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref)) ==>
;     old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref,
;     i + 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l56](_60.val_ref),
;     i)))))))
(declare-const $t@589@01 $Snap)
(assert (= $t@589@01 ($Snap.combine ($Snap.first $t@589@01) ($Snap.second $t@589@01))))
(assert (= ($Snap.first $t@589@01) $Snap.unit))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_59)
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) == 0
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(pop) ; 13
; Joined path conditions
(set-option :timeout 0)
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 95 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) == 0 | dead]
; [else-branch: 95 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) != 0 | live]
(set-option :timeout 0)
(push) ; 14
; [else-branch: 95 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) != 0]
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0)))
(assert (=
  ($Snap.second $t@589@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@589@01))
    ($Snap.second ($Snap.second $t@589@01)))))
(assert (= ($Snap.first ($Snap.second $t@589@01)) $Snap.unit))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref)) == 0
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) == 0
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(pop) ; 13
; Joined path conditions
(set-option :timeout 0)
(push) ; 13
; [then-branch: 96 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) == 0 | dead]
; [else-branch: 96 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) != 0 | live]
(push) ; 14
; [else-branch: 96 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) != 0]
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@589@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@589@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@589@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@589@01))) $Snap.unit))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_59)
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) > 0
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(pop) ; 13
; Joined path conditions
(set-option :timeout 0)
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 14
(set-option :timeout 10)
(assert (not (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@578@01
    $Snap.unit) ret@441@01)
  0)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 97 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0 | live]
; [else-branch: 97 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 97 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0]
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@578@01
    $Snap.unit) ret@441@01)
  0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_59)
(push) ; 15
; [eval] read$()
(push) ; 16
(pop) ; 16
; Joined path conditions
(push) ; 16
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(push) ; 16
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@587@01
  $Snap.unit) ret@585@01))
(pop) ; 15
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@587@01
  $Snap.unit) ret@585@01))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (>
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@578@01
        $Snap.unit) ret@441@01)
      0)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@587@01
      $Snap.unit) ret@585@01))))
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@578@01
    $Snap.unit) ret@441@01)
  0))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@587@01
    $Snap.unit) ret@585@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@589@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@589@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@589@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@589@01))))
  $Snap.unit))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_59) == old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref, 0))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) > 0
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(pop) ; 13
; Joined path conditions
(set-option :timeout 0)
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 98 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0 | live]
; [else-branch: 98 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 98 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_59) == old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_59)
(push) ; 15
; [eval] read$()
(push) ; 16
(pop) ; 16
; Joined path conditions
(push) ; 16
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(push) ; 16
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_pure_1)
(set-option :timeout 0)
(push) ; 16
; [eval] read$()
(push) ; 17
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(push) ; 17
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@587@01
  $Snap.unit) ret@585@01))
(pop) ; 16
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@587@01
  $Snap.unit) ret@585@01))
(set-option :timeout 0)
(push) ; 16
(assert (not (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@587@01
  $Snap.unit) ret@585@01)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@587@01
  $Snap.unit) ret@585@01))
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@587@01
  $Snap.unit) ret@585@01))
(pop) ; 15
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
    $t@587@01
    $Snap.unit) ret@585@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@587@01
    $Snap.unit) ret@585@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@587@01
    $Snap.unit) ret@585@01)))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref, 0)
(push) ; 15
; [eval] read$()
(push) ; 16
(pop) ; 16
; Joined path conditions
(push) ; 16
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(push) ; 16
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 16
; [eval] read$()
(push) ; 17
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(push) ; 17
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(pop) ; 16
; Joined path conditions
; [eval] 0 <= _pure_2
(pop) ; 15
; Joined path conditions
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@587@01
      $Snap.unit) ret@585@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
      $t@587@01
      $Snap.unit) ret@585@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@587@01
      $Snap.unit) ret@585@01))))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@587@01
      $Snap.unit) ret@585@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
      $t@578@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@589@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@589@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@589@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@589@01)))))
  $Snap.unit))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref)) == old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref) - 1)
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) > 0
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(pop) ; 13
; Joined path conditions
(set-option :timeout 0)
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 99 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0 | live]
; [else-branch: 99 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 99 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref)) == old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref))
; [eval] old[l56](_60.val_ref)
(push) ; 15
; [eval] read$()
(push) ; 16
(pop) ; 16
; Joined path conditions
(push) ; 16
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(push) ; 16
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@586@01
  $Snap.unit) ret@441@01))
(pop) ; 15
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@586@01
  $Snap.unit) ret@441@01))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref) - 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)
(set-option :timeout 0)
(push) ; 15
; [eval] read$()
(push) ; 16
(pop) ; 16
; Joined path conditions
(push) ; 16
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(push) ; 16
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(pop) ; 15
; Joined path conditions
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@586@01
    $Snap.unit) ret@441@01)))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    (-
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@578@01
        $Snap.unit) ret@441@01)
      1))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@589@01)))))
  $Snap.unit))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) > 0 ==> (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l56](_60.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref)) ==> old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l56](_60.val_ref), i))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)) > 0
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_60.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(pop) ; 13
; Joined path conditions
(set-option :timeout 0)
(push) ; 13
(push) ; 14
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
; [then-branch: 100 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0 | live]
; [else-branch: 100 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 100 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@578@01, _), ret@441@01) > 0]
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l56](_60.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref)) ==> old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l56](_60.val_ref), i))
(declare-const i@590@01 Int)
(push) ; 15
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref)) ==> old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l56](_60.val_ref), i)
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref))
; [eval] 0 <= i
(push) ; 16
; [then-branch: 101 | !(0 <= i@590@01) | live]
; [else-branch: 101 | 0 <= i@590@01 | live]
(push) ; 17
; [then-branch: 101 | !(0 <= i@590@01)]
(assert (not (<= 0 i@590@01)))
(pop) ; 17
(push) ; 17
; [else-branch: 101 | 0 <= i@590@01]
(assert (<= 0 i@590@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l56](_60.val_ref))
; [eval] old[l56](_60.val_ref)
(push) ; 18
; [eval] read$()
(push) ; 19
(pop) ; 19
; Joined path conditions
(push) ; 19
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(push) ; 19
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@586@01
  $Snap.unit) ret@441@01))
(pop) ; 18
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@586@01
  $Snap.unit) ret@441@01))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 i@590@01)
  (and
    (<= 0 i@590@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01))))
(assert (or (<= 0 i@590@01) (not (<= 0 i@590@01))))
(set-option :timeout 0)
(push) ; 16
; [then-branch: 102 | 0 <= i@590@01 && i@590@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) | live]
; [else-branch: 102 | !(0 <= i@590@01 && i@590@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01)) | live]
(push) ; 17
; [then-branch: 102 | 0 <= i@590@01 && i@590@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01)]
(assert (and
  (<= 0 i@590@01)
  (<
    i@590@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01))))
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l56](_60.val_ref), i)
; [eval] old[l56](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref, i + 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_60.val_ref, i + 1)
; [eval] i + 1
(push) ; 18
; [eval] read$()
(push) ; 19
(pop) ; 19
; Joined path conditions
(push) ; 19
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(push) ; 19
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 19
(assert (not (<= 0 (+ i@590@01 1))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (+ i@590@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 19
; [eval] read$()
(push) ; 20
(pop) ; 20
; Joined path conditions
(push) ; 20
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(push) ; 20
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(pop) ; 19
; Joined path conditions
(set-option :timeout 0)
(push) ; 19
(assert (not (<
  (+ i@590@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@578@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (<
  (+ i@590@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@578@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@578@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
  i@590@01
  1)))
(pop) ; 18
; Joined path conditions
(assert (and
  (<= 0 (+ i@590@01 1))
  (<
    (+ i@590@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@578@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
    i@590@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l56](_60.val_ref), i)
; [eval] old[l56](_60.val_ref)
(push) ; 18
; [eval] read$()
(push) ; 19
(pop) ; 19
; Joined path conditions
(push) ; 19
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(push) ; 19
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 19
; [eval] read$()
(push) ; 20
(pop) ; 20
; Joined path conditions
(push) ; 20
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(push) ; 20
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@586@01
  $Snap.unit) ret@441@01))
(pop) ; 19
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@586@01
  $Snap.unit) ret@441@01))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@586@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@590@01))
(pop) ; 18
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@586@01
    $Snap.unit) ret@441@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@586@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@590@01)))
(pop) ; 17
(set-option :timeout 0)
(push) ; 17
; [else-branch: 102 | !(0 <= i@590@01 && i@590@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01))]
(assert (not
  (and
    (<= 0 i@590@01)
    (<
      i@590@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@586@01
        $Snap.unit) ret@441@01)))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (=>
  (and
    (<= 0 i@590@01)
    (<
      i@590@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@586@01
        $Snap.unit) ret@441@01)))
  (and
    (<= 0 i@590@01)
    (<
      i@590@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@586@01
        $Snap.unit) ret@441@01))
    (<= 0 (+ i@590@01 1))
    (<
      (+ i@590@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@578@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@578@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
      i@590@01
      1))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@586@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@590@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 0 i@590@01)
      (<
        i@590@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@586@01
          $Snap.unit) ret@441@01))))
  (and
    (<= 0 i@590@01)
    (<
      i@590@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@586@01
        $Snap.unit) ret@441@01)))))
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@590@01 Int)) (!
  (and
    (=>
      (<= 0 i@590@01)
      (and
        (<= 0 i@590@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          $t@586@01
          $Snap.unit) ret@441@01)))
    (or (<= 0 i@590@01) (not (<= 0 i@590@01)))
    (=>
      (and
        (<= 0 i@590@01)
        (<
          i@590@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@586@01
            $Snap.unit) ret@441@01)))
      (and
        (<= 0 i@590@01)
        (<
          i@590@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@586@01
            $Snap.unit) ret@441@01))
        (<= 0 (+ i@590@01 1))
        (<
          (+ i@590@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@578@01
            $Snap.unit) ret@441@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@578@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
          i@590@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          $t@586@01
          $Snap.unit) ret@441@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@586@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@590@01)))
    (or
      (not
        (and
          (<= 0 i@590@01)
          (<
            i@590@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@586@01
              $Snap.unit) ret@441@01))))
      (and
        (<= 0 i@590@01)
        (<
          i@590@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@586@01
            $Snap.unit) ret@441@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@586@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@590@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2578@2585@2578@3223-aux|)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0)
  (forall ((i@590@01 Int)) (!
    (and
      (=>
        (<= 0 i@590@01)
        (and
          (<= 0 i@590@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            $t@586@01
            $Snap.unit) ret@441@01)))
      (or (<= 0 i@590@01) (not (<= 0 i@590@01)))
      (=>
        (and
          (<= 0 i@590@01)
          (<
            i@590@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@586@01
              $Snap.unit) ret@441@01)))
        (and
          (<= 0 i@590@01)
          (<
            i@590@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@586@01
              $Snap.unit) ret@441@01))
          (<= 0 (+ i@590@01 1))
          (<
            (+ i@590@01 1)
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@578@01
              $Snap.unit) ret@441@01))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            $t@578@01
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
            i@590@01
            1))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            $t@586@01
            $Snap.unit) ret@441@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            $t@586@01
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@590@01)))
      (or
        (not
          (and
            (<= 0 i@590@01)
            (<
              i@590@01
              (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
                $t@586@01
                $Snap.unit) ret@441@01))))
        (and
          (<= 0 i@590@01)
          (<
            i@590@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@586@01
              $Snap.unit) ret@441@01)))))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      $t@586@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@590@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2578@2585@2578@3223-aux|))))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@578@01
      $Snap.unit) ret@441@01)
    0)
  (forall ((i@590@01 Int)) (!
    (=>
      (and
        (<= 0 i@590@01)
        (<
          i@590@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@586@01
            $Snap.unit) ret@441@01)))
      (=
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          $t@578@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
          i@590@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          $t@586@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@590@01)))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      $t@586@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@590@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2578@2585@2578@3223|))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l57
; [exec]
; label l58
; [exec]
; label bb43
; [exec]
; __t25 := true
; [exec]
; _61 := builtin$havoc_int()
(declare-const ret@591@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@592@01 $Snap)
(assert (= $t@592@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _61 := m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_59)
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_59)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@587@01 ret@585@01))
(pop) ; 13
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@587@01 ret@585@01))
(declare-const _61@593@01 Int)
(assert (=
  _61@593@01
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@587@01 ret@585@01)))
; [exec]
; _62 := builtin$havoc_ref()
(declare-const ret@594@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_62.val_ref, write)
(declare-const $t@595@01 $Ref)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@594@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@594@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@594@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@594@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _62.val_ref := _59
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@594@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@594@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@594@01)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_59), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(set-option :timeout 0)
(push) ; 13
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(push) ; 13
(set-option :timeout 10)
(assert (not (=
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(assert (not (or
  (=
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No)
  (<
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_62.val_ref), read$())
; [eval] read$()
(push) ; 13
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(declare-const $t@596@01 $Snap)
(declare-const $t@597@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit)))))
    (= $t@597@01 $t@587@01))
  (=> (< $Perm.No (read$ $Snap.unit)) (= $t@597@01 $t@596@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l59
; [exec]
; _64 := builtin$havoc_int()
(declare-const ret@598@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@599@01 $Snap)
(assert (= $t@599@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _64 := m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_62.val_ref)
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_62.val_ref)
(set-option :timeout 0)
(push) ; 13
; [eval] read$()
(push) ; 14
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(push) ; 14
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@597@01 ret@585@01))
(pop) ; 13
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@597@01 ret@585@01))
(declare-const _64@600@01 Int)
(assert (=
  _64@600@01
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@597@01 ret@585@01)))
; [exec]
; __t56 := _64
; [eval] __t56 == 0
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (not (= _64@600@01 0))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 13
(set-option :timeout 10)
(assert (not (= _64@600@01 0)))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 103 | _64@600@01 == 0 | live]
; [else-branch: 103 | _64@600@01 != 0 | dead]
(set-option :timeout 0)
(push) ; 13
; [then-branch: 103 | _64@600@01 == 0]
(assert (= _64@600@01 0))
; [exec]
; label l61
; [exec]
; label bb46
; [exec]
; __t26 := true
; [exec]
; label l62
(push) ; 14
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
; [then-branch: 104 | True | live]
; [else-branch: 104 | False | dead]
(set-option :timeout 0)
(push) ; 14
; [then-branch: 104 | True]
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_62.val_ref), read$())
; [eval] read$()
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(push) ; 15
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_59), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 15
(pop) ; 15
; Joined path conditions
(push) ; 15
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(declare-const $t@601@01 $Snap)
(declare-const $t@602@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@602@01 $t@597@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@602@01 $t@601@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb49
; [exec]
; __t29 := true
; [exec]
; _63 := builtin$havoc_int()
(declare-const ret@603@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@604@01 $Snap)
(assert (= $t@604@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_59), write)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))
    ($Perm.min
      (+
        (-
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          ($Perm.min
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            (read$ $Snap.unit)))
        (- $Perm.Write (read$ $Snap.unit)))
      $Perm.Write))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(assert (not (or
  (=
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No)
  (<
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (= $t@602@01 ($Snap.combine ($Snap.first $t@602@01) ($Snap.second $t@602@01))))
(push) ; 15
(set-option :timeout 10)
(assert (not (= ret@532@01 ret@585@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (= ret@499@01 ret@585@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@585@01 $Ref.null)))
(assert (=
  ($Snap.second $t@602@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@602@01))
    ($Snap.second ($Snap.second $t@602@01)))))
(assert (= ($Snap.first ($Snap.second $t@602@01)) $Snap.unit))
; [eval] 0 <= self.discriminant
(assert (<= 0 ($SortWrappers.$SnapToInt ($Snap.first $t@602@01))))
(assert (=
  ($Snap.second ($Snap.second $t@602@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@602@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@602@01))) $Snap.unit))
; [eval] self.discriminant <= 1
(assert (<= ($SortWrappers.$SnapToInt ($Snap.first $t@602@01)) 1))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@602@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@602@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))))
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (= ret@532@01 ret@585@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (= ret@499@01 ret@585@01)))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [eval] self.discriminant == 0
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@602@01)) 0))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 15
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@602@01)) 0)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
; [then-branch: 105 | First:($t@602@01) == 0 | live]
; [else-branch: 105 | First:($t@602@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 15
; [then-branch: 105 | First:($t@602@01) == 0]
(assert (= ($SortWrappers.$SnapToInt ($Snap.first $t@602@01)) 0))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger $t@602@01 ret@585@01))
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some(_59.enum_Some), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))))
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@549@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@516@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))
    $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))))
; [exec]
; unfold acc(i32(_59.enum_Some.f$0), write)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01))))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01))))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))
    $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (i32%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))))
; [exec]
; _63 := _59.enum_Some.f$0.val_int
(declare-const _63@605@01 Int)
(assert (=
  _63@605@01
  ($SortWrappers.$SnapToInt ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))))
; [exec]
; label l63
; [exec]
; _67 := builtin$havoc_int()
(declare-const ret@606@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@607@01 $Snap)
(assert (= $t@607@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _67 := _63
; [exec]
; label l64
; [exec]
; _66 := builtin$havoc_ref()
(declare-const ret@608@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_66.val_bool, write)
(declare-const $t@609@01 Bool)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@608@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _66.val_bool := _67 == 5
; [eval] _67 == 5
(declare-const val_bool@610@01 Bool)
(assert (= val_bool@610@01 (= _63@605@01 5)))
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@608@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [exec]
; _65 := builtin$havoc_ref()
(declare-const ret@611@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_65.val_bool, write)
(declare-const $t@612@01 Bool)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@611@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _65.val_bool := !_66.val_bool
; [eval] !_66.val_bool
(declare-const val_bool@613@01 Bool)
(assert (= val_bool@613@01 (not val_bool@610@01)))
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@611@01)))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [exec]
; __t57 := _65.val_bool
; [eval] !__t57
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not val_bool@613@01))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 16
(set-option :timeout 10)
(assert (not (not val_bool@613@01)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 106 | !(val_bool@613@01) | live]
; [else-branch: 106 | val_bool@613@01 | dead]
(set-option :timeout 0)
(push) ; 16
; [then-branch: 106 | !(val_bool@613@01)]
(assert (not val_bool@613@01))
; [exec]
; label l66
; [exec]
; label bb51
; [exec]
; __t31 := true
; [exec]
; _58 := builtin$havoc_ref()
(declare-const ret@614@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_58), write)
(declare-const $t@615@01 $Snap)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@577@01 ret@614@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@567@01 ret@614@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@561@01 ret@614@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@528@01 ret@614@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@491@01 ret@614@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@481@01 ret@614@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@614@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@614@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _78 := builtin$havoc_ref()
(declare-const ret@616@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_78.val_ref, write)
(declare-const $t@617@01 $Ref)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@616@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@616@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@616@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@616@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@616@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _78.val_ref := _1
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@616@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@616@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@616@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@616@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l67
; [exec]
; label l68
; [exec]
; assert true
; [exec]
; exhale acc(_78.val_ref, write) &&
;   acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_78.val_ref), write)
; [exec]
; _77 := builtin$havoc_ref()
(declare-const ret@618@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l68](_78.val_ref)), write)
; [eval] old[l68](_78.val_ref)
(declare-const $t@619@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_77), write)
(declare-const $t@620@01 $Snap)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@448@01 ret@618@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@621@01 $Snap)
(assert (= $t@621@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_77)) &&
;   ((old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref)) ==
;   0) &&
;   ((old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_77)) &&
;   ((old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_77) ==
;   old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref,
;   0))) &&
;   ((old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref)) ==
;   old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref) -
;   1)) &&
;   (old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) >
;   0 ==>
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l68](_78.val_ref),
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref)) ==>
;     old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref,
;     i + 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l68](_78.val_ref),
;     i)))))))
(declare-const $t@622@01 $Snap)
(assert (= $t@622@01 ($Snap.combine ($Snap.first $t@622@01) ($Snap.second $t@622@01))))
(assert (= ($Snap.first $t@622@01) $Snap.unit))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_77)
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) == 0
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)
(set-option :timeout 0)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@586@01
  $Snap.unit) ret@441@01))
(pop) ; 17
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@586@01
  $Snap.unit) ret@441@01))
(set-option :timeout 0)
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 107 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) == 0 | dead]
; [else-branch: 107 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) != 0 | live]
(set-option :timeout 0)
(push) ; 18
; [else-branch: 107 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) != 0]
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0)))
(assert (=
  ($Snap.second $t@622@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@622@01))
    ($Snap.second ($Snap.second $t@622@01)))))
(assert (= ($Snap.first ($Snap.second $t@622@01)) $Snap.unit))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref)) == 0
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) == 0
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(pop) ; 17
; Joined path conditions
(set-option :timeout 0)
(push) ; 17
; [then-branch: 108 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) == 0 | dead]
; [else-branch: 108 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) != 0 | live]
(push) ; 18
; [else-branch: 108 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) != 0]
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@622@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@622@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@622@01))) $Snap.unit))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_77)
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) > 0
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(pop) ; 17
; Joined path conditions
(set-option :timeout 0)
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 18
(set-option :timeout 10)
(assert (not (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@586@01
    $Snap.unit) ret@441@01)
  0)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 109 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0 | live]
; [else-branch: 109 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 109 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0]
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@586@01
    $Snap.unit) ret@441@01)
  0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_77)
(push) ; 19
; [eval] read$()
(push) ; 20
(pop) ; 20
; Joined path conditions
(push) ; 20
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(push) ; 20
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@620@01
  $Snap.unit) ret@618@01))
(pop) ; 19
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@620@01
  $Snap.unit) ret@618@01))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (>
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@586@01
        $Snap.unit) ret@441@01)
      0)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@620@01
      $Snap.unit) ret@618@01))))
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@586@01
    $Snap.unit) ret@441@01)
  0))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@620@01
    $Snap.unit) ret@618@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@622@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
  $Snap.unit))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_77) == old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref, 0))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) > 0
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)
(set-option :timeout 0)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(pop) ; 17
; Joined path conditions
(set-option :timeout 0)
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 110 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0 | live]
; [else-branch: 110 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 110 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_77) == old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_77)
(push) ; 19
; [eval] read$()
(push) ; 20
(pop) ; 20
; Joined path conditions
(push) ; 20
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(push) ; 20
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_pure_1)
(set-option :timeout 0)
(push) ; 20
; [eval] read$()
(push) ; 21
(pop) ; 21
; Joined path conditions
(push) ; 21
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(push) ; 21
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@620@01
  $Snap.unit) ret@618@01))
(pop) ; 20
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@620@01
  $Snap.unit) ret@618@01))
(set-option :timeout 0)
(push) ; 20
(assert (not (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@620@01
  $Snap.unit) ret@618@01)))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@620@01
  $Snap.unit) ret@618@01))
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@620@01
  $Snap.unit) ret@618@01))
(pop) ; 19
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
    $t@620@01
    $Snap.unit) ret@618@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@620@01
    $Snap.unit) ret@618@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@620@01
    $Snap.unit) ret@618@01)))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref, 0)
(push) ; 19
; [eval] read$()
(push) ; 20
(pop) ; 20
; Joined path conditions
(push) ; 20
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(push) ; 20
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 20
; [eval] read$()
(push) ; 21
(pop) ; 21
; Joined path conditions
(push) ; 21
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(push) ; 21
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(pop) ; 20
; Joined path conditions
(set-option :timeout 0)
(push) ; 20
(assert (not (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@586@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(assert (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@586@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@586@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))
(pop) ; 19
; Joined path conditions
(assert (and
  (<
    0
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@586@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@620@01
      $Snap.unit) ret@618@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
      $t@620@01
      $Snap.unit) ret@618@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@620@01
      $Snap.unit) ret@618@01)
    (<
      0
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@586@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@586@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@620@01
      $Snap.unit) ret@618@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
      $t@586@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))
  $Snap.unit))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref)) == old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref) - 1)
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) > 0
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(pop) ; 17
; Joined path conditions
(set-option :timeout 0)
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 111 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0 | live]
; [else-branch: 111 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 111 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref)) == old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref))
; [eval] old[l68](_78.val_ref)
(push) ; 19
; [eval] read$()
(push) ; 20
(pop) ; 20
; Joined path conditions
(push) ; 20
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(push) ; 20
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@619@01
  $Snap.unit) ret@441@01))
(pop) ; 19
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@619@01
  $Snap.unit) ret@441@01))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref) - 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)
(set-option :timeout 0)
(push) ; 19
; [eval] read$()
(push) ; 20
(pop) ; 20
; Joined path conditions
(push) ; 20
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(push) ; 20
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(pop) ; 19
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@619@01
    $Snap.unit) ret@441@01)))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    (-
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@586@01
        $Snap.unit) ret@441@01)
      1))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@622@01)))))
  $Snap.unit))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) > 0 ==> (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l68](_78.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref)) ==> old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l68](_78.val_ref), i))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)) > 0
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_78.val_ref)
(set-option :timeout 0)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(pop) ; 17
; Joined path conditions
(set-option :timeout 0)
(push) ; 17
(push) ; 18
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
; [then-branch: 112 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0 | live]
; [else-branch: 112 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 112 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@586@01, _), ret@441@01) > 0]
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l68](_78.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref)) ==> old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l68](_78.val_ref), i))
(declare-const i@623@01 Int)
(push) ; 19
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref)) ==> old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l68](_78.val_ref), i)
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref))
; [eval] 0 <= i
(push) ; 20
; [then-branch: 113 | !(0 <= i@623@01) | live]
; [else-branch: 113 | 0 <= i@623@01 | live]
(push) ; 21
; [then-branch: 113 | !(0 <= i@623@01)]
(assert (not (<= 0 i@623@01)))
(pop) ; 21
(push) ; 21
; [else-branch: 113 | 0 <= i@623@01]
(assert (<= 0 i@623@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l68](_78.val_ref))
; [eval] old[l68](_78.val_ref)
(push) ; 22
; [eval] read$()
(push) ; 23
(pop) ; 23
; Joined path conditions
(push) ; 23
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(push) ; 23
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@619@01
  $Snap.unit) ret@441@01))
(pop) ; 22
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@619@01
  $Snap.unit) ret@441@01))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 i@623@01)
  (and
    (<= 0 i@623@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01))))
(assert (or (<= 0 i@623@01) (not (<= 0 i@623@01))))
(set-option :timeout 0)
(push) ; 20
; [then-branch: 114 | 0 <= i@623@01 && i@623@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) | live]
; [else-branch: 114 | !(0 <= i@623@01 && i@623@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01)) | live]
(push) ; 21
; [then-branch: 114 | 0 <= i@623@01 && i@623@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01)]
(assert (and
  (<= 0 i@623@01)
  (<
    i@623@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01))))
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l68](_78.val_ref), i)
; [eval] old[l68](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref, i + 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_78.val_ref, i + 1)
; [eval] i + 1
(push) ; 22
; [eval] read$()
(push) ; 23
(pop) ; 23
; Joined path conditions
(push) ; 23
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(push) ; 23
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 23
(assert (not (<= 0 (+ i@623@01 1))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (+ i@623@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 23
; [eval] read$()
(push) ; 24
(pop) ; 24
; Joined path conditions
(push) ; 24
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(push) ; 24
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(pop) ; 23
; Joined path conditions
(set-option :timeout 0)
(push) ; 23
(assert (not (<
  (+ i@623@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@586@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (<
  (+ i@623@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@586@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@586@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
  i@623@01
  1)))
(pop) ; 22
; Joined path conditions
(assert (and
  (<= 0 (+ i@623@01 1))
  (<
    (+ i@623@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@586@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
    i@623@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l68](_78.val_ref), i)
; [eval] old[l68](_78.val_ref)
(push) ; 22
; [eval] read$()
(push) ; 23
(pop) ; 23
; Joined path conditions
(push) ; 23
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(push) ; 23
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 23
; [eval] read$()
(push) ; 24
(pop) ; 24
; Joined path conditions
(push) ; 24
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(push) ; 24
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@619@01
  $Snap.unit) ret@441@01))
(pop) ; 23
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@619@01
  $Snap.unit) ret@441@01))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@619@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@623@01))
(pop) ; 22
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@619@01
    $Snap.unit) ret@441@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@619@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@623@01)))
(pop) ; 21
(set-option :timeout 0)
(push) ; 21
; [else-branch: 114 | !(0 <= i@623@01 && i@623@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01))]
(assert (not
  (and
    (<= 0 i@623@01)
    (<
      i@623@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@619@01
        $Snap.unit) ret@441@01)))))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (=>
  (and
    (<= 0 i@623@01)
    (<
      i@623@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@619@01
        $Snap.unit) ret@441@01)))
  (and
    (<= 0 i@623@01)
    (<
      i@623@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@619@01
        $Snap.unit) ret@441@01))
    (<= 0 (+ i@623@01 1))
    (<
      (+ i@623@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@586@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@586@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
      i@623@01
      1))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@619@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@623@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 0 i@623@01)
      (<
        i@623@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@619@01
          $Snap.unit) ret@441@01))))
  (and
    (<= 0 i@623@01)
    (<
      i@623@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@619@01
        $Snap.unit) ret@441@01)))))
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@623@01 Int)) (!
  (and
    (=>
      (<= 0 i@623@01)
      (and
        (<= 0 i@623@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          $t@619@01
          $Snap.unit) ret@441@01)))
    (or (<= 0 i@623@01) (not (<= 0 i@623@01)))
    (=>
      (and
        (<= 0 i@623@01)
        (<
          i@623@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@619@01
            $Snap.unit) ret@441@01)))
      (and
        (<= 0 i@623@01)
        (<
          i@623@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@619@01
            $Snap.unit) ret@441@01))
        (<= 0 (+ i@623@01 1))
        (<
          (+ i@623@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@586@01
            $Snap.unit) ret@441@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@586@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
          i@623@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          $t@619@01
          $Snap.unit) ret@441@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@619@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@623@01)))
    (or
      (not
        (and
          (<= 0 i@623@01)
          (<
            i@623@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@619@01
              $Snap.unit) ret@441@01))))
      (and
        (<= 0 i@623@01)
        (<
          i@623@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@619@01
            $Snap.unit) ret@441@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@619@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@623@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2742@2585@2742@3223-aux|)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0)
  (forall ((i@623@01 Int)) (!
    (and
      (=>
        (<= 0 i@623@01)
        (and
          (<= 0 i@623@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            $t@619@01
            $Snap.unit) ret@441@01)))
      (or (<= 0 i@623@01) (not (<= 0 i@623@01)))
      (=>
        (and
          (<= 0 i@623@01)
          (<
            i@623@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@619@01
              $Snap.unit) ret@441@01)))
        (and
          (<= 0 i@623@01)
          (<
            i@623@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@619@01
              $Snap.unit) ret@441@01))
          (<= 0 (+ i@623@01 1))
          (<
            (+ i@623@01 1)
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@586@01
              $Snap.unit) ret@441@01))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            $t@586@01
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
            i@623@01
            1))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            $t@619@01
            $Snap.unit) ret@441@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            $t@619@01
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@623@01)))
      (or
        (not
          (and
            (<= 0 i@623@01)
            (<
              i@623@01
              (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
                $t@619@01
                $Snap.unit) ret@441@01))))
        (and
          (<= 0 i@623@01)
          (<
            i@623@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@619@01
              $Snap.unit) ret@441@01)))))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      $t@619@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@623@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2742@2585@2742@3223-aux|))))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@586@01
      $Snap.unit) ret@441@01)
    0)
  (forall ((i@623@01 Int)) (!
    (=>
      (and
        (<= 0 i@623@01)
        (<
          i@623@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@619@01
            $Snap.unit) ret@441@01)))
      (=
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          $t@586@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
          i@623@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          $t@619@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@623@01)))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      $t@619@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@623@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2742@2585@2742@3223|))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l69
; [exec]
; label l70
; [exec]
; label bb54
; [exec]
; __t32 := true
; [exec]
; _79 := builtin$havoc_int()
(declare-const ret@624@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@625@01 $Snap)
(assert (= $t@625@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _79 := m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_77)
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_77)
(set-option :timeout 0)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@620@01 ret@618@01))
(pop) ; 17
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@620@01 ret@618@01))
(declare-const _79@626@01 Int)
(assert (=
  _79@626@01
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@620@01 ret@618@01)))
; [exec]
; _80 := builtin$havoc_ref()
(declare-const ret@627@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_80.val_ref, write)
(declare-const $t@628@01 $Ref)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@627@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@627@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@627@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@627@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@627@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _80.val_ref := _77
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@627@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@627@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@627@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@627@01)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_77), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(set-option :timeout 0)
(push) ; 17
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(push) ; 17
(set-option :timeout 10)
(assert (not (=
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(assert (not (or
  (=
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No)
  (<
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_80.val_ref), read$())
; [eval] read$()
(push) ; 17
(pop) ; 17
; Joined path conditions
(push) ; 17
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(declare-const $t@629@01 $Snap)
(declare-const $t@630@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit)))))
    (= $t@630@01 $t@620@01))
  (=> (< $Perm.No (read$ $Snap.unit)) (= $t@630@01 $t@629@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l71
; [exec]
; _82 := builtin$havoc_int()
(declare-const ret@631@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@632@01 $Snap)
(assert (= $t@632@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _82 := m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_80.val_ref)
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_80.val_ref)
(set-option :timeout 0)
(push) ; 17
; [eval] read$()
(push) ; 18
(pop) ; 18
; Joined path conditions
(push) ; 18
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(push) ; 18
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@630@01 ret@618@01))
(pop) ; 17
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@630@01 ret@618@01))
(declare-const _82@633@01 Int)
(assert (=
  _82@633@01
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@630@01 ret@618@01)))
; [exec]
; __t58 := _82
; [eval] __t58 == 0
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (not (= _82@633@01 0))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 17
(set-option :timeout 10)
(assert (not (= _82@633@01 0)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 115 | _82@633@01 == 0 | live]
; [else-branch: 115 | _82@633@01 != 0 | dead]
(set-option :timeout 0)
(push) ; 17
; [then-branch: 115 | _82@633@01 == 0]
(assert (= _82@633@01 0))
; [exec]
; label l73
; [exec]
; label bb57
; [exec]
; __t33 := true
; [exec]
; label l74
(push) ; 18
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
; [then-branch: 116 | True | live]
; [else-branch: 116 | False | dead]
(set-option :timeout 0)
(push) ; 18
; [then-branch: 116 | True]
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_80.val_ref), read$())
; [eval] read$()
(push) ; 19
(pop) ; 19
; Joined path conditions
(push) ; 19
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(push) ; 19
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_77), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 19
(pop) ; 19
; Joined path conditions
(push) ; 19
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(declare-const $t@634@01 $Snap)
(declare-const $t@635@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@635@01 $t@630@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@635@01 $t@634@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb60
; [exec]
; __t36 := true
; [exec]
; _81 := builtin$havoc_int()
(declare-const ret@636@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@637@01 $Snap)
(assert (= $t@637@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_77), write)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))
    ($Perm.min
      (+
        (-
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          ($Perm.min
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            (read$ $Snap.unit)))
        (- $Perm.Write (read$ $Snap.unit)))
      $Perm.Write))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(assert (not (or
  (=
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No)
  (<
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (= $t@635@01 ($Snap.combine ($Snap.first $t@635@01) ($Snap.second $t@635@01))))
(push) ; 19
(set-option :timeout 10)
(assert (not (= ret@585@01 ret@618@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (= ret@532@01 ret@618@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (= ret@499@01 ret@618@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@618@01 $Ref.null)))
(assert (=
  ($Snap.second $t@635@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@635@01))
    ($Snap.second ($Snap.second $t@635@01)))))
(assert (= ($Snap.first ($Snap.second $t@635@01)) $Snap.unit))
; [eval] 0 <= self.discriminant
(assert (<= 0 ($SortWrappers.$SnapToInt ($Snap.first $t@635@01))))
(assert (=
  ($Snap.second ($Snap.second $t@635@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@635@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@635@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@635@01))) $Snap.unit))
; [eval] self.discriminant <= 1
(assert (<= ($SortWrappers.$SnapToInt ($Snap.first $t@635@01)) 1))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@635@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@635@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01)))))))
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (= ret@585@01 ret@618@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (= ret@532@01 ret@618@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (= ret@499@01 ret@618@01)))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [eval] self.discriminant == 0
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@635@01)) 0))))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 19
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@635@01)) 0)))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
; [then-branch: 117 | First:($t@635@01) == 0 | live]
; [else-branch: 117 | First:($t@635@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 19
; [then-branch: 117 | First:($t@635@01) == 0]
(assert (= ($SortWrappers.$SnapToInt ($Snap.first $t@635@01)) 0))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger $t@635@01 ret@618@01))
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some(_77.enum_Some), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01))))))))
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@635@01))))))))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@549@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@635@01))))))))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@516@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@635@01))))))))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@635@01)))))
    $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@635@01)))))))
; [exec]
; unfold acc(i32(_77.enum_Some.f$0), write)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01)))))))))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01))))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01)))))))))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01))))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01)))))))))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01))))))
    $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (i32%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01))))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01))))))))
; [exec]
; _81 := _77.enum_Some.f$0.val_int
(declare-const _81@638@01 Int)
(assert (=
  _81@638@01
  ($SortWrappers.$SnapToInt ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01))))))))
; [exec]
; label l75
; [exec]
; _85 := builtin$havoc_int()
(declare-const ret@639@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@640@01 $Snap)
(assert (= $t@640@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _85 := _81
; [exec]
; label l76
; [exec]
; _84 := builtin$havoc_ref()
(declare-const ret@641@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_84.val_bool, write)
(declare-const $t@642@01 Bool)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@641@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _84.val_bool := _85 == 4
; [eval] _85 == 4
(declare-const val_bool@643@01 Bool)
(assert (= val_bool@643@01 (= _81@638@01 4)))
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@641@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [exec]
; _83 := builtin$havoc_ref()
(declare-const ret@644@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_83.val_bool, write)
(declare-const $t@645@01 Bool)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@641@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@644@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _83.val_bool := !_84.val_bool
; [eval] !_84.val_bool
(declare-const val_bool@646@01 Bool)
(assert (= val_bool@646@01 (not val_bool@643@01)))
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@641@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@644@01)))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [exec]
; __t59 := _83.val_bool
; [eval] !__t59
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not val_bool@646@01))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 20
(set-option :timeout 10)
(assert (not (not val_bool@646@01)))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 118 | !(val_bool@646@01) | live]
; [else-branch: 118 | val_bool@646@01 | dead]
(set-option :timeout 0)
(push) ; 20
; [then-branch: 118 | !(val_bool@646@01)]
(assert (not val_bool@646@01))
; [exec]
; label l78
; [exec]
; label bb62
; [exec]
; __t38 := true
; [exec]
; _76 := builtin$havoc_ref()
(declare-const ret@647@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_76), write)
(declare-const $t@648@01 $Snap)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@614@01 ret@647@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@577@01 ret@647@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@567@01 ret@647@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@561@01 ret@647@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@528@01 ret@647@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@491@01 ret@647@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@481@01 ret@647@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@647@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@647@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _96 := builtin$havoc_ref()
(declare-const ret@649@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_96.val_ref, write)
(declare-const $t@650@01 $Ref)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@627@01 ret@649@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@649@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@649@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@649@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@649@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@649@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _96.val_ref := _1
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@627@01 ret@649@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@649@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@649@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@649@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@649@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l79
; [exec]
; label l80
; [exec]
; assert true
; [exec]
; exhale acc(_96.val_ref, write) &&
;   acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_96.val_ref), write)
; [exec]
; _95 := builtin$havoc_ref()
(declare-const ret@651@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l80](_96.val_ref)), write)
; [eval] old[l80](_96.val_ref)
(declare-const $t@652@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_95), write)
(declare-const $t@653@01 $Snap)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@448@01 ret@651@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@654@01 $Snap)
(assert (= $t@654@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_95)) &&
;   ((old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref)) ==
;   0) &&
;   ((old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_95)) &&
;   ((old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_95) ==
;   old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref,
;   0))) &&
;   ((old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref)) ==
;   old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref) -
;   1)) &&
;   (old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) >
;   0 ==>
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l80](_96.val_ref),
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref)) ==>
;     old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref,
;     i + 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l80](_96.val_ref),
;     i)))))))
(declare-const $t@655@01 $Snap)
(assert (= $t@655@01 ($Snap.combine ($Snap.first $t@655@01) ($Snap.second $t@655@01))))
(assert (= ($Snap.first $t@655@01) $Snap.unit))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_95)
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) == 0
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)
(set-option :timeout 0)
(push) ; 21
; [eval] read$()
(push) ; 22
(pop) ; 22
; Joined path conditions
(push) ; 22
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(push) ; 22
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@619@01
  $Snap.unit) ret@441@01))
(pop) ; 21
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@619@01
  $Snap.unit) ret@441@01))
(set-option :timeout 0)
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 119 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) == 0 | dead]
; [else-branch: 119 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) != 0 | live]
(set-option :timeout 0)
(push) ; 22
; [else-branch: 119 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) != 0]
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0)))
(assert (=
  ($Snap.second $t@655@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@655@01))
    ($Snap.second ($Snap.second $t@655@01)))))
(assert (= ($Snap.first ($Snap.second $t@655@01)) $Snap.unit))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref)) == 0
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) == 0
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)
(push) ; 21
; [eval] read$()
(push) ; 22
(pop) ; 22
; Joined path conditions
(push) ; 22
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(push) ; 22
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(pop) ; 21
; Joined path conditions
(set-option :timeout 0)
(push) ; 21
; [then-branch: 120 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) == 0 | dead]
; [else-branch: 120 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) != 0 | live]
(push) ; 22
; [else-branch: 120 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) != 0]
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second $t@655@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@655@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@655@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@655@01))) $Snap.unit))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_95)
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) > 0
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)
(push) ; 21
; [eval] read$()
(push) ; 22
(pop) ; 22
; Joined path conditions
(push) ; 22
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(push) ; 22
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(pop) ; 21
; Joined path conditions
(set-option :timeout 0)
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 22
(set-option :timeout 10)
(assert (not (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@619@01
    $Snap.unit) ret@441@01)
  0)))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 121 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0 | live]
; [else-branch: 121 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 121 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0]
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@619@01
    $Snap.unit) ret@441@01)
  0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_95)
(push) ; 23
; [eval] read$()
(push) ; 24
(pop) ; 24
; Joined path conditions
(push) ; 24
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(push) ; 24
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@653@01
  $Snap.unit) ret@651@01))
(pop) ; 23
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@653@01
  $Snap.unit) ret@651@01))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (>
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@619@01
        $Snap.unit) ret@441@01)
      0)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@653@01
      $Snap.unit) ret@651@01))))
(assert (>
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@619@01
    $Snap.unit) ret@441@01)
  0))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@653@01
    $Snap.unit) ret@651@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@655@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@655@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@655@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@655@01))))
  $Snap.unit))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_95) == old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref, 0))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) > 0
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)
(set-option :timeout 0)
(push) ; 21
; [eval] read$()
(push) ; 22
(pop) ; 22
; Joined path conditions
(push) ; 22
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(push) ; 22
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(pop) ; 21
; Joined path conditions
(set-option :timeout 0)
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 122 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0 | live]
; [else-branch: 122 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 122 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_95) == old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_95)
(push) ; 23
; [eval] read$()
(push) ; 24
(pop) ; 24
; Joined path conditions
(push) ; 24
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(push) ; 24
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_pure_1)
(set-option :timeout 0)
(push) ; 24
; [eval] read$()
(push) ; 25
(pop) ; 25
; Joined path conditions
(push) ; 25
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(push) ; 25
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@653@01
  $Snap.unit) ret@651@01))
(pop) ; 24
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@653@01
  $Snap.unit) ret@651@01))
(set-option :timeout 0)
(push) ; 24
(assert (not (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@653@01
  $Snap.unit) ret@651@01)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
  $t@653@01
  $Snap.unit) ret@651@01))
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@653@01
  $Snap.unit) ret@651@01))
(pop) ; 23
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
    $t@653@01
    $Snap.unit) ret@651@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@653@01
    $Snap.unit) ret@651@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@653@01
    $Snap.unit) ret@651@01)))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref, 0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref, 0)
(push) ; 23
; [eval] read$()
(push) ; 24
(pop) ; 24
; Joined path conditions
(push) ; 24
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(push) ; 24
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 24
; [eval] read$()
(push) ; 25
(pop) ; 25
; Joined path conditions
(push) ; 25
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(push) ; 25
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(pop) ; 24
; Joined path conditions
(set-option :timeout 0)
(push) ; 24
(assert (not (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@619@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (<
  0
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@619@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@619@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))
(pop) ; 23
; Joined path conditions
(assert (and
  (<
    0
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@619@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@653@01
      $Snap.unit) ret@651@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
      $t@653@01
      $Snap.unit) ret@651@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@653@01
      $Snap.unit) ret@651@01)
    (<
      0
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@619@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@619@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@653@01
      $Snap.unit) ret@651@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
      $t@619@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 0))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@655@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@655@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@655@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@655@01)))))
  $Snap.unit))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref)) == old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref) - 1)
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) > 0
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)
(push) ; 21
; [eval] read$()
(push) ; 22
(pop) ; 22
; Joined path conditions
(push) ; 22
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(push) ; 22
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(pop) ; 21
; Joined path conditions
(set-option :timeout 0)
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 123 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0 | live]
; [else-branch: 123 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 123 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref)) == old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref))
; [eval] old[l80](_96.val_ref)
(push) ; 23
; [eval] read$()
(push) ; 24
(pop) ; 24
; Joined path conditions
(push) ; 24
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(push) ; 24
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@652@01
  $Snap.unit) ret@441@01))
(pop) ; 23
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@652@01
  $Snap.unit) ret@441@01))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref) - 1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref) - 1
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)
(set-option :timeout 0)
(push) ; 23
; [eval] read$()
(push) ; 24
(pop) ; 24
; Joined path conditions
(push) ; 24
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(push) ; 24
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(pop) ; 23
; Joined path conditions
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@652@01
    $Snap.unit) ret@441@01)))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    (-
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@619@01
        $Snap.unit) ret@441@01)
      1))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@655@01)))))
  $Snap.unit))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) > 0 ==> (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l80](_96.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref)) ==> old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l80](_96.val_ref), i))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)) > 0
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_96.val_ref)
(set-option :timeout 0)
(push) ; 21
; [eval] read$()
(push) ; 22
(pop) ; 22
; Joined path conditions
(push) ; 22
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(push) ; 22
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(pop) ; 21
; Joined path conditions
(set-option :timeout 0)
(push) ; 21
(push) ; 22
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
; [then-branch: 124 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0 | live]
; [else-branch: 124 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0) | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 124 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@619@01, _), ret@441@01) > 0]
; [eval] (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l80](_96.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref)) ==> old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l80](_96.val_ref), i))
(declare-const i@656@01 Int)
(push) ; 23
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref)) ==> old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l80](_96.val_ref), i)
; [eval] 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref))
; [eval] 0 <= i
(push) ; 24
; [then-branch: 125 | !(0 <= i@656@01) | live]
; [else-branch: 125 | 0 <= i@656@01 | live]
(push) ; 25
; [then-branch: 125 | !(0 <= i@656@01)]
(assert (not (<= 0 i@656@01)))
(pop) ; 25
(push) ; 25
; [else-branch: 125 | 0 <= i@656@01]
(assert (<= 0 i@656@01))
; [eval] i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l80](_96.val_ref))
; [eval] old[l80](_96.val_ref)
(push) ; 26
; [eval] read$()
(push) ; 27
(pop) ; 27
; Joined path conditions
(push) ; 27
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(push) ; 27
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@652@01
  $Snap.unit) ret@441@01))
(pop) ; 26
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@652@01
  $Snap.unit) ret@441@01))
(pop) ; 25
(pop) ; 24
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 i@656@01)
  (and
    (<= 0 i@656@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01))))
(assert (or (<= 0 i@656@01) (not (<= 0 i@656@01))))
(set-option :timeout 0)
(push) ; 24
; [then-branch: 126 | 0 <= i@656@01 && i@656@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) | live]
; [else-branch: 126 | !(0 <= i@656@01 && i@656@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01)) | live]
(push) ; 25
; [then-branch: 126 | 0 <= i@656@01 && i@656@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01)]
(assert (and
  (<= 0 i@656@01)
  (<
    i@656@01
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01))))
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l80](_96.val_ref), i)
; [eval] old[l80](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref, i + 1))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_96.val_ref, i + 1)
; [eval] i + 1
(push) ; 26
; [eval] read$()
(push) ; 27
(pop) ; 27
; Joined path conditions
(push) ; 27
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(push) ; 27
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
(set-option :timeout 0)
(push) ; 27
(assert (not (<= 0 (+ i@656@01 1))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(assert (<= 0 (+ i@656@01 1)))
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(push) ; 27
; [eval] read$()
(push) ; 28
(pop) ; 28
; Joined path conditions
(push) ; 28
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(push) ; 28
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(pop) ; 27
; Joined path conditions
(set-option :timeout 0)
(push) ; 27
(assert (not (<
  (+ i@656@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@619@01
    $Snap.unit) ret@441@01))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(assert (<
  (+ i@656@01 1)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@619@01
    $Snap.unit) ret@441@01)))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@619@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
  i@656@01
  1)))
(pop) ; 26
; Joined path conditions
(assert (and
  (<= 0 (+ i@656@01 1))
  (<
    (+ i@656@01 1)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01))
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@619@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
    i@656@01
    1))))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l80](_96.val_ref), i)
; [eval] old[l80](_96.val_ref)
(push) ; 26
; [eval] read$()
(push) ; 27
(pop) ; 27
; Joined path conditions
(push) ; 27
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(push) ; 27
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; [eval] 0 <= _pure_2
; [eval] _pure_2 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_pure_1)
(set-option :timeout 0)
(push) ; 27
; [eval] read$()
(push) ; 28
(pop) ; 28
; Joined path conditions
(push) ; 28
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(push) ; 28
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@652@01
  $Snap.unit) ret@441@01))
(pop) ; 27
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@652@01
  $Snap.unit) ret@441@01))
; [eval] 0 <= _pure_2
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
  $t@652@01
  ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@656@01))
(pop) ; 26
; Joined path conditions
(assert (and
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@652@01
    $Snap.unit) ret@441@01)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
    $t@652@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@656@01)))
(pop) ; 25
(set-option :timeout 0)
(push) ; 25
; [else-branch: 126 | !(0 <= i@656@01 && i@656@01 < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01))]
(assert (not
  (and
    (<= 0 i@656@01)
    (<
      i@656@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@652@01
        $Snap.unit) ret@441@01)))))
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (=>
  (and
    (<= 0 i@656@01)
    (<
      i@656@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@652@01
        $Snap.unit) ret@441@01)))
  (and
    (<= 0 i@656@01)
    (<
      i@656@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@652@01
        $Snap.unit) ret@441@01))
    (<= 0 (+ i@656@01 1))
    (<
      (+ i@656@01 1)
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@619@01
        $Snap.unit) ret@441@01))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@619@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
      i@656@01
      1))
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
      $t@652@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@656@01))))
; Joined path conditions
(assert (or
  (not
    (and
      (<= 0 i@656@01)
      (<
        i@656@01
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
          $t@652@01
          $Snap.unit) ret@441@01))))
  (and
    (<= 0 i@656@01)
    (<
      i@656@01
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@652@01
        $Snap.unit) ret@441@01)))))
(pop) ; 23
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i@656@01 Int)) (!
  (and
    (=>
      (<= 0 i@656@01)
      (and
        (<= 0 i@656@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          $t@652@01
          $Snap.unit) ret@441@01)))
    (or (<= 0 i@656@01) (not (<= 0 i@656@01)))
    (=>
      (and
        (<= 0 i@656@01)
        (<
          i@656@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@652@01
            $Snap.unit) ret@441@01)))
      (and
        (<= 0 i@656@01)
        (<
          i@656@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@652@01
            $Snap.unit) ret@441@01))
        (<= 0 (+ i@656@01 1))
        (<
          (+ i@656@01 1)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@619@01
            $Snap.unit) ret@441@01))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@619@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
          i@656@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
          $t@652@01
          $Snap.unit) ret@441@01)
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
          $t@652@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@656@01)))
    (or
      (not
        (and
          (<= 0 i@656@01)
          (<
            i@656@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@652@01
              $Snap.unit) ret@441@01))))
      (and
        (<= 0 i@656@01)
        (<
          i@656@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@652@01
            $Snap.unit) ret@441@01)))))
  :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
    $t@652@01
    ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@656@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2906@2585@2906@3223-aux|)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0)
  (forall ((i@656@01 Int)) (!
    (and
      (=>
        (<= 0 i@656@01)
        (and
          (<= 0 i@656@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            $t@652@01
            $Snap.unit) ret@441@01)))
      (or (<= 0 i@656@01) (not (<= 0 i@656@01)))
      (=>
        (and
          (<= 0 i@656@01)
          (<
            i@656@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@652@01
              $Snap.unit) ret@441@01)))
        (and
          (<= 0 i@656@01)
          (<
            i@656@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@652@01
              $Snap.unit) ret@441@01))
          (<= 0 (+ i@656@01 1))
          (<
            (+ i@656@01 1)
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@619@01
              $Snap.unit) ret@441@01))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            $t@619@01
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
            i@656@01
            1))
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
            $t@652@01
            $Snap.unit) ret@441@01)
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%precondition ($Snap.combine
            $t@652@01
            ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@656@01)))
      (or
        (not
          (and
            (<= 0 i@656@01)
            (<
              i@656@01
              (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
                $t@652@01
                $Snap.unit) ret@441@01))))
        (and
          (<= 0 i@656@01)
          (<
            i@656@01
            (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
              $t@652@01
              $Snap.unit) ret@441@01)))))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      $t@652@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@656@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2906@2585@2906@3223-aux|))))
(assert (=>
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@619@01
      $Snap.unit) ret@441@01)
    0)
  (forall ((i@656@01 Int)) (!
    (=>
      (and
        (<= 0 i@656@01)
        (<
          i@656@01
          (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
            $t@652@01
            $Snap.unit) ret@441@01)))
      (=
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          $t@619@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 (+
          i@656@01
          1))
        (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$ ($Snap.combine
          $t@652@01
          ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@656@01)))
    :pattern ((m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$%limited ($Snap.combine
      $t@652@01
      ($Snap.combine $Snap.unit ($Snap.combine $Snap.unit $Snap.unit))) ret@441@01 i@656@01))
    :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/frontends/prusti/first-final.rs.vpr@2906@2585@2906@3223|))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l81
; [exec]
; label l82
; [exec]
; label bb65
; [exec]
; __t39 := true
; [exec]
; _97 := builtin$havoc_int()
(declare-const ret@657@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@658@01 $Snap)
(assert (= $t@658@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _97 := m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_95)
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_95)
(set-option :timeout 0)
(push) ; 21
; [eval] read$()
(push) ; 22
(pop) ; 22
; Joined path conditions
(push) ; 22
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(push) ; 22
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@653@01 ret@651@01))
(pop) ; 21
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@653@01 ret@651@01))
(declare-const _97@659@01 Int)
(assert (=
  _97@659@01
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@653@01 ret@651@01)))
; [exec]
; _98 := builtin$havoc_ref()
(declare-const ret@660@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_98.val_ref, write)
(declare-const $t@661@01 $Ref)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@627@01 ret@660@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@660@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@660@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@660@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@660@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@660@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _98.val_ref := _95
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@627@01 ret@660@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@660@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@660@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@660@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@660@01)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_95), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(set-option :timeout 0)
(push) ; 21
(pop) ; 21
; Joined path conditions
(push) ; 21
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(push) ; 21
(set-option :timeout 10)
(assert (not (=
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(assert (not (or
  (=
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No)
  (<
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_98.val_ref), read$())
; [eval] read$()
(push) ; 21
(pop) ; 21
; Joined path conditions
(push) ; 21
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(declare-const $t@662@01 $Snap)
(declare-const $t@663@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit)))))
    (= $t@663@01 $t@653@01))
  (=> (< $Perm.No (read$ $Snap.unit)) (= $t@663@01 $t@662@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l83
; [exec]
; _100 := builtin$havoc_int()
(declare-const ret@664@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@665@01 $Snap)
(assert (= $t@665@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _100 := m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_98.val_ref)
; [eval] m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_98.val_ref)
(set-option :timeout 0)
(push) ; 21
; [eval] read$()
(push) ; 22
(pop) ; 22
; Joined path conditions
(push) ; 22
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(push) ; 22
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(push) ; 22
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@663@01 ret@651@01))
(pop) ; 21
; Joined path conditions
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition $t@663@01 ret@651@01))
(declare-const _100@666@01 Int)
(assert (=
  _100@666@01
  (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$discriminant$$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$ $t@663@01 ret@651@01)))
; [exec]
; __t60 := _100
; [eval] __t60 == 0
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (not (= _100@666@01 0))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 21
(set-option :timeout 10)
(assert (not (= _100@666@01 0)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 127 | _100@666@01 == 0 | live]
; [else-branch: 127 | _100@666@01 != 0 | dead]
(set-option :timeout 0)
(push) ; 21
; [then-branch: 127 | _100@666@01 == 0]
(assert (= _100@666@01 0))
; [exec]
; label l85
; [exec]
; label bb68
; [exec]
; __t40 := true
; [exec]
; label l86
(push) ; 22
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
; [then-branch: 128 | True | live]
; [else-branch: 128 | False | dead]
(set-option :timeout 0)
(push) ; 22
; [then-branch: 128 | True]
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_98.val_ref), read$())
; [eval] read$()
(push) ; 23
(pop) ; 23
; Joined path conditions
(push) ; 23
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(push) ; 23
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_95), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 23
(pop) ; 23
; Joined path conditions
(push) ; 23
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(declare-const $t@667@01 $Snap)
(declare-const $t@668@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@668@01 $t@663@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@668@01 $t@667@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb71
; [exec]
; __t43 := true
; [exec]
; _99 := builtin$havoc_int()
(declare-const ret@669@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@670@01 $Snap)
(assert (= $t@670@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_95), write)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit)))
      (- $Perm.Write (read$ $Snap.unit)))
    ($Perm.min
      (+
        (-
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          ($Perm.min
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            (read$ $Snap.unit)))
        (- $Perm.Write (read$ $Snap.unit)))
      $Perm.Write))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(assert (not (or
  (=
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No)
  (<
    (-
      $Perm.Write
      ($Perm.min
        (+
          (-
            (+
              (-
                $Perm.Write
                ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
              (read$ $Snap.unit))
            ($Perm.min
              (+
                (-
                  $Perm.Write
                  ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
                (read$ $Snap.unit))
              (read$ $Snap.unit)))
          (- $Perm.Write (read$ $Snap.unit)))
        $Perm.Write))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (= $t@668@01 ($Snap.combine ($Snap.first $t@668@01) ($Snap.second $t@668@01))))
(push) ; 23
(set-option :timeout 10)
(assert (not (= ret@618@01 ret@651@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (= ret@585@01 ret@651@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (= ret@532@01 ret@651@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (= ret@499@01 ret@651@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@651@01 $Ref.null)))
(assert (=
  ($Snap.second $t@668@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@668@01))
    ($Snap.second ($Snap.second $t@668@01)))))
(assert (= ($Snap.first ($Snap.second $t@668@01)) $Snap.unit))
; [eval] 0 <= self.discriminant
(assert (<= 0 ($SortWrappers.$SnapToInt ($Snap.first $t@668@01))))
(assert (=
  ($Snap.second ($Snap.second $t@668@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@668@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@668@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@668@01))) $Snap.unit))
; [eval] self.discriminant <= 1
(assert (<= ($SortWrappers.$SnapToInt ($Snap.first $t@668@01)) 1))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@668@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@668@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01)))))))
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (= ret@618@01 ret@651@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (= ret@585@01 ret@651@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (= ret@532@01 ret@651@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (= ret@499@01 ret@651@01)))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [eval] self.discriminant == 0
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@668@01)) 0))))
(check-sat)
; unknown
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 23
(set-option :timeout 10)
(assert (not (= ($SortWrappers.$SnapToInt ($Snap.first $t@668@01)) 0)))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
; [then-branch: 129 | First:($t@668@01) == 0 | live]
; [else-branch: 129 | First:($t@668@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 23
; [then-branch: 129 | First:($t@668@01) == 0]
(assert (= ($SortWrappers.$SnapToInt ($Snap.first $t@668@01)) 0))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_%trigger $t@668@01 ret@651@01))
; [exec]
; unfold acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some(_95.enum_Some), write)
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01))))))))
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@635@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@668@01))))))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@602@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@668@01))))))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@549@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@668@01))))))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@516@01)))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@668@01))))))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@668@01)))))
    $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_Some%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01)))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@668@01)))))))
; [exec]
; unfold acc(i32(_95.enum_Some.f$0), write)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@635@01))))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01)))))))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@602@01))))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01)))))))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@549@01))))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01)))))))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (=
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@516@01))))))
  ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01)))))))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (not
  (=
    ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01))))))
    $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (i32%trigger ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01))))) ($SortWrappers.$SnapTo$Ref ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01))))))))
; [exec]
; _99 := _95.enum_Some.f$0.val_int
(declare-const _99@671@01 Int)
(assert (=
  _99@671@01
  ($SortWrappers.$SnapToInt ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@668@01))))))))
; [exec]
; label l87
; [exec]
; _103 := builtin$havoc_int()
(declare-const ret@672@01 Int)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@673@01 $Snap)
(assert (= $t@673@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _103 := _99
; [exec]
; label l88
; [exec]
; _102 := builtin$havoc_ref()
(declare-const ret@674@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_102.val_bool, write)
(declare-const $t@675@01 Bool)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@644@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@641@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@674@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _102.val_bool := _103 == 1
; [eval] _103 == 1
(declare-const val_bool@676@01 Bool)
(assert (= val_bool@676@01 (= _99@671@01 1)))
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@644@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@641@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@674@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [exec]
; _101 := builtin$havoc_ref()
(declare-const ret@677@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_101.val_bool, write)
(declare-const $t@678@01 Bool)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@674@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@644@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@641@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@677@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _101.val_bool := !_102.val_bool
; [eval] !_102.val_bool
(declare-const val_bool@679@01 Bool)
(assert (= val_bool@679@01 (not val_bool@676@01)))
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@674@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@644@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@641@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@677@01)))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [exec]
; __t61 := _101.val_bool
; [eval] !__t61
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not val_bool@679@01))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 24
(set-option :timeout 10)
(assert (not (not val_bool@679@01)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 130 | !(val_bool@679@01) | live]
; [else-branch: 130 | val_bool@679@01 | dead]
(set-option :timeout 0)
(push) ; 24
; [then-branch: 130 | !(val_bool@679@01)]
(assert (not val_bool@679@01))
; [exec]
; label l90
; [exec]
; label bb73
; [exec]
; __t45 := true
; [exec]
; _94 := builtin$havoc_ref()
(declare-const ret@680@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_94), write)
(declare-const $t@681@01 $Snap)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@647@01 ret@680@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@614@01 ret@680@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@577@01 ret@680@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@567@01 ret@680@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@561@01 ret@680@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@528@01 ret@680@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@491@01 ret@680@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@481@01 ret@680@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@680@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@680@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _117 := builtin$havoc_ref()
(declare-const ret@682@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_117.val_ref, write)
(declare-const $t@683@01 $Ref)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@660@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@627@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@682@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _117.val_ref := _1
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@660@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@627@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@682@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [exec]
; label l91
; [exec]
; label l92
; [exec]
; assert true
; [exec]
; exhale acc(_117.val_ref, write) &&
;   acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(_117.val_ref), write)
; [exec]
; _116 := builtin$havoc_ref()
(declare-const ret@684@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_(old[l92](_117.val_ref)), write)
; [eval] old[l92](_117.val_ref)
(declare-const $t@685@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_116), write)
(declare-const $t@686@01 $Snap)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@448@01 ret@684@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@687@01 $Snap)
(assert (= $t@687@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_116)) &&
;   ((old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) ==
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l92](_117.val_ref)) ==
;   0) &&
;   ((old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_116)) &&
;   ((old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_116) ==
;   old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_117.val_ref,
;   0))) &&
;   ((old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) >
;   0 ==>
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l92](_117.val_ref)) ==
;   old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref) -
;   1)) &&
;   (old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) >
;   0 ==>
;   (forall i: Int ::
;     { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l92](_117.val_ref),
;     i) }
;     0 <= i &&
;     i <
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l92](_117.val_ref)) ==>
;     old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_117.val_ref,
;     i + 1)) ==
;     m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l92](_117.val_ref),
;     i)))))))
(declare-const $t@688@01 $Snap)
(assert (= $t@688@01 ($Snap.combine ($Snap.first $t@688@01) ($Snap.second $t@688@01))))
(assert (= ($Snap.first $t@688@01) $Snap.unit))
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_116)
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) == 0
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)
(set-option :timeout 0)
(push) ; 25
; [eval] read$()
(push) ; 26
(pop) ; 26
; Joined path conditions
(push) ; 26
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(push) ; 26
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@652@01
  $Snap.unit) ret@441@01))
(pop) ; 25
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@652@01
  $Snap.unit) ret@441@01))
(set-option :timeout 0)
(push) ; 25
(push) ; 26
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@652@01
    $Snap.unit) ret@441@01)
  0)))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 131 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) == 0 | live]
; [else-branch: 131 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 131 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) == 0]
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@652@01
    $Snap.unit) ret@441@01)
  0))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_116)
(push) ; 27
; [eval] read$()
(push) ; 28
(pop) ; 28
; Joined path conditions
(push) ; 28
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(push) ; 28
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@686@01
  $Snap.unit) ret@684@01))
(pop) ; 27
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@686@01
  $Snap.unit) ret@684@01))
(pop) ; 26
(pop) ; 25
; Joined path conditions
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    0)
  (and
    (=
      (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
        $t@652@01
        $Snap.unit) ret@441@01)
      0)
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
      $t@686@01
      $Snap.unit) ret@684@01))))
(assert (=
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
    $t@652@01
    $Snap.unit) ret@441@01)
  0))
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@686@01
    $Snap.unit) ret@684@01)))
(assert (=
  ($Snap.second $t@688@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@688@01))
    ($Snap.second ($Snap.second $t@688@01)))))
(assert (= ($Snap.first ($Snap.second $t@688@01)) $Snap.unit))
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) == 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l92](_117.val_ref)) == 0
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) == 0
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)
(set-option :timeout 0)
(push) ; 25
; [eval] read$()
(push) ; 26
(pop) ; 26
; Joined path conditions
(push) ; 26
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(push) ; 26
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(pop) ; 25
; Joined path conditions
(set-option :timeout 0)
(push) ; 25
(push) ; 26
(set-option :timeout 10)
(assert (not (not
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 132 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) == 0 | live]
; [else-branch: 132 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) != 0 | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 132 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) == 0]
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l92](_117.val_ref)) == 0
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l92](_117.val_ref))
; [eval] old[l92](_117.val_ref)
(push) ; 27
; [eval] read$()
(push) ; 28
(pop) ; 28
; Joined path conditions
(push) ; 28
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(push) ; 28
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@685@01
  $Snap.unit) ret@441@01))
(pop) ; 27
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
  $t@685@01
  $Snap.unit) ret@441@01))
(pop) ; 26
(pop) ; 25
; Joined path conditions
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    0)
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$%precondition ($Snap.combine
    $t@685@01
    $Snap.unit) ret@441@01)))
(assert (=>
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    0)
  (=
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@685@01
      $Snap.unit) ret@441@01)
    0)))
(assert (=
  ($Snap.second ($Snap.second $t@688@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@688@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@688@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@688@01))) $Snap.unit))
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_some$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_116)
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) > 0
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)
(set-option :timeout 0)
(push) ; 25
; [eval] read$()
(push) ; 26
(pop) ; 26
; Joined path conditions
(push) ; 26
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(push) ; 26
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(pop) ; 25
; Joined path conditions
(set-option :timeout 0)
(push) ; 25
(push) ; 26
(set-option :timeout 10)
(assert (not (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    0))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 133 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0 | dead]
; [else-branch: 133 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0) | live]
(set-option :timeout 0)
(push) ; 26
; [else-branch: 133 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0)]
(assert (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    0)))
(pop) ; 26
(pop) ; 25
; Joined path conditions
(assert (not
  (>
    (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$ ($Snap.combine
      $t@652@01
      $Snap.unit) ret@441@01)
    0)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@688@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@688@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@688@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@688@01))))
  $Snap.unit))
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$peek$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$int$(_116) == old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_117.val_ref, 0))
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) > 0
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)
(push) ; 25
; [eval] read$()
(push) ; 26
(pop) ; 26
; Joined path conditions
(push) ; 26
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(push) ; 26
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(pop) ; 25
; Joined path conditions
(set-option :timeout 0)
(push) ; 25
; [then-branch: 134 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0 | dead]
; [else-branch: 134 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0) | live]
(push) ; 26
; [else-branch: 134 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0)]
(pop) ; 26
(pop) ; 25
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@688@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@688@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@688@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@688@01)))))
  $Snap.unit))
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) > 0 ==> m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l92](_117.val_ref)) == old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref) - 1)
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) > 0
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)
(push) ; 25
; [eval] read$()
(push) ; 26
(pop) ; 26
; Joined path conditions
(push) ; 26
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(push) ; 26
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(pop) ; 25
; Joined path conditions
(set-option :timeout 0)
(push) ; 25
; [then-branch: 135 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0 | dead]
; [else-branch: 135 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0) | live]
(push) ; 26
; [else-branch: 135 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0)]
(pop) ; 26
(pop) ; 25
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@688@01)))))
  $Snap.unit))
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) > 0 ==> (forall i: Int :: { m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l92](_117.val_ref), i) } 0 <= i && i < m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(old[l92](_117.val_ref)) ==> old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(_117.val_ref, i + 1)) == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$lookup$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$$$int$(old[l92](_117.val_ref), i))
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)) > 0
; [eval] old[l92](m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref))
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(_117.val_ref)
(push) ; 25
; [eval] read$()
(push) ; 26
(pop) ; 26
; Joined path conditions
(push) ; 26
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(push) ; 26
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(pop) ; 25
; Joined path conditions
(set-option :timeout 0)
(push) ; 25
; [then-branch: 136 | m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0 | dead]
; [else-branch: 136 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0) | live]
(push) ; 26
; [else-branch: 136 | !(m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$5$closesqu$$$len$opensqu$0$closesqu$__$TY$__m_first_final$$List$opensqu$0$closesqu$$_beg_$_end_$$int$(($t@652@01, _), ret@441@01) > 0)]
(pop) ; 26
(pop) ; 25
; Joined path conditions
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l93
; [exec]
; label l94
; [exec]
; label bb76
; [exec]
; __t46 := true
; [exec]
; _115 := builtin$havoc_ref()
(declare-const ret@689@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_115.val_ref, write)
(declare-const $t@690@01 $Ref)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@660@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@627@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@689@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _115.val_ref := _116
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@660@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@627@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@594@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@541@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@508@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@453@01 ret@689@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_116), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(set-option :timeout 0)
(push) ; 25
(pop) ; 25
; Joined path conditions
(push) ; 25
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(push) ; 25
(set-option :timeout 10)
(assert (not (=
  (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(assert (not (or
  (=
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No)
  (<
    (-
      (- $Perm.Write (read$ $Snap.unit))
      ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_115.val_ref), read$())
; [eval] read$()
(push) ; 25
(pop) ; 25
; Joined path conditions
(push) ; 25
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(declare-const $t@691@01 $Snap)
(declare-const $t@692@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit)))))
    (= $t@692@01 $t@686@01))
  (=> (< $Perm.No (read$ $Snap.unit)) (= $t@692@01 $t@691@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l95
; [exec]
; label l96
; [exec]
; _114 := builtin$havoc_ref()
(declare-const ret@693@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(bool(_114), write)
(declare-const $t@694@01 Bool)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; unfold acc(bool(_114), write)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@677@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@674@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@644@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@641@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 25
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@693@01)))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@693@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (bool%trigger ($SortWrappers.BoolTo$Snap $t@694@01) ret@693@01))
; [exec]
; inhale _114.val_bool ==
;   m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_115.val_ref)
(declare-const $t@695@01 $Snap)
(assert (= $t@695@01 $Snap.unit))
; [eval] _114.val_bool == m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_115.val_ref)
; [eval] m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$(_115.val_ref)
(set-option :timeout 0)
(push) ; 25
; [eval] read$()
(push) ; 26
(pop) ; 26
; Joined path conditions
(push) ; 26
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(push) ; 26
(assert (not (=>
  (< $Perm.No (read$ $Snap.unit))
  (<
    $Perm.No
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(push) ; 26
(set-option :timeout 10)
(assert (not (< $Perm.No (read$ $Snap.unit))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@692@01
  $Snap.unit) ret@684@01))
(pop) ; 25
; Joined path conditions
(assert (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$%precondition ($Snap.combine
  $t@692@01
  $Snap.unit) ret@684@01))
(assert (=
  $t@694@01
  (m_first_final$$$opencur$$opencur$impl$closecur$$closecur$$opensqu$3$closesqu$$$is_none$opensqu$0$closesqu$__$TY$__m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_$$bool$ ($Snap.combine
    $t@692@01
    $Snap.unit) ret@684@01)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label l97
; [eval] __t46 && __t46
(set-option :timeout 0)
(push) ; 25
; [then-branch: 137 | False | live]
; [else-branch: 137 | True | live]
(push) ; 26
; [then-branch: 137 | False]
(assert false)
(pop) ; 26
(push) ; 26
; [else-branch: 137 | True]
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(push) ; 25
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
; [then-branch: 138 | True | live]
; [else-branch: 138 | False | dead]
(set-option :timeout 0)
(push) ; 25
; [then-branch: 138 | True]
; [exec]
; exhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(old[l95](_115.val_ref)), read$())
; [eval] read$()
(push) ; 26
(pop) ; 26
; Joined path conditions
; [eval] old[l95](_115.val_ref)
(push) ; 26
(assert (not (or (= (read$ $Snap.unit) $Perm.No) (< $Perm.No (read$ $Snap.unit)))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(push) ; 26
(set-option :timeout 10)
(assert (not (=
  (-
    (+
      (- $Perm.Write ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
      (read$ $Snap.unit))
    ($Perm.min
      (+
        (-
          $Perm.Write
          ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
        (read$ $Snap.unit))
      (read$ $Snap.unit)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(assert (not (or
  (=
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No)
  (<
    (-
      (read$ $Snap.unit)
      ($Perm.min
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        (read$ $Snap.unit)))
    $Perm.No))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [exec]
; inhale acc(m_first_final$$TrustedOption$opensqu$0$closesqu$$_beg_$_end_(_116), write -
;   read$())
; [eval] write - read$()
; [eval] read$()
(push) ; 26
(pop) ; 26
; Joined path conditions
(push) ; 26
(assert (not (or
  (= (- $Perm.Write (read$ $Snap.unit)) $Perm.No)
  (< $Perm.No (- $Perm.Write (read$ $Snap.unit))))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(declare-const $t@696@01 $Snap)
(declare-const $t@697@01 $Snap)
(assert (and
  (=>
    (<
      $Perm.No
      (-
        (+
          (-
            $Perm.Write
            ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
          (read$ $Snap.unit))
        ($Perm.min
          (+
            (-
              $Perm.Write
              ($Perm.min $Perm.Write (- $Perm.Write (read$ $Snap.unit))))
            (read$ $Snap.unit))
          (read$ $Snap.unit))))
    (= $t@697@01 $t@692@01))
  (=> (< $Perm.No (- $Perm.Write (read$ $Snap.unit))) (= $t@697@01 $t@696@01))))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb79
; [exec]
; __t47 := true
; [exec]
; _113 := builtin$havoc_ref()
(declare-const ret@698@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(_113.val_bool, write)
(declare-const $t@699@01 Bool)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@693@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@677@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@674@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@644@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@641@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(assert (not (= ret@698@01 $Ref.null)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _113.val_bool := !_114.val_bool
; [eval] !_114.val_bool
(declare-const val_bool@700@01 Bool)
(assert (= val_bool@700@01 (not $t@694@01)))
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@693@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@677@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@674@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@644@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@641@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@611@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@608@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@558@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@555@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@525@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@522@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@462@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (= ret@457@01 ret@698@01)))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [exec]
; __t62 := _113.val_bool
; [eval] !__t62
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not val_bool@700@01))
(check-sat)
; unknown
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not val_bool@700@01)))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 139 | !(val_bool@700@01) | live]
; [else-branch: 139 | val_bool@700@01 | dead]
(set-option :timeout 0)
(push) ; 26
; [then-branch: 139 | !(val_bool@700@01)]
(assert (not val_bool@700@01))
; [exec]
; label l99
; [exec]
; label bb81
; [exec]
; __t49 := true
; [exec]
; _112 := builtin$havoc_ref()
(declare-const ret@701@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_112), write)
(declare-const $t@702@01 $Snap)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@680@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@647@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@614@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@577@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@567@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@561@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@528@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@491@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@481@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@701@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; _0 := builtin$havoc_ref()
(declare-const ret@703@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_0), write)
(declare-const $t@704@01 $Snap)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@701@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@680@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@647@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@614@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@577@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@567@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@561@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@528@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@491@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@481@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@471@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 27
(set-option :timeout 10)
(assert (not (= ret@465@01 ret@703@01)))
(check-sat)
; unknown
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label bb83
; [exec]
; __t50 := true
; [exec]
; label return
; [exec]
; assert true
; [exec]
; exhale acc(tuple0$(_0), write)
; [exec]
; label end_of_method
(pop) ; 26
; [eval] !!__t62
; [eval] !__t62
(set-option :timeout 0)
(push) ; 26
(set-option :timeout 10)
(assert (not (not val_bool@700@01)))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
; [then-branch: 140 | val_bool@700@01 | dead]
; [else-branch: 140 | !(val_bool@700@01) | live]
(set-option :timeout 0)
(push) ; 26
; [else-branch: 140 | !(val_bool@700@01)]
(assert (not val_bool@700@01))
(pop) ; 26
(pop) ; 25
; [eval] !(__t46 && __t46)
; [eval] __t46 && __t46
(push) ; 25
; [then-branch: 141 | False | live]
; [else-branch: 141 | True | live]
(push) ; 26
; [then-branch: 141 | False]
(assert false)
(pop) ; 26
(push) ; 26
; [else-branch: 141 | True]
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
; [then-branch: 142 | False | dead]
; [else-branch: 142 | True | live]
(push) ; 25
; [else-branch: 142 | True]
(pop) ; 25
(pop) ; 24
; [eval] !!__t61
; [eval] !__t61
(push) ; 24
(set-option :timeout 10)
(assert (not (not val_bool@679@01)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
; [then-branch: 143 | val_bool@679@01 | dead]
; [else-branch: 143 | !(val_bool@679@01) | live]
(set-option :timeout 0)
(push) ; 24
; [else-branch: 143 | !(val_bool@679@01)]
(assert (not val_bool@679@01))
(pop) ; 24
(pop) ; 23
(pop) ; 22
; [eval] !__t39
; [then-branch: 144 | False | dead]
; [else-branch: 144 | True | live]
(push) ; 22
; [else-branch: 144 | True]
(pop) ; 22
(pop) ; 21
; [eval] !(__t60 == 0)
; [eval] __t60 == 0
(push) ; 21
(set-option :timeout 10)
(assert (not (= _100@666@01 0)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
; [then-branch: 145 | _100@666@01 != 0 | dead]
; [else-branch: 145 | _100@666@01 == 0 | live]
(set-option :timeout 0)
(push) ; 21
; [else-branch: 145 | _100@666@01 == 0]
(assert (= _100@666@01 0))
(pop) ; 21
(pop) ; 20
; [eval] !!__t59
; [eval] !__t59
(push) ; 20
(set-option :timeout 10)
(assert (not (not val_bool@646@01)))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
; [then-branch: 146 | val_bool@646@01 | dead]
; [else-branch: 146 | !(val_bool@646@01) | live]
(set-option :timeout 0)
(push) ; 20
; [else-branch: 146 | !(val_bool@646@01)]
(assert (not val_bool@646@01))
(pop) ; 20
(pop) ; 19
(pop) ; 18
; [eval] !__t32
; [then-branch: 147 | False | dead]
; [else-branch: 147 | True | live]
(push) ; 18
; [else-branch: 147 | True]
(pop) ; 18
(pop) ; 17
; [eval] !(__t58 == 0)
; [eval] __t58 == 0
(push) ; 17
(set-option :timeout 10)
(assert (not (= _82@633@01 0)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
; [then-branch: 148 | _82@633@01 != 0 | dead]
; [else-branch: 148 | _82@633@01 == 0 | live]
(set-option :timeout 0)
(push) ; 17
; [else-branch: 148 | _82@633@01 == 0]
(assert (= _82@633@01 0))
(pop) ; 17
(pop) ; 16
; [eval] !!__t57
; [eval] !__t57
(push) ; 16
(set-option :timeout 10)
(assert (not (not val_bool@613@01)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
; [then-branch: 149 | val_bool@613@01 | dead]
; [else-branch: 149 | !(val_bool@613@01) | live]
(set-option :timeout 0)
(push) ; 16
; [else-branch: 149 | !(val_bool@613@01)]
(assert (not val_bool@613@01))
(pop) ; 16
(pop) ; 15
(pop) ; 14
; [eval] !__t25
; [then-branch: 150 | False | dead]
; [else-branch: 150 | True | live]
(push) ; 14
; [else-branch: 150 | True]
(pop) ; 14
(pop) ; 13
; [eval] !(__t56 == 0)
; [eval] __t56 == 0
(push) ; 13
(set-option :timeout 10)
(assert (not (= _64@600@01 0)))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
; [then-branch: 151 | _64@600@01 != 0 | dead]
; [else-branch: 151 | _64@600@01 == 0 | live]
(set-option :timeout 0)
(push) ; 13
; [else-branch: 151 | _64@600@01 == 0]
(assert (= _64@600@01 0))
(pop) ; 13
(pop) ; 12
; [eval] !!__t55
; [eval] !__t55
(push) ; 12
(set-option :timeout 10)
(assert (not (not val_bool@560@01)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
; [then-branch: 152 | val_bool@560@01 | dead]
; [else-branch: 152 | !(val_bool@560@01) | live]
(set-option :timeout 0)
(push) ; 12
; [else-branch: 152 | !(val_bool@560@01)]
(assert (not val_bool@560@01))
(pop) ; 12
(pop) ; 11
(pop) ; 10
; [eval] !__t16
; [then-branch: 153 | False | dead]
; [else-branch: 153 | True | live]
(push) ; 10
; [else-branch: 153 | True]
(pop) ; 10
(pop) ; 9
; [eval] !(__t54 == 0)
; [eval] __t54 == 0
(push) ; 9
(set-option :timeout 10)
(assert (not (= _42@547@01 0)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; [then-branch: 154 | _42@547@01 != 0 | dead]
; [else-branch: 154 | _42@547@01 == 0 | live]
(set-option :timeout 0)
(push) ; 9
; [else-branch: 154 | _42@547@01 == 0]
(assert (= _42@547@01 0))
(pop) ; 9
(pop) ; 8
; [eval] !!__t53
; [eval] !__t53
(push) ; 8
(set-option :timeout 10)
(assert (not (not val_bool@527@01)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
; [then-branch: 155 | val_bool@527@01 | dead]
; [else-branch: 155 | !(val_bool@527@01) | live]
(set-option :timeout 0)
(push) ; 8
; [else-branch: 155 | !(val_bool@527@01)]
(assert (not val_bool@527@01))
(pop) ; 8
(pop) ; 7
(pop) ; 6
; [eval] !__t9
; [then-branch: 156 | False | dead]
; [else-branch: 156 | True | live]
(push) ; 6
; [else-branch: 156 | True]
(pop) ; 6
(pop) ; 5
; [eval] !(__t52 == 0)
; [eval] __t52 == 0
(push) ; 5
(set-option :timeout 10)
(assert (not (= _24@514@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 157 | _24@514@01 != 0 | dead]
; [else-branch: 157 | _24@514@01 == 0 | live]
(set-option :timeout 0)
(push) ; 5
; [else-branch: 157 | _24@514@01 == 0]
(assert (= _24@514@01 0))
(pop) ; 5
(pop) ; 4
; [eval] !!__t51
; [eval] !__t51
(push) ; 4
(set-option :timeout 10)
(assert (not (not val_bool@464@01)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 158 | val_bool@464@01 | dead]
; [else-branch: 158 | !(val_bool@464@01) | live]
(set-option :timeout 0)
(push) ; 4
; [else-branch: 158 | !(val_bool@464@01)]
(assert (not val_bool@464@01))
(pop) ; 4
(pop) ; 3
; [eval] !(__t2 && __t2)
; [eval] __t2 && __t2
(push) ; 3
; [then-branch: 159 | False | live]
; [else-branch: 159 | True | live]
(push) ; 4
; [then-branch: 159 | False]
(assert false)
(pop) ; 4
(push) ; 4
; [else-branch: 159 | True]
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
; [then-branch: 160 | False | dead]
; [else-branch: 160 | True | live]
(push) ; 3
; [else-branch: 160 | True]
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- m_first_final$$main$opensqu$0$closesqu$ ----------
(declare-const _0@705@01 $Ref)
(declare-const _0@706@01 $Ref)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var __t0: Bool
(declare-const __t0@707@01 Bool)
; [exec]
; label start
; [exec]
; __t0 := false
; [exec]
; inhale true
(declare-const $t@708@01 $Snap)
(assert (= $t@708@01 $Snap.unit))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@709@01 $Snap)
(assert (= $t@709@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@710@01 $Snap)
(assert (= $t@710@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale true
(declare-const $t@711@01 $Snap)
(assert (= $t@711@01 $Snap.unit))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; label pre
; [exec]
; label bb0
; [exec]
; __t0 := true
; [exec]
; _0 := builtin$havoc_ref()
(declare-const ret@712@01 $Ref)
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [exec]
; inhale acc(tuple0$(_0), write)
(declare-const $t@713@01 $Snap)
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; label return
; [exec]
; assert true
; [exec]
; exhale acc(tuple0$(_0), write)
; [exec]
; label end_of_method
(pop) ; 2
(pop) ; 1
; ---------- builtin$havoc_bool ----------
(declare-const ret@714@01 Bool)
(declare-const ret@715@01 Bool)
(set-option :timeout 0)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; inhale false
(pop) ; 2
(pop) ; 1
; ---------- builtin$havoc_ref ----------
(declare-const ret@716@01 $Ref)
(declare-const ret@717@01 $Ref)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; inhale false
(pop) ; 2
(pop) ; 1
; ---------- builtin$havoc_int ----------
(declare-const ret@718@01 Int)
(declare-const ret@719@01 Int)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; inhale false
(pop) ; 2
(pop) ; 1
