(get-info :version)
; (:version "4.12.1")
; Started: 2025-01-26 23:01:10
; Silicon.version: 1.1-SNAPSHOT (457c6eca@(detached))
; Input file: <unknown>
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Necessary for push pop mode
(set-option :auto_config false)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :type_check true)
(set-option :smt.mbqi false)
(set-option :pp.bv_literals false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.arith.solver 2)
(set-option :model.v2 true)
(set-option :smt.qi.max_multi_patterns 1000)
; 
; ; /preamble.smt2
(declare-datatypes (($Snap 0)) ((
    ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM 0)
(declare-sort $PPM 0)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<Int> 0)
(declare-sort Set<$Ref> 0)
(declare-sort Set<Int> 0)
(declare-sort Set<$Snap> 0)
(declare-sort $FVF<g> 0)
(declare-sort $PSF<pair> 0)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<g>To$Snap ($FVF<g>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<g> ($Snap) $FVF<g>)
(assert (forall ((x $FVF<g>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<g>($SortWrappers.$FVF<g>To$Snap x)))
    :pattern (($SortWrappers.$FVF<g>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<g>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<g>To$Snap($SortWrappers.$SnapTo$FVF<g> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<g> x))
    :qid |$Snap.$FVF<g>To$SnapTo$FVF<g>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$PSF<pair>To$Snap ($PSF<pair>) $Snap)
(declare-fun $SortWrappers.$SnapTo$PSF<pair> ($Snap) $PSF<pair>)
(assert (forall ((x $PSF<pair>)) (!
    (= x ($SortWrappers.$SnapTo$PSF<pair>($SortWrappers.$PSF<pair>To$Snap x)))
    :pattern (($SortWrappers.$PSF<pair>To$Snap x))
    :qid |$Snap.$SnapTo$PSF<pair>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PSF<pair>To$Snap($SortWrappers.$SnapTo$PSF<pair> x)))
    :pattern (($SortWrappers.$SnapTo$PSF<pair> x))
    :qid |$Snap.$PSF<pair>To$SnapTo$PSF<pair>|
    )))
; ////////// Symbols
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_skolem_diff (Set<$Ref> Set<$Ref>) $Ref)
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_skolem_diff (Set<Int> Set<Int>) Int)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_skolem_diff (Set<$Snap> Set<$Snap>) $Snap)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_add (Int Int) Int)
(declare-fun Seq_sub (Int Int) Int)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_contains_trigger (Seq<Int> Int) Bool)
(declare-fun Seq_skolem (Seq<Int> Int) Int)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_skolem_diff (Seq<Int> Seq<Int>) Int)
(declare-fun Seq_range (Int Int) Seq<Int>)
; /field_value_functions_declarations.smt2 [g: Int]
(declare-fun $FVF.domain_g ($FVF<g>) Set<$Ref>)
(declare-fun $FVF.lookup_g ($FVF<g> $Ref) Int)
(declare-fun $FVF.after_g ($FVF<g> $FVF<g>) Bool)
(declare-fun $FVF.loc_g (Int $Ref) Bool)
(declare-fun $FVF.perm_g ($FPM $Ref) $Perm)
(declare-const $fvfTOP_g $FVF<g>)
; /predicate_snap_functions_declarations.smt2 [pair: Snap]
(declare-fun $PSF.domain_pair ($PSF<pair>) Set<$Snap>)
(declare-fun $PSF.lookup_pair ($PSF<pair> $Snap) $Snap)
(declare-fun $PSF.after_pair ($PSF<pair> $PSF<pair>) Bool)
(declare-fun $PSF.loc_pair ($Snap $Snap) Bool)
(declare-fun $PSF.perm_pair ($PPM $Snap) $Perm)
(declare-const $psfTOP_pair $PSF<pair>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun addC ($Snap $Ref Int Int) Int)
(declare-fun addC%limited ($Snap $Ref Int Int) Int)
(declare-fun addC%stateless ($Ref Int Int) Bool)
(declare-fun addC%precondition ($Snap $Ref Int Int) Bool)
(declare-fun addA ($Snap Int Int) Int)
(declare-fun addA%limited ($Snap Int Int) Int)
(declare-fun addA%stateless (Int Int) Bool)
(declare-fun addA%precondition ($Snap Int Int) Bool)
(declare-fun addB ($Snap $Ref Int) Int)
(declare-fun addB%limited ($Snap $Ref Int) Int)
(declare-fun addB%stateless ($Ref Int) Bool)
(declare-fun addB%precondition ($Snap $Ref Int) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun pair%trigger ($Snap $Ref Int) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  )))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (=> (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  )))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (not (= s1 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s0 s1)) (+ (Seq_length s0) (Seq_length s1))))
  :pattern ((Seq_length (Seq_append s0 s1)))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>)) (!
  (and
    (=> (= s0 (as Seq_empty  Seq<Int>)) (= (Seq_append s0 s1) s1))
    (=> (= s1 (as Seq_empty  Seq<Int>)) (= (Seq_append s0 s1) s0)))
  :pattern ((Seq_append s0 s1))
  )))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((i Int) (j Int)) (!
  (= (Seq_add i j) (+ i j))
  :pattern ((Seq_add i j))
  )))
(assert (forall ((i Int) (j Int)) (!
  (= (Seq_sub i j) (- i j))
  :pattern ((Seq_sub i j))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Int>)))
        (and (<= 0 n) (< n (Seq_length s0)))))
    (= (Seq_index (Seq_append s0 s1) n) (Seq_index s0 n)))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  :pattern ((Seq_index s0 n) (Seq_append s0 s1))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Int>)))
        (and (<= (Seq_length s0) n) (< n (Seq_length (Seq_append s0 s1))))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s0)) (Seq_length s0)) n)
      (=
        (Seq_index (Seq_append s0 s1) n)
        (Seq_index s1 (Seq_sub n (Seq_length s0))))))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>) (m Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Int>)))
        (and (<= 0 m) (< m (Seq_length s1)))))
    (and
      (= (Seq_sub (Seq_add m (Seq_length s0)) (Seq_length s0)) m)
      (=
        (Seq_index (Seq_append s0 s1) (Seq_add m (Seq_length s0)))
        (Seq_index s1 m))))
  :pattern ((Seq_index s1 m) (Seq_append s0 s1))
  )))
(assert (forall ((s Seq<Int>) (i Int) (v Int)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i v)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i v)))
  :pattern ((Seq_length s) (Seq_update s i v))
  )))
(assert (forall ((s Seq<Int>) (i Int) (v Int) (n Int)) (!
  (=>
    (and (<= 0 n) (< n (Seq_length s)))
    (and
      (=> (= i n) (= (Seq_index (Seq_update s i v) n) v))
      (=> (not (= i n)) (= (Seq_index (Seq_update s i v) n) (Seq_index s n)))))
  :pattern ((Seq_index (Seq_update s i v) n))
  :pattern ((Seq_index s n) (Seq_update s i v))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=> (<= n (Seq_length s)) (= (Seq_length (Seq_take s n)) n))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_take s n)) (Seq_length s)))))
    (=> (< n 0) (= (Seq_length (Seq_take s n)) 0)))
  :pattern ((Seq_length (Seq_take s n)))
  :pattern ((Seq_take s n) (Seq_length s))
  )))
(assert (forall ((s Seq<Int>) (n Int) (j Int)) (!
  (=>
    (and (<= 0 j) (and (< j n) (< j (Seq_length s))))
    (= (Seq_index (Seq_take s n) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_take s n) j))
  :pattern ((Seq_index s j) (Seq_take s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=>
          (<= n (Seq_length s))
          (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n)))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_drop s n)) 0))))
    (=> (< n 0) (= (Seq_length (Seq_drop s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_drop s n)))
  :pattern ((Seq_length s) (Seq_drop s n))
  )))
(assert (forall ((s Seq<Int>) (n Int) (j Int)) (!
  (=>
    (and (< 0 n) (and (<= 0 j) (< j (- (Seq_length s) n))))
    (and
      (= (Seq_sub (Seq_add j n) n) j)
      (= (Seq_index (Seq_drop s n) j) (Seq_index s (Seq_add j n)))))
  :pattern ((Seq_index (Seq_drop s n) j))
  )))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (=>
    (and (< 0 n) (and (<= n i) (< i (Seq_length s))))
    (and
      (= (Seq_add (Seq_sub i n) n) i)
      (= (Seq_index (Seq_drop s n) (Seq_sub i n)) (Seq_index s i))))
  :pattern ((Seq_drop s n) (Seq_index s i))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_take (Seq_append s t) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (> n 0) (and (> n (Seq_length s)) (< n (Seq_length (Seq_append s t)))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (=
        (Seq_take (Seq_append s t) n)
        (Seq_append s (Seq_take t (Seq_sub n (Seq_length s)))))))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_append s t) n) (Seq_append (Seq_drop s n) t)))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (> n 0) (> n (Seq_length s)))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (= (Seq_drop (Seq_append s t) n) (Seq_drop t (Seq_sub n (Seq_length s))))))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_take s n) s))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_drop s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<Int>) (x Int)) (!
  (=>
    (Seq_contains s x)
    (and
      (<= 0 (Seq_skolem s x))
      (and
        (< (Seq_skolem s x) (Seq_length s))
        (= (Seq_index s (Seq_skolem s x)) x))))
  :pattern ((Seq_contains s x))
  )))
(assert (forall ((s Seq<Int>) (x Int) (i Int)) (!
  (=>
    (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) x)))
    (Seq_contains s x))
  :pattern ((Seq_contains s x) (Seq_index s i))
  )))
(assert (forall ((s Seq<Int>) (i Int)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (Seq_contains_trigger s (Seq_index s i)))
  :pattern ((Seq_index s i))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>)) (!
  (or
    (and (= s0 s1) (Seq_equal s0 s1))
    (or
      (and
        (not (= s0 s1))
        (and (not (Seq_equal s0 s1)) (not (= (Seq_length s0) (Seq_length s1)))))
      (and
        (not (= s0 s1))
        (and
          (not (Seq_equal s0 s1))
          (and
            (= (Seq_length s0) (Seq_length s1))
            (and
              (= (Seq_skolem_diff s0 s1) (Seq_skolem_diff s1 s0))
              (and
                (<= 0 (Seq_skolem_diff s0 s1))
                (and
                  (< (Seq_skolem_diff s0 s1) (Seq_length s0))
                  (not
                    (=
                      (Seq_index s0 (Seq_skolem_diff s0 s1))
                      (Seq_index s1 (Seq_skolem_diff s0 s1))))))))))))
  :pattern ((Seq_equal s0 s1))
  )))
(assert (forall ((a Seq<Int>) (b Seq<Int>)) (!
  (=> (Seq_equal a b) (= a b))
  :pattern ((Seq_equal a b))
  )))
(assert (forall ((x Int) (y Int)) (!
  (= (Seq_contains (Seq_singleton x) y) (= x y))
  :pattern ((Seq_contains (Seq_singleton x) y))
  )))
(assert (forall ((min_ Int) (max Int)) (!
  (and
    (=> (< min_ max) (= (Seq_length (Seq_range min_ max)) (- max min_)))
    (=> (<= max min_) (= (Seq_length (Seq_range min_ max)) 0)))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (j Int)) (!
  (=>
    (and (<= 0 j) (< j (- max min_)))
    (= (Seq_index (Seq_range min_ max) j) (+ min_ j)))
  :pattern ((Seq_index (Seq_range min_ max) j))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (v Int)) (!
  (= (Seq_contains (Seq_range min_ max) v) (and (<= min_ v) (< v max)))
  :pattern ((Seq_contains (Seq_range min_ max) v))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Ref)) (!
  (not (Set_in o (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in o (as Set_empty  Set<$Ref>)))
  )))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Ref))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Ref)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Ref) (o $Ref)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Ref)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (o $Ref)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Ref)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o Int)) (!
  (not (Set_in o (as Set_empty  Set<Int>)))
  :pattern ((Set_in o (as Set_empty  Set<Int>)))
  )))
(assert (forall ((s Set<Int>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (=> (not (= (Set_card s) 0)) (exists ((x Int))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r Int)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r Int) (o Int)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r Int)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<Int>) (x Int) (o Int)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<Int>) (x Int)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<Int>) (x Int) (y Int)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<Int>) (x Int)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Int>) (x Int)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (o Int)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (y Int)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (y Int)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (o Int)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (o Int)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (y Int)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (=
    (Set_subset a b)
    (forall ((o Int)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Snap)) (!
  (not (Set_in o (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in o (as Set_empty  Set<$Snap>)))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Snap))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Snap)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Snap) (o $Snap)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Snap)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (o $Snap)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Snap)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
; /field_value_functions_axioms.smt2 [g: Int]
(assert (forall ((vs $FVF<g>) (ws $FVF<g>)) (!
    (=>
      (and
        (Set_equal ($FVF.domain_g vs) ($FVF.domain_g ws))
        (forall ((x $Ref)) (!
          (=>
            (Set_in x ($FVF.domain_g vs))
            (= ($FVF.lookup_g vs x) ($FVF.lookup_g ws x)))
          :pattern (($FVF.lookup_g vs x) ($FVF.lookup_g ws x))
          :qid |qp.$FVF<g>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<g>To$Snap vs)
              ($SortWrappers.$FVF<g>To$Snap ws)
              )
    :qid |qp.$FVF<g>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_g pm r))
    :pattern (($FVF.perm_g pm r)))))
(assert (forall ((r $Ref) (f Int)) (!
    (= ($FVF.loc_g f r) true)
    :pattern (($FVF.loc_g f r)))))
; /predicate_snap_functions_axioms.smt2 [pair: Snap]
(assert (forall ((vs $PSF<pair>) (ws $PSF<pair>)) (!
    (=>
      (and
        (Set_equal ($PSF.domain_pair vs) ($PSF.domain_pair ws))
        (forall ((x $Snap)) (!
          (=>
            (Set_in x ($PSF.domain_pair vs))
            (= ($PSF.lookup_pair vs x) ($PSF.lookup_pair ws x)))
          :pattern (($PSF.lookup_pair vs x) ($PSF.lookup_pair ws x))
          :qid |qp.$PSF<pair>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$PSF<pair>To$Snap vs)
              ($SortWrappers.$PSF<pair>To$Snap ws)
              )
    :qid |qp.$PSF<pair>-eq-outer|
    )))
(assert (forall ((s $Snap) (pm $PPM)) (!
    ($Perm.isValidVar ($PSF.perm_pair pm s))
    :pattern (($PSF.perm_pair pm s)))))
(assert (forall ((s $Snap) (f $Snap)) (!
    (= ($PSF.loc_pair f s) true)
    :pattern (($PSF.loc_pair f s)))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(assert (forall ((s@$ $Snap) (x@0@00 $Ref) (v@1@00 Int) (i@2@00 Int)) (!
  (= (addC%limited s@$ x@0@00 v@1@00 i@2@00) (addC s@$ x@0@00 v@1@00 i@2@00))
  :pattern ((addC s@$ x@0@00 v@1@00 i@2@00))
  :qid |quant-u-5001|)))
(assert (forall ((s@$ $Snap) (x@0@00 $Ref) (v@1@00 Int) (i@2@00 Int)) (!
  (addC%stateless x@0@00 v@1@00 i@2@00)
  :pattern ((addC%limited s@$ x@0@00 v@1@00 i@2@00))
  :qid |quant-u-5002|)))
(assert (forall ((s@$ $Snap) (x@0@00 $Ref) (v@1@00 Int) (i@2@00 Int)) (!
  (=>
    (addC%precondition s@$ x@0@00 v@1@00 i@2@00)
    (=
      (addC s@$ x@0@00 v@1@00 i@2@00)
      (+ (+ ($SortWrappers.$SnapToInt s@$) v@1@00) i@2@00)))
  :pattern ((addC s@$ x@0@00 v@1@00 i@2@00))
  :qid |quant-u-5007|)))
(assert (forall ((s@$ $Snap) (x@0@00 $Ref) (v@1@00 Int) (i@2@00 Int)) (!
  true
  :pattern ((addC s@$ x@0@00 v@1@00 i@2@00))
  :qid |quant-u-5008|)))
(assert (forall ((s@$ $Snap) (v@4@00 Int) (i@5@00 Int)) (!
  (= (addA%limited s@$ v@4@00 i@5@00) (addA s@$ v@4@00 i@5@00))
  :pattern ((addA s@$ v@4@00 i@5@00))
  :qid |quant-u-5003|)))
(assert (forall ((s@$ $Snap) (v@4@00 Int) (i@5@00 Int)) (!
  (addA%stateless v@4@00 i@5@00)
  :pattern ((addA%limited s@$ v@4@00 i@5@00))
  :qid |quant-u-5004|)))
(assert (forall ((s@$ $Snap) (v@4@00 Int) (i@5@00 Int)) (!
  (=>
    (addA%precondition s@$ v@4@00 i@5@00)
    (= (addA s@$ v@4@00 i@5@00) (+ i@5@00 v@4@00)))
  :pattern ((addA s@$ v@4@00 i@5@00))
  :qid |quant-u-5009|)))
(assert (forall ((s@$ $Snap) (v@4@00 Int) (i@5@00 Int)) (!
  true
  :pattern ((addA s@$ v@4@00 i@5@00))
  :qid |quant-u-5010|)))
(assert (forall ((s@$ $Snap) (x@7@00 $Ref) (i@8@00 Int)) (!
  (= (addB%limited s@$ x@7@00 i@8@00) (addB s@$ x@7@00 i@8@00))
  :pattern ((addB s@$ x@7@00 i@8@00))
  :qid |quant-u-5005|)))
(assert (forall ((s@$ $Snap) (x@7@00 $Ref) (i@8@00 Int)) (!
  (addB%stateless x@7@00 i@8@00)
  :pattern ((addB%limited s@$ x@7@00 i@8@00))
  :qid |quant-u-5006|)))
(assert (forall ((s@$ $Snap) (x@7@00 $Ref) (i@8@00 Int)) (!
  (=>
    (addB%precondition s@$ x@7@00 i@8@00)
    (=
      (addB s@$ x@7@00 i@8@00)
      (+
        (+ i@8@00 ($SortWrappers.$SnapToInt ($Snap.first s@$)))
        ($SortWrappers.$SnapToInt ($Snap.second s@$)))))
  :pattern ((addB s@$ x@7@00 i@8@00))
  :qid |quant-u-5011|)))
(assert (forall ((s@$ $Snap) (x@7@00 $Ref) (i@8@00 Int)) (!
  true
  :pattern ((addB s@$ x@7@00 i@8@00))
  :qid |quant-u-5012|)))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- test01a ----------
(declare-const xs@0@01 Set<$Ref>)
(declare-const is@1@01 Seq<Int>)
(declare-const xs@2@01 Set<$Ref>)
(declare-const is@3@01 Seq<Int>)
(set-option :timeout 0)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@4@01 $Ref)
(declare-const i@5@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 0 | !(x@4@01 in xs@2@01) | live]
; [else-branch: 0 | x@4@01 in xs@2@01 | live]
(push) ; 5
; [then-branch: 0 | !(x@4@01 in xs@2@01)]
(assert (not (Set_in x@4@01 xs@2@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 0 | x@4@01 in xs@2@01]
(assert (Set_in x@4@01 xs@2@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@4@01 xs@2@01) (not (Set_in x@4@01 xs@2@01))))
(assert (and (Set_in x@4@01 xs@2@01) (Seq_contains is@3@01 i@5@01)))
(pop) ; 3
(declare-const $t@6@01 $PSF<pair>)
(declare-fun inv@7@01 ($Ref Int) $Ref)
(declare-fun img@8@01 ($Ref Int) Bool)
(declare-fun inv@9@01 ($Ref Int) Int)
(declare-fun img@10@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@4@01 $Ref) (i@5@01 Int)) (!
  (=>
    (and (Set_in x@4@01 xs@2@01) (Seq_contains is@3@01 i@5@01))
    (or (Set_in x@4@01 xs@2@01) (not (Set_in x@4@01 xs@2@01))))
  :pattern ((Set_in x@4@01 xs@2@01) (Seq_contains is@3@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (Seq_contains_trigger is@3@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (Seq_contains_trigger is@3@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (inv@7@01 x@4@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (inv@9@01 x@4@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (img@8@01 x@4@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (img@10@01 x@4@01 i@5@01))
  :pattern ((Seq_contains is@3@01 i@5@01) (inv@7@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (inv@7@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (inv@7@01 x@4@01 i@5@01))
  :pattern ((Seq_contains is@3@01 i@5@01) (inv@9@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (inv@9@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (inv@9@01 x@4@01 i@5@01))
  :pattern ((Seq_contains is@3@01 i@5@01) (img@8@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (img@8@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (img@8@01 x@4@01 i@5@01))
  :pattern ((Seq_contains is@3@01 i@5@01) (img@10@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (img@10@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (img@10@01 x@4@01 i@5@01))
  :pattern ((inv@7@01 x@4@01 i@5@01))
  :pattern ((inv@9@01 x@4@01 i@5@01))
  :pattern ((img@8@01 x@4@01 i@5@01))
  :pattern ((img@10@01 x@4@01 i@5@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@4@01 $Ref) (i1@5@01 Int) (x2@4@01 $Ref) (i2@5@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@4@01 xs@2@01) (Seq_contains is@3@01 i1@5@01))
      (and (Set_in x2@4@01 xs@2@01) (Seq_contains is@3@01 i2@5@01))
      (and (= x1@4@01 x2@4@01) (= i1@5@01 i2@5@01)))
    (and (= x1@4@01 x2@4@01) (= i1@5@01 i2@5@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@4@01 $Ref) (i@5@01 Int)) (!
  (=>
    (and (Set_in x@4@01 xs@2@01) (Seq_contains is@3@01 i@5@01))
    (and
      (and
        (= (inv@7@01 x@4@01 i@5@01) x@4@01)
        (= (inv@9@01 x@4@01 i@5@01) i@5@01))
      (and (img@8@01 x@4@01 i@5@01) (img@10@01 x@4@01 i@5@01))))
  :pattern ((Set_in x@4@01 xs@2@01) (Seq_contains is@3@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (Seq_contains_trigger is@3@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (Seq_contains_trigger is@3@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (inv@7@01 x@4@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (inv@9@01 x@4@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (img@8@01 x@4@01 i@5@01))
  :pattern ((Set_in x@4@01 xs@2@01) (img@10@01 x@4@01 i@5@01))
  :pattern ((Seq_contains is@3@01 i@5@01) (inv@7@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (inv@7@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (inv@7@01 x@4@01 i@5@01))
  :pattern ((Seq_contains is@3@01 i@5@01) (inv@9@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (inv@9@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (inv@9@01 x@4@01 i@5@01))
  :pattern ((Seq_contains is@3@01 i@5@01) (img@8@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (img@8@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (img@8@01 x@4@01 i@5@01))
  :pattern ((Seq_contains is@3@01 i@5@01) (img@10@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (img@10@01 x@4@01 i@5@01))
  :pattern ((Seq_contains_trigger is@3@01 i@5@01) (img@10@01 x@4@01 i@5@01))
  :pattern ((inv@7@01 x@4@01 i@5@01))
  :pattern ((inv@9@01 x@4@01 i@5@01))
  :pattern ((img@8@01 x@4@01 i@5@01))
  :pattern ((img@10@01 x@4@01 i@5@01))
  :qid |quant-u-5014|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@8@01 x i) (img@10@01 x i))
      (and (Set_in (inv@7@01 x i) xs@2@01) (Seq_contains is@3@01 (inv@9@01 x i))))
    (and (= (inv@7@01 x i) x) (= (inv@9@01 x i) i)))
  :pattern ((inv@7@01 x i))
  :pattern ((inv@9@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const $t@11@01 $Snap)
(assert (= $t@11@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const x@12@01 $Ref)
(declare-const i@13@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 1 | !(x@12@01 in xs@2@01) | live]
; [else-branch: 1 | x@12@01 in xs@2@01 | live]
(push) ; 5
; [then-branch: 1 | !(x@12@01 in xs@2@01)]
(assert (not (Set_in x@12@01 xs@2@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 1 | x@12@01 in xs@2@01]
(assert (Set_in x@12@01 xs@2@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@12@01 xs@2@01) (not (Set_in x@12@01 xs@2@01))))
(push) ; 4
; [then-branch: 2 | x@12@01 in xs@2@01 && i@13@01 in is@3@01 | live]
; [else-branch: 2 | !(x@12@01 in xs@2@01 && i@13@01 in is@3@01) | live]
(push) ; 5
; [then-branch: 2 | x@12@01 in xs@2@01 && i@13@01 in is@3@01]
(assert (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01)))
; [eval] 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@14@01 ((x $Ref) (i Int) (x@12@01 $Ref) (i@13@01 Int)) $Perm
  (ite
    (and (= x x@12@01) (= i i@13@01))
    ($Perm.min
      (ite
        (and
          (and (img@8@01 x i) (img@10@01 x i))
          (and
            (Set_in (inv@7@01 x i) xs@2@01)
            (Seq_contains is@3@01 (inv@9@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@8@01 x i) (img@10@01 x i))
          (and
            (Set_in (inv@7@01 x i) xs@2@01)
            (Seq_contains is@3@01 (inv@9@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@14@01 x i x@12@01 i@13@01))
    $Perm.No)
  
  :qid |quant-u-5016|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@14@01 x i x@12@01 i@13@01) $Perm.No)
  
  :qid |quant-u-5017|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@12@01) (= i i@13@01))
    (= (- $Perm.Write (pTaken@14@01 x i x@12@01 i@13@01)) $Perm.No))
  
  :qid |quant-u-5018|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@15@01 $PSF<pair>)
(declare-const s@16@01 $Snap)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@8@01 x@12@01 i@13@01) (img@10@01 x@12@01 i@13@01))
    (and
      (Set_in (inv@7@01 x@12@01 i@13@01) xs@2@01)
      (Seq_contains is@3@01 (inv@9@01 x@12@01 i@13@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@12@01)
          ($SortWrappers.IntTo$Snap i@13@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@12@01)
        ($SortWrappers.IntTo$Snap i@13@01)))
      ($PSF.lookup_pair $t@6@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@12@01)
        ($SortWrappers.IntTo$Snap i@13@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@12@01)
  ($SortWrappers.IntTo$Snap i@13@01))) x@12@01 i@13@01))
(assert (=
  ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@12@01)
    ($SortWrappers.IntTo$Snap i@13@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@12@01)
      ($SortWrappers.IntTo$Snap i@13@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@12@01)
      ($SortWrappers.IntTo$Snap i@13@01)))))))
(assert (not (= x@12@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@8@01 x@12@01 i@13@01) (img@10@01 x@12@01 i@13@01))
      (and
        (Set_in (inv@7@01 x@12@01 i@13@01) xs@2@01)
        (Seq_contains is@3@01 (inv@9@01 x@12@01 i@13@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@12@01)
            ($SortWrappers.IntTo$Snap i@13@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@12@01)
          ($SortWrappers.IntTo$Snap i@13@01)))
        ($PSF.lookup_pair $t@6@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@12@01)
          ($SortWrappers.IntTo$Snap i@13@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@12@01)
    ($SortWrappers.IntTo$Snap i@13@01))) x@12@01 i@13@01)
  (=
    ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@12@01)
      ($SortWrappers.IntTo$Snap i@13@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@12@01)
        ($SortWrappers.IntTo$Snap i@13@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@12@01)
        ($SortWrappers.IntTo$Snap i@13@01))))))
  (not (= x@12@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@12@01)
  ($SortWrappers.IntTo$Snap i@13@01))))) i@13@01))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@12@01)
  ($SortWrappers.IntTo$Snap i@13@01))))) i@13@01))
(pop) ; 5
(push) ; 5
; [else-branch: 2 | !(x@12@01 in xs@2@01 && i@13@01 in is@3@01)]
(assert (not (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01))
  (and
    (Set_in x@12@01 xs@2@01)
    (Seq_contains is@3@01 i@13@01)
    (=>
      (and
        (and (img@8@01 x@12@01 i@13@01) (img@10@01 x@12@01 i@13@01))
        (and
          (Set_in (inv@7@01 x@12@01 i@13@01) xs@2@01)
          (Seq_contains is@3@01 (inv@9@01 x@12@01 i@13@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@12@01)
              ($SortWrappers.IntTo$Snap i@13@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@12@01)
            ($SortWrappers.IntTo$Snap i@13@01)))
          ($PSF.lookup_pair $t@6@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@12@01)
            ($SortWrappers.IntTo$Snap i@13@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@12@01)
      ($SortWrappers.IntTo$Snap i@13@01))) x@12@01 i@13@01)
    (=
      ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@12@01)
        ($SortWrappers.IntTo$Snap i@13@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@12@01)
          ($SortWrappers.IntTo$Snap i@13@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@12@01)
          ($SortWrappers.IntTo$Snap i@13@01))))))
    (not (= x@12@01 $Ref.null))
    (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@12@01)
      ($SortWrappers.IntTo$Snap i@13@01))))) i@13@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01)))
  (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@12@01 $Ref) (i@13@01 Int)) (!
  (and
    (or (Set_in x@12@01 xs@2@01) (not (Set_in x@12@01 xs@2@01)))
    (=>
      (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01))
      (and
        (Set_in x@12@01 xs@2@01)
        (Seq_contains is@3@01 i@13@01)
        (=>
          (and
            (and (img@8@01 x@12@01 i@13@01) (img@10@01 x@12@01 i@13@01))
            (and
              (Set_in (inv@7@01 x@12@01 i@13@01) xs@2@01)
              (Seq_contains is@3@01 (inv@9@01 x@12@01 i@13@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@12@01)
                  ($SortWrappers.IntTo$Snap i@13@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@12@01)
                ($SortWrappers.IntTo$Snap i@13@01)))
              ($PSF.lookup_pair $t@6@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@12@01)
                ($SortWrappers.IntTo$Snap i@13@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@12@01)
          ($SortWrappers.IntTo$Snap i@13@01))) x@12@01 i@13@01)
        (=
          ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@12@01)
            ($SortWrappers.IntTo$Snap i@13@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@12@01)
              ($SortWrappers.IntTo$Snap i@13@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@12@01)
              ($SortWrappers.IntTo$Snap i@13@01))))))
        (not (= x@12@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@12@01)
          ($SortWrappers.IntTo$Snap i@13@01))))) i@13@01)))
    (or
      (not (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01)))
      (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01))))
  :pattern ((Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01))
  :pattern ((Set_in x@12@01 xs@2@01) (Seq_contains_trigger is@3@01 i@13@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@35@10@36@68-aux|)))
(assert (forall ((x@12@01 $Ref) (i@13@01 Int)) (!
  (and
    (or (Set_in x@12@01 xs@2@01) (not (Set_in x@12@01 xs@2@01)))
    (=>
      (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01))
      (and
        (Set_in x@12@01 xs@2@01)
        (Seq_contains is@3@01 i@13@01)
        (=>
          (and
            (and (img@8@01 x@12@01 i@13@01) (img@10@01 x@12@01 i@13@01))
            (and
              (Set_in (inv@7@01 x@12@01 i@13@01) xs@2@01)
              (Seq_contains is@3@01 (inv@9@01 x@12@01 i@13@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@12@01)
                  ($SortWrappers.IntTo$Snap i@13@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@12@01)
                ($SortWrappers.IntTo$Snap i@13@01)))
              ($PSF.lookup_pair $t@6@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@12@01)
                ($SortWrappers.IntTo$Snap i@13@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@12@01)
          ($SortWrappers.IntTo$Snap i@13@01))) x@12@01 i@13@01)
        (=
          ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@12@01)
            ($SortWrappers.IntTo$Snap i@13@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@12@01)
              ($SortWrappers.IntTo$Snap i@13@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@12@01)
              ($SortWrappers.IntTo$Snap i@13@01))))))
        (not (= x@12@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@12@01)
          ($SortWrappers.IntTo$Snap i@13@01))))) i@13@01)))
    (or
      (not (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01)))
      (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01))))
  :pattern ((Set_in x@12@01 xs@2@01) (Seq_contains_trigger is@3@01 i@13@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@35@10@36@68-aux|)))
(assert (forall ((x@12@01 $Ref) (i@13@01 Int)) (!
  (=>
    (and (Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01))
    (<
      0
      (addA $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@12@01)
        ($SortWrappers.IntTo$Snap i@13@01))))) i@13@01)))
  :pattern ((Set_in x@12@01 xs@2@01) (Seq_contains is@3@01 i@13@01))
  :pattern ((Set_in x@12@01 xs@2@01) (Seq_contains_trigger is@3@01 i@13@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@35@10@36@68|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert (forall x: Ref, i: Int ::
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@17@01 $Ref)
(declare-const i@18@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 3 | !(x@17@01 in xs@2@01) | live]
; [else-branch: 3 | x@17@01 in xs@2@01 | live]
(push) ; 5
; [then-branch: 3 | !(x@17@01 in xs@2@01)]
(assert (not (Set_in x@17@01 xs@2@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 3 | x@17@01 in xs@2@01]
(assert (Set_in x@17@01 xs@2@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@17@01 xs@2@01) (not (Set_in x@17@01 xs@2@01))))
(push) ; 4
; [then-branch: 4 | x@17@01 in xs@2@01 && i@18@01 in is@3@01 | live]
; [else-branch: 4 | !(x@17@01 in xs@2@01 && i@18@01 in is@3@01) | live]
(push) ; 5
; [then-branch: 4 | x@17@01 in xs@2@01 && i@18@01 in is@3@01]
(assert (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01)))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@19@01 ((x $Ref) (i Int) (x@17@01 $Ref) (i@18@01 Int)) $Perm
  (ite
    (and (= x x@17@01) (= i i@18@01))
    ($Perm.min
      (ite
        (and
          (and (img@8@01 x i) (img@10@01 x i))
          (and
            (Set_in (inv@7@01 x i) xs@2@01)
            (Seq_contains is@3@01 (inv@9@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@8@01 x i) (img@10@01 x i))
          (and
            (Set_in (inv@7@01 x i) xs@2@01)
            (Seq_contains is@3@01 (inv@9@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@19@01 x i x@17@01 i@18@01))
    $Perm.No)
  
  :qid |quant-u-5020|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@19@01 x i x@17@01 i@18@01) $Perm.No)
  
  :qid |quant-u-5021|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@17@01) (= i i@18@01))
    (= (- $Perm.Write (pTaken@19@01 x i x@17@01 i@18@01)) $Perm.No))
  
  :qid |quant-u-5022|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@8@01 x@17@01 i@18@01) (img@10@01 x@17@01 i@18@01))
    (and
      (Set_in (inv@7@01 x@17@01 i@18@01) xs@2@01)
      (Seq_contains is@3@01 (inv@9@01 x@17@01 i@18@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@17@01)
          ($SortWrappers.IntTo$Snap i@18@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@17@01)
        ($SortWrappers.IntTo$Snap i@18@01)))
      ($PSF.lookup_pair $t@6@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@17@01)
        ($SortWrappers.IntTo$Snap i@18@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@17@01)
  ($SortWrappers.IntTo$Snap i@18@01))) x@17@01 i@18@01))
(assert (=
  ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@17@01)
    ($SortWrappers.IntTo$Snap i@18@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@17@01)
      ($SortWrappers.IntTo$Snap i@18@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@17@01)
      ($SortWrappers.IntTo$Snap i@18@01)))))))
(assert (not (= x@17@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@8@01 x@17@01 i@18@01) (img@10@01 x@17@01 i@18@01))
      (and
        (Set_in (inv@7@01 x@17@01 i@18@01) xs@2@01)
        (Seq_contains is@3@01 (inv@9@01 x@17@01 i@18@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@17@01)
            ($SortWrappers.IntTo$Snap i@18@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@17@01)
          ($SortWrappers.IntTo$Snap i@18@01)))
        ($PSF.lookup_pair $t@6@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@17@01)
          ($SortWrappers.IntTo$Snap i@18@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@17@01)
    ($SortWrappers.IntTo$Snap i@18@01))) x@17@01 i@18@01)
  (=
    ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@17@01)
      ($SortWrappers.IntTo$Snap i@18@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@17@01)
        ($SortWrappers.IntTo$Snap i@18@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@17@01)
        ($SortWrappers.IntTo$Snap i@18@01))))))
  (not (= x@17@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@18@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@17@01)
  ($SortWrappers.IntTo$Snap i@18@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@18@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@17@01)
  ($SortWrappers.IntTo$Snap i@18@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 4 | !(x@17@01 in xs@2@01 && i@18@01 in is@3@01)]
(assert (not (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))
  (and
    (Set_in x@17@01 xs@2@01)
    (Seq_contains is@3@01 i@18@01)
    (=>
      (and
        (and (img@8@01 x@17@01 i@18@01) (img@10@01 x@17@01 i@18@01))
        (and
          (Set_in (inv@7@01 x@17@01 i@18@01) xs@2@01)
          (Seq_contains is@3@01 (inv@9@01 x@17@01 i@18@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@17@01)
              ($SortWrappers.IntTo$Snap i@18@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@17@01)
            ($SortWrappers.IntTo$Snap i@18@01)))
          ($PSF.lookup_pair $t@6@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@17@01)
            ($SortWrappers.IntTo$Snap i@18@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@17@01)
      ($SortWrappers.IntTo$Snap i@18@01))) x@17@01 i@18@01)
    (=
      ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@17@01)
        ($SortWrappers.IntTo$Snap i@18@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@17@01)
          ($SortWrappers.IntTo$Snap i@18@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@17@01)
          ($SortWrappers.IntTo$Snap i@18@01))))))
    (not (= x@17@01 $Ref.null))
    (addA%precondition $Snap.unit i@18@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@17@01)
      ($SortWrappers.IntTo$Snap i@18@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01)))
  (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@17@01 $Ref) (i@18@01 Int)) (!
  (and
    (or (Set_in x@17@01 xs@2@01) (not (Set_in x@17@01 xs@2@01)))
    (=>
      (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))
      (and
        (Set_in x@17@01 xs@2@01)
        (Seq_contains is@3@01 i@18@01)
        (=>
          (and
            (and (img@8@01 x@17@01 i@18@01) (img@10@01 x@17@01 i@18@01))
            (and
              (Set_in (inv@7@01 x@17@01 i@18@01) xs@2@01)
              (Seq_contains is@3@01 (inv@9@01 x@17@01 i@18@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@17@01)
                  ($SortWrappers.IntTo$Snap i@18@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@17@01)
                ($SortWrappers.IntTo$Snap i@18@01)))
              ($PSF.lookup_pair $t@6@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@17@01)
                ($SortWrappers.IntTo$Snap i@18@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@17@01)
          ($SortWrappers.IntTo$Snap i@18@01))) x@17@01 i@18@01)
        (=
          ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@17@01)
            ($SortWrappers.IntTo$Snap i@18@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@17@01)
              ($SortWrappers.IntTo$Snap i@18@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@17@01)
              ($SortWrappers.IntTo$Snap i@18@01))))))
        (not (= x@17@01 $Ref.null))
        (addA%precondition $Snap.unit i@18@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@17@01)
          ($SortWrappers.IntTo$Snap i@18@01))))))))
    (or
      (not (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01)))
      (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains_trigger is@3@01 i@18@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@38@10@39@68-aux|)))
(assert (forall ((x@17@01 $Ref) (i@18@01 Int)) (!
  (and
    (or (Set_in x@17@01 xs@2@01) (not (Set_in x@17@01 xs@2@01)))
    (=>
      (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))
      (and
        (Set_in x@17@01 xs@2@01)
        (Seq_contains is@3@01 i@18@01)
        (=>
          (and
            (and (img@8@01 x@17@01 i@18@01) (img@10@01 x@17@01 i@18@01))
            (and
              (Set_in (inv@7@01 x@17@01 i@18@01) xs@2@01)
              (Seq_contains is@3@01 (inv@9@01 x@17@01 i@18@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@17@01)
                  ($SortWrappers.IntTo$Snap i@18@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@17@01)
                ($SortWrappers.IntTo$Snap i@18@01)))
              ($PSF.lookup_pair $t@6@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@17@01)
                ($SortWrappers.IntTo$Snap i@18@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@17@01)
          ($SortWrappers.IntTo$Snap i@18@01))) x@17@01 i@18@01)
        (=
          ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@17@01)
            ($SortWrappers.IntTo$Snap i@18@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@17@01)
              ($SortWrappers.IntTo$Snap i@18@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@17@01)
              ($SortWrappers.IntTo$Snap i@18@01))))))
        (not (= x@17@01 $Ref.null))
        (addA%precondition $Snap.unit i@18@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@17@01)
          ($SortWrappers.IntTo$Snap i@18@01))))))))
    (or
      (not (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01)))
      (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains_trigger is@3@01 i@18@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@38@10@39@68-aux|)))
(assert (forall ((x@17@01 $Ref) (i@18@01 Int)) (!
  (=>
    (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))
    (addA%precondition $Snap.unit i@18@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@17@01)
      ($SortWrappers.IntTo$Snap i@18@01)))))))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains_trigger is@3@01 i@18@01))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains_trigger is@3@01 i@18@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@38@10@39@68_precondition|)))
(push) ; 3
(assert (not (forall ((x@17@01 $Ref) (i@18@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))
        (addA%precondition $Snap.unit i@18@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@17@01)
          ($SortWrappers.IntTo$Snap i@18@01)))))))
      (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01)))
    (<
      0
      (addA $Snap.unit i@18@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@17@01)
        ($SortWrappers.IntTo$Snap i@18@01))))))))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains_trigger is@3@01 i@18@01))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains_trigger is@3@01 i@18@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@38@10@39@68|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (forall ((x@17@01 $Ref) (i@18@01 Int)) (!
  (=>
    (and (Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))
    (<
      0
      (addA $Snap.unit i@18@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@15@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@17@01)
        ($SortWrappers.IntTo$Snap i@18@01))))))))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains is@3@01 i@18@01))
  :pattern ((Set_in x@17@01 xs@2@01) (Seq_contains_trigger is@3@01 i@18@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@38@10@39@68|)))
(pop) ; 2
(pop) ; 1
; ---------- test01b ----------
(declare-const xs@20@01 Set<$Ref>)
(declare-const is@21@01 Seq<Int>)
(declare-const xs@22@01 Set<$Ref>)
(declare-const is@23@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@24@01 $Ref)
(declare-const i@25@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 5 | !(x@24@01 in xs@22@01) | live]
; [else-branch: 5 | x@24@01 in xs@22@01 | live]
(push) ; 5
; [then-branch: 5 | !(x@24@01 in xs@22@01)]
(assert (not (Set_in x@24@01 xs@22@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 5 | x@24@01 in xs@22@01]
(assert (Set_in x@24@01 xs@22@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@24@01 xs@22@01) (not (Set_in x@24@01 xs@22@01))))
(assert (and (Set_in x@24@01 xs@22@01) (Seq_contains is@23@01 i@25@01)))
(pop) ; 3
(declare-const $t@26@01 $PSF<pair>)
(declare-fun inv@27@01 ($Ref Int) $Ref)
(declare-fun img@28@01 ($Ref Int) Bool)
(declare-fun inv@29@01 ($Ref Int) Int)
(declare-fun img@30@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@24@01 $Ref) (i@25@01 Int)) (!
  (=>
    (and (Set_in x@24@01 xs@22@01) (Seq_contains is@23@01 i@25@01))
    (or (Set_in x@24@01 xs@22@01) (not (Set_in x@24@01 xs@22@01))))
  :pattern ((Set_in x@24@01 xs@22@01) (Seq_contains is@23@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (Seq_contains_trigger is@23@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (Seq_contains_trigger is@23@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (inv@27@01 x@24@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (inv@29@01 x@24@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (img@28@01 x@24@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (img@30@01 x@24@01 i@25@01))
  :pattern ((Seq_contains is@23@01 i@25@01) (inv@27@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (inv@27@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (inv@27@01 x@24@01 i@25@01))
  :pattern ((Seq_contains is@23@01 i@25@01) (inv@29@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (inv@29@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (inv@29@01 x@24@01 i@25@01))
  :pattern ((Seq_contains is@23@01 i@25@01) (img@28@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (img@28@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (img@28@01 x@24@01 i@25@01))
  :pattern ((Seq_contains is@23@01 i@25@01) (img@30@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (img@30@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (img@30@01 x@24@01 i@25@01))
  :pattern ((inv@27@01 x@24@01 i@25@01))
  :pattern ((inv@29@01 x@24@01 i@25@01))
  :pattern ((img@28@01 x@24@01 i@25@01))
  :pattern ((img@30@01 x@24@01 i@25@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@24@01 $Ref) (i1@25@01 Int) (x2@24@01 $Ref) (i2@25@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@24@01 xs@22@01) (Seq_contains is@23@01 i1@25@01))
      (and (Set_in x2@24@01 xs@22@01) (Seq_contains is@23@01 i2@25@01))
      (and (= x1@24@01 x2@24@01) (= i1@25@01 i2@25@01)))
    (and (= x1@24@01 x2@24@01) (= i1@25@01 i2@25@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@24@01 $Ref) (i@25@01 Int)) (!
  (=>
    (and (Set_in x@24@01 xs@22@01) (Seq_contains is@23@01 i@25@01))
    (and
      (and
        (= (inv@27@01 x@24@01 i@25@01) x@24@01)
        (= (inv@29@01 x@24@01 i@25@01) i@25@01))
      (and (img@28@01 x@24@01 i@25@01) (img@30@01 x@24@01 i@25@01))))
  :pattern ((Set_in x@24@01 xs@22@01) (Seq_contains is@23@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (Seq_contains_trigger is@23@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (Seq_contains_trigger is@23@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (inv@27@01 x@24@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (inv@29@01 x@24@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (img@28@01 x@24@01 i@25@01))
  :pattern ((Set_in x@24@01 xs@22@01) (img@30@01 x@24@01 i@25@01))
  :pattern ((Seq_contains is@23@01 i@25@01) (inv@27@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (inv@27@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (inv@27@01 x@24@01 i@25@01))
  :pattern ((Seq_contains is@23@01 i@25@01) (inv@29@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (inv@29@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (inv@29@01 x@24@01 i@25@01))
  :pattern ((Seq_contains is@23@01 i@25@01) (img@28@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (img@28@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (img@28@01 x@24@01 i@25@01))
  :pattern ((Seq_contains is@23@01 i@25@01) (img@30@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (img@30@01 x@24@01 i@25@01))
  :pattern ((Seq_contains_trigger is@23@01 i@25@01) (img@30@01 x@24@01 i@25@01))
  :pattern ((inv@27@01 x@24@01 i@25@01))
  :pattern ((inv@29@01 x@24@01 i@25@01))
  :pattern ((img@28@01 x@24@01 i@25@01))
  :pattern ((img@30@01 x@24@01 i@25@01))
  :qid |quant-u-5024|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@28@01 x i) (img@30@01 x i))
      (and
        (Set_in (inv@27@01 x i) xs@22@01)
        (Seq_contains is@23@01 (inv@29@01 x i))))
    (and (= (inv@27@01 x i) x) (= (inv@29@01 x i) i)))
  :pattern ((inv@27@01 x i))
  :pattern ((inv@29@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const $t@31@01 $Snap)
(assert (= $t@31@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const x@32@01 $Ref)
(declare-const i@33@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 6 | !(x@32@01 in xs@22@01) | live]
; [else-branch: 6 | x@32@01 in xs@22@01 | live]
(push) ; 5
; [then-branch: 6 | !(x@32@01 in xs@22@01)]
(assert (not (Set_in x@32@01 xs@22@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 6 | x@32@01 in xs@22@01]
(assert (Set_in x@32@01 xs@22@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@32@01 xs@22@01) (not (Set_in x@32@01 xs@22@01))))
(push) ; 4
; [then-branch: 7 | x@32@01 in xs@22@01 && i@33@01 in is@23@01 | live]
; [else-branch: 7 | !(x@32@01 in xs@22@01 && i@33@01 in is@23@01) | live]
(push) ; 5
; [then-branch: 7 | x@32@01 in xs@22@01 && i@33@01 in is@23@01]
(assert (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01)))
; [eval] 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@34@01 ((x $Ref) (i Int) (x@32@01 $Ref) (i@33@01 Int)) $Perm
  (ite
    (and (= x x@32@01) (= i i@33@01))
    ($Perm.min
      (ite
        (and
          (and (img@28@01 x i) (img@30@01 x i))
          (and
            (Set_in (inv@27@01 x i) xs@22@01)
            (Seq_contains is@23@01 (inv@29@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@28@01 x i) (img@30@01 x i))
          (and
            (Set_in (inv@27@01 x i) xs@22@01)
            (Seq_contains is@23@01 (inv@29@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@34@01 x i x@32@01 i@33@01))
    $Perm.No)
  
  :qid |quant-u-5026|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@34@01 x i x@32@01 i@33@01) $Perm.No)
  
  :qid |quant-u-5027|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@32@01) (= i i@33@01))
    (= (- $Perm.Write (pTaken@34@01 x i x@32@01 i@33@01)) $Perm.No))
  
  :qid |quant-u-5028|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@35@01 $PSF<pair>)
(declare-const s@36@01 $Snap)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@28@01 x@32@01 i@33@01) (img@30@01 x@32@01 i@33@01))
    (and
      (Set_in (inv@27@01 x@32@01 i@33@01) xs@22@01)
      (Seq_contains is@23@01 (inv@29@01 x@32@01 i@33@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@32@01)
          ($SortWrappers.IntTo$Snap i@33@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@32@01)
        ($SortWrappers.IntTo$Snap i@33@01)))
      ($PSF.lookup_pair $t@26@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@32@01)
        ($SortWrappers.IntTo$Snap i@33@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@32@01)
  ($SortWrappers.IntTo$Snap i@33@01))) x@32@01 i@33@01))
(assert (=
  ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@32@01)
    ($SortWrappers.IntTo$Snap i@33@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@32@01)
      ($SortWrappers.IntTo$Snap i@33@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@32@01)
      ($SortWrappers.IntTo$Snap i@33@01)))))))
(assert (not (= x@32@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@28@01 x@32@01 i@33@01) (img@30@01 x@32@01 i@33@01))
      (and
        (Set_in (inv@27@01 x@32@01 i@33@01) xs@22@01)
        (Seq_contains is@23@01 (inv@29@01 x@32@01 i@33@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@32@01)
            ($SortWrappers.IntTo$Snap i@33@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@32@01)
          ($SortWrappers.IntTo$Snap i@33@01)))
        ($PSF.lookup_pair $t@26@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@32@01)
          ($SortWrappers.IntTo$Snap i@33@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@32@01)
    ($SortWrappers.IntTo$Snap i@33@01))) x@32@01 i@33@01)
  (=
    ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@32@01)
      ($SortWrappers.IntTo$Snap i@33@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@32@01)
        ($SortWrappers.IntTo$Snap i@33@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@32@01)
        ($SortWrappers.IntTo$Snap i@33@01))))))
  (not (= x@32@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@32@01)
  ($SortWrappers.IntTo$Snap i@33@01))))) i@33@01))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@32@01)
  ($SortWrappers.IntTo$Snap i@33@01))))) i@33@01))
(pop) ; 5
(push) ; 5
; [else-branch: 7 | !(x@32@01 in xs@22@01 && i@33@01 in is@23@01)]
(assert (not (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01))
  (and
    (Set_in x@32@01 xs@22@01)
    (Seq_contains is@23@01 i@33@01)
    (=>
      (and
        (and (img@28@01 x@32@01 i@33@01) (img@30@01 x@32@01 i@33@01))
        (and
          (Set_in (inv@27@01 x@32@01 i@33@01) xs@22@01)
          (Seq_contains is@23@01 (inv@29@01 x@32@01 i@33@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@32@01)
              ($SortWrappers.IntTo$Snap i@33@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@32@01)
            ($SortWrappers.IntTo$Snap i@33@01)))
          ($PSF.lookup_pair $t@26@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@32@01)
            ($SortWrappers.IntTo$Snap i@33@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@32@01)
      ($SortWrappers.IntTo$Snap i@33@01))) x@32@01 i@33@01)
    (=
      ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@32@01)
        ($SortWrappers.IntTo$Snap i@33@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@32@01)
          ($SortWrappers.IntTo$Snap i@33@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@32@01)
          ($SortWrappers.IntTo$Snap i@33@01))))))
    (not (= x@32@01 $Ref.null))
    (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@32@01)
      ($SortWrappers.IntTo$Snap i@33@01))))) i@33@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01)))
  (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@32@01 $Ref) (i@33@01 Int)) (!
  (and
    (or (Set_in x@32@01 xs@22@01) (not (Set_in x@32@01 xs@22@01)))
    (=>
      (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01))
      (and
        (Set_in x@32@01 xs@22@01)
        (Seq_contains is@23@01 i@33@01)
        (=>
          (and
            (and (img@28@01 x@32@01 i@33@01) (img@30@01 x@32@01 i@33@01))
            (and
              (Set_in (inv@27@01 x@32@01 i@33@01) xs@22@01)
              (Seq_contains is@23@01 (inv@29@01 x@32@01 i@33@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@32@01)
                  ($SortWrappers.IntTo$Snap i@33@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@32@01)
                ($SortWrappers.IntTo$Snap i@33@01)))
              ($PSF.lookup_pair $t@26@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@32@01)
                ($SortWrappers.IntTo$Snap i@33@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@32@01)
          ($SortWrappers.IntTo$Snap i@33@01))) x@32@01 i@33@01)
        (=
          ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@32@01)
            ($SortWrappers.IntTo$Snap i@33@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@32@01)
              ($SortWrappers.IntTo$Snap i@33@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@32@01)
              ($SortWrappers.IntTo$Snap i@33@01))))))
        (not (= x@32@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@32@01)
          ($SortWrappers.IntTo$Snap i@33@01))))) i@33@01)))
    (or
      (not (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01)))
      (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01))))
  :pattern ((Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01))
  :pattern ((Set_in x@32@01 xs@22@01) (Seq_contains_trigger is@23@01 i@33@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@45@10@46@68-aux|)))
(assert (forall ((x@32@01 $Ref) (i@33@01 Int)) (!
  (and
    (or (Set_in x@32@01 xs@22@01) (not (Set_in x@32@01 xs@22@01)))
    (=>
      (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01))
      (and
        (Set_in x@32@01 xs@22@01)
        (Seq_contains is@23@01 i@33@01)
        (=>
          (and
            (and (img@28@01 x@32@01 i@33@01) (img@30@01 x@32@01 i@33@01))
            (and
              (Set_in (inv@27@01 x@32@01 i@33@01) xs@22@01)
              (Seq_contains is@23@01 (inv@29@01 x@32@01 i@33@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@32@01)
                  ($SortWrappers.IntTo$Snap i@33@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@32@01)
                ($SortWrappers.IntTo$Snap i@33@01)))
              ($PSF.lookup_pair $t@26@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@32@01)
                ($SortWrappers.IntTo$Snap i@33@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@32@01)
          ($SortWrappers.IntTo$Snap i@33@01))) x@32@01 i@33@01)
        (=
          ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@32@01)
            ($SortWrappers.IntTo$Snap i@33@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@32@01)
              ($SortWrappers.IntTo$Snap i@33@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@32@01)
              ($SortWrappers.IntTo$Snap i@33@01))))))
        (not (= x@32@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@32@01)
          ($SortWrappers.IntTo$Snap i@33@01))))) i@33@01)))
    (or
      (not (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01)))
      (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01))))
  :pattern ((Set_in x@32@01 xs@22@01) (Seq_contains_trigger is@23@01 i@33@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@45@10@46@68-aux|)))
(assert (forall ((x@32@01 $Ref) (i@33@01 Int)) (!
  (=>
    (and (Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01))
    (<
      0
      (addA $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@32@01)
        ($SortWrappers.IntTo$Snap i@33@01))))) i@33@01)))
  :pattern ((Set_in x@32@01 xs@22@01) (Seq_contains is@23@01 i@33@01))
  :pattern ((Set_in x@32@01 xs@22@01) (Seq_contains_trigger is@23@01 i@33@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@45@10@46@68|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert (forall x: Ref, i: Int ::
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@37@01 $Ref)
(declare-const i@38@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 8 | !(x@37@01 in xs@22@01) | live]
; [else-branch: 8 | x@37@01 in xs@22@01 | live]
(push) ; 5
; [then-branch: 8 | !(x@37@01 in xs@22@01)]
(assert (not (Set_in x@37@01 xs@22@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 8 | x@37@01 in xs@22@01]
(assert (Set_in x@37@01 xs@22@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@37@01 xs@22@01) (not (Set_in x@37@01 xs@22@01))))
(push) ; 4
; [then-branch: 9 | x@37@01 in xs@22@01 && i@38@01 in is@23@01 | live]
; [else-branch: 9 | !(x@37@01 in xs@22@01 && i@38@01 in is@23@01) | live]
(push) ; 5
; [then-branch: 9 | x@37@01 in xs@22@01 && i@38@01 in is@23@01]
(assert (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01)))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@39@01 ((x $Ref) (i Int) (x@37@01 $Ref) (i@38@01 Int)) $Perm
  (ite
    (and (= x x@37@01) (= i i@38@01))
    ($Perm.min
      (ite
        (and
          (and (img@28@01 x i) (img@30@01 x i))
          (and
            (Set_in (inv@27@01 x i) xs@22@01)
            (Seq_contains is@23@01 (inv@29@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@28@01 x i) (img@30@01 x i))
          (and
            (Set_in (inv@27@01 x i) xs@22@01)
            (Seq_contains is@23@01 (inv@29@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@39@01 x i x@37@01 i@38@01))
    $Perm.No)
  
  :qid |quant-u-5030|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@39@01 x i x@37@01 i@38@01) $Perm.No)
  
  :qid |quant-u-5031|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@37@01) (= i i@38@01))
    (= (- $Perm.Write (pTaken@39@01 x i x@37@01 i@38@01)) $Perm.No))
  
  :qid |quant-u-5032|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@28@01 x@37@01 i@38@01) (img@30@01 x@37@01 i@38@01))
    (and
      (Set_in (inv@27@01 x@37@01 i@38@01) xs@22@01)
      (Seq_contains is@23@01 (inv@29@01 x@37@01 i@38@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@37@01)
          ($SortWrappers.IntTo$Snap i@38@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@37@01)
        ($SortWrappers.IntTo$Snap i@38@01)))
      ($PSF.lookup_pair $t@26@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@37@01)
        ($SortWrappers.IntTo$Snap i@38@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@37@01)
  ($SortWrappers.IntTo$Snap i@38@01))) x@37@01 i@38@01))
(assert (=
  ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@37@01)
    ($SortWrappers.IntTo$Snap i@38@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@37@01)
      ($SortWrappers.IntTo$Snap i@38@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@37@01)
      ($SortWrappers.IntTo$Snap i@38@01)))))))
(assert (not (= x@37@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@28@01 x@37@01 i@38@01) (img@30@01 x@37@01 i@38@01))
      (and
        (Set_in (inv@27@01 x@37@01 i@38@01) xs@22@01)
        (Seq_contains is@23@01 (inv@29@01 x@37@01 i@38@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@37@01)
            ($SortWrappers.IntTo$Snap i@38@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@37@01)
          ($SortWrappers.IntTo$Snap i@38@01)))
        ($PSF.lookup_pair $t@26@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@37@01)
          ($SortWrappers.IntTo$Snap i@38@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@37@01)
    ($SortWrappers.IntTo$Snap i@38@01))) x@37@01 i@38@01)
  (=
    ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@37@01)
      ($SortWrappers.IntTo$Snap i@38@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@37@01)
        ($SortWrappers.IntTo$Snap i@38@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@37@01)
        ($SortWrappers.IntTo$Snap i@38@01))))))
  (not (= x@37@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@38@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@37@01)
  ($SortWrappers.IntTo$Snap i@38@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@38@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@37@01)
  ($SortWrappers.IntTo$Snap i@38@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 9 | !(x@37@01 in xs@22@01 && i@38@01 in is@23@01)]
(assert (not (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))
  (and
    (Set_in x@37@01 xs@22@01)
    (Seq_contains is@23@01 i@38@01)
    (=>
      (and
        (and (img@28@01 x@37@01 i@38@01) (img@30@01 x@37@01 i@38@01))
        (and
          (Set_in (inv@27@01 x@37@01 i@38@01) xs@22@01)
          (Seq_contains is@23@01 (inv@29@01 x@37@01 i@38@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@37@01)
              ($SortWrappers.IntTo$Snap i@38@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@37@01)
            ($SortWrappers.IntTo$Snap i@38@01)))
          ($PSF.lookup_pair $t@26@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@37@01)
            ($SortWrappers.IntTo$Snap i@38@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@37@01)
      ($SortWrappers.IntTo$Snap i@38@01))) x@37@01 i@38@01)
    (=
      ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@37@01)
        ($SortWrappers.IntTo$Snap i@38@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@37@01)
          ($SortWrappers.IntTo$Snap i@38@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@37@01)
          ($SortWrappers.IntTo$Snap i@38@01))))))
    (not (= x@37@01 $Ref.null))
    (addA%precondition $Snap.unit i@38@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@37@01)
      ($SortWrappers.IntTo$Snap i@38@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01)))
  (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@37@01 $Ref) (i@38@01 Int)) (!
  (and
    (or (Set_in x@37@01 xs@22@01) (not (Set_in x@37@01 xs@22@01)))
    (=>
      (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))
      (and
        (Set_in x@37@01 xs@22@01)
        (Seq_contains is@23@01 i@38@01)
        (=>
          (and
            (and (img@28@01 x@37@01 i@38@01) (img@30@01 x@37@01 i@38@01))
            (and
              (Set_in (inv@27@01 x@37@01 i@38@01) xs@22@01)
              (Seq_contains is@23@01 (inv@29@01 x@37@01 i@38@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@37@01)
                  ($SortWrappers.IntTo$Snap i@38@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@37@01)
                ($SortWrappers.IntTo$Snap i@38@01)))
              ($PSF.lookup_pair $t@26@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@37@01)
                ($SortWrappers.IntTo$Snap i@38@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@37@01)
          ($SortWrappers.IntTo$Snap i@38@01))) x@37@01 i@38@01)
        (=
          ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@37@01)
            ($SortWrappers.IntTo$Snap i@38@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@37@01)
              ($SortWrappers.IntTo$Snap i@38@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@37@01)
              ($SortWrappers.IntTo$Snap i@38@01))))))
        (not (= x@37@01 $Ref.null))
        (addA%precondition $Snap.unit i@38@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@37@01)
          ($SortWrappers.IntTo$Snap i@38@01))))))))
    (or
      (not (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01)))
      (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains_trigger is@23@01 i@38@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@48@10@49@68-aux|)))
(assert (forall ((x@37@01 $Ref) (i@38@01 Int)) (!
  (and
    (or (Set_in x@37@01 xs@22@01) (not (Set_in x@37@01 xs@22@01)))
    (=>
      (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))
      (and
        (Set_in x@37@01 xs@22@01)
        (Seq_contains is@23@01 i@38@01)
        (=>
          (and
            (and (img@28@01 x@37@01 i@38@01) (img@30@01 x@37@01 i@38@01))
            (and
              (Set_in (inv@27@01 x@37@01 i@38@01) xs@22@01)
              (Seq_contains is@23@01 (inv@29@01 x@37@01 i@38@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@37@01)
                  ($SortWrappers.IntTo$Snap i@38@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@37@01)
                ($SortWrappers.IntTo$Snap i@38@01)))
              ($PSF.lookup_pair $t@26@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@37@01)
                ($SortWrappers.IntTo$Snap i@38@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@37@01)
          ($SortWrappers.IntTo$Snap i@38@01))) x@37@01 i@38@01)
        (=
          ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@37@01)
            ($SortWrappers.IntTo$Snap i@38@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@37@01)
              ($SortWrappers.IntTo$Snap i@38@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@37@01)
              ($SortWrappers.IntTo$Snap i@38@01))))))
        (not (= x@37@01 $Ref.null))
        (addA%precondition $Snap.unit i@38@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@37@01)
          ($SortWrappers.IntTo$Snap i@38@01))))))))
    (or
      (not (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01)))
      (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains_trigger is@23@01 i@38@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@48@10@49@68-aux|)))
(assert (forall ((x@37@01 $Ref) (i@38@01 Int)) (!
  (=>
    (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))
    (addA%precondition $Snap.unit i@38@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@37@01)
      ($SortWrappers.IntTo$Snap i@38@01)))))))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains_trigger is@23@01 i@38@01))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains_trigger is@23@01 i@38@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@48@10@49@68_precondition|)))
(push) ; 3
(assert (not (forall ((x@37@01 $Ref) (i@38@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))
        (addA%precondition $Snap.unit i@38@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@37@01)
          ($SortWrappers.IntTo$Snap i@38@01)))))))
      (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01)))
    (<
      0
      (addA $Snap.unit i@38@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@37@01)
        ($SortWrappers.IntTo$Snap i@38@01))))))))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains_trigger is@23@01 i@38@01))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains_trigger is@23@01 i@38@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@48@10@49@68|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (forall ((x@37@01 $Ref) (i@38@01 Int)) (!
  (=>
    (and (Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))
    (<
      0
      (addA $Snap.unit i@38@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@35@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@37@01)
        ($SortWrappers.IntTo$Snap i@38@01))))))))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains is@23@01 i@38@01))
  :pattern ((Set_in x@37@01 xs@22@01) (Seq_contains_trigger is@23@01 i@38@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@48@10@49@68|)))
(pop) ; 2
(pop) ; 1
; ---------- test01c ----------
(declare-const xs@40@01 Set<$Ref>)
(declare-const is@41@01 Seq<Int>)
(declare-const xs@42@01 Set<$Ref>)
(declare-const is@43@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var tx: Ref
(declare-const tx@44@01 $Ref)
; [exec]
; var ti: Int
(declare-const ti@45@01 Int)
; [exec]
; var tmp: Int
(declare-const tmp@46@01 Int)
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@47@01 $Ref)
(declare-const i@48@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 10 | !(x@47@01 in xs@42@01) | live]
; [else-branch: 10 | x@47@01 in xs@42@01 | live]
(push) ; 5
; [then-branch: 10 | !(x@47@01 in xs@42@01)]
(assert (not (Set_in x@47@01 xs@42@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 10 | x@47@01 in xs@42@01]
(assert (Set_in x@47@01 xs@42@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@47@01 xs@42@01) (not (Set_in x@47@01 xs@42@01))))
(assert (and (Set_in x@47@01 xs@42@01) (Seq_contains is@43@01 i@48@01)))
(pop) ; 3
(declare-const $t@49@01 $PSF<pair>)
(declare-fun inv@50@01 ($Ref Int) $Ref)
(declare-fun img@51@01 ($Ref Int) Bool)
(declare-fun inv@52@01 ($Ref Int) Int)
(declare-fun img@53@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@47@01 $Ref) (i@48@01 Int)) (!
  (=>
    (and (Set_in x@47@01 xs@42@01) (Seq_contains is@43@01 i@48@01))
    (or (Set_in x@47@01 xs@42@01) (not (Set_in x@47@01 xs@42@01))))
  :pattern ((Set_in x@47@01 xs@42@01) (Seq_contains is@43@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (Seq_contains_trigger is@43@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (Seq_contains_trigger is@43@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (inv@50@01 x@47@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (inv@52@01 x@47@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (img@51@01 x@47@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (img@53@01 x@47@01 i@48@01))
  :pattern ((Seq_contains is@43@01 i@48@01) (inv@50@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (inv@50@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (inv@50@01 x@47@01 i@48@01))
  :pattern ((Seq_contains is@43@01 i@48@01) (inv@52@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (inv@52@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (inv@52@01 x@47@01 i@48@01))
  :pattern ((Seq_contains is@43@01 i@48@01) (img@51@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (img@51@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (img@51@01 x@47@01 i@48@01))
  :pattern ((Seq_contains is@43@01 i@48@01) (img@53@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (img@53@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (img@53@01 x@47@01 i@48@01))
  :pattern ((inv@50@01 x@47@01 i@48@01))
  :pattern ((inv@52@01 x@47@01 i@48@01))
  :pattern ((img@51@01 x@47@01 i@48@01))
  :pattern ((img@53@01 x@47@01 i@48@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@47@01 $Ref) (i1@48@01 Int) (x2@47@01 $Ref) (i2@48@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@47@01 xs@42@01) (Seq_contains is@43@01 i1@48@01))
      (and (Set_in x2@47@01 xs@42@01) (Seq_contains is@43@01 i2@48@01))
      (and (= x1@47@01 x2@47@01) (= i1@48@01 i2@48@01)))
    (and (= x1@47@01 x2@47@01) (= i1@48@01 i2@48@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@47@01 $Ref) (i@48@01 Int)) (!
  (=>
    (and (Set_in x@47@01 xs@42@01) (Seq_contains is@43@01 i@48@01))
    (and
      (and
        (= (inv@50@01 x@47@01 i@48@01) x@47@01)
        (= (inv@52@01 x@47@01 i@48@01) i@48@01))
      (and (img@51@01 x@47@01 i@48@01) (img@53@01 x@47@01 i@48@01))))
  :pattern ((Set_in x@47@01 xs@42@01) (Seq_contains is@43@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (Seq_contains_trigger is@43@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (Seq_contains_trigger is@43@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (inv@50@01 x@47@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (inv@52@01 x@47@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (img@51@01 x@47@01 i@48@01))
  :pattern ((Set_in x@47@01 xs@42@01) (img@53@01 x@47@01 i@48@01))
  :pattern ((Seq_contains is@43@01 i@48@01) (inv@50@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (inv@50@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (inv@50@01 x@47@01 i@48@01))
  :pattern ((Seq_contains is@43@01 i@48@01) (inv@52@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (inv@52@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (inv@52@01 x@47@01 i@48@01))
  :pattern ((Seq_contains is@43@01 i@48@01) (img@51@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (img@51@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (img@51@01 x@47@01 i@48@01))
  :pattern ((Seq_contains is@43@01 i@48@01) (img@53@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (img@53@01 x@47@01 i@48@01))
  :pattern ((Seq_contains_trigger is@43@01 i@48@01) (img@53@01 x@47@01 i@48@01))
  :pattern ((inv@50@01 x@47@01 i@48@01))
  :pattern ((inv@52@01 x@47@01 i@48@01))
  :pattern ((img@51@01 x@47@01 i@48@01))
  :pattern ((img@53@01 x@47@01 i@48@01))
  :qid |quant-u-5034|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@51@01 x i) (img@53@01 x i))
      (and
        (Set_in (inv@50@01 x i) xs@42@01)
        (Seq_contains is@43@01 (inv@52@01 x i))))
    (and (= (inv@50@01 x i) x) (= (inv@52@01 x i) i)))
  :pattern ((inv@50@01 x i))
  :pattern ((inv@52@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const $t@54@01 $Snap)
(assert (= $t@54@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const x@55@01 $Ref)
(declare-const i@56@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 11 | !(x@55@01 in xs@42@01) | live]
; [else-branch: 11 | x@55@01 in xs@42@01 | live]
(push) ; 5
; [then-branch: 11 | !(x@55@01 in xs@42@01)]
(assert (not (Set_in x@55@01 xs@42@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 11 | x@55@01 in xs@42@01]
(assert (Set_in x@55@01 xs@42@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@55@01 xs@42@01) (not (Set_in x@55@01 xs@42@01))))
(push) ; 4
; [then-branch: 12 | x@55@01 in xs@42@01 && i@56@01 in is@43@01 | live]
; [else-branch: 12 | !(x@55@01 in xs@42@01 && i@56@01 in is@43@01) | live]
(push) ; 5
; [then-branch: 12 | x@55@01 in xs@42@01 && i@56@01 in is@43@01]
(assert (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01)))
; [eval] 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@57@01 ((x $Ref) (i Int) (x@55@01 $Ref) (i@56@01 Int)) $Perm
  (ite
    (and (= x x@55@01) (= i i@56@01))
    ($Perm.min
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@57@01 x i x@55@01 i@56@01))
    $Perm.No)
  
  :qid |quant-u-5036|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@57@01 x i x@55@01 i@56@01) $Perm.No)
  
  :qid |quant-u-5037|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@55@01) (= i i@56@01))
    (= (- $Perm.Write (pTaken@57@01 x i x@55@01 i@56@01)) $Perm.No))
  
  :qid |quant-u-5038|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@58@01 $PSF<pair>)
(declare-const s@59@01 $Snap)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@51@01 x@55@01 i@56@01) (img@53@01 x@55@01 i@56@01))
    (and
      (Set_in (inv@50@01 x@55@01 i@56@01) xs@42@01)
      (Seq_contains is@43@01 (inv@52@01 x@55@01 i@56@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@55@01)
          ($SortWrappers.IntTo$Snap i@56@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@55@01)
        ($SortWrappers.IntTo$Snap i@56@01)))
      ($PSF.lookup_pair $t@49@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@55@01)
        ($SortWrappers.IntTo$Snap i@56@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@55@01)
  ($SortWrappers.IntTo$Snap i@56@01))) x@55@01 i@56@01))
(assert (=
  ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@55@01)
    ($SortWrappers.IntTo$Snap i@56@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@55@01)
      ($SortWrappers.IntTo$Snap i@56@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@55@01)
      ($SortWrappers.IntTo$Snap i@56@01)))))))
(assert (not (= x@55@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@51@01 x@55@01 i@56@01) (img@53@01 x@55@01 i@56@01))
      (and
        (Set_in (inv@50@01 x@55@01 i@56@01) xs@42@01)
        (Seq_contains is@43@01 (inv@52@01 x@55@01 i@56@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@55@01)
            ($SortWrappers.IntTo$Snap i@56@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@55@01)
          ($SortWrappers.IntTo$Snap i@56@01)))
        ($PSF.lookup_pair $t@49@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@55@01)
          ($SortWrappers.IntTo$Snap i@56@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@55@01)
    ($SortWrappers.IntTo$Snap i@56@01))) x@55@01 i@56@01)
  (=
    ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@55@01)
      ($SortWrappers.IntTo$Snap i@56@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@55@01)
        ($SortWrappers.IntTo$Snap i@56@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@55@01)
        ($SortWrappers.IntTo$Snap i@56@01))))))
  (not (= x@55@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@55@01)
  ($SortWrappers.IntTo$Snap i@56@01))))) i@56@01))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@55@01)
  ($SortWrappers.IntTo$Snap i@56@01))))) i@56@01))
(pop) ; 5
(push) ; 5
; [else-branch: 12 | !(x@55@01 in xs@42@01 && i@56@01 in is@43@01)]
(assert (not (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01))
  (and
    (Set_in x@55@01 xs@42@01)
    (Seq_contains is@43@01 i@56@01)
    (=>
      (and
        (and (img@51@01 x@55@01 i@56@01) (img@53@01 x@55@01 i@56@01))
        (and
          (Set_in (inv@50@01 x@55@01 i@56@01) xs@42@01)
          (Seq_contains is@43@01 (inv@52@01 x@55@01 i@56@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@55@01)
              ($SortWrappers.IntTo$Snap i@56@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@55@01)
            ($SortWrappers.IntTo$Snap i@56@01)))
          ($PSF.lookup_pair $t@49@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@55@01)
            ($SortWrappers.IntTo$Snap i@56@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@55@01)
      ($SortWrappers.IntTo$Snap i@56@01))) x@55@01 i@56@01)
    (=
      ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@55@01)
        ($SortWrappers.IntTo$Snap i@56@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@55@01)
          ($SortWrappers.IntTo$Snap i@56@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@55@01)
          ($SortWrappers.IntTo$Snap i@56@01))))))
    (not (= x@55@01 $Ref.null))
    (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@55@01)
      ($SortWrappers.IntTo$Snap i@56@01))))) i@56@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01)))
  (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@55@01 $Ref) (i@56@01 Int)) (!
  (and
    (or (Set_in x@55@01 xs@42@01) (not (Set_in x@55@01 xs@42@01)))
    (=>
      (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01))
      (and
        (Set_in x@55@01 xs@42@01)
        (Seq_contains is@43@01 i@56@01)
        (=>
          (and
            (and (img@51@01 x@55@01 i@56@01) (img@53@01 x@55@01 i@56@01))
            (and
              (Set_in (inv@50@01 x@55@01 i@56@01) xs@42@01)
              (Seq_contains is@43@01 (inv@52@01 x@55@01 i@56@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@55@01)
                  ($SortWrappers.IntTo$Snap i@56@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@55@01)
                ($SortWrappers.IntTo$Snap i@56@01)))
              ($PSF.lookup_pair $t@49@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@55@01)
                ($SortWrappers.IntTo$Snap i@56@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@55@01)
          ($SortWrappers.IntTo$Snap i@56@01))) x@55@01 i@56@01)
        (=
          ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@55@01)
            ($SortWrappers.IntTo$Snap i@56@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@55@01)
              ($SortWrappers.IntTo$Snap i@56@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@55@01)
              ($SortWrappers.IntTo$Snap i@56@01))))))
        (not (= x@55@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@55@01)
          ($SortWrappers.IntTo$Snap i@56@01))))) i@56@01)))
    (or
      (not (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01)))
      (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01))))
  :pattern ((Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01))
  :pattern ((Set_in x@55@01 xs@42@01) (Seq_contains_trigger is@43@01 i@56@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@55@10@56@68-aux|)))
(assert (forall ((x@55@01 $Ref) (i@56@01 Int)) (!
  (and
    (or (Set_in x@55@01 xs@42@01) (not (Set_in x@55@01 xs@42@01)))
    (=>
      (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01))
      (and
        (Set_in x@55@01 xs@42@01)
        (Seq_contains is@43@01 i@56@01)
        (=>
          (and
            (and (img@51@01 x@55@01 i@56@01) (img@53@01 x@55@01 i@56@01))
            (and
              (Set_in (inv@50@01 x@55@01 i@56@01) xs@42@01)
              (Seq_contains is@43@01 (inv@52@01 x@55@01 i@56@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@55@01)
                  ($SortWrappers.IntTo$Snap i@56@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@55@01)
                ($SortWrappers.IntTo$Snap i@56@01)))
              ($PSF.lookup_pair $t@49@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@55@01)
                ($SortWrappers.IntTo$Snap i@56@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@55@01)
          ($SortWrappers.IntTo$Snap i@56@01))) x@55@01 i@56@01)
        (=
          ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@55@01)
            ($SortWrappers.IntTo$Snap i@56@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@55@01)
              ($SortWrappers.IntTo$Snap i@56@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@55@01)
              ($SortWrappers.IntTo$Snap i@56@01))))))
        (not (= x@55@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@55@01)
          ($SortWrappers.IntTo$Snap i@56@01))))) i@56@01)))
    (or
      (not (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01)))
      (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01))))
  :pattern ((Set_in x@55@01 xs@42@01) (Seq_contains_trigger is@43@01 i@56@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@55@10@56@68-aux|)))
(assert (forall ((x@55@01 $Ref) (i@56@01 Int)) (!
  (=>
    (and (Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01))
    (<
      0
      (addA $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@55@01)
        ($SortWrappers.IntTo$Snap i@56@01))))) i@56@01)))
  :pattern ((Set_in x@55@01 xs@42@01) (Seq_contains is@43@01 i@56@01))
  :pattern ((Set_in x@55@01 xs@42@01) (Seq_contains_trigger is@43@01 i@56@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@55@10@56@68|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (tx in xs)
(declare-const $t@60@01 $Snap)
(assert (= $t@60@01 $Snap.unit))
; [eval] (tx in xs)
(assert (Set_in tx@44@01 xs@42@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (ti in is)
(declare-const $t@61@01 $Snap)
(assert (= $t@61@01 $Snap.unit))
; [eval] (ti in is)
(assert (Seq_contains is@43@01 ti@45@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; unfold acc(pair(tx, ti), write)
; Precomputing data for removing quantified permissions
(define-fun pTaken@62@01 ((x $Ref) (i Int)) $Perm
  (ite
    (and (= x tx@44@01) (= i ti@45@01))
    ($Perm.min
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@62@01 x i))
    $Perm.No)
  
  :qid |quant-u-5040|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@62@01 x i) $Perm.No)
  
  :qid |quant-u-5041|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x tx@44@01) (= i ti@45@01))
    (= (- $Perm.Write (pTaken@62@01 x i)) $Perm.No))
  
  :qid |quant-u-5042|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@51@01 tx@44@01 ti@45@01) (img@53@01 tx@44@01 ti@45@01))
    (and
      (Set_in (inv@50@01 tx@44@01 ti@45@01) xs@42@01)
      (Seq_contains is@43@01 (inv@52@01 tx@44@01 ti@45@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap tx@44@01)
          ($SortWrappers.IntTo$Snap ti@45@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@44@01)
        ($SortWrappers.IntTo$Snap ti@45@01)))
      ($PSF.lookup_pair $t@49@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@44@01)
        ($SortWrappers.IntTo$Snap ti@45@01)))))))
(assert (=
  ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@44@01)
    ($SortWrappers.IntTo$Snap ti@45@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@44@01)
      ($SortWrappers.IntTo$Snap ti@45@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@44@01)
      ($SortWrappers.IntTo$Snap ti@45@01)))))))
(assert (not (= tx@44@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (pair%trigger ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@44@01)
  ($SortWrappers.IntTo$Snap ti@45@01))) tx@44@01 ti@45@01))
; [exec]
; tmp := tx.f
(declare-const tmp@63@01 Int)
(assert (=
  tmp@63@01
  ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@44@01)
    ($SortWrappers.IntTo$Snap ti@45@01)))))))
; [exec]
; tx.f := tx.g
(declare-const f@64@01 Int)
(assert (=
  f@64@01
  ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@58@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@44@01)
    ($SortWrappers.IntTo$Snap ti@45@01)))))))
; [exec]
; tx.g := tmp
; [exec]
; fold acc(pair(tx, ti), write)
(assert (pair%trigger ($Snap.combine
  ($SortWrappers.IntTo$Snap f@64@01)
  ($SortWrappers.IntTo$Snap tmp@63@01)) tx@44@01 ti@45@01))
(declare-const sm@65@01 $PSF<pair>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@44@01)
    ($SortWrappers.IntTo$Snap ti@45@01)))
  ($Snap.combine
    ($SortWrappers.IntTo$Snap f@64@01)
    ($SortWrappers.IntTo$Snap tmp@63@01))))
; [exec]
; assert (forall x: Ref, i: Int ::
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@66@01 $Ref)
(declare-const i@67@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 13 | !(x@66@01 in xs@42@01) | live]
; [else-branch: 13 | x@66@01 in xs@42@01 | live]
(push) ; 5
; [then-branch: 13 | !(x@66@01 in xs@42@01)]
(assert (not (Set_in x@66@01 xs@42@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 13 | x@66@01 in xs@42@01]
(assert (Set_in x@66@01 xs@42@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@66@01 xs@42@01) (not (Set_in x@66@01 xs@42@01))))
(push) ; 4
; [then-branch: 14 | x@66@01 in xs@42@01 && i@67@01 in is@43@01 | live]
; [else-branch: 14 | !(x@66@01 in xs@42@01 && i@67@01 in is@43@01) | live]
(push) ; 5
; [then-branch: 14 | x@66@01 in xs@42@01 && i@67@01 in is@43@01]
(assert (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01)))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@44@01 x@66@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@68@01 ((x $Ref) (i Int) (x@66@01 $Ref) (i@67@01 Int)) $Perm
  (ite
    (and (= x x@66@01) (= i i@67@01))
    ($Perm.min
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        (- $Perm.Write (pTaken@62@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@69@01 ((x $Ref) (i Int) (x@66@01 $Ref) (i@67@01 Int)) $Perm
  (ite
    (and (= x x@66@01) (= i i@67@01))
    ($Perm.min
      (ite (and (= x tx@44@01) (= i ti@45@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@68@01 x i x@66@01 i@67@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        (- $Perm.Write (pTaken@62@01 x i))
        $Perm.No)
      (pTaken@68@01 x i x@66@01 i@67@01))
    $Perm.No)
  
  :qid |quant-u-5044|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@68@01 x i x@66@01 i@67@01) $Perm.No)
  
  :qid |quant-u-5045|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@66@01) (= i i@67@01))
    (= (- $Perm.Write (pTaken@68@01 x i x@66@01 i@67@01)) $Perm.No))
  
  :qid |quant-u-5046|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@69@01 tx@44@01 ti@45@01 x@66@01 i@67@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@69@01 x i x@66@01 i@67@01) $Perm.No)
  
  :qid |quant-u-5048|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@66@01) (= i i@67@01))
    (=
      (-
        (- $Perm.Write (pTaken@68@01 x i x@66@01 i@67@01))
        (pTaken@69@01 x i x@66@01 i@67@01))
      $Perm.No))
  
  :qid |quant-u-5049|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@70@01 $PSF<pair>)
(declare-const s@71@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@66@01 tx@44@01) (= i@67@01 ti@45@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@66@01)
        ($SortWrappers.IntTo$Snap i@67@01)))
      ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@66@01)
        ($SortWrappers.IntTo$Snap i@67@01)))))))
(assert (=>
  (ite
    (and
      (and (img@51@01 x@66@01 i@67@01) (img@53@01 x@66@01 i@67@01))
      (and
        (Set_in (inv@50@01 x@66@01 i@67@01) xs@42@01)
        (Seq_contains is@43@01 (inv@52@01 x@66@01 i@67@01))))
    (< $Perm.No (- $Perm.Write (pTaken@62@01 x@66@01 i@67@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@66@01)
        ($SortWrappers.IntTo$Snap i@67@01)))
      ($PSF.lookup_pair $t@49@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@66@01)
        ($SortWrappers.IntTo$Snap i@67@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@66@01)
  ($SortWrappers.IntTo$Snap i@67@01))) x@66@01 i@67@01))
(assert (=
  ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@66@01)
    ($SortWrappers.IntTo$Snap i@67@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@66@01)
      ($SortWrappers.IntTo$Snap i@67@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@66@01)
      ($SortWrappers.IntTo$Snap i@67@01)))))))
(assert (not (= x@66@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@66@01 tx@44@01) (= i@67@01 ti@45@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@66@01)
            ($SortWrappers.IntTo$Snap i@67@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01)))
        ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01))))))
  (=>
    (ite
      (and
        (and (img@51@01 x@66@01 i@67@01) (img@53@01 x@66@01 i@67@01))
        (and
          (Set_in (inv@50@01 x@66@01 i@67@01) xs@42@01)
          (Seq_contains is@43@01 (inv@52@01 x@66@01 i@67@01))))
      (< $Perm.No (- $Perm.Write (pTaken@62@01 x@66@01 i@67@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@66@01)
            ($SortWrappers.IntTo$Snap i@67@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01)))
        ($PSF.lookup_pair $t@49@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@66@01)
    ($SortWrappers.IntTo$Snap i@67@01))) x@66@01 i@67@01)
  (=
    ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@66@01)
      ($SortWrappers.IntTo$Snap i@67@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@66@01)
        ($SortWrappers.IntTo$Snap i@67@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@66@01)
        ($SortWrappers.IntTo$Snap i@67@01))))))
  (not (= x@66@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@67@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@66@01)
  ($SortWrappers.IntTo$Snap i@67@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@67@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@66@01)
  ($SortWrappers.IntTo$Snap i@67@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 14 | !(x@66@01 in xs@42@01 && i@67@01 in is@43@01)]
(assert (not (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))
  (and
    (Set_in x@66@01 xs@42@01)
    (Seq_contains is@43@01 i@67@01)
    (=>
      (and (= x@66@01 tx@44@01) (= i@67@01 ti@45@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@66@01)
              ($SortWrappers.IntTo$Snap i@67@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@66@01)
            ($SortWrappers.IntTo$Snap i@67@01)))
          ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@66@01)
            ($SortWrappers.IntTo$Snap i@67@01))))))
    (=>
      (ite
        (and
          (and (img@51@01 x@66@01 i@67@01) (img@53@01 x@66@01 i@67@01))
          (and
            (Set_in (inv@50@01 x@66@01 i@67@01) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x@66@01 i@67@01))))
        (< $Perm.No (- $Perm.Write (pTaken@62@01 x@66@01 i@67@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@66@01)
              ($SortWrappers.IntTo$Snap i@67@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@66@01)
            ($SortWrappers.IntTo$Snap i@67@01)))
          ($PSF.lookup_pair $t@49@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@66@01)
            ($SortWrappers.IntTo$Snap i@67@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@66@01)
      ($SortWrappers.IntTo$Snap i@67@01))) x@66@01 i@67@01)
    (=
      ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@66@01)
        ($SortWrappers.IntTo$Snap i@67@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01))))))
    (not (= x@66@01 $Ref.null))
    (addA%precondition $Snap.unit i@67@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@66@01)
      ($SortWrappers.IntTo$Snap i@67@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01)))
  (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@66@01 $Ref) (i@67@01 Int)) (!
  (and
    (or (Set_in x@66@01 xs@42@01) (not (Set_in x@66@01 xs@42@01)))
    (=>
      (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))
      (and
        (Set_in x@66@01 xs@42@01)
        (Seq_contains is@43@01 i@67@01)
        (=>
          (and (= x@66@01 tx@44@01) (= i@67@01 ti@45@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@66@01)
                  ($SortWrappers.IntTo$Snap i@67@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@66@01)
                ($SortWrappers.IntTo$Snap i@67@01)))
              ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@66@01)
                ($SortWrappers.IntTo$Snap i@67@01))))))
        (=>
          (ite
            (and
              (and (img@51@01 x@66@01 i@67@01) (img@53@01 x@66@01 i@67@01))
              (and
                (Set_in (inv@50@01 x@66@01 i@67@01) xs@42@01)
                (Seq_contains is@43@01 (inv@52@01 x@66@01 i@67@01))))
            (< $Perm.No (- $Perm.Write (pTaken@62@01 x@66@01 i@67@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@66@01)
                  ($SortWrappers.IntTo$Snap i@67@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@66@01)
                ($SortWrappers.IntTo$Snap i@67@01)))
              ($PSF.lookup_pair $t@49@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@66@01)
                ($SortWrappers.IntTo$Snap i@67@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01))) x@66@01 i@67@01)
        (=
          ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@66@01)
            ($SortWrappers.IntTo$Snap i@67@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@66@01)
              ($SortWrappers.IntTo$Snap i@67@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@66@01)
              ($SortWrappers.IntTo$Snap i@67@01))))))
        (not (= x@66@01 $Ref.null))
        (addA%precondition $Snap.unit i@67@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01))))))))
    (or
      (not (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01)))
      (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))))
  :pattern ((Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))
  :pattern ((Set_in x@66@01 xs@42@01) (Seq_contains_trigger is@43@01 i@67@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68-aux|)))
(assert (forall ((x@66@01 $Ref) (i@67@01 Int)) (!
  (and
    (or (Set_in x@66@01 xs@42@01) (not (Set_in x@66@01 xs@42@01)))
    (=>
      (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))
      (and
        (Set_in x@66@01 xs@42@01)
        (Seq_contains is@43@01 i@67@01)
        (=>
          (and (= x@66@01 tx@44@01) (= i@67@01 ti@45@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@66@01)
                  ($SortWrappers.IntTo$Snap i@67@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@66@01)
                ($SortWrappers.IntTo$Snap i@67@01)))
              ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@66@01)
                ($SortWrappers.IntTo$Snap i@67@01))))))
        (=>
          (ite
            (and
              (and (img@51@01 x@66@01 i@67@01) (img@53@01 x@66@01 i@67@01))
              (and
                (Set_in (inv@50@01 x@66@01 i@67@01) xs@42@01)
                (Seq_contains is@43@01 (inv@52@01 x@66@01 i@67@01))))
            (< $Perm.No (- $Perm.Write (pTaken@62@01 x@66@01 i@67@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@66@01)
                  ($SortWrappers.IntTo$Snap i@67@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@66@01)
                ($SortWrappers.IntTo$Snap i@67@01)))
              ($PSF.lookup_pair $t@49@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@66@01)
                ($SortWrappers.IntTo$Snap i@67@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01))) x@66@01 i@67@01)
        (=
          ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@66@01)
            ($SortWrappers.IntTo$Snap i@67@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@66@01)
              ($SortWrappers.IntTo$Snap i@67@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@66@01)
              ($SortWrappers.IntTo$Snap i@67@01))))))
        (not (= x@66@01 $Ref.null))
        (addA%precondition $Snap.unit i@67@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01))))))))
    (or
      (not (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01)))
      (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))))
  :pattern ((Set_in x@66@01 xs@42@01) (Seq_contains_trigger is@43@01 i@67@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68-aux|)))
(assert (forall ((x@66@01 $Ref) (i@67@01 Int)) (!
  (=>
    (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))
    (addA%precondition $Snap.unit i@67@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@66@01)
      ($SortWrappers.IntTo$Snap i@67@01)))))))
  :pattern ((Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))
  :pattern ((Set_in x@66@01 xs@42@01) (Seq_contains_trigger is@43@01 i@67@01))
  :pattern ((Set_in x@66@01 xs@42@01) (Seq_contains_trigger is@43@01 i@67@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68_precondition|)))
(push) ; 3
(assert (not (forall ((x@66@01 $Ref) (i@67@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))
        (addA%precondition $Snap.unit i@67@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@66@01)
          ($SortWrappers.IntTo$Snap i@67@01)))))))
      (and (Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01)))
    (<
      0
      (addA $Snap.unit i@67@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@70@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@66@01)
        ($SortWrappers.IntTo$Snap i@67@01))))))))
  :pattern ((Set_in x@66@01 xs@42@01) (Seq_contains is@43@01 i@67@01))
  :pattern ((Set_in x@66@01 xs@42@01) (Seq_contains_trigger is@43@01 i@67@01))
  :pattern ((Set_in x@66@01 xs@42@01) (Seq_contains_trigger is@43@01 i@67@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@72@01 $Ref)
(declare-const i@73@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 15 | !(x@72@01 in xs@42@01) | live]
; [else-branch: 15 | x@72@01 in xs@42@01 | live]
(push) ; 5
; [then-branch: 15 | !(x@72@01 in xs@42@01)]
(assert (not (Set_in x@72@01 xs@42@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 15 | x@72@01 in xs@42@01]
(assert (Set_in x@72@01 xs@42@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@72@01 xs@42@01) (not (Set_in x@72@01 xs@42@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 16 | x@72@01 in xs@42@01 && i@73@01 in is@43@01 | live]
; [else-branch: 16 | !(x@72@01 in xs@42@01 && i@73@01 in is@43@01) | live]
(push) ; 5
; [then-branch: 16 | x@72@01 in xs@42@01 && i@73@01 in is@43@01]
(assert (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(set-option :timeout 0)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@44@01 x@72@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@74@01 ((x $Ref) (i Int) (x@72@01 $Ref) (i@73@01 Int)) $Perm
  (ite
    (and (= x x@72@01) (= i i@73@01))
    ($Perm.min
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        (- $Perm.Write (pTaken@62@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@75@01 ((x $Ref) (i Int) (x@72@01 $Ref) (i@73@01 Int)) $Perm
  (ite
    (and (= x x@72@01) (= i i@73@01))
    ($Perm.min
      (ite (and (= x tx@44@01) (= i ti@45@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@74@01 x i x@72@01 i@73@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        (- $Perm.Write (pTaken@62@01 x i))
        $Perm.No)
      (pTaken@74@01 x i x@72@01 i@73@01))
    $Perm.No)
  
  :qid |quant-u-5051|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@74@01 x i x@72@01 i@73@01) $Perm.No)
  
  :qid |quant-u-5052|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@72@01) (= i i@73@01))
    (= (- $Perm.Write (pTaken@74@01 x i x@72@01 i@73@01)) $Perm.No))
  
  :qid |quant-u-5053|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@75@01 tx@44@01 ti@45@01 x@72@01 i@73@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@75@01 x i x@72@01 i@73@01) $Perm.No)
  
  :qid |quant-u-5055|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@72@01) (= i i@73@01))
    (=
      (-
        (- $Perm.Write (pTaken@74@01 x i x@72@01 i@73@01))
        (pTaken@75@01 x i x@72@01 i@73@01))
      $Perm.No))
  
  :qid |quant-u-5056|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@76@01 $PSF<pair>)
(declare-const s@77@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@72@01 tx@44@01) (= i@73@01 ti@45@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@72@01)
        ($SortWrappers.IntTo$Snap i@73@01)))
      ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@72@01)
        ($SortWrappers.IntTo$Snap i@73@01)))))))
(assert (=>
  (ite
    (and
      (and (img@51@01 x@72@01 i@73@01) (img@53@01 x@72@01 i@73@01))
      (and
        (Set_in (inv@50@01 x@72@01 i@73@01) xs@42@01)
        (Seq_contains is@43@01 (inv@52@01 x@72@01 i@73@01))))
    (< $Perm.No (- $Perm.Write (pTaken@62@01 x@72@01 i@73@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@72@01)
        ($SortWrappers.IntTo$Snap i@73@01)))
      ($PSF.lookup_pair $t@49@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@72@01)
        ($SortWrappers.IntTo$Snap i@73@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@72@01)
  ($SortWrappers.IntTo$Snap i@73@01))) x@72@01 i@73@01))
(assert (=
  ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@72@01)
    ($SortWrappers.IntTo$Snap i@73@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@72@01)
      ($SortWrappers.IntTo$Snap i@73@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@72@01)
      ($SortWrappers.IntTo$Snap i@73@01)))))))
(assert (not (= x@72@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@72@01 tx@44@01) (= i@73@01 ti@45@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@72@01)
            ($SortWrappers.IntTo$Snap i@73@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01)))
        ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01))))))
  (=>
    (ite
      (and
        (and (img@51@01 x@72@01 i@73@01) (img@53@01 x@72@01 i@73@01))
        (and
          (Set_in (inv@50@01 x@72@01 i@73@01) xs@42@01)
          (Seq_contains is@43@01 (inv@52@01 x@72@01 i@73@01))))
      (< $Perm.No (- $Perm.Write (pTaken@62@01 x@72@01 i@73@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@72@01)
            ($SortWrappers.IntTo$Snap i@73@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01)))
        ($PSF.lookup_pair $t@49@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@72@01)
    ($SortWrappers.IntTo$Snap i@73@01))) x@72@01 i@73@01)
  (=
    ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@72@01)
      ($SortWrappers.IntTo$Snap i@73@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@72@01)
        ($SortWrappers.IntTo$Snap i@73@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@72@01)
        ($SortWrappers.IntTo$Snap i@73@01))))))
  (not (= x@72@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@73@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@72@01)
  ($SortWrappers.IntTo$Snap i@73@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@73@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@72@01)
  ($SortWrappers.IntTo$Snap i@73@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 16 | !(x@72@01 in xs@42@01 && i@73@01 in is@43@01)]
(assert (not (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))
  (and
    (Set_in x@72@01 xs@42@01)
    (Seq_contains is@43@01 i@73@01)
    (=>
      (and (= x@72@01 tx@44@01) (= i@73@01 ti@45@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@72@01)
              ($SortWrappers.IntTo$Snap i@73@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@72@01)
            ($SortWrappers.IntTo$Snap i@73@01)))
          ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@72@01)
            ($SortWrappers.IntTo$Snap i@73@01))))))
    (=>
      (ite
        (and
          (and (img@51@01 x@72@01 i@73@01) (img@53@01 x@72@01 i@73@01))
          (and
            (Set_in (inv@50@01 x@72@01 i@73@01) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x@72@01 i@73@01))))
        (< $Perm.No (- $Perm.Write (pTaken@62@01 x@72@01 i@73@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@72@01)
              ($SortWrappers.IntTo$Snap i@73@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@72@01)
            ($SortWrappers.IntTo$Snap i@73@01)))
          ($PSF.lookup_pair $t@49@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@72@01)
            ($SortWrappers.IntTo$Snap i@73@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@72@01)
      ($SortWrappers.IntTo$Snap i@73@01))) x@72@01 i@73@01)
    (=
      ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@72@01)
        ($SortWrappers.IntTo$Snap i@73@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01))))))
    (not (= x@72@01 $Ref.null))
    (addA%precondition $Snap.unit i@73@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@72@01)
      ($SortWrappers.IntTo$Snap i@73@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01)))
  (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@72@01 $Ref) (i@73@01 Int)) (!
  (and
    (or (Set_in x@72@01 xs@42@01) (not (Set_in x@72@01 xs@42@01)))
    (=>
      (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))
      (and
        (Set_in x@72@01 xs@42@01)
        (Seq_contains is@43@01 i@73@01)
        (=>
          (and (= x@72@01 tx@44@01) (= i@73@01 ti@45@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@72@01)
                  ($SortWrappers.IntTo$Snap i@73@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@72@01)
                ($SortWrappers.IntTo$Snap i@73@01)))
              ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@72@01)
                ($SortWrappers.IntTo$Snap i@73@01))))))
        (=>
          (ite
            (and
              (and (img@51@01 x@72@01 i@73@01) (img@53@01 x@72@01 i@73@01))
              (and
                (Set_in (inv@50@01 x@72@01 i@73@01) xs@42@01)
                (Seq_contains is@43@01 (inv@52@01 x@72@01 i@73@01))))
            (< $Perm.No (- $Perm.Write (pTaken@62@01 x@72@01 i@73@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@72@01)
                  ($SortWrappers.IntTo$Snap i@73@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@72@01)
                ($SortWrappers.IntTo$Snap i@73@01)))
              ($PSF.lookup_pair $t@49@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@72@01)
                ($SortWrappers.IntTo$Snap i@73@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01))) x@72@01 i@73@01)
        (=
          ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@72@01)
            ($SortWrappers.IntTo$Snap i@73@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@72@01)
              ($SortWrappers.IntTo$Snap i@73@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@72@01)
              ($SortWrappers.IntTo$Snap i@73@01))))))
        (not (= x@72@01 $Ref.null))
        (addA%precondition $Snap.unit i@73@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01))))))))
    (or
      (not (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01)))
      (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))))
  :pattern ((Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))
  :pattern ((Set_in x@72@01 xs@42@01) (Seq_contains_trigger is@43@01 i@73@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68-aux|)))
(assert (forall ((x@72@01 $Ref) (i@73@01 Int)) (!
  (and
    (or (Set_in x@72@01 xs@42@01) (not (Set_in x@72@01 xs@42@01)))
    (=>
      (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))
      (and
        (Set_in x@72@01 xs@42@01)
        (Seq_contains is@43@01 i@73@01)
        (=>
          (and (= x@72@01 tx@44@01) (= i@73@01 ti@45@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@72@01)
                  ($SortWrappers.IntTo$Snap i@73@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@72@01)
                ($SortWrappers.IntTo$Snap i@73@01)))
              ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@72@01)
                ($SortWrappers.IntTo$Snap i@73@01))))))
        (=>
          (ite
            (and
              (and (img@51@01 x@72@01 i@73@01) (img@53@01 x@72@01 i@73@01))
              (and
                (Set_in (inv@50@01 x@72@01 i@73@01) xs@42@01)
                (Seq_contains is@43@01 (inv@52@01 x@72@01 i@73@01))))
            (< $Perm.No (- $Perm.Write (pTaken@62@01 x@72@01 i@73@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@72@01)
                  ($SortWrappers.IntTo$Snap i@73@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@72@01)
                ($SortWrappers.IntTo$Snap i@73@01)))
              ($PSF.lookup_pair $t@49@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@72@01)
                ($SortWrappers.IntTo$Snap i@73@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01))) x@72@01 i@73@01)
        (=
          ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@72@01)
            ($SortWrappers.IntTo$Snap i@73@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@72@01)
              ($SortWrappers.IntTo$Snap i@73@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@72@01)
              ($SortWrappers.IntTo$Snap i@73@01))))))
        (not (= x@72@01 $Ref.null))
        (addA%precondition $Snap.unit i@73@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01))))))))
    (or
      (not (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01)))
      (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))))
  :pattern ((Set_in x@72@01 xs@42@01) (Seq_contains_trigger is@43@01 i@73@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68-aux|)))
(assert (forall ((x@72@01 $Ref) (i@73@01 Int)) (!
  (=>
    (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))
    (addA%precondition $Snap.unit i@73@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@72@01)
      ($SortWrappers.IntTo$Snap i@73@01)))))))
  :pattern ((Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))
  :pattern ((Set_in x@72@01 xs@42@01) (Seq_contains_trigger is@43@01 i@73@01))
  :pattern ((Set_in x@72@01 xs@42@01) (Seq_contains_trigger is@43@01 i@73@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@72@01 $Ref) (i@73@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))
        (addA%precondition $Snap.unit i@73@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@72@01)
          ($SortWrappers.IntTo$Snap i@73@01)))))))
      (and (Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01)))
    (<
      0
      (addA $Snap.unit i@73@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@76@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@72@01)
        ($SortWrappers.IntTo$Snap i@73@01))))))))
  :pattern ((Set_in x@72@01 xs@42@01) (Seq_contains is@43@01 i@73@01))
  :pattern ((Set_in x@72@01 xs@42@01) (Seq_contains_trigger is@43@01 i@73@01))
  :pattern ((Set_in x@72@01 xs@42@01) (Seq_contains_trigger is@43@01 i@73@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@78@01 $Ref)
(declare-const i@79@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 17 | !(x@78@01 in xs@42@01) | live]
; [else-branch: 17 | x@78@01 in xs@42@01 | live]
(push) ; 5
; [then-branch: 17 | !(x@78@01 in xs@42@01)]
(assert (not (Set_in x@78@01 xs@42@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 17 | x@78@01 in xs@42@01]
(assert (Set_in x@78@01 xs@42@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@78@01 xs@42@01) (not (Set_in x@78@01 xs@42@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 18 | x@78@01 in xs@42@01 && i@79@01 in is@43@01 | live]
; [else-branch: 18 | !(x@78@01 in xs@42@01 && i@79@01 in is@43@01) | live]
(push) ; 5
; [then-branch: 18 | x@78@01 in xs@42@01 && i@79@01 in is@43@01]
(assert (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(set-option :timeout 0)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@44@01 x@78@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@80@01 ((x $Ref) (i Int) (x@78@01 $Ref) (i@79@01 Int)) $Perm
  (ite
    (and (= x x@78@01) (= i i@79@01))
    ($Perm.min
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        (- $Perm.Write (pTaken@62@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@81@01 ((x $Ref) (i Int) (x@78@01 $Ref) (i@79@01 Int)) $Perm
  (ite
    (and (= x x@78@01) (= i i@79@01))
    ($Perm.min
      (ite (and (= x tx@44@01) (= i ti@45@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@80@01 x i x@78@01 i@79@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        (- $Perm.Write (pTaken@62@01 x i))
        $Perm.No)
      (pTaken@80@01 x i x@78@01 i@79@01))
    $Perm.No)
  
  :qid |quant-u-5058|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@80@01 x i x@78@01 i@79@01) $Perm.No)
  
  :qid |quant-u-5059|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@78@01) (= i i@79@01))
    (= (- $Perm.Write (pTaken@80@01 x i x@78@01 i@79@01)) $Perm.No))
  
  :qid |quant-u-5060|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@81@01 tx@44@01 ti@45@01 x@78@01 i@79@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@81@01 x i x@78@01 i@79@01) $Perm.No)
  
  :qid |quant-u-5062|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@78@01) (= i i@79@01))
    (=
      (-
        (- $Perm.Write (pTaken@80@01 x i x@78@01 i@79@01))
        (pTaken@81@01 x i x@78@01 i@79@01))
      $Perm.No))
  
  :qid |quant-u-5063|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@82@01 $PSF<pair>)
(declare-const s@83@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (ite
    (and
      (and (img@51@01 x@78@01 i@79@01) (img@53@01 x@78@01 i@79@01))
      (and
        (Set_in (inv@50@01 x@78@01 i@79@01) xs@42@01)
        (Seq_contains is@43@01 (inv@52@01 x@78@01 i@79@01))))
    (< $Perm.No (- $Perm.Write (pTaken@62@01 x@78@01 i@79@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@78@01)
        ($SortWrappers.IntTo$Snap i@79@01)))
      ($PSF.lookup_pair $t@49@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@78@01)
        ($SortWrappers.IntTo$Snap i@79@01)))))))
(assert (=>
  (and (= x@78@01 tx@44@01) (= i@79@01 ti@45@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@78@01)
        ($SortWrappers.IntTo$Snap i@79@01)))
      ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@78@01)
        ($SortWrappers.IntTo$Snap i@79@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@78@01)
  ($SortWrappers.IntTo$Snap i@79@01))) x@78@01 i@79@01))
(assert (=
  ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@78@01)
    ($SortWrappers.IntTo$Snap i@79@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@78@01)
      ($SortWrappers.IntTo$Snap i@79@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@78@01)
      ($SortWrappers.IntTo$Snap i@79@01)))))))
(assert (not (= x@78@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (ite
      (and
        (and (img@51@01 x@78@01 i@79@01) (img@53@01 x@78@01 i@79@01))
        (and
          (Set_in (inv@50@01 x@78@01 i@79@01) xs@42@01)
          (Seq_contains is@43@01 (inv@52@01 x@78@01 i@79@01))))
      (< $Perm.No (- $Perm.Write (pTaken@62@01 x@78@01 i@79@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@78@01)
            ($SortWrappers.IntTo$Snap i@79@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01)))
        ($PSF.lookup_pair $t@49@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01))))))
  (=>
    (and (= x@78@01 tx@44@01) (= i@79@01 ti@45@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@78@01)
            ($SortWrappers.IntTo$Snap i@79@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01)))
        ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@78@01)
    ($SortWrappers.IntTo$Snap i@79@01))) x@78@01 i@79@01)
  (=
    ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@78@01)
      ($SortWrappers.IntTo$Snap i@79@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@78@01)
        ($SortWrappers.IntTo$Snap i@79@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@78@01)
        ($SortWrappers.IntTo$Snap i@79@01))))))
  (not (= x@78@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@79@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@78@01)
  ($SortWrappers.IntTo$Snap i@79@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@79@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@78@01)
  ($SortWrappers.IntTo$Snap i@79@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 18 | !(x@78@01 in xs@42@01 && i@79@01 in is@43@01)]
(assert (not (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))
  (and
    (Set_in x@78@01 xs@42@01)
    (Seq_contains is@43@01 i@79@01)
    (=>
      (ite
        (and
          (and (img@51@01 x@78@01 i@79@01) (img@53@01 x@78@01 i@79@01))
          (and
            (Set_in (inv@50@01 x@78@01 i@79@01) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x@78@01 i@79@01))))
        (< $Perm.No (- $Perm.Write (pTaken@62@01 x@78@01 i@79@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@78@01)
              ($SortWrappers.IntTo$Snap i@79@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@78@01)
            ($SortWrappers.IntTo$Snap i@79@01)))
          ($PSF.lookup_pair $t@49@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@78@01)
            ($SortWrappers.IntTo$Snap i@79@01))))))
    (=>
      (and (= x@78@01 tx@44@01) (= i@79@01 ti@45@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@78@01)
              ($SortWrappers.IntTo$Snap i@79@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@78@01)
            ($SortWrappers.IntTo$Snap i@79@01)))
          ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@78@01)
            ($SortWrappers.IntTo$Snap i@79@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@78@01)
      ($SortWrappers.IntTo$Snap i@79@01))) x@78@01 i@79@01)
    (=
      ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@78@01)
        ($SortWrappers.IntTo$Snap i@79@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01))))))
    (not (= x@78@01 $Ref.null))
    (addA%precondition $Snap.unit i@79@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@78@01)
      ($SortWrappers.IntTo$Snap i@79@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01)))
  (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@78@01 $Ref) (i@79@01 Int)) (!
  (and
    (or (Set_in x@78@01 xs@42@01) (not (Set_in x@78@01 xs@42@01)))
    (=>
      (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))
      (and
        (Set_in x@78@01 xs@42@01)
        (Seq_contains is@43@01 i@79@01)
        (=>
          (ite
            (and
              (and (img@51@01 x@78@01 i@79@01) (img@53@01 x@78@01 i@79@01))
              (and
                (Set_in (inv@50@01 x@78@01 i@79@01) xs@42@01)
                (Seq_contains is@43@01 (inv@52@01 x@78@01 i@79@01))))
            (< $Perm.No (- $Perm.Write (pTaken@62@01 x@78@01 i@79@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@78@01)
                  ($SortWrappers.IntTo$Snap i@79@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@78@01)
                ($SortWrappers.IntTo$Snap i@79@01)))
              ($PSF.lookup_pair $t@49@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@78@01)
                ($SortWrappers.IntTo$Snap i@79@01))))))
        (=>
          (and (= x@78@01 tx@44@01) (= i@79@01 ti@45@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@78@01)
                  ($SortWrappers.IntTo$Snap i@79@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@78@01)
                ($SortWrappers.IntTo$Snap i@79@01)))
              ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@78@01)
                ($SortWrappers.IntTo$Snap i@79@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01))) x@78@01 i@79@01)
        (=
          ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@78@01)
            ($SortWrappers.IntTo$Snap i@79@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@78@01)
              ($SortWrappers.IntTo$Snap i@79@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@78@01)
              ($SortWrappers.IntTo$Snap i@79@01))))))
        (not (= x@78@01 $Ref.null))
        (addA%precondition $Snap.unit i@79@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01))))))))
    (or
      (not (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01)))
      (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))))
  :pattern ((Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))
  :pattern ((Set_in x@78@01 xs@42@01) (Seq_contains_trigger is@43@01 i@79@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68-aux|)))
(assert (forall ((x@78@01 $Ref) (i@79@01 Int)) (!
  (and
    (or (Set_in x@78@01 xs@42@01) (not (Set_in x@78@01 xs@42@01)))
    (=>
      (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))
      (and
        (Set_in x@78@01 xs@42@01)
        (Seq_contains is@43@01 i@79@01)
        (=>
          (ite
            (and
              (and (img@51@01 x@78@01 i@79@01) (img@53@01 x@78@01 i@79@01))
              (and
                (Set_in (inv@50@01 x@78@01 i@79@01) xs@42@01)
                (Seq_contains is@43@01 (inv@52@01 x@78@01 i@79@01))))
            (< $Perm.No (- $Perm.Write (pTaken@62@01 x@78@01 i@79@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@78@01)
                  ($SortWrappers.IntTo$Snap i@79@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@78@01)
                ($SortWrappers.IntTo$Snap i@79@01)))
              ($PSF.lookup_pair $t@49@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@78@01)
                ($SortWrappers.IntTo$Snap i@79@01))))))
        (=>
          (and (= x@78@01 tx@44@01) (= i@79@01 ti@45@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@78@01)
                  ($SortWrappers.IntTo$Snap i@79@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@78@01)
                ($SortWrappers.IntTo$Snap i@79@01)))
              ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@78@01)
                ($SortWrappers.IntTo$Snap i@79@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01))) x@78@01 i@79@01)
        (=
          ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@78@01)
            ($SortWrappers.IntTo$Snap i@79@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@78@01)
              ($SortWrappers.IntTo$Snap i@79@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@78@01)
              ($SortWrappers.IntTo$Snap i@79@01))))))
        (not (= x@78@01 $Ref.null))
        (addA%precondition $Snap.unit i@79@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01))))))))
    (or
      (not (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01)))
      (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))))
  :pattern ((Set_in x@78@01 xs@42@01) (Seq_contains_trigger is@43@01 i@79@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68-aux|)))
(assert (forall ((x@78@01 $Ref) (i@79@01 Int)) (!
  (=>
    (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))
    (addA%precondition $Snap.unit i@79@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@78@01)
      ($SortWrappers.IntTo$Snap i@79@01)))))))
  :pattern ((Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))
  :pattern ((Set_in x@78@01 xs@42@01) (Seq_contains_trigger is@43@01 i@79@01))
  :pattern ((Set_in x@78@01 xs@42@01) (Seq_contains_trigger is@43@01 i@79@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@78@01 $Ref) (i@79@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))
        (addA%precondition $Snap.unit i@79@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@78@01)
          ($SortWrappers.IntTo$Snap i@79@01)))))))
      (and (Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01)))
    (<
      0
      (addA $Snap.unit i@79@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@82@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@78@01)
        ($SortWrappers.IntTo$Snap i@79@01))))))))
  :pattern ((Set_in x@78@01 xs@42@01) (Seq_contains is@43@01 i@79@01))
  :pattern ((Set_in x@78@01 xs@42@01) (Seq_contains_trigger is@43@01 i@79@01))
  :pattern ((Set_in x@78@01 xs@42@01) (Seq_contains_trigger is@43@01 i@79@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@84@01 $Ref)
(declare-const i@85@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 19 | !(x@84@01 in xs@42@01) | live]
; [else-branch: 19 | x@84@01 in xs@42@01 | live]
(push) ; 5
; [then-branch: 19 | !(x@84@01 in xs@42@01)]
(assert (not (Set_in x@84@01 xs@42@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 19 | x@84@01 in xs@42@01]
(assert (Set_in x@84@01 xs@42@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@84@01 xs@42@01) (not (Set_in x@84@01 xs@42@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 20 | x@84@01 in xs@42@01 && i@85@01 in is@43@01 | live]
; [else-branch: 20 | !(x@84@01 in xs@42@01 && i@85@01 in is@43@01) | live]
(push) ; 5
; [then-branch: 20 | x@84@01 in xs@42@01 && i@85@01 in is@43@01]
(assert (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(set-option :timeout 0)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@44@01 x@84@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@86@01 ((x $Ref) (i Int) (x@84@01 $Ref) (i@85@01 Int)) $Perm
  (ite
    (and (= x x@84@01) (= i i@85@01))
    ($Perm.min
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        (- $Perm.Write (pTaken@62@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@87@01 ((x $Ref) (i Int) (x@84@01 $Ref) (i@85@01 Int)) $Perm
  (ite
    (and (= x x@84@01) (= i i@85@01))
    ($Perm.min
      (ite (and (= x tx@44@01) (= i ti@45@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@86@01 x i x@84@01 i@85@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@51@01 x i) (img@53@01 x i))
          (and
            (Set_in (inv@50@01 x i) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x i))))
        (- $Perm.Write (pTaken@62@01 x i))
        $Perm.No)
      (pTaken@86@01 x i x@84@01 i@85@01))
    $Perm.No)
  
  :qid |quant-u-5065|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@86@01 x i x@84@01 i@85@01) $Perm.No)
  
  :qid |quant-u-5066|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@84@01) (= i i@85@01))
    (= (- $Perm.Write (pTaken@86@01 x i x@84@01 i@85@01)) $Perm.No))
  
  :qid |quant-u-5067|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@87@01 tx@44@01 ti@45@01 x@84@01 i@85@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@87@01 x i x@84@01 i@85@01) $Perm.No)
  
  :qid |quant-u-5069|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@84@01) (= i i@85@01))
    (=
      (-
        (- $Perm.Write (pTaken@86@01 x i x@84@01 i@85@01))
        (pTaken@87@01 x i x@84@01 i@85@01))
      $Perm.No))
  
  :qid |quant-u-5070|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@88@01 $PSF<pair>)
(declare-const s@89@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@84@01 tx@44@01) (= i@85@01 ti@45@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@84@01)
        ($SortWrappers.IntTo$Snap i@85@01)))
      ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@84@01)
        ($SortWrappers.IntTo$Snap i@85@01)))))))
(assert (=>
  (ite
    (and
      (and (img@51@01 x@84@01 i@85@01) (img@53@01 x@84@01 i@85@01))
      (and
        (Set_in (inv@50@01 x@84@01 i@85@01) xs@42@01)
        (Seq_contains is@43@01 (inv@52@01 x@84@01 i@85@01))))
    (< $Perm.No (- $Perm.Write (pTaken@62@01 x@84@01 i@85@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@84@01)
        ($SortWrappers.IntTo$Snap i@85@01)))
      ($PSF.lookup_pair $t@49@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@84@01)
        ($SortWrappers.IntTo$Snap i@85@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@84@01)
  ($SortWrappers.IntTo$Snap i@85@01))) x@84@01 i@85@01))
(assert (=
  ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@84@01)
    ($SortWrappers.IntTo$Snap i@85@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@84@01)
      ($SortWrappers.IntTo$Snap i@85@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@84@01)
      ($SortWrappers.IntTo$Snap i@85@01)))))))
(assert (not (= x@84@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@84@01 tx@44@01) (= i@85@01 ti@45@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@84@01)
            ($SortWrappers.IntTo$Snap i@85@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01)))
        ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01))))))
  (=>
    (ite
      (and
        (and (img@51@01 x@84@01 i@85@01) (img@53@01 x@84@01 i@85@01))
        (and
          (Set_in (inv@50@01 x@84@01 i@85@01) xs@42@01)
          (Seq_contains is@43@01 (inv@52@01 x@84@01 i@85@01))))
      (< $Perm.No (- $Perm.Write (pTaken@62@01 x@84@01 i@85@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@84@01)
            ($SortWrappers.IntTo$Snap i@85@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01)))
        ($PSF.lookup_pair $t@49@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@84@01)
    ($SortWrappers.IntTo$Snap i@85@01))) x@84@01 i@85@01)
  (=
    ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@84@01)
      ($SortWrappers.IntTo$Snap i@85@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@84@01)
        ($SortWrappers.IntTo$Snap i@85@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@84@01)
        ($SortWrappers.IntTo$Snap i@85@01))))))
  (not (= x@84@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@85@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@84@01)
  ($SortWrappers.IntTo$Snap i@85@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@85@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@84@01)
  ($SortWrappers.IntTo$Snap i@85@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 20 | !(x@84@01 in xs@42@01 && i@85@01 in is@43@01)]
(assert (not (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))
  (and
    (Set_in x@84@01 xs@42@01)
    (Seq_contains is@43@01 i@85@01)
    (=>
      (and (= x@84@01 tx@44@01) (= i@85@01 ti@45@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@84@01)
              ($SortWrappers.IntTo$Snap i@85@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@84@01)
            ($SortWrappers.IntTo$Snap i@85@01)))
          ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@84@01)
            ($SortWrappers.IntTo$Snap i@85@01))))))
    (=>
      (ite
        (and
          (and (img@51@01 x@84@01 i@85@01) (img@53@01 x@84@01 i@85@01))
          (and
            (Set_in (inv@50@01 x@84@01 i@85@01) xs@42@01)
            (Seq_contains is@43@01 (inv@52@01 x@84@01 i@85@01))))
        (< $Perm.No (- $Perm.Write (pTaken@62@01 x@84@01 i@85@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@84@01)
              ($SortWrappers.IntTo$Snap i@85@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@84@01)
            ($SortWrappers.IntTo$Snap i@85@01)))
          ($PSF.lookup_pair $t@49@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@84@01)
            ($SortWrappers.IntTo$Snap i@85@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@84@01)
      ($SortWrappers.IntTo$Snap i@85@01))) x@84@01 i@85@01)
    (=
      ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@84@01)
        ($SortWrappers.IntTo$Snap i@85@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01))))))
    (not (= x@84@01 $Ref.null))
    (addA%precondition $Snap.unit i@85@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@84@01)
      ($SortWrappers.IntTo$Snap i@85@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01)))
  (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@84@01 $Ref) (i@85@01 Int)) (!
  (and
    (or (Set_in x@84@01 xs@42@01) (not (Set_in x@84@01 xs@42@01)))
    (=>
      (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))
      (and
        (Set_in x@84@01 xs@42@01)
        (Seq_contains is@43@01 i@85@01)
        (=>
          (and (= x@84@01 tx@44@01) (= i@85@01 ti@45@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@84@01)
                  ($SortWrappers.IntTo$Snap i@85@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@84@01)
                ($SortWrappers.IntTo$Snap i@85@01)))
              ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@84@01)
                ($SortWrappers.IntTo$Snap i@85@01))))))
        (=>
          (ite
            (and
              (and (img@51@01 x@84@01 i@85@01) (img@53@01 x@84@01 i@85@01))
              (and
                (Set_in (inv@50@01 x@84@01 i@85@01) xs@42@01)
                (Seq_contains is@43@01 (inv@52@01 x@84@01 i@85@01))))
            (< $Perm.No (- $Perm.Write (pTaken@62@01 x@84@01 i@85@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@84@01)
                  ($SortWrappers.IntTo$Snap i@85@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@84@01)
                ($SortWrappers.IntTo$Snap i@85@01)))
              ($PSF.lookup_pair $t@49@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@84@01)
                ($SortWrappers.IntTo$Snap i@85@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01))) x@84@01 i@85@01)
        (=
          ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@84@01)
            ($SortWrappers.IntTo$Snap i@85@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@84@01)
              ($SortWrappers.IntTo$Snap i@85@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@84@01)
              ($SortWrappers.IntTo$Snap i@85@01))))))
        (not (= x@84@01 $Ref.null))
        (addA%precondition $Snap.unit i@85@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01))))))))
    (or
      (not (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01)))
      (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))))
  :pattern ((Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))
  :pattern ((Set_in x@84@01 xs@42@01) (Seq_contains_trigger is@43@01 i@85@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68-aux|)))
(assert (forall ((x@84@01 $Ref) (i@85@01 Int)) (!
  (and
    (or (Set_in x@84@01 xs@42@01) (not (Set_in x@84@01 xs@42@01)))
    (=>
      (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))
      (and
        (Set_in x@84@01 xs@42@01)
        (Seq_contains is@43@01 i@85@01)
        (=>
          (and (= x@84@01 tx@44@01) (= i@85@01 ti@45@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@84@01)
                  ($SortWrappers.IntTo$Snap i@85@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@84@01)
                ($SortWrappers.IntTo$Snap i@85@01)))
              ($PSF.lookup_pair (as sm@65@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@84@01)
                ($SortWrappers.IntTo$Snap i@85@01))))))
        (=>
          (ite
            (and
              (and (img@51@01 x@84@01 i@85@01) (img@53@01 x@84@01 i@85@01))
              (and
                (Set_in (inv@50@01 x@84@01 i@85@01) xs@42@01)
                (Seq_contains is@43@01 (inv@52@01 x@84@01 i@85@01))))
            (< $Perm.No (- $Perm.Write (pTaken@62@01 x@84@01 i@85@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@84@01)
                  ($SortWrappers.IntTo$Snap i@85@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@84@01)
                ($SortWrappers.IntTo$Snap i@85@01)))
              ($PSF.lookup_pair $t@49@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@84@01)
                ($SortWrappers.IntTo$Snap i@85@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01))) x@84@01 i@85@01)
        (=
          ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@84@01)
            ($SortWrappers.IntTo$Snap i@85@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@84@01)
              ($SortWrappers.IntTo$Snap i@85@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@84@01)
              ($SortWrappers.IntTo$Snap i@85@01))))))
        (not (= x@84@01 $Ref.null))
        (addA%precondition $Snap.unit i@85@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01))))))))
    (or
      (not (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01)))
      (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))))
  :pattern ((Set_in x@84@01 xs@42@01) (Seq_contains_trigger is@43@01 i@85@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68-aux|)))
(assert (forall ((x@84@01 $Ref) (i@85@01 Int)) (!
  (=>
    (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))
    (addA%precondition $Snap.unit i@85@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@84@01)
      ($SortWrappers.IntTo$Snap i@85@01)))))))
  :pattern ((Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))
  :pattern ((Set_in x@84@01 xs@42@01) (Seq_contains_trigger is@43@01 i@85@01))
  :pattern ((Set_in x@84@01 xs@42@01) (Seq_contains_trigger is@43@01 i@85@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@84@01 $Ref) (i@85@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))
        (addA%precondition $Snap.unit i@85@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@84@01)
          ($SortWrappers.IntTo$Snap i@85@01)))))))
      (and (Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01)))
    (<
      0
      (addA $Snap.unit i@85@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@88@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@84@01)
        ($SortWrappers.IntTo$Snap i@85@01))))))))
  :pattern ((Set_in x@84@01 xs@42@01) (Seq_contains is@43@01 i@85@01))
  :pattern ((Set_in x@84@01 xs@42@01) (Seq_contains_trigger is@43@01 i@85@01))
  :pattern ((Set_in x@84@01 xs@42@01) (Seq_contains_trigger is@43@01 i@85@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@61@10@62@68|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(pop) ; 2
(pop) ; 1
; ---------- test01d ----------
(declare-const xs@90@01 Set<$Ref>)
(declare-const is@91@01 Seq<Int>)
(declare-const xs@92@01 Set<$Ref>)
(declare-const is@93@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var tx: Ref
(declare-const tx@94@01 $Ref)
; [exec]
; var ti: Int
(declare-const ti@95@01 Int)
; [exec]
; var tmp: Int
(declare-const tmp@96@01 Int)
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@97@01 $Ref)
(declare-const i@98@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 21 | !(x@97@01 in xs@92@01) | live]
; [else-branch: 21 | x@97@01 in xs@92@01 | live]
(push) ; 5
; [then-branch: 21 | !(x@97@01 in xs@92@01)]
(assert (not (Set_in x@97@01 xs@92@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 21 | x@97@01 in xs@92@01]
(assert (Set_in x@97@01 xs@92@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@97@01 xs@92@01) (not (Set_in x@97@01 xs@92@01))))
(assert (and (Set_in x@97@01 xs@92@01) (Seq_contains is@93@01 i@98@01)))
(pop) ; 3
(declare-const $t@99@01 $PSF<pair>)
(declare-fun inv@100@01 ($Ref Int) $Ref)
(declare-fun img@101@01 ($Ref Int) Bool)
(declare-fun inv@102@01 ($Ref Int) Int)
(declare-fun img@103@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@97@01 $Ref) (i@98@01 Int)) (!
  (=>
    (and (Set_in x@97@01 xs@92@01) (Seq_contains is@93@01 i@98@01))
    (or (Set_in x@97@01 xs@92@01) (not (Set_in x@97@01 xs@92@01))))
  :pattern ((Set_in x@97@01 xs@92@01) (Seq_contains is@93@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (Seq_contains_trigger is@93@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (Seq_contains_trigger is@93@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (inv@100@01 x@97@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (inv@102@01 x@97@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (img@101@01 x@97@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (img@103@01 x@97@01 i@98@01))
  :pattern ((Seq_contains is@93@01 i@98@01) (inv@100@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (inv@100@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (inv@100@01 x@97@01 i@98@01))
  :pattern ((Seq_contains is@93@01 i@98@01) (inv@102@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (inv@102@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (inv@102@01 x@97@01 i@98@01))
  :pattern ((Seq_contains is@93@01 i@98@01) (img@101@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (img@101@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (img@101@01 x@97@01 i@98@01))
  :pattern ((Seq_contains is@93@01 i@98@01) (img@103@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (img@103@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (img@103@01 x@97@01 i@98@01))
  :pattern ((inv@100@01 x@97@01 i@98@01))
  :pattern ((inv@102@01 x@97@01 i@98@01))
  :pattern ((img@101@01 x@97@01 i@98@01))
  :pattern ((img@103@01 x@97@01 i@98@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@97@01 $Ref) (i1@98@01 Int) (x2@97@01 $Ref) (i2@98@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@97@01 xs@92@01) (Seq_contains is@93@01 i1@98@01))
      (and (Set_in x2@97@01 xs@92@01) (Seq_contains is@93@01 i2@98@01))
      (and (= x1@97@01 x2@97@01) (= i1@98@01 i2@98@01)))
    (and (= x1@97@01 x2@97@01) (= i1@98@01 i2@98@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@97@01 $Ref) (i@98@01 Int)) (!
  (=>
    (and (Set_in x@97@01 xs@92@01) (Seq_contains is@93@01 i@98@01))
    (and
      (and
        (= (inv@100@01 x@97@01 i@98@01) x@97@01)
        (= (inv@102@01 x@97@01 i@98@01) i@98@01))
      (and (img@101@01 x@97@01 i@98@01) (img@103@01 x@97@01 i@98@01))))
  :pattern ((Set_in x@97@01 xs@92@01) (Seq_contains is@93@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (Seq_contains_trigger is@93@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (Seq_contains_trigger is@93@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (inv@100@01 x@97@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (inv@102@01 x@97@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (img@101@01 x@97@01 i@98@01))
  :pattern ((Set_in x@97@01 xs@92@01) (img@103@01 x@97@01 i@98@01))
  :pattern ((Seq_contains is@93@01 i@98@01) (inv@100@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (inv@100@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (inv@100@01 x@97@01 i@98@01))
  :pattern ((Seq_contains is@93@01 i@98@01) (inv@102@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (inv@102@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (inv@102@01 x@97@01 i@98@01))
  :pattern ((Seq_contains is@93@01 i@98@01) (img@101@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (img@101@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (img@101@01 x@97@01 i@98@01))
  :pattern ((Seq_contains is@93@01 i@98@01) (img@103@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (img@103@01 x@97@01 i@98@01))
  :pattern ((Seq_contains_trigger is@93@01 i@98@01) (img@103@01 x@97@01 i@98@01))
  :pattern ((inv@100@01 x@97@01 i@98@01))
  :pattern ((inv@102@01 x@97@01 i@98@01))
  :pattern ((img@101@01 x@97@01 i@98@01))
  :pattern ((img@103@01 x@97@01 i@98@01))
  :qid |quant-u-5072|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@101@01 x i) (img@103@01 x i))
      (and
        (Set_in (inv@100@01 x i) xs@92@01)
        (Seq_contains is@93@01 (inv@102@01 x i))))
    (and (= (inv@100@01 x i) x) (= (inv@102@01 x i) i)))
  :pattern ((inv@100@01 x i))
  :pattern ((inv@102@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const $t@104@01 $Snap)
(assert (= $t@104@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const x@105@01 $Ref)
(declare-const i@106@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 22 | !(x@105@01 in xs@92@01) | live]
; [else-branch: 22 | x@105@01 in xs@92@01 | live]
(push) ; 5
; [then-branch: 22 | !(x@105@01 in xs@92@01)]
(assert (not (Set_in x@105@01 xs@92@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 22 | x@105@01 in xs@92@01]
(assert (Set_in x@105@01 xs@92@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@105@01 xs@92@01) (not (Set_in x@105@01 xs@92@01))))
(push) ; 4
; [then-branch: 23 | x@105@01 in xs@92@01 && i@106@01 in is@93@01 | live]
; [else-branch: 23 | !(x@105@01 in xs@92@01 && i@106@01 in is@93@01) | live]
(push) ; 5
; [then-branch: 23 | x@105@01 in xs@92@01 && i@106@01 in is@93@01]
(assert (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01)))
; [eval] 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@107@01 ((x $Ref) (i Int) (x@105@01 $Ref) (i@106@01 Int)) $Perm
  (ite
    (and (= x x@105@01) (= i i@106@01))
    ($Perm.min
      (ite
        (and
          (and (img@101@01 x i) (img@103@01 x i))
          (and
            (Set_in (inv@100@01 x i) xs@92@01)
            (Seq_contains is@93@01 (inv@102@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@101@01 x i) (img@103@01 x i))
          (and
            (Set_in (inv@100@01 x i) xs@92@01)
            (Seq_contains is@93@01 (inv@102@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@107@01 x i x@105@01 i@106@01))
    $Perm.No)
  
  :qid |quant-u-5074|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@107@01 x i x@105@01 i@106@01) $Perm.No)
  
  :qid |quant-u-5075|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@105@01) (= i i@106@01))
    (= (- $Perm.Write (pTaken@107@01 x i x@105@01 i@106@01)) $Perm.No))
  
  :qid |quant-u-5076|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@108@01 $PSF<pair>)
(declare-const s@109@01 $Snap)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@101@01 x@105@01 i@106@01) (img@103@01 x@105@01 i@106@01))
    (and
      (Set_in (inv@100@01 x@105@01 i@106@01) xs@92@01)
      (Seq_contains is@93@01 (inv@102@01 x@105@01 i@106@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@105@01)
          ($SortWrappers.IntTo$Snap i@106@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@105@01)
        ($SortWrappers.IntTo$Snap i@106@01)))
      ($PSF.lookup_pair $t@99@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@105@01)
        ($SortWrappers.IntTo$Snap i@106@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@105@01)
  ($SortWrappers.IntTo$Snap i@106@01))) x@105@01 i@106@01))
(assert (=
  ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@105@01)
    ($SortWrappers.IntTo$Snap i@106@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@105@01)
      ($SortWrappers.IntTo$Snap i@106@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@105@01)
      ($SortWrappers.IntTo$Snap i@106@01)))))))
(assert (not (= x@105@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@101@01 x@105@01 i@106@01) (img@103@01 x@105@01 i@106@01))
      (and
        (Set_in (inv@100@01 x@105@01 i@106@01) xs@92@01)
        (Seq_contains is@93@01 (inv@102@01 x@105@01 i@106@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@105@01)
            ($SortWrappers.IntTo$Snap i@106@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@105@01)
          ($SortWrappers.IntTo$Snap i@106@01)))
        ($PSF.lookup_pair $t@99@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@105@01)
          ($SortWrappers.IntTo$Snap i@106@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@105@01)
    ($SortWrappers.IntTo$Snap i@106@01))) x@105@01 i@106@01)
  (=
    ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@105@01)
      ($SortWrappers.IntTo$Snap i@106@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@105@01)
        ($SortWrappers.IntTo$Snap i@106@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@105@01)
        ($SortWrappers.IntTo$Snap i@106@01))))))
  (not (= x@105@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@105@01)
  ($SortWrappers.IntTo$Snap i@106@01))))) i@106@01))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@105@01)
  ($SortWrappers.IntTo$Snap i@106@01))))) i@106@01))
(pop) ; 5
(push) ; 5
; [else-branch: 23 | !(x@105@01 in xs@92@01 && i@106@01 in is@93@01)]
(assert (not (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01))
  (and
    (Set_in x@105@01 xs@92@01)
    (Seq_contains is@93@01 i@106@01)
    (=>
      (and
        (and (img@101@01 x@105@01 i@106@01) (img@103@01 x@105@01 i@106@01))
        (and
          (Set_in (inv@100@01 x@105@01 i@106@01) xs@92@01)
          (Seq_contains is@93@01 (inv@102@01 x@105@01 i@106@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@105@01)
              ($SortWrappers.IntTo$Snap i@106@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@105@01)
            ($SortWrappers.IntTo$Snap i@106@01)))
          ($PSF.lookup_pair $t@99@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@105@01)
            ($SortWrappers.IntTo$Snap i@106@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@105@01)
      ($SortWrappers.IntTo$Snap i@106@01))) x@105@01 i@106@01)
    (=
      ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@105@01)
        ($SortWrappers.IntTo$Snap i@106@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@105@01)
          ($SortWrappers.IntTo$Snap i@106@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@105@01)
          ($SortWrappers.IntTo$Snap i@106@01))))))
    (not (= x@105@01 $Ref.null))
    (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@105@01)
      ($SortWrappers.IntTo$Snap i@106@01))))) i@106@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01)))
  (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@105@01 $Ref) (i@106@01 Int)) (!
  (and
    (or (Set_in x@105@01 xs@92@01) (not (Set_in x@105@01 xs@92@01)))
    (=>
      (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01))
      (and
        (Set_in x@105@01 xs@92@01)
        (Seq_contains is@93@01 i@106@01)
        (=>
          (and
            (and (img@101@01 x@105@01 i@106@01) (img@103@01 x@105@01 i@106@01))
            (and
              (Set_in (inv@100@01 x@105@01 i@106@01) xs@92@01)
              (Seq_contains is@93@01 (inv@102@01 x@105@01 i@106@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@105@01)
                  ($SortWrappers.IntTo$Snap i@106@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@105@01)
                ($SortWrappers.IntTo$Snap i@106@01)))
              ($PSF.lookup_pair $t@99@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@105@01)
                ($SortWrappers.IntTo$Snap i@106@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@105@01)
          ($SortWrappers.IntTo$Snap i@106@01))) x@105@01 i@106@01)
        (=
          ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@105@01)
            ($SortWrappers.IntTo$Snap i@106@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@105@01)
              ($SortWrappers.IntTo$Snap i@106@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@105@01)
              ($SortWrappers.IntTo$Snap i@106@01))))))
        (not (= x@105@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@105@01)
          ($SortWrappers.IntTo$Snap i@106@01))))) i@106@01)))
    (or
      (not (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01)))
      (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01))))
  :pattern ((Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01))
  :pattern ((Set_in x@105@01 xs@92@01) (Seq_contains_trigger is@93@01 i@106@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@68@10@69@68-aux|)))
(assert (forall ((x@105@01 $Ref) (i@106@01 Int)) (!
  (and
    (or (Set_in x@105@01 xs@92@01) (not (Set_in x@105@01 xs@92@01)))
    (=>
      (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01))
      (and
        (Set_in x@105@01 xs@92@01)
        (Seq_contains is@93@01 i@106@01)
        (=>
          (and
            (and (img@101@01 x@105@01 i@106@01) (img@103@01 x@105@01 i@106@01))
            (and
              (Set_in (inv@100@01 x@105@01 i@106@01) xs@92@01)
              (Seq_contains is@93@01 (inv@102@01 x@105@01 i@106@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@105@01)
                  ($SortWrappers.IntTo$Snap i@106@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@105@01)
                ($SortWrappers.IntTo$Snap i@106@01)))
              ($PSF.lookup_pair $t@99@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@105@01)
                ($SortWrappers.IntTo$Snap i@106@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@105@01)
          ($SortWrappers.IntTo$Snap i@106@01))) x@105@01 i@106@01)
        (=
          ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@105@01)
            ($SortWrappers.IntTo$Snap i@106@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@105@01)
              ($SortWrappers.IntTo$Snap i@106@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@105@01)
              ($SortWrappers.IntTo$Snap i@106@01))))))
        (not (= x@105@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@105@01)
          ($SortWrappers.IntTo$Snap i@106@01))))) i@106@01)))
    (or
      (not (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01)))
      (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01))))
  :pattern ((Set_in x@105@01 xs@92@01) (Seq_contains_trigger is@93@01 i@106@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@68@10@69@68-aux|)))
(assert (forall ((x@105@01 $Ref) (i@106@01 Int)) (!
  (=>
    (and (Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01))
    (<
      0
      (addA $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@105@01)
        ($SortWrappers.IntTo$Snap i@106@01))))) i@106@01)))
  :pattern ((Set_in x@105@01 xs@92@01) (Seq_contains is@93@01 i@106@01))
  :pattern ((Set_in x@105@01 xs@92@01) (Seq_contains_trigger is@93@01 i@106@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@68@10@69@68|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (tx in xs)
(declare-const $t@110@01 $Snap)
(assert (= $t@110@01 $Snap.unit))
; [eval] (tx in xs)
(assert (Set_in tx@94@01 xs@92@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (ti in is)
(declare-const $t@111@01 $Snap)
(assert (= $t@111@01 $Snap.unit))
; [eval] (ti in is)
(assert (Seq_contains is@93@01 ti@95@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; unfold acc(pair(tx, ti), write)
; Precomputing data for removing quantified permissions
(define-fun pTaken@112@01 ((x $Ref) (i Int)) $Perm
  (ite
    (and (= x tx@94@01) (= i ti@95@01))
    ($Perm.min
      (ite
        (and
          (and (img@101@01 x i) (img@103@01 x i))
          (and
            (Set_in (inv@100@01 x i) xs@92@01)
            (Seq_contains is@93@01 (inv@102@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@101@01 x i) (img@103@01 x i))
          (and
            (Set_in (inv@100@01 x i) xs@92@01)
            (Seq_contains is@93@01 (inv@102@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@112@01 x i))
    $Perm.No)
  
  :qid |quant-u-5078|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@112@01 x i) $Perm.No)
  
  :qid |quant-u-5079|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x tx@94@01) (= i ti@95@01))
    (= (- $Perm.Write (pTaken@112@01 x i)) $Perm.No))
  
  :qid |quant-u-5080|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@101@01 tx@94@01 ti@95@01) (img@103@01 tx@94@01 ti@95@01))
    (and
      (Set_in (inv@100@01 tx@94@01 ti@95@01) xs@92@01)
      (Seq_contains is@93@01 (inv@102@01 tx@94@01 ti@95@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap tx@94@01)
          ($SortWrappers.IntTo$Snap ti@95@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@94@01)
        ($SortWrappers.IntTo$Snap ti@95@01)))
      ($PSF.lookup_pair $t@99@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@94@01)
        ($SortWrappers.IntTo$Snap ti@95@01)))))))
(assert (=
  ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@94@01)
    ($SortWrappers.IntTo$Snap ti@95@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@94@01)
      ($SortWrappers.IntTo$Snap ti@95@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@94@01)
      ($SortWrappers.IntTo$Snap ti@95@01)))))))
(assert (not (= tx@94@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (pair%trigger ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@94@01)
  ($SortWrappers.IntTo$Snap ti@95@01))) tx@94@01 ti@95@01))
; [exec]
; tmp := tx.f
(declare-const tmp@113@01 Int)
(assert (=
  tmp@113@01
  ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@94@01)
    ($SortWrappers.IntTo$Snap ti@95@01)))))))
; [exec]
; tx.f := tx.g
(declare-const f@114@01 Int)
(assert (=
  f@114@01
  ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@108@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@94@01)
    ($SortWrappers.IntTo$Snap ti@95@01)))))))
; [exec]
; tx.g := tmp
; [exec]
; fold acc(pair(tx, ti), write)
(assert (pair%trigger ($Snap.combine
  ($SortWrappers.IntTo$Snap f@114@01)
  ($SortWrappers.IntTo$Snap tmp@113@01)) tx@94@01 ti@95@01))
(declare-const sm@115@01 $PSF<pair>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_pair (as sm@115@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@94@01)
    ($SortWrappers.IntTo$Snap ti@95@01)))
  ($Snap.combine
    ($SortWrappers.IntTo$Snap f@114@01)
    ($SortWrappers.IntTo$Snap tmp@113@01))))
; [exec]
; assert (forall x: Ref, i: Int ::
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) ||
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.g)))
; [eval] (forall x: Ref, i: Int :: { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) || 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g)))
(declare-const x@116@01 $Ref)
(declare-const i@117@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) || 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 24 | !(x@116@01 in xs@92@01) | live]
; [else-branch: 24 | x@116@01 in xs@92@01 | live]
(push) ; 5
; [then-branch: 24 | !(x@116@01 in xs@92@01)]
(assert (not (Set_in x@116@01 xs@92@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 24 | x@116@01 in xs@92@01]
(assert (Set_in x@116@01 xs@92@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@116@01 xs@92@01) (not (Set_in x@116@01 xs@92@01))))
(push) ; 4
; [then-branch: 25 | x@116@01 in xs@92@01 && i@117@01 in is@93@01 | live]
; [else-branch: 25 | !(x@116@01 in xs@92@01 && i@117@01 in is@93@01) | live]
(push) ; 5
; [then-branch: 25 | x@116@01 in xs@92@01 && i@117@01 in is@93@01]
(assert (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01)))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) || 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@94@01 x@116@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@118@01 ((x $Ref) (i Int) (x@116@01 $Ref) (i@117@01 Int)) $Perm
  (ite
    (and (= x x@116@01) (= i i@117@01))
    ($Perm.min
      (ite
        (and
          (and (img@101@01 x i) (img@103@01 x i))
          (and
            (Set_in (inv@100@01 x i) xs@92@01)
            (Seq_contains is@93@01 (inv@102@01 x i))))
        (- $Perm.Write (pTaken@112@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@119@01 ((x $Ref) (i Int) (x@116@01 $Ref) (i@117@01 Int)) $Perm
  (ite
    (and (= x x@116@01) (= i i@117@01))
    ($Perm.min
      (ite (and (= x tx@94@01) (= i ti@95@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@118@01 x i x@116@01 i@117@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@101@01 x i) (img@103@01 x i))
          (and
            (Set_in (inv@100@01 x i) xs@92@01)
            (Seq_contains is@93@01 (inv@102@01 x i))))
        (- $Perm.Write (pTaken@112@01 x i))
        $Perm.No)
      (pTaken@118@01 x i x@116@01 i@117@01))
    $Perm.No)
  
  :qid |quant-u-5082|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@118@01 x i x@116@01 i@117@01) $Perm.No)
  
  :qid |quant-u-5083|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@116@01) (= i i@117@01))
    (= (- $Perm.Write (pTaken@118@01 x i x@116@01 i@117@01)) $Perm.No))
  
  :qid |quant-u-5084|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@119@01 tx@94@01 ti@95@01 x@116@01 i@117@01)) $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@119@01 x i x@116@01 i@117@01) $Perm.No)
  
  :qid |quant-u-5086|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@116@01) (= i i@117@01))
    (=
      (-
        (- $Perm.Write (pTaken@118@01 x i x@116@01 i@117@01))
        (pTaken@119@01 x i x@116@01 i@117@01))
      $Perm.No))
  
  :qid |quant-u-5087|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@120@01 $PSF<pair>)
(declare-const s@121@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@116@01 tx@94@01) (= i@117@01 ti@95@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@116@01)
        ($SortWrappers.IntTo$Snap i@117@01)))
      ($PSF.lookup_pair (as sm@115@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@116@01)
        ($SortWrappers.IntTo$Snap i@117@01)))))))
(assert (=>
  (ite
    (and
      (and (img@101@01 x@116@01 i@117@01) (img@103@01 x@116@01 i@117@01))
      (and
        (Set_in (inv@100@01 x@116@01 i@117@01) xs@92@01)
        (Seq_contains is@93@01 (inv@102@01 x@116@01 i@117@01))))
    (< $Perm.No (- $Perm.Write (pTaken@112@01 x@116@01 i@117@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@116@01)
        ($SortWrappers.IntTo$Snap i@117@01)))
      ($PSF.lookup_pair $t@99@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@116@01)
        ($SortWrappers.IntTo$Snap i@117@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@116@01)
  ($SortWrappers.IntTo$Snap i@117@01))) x@116@01 i@117@01))
(assert (=
  ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@116@01)
    ($SortWrappers.IntTo$Snap i@117@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@116@01)
      ($SortWrappers.IntTo$Snap i@117@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@116@01)
      ($SortWrappers.IntTo$Snap i@117@01)))))))
(assert (not (= x@116@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@116@01 tx@94@01) (= i@117@01 ti@95@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01)))
        ($PSF.lookup_pair (as sm@115@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))))))
  (=>
    (ite
      (and
        (and (img@101@01 x@116@01 i@117@01) (img@103@01 x@116@01 i@117@01))
        (and
          (Set_in (inv@100@01 x@116@01 i@117@01) xs@92@01)
          (Seq_contains is@93@01 (inv@102@01 x@116@01 i@117@01))))
      (< $Perm.No (- $Perm.Write (pTaken@112@01 x@116@01 i@117@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01)))
        ($PSF.lookup_pair $t@99@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@116@01)
    ($SortWrappers.IntTo$Snap i@117@01))) x@116@01 i@117@01)
  (=
    ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@116@01)
      ($SortWrappers.IntTo$Snap i@117@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@116@01)
        ($SortWrappers.IntTo$Snap i@117@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@116@01)
        ($SortWrappers.IntTo$Snap i@117@01))))))
  (not (= x@116@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@116@01)
  ($SortWrappers.IntTo$Snap i@117@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@116@01)
  ($SortWrappers.IntTo$Snap i@117@01)))))))
(push) ; 6
; [then-branch: 26 | 0 < addA(_, i@117@01, First:(PredicateLookup(pair, sm@120@01, List(x@116@01, i@117@01)))) | live]
; [else-branch: 26 | !(0 < addA(_, i@117@01, First:(PredicateLookup(pair, sm@120@01, List(x@116@01, i@117@01))))) | live]
(push) ; 7
; [then-branch: 26 | 0 < addA(_, i@117@01, First:(PredicateLookup(pair, sm@120@01, List(x@116@01, i@117@01))))]
(assert (<
  0
  (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@116@01)
    ($SortWrappers.IntTo$Snap i@117@01))))))))
(pop) ; 7
(push) ; 7
; [else-branch: 26 | !(0 < addA(_, i@117@01, First:(PredicateLookup(pair, sm@120@01, List(x@116@01, i@117@01)))))]
(assert (not
  (<
    0
    (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@116@01)
      ($SortWrappers.IntTo$Snap i@117@01)))))))))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] (unfolding acc(pair(x, i), write) in x.g)
(push) ; 8
(push) ; 9
(set-option :timeout 10)
(assert (not (= tx@94@01 x@116@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ti@95@01 i@117@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@122@01 ((x $Ref) (i Int) (x@116@01 $Ref) (i@117@01 Int)) $Perm
  (ite
    (and (= x x@116@01) (= i i@117@01))
    ($Perm.min
      (ite (and (= x tx@94@01) (= i ti@95@01)) $Perm.Write $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@123@01 ((x $Ref) (i Int) (x@116@01 $Ref) (i@117@01 Int)) $Perm
  (ite
    (and (= x x@116@01) (= i i@117@01))
    ($Perm.min
      (ite
        (and
          (and (img@101@01 x i) (img@103@01 x i))
          (and
            (Set_in (inv@100@01 x i) xs@92@01)
            (Seq_contains is@93@01 (inv@102@01 x i))))
        (- $Perm.Write (pTaken@112@01 x i))
        $Perm.No)
      (- $Perm.Write (pTaken@122@01 x i x@116@01 i@117@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (= (- $Perm.Write (pTaken@122@01 tx@94@01 ti@95@01 x@116@01 i@117@01)) $Perm.No)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@116@01) (= i i@117@01))
    (= (- $Perm.Write (pTaken@122@01 x i x@116@01 i@117@01)) $Perm.No))
  
  :qid |quant-u-5090|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(pop) ; 8
; Joined path conditions
(set-option :timeout 0)
(push) ; 8
(assert (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@116@01)
  ($SortWrappers.IntTo$Snap i@117@01)))))))
(pop) ; 8
; Joined path conditions
(assert (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@116@01)
  ($SortWrappers.IntTo$Snap i@117@01)))))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (=>
  (not
    (<
      0
      (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@116@01)
        ($SortWrappers.IntTo$Snap i@117@01))))))))
  (and
    (not
      (<
        0
        (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))))))))
    (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@116@01)
      ($SortWrappers.IntTo$Snap i@117@01)))))))))
(assert (or
  (not
    (<
      0
      (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@116@01)
        ($SortWrappers.IntTo$Snap i@117@01))))))))
  (<
    0
    (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@116@01)
      ($SortWrappers.IntTo$Snap i@117@01)))))))))
(pop) ; 5
(push) ; 5
; [else-branch: 25 | !(x@116@01 in xs@92@01 && i@117@01 in is@93@01)]
(assert (not (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))
  (and
    (Set_in x@116@01 xs@92@01)
    (Seq_contains is@93@01 i@117@01)
    (=>
      (and (= x@116@01 tx@94@01) (= i@117@01 ti@95@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01)))
          ($PSF.lookup_pair (as sm@115@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01))))))
    (=>
      (ite
        (and
          (and (img@101@01 x@116@01 i@117@01) (img@103@01 x@116@01 i@117@01))
          (and
            (Set_in (inv@100@01 x@116@01 i@117@01) xs@92@01)
            (Seq_contains is@93@01 (inv@102@01 x@116@01 i@117@01))))
        (< $Perm.No (- $Perm.Write (pTaken@112@01 x@116@01 i@117@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01)))
          ($PSF.lookup_pair $t@99@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@116@01)
      ($SortWrappers.IntTo$Snap i@117@01))) x@116@01 i@117@01)
    (=
      ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@116@01)
        ($SortWrappers.IntTo$Snap i@117@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))))))
    (not (= x@116@01 $Ref.null))
    (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@116@01)
      ($SortWrappers.IntTo$Snap i@117@01))))))
    (=>
      (not
        (<
          0
          (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01))))))))
      (and
        (not
          (<
            0
            (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))))))))
        (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))))))))
    (or
      (not
        (<
          0
          (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01))))))))
      (<
        0
        (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01)))))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01)))
  (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@116@01 $Ref) (i@117@01 Int)) (!
  (and
    (or (Set_in x@116@01 xs@92@01) (not (Set_in x@116@01 xs@92@01)))
    (=>
      (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))
      (and
        (Set_in x@116@01 xs@92@01)
        (Seq_contains is@93@01 i@117@01)
        (=>
          (and (= x@116@01 tx@94@01) (= i@117@01 ti@95@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@116@01)
                  ($SortWrappers.IntTo$Snap i@117@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01)))
              ($PSF.lookup_pair (as sm@115@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01))))))
        (=>
          (ite
            (and
              (and (img@101@01 x@116@01 i@117@01) (img@103@01 x@116@01 i@117@01))
              (and
                (Set_in (inv@100@01 x@116@01 i@117@01) xs@92@01)
                (Seq_contains is@93@01 (inv@102@01 x@116@01 i@117@01))))
            (< $Perm.No (- $Perm.Write (pTaken@112@01 x@116@01 i@117@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@116@01)
                  ($SortWrappers.IntTo$Snap i@117@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01)))
              ($PSF.lookup_pair $t@99@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))) x@116@01 i@117@01)
        (=
          ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))))))
        (not (= x@116@01 $Ref.null))
        (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))))))
        (=>
          (not
            (<
              0
              (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01))))))))
          (and
            (not
              (<
                0
                (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@116@01)
                  ($SortWrappers.IntTo$Snap i@117@01))))))))
            (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))))))))
        (or
          (not
            (<
              0
              (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01))))))))
          (<
            0
            (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))))))))))
    (or
      (not (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01)))
      (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains_trigger is@93@01 i@117@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@73@10@76@48-aux|)))
(assert (forall ((x@116@01 $Ref) (i@117@01 Int)) (!
  (and
    (or (Set_in x@116@01 xs@92@01) (not (Set_in x@116@01 xs@92@01)))
    (=>
      (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))
      (and
        (Set_in x@116@01 xs@92@01)
        (Seq_contains is@93@01 i@117@01)
        (=>
          (and (= x@116@01 tx@94@01) (= i@117@01 ti@95@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@116@01)
                  ($SortWrappers.IntTo$Snap i@117@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01)))
              ($PSF.lookup_pair (as sm@115@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01))))))
        (=>
          (ite
            (and
              (and (img@101@01 x@116@01 i@117@01) (img@103@01 x@116@01 i@117@01))
              (and
                (Set_in (inv@100@01 x@116@01 i@117@01) xs@92@01)
                (Seq_contains is@93@01 (inv@102@01 x@116@01 i@117@01))))
            (< $Perm.No (- $Perm.Write (pTaken@112@01 x@116@01 i@117@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@116@01)
                  ($SortWrappers.IntTo$Snap i@117@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01)))
              ($PSF.lookup_pair $t@99@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))) x@116@01 i@117@01)
        (=
          ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))))))
        (not (= x@116@01 $Ref.null))
        (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01))))))
        (=>
          (not
            (<
              0
              (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01))))))))
          (and
            (not
              (<
                0
                (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@116@01)
                  ($SortWrappers.IntTo$Snap i@117@01))))))))
            (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))))))))
        (or
          (not
            (<
              0
              (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@116@01)
                ($SortWrappers.IntTo$Snap i@117@01))))))))
          (<
            0
            (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))))))))))
    (or
      (not (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01)))
      (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains_trigger is@93@01 i@117@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@73@10@76@48-aux|)))
(assert (forall ((x@116@01 $Ref) (i@117@01 Int)) (!
  (=>
    (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))
    (and
      (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@116@01)
        ($SortWrappers.IntTo$Snap i@117@01))))))
      (=>
        (not
          (<
            0
            (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01))))))))
        (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01)))))))))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains_trigger is@93@01 i@117@01))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains_trigger is@93@01 i@117@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@73@10@76@48_precondition|)))
(push) ; 3
(assert (not (forall ((x@116@01 $Ref) (i@117@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))
        (and
          (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@116@01)
            ($SortWrappers.IntTo$Snap i@117@01))))))
          (=>
            (not
              (<
                0
                (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@116@01)
                  ($SortWrappers.IntTo$Snap i@117@01))))))))
            (addA%precondition $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@116@01)
              ($SortWrappers.IntTo$Snap i@117@01)))))))))
      (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01)))
    (or
      (<
        0
        (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01)))))))
      (<
        0
        (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01)))))))))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains_trigger is@93@01 i@117@01))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains_trigger is@93@01 i@117@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@73@10@76@48|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (forall ((x@116@01 $Ref) (i@117@01 Int)) (!
  (=>
    (and (Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))
    (or
      (<
        0
        (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01)))))))
      (<
        0
        (addA $Snap.unit i@117@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@120@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@116@01)
          ($SortWrappers.IntTo$Snap i@117@01)))))))))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains is@93@01 i@117@01))
  :pattern ((Set_in x@116@01 xs@92@01) (Seq_contains_trigger is@93@01 i@117@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@73@10@76@48|)))
(pop) ; 2
(pop) ; 1
; ---------- test02a ----------
(declare-const xs@124@01 Set<$Ref>)
(declare-const is@125@01 Seq<Int>)
(declare-const xs@126@01 Set<$Ref>)
(declare-const is@127@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@128@01 $Ref)
(declare-const i@129@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 27 | !(x@128@01 in xs@126@01) | live]
; [else-branch: 27 | x@128@01 in xs@126@01 | live]
(push) ; 5
; [then-branch: 27 | !(x@128@01 in xs@126@01)]
(assert (not (Set_in x@128@01 xs@126@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 27 | x@128@01 in xs@126@01]
(assert (Set_in x@128@01 xs@126@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@128@01 xs@126@01) (not (Set_in x@128@01 xs@126@01))))
(assert (and (Set_in x@128@01 xs@126@01) (Seq_contains is@127@01 i@129@01)))
(pop) ; 3
(declare-const $t@130@01 $PSF<pair>)
(declare-fun inv@131@01 ($Ref Int) $Ref)
(declare-fun img@132@01 ($Ref Int) Bool)
(declare-fun inv@133@01 ($Ref Int) Int)
(declare-fun img@134@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@128@01 $Ref) (i@129@01 Int)) (!
  (=>
    (and (Set_in x@128@01 xs@126@01) (Seq_contains is@127@01 i@129@01))
    (or (Set_in x@128@01 xs@126@01) (not (Set_in x@128@01 xs@126@01))))
  :pattern ((Set_in x@128@01 xs@126@01) (Seq_contains is@127@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (Seq_contains_trigger is@127@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (Seq_contains_trigger is@127@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (inv@131@01 x@128@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (inv@133@01 x@128@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (img@132@01 x@128@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (img@134@01 x@128@01 i@129@01))
  :pattern ((Seq_contains is@127@01 i@129@01) (inv@131@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (inv@131@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (inv@131@01 x@128@01 i@129@01))
  :pattern ((Seq_contains is@127@01 i@129@01) (inv@133@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (inv@133@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (inv@133@01 x@128@01 i@129@01))
  :pattern ((Seq_contains is@127@01 i@129@01) (img@132@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (img@132@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (img@132@01 x@128@01 i@129@01))
  :pattern ((Seq_contains is@127@01 i@129@01) (img@134@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (img@134@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (img@134@01 x@128@01 i@129@01))
  :pattern ((inv@131@01 x@128@01 i@129@01))
  :pattern ((inv@133@01 x@128@01 i@129@01))
  :pattern ((img@132@01 x@128@01 i@129@01))
  :pattern ((img@134@01 x@128@01 i@129@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@128@01 $Ref) (i1@129@01 Int) (x2@128@01 $Ref) (i2@129@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@128@01 xs@126@01) (Seq_contains is@127@01 i1@129@01))
      (and (Set_in x2@128@01 xs@126@01) (Seq_contains is@127@01 i2@129@01))
      (and (= x1@128@01 x2@128@01) (= i1@129@01 i2@129@01)))
    (and (= x1@128@01 x2@128@01) (= i1@129@01 i2@129@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@128@01 $Ref) (i@129@01 Int)) (!
  (=>
    (and (Set_in x@128@01 xs@126@01) (Seq_contains is@127@01 i@129@01))
    (and
      (and
        (= (inv@131@01 x@128@01 i@129@01) x@128@01)
        (= (inv@133@01 x@128@01 i@129@01) i@129@01))
      (and (img@132@01 x@128@01 i@129@01) (img@134@01 x@128@01 i@129@01))))
  :pattern ((Set_in x@128@01 xs@126@01) (Seq_contains is@127@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (Seq_contains_trigger is@127@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (Seq_contains_trigger is@127@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (inv@131@01 x@128@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (inv@133@01 x@128@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (img@132@01 x@128@01 i@129@01))
  :pattern ((Set_in x@128@01 xs@126@01) (img@134@01 x@128@01 i@129@01))
  :pattern ((Seq_contains is@127@01 i@129@01) (inv@131@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (inv@131@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (inv@131@01 x@128@01 i@129@01))
  :pattern ((Seq_contains is@127@01 i@129@01) (inv@133@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (inv@133@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (inv@133@01 x@128@01 i@129@01))
  :pattern ((Seq_contains is@127@01 i@129@01) (img@132@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (img@132@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (img@132@01 x@128@01 i@129@01))
  :pattern ((Seq_contains is@127@01 i@129@01) (img@134@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (img@134@01 x@128@01 i@129@01))
  :pattern ((Seq_contains_trigger is@127@01 i@129@01) (img@134@01 x@128@01 i@129@01))
  :pattern ((inv@131@01 x@128@01 i@129@01))
  :pattern ((inv@133@01 x@128@01 i@129@01))
  :pattern ((img@132@01 x@128@01 i@129@01))
  :pattern ((img@134@01 x@128@01 i@129@01))
  :qid |quant-u-5092|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@132@01 x i) (img@134@01 x i))
      (and
        (Set_in (inv@131@01 x i) xs@126@01)
        (Seq_contains is@127@01 (inv@133@01 x i))))
    (and (= (inv@131@01 x i) x) (= (inv@133@01 x i) i)))
  :pattern ((inv@131@01 x i))
  :pattern ((inv@133@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
(declare-const sm@135@01 $PSF<pair>)
(declare-const s@136@01 $Snap)
; Definitional axioms for snapshot map values
(assert (forall ((s@136@01 $Snap)) (!
  (=>
    (and
      (and
        (img@132@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@136@01)) ($SortWrappers.$SnapToInt ($Snap.second s@136@01)))
        (img@134@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@136@01)) ($SortWrappers.$SnapToInt ($Snap.second s@136@01))))
      (and
        (Set_in (inv@131@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@136@01)) ($SortWrappers.$SnapToInt ($Snap.second s@136@01))) xs@126@01)
        (Seq_contains
          is@127@01
          (inv@133@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@136@01)) ($SortWrappers.$SnapToInt ($Snap.second s@136@01))))))
    (and
      (not (= s@136@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) s@136@01)
        ($PSF.lookup_pair $t@130@01 s@136@01))))
  :pattern (($PSF.lookup_pair (as sm@135@01  $PSF<pair>) s@136@01))
  :pattern (($PSF.lookup_pair $t@130@01 s@136@01))
  :qid |qp.psmValDef14|)))
(assert (forall ((s@136@01 $Snap)) (!
  ($PSF.loc_pair ($PSF.lookup_pair $t@130@01 s@136@01) s@136@01)
  :pattern (($PSF.lookup_pair (as sm@135@01  $PSF<pair>) s@136@01))
  :qid |qp.psmResTrgDef15|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (Set_in (inv@131@01 x i) xs@126@01)
      (Seq_contains is@127@01 (inv@133@01 x i)))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x)
      ($SortWrappers.IntTo$Snap i))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x)
      ($SortWrappers.IntTo$Snap i))))
  :pattern ((inv@131@01 x i) (inv@133@01 x i))
  :qid |quant-u-5093|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { pair(x, i) }
;     (x in xs) && (i in is) ==>
;     0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const $t@137@01 $Snap)
(assert (= $t@137@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const x@138@01 $Ref)
(declare-const i@139@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 28 | !(x@138@01 in xs@126@01) | live]
; [else-branch: 28 | x@138@01 in xs@126@01 | live]
(push) ; 5
; [then-branch: 28 | !(x@138@01 in xs@126@01)]
(assert (not (Set_in x@138@01 xs@126@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 28 | x@138@01 in xs@126@01]
(assert (Set_in x@138@01 xs@126@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@138@01 xs@126@01) (not (Set_in x@138@01 xs@126@01))))
(push) ; 4
; [then-branch: 29 | x@138@01 in xs@126@01 && i@139@01 in is@127@01 | live]
; [else-branch: 29 | !(x@138@01 in xs@126@01 && i@139@01 in is@127@01) | live]
(push) ; 5
; [then-branch: 29 | x@138@01 in xs@126@01 && i@139@01 in is@127@01]
(assert (and (Set_in x@138@01 xs@126@01) (Seq_contains is@127@01 i@139@01)))
; [eval] 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@138@01)
  ($SortWrappers.IntTo$Snap i@139@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@138@01)
  ($SortWrappers.IntTo$Snap i@139@01))))
; Precomputing data for removing quantified permissions
(define-fun pTaken@140@01 ((x $Ref) (i Int) (x@138@01 $Ref) (i@139@01 Int)) $Perm
  (ite
    (and (= x x@138@01) (= i i@139@01))
    ($Perm.min
      (ite
        (and
          (and (img@132@01 x i) (img@134@01 x i))
          (and
            (Set_in (inv@131@01 x i) xs@126@01)
            (Seq_contains is@127@01 (inv@133@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@132@01 x i) (img@134@01 x i))
          (and
            (Set_in (inv@131@01 x i) xs@126@01)
            (Seq_contains is@127@01 (inv@133@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@140@01 x i x@138@01 i@139@01))
    $Perm.No)
  
  :qid |quant-u-5095|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@140@01 x i x@138@01 i@139@01) $Perm.No)
  
  :qid |quant-u-5096|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@138@01) (= i i@139@01))
    (= (- $Perm.Write (pTaken@140@01 x i x@138@01 i@139@01)) $Perm.No))
  
  :qid |quant-u-5097|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@132@01 x@138@01 i@139@01) (img@134@01 x@138@01 i@139@01))
    (and
      (Set_in (inv@131@01 x@138@01 i@139@01) xs@126@01)
      (Seq_contains is@127@01 (inv@133@01 x@138@01 i@139@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@138@01)
        ($SortWrappers.IntTo$Snap i@139@01)))
      ($PSF.lookup_pair $t@130@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@138@01)
        ($SortWrappers.IntTo$Snap i@139@01)))))))
(assert ($PSF.loc_pair ($PSF.lookup_pair $t@130@01 ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@138@01)
  ($SortWrappers.IntTo$Snap i@139@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@138@01)
  ($SortWrappers.IntTo$Snap i@139@01))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@138@01)
  ($SortWrappers.IntTo$Snap i@139@01))) x@138@01 i@139@01))
(assert (=
  ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@138@01)
    ($SortWrappers.IntTo$Snap i@139@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@138@01)
      ($SortWrappers.IntTo$Snap i@139@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@138@01)
      ($SortWrappers.IntTo$Snap i@139@01)))))))
(assert (not (= x@138@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@138@01)
    ($SortWrappers.IntTo$Snap i@139@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@138@01)
    ($SortWrappers.IntTo$Snap i@139@01)))
  (=>
    (and
      (and (img@132@01 x@138@01 i@139@01) (img@134@01 x@138@01 i@139@01))
      (and
        (Set_in (inv@131@01 x@138@01 i@139@01) xs@126@01)
        (Seq_contains is@127@01 (inv@133@01 x@138@01 i@139@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@138@01)
            ($SortWrappers.IntTo$Snap i@139@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01)))
        ($PSF.lookup_pair $t@130@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair $t@130@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@138@01)
    ($SortWrappers.IntTo$Snap i@139@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@138@01)
    ($SortWrappers.IntTo$Snap i@139@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@138@01)
    ($SortWrappers.IntTo$Snap i@139@01))) x@138@01 i@139@01)
  (=
    ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@138@01)
      ($SortWrappers.IntTo$Snap i@139@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@138@01)
        ($SortWrappers.IntTo$Snap i@139@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@138@01)
        ($SortWrappers.IntTo$Snap i@139@01))))))
  (not (= x@138@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@138@01)
  ($SortWrappers.IntTo$Snap i@139@01))))) i@139@01))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@138@01)
  ($SortWrappers.IntTo$Snap i@139@01))))) i@139@01))
(pop) ; 5
(push) ; 5
; [else-branch: 29 | !(x@138@01 in xs@126@01 && i@139@01 in is@127@01)]
(assert (not (and (Set_in x@138@01 xs@126@01) (Seq_contains is@127@01 i@139@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@138@01 xs@126@01) (Seq_contains is@127@01 i@139@01))
  (and
    (Set_in x@138@01 xs@126@01)
    (Seq_contains is@127@01 i@139@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@138@01)
      ($SortWrappers.IntTo$Snap i@139@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@138@01)
      ($SortWrappers.IntTo$Snap i@139@01)))
    (=>
      (and
        (and (img@132@01 x@138@01 i@139@01) (img@134@01 x@138@01 i@139@01))
        (and
          (Set_in (inv@131@01 x@138@01 i@139@01) xs@126@01)
          (Seq_contains is@127@01 (inv@133@01 x@138@01 i@139@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@138@01)
              ($SortWrappers.IntTo$Snap i@139@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@138@01)
            ($SortWrappers.IntTo$Snap i@139@01)))
          ($PSF.lookup_pair $t@130@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@138@01)
            ($SortWrappers.IntTo$Snap i@139@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair $t@130@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@138@01)
      ($SortWrappers.IntTo$Snap i@139@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@138@01)
      ($SortWrappers.IntTo$Snap i@139@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@138@01)
      ($SortWrappers.IntTo$Snap i@139@01))) x@138@01 i@139@01)
    (=
      ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@138@01)
        ($SortWrappers.IntTo$Snap i@139@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01))))))
    (not (= x@138@01 $Ref.null))
    (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@138@01)
      ($SortWrappers.IntTo$Snap i@139@01))))) i@139@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@138@01 xs@126@01) (Seq_contains is@127@01 i@139@01)))
  (and (Set_in x@138@01 xs@126@01) (Seq_contains is@127@01 i@139@01))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@138@01 $Ref) (i@139@01 Int)) (!
  (and
    (or (Set_in x@138@01 xs@126@01) (not (Set_in x@138@01 xs@126@01)))
    (=>
      (and (Set_in x@138@01 xs@126@01) (Seq_contains is@127@01 i@139@01))
      (and
        (Set_in x@138@01 xs@126@01)
        (Seq_contains is@127@01 i@139@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01)))
        (=>
          (and
            (and (img@132@01 x@138@01 i@139@01) (img@134@01 x@138@01 i@139@01))
            (and
              (Set_in (inv@131@01 x@138@01 i@139@01) xs@126@01)
              (Seq_contains is@127@01 (inv@133@01 x@138@01 i@139@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@138@01)
                  ($SortWrappers.IntTo$Snap i@139@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@138@01)
                ($SortWrappers.IntTo$Snap i@139@01)))
              ($PSF.lookup_pair $t@130@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@138@01)
                ($SortWrappers.IntTo$Snap i@139@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair $t@130@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01))) x@138@01 i@139@01)
        (=
          ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@138@01)
            ($SortWrappers.IntTo$Snap i@139@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@138@01)
              ($SortWrappers.IntTo$Snap i@139@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@138@01)
              ($SortWrappers.IntTo$Snap i@139@01))))))
        (not (= x@138@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@138@01)
          ($SortWrappers.IntTo$Snap i@139@01))))) i@139@01)))
    (or
      (not (and (Set_in x@138@01 xs@126@01) (Seq_contains is@127@01 i@139@01)))
      (and (Set_in x@138@01 xs@126@01) (Seq_contains is@127@01 i@139@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@138@01)
    ($SortWrappers.IntTo$Snap i@139@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@138@01)
    ($SortWrappers.IntTo$Snap i@139@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@83@10@84@68-aux|)))
(assert (forall ((x@138@01 $Ref) (i@139@01 Int)) (!
  (=>
    (and (Set_in x@138@01 xs@126@01) (Seq_contains is@127@01 i@139@01))
    (<
      0
      (addA $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@138@01)
        ($SortWrappers.IntTo$Snap i@139@01))))) i@139@01)))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@138@01)
    ($SortWrappers.IntTo$Snap i@139@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@138@01)
    ($SortWrappers.IntTo$Snap i@139@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@83@10@84@68|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert (forall x: Ref, i: Int ::
;     { pair(x, i) }
;     (x in xs) && (i in is) ==>
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@141@01 $Ref)
(declare-const i@142@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 30 | !(x@141@01 in xs@126@01) | live]
; [else-branch: 30 | x@141@01 in xs@126@01 | live]
(push) ; 5
; [then-branch: 30 | !(x@141@01 in xs@126@01)]
(assert (not (Set_in x@141@01 xs@126@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 30 | x@141@01 in xs@126@01]
(assert (Set_in x@141@01 xs@126@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@141@01 xs@126@01) (not (Set_in x@141@01 xs@126@01))))
(push) ; 4
; [then-branch: 31 | x@141@01 in xs@126@01 && i@142@01 in is@127@01 | live]
; [else-branch: 31 | !(x@141@01 in xs@126@01 && i@142@01 in is@127@01) | live]
(push) ; 5
; [then-branch: 31 | x@141@01 in xs@126@01 && i@142@01 in is@127@01]
(assert (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01)))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@141@01)
  ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@141@01)
  ($SortWrappers.IntTo$Snap i@142@01))))
; Precomputing data for removing quantified permissions
(define-fun pTaken@143@01 ((x $Ref) (i Int) (x@141@01 $Ref) (i@142@01 Int)) $Perm
  (ite
    (and (= x x@141@01) (= i i@142@01))
    ($Perm.min
      (ite
        (and
          (and (img@132@01 x i) (img@134@01 x i))
          (and
            (Set_in (inv@131@01 x i) xs@126@01)
            (Seq_contains is@127@01 (inv@133@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@132@01 x i) (img@134@01 x i))
          (and
            (Set_in (inv@131@01 x i) xs@126@01)
            (Seq_contains is@127@01 (inv@133@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@143@01 x i x@141@01 i@142@01))
    $Perm.No)
  
  :qid |quant-u-5099|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@143@01 x i x@141@01 i@142@01) $Perm.No)
  
  :qid |quant-u-5100|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@141@01) (= i i@142@01))
    (= (- $Perm.Write (pTaken@143@01 x i x@141@01 i@142@01)) $Perm.No))
  
  :qid |quant-u-5101|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@132@01 x@141@01 i@142@01) (img@134@01 x@141@01 i@142@01))
    (and
      (Set_in (inv@131@01 x@141@01 i@142@01) xs@126@01)
      (Seq_contains is@127@01 (inv@133@01 x@141@01 i@142@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@141@01)
        ($SortWrappers.IntTo$Snap i@142@01)))
      ($PSF.lookup_pair $t@130@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@141@01)
        ($SortWrappers.IntTo$Snap i@142@01)))))))
(assert ($PSF.loc_pair ($PSF.lookup_pair $t@130@01 ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@141@01)
  ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@141@01)
  ($SortWrappers.IntTo$Snap i@142@01))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@141@01)
  ($SortWrappers.IntTo$Snap i@142@01))) x@141@01 i@142@01))
(assert (=
  ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@141@01)
      ($SortWrappers.IntTo$Snap i@142@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@141@01)
      ($SortWrappers.IntTo$Snap i@142@01)))))))
(assert (not (= x@141@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01)))
  (=>
    (and
      (and (img@132@01 x@141@01 i@142@01) (img@134@01 x@141@01 i@142@01))
      (and
        (Set_in (inv@131@01 x@141@01 i@142@01) xs@126@01)
        (Seq_contains is@127@01 (inv@133@01 x@141@01 i@142@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@141@01)
            ($SortWrappers.IntTo$Snap i@142@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01)))
        ($PSF.lookup_pair $t@130@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair $t@130@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))) x@141@01 i@142@01)
  (=
    ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@141@01)
      ($SortWrappers.IntTo$Snap i@142@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@141@01)
        ($SortWrappers.IntTo$Snap i@142@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@141@01)
        ($SortWrappers.IntTo$Snap i@142@01))))))
  (not (= x@141@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@142@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@141@01)
  ($SortWrappers.IntTo$Snap i@142@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@142@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@141@01)
  ($SortWrappers.IntTo$Snap i@142@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 31 | !(x@141@01 in xs@126@01 && i@142@01 in is@127@01)]
(assert (not (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01))
  (and
    (Set_in x@141@01 xs@126@01)
    (Seq_contains is@127@01 i@142@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@141@01)
      ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@141@01)
      ($SortWrappers.IntTo$Snap i@142@01)))
    (=>
      (and
        (and (img@132@01 x@141@01 i@142@01) (img@134@01 x@141@01 i@142@01))
        (and
          (Set_in (inv@131@01 x@141@01 i@142@01) xs@126@01)
          (Seq_contains is@127@01 (inv@133@01 x@141@01 i@142@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@141@01)
              ($SortWrappers.IntTo$Snap i@142@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@141@01)
            ($SortWrappers.IntTo$Snap i@142@01)))
          ($PSF.lookup_pair $t@130@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@141@01)
            ($SortWrappers.IntTo$Snap i@142@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair $t@130@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@141@01)
      ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@141@01)
      ($SortWrappers.IntTo$Snap i@142@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@141@01)
      ($SortWrappers.IntTo$Snap i@142@01))) x@141@01 i@142@01)
    (=
      ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@141@01)
        ($SortWrappers.IntTo$Snap i@142@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01))))))
    (not (= x@141@01 $Ref.null))
    (addA%precondition $Snap.unit i@142@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@141@01)
      ($SortWrappers.IntTo$Snap i@142@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01)))
  (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@141@01 $Ref) (i@142@01 Int)) (!
  (and
    (or (Set_in x@141@01 xs@126@01) (not (Set_in x@141@01 xs@126@01)))
    (=>
      (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01))
      (and
        (Set_in x@141@01 xs@126@01)
        (Seq_contains is@127@01 i@142@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01)))
        (=>
          (and
            (and (img@132@01 x@141@01 i@142@01) (img@134@01 x@141@01 i@142@01))
            (and
              (Set_in (inv@131@01 x@141@01 i@142@01) xs@126@01)
              (Seq_contains is@127@01 (inv@133@01 x@141@01 i@142@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@141@01)
                  ($SortWrappers.IntTo$Snap i@142@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@141@01)
                ($SortWrappers.IntTo$Snap i@142@01)))
              ($PSF.lookup_pair $t@130@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@141@01)
                ($SortWrappers.IntTo$Snap i@142@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair $t@130@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01))) x@141@01 i@142@01)
        (=
          ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@141@01)
            ($SortWrappers.IntTo$Snap i@142@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@141@01)
              ($SortWrappers.IntTo$Snap i@142@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@141@01)
              ($SortWrappers.IntTo$Snap i@142@01))))))
        (not (= x@141@01 $Ref.null))
        (addA%precondition $Snap.unit i@142@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01))))))))
    (or
      (not (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01)))
      (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@86@10@87@68-aux|)))
(assert (forall ((x@141@01 $Ref) (i@142@01 Int)) (!
  (=>
    (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01))
    (addA%precondition $Snap.unit i@142@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@141@01)
      ($SortWrappers.IntTo$Snap i@142@01)))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@86@10@87@68_precondition|)))
(push) ; 3
(assert (not (forall ((x@141@01 $Ref) (i@142@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01))
        (addA%precondition $Snap.unit i@142@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@141@01)
          ($SortWrappers.IntTo$Snap i@142@01)))))))
      (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01)))
    (<
      0
      (addA $Snap.unit i@142@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@141@01)
        ($SortWrappers.IntTo$Snap i@142@01))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@86@10@87@68|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (forall ((x@141@01 $Ref) (i@142@01 Int)) (!
  (=>
    (and (Set_in x@141@01 xs@126@01) (Seq_contains is@127@01 i@142@01))
    (<
      0
      (addA $Snap.unit i@142@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@141@01)
        ($SortWrappers.IntTo$Snap i@142@01))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@135@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@141@01)
    ($SortWrappers.IntTo$Snap i@142@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@86@10@87@68|)))
(pop) ; 2
(pop) ; 1
; ---------- test02b ----------
(declare-const xs@144@01 Set<$Ref>)
(declare-const is@145@01 Seq<Int>)
(declare-const xs@146@01 Set<$Ref>)
(declare-const is@147@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var tx: Ref
(declare-const tx@148@01 $Ref)
; [exec]
; var ti: Int
(declare-const ti@149@01 Int)
; [exec]
; var tmp: Int
(declare-const tmp@150@01 Int)
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@151@01 $Ref)
(declare-const i@152@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 32 | !(x@151@01 in xs@146@01) | live]
; [else-branch: 32 | x@151@01 in xs@146@01 | live]
(push) ; 5
; [then-branch: 32 | !(x@151@01 in xs@146@01)]
(assert (not (Set_in x@151@01 xs@146@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 32 | x@151@01 in xs@146@01]
(assert (Set_in x@151@01 xs@146@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@151@01 xs@146@01) (not (Set_in x@151@01 xs@146@01))))
(assert (and (Set_in x@151@01 xs@146@01) (Seq_contains is@147@01 i@152@01)))
(pop) ; 3
(declare-const $t@153@01 $PSF<pair>)
(declare-fun inv@154@01 ($Ref Int) $Ref)
(declare-fun img@155@01 ($Ref Int) Bool)
(declare-fun inv@156@01 ($Ref Int) Int)
(declare-fun img@157@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@151@01 $Ref) (i@152@01 Int)) (!
  (=>
    (and (Set_in x@151@01 xs@146@01) (Seq_contains is@147@01 i@152@01))
    (or (Set_in x@151@01 xs@146@01) (not (Set_in x@151@01 xs@146@01))))
  :pattern ((Set_in x@151@01 xs@146@01) (Seq_contains is@147@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (Seq_contains_trigger is@147@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (Seq_contains_trigger is@147@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (inv@154@01 x@151@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (inv@156@01 x@151@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (img@155@01 x@151@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (img@157@01 x@151@01 i@152@01))
  :pattern ((Seq_contains is@147@01 i@152@01) (inv@154@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (inv@154@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (inv@154@01 x@151@01 i@152@01))
  :pattern ((Seq_contains is@147@01 i@152@01) (inv@156@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (inv@156@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (inv@156@01 x@151@01 i@152@01))
  :pattern ((Seq_contains is@147@01 i@152@01) (img@155@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (img@155@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (img@155@01 x@151@01 i@152@01))
  :pattern ((Seq_contains is@147@01 i@152@01) (img@157@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (img@157@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (img@157@01 x@151@01 i@152@01))
  :pattern ((inv@154@01 x@151@01 i@152@01))
  :pattern ((inv@156@01 x@151@01 i@152@01))
  :pattern ((img@155@01 x@151@01 i@152@01))
  :pattern ((img@157@01 x@151@01 i@152@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@151@01 $Ref) (i1@152@01 Int) (x2@151@01 $Ref) (i2@152@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@151@01 xs@146@01) (Seq_contains is@147@01 i1@152@01))
      (and (Set_in x2@151@01 xs@146@01) (Seq_contains is@147@01 i2@152@01))
      (and (= x1@151@01 x2@151@01) (= i1@152@01 i2@152@01)))
    (and (= x1@151@01 x2@151@01) (= i1@152@01 i2@152@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@151@01 $Ref) (i@152@01 Int)) (!
  (=>
    (and (Set_in x@151@01 xs@146@01) (Seq_contains is@147@01 i@152@01))
    (and
      (and
        (= (inv@154@01 x@151@01 i@152@01) x@151@01)
        (= (inv@156@01 x@151@01 i@152@01) i@152@01))
      (and (img@155@01 x@151@01 i@152@01) (img@157@01 x@151@01 i@152@01))))
  :pattern ((Set_in x@151@01 xs@146@01) (Seq_contains is@147@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (Seq_contains_trigger is@147@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (Seq_contains_trigger is@147@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (inv@154@01 x@151@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (inv@156@01 x@151@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (img@155@01 x@151@01 i@152@01))
  :pattern ((Set_in x@151@01 xs@146@01) (img@157@01 x@151@01 i@152@01))
  :pattern ((Seq_contains is@147@01 i@152@01) (inv@154@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (inv@154@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (inv@154@01 x@151@01 i@152@01))
  :pattern ((Seq_contains is@147@01 i@152@01) (inv@156@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (inv@156@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (inv@156@01 x@151@01 i@152@01))
  :pattern ((Seq_contains is@147@01 i@152@01) (img@155@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (img@155@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (img@155@01 x@151@01 i@152@01))
  :pattern ((Seq_contains is@147@01 i@152@01) (img@157@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (img@157@01 x@151@01 i@152@01))
  :pattern ((Seq_contains_trigger is@147@01 i@152@01) (img@157@01 x@151@01 i@152@01))
  :pattern ((inv@154@01 x@151@01 i@152@01))
  :pattern ((inv@156@01 x@151@01 i@152@01))
  :pattern ((img@155@01 x@151@01 i@152@01))
  :pattern ((img@157@01 x@151@01 i@152@01))
  :qid |quant-u-5103|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@155@01 x i) (img@157@01 x i))
      (and
        (Set_in (inv@154@01 x i) xs@146@01)
        (Seq_contains is@147@01 (inv@156@01 x i))))
    (and (= (inv@154@01 x i) x) (= (inv@156@01 x i) i)))
  :pattern ((inv@154@01 x i))
  :pattern ((inv@156@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
(declare-const sm@158@01 $PSF<pair>)
(declare-const s@159@01 $Snap)
; Definitional axioms for snapshot map values
(assert (forall ((s@159@01 $Snap)) (!
  (=>
    (and
      (and
        (img@155@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@159@01)) ($SortWrappers.$SnapToInt ($Snap.second s@159@01)))
        (img@157@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@159@01)) ($SortWrappers.$SnapToInt ($Snap.second s@159@01))))
      (and
        (Set_in (inv@154@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@159@01)) ($SortWrappers.$SnapToInt ($Snap.second s@159@01))) xs@146@01)
        (Seq_contains
          is@147@01
          (inv@156@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@159@01)) ($SortWrappers.$SnapToInt ($Snap.second s@159@01))))))
    (and
      (not (= s@159@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) s@159@01)
        ($PSF.lookup_pair $t@153@01 s@159@01))))
  :pattern (($PSF.lookup_pair (as sm@158@01  $PSF<pair>) s@159@01))
  :pattern (($PSF.lookup_pair $t@153@01 s@159@01))
  :qid |qp.psmValDef16|)))
(assert (forall ((s@159@01 $Snap)) (!
  ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 s@159@01) s@159@01)
  :pattern (($PSF.lookup_pair (as sm@158@01  $PSF<pair>) s@159@01))
  :qid |qp.psmResTrgDef17|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (Set_in (inv@154@01 x i) xs@146@01)
      (Seq_contains is@147@01 (inv@156@01 x i)))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x)
      ($SortWrappers.IntTo$Snap i))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x)
      ($SortWrappers.IntTo$Snap i))))
  :pattern ((inv@154@01 x i) (inv@156@01 x i))
  :qid |quant-u-5104|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { pair(x, i) }
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const $t@160@01 $Snap)
(assert (= $t@160@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const x@161@01 $Ref)
(declare-const i@162@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 33 | !(x@161@01 in xs@146@01) | live]
; [else-branch: 33 | x@161@01 in xs@146@01 | live]
(push) ; 5
; [then-branch: 33 | !(x@161@01 in xs@146@01)]
(assert (not (Set_in x@161@01 xs@146@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 33 | x@161@01 in xs@146@01]
(assert (Set_in x@161@01 xs@146@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@161@01 xs@146@01) (not (Set_in x@161@01 xs@146@01))))
(push) ; 4
; [then-branch: 34 | x@161@01 in xs@146@01 && i@162@01 in is@147@01 | live]
; [else-branch: 34 | !(x@161@01 in xs@146@01 && i@162@01 in is@147@01) | live]
(push) ; 5
; [then-branch: 34 | x@161@01 in xs@146@01 && i@162@01 in is@147@01]
(assert (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01)))
; [eval] 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@161@01)
  ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@161@01)
  ($SortWrappers.IntTo$Snap i@162@01))))
; Precomputing data for removing quantified permissions
(define-fun pTaken@163@01 ((x $Ref) (i Int) (x@161@01 $Ref) (i@162@01 Int)) $Perm
  (ite
    (and (= x x@161@01) (= i i@162@01))
    ($Perm.min
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@163@01 x i x@161@01 i@162@01))
    $Perm.No)
  
  :qid |quant-u-5106|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@163@01 x i x@161@01 i@162@01) $Perm.No)
  
  :qid |quant-u-5107|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@161@01) (= i i@162@01))
    (= (- $Perm.Write (pTaken@163@01 x i x@161@01 i@162@01)) $Perm.No))
  
  :qid |quant-u-5108|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@155@01 x@161@01 i@162@01) (img@157@01 x@161@01 i@162@01))
    (and
      (Set_in (inv@154@01 x@161@01 i@162@01) xs@146@01)
      (Seq_contains is@147@01 (inv@156@01 x@161@01 i@162@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@161@01)
        ($SortWrappers.IntTo$Snap i@162@01)))
      ($PSF.lookup_pair $t@153@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@161@01)
        ($SortWrappers.IntTo$Snap i@162@01)))))))
(assert ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@161@01)
  ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@161@01)
  ($SortWrappers.IntTo$Snap i@162@01))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@161@01)
  ($SortWrappers.IntTo$Snap i@162@01))) x@161@01 i@162@01))
(assert (=
  ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@161@01)
    ($SortWrappers.IntTo$Snap i@162@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@161@01)
      ($SortWrappers.IntTo$Snap i@162@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@161@01)
      ($SortWrappers.IntTo$Snap i@162@01)))))))
(assert (not (= x@161@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@161@01)
    ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@161@01)
    ($SortWrappers.IntTo$Snap i@162@01)))
  (=>
    (and
      (and (img@155@01 x@161@01 i@162@01) (img@157@01 x@161@01 i@162@01))
      (and
        (Set_in (inv@154@01 x@161@01 i@162@01) xs@146@01)
        (Seq_contains is@147@01 (inv@156@01 x@161@01 i@162@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@161@01)
            ($SortWrappers.IntTo$Snap i@162@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01)))
        ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@161@01)
    ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@161@01)
    ($SortWrappers.IntTo$Snap i@162@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@161@01)
    ($SortWrappers.IntTo$Snap i@162@01))) x@161@01 i@162@01)
  (=
    ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@161@01)
      ($SortWrappers.IntTo$Snap i@162@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@161@01)
        ($SortWrappers.IntTo$Snap i@162@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@161@01)
        ($SortWrappers.IntTo$Snap i@162@01))))))
  (not (= x@161@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@161@01)
  ($SortWrappers.IntTo$Snap i@162@01))))) i@162@01))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@161@01)
  ($SortWrappers.IntTo$Snap i@162@01))))) i@162@01))
(pop) ; 5
(push) ; 5
; [else-branch: 34 | !(x@161@01 in xs@146@01 && i@162@01 in is@147@01)]
(assert (not (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))
  (and
    (Set_in x@161@01 xs@146@01)
    (Seq_contains is@147@01 i@162@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@161@01)
      ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@161@01)
      ($SortWrappers.IntTo$Snap i@162@01)))
    (=>
      (and
        (and (img@155@01 x@161@01 i@162@01) (img@157@01 x@161@01 i@162@01))
        (and
          (Set_in (inv@154@01 x@161@01 i@162@01) xs@146@01)
          (Seq_contains is@147@01 (inv@156@01 x@161@01 i@162@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@161@01)
              ($SortWrappers.IntTo$Snap i@162@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@161@01)
            ($SortWrappers.IntTo$Snap i@162@01)))
          ($PSF.lookup_pair $t@153@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@161@01)
            ($SortWrappers.IntTo$Snap i@162@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@161@01)
      ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@161@01)
      ($SortWrappers.IntTo$Snap i@162@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@161@01)
      ($SortWrappers.IntTo$Snap i@162@01))) x@161@01 i@162@01)
    (=
      ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@161@01)
        ($SortWrappers.IntTo$Snap i@162@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))))))
    (not (= x@161@01 $Ref.null))
    (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@161@01)
      ($SortWrappers.IntTo$Snap i@162@01))))) i@162@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01)))
  (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@161@01 $Ref) (i@162@01 Int)) (!
  (and
    (or (Set_in x@161@01 xs@146@01) (not (Set_in x@161@01 xs@146@01)))
    (=>
      (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))
      (and
        (Set_in x@161@01 xs@146@01)
        (Seq_contains is@147@01 i@162@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01)))
        (=>
          (and
            (and (img@155@01 x@161@01 i@162@01) (img@157@01 x@161@01 i@162@01))
            (and
              (Set_in (inv@154@01 x@161@01 i@162@01) xs@146@01)
              (Seq_contains is@147@01 (inv@156@01 x@161@01 i@162@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@161@01)
                  ($SortWrappers.IntTo$Snap i@162@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@161@01)
                ($SortWrappers.IntTo$Snap i@162@01)))
              ($PSF.lookup_pair $t@153@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@161@01)
                ($SortWrappers.IntTo$Snap i@162@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))) x@161@01 i@162@01)
        (=
          ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@161@01)
            ($SortWrappers.IntTo$Snap i@162@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@161@01)
              ($SortWrappers.IntTo$Snap i@162@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@161@01)
              ($SortWrappers.IntTo$Snap i@162@01))))))
        (not (= x@161@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))))) i@162@01)))
    (or
      (not (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01)))
      (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@161@01)
    ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@161@01)
    ($SortWrappers.IntTo$Snap i@162@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@93@10@94@68-aux|)))
(assert (forall ((x@161@01 $Ref) (i@162@01 Int)) (!
  (and
    (or (Set_in x@161@01 xs@146@01) (not (Set_in x@161@01 xs@146@01)))
    (=>
      (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))
      (and
        (Set_in x@161@01 xs@146@01)
        (Seq_contains is@147@01 i@162@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01)))
        (=>
          (and
            (and (img@155@01 x@161@01 i@162@01) (img@157@01 x@161@01 i@162@01))
            (and
              (Set_in (inv@154@01 x@161@01 i@162@01) xs@146@01)
              (Seq_contains is@147@01 (inv@156@01 x@161@01 i@162@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@161@01)
                  ($SortWrappers.IntTo$Snap i@162@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@161@01)
                ($SortWrappers.IntTo$Snap i@162@01)))
              ($PSF.lookup_pair $t@153@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@161@01)
                ($SortWrappers.IntTo$Snap i@162@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))) x@161@01 i@162@01)
        (=
          ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@161@01)
            ($SortWrappers.IntTo$Snap i@162@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@161@01)
              ($SortWrappers.IntTo$Snap i@162@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@161@01)
              ($SortWrappers.IntTo$Snap i@162@01))))))
        (not (= x@161@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))))) i@162@01)))
    (or
      (not (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01)))
      (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))))
  :pattern ((Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))
  :pattern ((Set_in x@161@01 xs@146@01) (Seq_contains_trigger is@147@01 i@162@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@93@10@94@68-aux|)))
(assert (forall ((x@161@01 $Ref) (i@162@01 Int)) (!
  (and
    (or (Set_in x@161@01 xs@146@01) (not (Set_in x@161@01 xs@146@01)))
    (=>
      (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))
      (and
        (Set_in x@161@01 xs@146@01)
        (Seq_contains is@147@01 i@162@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01)))
        (=>
          (and
            (and (img@155@01 x@161@01 i@162@01) (img@157@01 x@161@01 i@162@01))
            (and
              (Set_in (inv@154@01 x@161@01 i@162@01) xs@146@01)
              (Seq_contains is@147@01 (inv@156@01 x@161@01 i@162@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@161@01)
                  ($SortWrappers.IntTo$Snap i@162@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@161@01)
                ($SortWrappers.IntTo$Snap i@162@01)))
              ($PSF.lookup_pair $t@153@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@161@01)
                ($SortWrappers.IntTo$Snap i@162@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))) x@161@01 i@162@01)
        (=
          ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@161@01)
            ($SortWrappers.IntTo$Snap i@162@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@161@01)
              ($SortWrappers.IntTo$Snap i@162@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@161@01)
              ($SortWrappers.IntTo$Snap i@162@01))))))
        (not (= x@161@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@161@01)
          ($SortWrappers.IntTo$Snap i@162@01))))) i@162@01)))
    (or
      (not (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01)))
      (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))))
  :pattern ((Set_in x@161@01 xs@146@01) (Seq_contains_trigger is@147@01 i@162@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@93@10@94@68-aux|)))
(assert (forall ((x@161@01 $Ref) (i@162@01 Int)) (!
  (=>
    (and (Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))
    (<
      0
      (addA $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@161@01)
        ($SortWrappers.IntTo$Snap i@162@01))))) i@162@01)))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@161@01)
    ($SortWrappers.IntTo$Snap i@162@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@161@01)
    ($SortWrappers.IntTo$Snap i@162@01))))
  :pattern ((Set_in x@161@01 xs@146@01) (Seq_contains is@147@01 i@162@01))
  :pattern ((Set_in x@161@01 xs@146@01) (Seq_contains_trigger is@147@01 i@162@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@93@10@94@68|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (tx in xs)
(declare-const $t@164@01 $Snap)
(assert (= $t@164@01 $Snap.unit))
; [eval] (tx in xs)
(assert (Set_in tx@148@01 xs@146@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (ti in is)
(declare-const $t@165@01 $Snap)
(assert (= $t@165@01 $Snap.unit))
; [eval] (ti in is)
(assert (Seq_contains is@147@01 ti@149@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; unfold acc(pair(tx, ti), write)
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@148@01)
  ($SortWrappers.IntTo$Snap ti@149@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@148@01)
  ($SortWrappers.IntTo$Snap ti@149@01))))
; Precomputing data for removing quantified permissions
(define-fun pTaken@166@01 ((x $Ref) (i Int)) $Perm
  (ite
    (and (= x tx@148@01) (= i ti@149@01))
    ($Perm.min
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@166@01 x i))
    $Perm.No)
  
  :qid |quant-u-5110|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@166@01 x i) $Perm.No)
  
  :qid |quant-u-5111|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x tx@148@01) (= i ti@149@01))
    (= (- $Perm.Write (pTaken@166@01 x i)) $Perm.No))
  
  :qid |quant-u-5112|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@155@01 tx@148@01 ti@149@01) (img@157@01 tx@148@01 ti@149@01))
    (and
      (Set_in (inv@154@01 tx@148@01 ti@149@01) xs@146@01)
      (Seq_contains is@147@01 (inv@156@01 tx@148@01 ti@149@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap tx@148@01)
          ($SortWrappers.IntTo$Snap ti@149@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@148@01)
        ($SortWrappers.IntTo$Snap ti@149@01)))
      ($PSF.lookup_pair $t@153@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@148@01)
        ($SortWrappers.IntTo$Snap ti@149@01)))))))
(assert ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@148@01)
  ($SortWrappers.IntTo$Snap ti@149@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@148@01)
  ($SortWrappers.IntTo$Snap ti@149@01))))
(assert (=
  ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@148@01)
    ($SortWrappers.IntTo$Snap ti@149@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@148@01)
      ($SortWrappers.IntTo$Snap ti@149@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@148@01)
      ($SortWrappers.IntTo$Snap ti@149@01)))))))
(assert (not (= tx@148@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (pair%trigger ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@148@01)
  ($SortWrappers.IntTo$Snap ti@149@01))) tx@148@01 ti@149@01))
; [exec]
; tmp := tx.f
(declare-const tmp@167@01 Int)
(assert (=
  tmp@167@01
  ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@148@01)
    ($SortWrappers.IntTo$Snap ti@149@01)))))))
; [exec]
; tx.f := tx.g
(declare-const f@168@01 Int)
(assert (=
  f@168@01
  ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@158@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@148@01)
    ($SortWrappers.IntTo$Snap ti@149@01)))))))
; [exec]
; tx.g := tmp
; [exec]
; fold acc(pair(tx, ti), write)
(assert (pair%trigger ($Snap.combine
  ($SortWrappers.IntTo$Snap f@168@01)
  ($SortWrappers.IntTo$Snap tmp@167@01)) tx@148@01 ti@149@01))
(declare-const sm@169@01 $PSF<pair>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@148@01)
    ($SortWrappers.IntTo$Snap ti@149@01)))
  ($Snap.combine
    ($SortWrappers.IntTo$Snap f@168@01)
    ($SortWrappers.IntTo$Snap tmp@167@01))))
(declare-const sm@170@01 $PSF<pair>)
(declare-const s@171@01 $Snap)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((s@171@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@171@01)) tx@148@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@171@01)) ti@149@01))
    (and
      (not (= s@171@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) s@171@01)
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@171@01))))
  :pattern (($PSF.lookup_pair (as sm@170@01  $PSF<pair>) s@171@01))
  :pattern (($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@171@01))
  :qid |qp.psmValDef18|)))
(assert (forall ((s@171@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@155@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@171@01)) ($SortWrappers.$SnapToInt ($Snap.second s@171@01)))
          (img@157@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@171@01)) ($SortWrappers.$SnapToInt ($Snap.second s@171@01))))
        (and
          (Set_in (inv@154@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@171@01)) ($SortWrappers.$SnapToInt ($Snap.second s@171@01))) xs@146@01)
          (Seq_contains
            is@147@01
            (inv@156@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@171@01)) ($SortWrappers.$SnapToInt ($Snap.second s@171@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@166@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@171@01)) ($SortWrappers.$SnapToInt ($Snap.second s@171@01)))))
      false)
    (and
      (not (= s@171@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) s@171@01)
        ($PSF.lookup_pair $t@153@01 s@171@01))))
  :pattern (($PSF.lookup_pair (as sm@170@01  $PSF<pair>) s@171@01))
  :pattern (($PSF.lookup_pair $t@153@01 s@171@01))
  :qid |qp.psmValDef19|)))
(assert (forall ((s@171@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@171@01) s@171@01)
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 s@171@01) s@171@01))
  :pattern (($PSF.lookup_pair (as sm@170@01  $PSF<pair>) s@171@01))
  :qid |qp.psmResTrgDef20|)))
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@148@01)
  ($SortWrappers.IntTo$Snap ti@149@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@148@01)
  ($SortWrappers.IntTo$Snap ti@149@01))))
; [exec]
; assert (forall x: Ref, i: Int ::
;     { pair(x, i) }
;     (x in xs) && (i in is) ==>
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@172@01 $Ref)
(declare-const i@173@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 35 | !(x@172@01 in xs@146@01) | live]
; [else-branch: 35 | x@172@01 in xs@146@01 | live]
(push) ; 5
; [then-branch: 35 | !(x@172@01 in xs@146@01)]
(assert (not (Set_in x@172@01 xs@146@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 35 | x@172@01 in xs@146@01]
(assert (Set_in x@172@01 xs@146@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@172@01 xs@146@01) (not (Set_in x@172@01 xs@146@01))))
(push) ; 4
; [then-branch: 36 | x@172@01 in xs@146@01 && i@173@01 in is@147@01 | live]
; [else-branch: 36 | !(x@172@01 in xs@146@01 && i@173@01 in is@147@01) | live]
(push) ; 5
; [then-branch: 36 | x@172@01 in xs@146@01 && i@173@01 in is@147@01]
(assert (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01)))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@172@01)
  ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@172@01)
  ($SortWrappers.IntTo$Snap i@173@01))))
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@148@01 x@172@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@174@01 ((x $Ref) (i Int) (x@172@01 $Ref) (i@173@01 Int)) $Perm
  (ite
    (and (= x x@172@01) (= i i@173@01))
    ($Perm.min
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        (- $Perm.Write (pTaken@166@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@175@01 ((x $Ref) (i Int) (x@172@01 $Ref) (i@173@01 Int)) $Perm
  (ite
    (and (= x x@172@01) (= i i@173@01))
    ($Perm.min
      (ite (and (= x tx@148@01) (= i ti@149@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@174@01 x i x@172@01 i@173@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        (- $Perm.Write (pTaken@166@01 x i))
        $Perm.No)
      (pTaken@174@01 x i x@172@01 i@173@01))
    $Perm.No)
  
  :qid |quant-u-5114|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@174@01 x i x@172@01 i@173@01) $Perm.No)
  
  :qid |quant-u-5115|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@172@01) (= i i@173@01))
    (= (- $Perm.Write (pTaken@174@01 x i x@172@01 i@173@01)) $Perm.No))
  
  :qid |quant-u-5116|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@175@01 tx@148@01 ti@149@01 x@172@01 i@173@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@175@01 x i x@172@01 i@173@01) $Perm.No)
  
  :qid |quant-u-5118|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@172@01) (= i i@173@01))
    (=
      (-
        (- $Perm.Write (pTaken@174@01 x i x@172@01 i@173@01))
        (pTaken@175@01 x i x@172@01 i@173@01))
      $Perm.No))
  
  :qid |quant-u-5119|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@172@01 tx@148@01) (= i@173@01 ti@149@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@172@01)
        ($SortWrappers.IntTo$Snap i@173@01)))
      ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@172@01)
        ($SortWrappers.IntTo$Snap i@173@01)))))))
(assert (=>
  (ite
    (and
      (and (img@155@01 x@172@01 i@173@01) (img@157@01 x@172@01 i@173@01))
      (and
        (Set_in (inv@154@01 x@172@01 i@173@01) xs@146@01)
        (Seq_contains is@147@01 (inv@156@01 x@172@01 i@173@01))))
    (< $Perm.No (- $Perm.Write (pTaken@166@01 x@172@01 i@173@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@172@01)
        ($SortWrappers.IntTo$Snap i@173@01)))
      ($PSF.lookup_pair $t@153@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@172@01)
        ($SortWrappers.IntTo$Snap i@173@01)))))))
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01)))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@172@01)
  ($SortWrappers.IntTo$Snap i@173@01))) x@172@01 i@173@01))
(assert (=
  ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01)))))))
(assert (not (= x@172@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01)))
  (=>
    (and (= x@172@01 tx@148@01) (= i@173@01 ti@149@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@172@01)
            ($SortWrappers.IntTo$Snap i@173@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01)))
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))))))
  (=>
    (ite
      (and
        (and (img@155@01 x@172@01 i@173@01) (img@157@01 x@172@01 i@173@01))
        (and
          (Set_in (inv@154@01 x@172@01 i@173@01) xs@146@01)
          (Seq_contains is@147@01 (inv@156@01 x@172@01 i@173@01))))
      (< $Perm.No (- $Perm.Write (pTaken@166@01 x@172@01 i@173@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@172@01)
            ($SortWrappers.IntTo$Snap i@173@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01)))
        ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))) x@172@01 i@173@01)
  (=
    ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@172@01)
        ($SortWrappers.IntTo$Snap i@173@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@172@01)
        ($SortWrappers.IntTo$Snap i@173@01))))))
  (not (= x@172@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@173@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@172@01)
  ($SortWrappers.IntTo$Snap i@173@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@173@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@172@01)
  ($SortWrappers.IntTo$Snap i@173@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 36 | !(x@172@01 in xs@146@01 && i@173@01 in is@147@01)]
(assert (not (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01))
  (and
    (Set_in x@172@01 xs@146@01)
    (Seq_contains is@147@01 i@173@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01)))
    (=>
      (and (= x@172@01 tx@148@01) (= i@173@01 ti@149@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@172@01)
              ($SortWrappers.IntTo$Snap i@173@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@172@01)
            ($SortWrappers.IntTo$Snap i@173@01)))
          ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@172@01)
            ($SortWrappers.IntTo$Snap i@173@01))))))
    (=>
      (ite
        (and
          (and (img@155@01 x@172@01 i@173@01) (img@157@01 x@172@01 i@173@01))
          (and
            (Set_in (inv@154@01 x@172@01 i@173@01) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x@172@01 i@173@01))))
        (< $Perm.No (- $Perm.Write (pTaken@166@01 x@172@01 i@173@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@172@01)
              ($SortWrappers.IntTo$Snap i@173@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@172@01)
            ($SortWrappers.IntTo$Snap i@173@01)))
          ($PSF.lookup_pair $t@153@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@172@01)
            ($SortWrappers.IntTo$Snap i@173@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01)))
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01))) x@172@01 i@173@01)
    (=
      ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@172@01)
        ($SortWrappers.IntTo$Snap i@173@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))))))
    (not (= x@172@01 $Ref.null))
    (addA%precondition $Snap.unit i@173@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01)))
  (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@172@01 $Ref) (i@173@01 Int)) (!
  (and
    (or (Set_in x@172@01 xs@146@01) (not (Set_in x@172@01 xs@146@01)))
    (=>
      (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01))
      (and
        (Set_in x@172@01 xs@146@01)
        (Seq_contains is@147@01 i@173@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01)))
        (=>
          (and (= x@172@01 tx@148@01) (= i@173@01 ti@149@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@172@01)
                  ($SortWrappers.IntTo$Snap i@173@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@172@01)
                ($SortWrappers.IntTo$Snap i@173@01)))
              ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@172@01)
                ($SortWrappers.IntTo$Snap i@173@01))))))
        (=>
          (ite
            (and
              (and (img@155@01 x@172@01 i@173@01) (img@157@01 x@172@01 i@173@01))
              (and
                (Set_in (inv@154@01 x@172@01 i@173@01) xs@146@01)
                (Seq_contains is@147@01 (inv@156@01 x@172@01 i@173@01))))
            (< $Perm.No (- $Perm.Write (pTaken@166@01 x@172@01 i@173@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@172@01)
                  ($SortWrappers.IntTo$Snap i@173@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@172@01)
                ($SortWrappers.IntTo$Snap i@173@01)))
              ($PSF.lookup_pair $t@153@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@172@01)
                ($SortWrappers.IntTo$Snap i@173@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01)))
        ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))) x@172@01 i@173@01)
        (=
          ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@172@01)
            ($SortWrappers.IntTo$Snap i@173@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@172@01)
              ($SortWrappers.IntTo$Snap i@173@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@172@01)
              ($SortWrappers.IntTo$Snap i@173@01))))))
        (not (= x@172@01 $Ref.null))
        (addA%precondition $Snap.unit i@173@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01))))))))
    (or
      (not (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01)))
      (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68-aux|)))
(assert (forall ((x@172@01 $Ref) (i@173@01 Int)) (!
  (=>
    (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01))
    (addA%precondition $Snap.unit i@173@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@172@01)
      ($SortWrappers.IntTo$Snap i@173@01)))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68_precondition|)))
(push) ; 3
(assert (not (forall ((x@172@01 $Ref) (i@173@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01))
        (addA%precondition $Snap.unit i@173@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@172@01)
          ($SortWrappers.IntTo$Snap i@173@01)))))))
      (and (Set_in x@172@01 xs@146@01) (Seq_contains is@147@01 i@173@01)))
    (<
      0
      (addA $Snap.unit i@173@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@172@01)
        ($SortWrappers.IntTo$Snap i@173@01))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@172@01)
    ($SortWrappers.IntTo$Snap i@173@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@176@01 $Ref)
(declare-const i@177@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 37 | !(x@176@01 in xs@146@01) | live]
; [else-branch: 37 | x@176@01 in xs@146@01 | live]
(push) ; 5
; [then-branch: 37 | !(x@176@01 in xs@146@01)]
(assert (not (Set_in x@176@01 xs@146@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 37 | x@176@01 in xs@146@01]
(assert (Set_in x@176@01 xs@146@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@176@01 xs@146@01) (not (Set_in x@176@01 xs@146@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 38 | x@176@01 in xs@146@01 && i@177@01 in is@147@01 | live]
; [else-branch: 38 | !(x@176@01 in xs@146@01 && i@177@01 in is@147@01) | live]
(push) ; 5
; [then-branch: 38 | x@176@01 in xs@146@01 && i@177@01 in is@147@01]
(assert (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(set-option :timeout 0)
(push) ; 6
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@176@01)
  ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@176@01)
  ($SortWrappers.IntTo$Snap i@177@01))))
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@148@01 x@176@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@178@01 ((x $Ref) (i Int) (x@176@01 $Ref) (i@177@01 Int)) $Perm
  (ite
    (and (= x x@176@01) (= i i@177@01))
    ($Perm.min
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        (- $Perm.Write (pTaken@166@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@179@01 ((x $Ref) (i Int) (x@176@01 $Ref) (i@177@01 Int)) $Perm
  (ite
    (and (= x x@176@01) (= i i@177@01))
    ($Perm.min
      (ite (and (= x tx@148@01) (= i ti@149@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@178@01 x i x@176@01 i@177@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        (- $Perm.Write (pTaken@166@01 x i))
        $Perm.No)
      (pTaken@178@01 x i x@176@01 i@177@01))
    $Perm.No)
  
  :qid |quant-u-5121|))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@178@01 x i x@176@01 i@177@01) $Perm.No)
  
  :qid |quant-u-5122|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@176@01) (= i i@177@01))
    (= (- $Perm.Write (pTaken@178@01 x i x@176@01 i@177@01)) $Perm.No))
  
  :qid |quant-u-5123|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@179@01 tx@148@01 ti@149@01 x@176@01 i@177@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@179@01 x i x@176@01 i@177@01) $Perm.No)
  
  :qid |quant-u-5125|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@176@01) (= i i@177@01))
    (=
      (-
        (- $Perm.Write (pTaken@178@01 x i x@176@01 i@177@01))
        (pTaken@179@01 x i x@176@01 i@177@01))
      $Perm.No))
  
  :qid |quant-u-5126|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@176@01 tx@148@01) (= i@177@01 ti@149@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@176@01)
        ($SortWrappers.IntTo$Snap i@177@01)))
      ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@176@01)
        ($SortWrappers.IntTo$Snap i@177@01)))))))
(assert (=>
  (ite
    (and
      (and (img@155@01 x@176@01 i@177@01) (img@157@01 x@176@01 i@177@01))
      (and
        (Set_in (inv@154@01 x@176@01 i@177@01) xs@146@01)
        (Seq_contains is@147@01 (inv@156@01 x@176@01 i@177@01))))
    (< $Perm.No (- $Perm.Write (pTaken@166@01 x@176@01 i@177@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@176@01)
        ($SortWrappers.IntTo$Snap i@177@01)))
      ($PSF.lookup_pair $t@153@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@176@01)
        ($SortWrappers.IntTo$Snap i@177@01)))))))
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01)))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@176@01)
  ($SortWrappers.IntTo$Snap i@177@01))) x@176@01 i@177@01))
(assert (=
  ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01)))))))
(assert (not (= x@176@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 6
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01)))
  (=>
    (and (= x@176@01 tx@148@01) (= i@177@01 ti@149@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@176@01)
            ($SortWrappers.IntTo$Snap i@177@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01)))
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))))))
  (=>
    (ite
      (and
        (and (img@155@01 x@176@01 i@177@01) (img@157@01 x@176@01 i@177@01))
        (and
          (Set_in (inv@154@01 x@176@01 i@177@01) xs@146@01)
          (Seq_contains is@147@01 (inv@156@01 x@176@01 i@177@01))))
      (< $Perm.No (- $Perm.Write (pTaken@166@01 x@176@01 i@177@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@176@01)
            ($SortWrappers.IntTo$Snap i@177@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01)))
        ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))) x@176@01 i@177@01)
  (=
    ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@176@01)
        ($SortWrappers.IntTo$Snap i@177@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@176@01)
        ($SortWrappers.IntTo$Snap i@177@01))))))
  (not (= x@176@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@177@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@176@01)
  ($SortWrappers.IntTo$Snap i@177@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@177@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@176@01)
  ($SortWrappers.IntTo$Snap i@177@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 38 | !(x@176@01 in xs@146@01 && i@177@01 in is@147@01)]
(assert (not (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01))
  (and
    (Set_in x@176@01 xs@146@01)
    (Seq_contains is@147@01 i@177@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01)))
    (=>
      (and (= x@176@01 tx@148@01) (= i@177@01 ti@149@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@176@01)
              ($SortWrappers.IntTo$Snap i@177@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@176@01)
            ($SortWrappers.IntTo$Snap i@177@01)))
          ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@176@01)
            ($SortWrappers.IntTo$Snap i@177@01))))))
    (=>
      (ite
        (and
          (and (img@155@01 x@176@01 i@177@01) (img@157@01 x@176@01 i@177@01))
          (and
            (Set_in (inv@154@01 x@176@01 i@177@01) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x@176@01 i@177@01))))
        (< $Perm.No (- $Perm.Write (pTaken@166@01 x@176@01 i@177@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@176@01)
              ($SortWrappers.IntTo$Snap i@177@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@176@01)
            ($SortWrappers.IntTo$Snap i@177@01)))
          ($PSF.lookup_pair $t@153@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@176@01)
            ($SortWrappers.IntTo$Snap i@177@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01)))
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01))) x@176@01 i@177@01)
    (=
      ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@176@01)
        ($SortWrappers.IntTo$Snap i@177@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))))))
    (not (= x@176@01 $Ref.null))
    (addA%precondition $Snap.unit i@177@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01)))
  (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01))))
(declare-const sm@180@01 $PSF<pair>)
(declare-const s@181@01 $Snap)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((s@181@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@155@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) ($SortWrappers.$SnapToInt ($Snap.second s@181@01)))
          (img@157@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) ($SortWrappers.$SnapToInt ($Snap.second s@181@01))))
        (and
          (Set_in (inv@154@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) ($SortWrappers.$SnapToInt ($Snap.second s@181@01))) xs@146@01)
          (Seq_contains
            is@147@01
            (inv@156@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) ($SortWrappers.$SnapToInt ($Snap.second s@181@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@166@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) ($SortWrappers.$SnapToInt ($Snap.second s@181@01)))))
      false)
    (and
      (not (= s@181@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@180@01  $PSF<pair>) s@181@01)
        ($PSF.lookup_pair $t@153@01 s@181@01))))
  :pattern (($PSF.lookup_pair (as sm@180@01  $PSF<pair>) s@181@01))
  :pattern (($PSF.lookup_pair $t@153@01 s@181@01))
  :qid |qp.psmValDef21|)))
(assert (forall ((s@181@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) tx@148@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@181@01)) ti@149@01))
    (and
      (not (= s@181@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@180@01  $PSF<pair>) s@181@01)
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@181@01))))
  :pattern (($PSF.lookup_pair (as sm@180@01  $PSF<pair>) s@181@01))
  :pattern (($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@181@01))
  :qid |qp.psmValDef22|)))
(assert (forall ((s@181@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 s@181@01) s@181@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@181@01) s@181@01))
  :pattern (($PSF.lookup_pair (as sm@180@01  $PSF<pair>) s@181@01))
  :qid |qp.psmResTrgDef23|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((s@181@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@155@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) ($SortWrappers.$SnapToInt ($Snap.second s@181@01)))
          (img@157@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) ($SortWrappers.$SnapToInt ($Snap.second s@181@01))))
        (and
          (Set_in (inv@154@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) ($SortWrappers.$SnapToInt ($Snap.second s@181@01))) xs@146@01)
          (Seq_contains
            is@147@01
            (inv@156@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) ($SortWrappers.$SnapToInt ($Snap.second s@181@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@166@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) ($SortWrappers.$SnapToInt ($Snap.second s@181@01)))))
      false)
    (and
      (not (= s@181@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@180@01  $PSF<pair>) s@181@01)
        ($PSF.lookup_pair $t@153@01 s@181@01))))
  :pattern (($PSF.lookup_pair (as sm@180@01  $PSF<pair>) s@181@01))
  :pattern (($PSF.lookup_pair $t@153@01 s@181@01))
  :qid |qp.psmValDef21|)))
(assert (forall ((s@181@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@181@01)) tx@148@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@181@01)) ti@149@01))
    (and
      (not (= s@181@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@180@01  $PSF<pair>) s@181@01)
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@181@01))))
  :pattern (($PSF.lookup_pair (as sm@180@01  $PSF<pair>) s@181@01))
  :pattern (($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@181@01))
  :qid |qp.psmValDef22|)))
(assert (forall ((s@181@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 s@181@01) s@181@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@181@01) s@181@01))
  :pattern (($PSF.lookup_pair (as sm@180@01  $PSF<pair>) s@181@01))
  :qid |qp.psmResTrgDef23|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@176@01 $Ref) (i@177@01 Int)) (!
  (and
    (or (Set_in x@176@01 xs@146@01) (not (Set_in x@176@01 xs@146@01)))
    (=>
      (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01))
      (and
        (Set_in x@176@01 xs@146@01)
        (Seq_contains is@147@01 i@177@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01)))
        (=>
          (and (= x@176@01 tx@148@01) (= i@177@01 ti@149@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@176@01)
                  ($SortWrappers.IntTo$Snap i@177@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@176@01)
                ($SortWrappers.IntTo$Snap i@177@01)))
              ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@176@01)
                ($SortWrappers.IntTo$Snap i@177@01))))))
        (=>
          (ite
            (and
              (and (img@155@01 x@176@01 i@177@01) (img@157@01 x@176@01 i@177@01))
              (and
                (Set_in (inv@154@01 x@176@01 i@177@01) xs@146@01)
                (Seq_contains is@147@01 (inv@156@01 x@176@01 i@177@01))))
            (< $Perm.No (- $Perm.Write (pTaken@166@01 x@176@01 i@177@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@176@01)
                  ($SortWrappers.IntTo$Snap i@177@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@176@01)
                ($SortWrappers.IntTo$Snap i@177@01)))
              ($PSF.lookup_pair $t@153@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@176@01)
                ($SortWrappers.IntTo$Snap i@177@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01)))
        ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))) x@176@01 i@177@01)
        (=
          ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@176@01)
            ($SortWrappers.IntTo$Snap i@177@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@176@01)
              ($SortWrappers.IntTo$Snap i@177@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@176@01)
              ($SortWrappers.IntTo$Snap i@177@01))))))
        (not (= x@176@01 $Ref.null))
        (addA%precondition $Snap.unit i@177@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01))))))))
    (or
      (not (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01)))
      (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@180@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68-aux|)))
(assert (forall ((x@176@01 $Ref) (i@177@01 Int)) (!
  (=>
    (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01))
    (addA%precondition $Snap.unit i@177@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@176@01)
      ($SortWrappers.IntTo$Snap i@177@01)))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@180@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@176@01 $Ref) (i@177@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01))
        (addA%precondition $Snap.unit i@177@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@176@01)
          ($SortWrappers.IntTo$Snap i@177@01)))))))
      (and (Set_in x@176@01 xs@146@01) (Seq_contains is@147@01 i@177@01)))
    (<
      0
      (addA $Snap.unit i@177@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@176@01)
        ($SortWrappers.IntTo$Snap i@177@01))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@180@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@176@01)
    ($SortWrappers.IntTo$Snap i@177@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@182@01 $Ref)
(declare-const i@183@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 39 | !(x@182@01 in xs@146@01) | live]
; [else-branch: 39 | x@182@01 in xs@146@01 | live]
(push) ; 5
; [then-branch: 39 | !(x@182@01 in xs@146@01)]
(assert (not (Set_in x@182@01 xs@146@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 39 | x@182@01 in xs@146@01]
(assert (Set_in x@182@01 xs@146@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@182@01 xs@146@01) (not (Set_in x@182@01 xs@146@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 40 | x@182@01 in xs@146@01 && i@183@01 in is@147@01 | live]
; [else-branch: 40 | !(x@182@01 in xs@146@01 && i@183@01 in is@147@01) | live]
(push) ; 5
; [then-branch: 40 | x@182@01 in xs@146@01 && i@183@01 in is@147@01]
(assert (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(set-option :timeout 0)
(push) ; 6
(declare-const sm@184@01 $PSF<pair>)
(declare-const s@185@01 $Snap)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((s@185@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@155@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01)))
          (img@157@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))))
        (and
          (Set_in (inv@154@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))) xs@146@01)
          (Seq_contains
            is@147@01
            (inv@156@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@166@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01)))))
      false)
    (and
      (not (= s@185@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01)
        ($PSF.lookup_pair $t@153@01 s@185@01))))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :pattern (($PSF.lookup_pair $t@153@01 s@185@01))
  :qid |qp.psmValDef24|)))
(assert (forall ((s@185@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) tx@148@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@185@01)) ti@149@01))
    (and
      (not (= s@185@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01)
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01))))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :pattern (($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01))
  :qid |qp.psmValDef25|)))
(assert (forall ((s@185@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 s@185@01) s@185@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01) s@185@01))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :qid |qp.psmResTrgDef26|)))
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@182@01)
  ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@182@01)
  ($SortWrappers.IntTo$Snap i@183@01))))
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@148@01 x@182@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@186@01 ((x $Ref) (i Int) (x@182@01 $Ref) (i@183@01 Int)) $Perm
  (ite
    (and (= x x@182@01) (= i i@183@01))
    ($Perm.min
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        (- $Perm.Write (pTaken@166@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@187@01 ((x $Ref) (i Int) (x@182@01 $Ref) (i@183@01 Int)) $Perm
  (ite
    (and (= x x@182@01) (= i i@183@01))
    ($Perm.min
      (ite (and (= x tx@148@01) (= i ti@149@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@186@01 x i x@182@01 i@183@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        (- $Perm.Write (pTaken@166@01 x i))
        $Perm.No)
      (pTaken@186@01 x i x@182@01 i@183@01))
    $Perm.No)
  
  :qid |quant-u-5128|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@186@01 x i x@182@01 i@183@01) $Perm.No)
  
  :qid |quant-u-5129|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@182@01) (= i i@183@01))
    (= (- $Perm.Write (pTaken@186@01 x i x@182@01 i@183@01)) $Perm.No))
  
  :qid |quant-u-5130|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@187@01 tx@148@01 ti@149@01 x@182@01 i@183@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@187@01 x i x@182@01 i@183@01) $Perm.No)
  
  :qid |quant-u-5132|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@182@01) (= i i@183@01))
    (=
      (-
        (- $Perm.Write (pTaken@186@01 x i x@182@01 i@183@01))
        (pTaken@187@01 x i x@182@01 i@183@01))
      $Perm.No))
  
  :qid |quant-u-5133|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (ite
    (and
      (and (img@155@01 x@182@01 i@183@01) (img@157@01 x@182@01 i@183@01))
      (and
        (Set_in (inv@154@01 x@182@01 i@183@01) xs@146@01)
        (Seq_contains is@147@01 (inv@156@01 x@182@01 i@183@01))))
    (< $Perm.No (- $Perm.Write (pTaken@166@01 x@182@01 i@183@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@182@01)
        ($SortWrappers.IntTo$Snap i@183@01)))
      ($PSF.lookup_pair $t@153@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@182@01)
        ($SortWrappers.IntTo$Snap i@183@01)))))))
(assert (=>
  (and (= x@182@01 tx@148@01) (= i@183@01 ti@149@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@182@01)
        ($SortWrappers.IntTo$Snap i@183@01)))
      ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@182@01)
        ($SortWrappers.IntTo$Snap i@183@01)))))))
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01)))
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01)))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@182@01)
  ($SortWrappers.IntTo$Snap i@183@01))) x@182@01 i@183@01))
(assert (=
  ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01)))))))
(assert (not (= x@182@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 6
; Joined path conditions
(assert (forall ((s@185@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@155@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01)))
          (img@157@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))))
        (and
          (Set_in (inv@154@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))) xs@146@01)
          (Seq_contains
            is@147@01
            (inv@156@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@166@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01)))))
      false)
    (and
      (not (= s@185@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01)
        ($PSF.lookup_pair $t@153@01 s@185@01))))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :pattern (($PSF.lookup_pair $t@153@01 s@185@01))
  :qid |qp.psmValDef24|)))
(assert (forall ((s@185@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) tx@148@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@185@01)) ti@149@01))
    (and
      (not (= s@185@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01)
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01))))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :pattern (($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01))
  :qid |qp.psmValDef25|)))
(assert (forall ((s@185@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 s@185@01) s@185@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01) s@185@01))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :qid |qp.psmResTrgDef26|)))
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01)))
  (=>
    (ite
      (and
        (and (img@155@01 x@182@01 i@183@01) (img@157@01 x@182@01 i@183@01))
        (and
          (Set_in (inv@154@01 x@182@01 i@183@01) xs@146@01)
          (Seq_contains is@147@01 (inv@156@01 x@182@01 i@183@01))))
      (< $Perm.No (- $Perm.Write (pTaken@166@01 x@182@01 i@183@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@182@01)
            ($SortWrappers.IntTo$Snap i@183@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01)))
        ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))))))
  (=>
    (and (= x@182@01 tx@148@01) (= i@183@01 ti@149@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@182@01)
            ($SortWrappers.IntTo$Snap i@183@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01)))
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01)))
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))) x@182@01 i@183@01)
  (=
    ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@182@01)
        ($SortWrappers.IntTo$Snap i@183@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@182@01)
        ($SortWrappers.IntTo$Snap i@183@01))))))
  (not (= x@182@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@183@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@182@01)
  ($SortWrappers.IntTo$Snap i@183@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@183@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@182@01)
  ($SortWrappers.IntTo$Snap i@183@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 40 | !(x@182@01 in xs@146@01 && i@183@01 in is@147@01)]
(assert (not (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (forall ((s@185@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@155@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01)))
          (img@157@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))))
        (and
          (Set_in (inv@154@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))) xs@146@01)
          (Seq_contains
            is@147@01
            (inv@156@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@166@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01)))))
      false)
    (and
      (not (= s@185@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01)
        ($PSF.lookup_pair $t@153@01 s@185@01))))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :pattern (($PSF.lookup_pair $t@153@01 s@185@01))
  :qid |qp.psmValDef24|)))
(assert (forall ((s@185@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) tx@148@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@185@01)) ti@149@01))
    (and
      (not (= s@185@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01)
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01))))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :pattern (($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01))
  :qid |qp.psmValDef25|)))
(assert (forall ((s@185@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 s@185@01) s@185@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01) s@185@01))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :qid |qp.psmResTrgDef26|)))
(assert (=>
  (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01))
  (and
    (Set_in x@182@01 xs@146@01)
    (Seq_contains is@147@01 i@183@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01)))
    (=>
      (ite
        (and
          (and (img@155@01 x@182@01 i@183@01) (img@157@01 x@182@01 i@183@01))
          (and
            (Set_in (inv@154@01 x@182@01 i@183@01) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x@182@01 i@183@01))))
        (< $Perm.No (- $Perm.Write (pTaken@166@01 x@182@01 i@183@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@182@01)
              ($SortWrappers.IntTo$Snap i@183@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@182@01)
            ($SortWrappers.IntTo$Snap i@183@01)))
          ($PSF.lookup_pair $t@153@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@182@01)
            ($SortWrappers.IntTo$Snap i@183@01))))))
    (=>
      (and (= x@182@01 tx@148@01) (= i@183@01 ti@149@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@182@01)
              ($SortWrappers.IntTo$Snap i@183@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@182@01)
            ($SortWrappers.IntTo$Snap i@183@01)))
          ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@182@01)
            ($SortWrappers.IntTo$Snap i@183@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01)))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01))) x@182@01 i@183@01)
    (=
      ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@182@01)
        ($SortWrappers.IntTo$Snap i@183@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))))))
    (not (= x@182@01 $Ref.null))
    (addA%precondition $Snap.unit i@183@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01)))
  (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((s@185@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@155@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01)))
          (img@157@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))))
        (and
          (Set_in (inv@154@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))) xs@146@01)
          (Seq_contains
            is@147@01
            (inv@156@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@166@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) ($SortWrappers.$SnapToInt ($Snap.second s@185@01)))))
      false)
    (and
      (not (= s@185@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01)
        ($PSF.lookup_pair $t@153@01 s@185@01))))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :pattern (($PSF.lookup_pair $t@153@01 s@185@01))
  :qid |qp.psmValDef24|)))
(assert (forall ((s@185@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@185@01)) tx@148@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@185@01)) ti@149@01))
    (and
      (not (= s@185@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01)
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01))))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :pattern (($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01))
  :qid |qp.psmValDef25|)))
(assert (forall ((s@185@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 s@185@01) s@185@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@185@01) s@185@01))
  :pattern (($PSF.lookup_pair (as sm@184@01  $PSF<pair>) s@185@01))
  :qid |qp.psmResTrgDef26|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@182@01 $Ref) (i@183@01 Int)) (!
  (and
    (or (Set_in x@182@01 xs@146@01) (not (Set_in x@182@01 xs@146@01)))
    (=>
      (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01))
      (and
        (Set_in x@182@01 xs@146@01)
        (Seq_contains is@147@01 i@183@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01)))
        (=>
          (ite
            (and
              (and (img@155@01 x@182@01 i@183@01) (img@157@01 x@182@01 i@183@01))
              (and
                (Set_in (inv@154@01 x@182@01 i@183@01) xs@146@01)
                (Seq_contains is@147@01 (inv@156@01 x@182@01 i@183@01))))
            (< $Perm.No (- $Perm.Write (pTaken@166@01 x@182@01 i@183@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@182@01)
                  ($SortWrappers.IntTo$Snap i@183@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@182@01)
                ($SortWrappers.IntTo$Snap i@183@01)))
              ($PSF.lookup_pair $t@153@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@182@01)
                ($SortWrappers.IntTo$Snap i@183@01))))))
        (=>
          (and (= x@182@01 tx@148@01) (= i@183@01 ti@149@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@182@01)
                  ($SortWrappers.IntTo$Snap i@183@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@182@01)
                ($SortWrappers.IntTo$Snap i@183@01)))
              ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@182@01)
                ($SortWrappers.IntTo$Snap i@183@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01)))
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))) x@182@01 i@183@01)
        (=
          ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@182@01)
            ($SortWrappers.IntTo$Snap i@183@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@182@01)
              ($SortWrappers.IntTo$Snap i@183@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@182@01)
              ($SortWrappers.IntTo$Snap i@183@01))))))
        (not (= x@182@01 $Ref.null))
        (addA%precondition $Snap.unit i@183@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01))))))))
    (or
      (not (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01)))
      (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68-aux|)))
(assert (forall ((x@182@01 $Ref) (i@183@01 Int)) (!
  (=>
    (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01))
    (addA%precondition $Snap.unit i@183@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@182@01)
      ($SortWrappers.IntTo$Snap i@183@01)))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@182@01 $Ref) (i@183@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01))
        (addA%precondition $Snap.unit i@183@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@182@01)
          ($SortWrappers.IntTo$Snap i@183@01)))))))
      (and (Set_in x@182@01 xs@146@01) (Seq_contains is@147@01 i@183@01)))
    (<
      0
      (addA $Snap.unit i@183@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@184@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@182@01)
        ($SortWrappers.IntTo$Snap i@183@01))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@182@01)
    ($SortWrappers.IntTo$Snap i@183@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)))
(declare-const x@188@01 $Ref)
(declare-const i@189@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 41 | !(x@188@01 in xs@146@01) | live]
; [else-branch: 41 | x@188@01 in xs@146@01 | live]
(push) ; 5
; [then-branch: 41 | !(x@188@01 in xs@146@01)]
(assert (not (Set_in x@188@01 xs@146@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 41 | x@188@01 in xs@146@01]
(assert (Set_in x@188@01 xs@146@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@188@01 xs@146@01) (not (Set_in x@188@01 xs@146@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 42 | x@188@01 in xs@146@01 && i@189@01 in is@147@01 | live]
; [else-branch: 42 | !(x@188@01 in xs@146@01 && i@189@01 in is@147@01) | live]
(push) ; 5
; [then-branch: 42 | x@188@01 in xs@146@01 && i@189@01 in is@147@01]
(assert (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(set-option :timeout 0)
(push) ; 6
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@188@01)
  ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@188@01)
  ($SortWrappers.IntTo$Snap i@189@01))))
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@148@01 x@188@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@190@01 ((x $Ref) (i Int) (x@188@01 $Ref) (i@189@01 Int)) $Perm
  (ite
    (and (= x x@188@01) (= i i@189@01))
    ($Perm.min
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        (- $Perm.Write (pTaken@166@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@191@01 ((x $Ref) (i Int) (x@188@01 $Ref) (i@189@01 Int)) $Perm
  (ite
    (and (= x x@188@01) (= i i@189@01))
    ($Perm.min
      (ite (and (= x tx@148@01) (= i ti@149@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@190@01 x i x@188@01 i@189@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@155@01 x i) (img@157@01 x i))
          (and
            (Set_in (inv@154@01 x i) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x i))))
        (- $Perm.Write (pTaken@166@01 x i))
        $Perm.No)
      (pTaken@190@01 x i x@188@01 i@189@01))
    $Perm.No)
  
  :qid |quant-u-5135|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@190@01 x i x@188@01 i@189@01) $Perm.No)
  
  :qid |quant-u-5136|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@188@01) (= i i@189@01))
    (= (- $Perm.Write (pTaken@190@01 x i x@188@01 i@189@01)) $Perm.No))
  
  :qid |quant-u-5137|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@191@01 tx@148@01 ti@149@01 x@188@01 i@189@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@191@01 x i x@188@01 i@189@01) $Perm.No)
  
  :qid |quant-u-5139|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@188@01) (= i i@189@01))
    (=
      (-
        (- $Perm.Write (pTaken@190@01 x i x@188@01 i@189@01))
        (pTaken@191@01 x i x@188@01 i@189@01))
      $Perm.No))
  
  :qid |quant-u-5140|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@188@01 tx@148@01) (= i@189@01 ti@149@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@188@01)
        ($SortWrappers.IntTo$Snap i@189@01)))
      ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@188@01)
        ($SortWrappers.IntTo$Snap i@189@01)))))))
(assert (=>
  (ite
    (and
      (and (img@155@01 x@188@01 i@189@01) (img@157@01 x@188@01 i@189@01))
      (and
        (Set_in (inv@154@01 x@188@01 i@189@01) xs@146@01)
        (Seq_contains is@147@01 (inv@156@01 x@188@01 i@189@01))))
    (< $Perm.No (- $Perm.Write (pTaken@166@01 x@188@01 i@189@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@188@01)
        ($SortWrappers.IntTo$Snap i@189@01)))
      ($PSF.lookup_pair $t@153@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@188@01)
        ($SortWrappers.IntTo$Snap i@189@01)))))))
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01)))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@188@01)
  ($SortWrappers.IntTo$Snap i@189@01))) x@188@01 i@189@01))
(assert (=
  ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01)))))))
(assert (not (= x@188@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 6
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01)))
  (=>
    (and (= x@188@01 tx@148@01) (= i@189@01 ti@149@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@188@01)
            ($SortWrappers.IntTo$Snap i@189@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01)))
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))))))
  (=>
    (ite
      (and
        (and (img@155@01 x@188@01 i@189@01) (img@157@01 x@188@01 i@189@01))
        (and
          (Set_in (inv@154@01 x@188@01 i@189@01) xs@146@01)
          (Seq_contains is@147@01 (inv@156@01 x@188@01 i@189@01))))
      (< $Perm.No (- $Perm.Write (pTaken@166@01 x@188@01 i@189@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@188@01)
            ($SortWrappers.IntTo$Snap i@189@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01)))
        ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))) x@188@01 i@189@01)
  (=
    ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@188@01)
        ($SortWrappers.IntTo$Snap i@189@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@188@01)
        ($SortWrappers.IntTo$Snap i@189@01))))))
  (not (= x@188@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@189@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@188@01)
  ($SortWrappers.IntTo$Snap i@189@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@189@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@188@01)
  ($SortWrappers.IntTo$Snap i@189@01)))))))
(pop) ; 5
(push) ; 5
; [else-branch: 42 | !(x@188@01 in xs@146@01 && i@189@01 in is@147@01)]
(assert (not (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01))
  (and
    (Set_in x@188@01 xs@146@01)
    (Seq_contains is@147@01 i@189@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01)))
    (=>
      (and (= x@188@01 tx@148@01) (= i@189@01 ti@149@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@188@01)
              ($SortWrappers.IntTo$Snap i@189@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@188@01)
            ($SortWrappers.IntTo$Snap i@189@01)))
          ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@188@01)
            ($SortWrappers.IntTo$Snap i@189@01))))))
    (=>
      (ite
        (and
          (and (img@155@01 x@188@01 i@189@01) (img@157@01 x@188@01 i@189@01))
          (and
            (Set_in (inv@154@01 x@188@01 i@189@01) xs@146@01)
            (Seq_contains is@147@01 (inv@156@01 x@188@01 i@189@01))))
        (< $Perm.No (- $Perm.Write (pTaken@166@01 x@188@01 i@189@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@188@01)
              ($SortWrappers.IntTo$Snap i@189@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@188@01)
            ($SortWrappers.IntTo$Snap i@189@01)))
          ($PSF.lookup_pair $t@153@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@188@01)
            ($SortWrappers.IntTo$Snap i@189@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01)))
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01))) x@188@01 i@189@01)
    (=
      ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@188@01)
        ($SortWrappers.IntTo$Snap i@189@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))))))
    (not (= x@188@01 $Ref.null))
    (addA%precondition $Snap.unit i@189@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01)))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01)))
  (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01))))
(declare-const sm@192@01 $PSF<pair>)
(declare-const s@193@01 $Snap)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((s@193@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@155@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) ($SortWrappers.$SnapToInt ($Snap.second s@193@01)))
          (img@157@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) ($SortWrappers.$SnapToInt ($Snap.second s@193@01))))
        (and
          (Set_in (inv@154@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) ($SortWrappers.$SnapToInt ($Snap.second s@193@01))) xs@146@01)
          (Seq_contains
            is@147@01
            (inv@156@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) ($SortWrappers.$SnapToInt ($Snap.second s@193@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@166@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) ($SortWrappers.$SnapToInt ($Snap.second s@193@01)))))
      false)
    (and
      (not (= s@193@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@192@01  $PSF<pair>) s@193@01)
        ($PSF.lookup_pair $t@153@01 s@193@01))))
  :pattern (($PSF.lookup_pair (as sm@192@01  $PSF<pair>) s@193@01))
  :pattern (($PSF.lookup_pair $t@153@01 s@193@01))
  :qid |qp.psmValDef27|)))
(assert (forall ((s@193@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) tx@148@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@193@01)) ti@149@01))
    (and
      (not (= s@193@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@192@01  $PSF<pair>) s@193@01)
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@193@01))))
  :pattern (($PSF.lookup_pair (as sm@192@01  $PSF<pair>) s@193@01))
  :pattern (($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@193@01))
  :qid |qp.psmValDef28|)))
(assert (forall ((s@193@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 s@193@01) s@193@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@193@01) s@193@01))
  :pattern (($PSF.lookup_pair (as sm@192@01  $PSF<pair>) s@193@01))
  :qid |qp.psmResTrgDef29|)))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
(assert (forall ((s@193@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@155@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) ($SortWrappers.$SnapToInt ($Snap.second s@193@01)))
          (img@157@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) ($SortWrappers.$SnapToInt ($Snap.second s@193@01))))
        (and
          (Set_in (inv@154@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) ($SortWrappers.$SnapToInt ($Snap.second s@193@01))) xs@146@01)
          (Seq_contains
            is@147@01
            (inv@156@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) ($SortWrappers.$SnapToInt ($Snap.second s@193@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@166@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) ($SortWrappers.$SnapToInt ($Snap.second s@193@01)))))
      false)
    (and
      (not (= s@193@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@192@01  $PSF<pair>) s@193@01)
        ($PSF.lookup_pair $t@153@01 s@193@01))))
  :pattern (($PSF.lookup_pair (as sm@192@01  $PSF<pair>) s@193@01))
  :pattern (($PSF.lookup_pair $t@153@01 s@193@01))
  :qid |qp.psmValDef27|)))
(assert (forall ((s@193@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@193@01)) tx@148@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@193@01)) ti@149@01))
    (and
      (not (= s@193@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@192@01  $PSF<pair>) s@193@01)
        ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@193@01))))
  :pattern (($PSF.lookup_pair (as sm@192@01  $PSF<pair>) s@193@01))
  :pattern (($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@193@01))
  :qid |qp.psmValDef28|)))
(assert (forall ((s@193@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 s@193@01) s@193@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) s@193@01) s@193@01))
  :pattern (($PSF.lookup_pair (as sm@192@01  $PSF<pair>) s@193@01))
  :qid |qp.psmResTrgDef29|)))
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@188@01 $Ref) (i@189@01 Int)) (!
  (and
    (or (Set_in x@188@01 xs@146@01) (not (Set_in x@188@01 xs@146@01)))
    (=>
      (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01))
      (and
        (Set_in x@188@01 xs@146@01)
        (Seq_contains is@147@01 i@189@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01)))
        (=>
          (and (= x@188@01 tx@148@01) (= i@189@01 ti@149@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@188@01)
                  ($SortWrappers.IntTo$Snap i@189@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@188@01)
                ($SortWrappers.IntTo$Snap i@189@01)))
              ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@188@01)
                ($SortWrappers.IntTo$Snap i@189@01))))))
        (=>
          (ite
            (and
              (and (img@155@01 x@188@01 i@189@01) (img@157@01 x@188@01 i@189@01))
              (and
                (Set_in (inv@154@01 x@188@01 i@189@01) xs@146@01)
                (Seq_contains is@147@01 (inv@156@01 x@188@01 i@189@01))))
            (< $Perm.No (- $Perm.Write (pTaken@166@01 x@188@01 i@189@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@188@01)
                  ($SortWrappers.IntTo$Snap i@189@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@188@01)
                ($SortWrappers.IntTo$Snap i@189@01)))
              ($PSF.lookup_pair $t@153@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@188@01)
                ($SortWrappers.IntTo$Snap i@189@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@169@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01)))
        ($PSF.loc_pair ($PSF.lookup_pair $t@153@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))) x@188@01 i@189@01)
        (=
          ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@188@01)
            ($SortWrappers.IntTo$Snap i@189@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@188@01)
              ($SortWrappers.IntTo$Snap i@189@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@188@01)
              ($SortWrappers.IntTo$Snap i@189@01))))))
        (not (= x@188@01 $Ref.null))
        (addA%precondition $Snap.unit i@189@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01))))))))
    (or
      (not (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01)))
      (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@192@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68-aux|)))
(assert (forall ((x@188@01 $Ref) (i@189@01 Int)) (!
  (=>
    (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01))
    (addA%precondition $Snap.unit i@189@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@188@01)
      ($SortWrappers.IntTo$Snap i@189@01)))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@192@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@188@01 $Ref) (i@189@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01))
        (addA%precondition $Snap.unit i@189@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@188@01)
          ($SortWrappers.IntTo$Snap i@189@01)))))))
      (and (Set_in x@188@01 xs@146@01) (Seq_contains is@147@01 i@189@01)))
    (<
      0
      (addA $Snap.unit i@189@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@170@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@188@01)
        ($SortWrappers.IntTo$Snap i@189@01))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@192@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@188@01)
    ($SortWrappers.IntTo$Snap i@189@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@99@10@100@68|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(pop) ; 2
(pop) ; 1
; ---------- test02c ----------
(declare-const xs@194@01 Set<$Ref>)
(declare-const is@195@01 Seq<Int>)
(declare-const xs@196@01 Set<$Ref>)
(declare-const is@197@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var tx: Ref
(declare-const tx@198@01 $Ref)
; [exec]
; var ti: Int
(declare-const ti@199@01 Int)
; [exec]
; var tmp: Int
(declare-const tmp@200@01 Int)
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@201@01 $Ref)
(declare-const i@202@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 43 | !(x@201@01 in xs@196@01) | live]
; [else-branch: 43 | x@201@01 in xs@196@01 | live]
(push) ; 5
; [then-branch: 43 | !(x@201@01 in xs@196@01)]
(assert (not (Set_in x@201@01 xs@196@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 43 | x@201@01 in xs@196@01]
(assert (Set_in x@201@01 xs@196@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@201@01 xs@196@01) (not (Set_in x@201@01 xs@196@01))))
(assert (and (Set_in x@201@01 xs@196@01) (Seq_contains is@197@01 i@202@01)))
(pop) ; 3
(declare-const $t@203@01 $PSF<pair>)
(declare-fun inv@204@01 ($Ref Int) $Ref)
(declare-fun img@205@01 ($Ref Int) Bool)
(declare-fun inv@206@01 ($Ref Int) Int)
(declare-fun img@207@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@201@01 $Ref) (i@202@01 Int)) (!
  (=>
    (and (Set_in x@201@01 xs@196@01) (Seq_contains is@197@01 i@202@01))
    (or (Set_in x@201@01 xs@196@01) (not (Set_in x@201@01 xs@196@01))))
  :pattern ((Set_in x@201@01 xs@196@01) (Seq_contains is@197@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (Seq_contains_trigger is@197@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (Seq_contains_trigger is@197@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (inv@204@01 x@201@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (inv@206@01 x@201@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (img@205@01 x@201@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (img@207@01 x@201@01 i@202@01))
  :pattern ((Seq_contains is@197@01 i@202@01) (inv@204@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (inv@204@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (inv@204@01 x@201@01 i@202@01))
  :pattern ((Seq_contains is@197@01 i@202@01) (inv@206@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (inv@206@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (inv@206@01 x@201@01 i@202@01))
  :pattern ((Seq_contains is@197@01 i@202@01) (img@205@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (img@205@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (img@205@01 x@201@01 i@202@01))
  :pattern ((Seq_contains is@197@01 i@202@01) (img@207@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (img@207@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (img@207@01 x@201@01 i@202@01))
  :pattern ((inv@204@01 x@201@01 i@202@01))
  :pattern ((inv@206@01 x@201@01 i@202@01))
  :pattern ((img@205@01 x@201@01 i@202@01))
  :pattern ((img@207@01 x@201@01 i@202@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@201@01 $Ref) (i1@202@01 Int) (x2@201@01 $Ref) (i2@202@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@201@01 xs@196@01) (Seq_contains is@197@01 i1@202@01))
      (and (Set_in x2@201@01 xs@196@01) (Seq_contains is@197@01 i2@202@01))
      (and (= x1@201@01 x2@201@01) (= i1@202@01 i2@202@01)))
    (and (= x1@201@01 x2@201@01) (= i1@202@01 i2@202@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@201@01 $Ref) (i@202@01 Int)) (!
  (=>
    (and (Set_in x@201@01 xs@196@01) (Seq_contains is@197@01 i@202@01))
    (and
      (and
        (= (inv@204@01 x@201@01 i@202@01) x@201@01)
        (= (inv@206@01 x@201@01 i@202@01) i@202@01))
      (and (img@205@01 x@201@01 i@202@01) (img@207@01 x@201@01 i@202@01))))
  :pattern ((Set_in x@201@01 xs@196@01) (Seq_contains is@197@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (Seq_contains_trigger is@197@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (Seq_contains_trigger is@197@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (inv@204@01 x@201@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (inv@206@01 x@201@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (img@205@01 x@201@01 i@202@01))
  :pattern ((Set_in x@201@01 xs@196@01) (img@207@01 x@201@01 i@202@01))
  :pattern ((Seq_contains is@197@01 i@202@01) (inv@204@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (inv@204@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (inv@204@01 x@201@01 i@202@01))
  :pattern ((Seq_contains is@197@01 i@202@01) (inv@206@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (inv@206@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (inv@206@01 x@201@01 i@202@01))
  :pattern ((Seq_contains is@197@01 i@202@01) (img@205@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (img@205@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (img@205@01 x@201@01 i@202@01))
  :pattern ((Seq_contains is@197@01 i@202@01) (img@207@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (img@207@01 x@201@01 i@202@01))
  :pattern ((Seq_contains_trigger is@197@01 i@202@01) (img@207@01 x@201@01 i@202@01))
  :pattern ((inv@204@01 x@201@01 i@202@01))
  :pattern ((inv@206@01 x@201@01 i@202@01))
  :pattern ((img@205@01 x@201@01 i@202@01))
  :pattern ((img@207@01 x@201@01 i@202@01))
  :qid |quant-u-5142|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@205@01 x i) (img@207@01 x i))
      (and
        (Set_in (inv@204@01 x i) xs@196@01)
        (Seq_contains is@197@01 (inv@206@01 x i))))
    (and (= (inv@204@01 x i) x) (= (inv@206@01 x i) i)))
  :pattern ((inv@204@01 x i))
  :pattern ((inv@206@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
(declare-const sm@208@01 $PSF<pair>)
(declare-const s@209@01 $Snap)
; Definitional axioms for snapshot map values
(assert (forall ((s@209@01 $Snap)) (!
  (=>
    (and
      (and
        (img@205@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@209@01)) ($SortWrappers.$SnapToInt ($Snap.second s@209@01)))
        (img@207@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@209@01)) ($SortWrappers.$SnapToInt ($Snap.second s@209@01))))
      (and
        (Set_in (inv@204@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@209@01)) ($SortWrappers.$SnapToInt ($Snap.second s@209@01))) xs@196@01)
        (Seq_contains
          is@197@01
          (inv@206@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@209@01)) ($SortWrappers.$SnapToInt ($Snap.second s@209@01))))))
    (and
      (not (= s@209@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) s@209@01)
        ($PSF.lookup_pair $t@203@01 s@209@01))))
  :pattern (($PSF.lookup_pair (as sm@208@01  $PSF<pair>) s@209@01))
  :pattern (($PSF.lookup_pair $t@203@01 s@209@01))
  :qid |qp.psmValDef30|)))
(assert (forall ((s@209@01 $Snap)) (!
  ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 s@209@01) s@209@01)
  :pattern (($PSF.lookup_pair (as sm@208@01  $PSF<pair>) s@209@01))
  :qid |qp.psmResTrgDef31|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (Set_in (inv@204@01 x i) xs@196@01)
      (Seq_contains is@197@01 (inv@206@01 x i)))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x)
      ($SortWrappers.IntTo$Snap i))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x)
      ($SortWrappers.IntTo$Snap i))))
  :pattern ((inv@204@01 x i) (inv@206@01 x i))
  :qid |quant-u-5143|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { pair(x, i) }
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const $t@210@01 $Snap)
(assert (= $t@210@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } { (x in xs), (i in is) } (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const x@211@01 $Ref)
(declare-const i@212@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 44 | !(x@211@01 in xs@196@01) | live]
; [else-branch: 44 | x@211@01 in xs@196@01 | live]
(push) ; 5
; [then-branch: 44 | !(x@211@01 in xs@196@01)]
(assert (not (Set_in x@211@01 xs@196@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 44 | x@211@01 in xs@196@01]
(assert (Set_in x@211@01 xs@196@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@211@01 xs@196@01) (not (Set_in x@211@01 xs@196@01))))
(push) ; 4
; [then-branch: 45 | x@211@01 in xs@196@01 && i@212@01 in is@197@01 | live]
; [else-branch: 45 | !(x@211@01 in xs@196@01 && i@212@01 in is@197@01) | live]
(push) ; 5
; [then-branch: 45 | x@211@01 in xs@196@01 && i@212@01 in is@197@01]
(assert (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01)))
; [eval] 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@211@01)
  ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@211@01)
  ($SortWrappers.IntTo$Snap i@212@01))))
; Precomputing data for removing quantified permissions
(define-fun pTaken@213@01 ((x $Ref) (i Int) (x@211@01 $Ref) (i@212@01 Int)) $Perm
  (ite
    (and (= x x@211@01) (= i i@212@01))
    ($Perm.min
      (ite
        (and
          (and (img@205@01 x i) (img@207@01 x i))
          (and
            (Set_in (inv@204@01 x i) xs@196@01)
            (Seq_contains is@197@01 (inv@206@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@205@01 x i) (img@207@01 x i))
          (and
            (Set_in (inv@204@01 x i) xs@196@01)
            (Seq_contains is@197@01 (inv@206@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@213@01 x i x@211@01 i@212@01))
    $Perm.No)
  
  :qid |quant-u-5145|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@213@01 x i x@211@01 i@212@01) $Perm.No)
  
  :qid |quant-u-5146|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@211@01) (= i i@212@01))
    (= (- $Perm.Write (pTaken@213@01 x i x@211@01 i@212@01)) $Perm.No))
  
  :qid |quant-u-5147|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@205@01 x@211@01 i@212@01) (img@207@01 x@211@01 i@212@01))
    (and
      (Set_in (inv@204@01 x@211@01 i@212@01) xs@196@01)
      (Seq_contains is@197@01 (inv@206@01 x@211@01 i@212@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@211@01)
        ($SortWrappers.IntTo$Snap i@212@01)))
      ($PSF.lookup_pair $t@203@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@211@01)
        ($SortWrappers.IntTo$Snap i@212@01)))))))
(assert ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@211@01)
  ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@211@01)
  ($SortWrappers.IntTo$Snap i@212@01))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@211@01)
  ($SortWrappers.IntTo$Snap i@212@01))) x@211@01 i@212@01))
(assert (=
  ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@211@01)
    ($SortWrappers.IntTo$Snap i@212@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@211@01)
      ($SortWrappers.IntTo$Snap i@212@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@211@01)
      ($SortWrappers.IntTo$Snap i@212@01)))))))
(assert (not (= x@211@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@211@01)
    ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@211@01)
    ($SortWrappers.IntTo$Snap i@212@01)))
  (=>
    (and
      (and (img@205@01 x@211@01 i@212@01) (img@207@01 x@211@01 i@212@01))
      (and
        (Set_in (inv@204@01 x@211@01 i@212@01) xs@196@01)
        (Seq_contains is@197@01 (inv@206@01 x@211@01 i@212@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@211@01)
            ($SortWrappers.IntTo$Snap i@212@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01)))
        ($PSF.lookup_pair $t@203@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@211@01)
    ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@211@01)
    ($SortWrappers.IntTo$Snap i@212@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@211@01)
    ($SortWrappers.IntTo$Snap i@212@01))) x@211@01 i@212@01)
  (=
    ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@211@01)
      ($SortWrappers.IntTo$Snap i@212@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@211@01)
        ($SortWrappers.IntTo$Snap i@212@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@211@01)
        ($SortWrappers.IntTo$Snap i@212@01))))))
  (not (= x@211@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@211@01)
  ($SortWrappers.IntTo$Snap i@212@01))))) i@212@01))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@211@01)
  ($SortWrappers.IntTo$Snap i@212@01))))) i@212@01))
(pop) ; 5
(push) ; 5
; [else-branch: 45 | !(x@211@01 in xs@196@01 && i@212@01 in is@197@01)]
(assert (not (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))
  (and
    (Set_in x@211@01 xs@196@01)
    (Seq_contains is@197@01 i@212@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@211@01)
      ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@211@01)
      ($SortWrappers.IntTo$Snap i@212@01)))
    (=>
      (and
        (and (img@205@01 x@211@01 i@212@01) (img@207@01 x@211@01 i@212@01))
        (and
          (Set_in (inv@204@01 x@211@01 i@212@01) xs@196@01)
          (Seq_contains is@197@01 (inv@206@01 x@211@01 i@212@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@211@01)
              ($SortWrappers.IntTo$Snap i@212@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@211@01)
            ($SortWrappers.IntTo$Snap i@212@01)))
          ($PSF.lookup_pair $t@203@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@211@01)
            ($SortWrappers.IntTo$Snap i@212@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@211@01)
      ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@211@01)
      ($SortWrappers.IntTo$Snap i@212@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@211@01)
      ($SortWrappers.IntTo$Snap i@212@01))) x@211@01 i@212@01)
    (=
      ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@211@01)
        ($SortWrappers.IntTo$Snap i@212@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))))))
    (not (= x@211@01 $Ref.null))
    (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@211@01)
      ($SortWrappers.IntTo$Snap i@212@01))))) i@212@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01)))
  (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@211@01 $Ref) (i@212@01 Int)) (!
  (and
    (or (Set_in x@211@01 xs@196@01) (not (Set_in x@211@01 xs@196@01)))
    (=>
      (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))
      (and
        (Set_in x@211@01 xs@196@01)
        (Seq_contains is@197@01 i@212@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01)))
        (=>
          (and
            (and (img@205@01 x@211@01 i@212@01) (img@207@01 x@211@01 i@212@01))
            (and
              (Set_in (inv@204@01 x@211@01 i@212@01) xs@196@01)
              (Seq_contains is@197@01 (inv@206@01 x@211@01 i@212@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@211@01)
                  ($SortWrappers.IntTo$Snap i@212@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@211@01)
                ($SortWrappers.IntTo$Snap i@212@01)))
              ($PSF.lookup_pair $t@203@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@211@01)
                ($SortWrappers.IntTo$Snap i@212@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))) x@211@01 i@212@01)
        (=
          ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@211@01)
            ($SortWrappers.IntTo$Snap i@212@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@211@01)
              ($SortWrappers.IntTo$Snap i@212@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@211@01)
              ($SortWrappers.IntTo$Snap i@212@01))))))
        (not (= x@211@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))))) i@212@01)))
    (or
      (not (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01)))
      (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@211@01)
    ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@211@01)
    ($SortWrappers.IntTo$Snap i@212@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@106@10@107@68-aux|)))
(assert (forall ((x@211@01 $Ref) (i@212@01 Int)) (!
  (and
    (or (Set_in x@211@01 xs@196@01) (not (Set_in x@211@01 xs@196@01)))
    (=>
      (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))
      (and
        (Set_in x@211@01 xs@196@01)
        (Seq_contains is@197@01 i@212@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01)))
        (=>
          (and
            (and (img@205@01 x@211@01 i@212@01) (img@207@01 x@211@01 i@212@01))
            (and
              (Set_in (inv@204@01 x@211@01 i@212@01) xs@196@01)
              (Seq_contains is@197@01 (inv@206@01 x@211@01 i@212@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@211@01)
                  ($SortWrappers.IntTo$Snap i@212@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@211@01)
                ($SortWrappers.IntTo$Snap i@212@01)))
              ($PSF.lookup_pair $t@203@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@211@01)
                ($SortWrappers.IntTo$Snap i@212@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))) x@211@01 i@212@01)
        (=
          ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@211@01)
            ($SortWrappers.IntTo$Snap i@212@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@211@01)
              ($SortWrappers.IntTo$Snap i@212@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@211@01)
              ($SortWrappers.IntTo$Snap i@212@01))))))
        (not (= x@211@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))))) i@212@01)))
    (or
      (not (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01)))
      (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))))
  :pattern ((Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))
  :pattern ((Set_in x@211@01 xs@196@01) (Seq_contains_trigger is@197@01 i@212@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@106@10@107@68-aux|)))
(assert (forall ((x@211@01 $Ref) (i@212@01 Int)) (!
  (and
    (or (Set_in x@211@01 xs@196@01) (not (Set_in x@211@01 xs@196@01)))
    (=>
      (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))
      (and
        (Set_in x@211@01 xs@196@01)
        (Seq_contains is@197@01 i@212@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01)))
        (=>
          (and
            (and (img@205@01 x@211@01 i@212@01) (img@207@01 x@211@01 i@212@01))
            (and
              (Set_in (inv@204@01 x@211@01 i@212@01) xs@196@01)
              (Seq_contains is@197@01 (inv@206@01 x@211@01 i@212@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@211@01)
                  ($SortWrappers.IntTo$Snap i@212@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@211@01)
                ($SortWrappers.IntTo$Snap i@212@01)))
              ($PSF.lookup_pair $t@203@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@211@01)
                ($SortWrappers.IntTo$Snap i@212@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))) x@211@01 i@212@01)
        (=
          ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@211@01)
            ($SortWrappers.IntTo$Snap i@212@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@211@01)
              ($SortWrappers.IntTo$Snap i@212@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@211@01)
              ($SortWrappers.IntTo$Snap i@212@01))))))
        (not (= x@211@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@211@01)
          ($SortWrappers.IntTo$Snap i@212@01))))) i@212@01)))
    (or
      (not (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01)))
      (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))))
  :pattern ((Set_in x@211@01 xs@196@01) (Seq_contains_trigger is@197@01 i@212@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@106@10@107@68-aux|)))
(assert (forall ((x@211@01 $Ref) (i@212@01 Int)) (!
  (=>
    (and (Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))
    (<
      0
      (addA $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@211@01)
        ($SortWrappers.IntTo$Snap i@212@01))))) i@212@01)))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@211@01)
    ($SortWrappers.IntTo$Snap i@212@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@211@01)
    ($SortWrappers.IntTo$Snap i@212@01))))
  :pattern ((Set_in x@211@01 xs@196@01) (Seq_contains is@197@01 i@212@01))
  :pattern ((Set_in x@211@01 xs@196@01) (Seq_contains_trigger is@197@01 i@212@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@106@10@107@68|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (tx in xs)
(declare-const $t@214@01 $Snap)
(assert (= $t@214@01 $Snap.unit))
; [eval] (tx in xs)
(assert (Set_in tx@198@01 xs@196@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (ti in is)
(declare-const $t@215@01 $Snap)
(assert (= $t@215@01 $Snap.unit))
; [eval] (ti in is)
(assert (Seq_contains is@197@01 ti@199@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; unfold acc(pair(tx, ti), write)
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@198@01)
  ($SortWrappers.IntTo$Snap ti@199@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@198@01)
  ($SortWrappers.IntTo$Snap ti@199@01))))
; Precomputing data for removing quantified permissions
(define-fun pTaken@216@01 ((x $Ref) (i Int)) $Perm
  (ite
    (and (= x tx@198@01) (= i ti@199@01))
    ($Perm.min
      (ite
        (and
          (and (img@205@01 x i) (img@207@01 x i))
          (and
            (Set_in (inv@204@01 x i) xs@196@01)
            (Seq_contains is@197@01 (inv@206@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@205@01 x i) (img@207@01 x i))
          (and
            (Set_in (inv@204@01 x i) xs@196@01)
            (Seq_contains is@197@01 (inv@206@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@216@01 x i))
    $Perm.No)
  
  :qid |quant-u-5149|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@216@01 x i) $Perm.No)
  
  :qid |quant-u-5150|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x tx@198@01) (= i ti@199@01))
    (= (- $Perm.Write (pTaken@216@01 x i)) $Perm.No))
  
  :qid |quant-u-5151|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@205@01 tx@198@01 ti@199@01) (img@207@01 tx@198@01 ti@199@01))
    (and
      (Set_in (inv@204@01 tx@198@01 ti@199@01) xs@196@01)
      (Seq_contains is@197@01 (inv@206@01 tx@198@01 ti@199@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap tx@198@01)
          ($SortWrappers.IntTo$Snap ti@199@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@198@01)
        ($SortWrappers.IntTo$Snap ti@199@01)))
      ($PSF.lookup_pair $t@203@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@198@01)
        ($SortWrappers.IntTo$Snap ti@199@01)))))))
(assert ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@198@01)
  ($SortWrappers.IntTo$Snap ti@199@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@198@01)
  ($SortWrappers.IntTo$Snap ti@199@01))))
(assert (=
  ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@198@01)
    ($SortWrappers.IntTo$Snap ti@199@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@198@01)
      ($SortWrappers.IntTo$Snap ti@199@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@198@01)
      ($SortWrappers.IntTo$Snap ti@199@01)))))))
(assert (not (= tx@198@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (pair%trigger ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@198@01)
  ($SortWrappers.IntTo$Snap ti@199@01))) tx@198@01 ti@199@01))
; [exec]
; tmp := tx.f
(declare-const tmp@217@01 Int)
(assert (=
  tmp@217@01
  ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@198@01)
    ($SortWrappers.IntTo$Snap ti@199@01)))))))
; [exec]
; tx.f := tx.g
(declare-const f@218@01 Int)
(assert (=
  f@218@01
  ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@208@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@198@01)
    ($SortWrappers.IntTo$Snap ti@199@01)))))))
; [exec]
; tx.g := tmp
; [exec]
; fold acc(pair(tx, ti), write)
(assert (pair%trigger ($Snap.combine
  ($SortWrappers.IntTo$Snap f@218@01)
  ($SortWrappers.IntTo$Snap tmp@217@01)) tx@198@01 ti@199@01))
(declare-const sm@219@01 $PSF<pair>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@198@01)
    ($SortWrappers.IntTo$Snap ti@199@01)))
  ($Snap.combine
    ($SortWrappers.IntTo$Snap f@218@01)
    ($SortWrappers.IntTo$Snap tmp@217@01))))
(declare-const sm@220@01 $PSF<pair>)
(declare-const s@221@01 $Snap)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((s@221@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@221@01)) tx@198@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@221@01)) ti@199@01))
    (and
      (not (= s@221@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) s@221@01)
        ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) s@221@01))))
  :pattern (($PSF.lookup_pair (as sm@220@01  $PSF<pair>) s@221@01))
  :pattern (($PSF.lookup_pair (as sm@219@01  $PSF<pair>) s@221@01))
  :qid |qp.psmValDef32|)))
(assert (forall ((s@221@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@205@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@221@01)) ($SortWrappers.$SnapToInt ($Snap.second s@221@01)))
          (img@207@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@221@01)) ($SortWrappers.$SnapToInt ($Snap.second s@221@01))))
        (and
          (Set_in (inv@204@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@221@01)) ($SortWrappers.$SnapToInt ($Snap.second s@221@01))) xs@196@01)
          (Seq_contains
            is@197@01
            (inv@206@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@221@01)) ($SortWrappers.$SnapToInt ($Snap.second s@221@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@216@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@221@01)) ($SortWrappers.$SnapToInt ($Snap.second s@221@01)))))
      false)
    (and
      (not (= s@221@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) s@221@01)
        ($PSF.lookup_pair $t@203@01 s@221@01))))
  :pattern (($PSF.lookup_pair (as sm@220@01  $PSF<pair>) s@221@01))
  :pattern (($PSF.lookup_pair $t@203@01 s@221@01))
  :qid |qp.psmValDef33|)))
(assert (forall ((s@221@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) s@221@01) s@221@01)
    ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 s@221@01) s@221@01))
  :pattern (($PSF.lookup_pair (as sm@220@01  $PSF<pair>) s@221@01))
  :qid |qp.psmResTrgDef34|)))
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@198@01)
  ($SortWrappers.IntTo$Snap ti@199@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@198@01)
  ($SortWrappers.IntTo$Snap ti@199@01))))
; [exec]
; assert (forall x: Ref, i: Int ::
;     { pair(x, i) }
;     (x in xs) && (i in is) ==>
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) ||
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.g)))
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) || 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g)))
(declare-const x@222@01 $Ref)
(declare-const i@223@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) || 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 46 | !(x@222@01 in xs@196@01) | live]
; [else-branch: 46 | x@222@01 in xs@196@01 | live]
(push) ; 5
; [then-branch: 46 | !(x@222@01 in xs@196@01)]
(assert (not (Set_in x@222@01 xs@196@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 46 | x@222@01 in xs@196@01]
(assert (Set_in x@222@01 xs@196@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@222@01 xs@196@01) (not (Set_in x@222@01 xs@196@01))))
(push) ; 4
; [then-branch: 47 | x@222@01 in xs@196@01 && i@223@01 in is@197@01 | live]
; [else-branch: 47 | !(x@222@01 in xs@196@01 && i@223@01 in is@197@01) | live]
(push) ; 5
; [then-branch: 47 | x@222@01 in xs@196@01 && i@223@01 in is@197@01]
(assert (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01)))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) || 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@222@01)
  ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@222@01)
  ($SortWrappers.IntTo$Snap i@223@01))))
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@198@01 x@222@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@224@01 ((x $Ref) (i Int) (x@222@01 $Ref) (i@223@01 Int)) $Perm
  (ite
    (and (= x x@222@01) (= i i@223@01))
    ($Perm.min
      (ite
        (and
          (and (img@205@01 x i) (img@207@01 x i))
          (and
            (Set_in (inv@204@01 x i) xs@196@01)
            (Seq_contains is@197@01 (inv@206@01 x i))))
        (- $Perm.Write (pTaken@216@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@225@01 ((x $Ref) (i Int) (x@222@01 $Ref) (i@223@01 Int)) $Perm
  (ite
    (and (= x x@222@01) (= i i@223@01))
    ($Perm.min
      (ite (and (= x tx@198@01) (= i ti@199@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@224@01 x i x@222@01 i@223@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@205@01 x i) (img@207@01 x i))
          (and
            (Set_in (inv@204@01 x i) xs@196@01)
            (Seq_contains is@197@01 (inv@206@01 x i))))
        (- $Perm.Write (pTaken@216@01 x i))
        $Perm.No)
      (pTaken@224@01 x i x@222@01 i@223@01))
    $Perm.No)
  
  :qid |quant-u-5153|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@224@01 x i x@222@01 i@223@01) $Perm.No)
  
  :qid |quant-u-5154|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@222@01) (= i i@223@01))
    (= (- $Perm.Write (pTaken@224@01 x i x@222@01 i@223@01)) $Perm.No))
  
  :qid |quant-u-5155|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@225@01 tx@198@01 ti@199@01 x@222@01 i@223@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@225@01 x i x@222@01 i@223@01) $Perm.No)
  
  :qid |quant-u-5157|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@222@01) (= i i@223@01))
    (=
      (-
        (- $Perm.Write (pTaken@224@01 x i x@222@01 i@223@01))
        (pTaken@225@01 x i x@222@01 i@223@01))
      $Perm.No))
  
  :qid |quant-u-5158|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@222@01 tx@198@01) (= i@223@01 ti@199@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@222@01)
        ($SortWrappers.IntTo$Snap i@223@01)))
      ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@222@01)
        ($SortWrappers.IntTo$Snap i@223@01)))))))
(assert (=>
  (ite
    (and
      (and (img@205@01 x@222@01 i@223@01) (img@207@01 x@222@01 i@223@01))
      (and
        (Set_in (inv@204@01 x@222@01 i@223@01) xs@196@01)
        (Seq_contains is@197@01 (inv@206@01 x@222@01 i@223@01))))
    (< $Perm.No (- $Perm.Write (pTaken@216@01 x@222@01 i@223@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@222@01)
        ($SortWrappers.IntTo$Snap i@223@01)))
      ($PSF.lookup_pair $t@203@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@222@01)
        ($SortWrappers.IntTo$Snap i@223@01)))))))
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01)))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@222@01)
  ($SortWrappers.IntTo$Snap i@223@01))) x@222@01 i@223@01))
(assert (=
  ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01)))))))
(assert (not (= x@222@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01)))
  (=>
    (and (= x@222@01 tx@198@01) (= i@223@01 ti@199@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@222@01)
            ($SortWrappers.IntTo$Snap i@223@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))
        ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))))))
  (=>
    (ite
      (and
        (and (img@205@01 x@222@01 i@223@01) (img@207@01 x@222@01 i@223@01))
        (and
          (Set_in (inv@204@01 x@222@01 i@223@01) xs@196@01)
          (Seq_contains is@197@01 (inv@206@01 x@222@01 i@223@01))))
      (< $Perm.No (- $Perm.Write (pTaken@216@01 x@222@01 i@223@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@222@01)
            ($SortWrappers.IntTo$Snap i@223@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))
        ($PSF.lookup_pair $t@203@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) x@222@01 i@223@01)
  (=
    ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@222@01)
        ($SortWrappers.IntTo$Snap i@223@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@222@01)
        ($SortWrappers.IntTo$Snap i@223@01))))))
  (not (= x@222@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@222@01)
  ($SortWrappers.IntTo$Snap i@223@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@222@01)
  ($SortWrappers.IntTo$Snap i@223@01)))))))
(push) ; 6
; [then-branch: 48 | 0 < addA(_, i@223@01, First:(PredicateLookup(pair, sm@220@01, List(x@222@01, i@223@01)))) | live]
; [else-branch: 48 | !(0 < addA(_, i@223@01, First:(PredicateLookup(pair, sm@220@01, List(x@222@01, i@223@01))))) | live]
(push) ; 7
; [then-branch: 48 | 0 < addA(_, i@223@01, First:(PredicateLookup(pair, sm@220@01, List(x@222@01, i@223@01))))]
(assert (<
  0
  (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))))))))
(pop) ; 7
(push) ; 7
; [else-branch: 48 | !(0 < addA(_, i@223@01, First:(PredicateLookup(pair, sm@220@01, List(x@222@01, i@223@01)))))]
(assert (not
  (<
    0
    (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01)))))))))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] (unfolding acc(pair(x, i), write) in x.g)
(push) ; 8
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(push) ; 9
(set-option :timeout 10)
(assert (not (= tx@198@01 x@222@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ti@199@01 i@223@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@226@01 ((x $Ref) (i Int) (x@222@01 $Ref) (i@223@01 Int)) $Perm
  (ite
    (and (= x x@222@01) (= i i@223@01))
    ($Perm.min
      (ite (and (= x tx@198@01) (= i ti@199@01)) $Perm.Write $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@227@01 ((x $Ref) (i Int) (x@222@01 $Ref) (i@223@01 Int)) $Perm
  (ite
    (and (= x x@222@01) (= i i@223@01))
    ($Perm.min
      (ite
        (and
          (and (img@205@01 x i) (img@207@01 x i))
          (and
            (Set_in (inv@204@01 x i) xs@196@01)
            (Seq_contains is@197@01 (inv@206@01 x i))))
        (- $Perm.Write (pTaken@216@01 x i))
        $Perm.No)
      (- $Perm.Write (pTaken@226@01 x i x@222@01 i@223@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@226@01 tx@198@01 ti@199@01 x@222@01 i@223@01))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@222@01) (= i i@223@01))
    (= (- $Perm.Write (pTaken@226@01 x i x@222@01 i@223@01)) $Perm.No))
  
  :qid |quant-u-5161|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01)))))
(pop) ; 8
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01)))))
(set-option :timeout 0)
(push) ; 8
(assert (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@222@01)
  ($SortWrappers.IntTo$Snap i@223@01)))))))
(pop) ; 8
; Joined path conditions
(assert (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@222@01)
  ($SortWrappers.IntTo$Snap i@223@01)))))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (=>
  (not
    (<
      0
      (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@222@01)
        ($SortWrappers.IntTo$Snap i@223@01))))))))
  (and
    (not
      (<
        0
        (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))))))))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01)))
    ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01)))
    (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01)))))))))
(assert (or
  (not
    (<
      0
      (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@222@01)
        ($SortWrappers.IntTo$Snap i@223@01))))))))
  (<
    0
    (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01)))))))))
(pop) ; 5
(push) ; 5
; [else-branch: 47 | !(x@222@01 in xs@196@01 && i@223@01 in is@197@01)]
(assert (not (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01))
  (and
    (Set_in x@222@01 xs@196@01)
    (Seq_contains is@197@01 i@223@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01)))
    (=>
      (and (= x@222@01 tx@198@01) (= i@223@01 ti@199@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@222@01)
            ($SortWrappers.IntTo$Snap i@223@01)))
          ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@222@01)
            ($SortWrappers.IntTo$Snap i@223@01))))))
    (=>
      (ite
        (and
          (and (img@205@01 x@222@01 i@223@01) (img@207@01 x@222@01 i@223@01))
          (and
            (Set_in (inv@204@01 x@222@01 i@223@01) xs@196@01)
            (Seq_contains is@197@01 (inv@206@01 x@222@01 i@223@01))))
        (< $Perm.No (- $Perm.Write (pTaken@216@01 x@222@01 i@223@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@222@01)
            ($SortWrappers.IntTo$Snap i@223@01)))
          ($PSF.lookup_pair $t@203@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@222@01)
            ($SortWrappers.IntTo$Snap i@223@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01)))
    ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01))) x@222@01 i@223@01)
    (=
      ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@222@01)
        ($SortWrappers.IntTo$Snap i@223@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))))))
    (not (= x@222@01 $Ref.null))
    (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@222@01)
      ($SortWrappers.IntTo$Snap i@223@01))))))
    (=>
      (not
        (<
          0
          (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@222@01)
            ($SortWrappers.IntTo$Snap i@223@01))))))))
      (and
        (not
          (<
            0
            (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01))))))))
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))
        ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))
        (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))))))))
    (or
      (not
        (<
          0
          (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@222@01)
            ($SortWrappers.IntTo$Snap i@223@01))))))))
      (<
        0
        (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01)))
  (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@222@01 $Ref) (i@223@01 Int)) (!
  (and
    (or (Set_in x@222@01 xs@196@01) (not (Set_in x@222@01 xs@196@01)))
    (=>
      (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01))
      (and
        (Set_in x@222@01 xs@196@01)
        (Seq_contains is@197@01 i@223@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))
        (=>
          (and (= x@222@01 tx@198@01) (= i@223@01 ti@199@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@222@01)
                  ($SortWrappers.IntTo$Snap i@223@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@222@01)
                ($SortWrappers.IntTo$Snap i@223@01)))
              ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@222@01)
                ($SortWrappers.IntTo$Snap i@223@01))))))
        (=>
          (ite
            (and
              (and (img@205@01 x@222@01 i@223@01) (img@207@01 x@222@01 i@223@01))
              (and
                (Set_in (inv@204@01 x@222@01 i@223@01) xs@196@01)
                (Seq_contains is@197@01 (inv@206@01 x@222@01 i@223@01))))
            (< $Perm.No (- $Perm.Write (pTaken@216@01 x@222@01 i@223@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@222@01)
                  ($SortWrappers.IntTo$Snap i@223@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@222@01)
                ($SortWrappers.IntTo$Snap i@223@01)))
              ($PSF.lookup_pair $t@203@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@222@01)
                ($SortWrappers.IntTo$Snap i@223@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))
        ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))) x@222@01 i@223@01)
        (=
          ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@222@01)
            ($SortWrappers.IntTo$Snap i@223@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01))))))
        (not (= x@222@01 $Ref.null))
        (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01))))))
        (=>
          (not
            (<
              0
              (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@222@01)
                ($SortWrappers.IntTo$Snap i@223@01))))))))
          (and
            (not
              (<
                0
                (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@222@01)
                  ($SortWrappers.IntTo$Snap i@223@01))))))))
            ($PSF.loc_pair ($PSF.lookup_pair (as sm@219@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01)))
            ($PSF.loc_pair ($PSF.lookup_pair $t@203@01 ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01)))
            (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01))))))))
        (or
          (not
            (<
              0
              (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@222@01)
                ($SortWrappers.IntTo$Snap i@223@01))))))))
          (<
            0
            (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01))))))))))
    (or
      (not (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01)))
      (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@111@10@114@48-aux|)))
(assert (forall ((x@222@01 $Ref) (i@223@01 Int)) (!
  (=>
    (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01))
    (and
      (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@222@01)
        ($SortWrappers.IntTo$Snap i@223@01))))))
      (=>
        (not
          (<
            0
            (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01))))))))
        (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@111@10@114@48_precondition|)))
(push) ; 3
(assert (not (forall ((x@222@01 $Ref) (i@223@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01))
        (and
          (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@222@01)
            ($SortWrappers.IntTo$Snap i@223@01))))))
          (=>
            (not
              (<
                0
                (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@222@01)
                  ($SortWrappers.IntTo$Snap i@223@01))))))))
            (addA%precondition $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@222@01)
              ($SortWrappers.IntTo$Snap i@223@01)))))))))
      (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01)))
    (or
      (<
        0
        (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))))))
      (<
        0
        (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@111@10@114@48|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (forall ((x@222@01 $Ref) (i@223@01 Int)) (!
  (=>
    (and (Set_in x@222@01 xs@196@01) (Seq_contains is@197@01 i@223@01))
    (or
      (<
        0
        (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))))))
      (<
        0
        (addA $Snap.unit i@223@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@222@01)
          ($SortWrappers.IntTo$Snap i@223@01)))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@220@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@222@01)
    ($SortWrappers.IntTo$Snap i@223@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@111@10@114@48|)))
(pop) ; 2
(pop) ; 1
; ---------- test02d ----------
(declare-const xs@228@01 Set<$Ref>)
(declare-const is@229@01 Seq<Int>)
(declare-const xs@230@01 Set<$Ref>)
(declare-const is@231@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var tx: Ref
(declare-const tx@232@01 $Ref)
; [exec]
; var ti: Int
(declare-const ti@233@01 Int)
; [exec]
; var tmp: Int
(declare-const tmp@234@01 Int)
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@235@01 $Ref)
(declare-const i@236@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 49 | !(x@235@01 in xs@230@01) | live]
; [else-branch: 49 | x@235@01 in xs@230@01 | live]
(push) ; 5
; [then-branch: 49 | !(x@235@01 in xs@230@01)]
(assert (not (Set_in x@235@01 xs@230@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 49 | x@235@01 in xs@230@01]
(assert (Set_in x@235@01 xs@230@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@235@01 xs@230@01) (not (Set_in x@235@01 xs@230@01))))
(assert (and (Set_in x@235@01 xs@230@01) (Seq_contains is@231@01 i@236@01)))
(pop) ; 3
(declare-const $t@237@01 $PSF<pair>)
(declare-fun inv@238@01 ($Ref Int) $Ref)
(declare-fun img@239@01 ($Ref Int) Bool)
(declare-fun inv@240@01 ($Ref Int) Int)
(declare-fun img@241@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@235@01 $Ref) (i@236@01 Int)) (!
  (=>
    (and (Set_in x@235@01 xs@230@01) (Seq_contains is@231@01 i@236@01))
    (or (Set_in x@235@01 xs@230@01) (not (Set_in x@235@01 xs@230@01))))
  :pattern ((Set_in x@235@01 xs@230@01) (Seq_contains is@231@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (Seq_contains_trigger is@231@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (Seq_contains_trigger is@231@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (inv@238@01 x@235@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (inv@240@01 x@235@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (img@239@01 x@235@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (img@241@01 x@235@01 i@236@01))
  :pattern ((Seq_contains is@231@01 i@236@01) (inv@238@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (inv@238@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (inv@238@01 x@235@01 i@236@01))
  :pattern ((Seq_contains is@231@01 i@236@01) (inv@240@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (inv@240@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (inv@240@01 x@235@01 i@236@01))
  :pattern ((Seq_contains is@231@01 i@236@01) (img@239@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (img@239@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (img@239@01 x@235@01 i@236@01))
  :pattern ((Seq_contains is@231@01 i@236@01) (img@241@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (img@241@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (img@241@01 x@235@01 i@236@01))
  :pattern ((inv@238@01 x@235@01 i@236@01))
  :pattern ((inv@240@01 x@235@01 i@236@01))
  :pattern ((img@239@01 x@235@01 i@236@01))
  :pattern ((img@241@01 x@235@01 i@236@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@235@01 $Ref) (i1@236@01 Int) (x2@235@01 $Ref) (i2@236@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@235@01 xs@230@01) (Seq_contains is@231@01 i1@236@01))
      (and (Set_in x2@235@01 xs@230@01) (Seq_contains is@231@01 i2@236@01))
      (and (= x1@235@01 x2@235@01) (= i1@236@01 i2@236@01)))
    (and (= x1@235@01 x2@235@01) (= i1@236@01 i2@236@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@235@01 $Ref) (i@236@01 Int)) (!
  (=>
    (and (Set_in x@235@01 xs@230@01) (Seq_contains is@231@01 i@236@01))
    (and
      (and
        (= (inv@238@01 x@235@01 i@236@01) x@235@01)
        (= (inv@240@01 x@235@01 i@236@01) i@236@01))
      (and (img@239@01 x@235@01 i@236@01) (img@241@01 x@235@01 i@236@01))))
  :pattern ((Set_in x@235@01 xs@230@01) (Seq_contains is@231@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (Seq_contains_trigger is@231@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (Seq_contains_trigger is@231@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (inv@238@01 x@235@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (inv@240@01 x@235@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (img@239@01 x@235@01 i@236@01))
  :pattern ((Set_in x@235@01 xs@230@01) (img@241@01 x@235@01 i@236@01))
  :pattern ((Seq_contains is@231@01 i@236@01) (inv@238@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (inv@238@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (inv@238@01 x@235@01 i@236@01))
  :pattern ((Seq_contains is@231@01 i@236@01) (inv@240@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (inv@240@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (inv@240@01 x@235@01 i@236@01))
  :pattern ((Seq_contains is@231@01 i@236@01) (img@239@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (img@239@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (img@239@01 x@235@01 i@236@01))
  :pattern ((Seq_contains is@231@01 i@236@01) (img@241@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (img@241@01 x@235@01 i@236@01))
  :pattern ((Seq_contains_trigger is@231@01 i@236@01) (img@241@01 x@235@01 i@236@01))
  :pattern ((inv@238@01 x@235@01 i@236@01))
  :pattern ((inv@240@01 x@235@01 i@236@01))
  :pattern ((img@239@01 x@235@01 i@236@01))
  :pattern ((img@241@01 x@235@01 i@236@01))
  :qid |quant-u-5163|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@239@01 x i) (img@241@01 x i))
      (and
        (Set_in (inv@238@01 x i) xs@230@01)
        (Seq_contains is@231@01 (inv@240@01 x i))))
    (and (= (inv@238@01 x i) x) (= (inv@240@01 x i) i)))
  :pattern ((inv@238@01 x i))
  :pattern ((inv@240@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
(declare-const sm@242@01 $PSF<pair>)
(declare-const s@243@01 $Snap)
; Definitional axioms for snapshot map values
(assert (forall ((s@243@01 $Snap)) (!
  (=>
    (and
      (and
        (img@239@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@243@01)) ($SortWrappers.$SnapToInt ($Snap.second s@243@01)))
        (img@241@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@243@01)) ($SortWrappers.$SnapToInt ($Snap.second s@243@01))))
      (and
        (Set_in (inv@238@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@243@01)) ($SortWrappers.$SnapToInt ($Snap.second s@243@01))) xs@230@01)
        (Seq_contains
          is@231@01
          (inv@240@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@243@01)) ($SortWrappers.$SnapToInt ($Snap.second s@243@01))))))
    (and
      (not (= s@243@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) s@243@01)
        ($PSF.lookup_pair $t@237@01 s@243@01))))
  :pattern (($PSF.lookup_pair (as sm@242@01  $PSF<pair>) s@243@01))
  :pattern (($PSF.lookup_pair $t@237@01 s@243@01))
  :qid |qp.psmValDef35|)))
(assert (forall ((s@243@01 $Snap)) (!
  ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 s@243@01) s@243@01)
  :pattern (($PSF.lookup_pair (as sm@242@01  $PSF<pair>) s@243@01))
  :qid |qp.psmResTrgDef36|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (Set_in (inv@238@01 x i) xs@230@01)
      (Seq_contains is@231@01 (inv@240@01 x i)))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x)
      ($SortWrappers.IntTo$Snap i))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x)
      ($SortWrappers.IntTo$Snap i))))
  :pattern ((inv@238@01 x i) (inv@240@01 x i))
  :qid |quant-u-5164|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { pair(x, i) }
;     (x in xs) && (i in is) ==>
;     0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const $t@244@01 $Snap)
(assert (= $t@244@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i))
(declare-const x@245@01 $Ref)
(declare-const i@246@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 50 | !(x@245@01 in xs@230@01) | live]
; [else-branch: 50 | x@245@01 in xs@230@01 | live]
(push) ; 5
; [then-branch: 50 | !(x@245@01 in xs@230@01)]
(assert (not (Set_in x@245@01 xs@230@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 50 | x@245@01 in xs@230@01]
(assert (Set_in x@245@01 xs@230@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@245@01 xs@230@01) (not (Set_in x@245@01 xs@230@01))))
(push) ; 4
; [then-branch: 51 | x@245@01 in xs@230@01 && i@246@01 in is@231@01 | live]
; [else-branch: 51 | !(x@245@01 in xs@230@01 && i@246@01 in is@231@01) | live]
(push) ; 5
; [then-branch: 51 | x@245@01 in xs@230@01 && i@246@01 in is@231@01]
(assert (and (Set_in x@245@01 xs@230@01) (Seq_contains is@231@01 i@246@01)))
; [eval] 0 < addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] addA((unfolding acc(pair(x, i), write) in x.f), i)
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@245@01)
  ($SortWrappers.IntTo$Snap i@246@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@245@01)
  ($SortWrappers.IntTo$Snap i@246@01))))
; Precomputing data for removing quantified permissions
(define-fun pTaken@247@01 ((x $Ref) (i Int) (x@245@01 $Ref) (i@246@01 Int)) $Perm
  (ite
    (and (= x x@245@01) (= i i@246@01))
    ($Perm.min
      (ite
        (and
          (and (img@239@01 x i) (img@241@01 x i))
          (and
            (Set_in (inv@238@01 x i) xs@230@01)
            (Seq_contains is@231@01 (inv@240@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@239@01 x i) (img@241@01 x i))
          (and
            (Set_in (inv@238@01 x i) xs@230@01)
            (Seq_contains is@231@01 (inv@240@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@247@01 x i x@245@01 i@246@01))
    $Perm.No)
  
  :qid |quant-u-5166|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@247@01 x i x@245@01 i@246@01) $Perm.No)
  
  :qid |quant-u-5167|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@245@01) (= i i@246@01))
    (= (- $Perm.Write (pTaken@247@01 x i x@245@01 i@246@01)) $Perm.No))
  
  :qid |quant-u-5168|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@239@01 x@245@01 i@246@01) (img@241@01 x@245@01 i@246@01))
    (and
      (Set_in (inv@238@01 x@245@01 i@246@01) xs@230@01)
      (Seq_contains is@231@01 (inv@240@01 x@245@01 i@246@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@245@01)
        ($SortWrappers.IntTo$Snap i@246@01)))
      ($PSF.lookup_pair $t@237@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@245@01)
        ($SortWrappers.IntTo$Snap i@246@01)))))))
(assert ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@245@01)
  ($SortWrappers.IntTo$Snap i@246@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@245@01)
  ($SortWrappers.IntTo$Snap i@246@01))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@245@01)
  ($SortWrappers.IntTo$Snap i@246@01))) x@245@01 i@246@01))
(assert (=
  ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@245@01)
    ($SortWrappers.IntTo$Snap i@246@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@245@01)
      ($SortWrappers.IntTo$Snap i@246@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@245@01)
      ($SortWrappers.IntTo$Snap i@246@01)))))))
(assert (not (= x@245@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@245@01)
    ($SortWrappers.IntTo$Snap i@246@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@245@01)
    ($SortWrappers.IntTo$Snap i@246@01)))
  (=>
    (and
      (and (img@239@01 x@245@01 i@246@01) (img@241@01 x@245@01 i@246@01))
      (and
        (Set_in (inv@238@01 x@245@01 i@246@01) xs@230@01)
        (Seq_contains is@231@01 (inv@240@01 x@245@01 i@246@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@245@01)
            ($SortWrappers.IntTo$Snap i@246@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01)))
        ($PSF.lookup_pair $t@237@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@245@01)
    ($SortWrappers.IntTo$Snap i@246@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@245@01)
    ($SortWrappers.IntTo$Snap i@246@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@245@01)
    ($SortWrappers.IntTo$Snap i@246@01))) x@245@01 i@246@01)
  (=
    ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@245@01)
      ($SortWrappers.IntTo$Snap i@246@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@245@01)
        ($SortWrappers.IntTo$Snap i@246@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@245@01)
        ($SortWrappers.IntTo$Snap i@246@01))))))
  (not (= x@245@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@245@01)
  ($SortWrappers.IntTo$Snap i@246@01))))) i@246@01))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@245@01)
  ($SortWrappers.IntTo$Snap i@246@01))))) i@246@01))
(pop) ; 5
(push) ; 5
; [else-branch: 51 | !(x@245@01 in xs@230@01 && i@246@01 in is@231@01)]
(assert (not (and (Set_in x@245@01 xs@230@01) (Seq_contains is@231@01 i@246@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@245@01 xs@230@01) (Seq_contains is@231@01 i@246@01))
  (and
    (Set_in x@245@01 xs@230@01)
    (Seq_contains is@231@01 i@246@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@245@01)
      ($SortWrappers.IntTo$Snap i@246@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@245@01)
      ($SortWrappers.IntTo$Snap i@246@01)))
    (=>
      (and
        (and (img@239@01 x@245@01 i@246@01) (img@241@01 x@245@01 i@246@01))
        (and
          (Set_in (inv@238@01 x@245@01 i@246@01) xs@230@01)
          (Seq_contains is@231@01 (inv@240@01 x@245@01 i@246@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@245@01)
              ($SortWrappers.IntTo$Snap i@246@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@245@01)
            ($SortWrappers.IntTo$Snap i@246@01)))
          ($PSF.lookup_pair $t@237@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@245@01)
            ($SortWrappers.IntTo$Snap i@246@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@245@01)
      ($SortWrappers.IntTo$Snap i@246@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@245@01)
      ($SortWrappers.IntTo$Snap i@246@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@245@01)
      ($SortWrappers.IntTo$Snap i@246@01))) x@245@01 i@246@01)
    (=
      ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@245@01)
        ($SortWrappers.IntTo$Snap i@246@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01))))))
    (not (= x@245@01 $Ref.null))
    (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@245@01)
      ($SortWrappers.IntTo$Snap i@246@01))))) i@246@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@245@01 xs@230@01) (Seq_contains is@231@01 i@246@01)))
  (and (Set_in x@245@01 xs@230@01) (Seq_contains is@231@01 i@246@01))))
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@245@01 $Ref) (i@246@01 Int)) (!
  (and
    (or (Set_in x@245@01 xs@230@01) (not (Set_in x@245@01 xs@230@01)))
    (=>
      (and (Set_in x@245@01 xs@230@01) (Seq_contains is@231@01 i@246@01))
      (and
        (Set_in x@245@01 xs@230@01)
        (Seq_contains is@231@01 i@246@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01)))
        (=>
          (and
            (and (img@239@01 x@245@01 i@246@01) (img@241@01 x@245@01 i@246@01))
            (and
              (Set_in (inv@238@01 x@245@01 i@246@01) xs@230@01)
              (Seq_contains is@231@01 (inv@240@01 x@245@01 i@246@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@245@01)
                  ($SortWrappers.IntTo$Snap i@246@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@245@01)
                ($SortWrappers.IntTo$Snap i@246@01)))
              ($PSF.lookup_pair $t@237@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@245@01)
                ($SortWrappers.IntTo$Snap i@246@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01))) x@245@01 i@246@01)
        (=
          ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@245@01)
            ($SortWrappers.IntTo$Snap i@246@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@245@01)
              ($SortWrappers.IntTo$Snap i@246@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@245@01)
              ($SortWrappers.IntTo$Snap i@246@01))))))
        (not (= x@245@01 $Ref.null))
        (addA%precondition $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@245@01)
          ($SortWrappers.IntTo$Snap i@246@01))))) i@246@01)))
    (or
      (not (and (Set_in x@245@01 xs@230@01) (Seq_contains is@231@01 i@246@01)))
      (and (Set_in x@245@01 xs@230@01) (Seq_contains is@231@01 i@246@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@245@01)
    ($SortWrappers.IntTo$Snap i@246@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@245@01)
    ($SortWrappers.IntTo$Snap i@246@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@120@10@121@68-aux|)))
(assert (forall ((x@245@01 $Ref) (i@246@01 Int)) (!
  (=>
    (and (Set_in x@245@01 xs@230@01) (Seq_contains is@231@01 i@246@01))
    (<
      0
      (addA $Snap.unit ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@245@01)
        ($SortWrappers.IntTo$Snap i@246@01))))) i@246@01)))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@245@01)
    ($SortWrappers.IntTo$Snap i@246@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@245@01)
    ($SortWrappers.IntTo$Snap i@246@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@120@10@121@68|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (tx in xs)
(declare-const $t@248@01 $Snap)
(assert (= $t@248@01 $Snap.unit))
; [eval] (tx in xs)
(assert (Set_in tx@232@01 xs@230@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (ti in is)
(declare-const $t@249@01 $Snap)
(assert (= $t@249@01 $Snap.unit))
; [eval] (ti in is)
(assert (Seq_contains is@231@01 ti@233@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; unfold acc(pair(tx, ti), write)
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@232@01)
  ($SortWrappers.IntTo$Snap ti@233@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@232@01)
  ($SortWrappers.IntTo$Snap ti@233@01))))
; Precomputing data for removing quantified permissions
(define-fun pTaken@250@01 ((x $Ref) (i Int)) $Perm
  (ite
    (and (= x tx@232@01) (= i ti@233@01))
    ($Perm.min
      (ite
        (and
          (and (img@239@01 x i) (img@241@01 x i))
          (and
            (Set_in (inv@238@01 x i) xs@230@01)
            (Seq_contains is@231@01 (inv@240@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@239@01 x i) (img@241@01 x i))
          (and
            (Set_in (inv@238@01 x i) xs@230@01)
            (Seq_contains is@231@01 (inv@240@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@250@01 x i))
    $Perm.No)
  
  :qid |quant-u-5170|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@250@01 x i) $Perm.No)
  
  :qid |quant-u-5171|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x tx@232@01) (= i ti@233@01))
    (= (- $Perm.Write (pTaken@250@01 x i)) $Perm.No))
  
  :qid |quant-u-5172|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@239@01 tx@232@01 ti@233@01) (img@241@01 tx@232@01 ti@233@01))
    (and
      (Set_in (inv@238@01 tx@232@01 ti@233@01) xs@230@01)
      (Seq_contains is@231@01 (inv@240@01 tx@232@01 ti@233@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap tx@232@01)
          ($SortWrappers.IntTo$Snap ti@233@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@232@01)
        ($SortWrappers.IntTo$Snap ti@233@01)))
      ($PSF.lookup_pair $t@237@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@232@01)
        ($SortWrappers.IntTo$Snap ti@233@01)))))))
(assert ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@232@01)
  ($SortWrappers.IntTo$Snap ti@233@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@232@01)
  ($SortWrappers.IntTo$Snap ti@233@01))))
(assert (=
  ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@232@01)
    ($SortWrappers.IntTo$Snap ti@233@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@232@01)
      ($SortWrappers.IntTo$Snap ti@233@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@232@01)
      ($SortWrappers.IntTo$Snap ti@233@01)))))))
(assert (not (= tx@232@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (pair%trigger ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@232@01)
  ($SortWrappers.IntTo$Snap ti@233@01))) tx@232@01 ti@233@01))
; [exec]
; tmp := tx.f
(declare-const tmp@251@01 Int)
(assert (=
  tmp@251@01
  ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@232@01)
    ($SortWrappers.IntTo$Snap ti@233@01)))))))
; [exec]
; tx.f := tx.g
(declare-const f@252@01 Int)
(assert (=
  f@252@01
  ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@242@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@232@01)
    ($SortWrappers.IntTo$Snap ti@233@01)))))))
; [exec]
; tx.g := tmp
; [exec]
; fold acc(pair(tx, ti), write)
(assert (pair%trigger ($Snap.combine
  ($SortWrappers.IntTo$Snap f@252@01)
  ($SortWrappers.IntTo$Snap tmp@251@01)) tx@232@01 ti@233@01))
(declare-const sm@253@01 $PSF<pair>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@232@01)
    ($SortWrappers.IntTo$Snap ti@233@01)))
  ($Snap.combine
    ($SortWrappers.IntTo$Snap f@252@01)
    ($SortWrappers.IntTo$Snap tmp@251@01))))
(declare-const sm@254@01 $PSF<pair>)
(declare-const s@255@01 $Snap)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((s@255@01 $Snap)) (!
  (=>
    (and
      (= ($SortWrappers.$SnapTo$Ref ($Snap.first s@255@01)) tx@232@01)
      (= ($SortWrappers.$SnapToInt ($Snap.second s@255@01)) ti@233@01))
    (and
      (not (= s@255@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) s@255@01)
        ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) s@255@01))))
  :pattern (($PSF.lookup_pair (as sm@254@01  $PSF<pair>) s@255@01))
  :pattern (($PSF.lookup_pair (as sm@253@01  $PSF<pair>) s@255@01))
  :qid |qp.psmValDef37|)))
(assert (forall ((s@255@01 $Snap)) (!
  (=>
    (ite
      (and
        (and
          (img@239@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@255@01)) ($SortWrappers.$SnapToInt ($Snap.second s@255@01)))
          (img@241@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@255@01)) ($SortWrappers.$SnapToInt ($Snap.second s@255@01))))
        (and
          (Set_in (inv@238@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@255@01)) ($SortWrappers.$SnapToInt ($Snap.second s@255@01))) xs@230@01)
          (Seq_contains
            is@231@01
            (inv@240@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@255@01)) ($SortWrappers.$SnapToInt ($Snap.second s@255@01))))))
      (<
        $Perm.No
        (-
          $Perm.Write
          (pTaken@250@01 ($SortWrappers.$SnapTo$Ref ($Snap.first s@255@01)) ($SortWrappers.$SnapToInt ($Snap.second s@255@01)))))
      false)
    (and
      (not (= s@255@01 $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) s@255@01)
        ($PSF.lookup_pair $t@237@01 s@255@01))))
  :pattern (($PSF.lookup_pair (as sm@254@01  $PSF<pair>) s@255@01))
  :pattern (($PSF.lookup_pair $t@237@01 s@255@01))
  :qid |qp.psmValDef38|)))
(assert (forall ((s@255@01 $Snap)) (!
  (and
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) s@255@01) s@255@01)
    ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 s@255@01) s@255@01))
  :pattern (($PSF.lookup_pair (as sm@254@01  $PSF<pair>) s@255@01))
  :qid |qp.psmResTrgDef39|)))
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@232@01)
  ($SortWrappers.IntTo$Snap ti@233@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@232@01)
  ($SortWrappers.IntTo$Snap ti@233@01))))
; [exec]
; assert (forall x: Ref, i: Int ::
;     { pair(x, i) }
;     (x in xs) && (i in is) ==>
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) ||
;     0 < addA(i, (unfolding acc(pair(x, i), write) in x.g)))
; [eval] (forall x: Ref, i: Int :: { pair(x, i) } (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) || 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g)))
(declare-const x@256@01 $Ref)
(declare-const i@257@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) || 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 52 | !(x@256@01 in xs@230@01) | live]
; [else-branch: 52 | x@256@01 in xs@230@01 | live]
(push) ; 5
; [then-branch: 52 | !(x@256@01 in xs@230@01)]
(assert (not (Set_in x@256@01 xs@230@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 52 | x@256@01 in xs@230@01]
(assert (Set_in x@256@01 xs@230@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@256@01 xs@230@01) (not (Set_in x@256@01 xs@230@01))))
(push) ; 4
; [then-branch: 53 | x@256@01 in xs@230@01 && i@257@01 in is@231@01 | live]
; [else-branch: 53 | !(x@256@01 in xs@230@01 && i@257@01 in is@231@01) | live]
(push) ; 5
; [then-branch: 53 | x@256@01 in xs@230@01 && i@257@01 in is@231@01]
(assert (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01)))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f)) || 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.f))
; [eval] (unfolding acc(pair(x, i), write) in x.f)
(push) ; 6
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert ($PSF.loc_pair ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@256@01)
  ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@256@01)
  ($SortWrappers.IntTo$Snap i@257@01))))
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@232@01 x@256@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@258@01 ((x $Ref) (i Int) (x@256@01 $Ref) (i@257@01 Int)) $Perm
  (ite
    (and (= x x@256@01) (= i i@257@01))
    ($Perm.min
      (ite
        (and
          (and (img@239@01 x i) (img@241@01 x i))
          (and
            (Set_in (inv@238@01 x i) xs@230@01)
            (Seq_contains is@231@01 (inv@240@01 x i))))
        (- $Perm.Write (pTaken@250@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@259@01 ((x $Ref) (i Int) (x@256@01 $Ref) (i@257@01 Int)) $Perm
  (ite
    (and (= x x@256@01) (= i i@257@01))
    ($Perm.min
      (ite (and (= x tx@232@01) (= i ti@233@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@258@01 x i x@256@01 i@257@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@239@01 x i) (img@241@01 x i))
          (and
            (Set_in (inv@238@01 x i) xs@230@01)
            (Seq_contains is@231@01 (inv@240@01 x i))))
        (- $Perm.Write (pTaken@250@01 x i))
        $Perm.No)
      (pTaken@258@01 x i x@256@01 i@257@01))
    $Perm.No)
  
  :qid |quant-u-5174|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@258@01 x i x@256@01 i@257@01) $Perm.No)
  
  :qid |quant-u-5175|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@256@01) (= i i@257@01))
    (= (- $Perm.Write (pTaken@258@01 x i x@256@01 i@257@01)) $Perm.No))
  
  :qid |quant-u-5176|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@259@01 tx@232@01 ti@233@01 x@256@01 i@257@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@259@01 x i x@256@01 i@257@01) $Perm.No)
  
  :qid |quant-u-5178|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@256@01) (= i i@257@01))
    (=
      (-
        (- $Perm.Write (pTaken@258@01 x i x@256@01 i@257@01))
        (pTaken@259@01 x i x@256@01 i@257@01))
      $Perm.No))
  
  :qid |quant-u-5179|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@256@01 tx@232@01) (= i@257@01 ti@233@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@256@01)
        ($SortWrappers.IntTo$Snap i@257@01)))
      ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@256@01)
        ($SortWrappers.IntTo$Snap i@257@01)))))))
(assert (=>
  (ite
    (and
      (and (img@239@01 x@256@01 i@257@01) (img@241@01 x@256@01 i@257@01))
      (and
        (Set_in (inv@238@01 x@256@01 i@257@01) xs@230@01)
        (Seq_contains is@231@01 (inv@240@01 x@256@01 i@257@01))))
    (< $Perm.No (- $Perm.Write (pTaken@250@01 x@256@01 i@257@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@256@01)
        ($SortWrappers.IntTo$Snap i@257@01)))
      ($PSF.lookup_pair $t@237@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@256@01)
        ($SortWrappers.IntTo$Snap i@257@01)))))))
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01)))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@256@01)
  ($SortWrappers.IntTo$Snap i@257@01))) x@256@01 i@257@01))
(assert (=
  ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01)))))))
(assert (not (= x@256@01 $Ref.null)))
(pop) ; 6
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01)))
  (=>
    (and (= x@256@01 tx@232@01) (= i@257@01 ti@233@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@256@01)
            ($SortWrappers.IntTo$Snap i@257@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))
        ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))))))
  (=>
    (ite
      (and
        (and (img@239@01 x@256@01 i@257@01) (img@241@01 x@256@01 i@257@01))
        (and
          (Set_in (inv@238@01 x@256@01 i@257@01) xs@230@01)
          (Seq_contains is@231@01 (inv@240@01 x@256@01 i@257@01))))
      (< $Perm.No (- $Perm.Write (pTaken@250@01 x@256@01 i@257@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@256@01)
            ($SortWrappers.IntTo$Snap i@257@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))
        ($PSF.lookup_pair $t@237@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))))))
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01)))
  (pair%trigger ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) x@256@01 i@257@01)
  (=
    ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@256@01)
        ($SortWrappers.IntTo$Snap i@257@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@256@01)
        ($SortWrappers.IntTo$Snap i@257@01))))))
  (not (= x@256@01 $Ref.null))))
(set-option :timeout 0)
(push) ; 6
(assert (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@256@01)
  ($SortWrappers.IntTo$Snap i@257@01)))))))
(pop) ; 6
; Joined path conditions
(assert (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@256@01)
  ($SortWrappers.IntTo$Snap i@257@01)))))))
(push) ; 6
; [then-branch: 54 | 0 < addA(_, i@257@01, First:(PredicateLookup(pair, sm@254@01, List(x@256@01, i@257@01)))) | live]
; [else-branch: 54 | !(0 < addA(_, i@257@01, First:(PredicateLookup(pair, sm@254@01, List(x@256@01, i@257@01))))) | live]
(push) ; 7
; [then-branch: 54 | 0 < addA(_, i@257@01, First:(PredicateLookup(pair, sm@254@01, List(x@256@01, i@257@01))))]
(assert (<
  0
  (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))))))))
(pop) ; 7
(push) ; 7
; [else-branch: 54 | !(0 < addA(_, i@257@01, First:(PredicateLookup(pair, sm@254@01, List(x@256@01, i@257@01)))))]
(assert (not
  (<
    0
    (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01)))))))))
; [eval] 0 < addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] addA(i, (unfolding acc(pair(x, i), write) in x.g))
; [eval] (unfolding acc(pair(x, i), write) in x.g)
(push) ; 8
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(push) ; 9
(set-option :timeout 10)
(assert (not (= tx@232@01 x@256@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (= ti@233@01 i@257@01)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@260@01 ((x $Ref) (i Int) (x@256@01 $Ref) (i@257@01 Int)) $Perm
  (ite
    (and (= x x@256@01) (= i i@257@01))
    ($Perm.min
      (ite (and (= x tx@232@01) (= i ti@233@01)) $Perm.Write $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@261@01 ((x $Ref) (i Int) (x@256@01 $Ref) (i@257@01 Int)) $Perm
  (ite
    (and (= x x@256@01) (= i i@257@01))
    ($Perm.min
      (ite
        (and
          (and (img@239@01 x i) (img@241@01 x i))
          (and
            (Set_in (inv@238@01 x i) xs@230@01)
            (Seq_contains is@231@01 (inv@240@01 x i))))
        (- $Perm.Write (pTaken@250@01 x i))
        $Perm.No)
      (- $Perm.Write (pTaken@260@01 x i x@256@01 i@257@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@260@01 tx@232@01 ti@233@01 x@256@01 i@257@01))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@256@01) (= i i@257@01))
    (= (- $Perm.Write (pTaken@260@01 x i x@256@01 i@257@01)) $Perm.No))
  
  :qid |quant-u-5182|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01)))))
(pop) ; 8
; Joined path conditions
(assert (and
  ($PSF.loc_pair ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01)))
  ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01)))))
(set-option :timeout 0)
(push) ; 8
(assert (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@256@01)
  ($SortWrappers.IntTo$Snap i@257@01)))))))
(pop) ; 8
; Joined path conditions
(assert (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@256@01)
  ($SortWrappers.IntTo$Snap i@257@01)))))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (=>
  (not
    (<
      0
      (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@256@01)
        ($SortWrappers.IntTo$Snap i@257@01))))))))
  (and
    (not
      (<
        0
        (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))))))))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01)))
    ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01)))
    (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01)))))))))
(assert (or
  (not
    (<
      0
      (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@256@01)
        ($SortWrappers.IntTo$Snap i@257@01))))))))
  (<
    0
    (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01)))))))))
(pop) ; 5
(push) ; 5
; [else-branch: 53 | !(x@256@01 in xs@230@01 && i@257@01 in is@231@01)]
(assert (not (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01))
  (and
    (Set_in x@256@01 xs@230@01)
    (Seq_contains is@231@01 i@257@01)
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01)))
    (=>
      (and (= x@256@01 tx@232@01) (= i@257@01 ti@233@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@256@01)
            ($SortWrappers.IntTo$Snap i@257@01)))
          ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@256@01)
            ($SortWrappers.IntTo$Snap i@257@01))))))
    (=>
      (ite
        (and
          (and (img@239@01 x@256@01 i@257@01) (img@241@01 x@256@01 i@257@01))
          (and
            (Set_in (inv@238@01 x@256@01 i@257@01) xs@230@01)
            (Seq_contains is@231@01 (inv@240@01 x@256@01 i@257@01))))
        (< $Perm.No (- $Perm.Write (pTaken@250@01 x@256@01 i@257@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@256@01)
            ($SortWrappers.IntTo$Snap i@257@01)))
          ($PSF.lookup_pair $t@237@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@256@01)
            ($SortWrappers.IntTo$Snap i@257@01))))))
    ($PSF.loc_pair ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01)))
    ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01)))
    (pair%trigger ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01))) x@256@01 i@257@01)
    (=
      ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@256@01)
        ($SortWrappers.IntTo$Snap i@257@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))))))
    (not (= x@256@01 $Ref.null))
    (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@256@01)
      ($SortWrappers.IntTo$Snap i@257@01))))))
    (=>
      (not
        (<
          0
          (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@256@01)
            ($SortWrappers.IntTo$Snap i@257@01))))))))
      (and
        (not
          (<
            0
            (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01))))))))
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))
        ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))
        (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))))))))
    (or
      (not
        (<
          0
          (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@256@01)
            ($SortWrappers.IntTo$Snap i@257@01))))))))
      (<
        0
        (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))))))))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01)))
  (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@256@01 $Ref) (i@257@01 Int)) (!
  (and
    (or (Set_in x@256@01 xs@230@01) (not (Set_in x@256@01 xs@230@01)))
    (=>
      (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01))
      (and
        (Set_in x@256@01 xs@230@01)
        (Seq_contains is@231@01 i@257@01)
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))
        (=>
          (and (= x@256@01 tx@232@01) (= i@257@01 ti@233@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@256@01)
                  ($SortWrappers.IntTo$Snap i@257@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@256@01)
                ($SortWrappers.IntTo$Snap i@257@01)))
              ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@256@01)
                ($SortWrappers.IntTo$Snap i@257@01))))))
        (=>
          (ite
            (and
              (and (img@239@01 x@256@01 i@257@01) (img@241@01 x@256@01 i@257@01))
              (and
                (Set_in (inv@238@01 x@256@01 i@257@01) xs@230@01)
                (Seq_contains is@231@01 (inv@240@01 x@256@01 i@257@01))))
            (< $Perm.No (- $Perm.Write (pTaken@250@01 x@256@01 i@257@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@256@01)
                  ($SortWrappers.IntTo$Snap i@257@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@256@01)
                ($SortWrappers.IntTo$Snap i@257@01)))
              ($PSF.lookup_pair $t@237@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@256@01)
                ($SortWrappers.IntTo$Snap i@257@01))))))
        ($PSF.loc_pair ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))
        ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))
        (pair%trigger ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))) x@256@01 i@257@01)
        (=
          ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@256@01)
            ($SortWrappers.IntTo$Snap i@257@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01))))))
        (not (= x@256@01 $Ref.null))
        (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01))))))
        (=>
          (not
            (<
              0
              (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@256@01)
                ($SortWrappers.IntTo$Snap i@257@01))))))))
          (and
            (not
              (<
                0
                (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@256@01)
                  ($SortWrappers.IntTo$Snap i@257@01))))))))
            ($PSF.loc_pair ($PSF.lookup_pair (as sm@253@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01)))
            ($PSF.loc_pair ($PSF.lookup_pair $t@237@01 ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01)))
            (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01))))))))
        (or
          (not
            (<
              0
              (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@256@01)
                ($SortWrappers.IntTo$Snap i@257@01))))))))
          (<
            0
            (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01))))))))))
    (or
      (not (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01)))
      (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@127@10@130@48-aux|)))
(assert (forall ((x@256@01 $Ref) (i@257@01 Int)) (!
  (=>
    (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01))
    (and
      (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@256@01)
        ($SortWrappers.IntTo$Snap i@257@01))))))
      (=>
        (not
          (<
            0
            (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01))))))))
        (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@127@10@130@48_precondition|)))
(push) ; 3
(assert (not (forall ((x@256@01 $Ref) (i@257@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01))
        (and
          (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@256@01)
            ($SortWrappers.IntTo$Snap i@257@01))))))
          (=>
            (not
              (<
                0
                (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@256@01)
                  ($SortWrappers.IntTo$Snap i@257@01))))))))
            (addA%precondition $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@256@01)
              ($SortWrappers.IntTo$Snap i@257@01)))))))))
      (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01)))
    (or
      (<
        0
        (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))))))
      (<
        0
        (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@127@10@130@48|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (forall ((x@256@01 $Ref) (i@257@01 Int)) (!
  (=>
    (and (Set_in x@256@01 xs@230@01) (Seq_contains is@231@01 i@257@01))
    (or
      (<
        0
        (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))))))
      (<
        0
        (addA $Snap.unit i@257@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@256@01)
          ($SortWrappers.IntTo$Snap i@257@01)))))))))
  :pattern (($PSF.loc_pair ($PSF.lookup_pair (as sm@254@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@256@01)
    ($SortWrappers.IntTo$Snap i@257@01))))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@127@10@130@48|)))
(pop) ; 2
(pop) ; 1
; ---------- test03a ----------
(declare-const xs@262@01 Set<$Ref>)
(declare-const is@263@01 Seq<Int>)
(declare-const xs@264@01 Set<$Ref>)
(declare-const is@265@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@266@01 $Ref)
(declare-const i@267@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 55 | !(x@266@01 in xs@264@01) | live]
; [else-branch: 55 | x@266@01 in xs@264@01 | live]
(push) ; 5
; [then-branch: 55 | !(x@266@01 in xs@264@01)]
(assert (not (Set_in x@266@01 xs@264@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 55 | x@266@01 in xs@264@01]
(assert (Set_in x@266@01 xs@264@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@266@01 xs@264@01) (not (Set_in x@266@01 xs@264@01))))
(assert (and (Set_in x@266@01 xs@264@01) (Seq_contains is@265@01 i@267@01)))
(pop) ; 3
(declare-const $t@268@01 $PSF<pair>)
(declare-fun inv@269@01 ($Ref Int) $Ref)
(declare-fun img@270@01 ($Ref Int) Bool)
(declare-fun inv@271@01 ($Ref Int) Int)
(declare-fun img@272@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@266@01 $Ref) (i@267@01 Int)) (!
  (=>
    (and (Set_in x@266@01 xs@264@01) (Seq_contains is@265@01 i@267@01))
    (or (Set_in x@266@01 xs@264@01) (not (Set_in x@266@01 xs@264@01))))
  :pattern ((Set_in x@266@01 xs@264@01) (Seq_contains is@265@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (Seq_contains_trigger is@265@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (Seq_contains_trigger is@265@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (inv@269@01 x@266@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (inv@271@01 x@266@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (img@270@01 x@266@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (img@272@01 x@266@01 i@267@01))
  :pattern ((Seq_contains is@265@01 i@267@01) (inv@269@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (inv@269@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (inv@269@01 x@266@01 i@267@01))
  :pattern ((Seq_contains is@265@01 i@267@01) (inv@271@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (inv@271@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (inv@271@01 x@266@01 i@267@01))
  :pattern ((Seq_contains is@265@01 i@267@01) (img@270@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (img@270@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (img@270@01 x@266@01 i@267@01))
  :pattern ((Seq_contains is@265@01 i@267@01) (img@272@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (img@272@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (img@272@01 x@266@01 i@267@01))
  :pattern ((inv@269@01 x@266@01 i@267@01))
  :pattern ((inv@271@01 x@266@01 i@267@01))
  :pattern ((img@270@01 x@266@01 i@267@01))
  :pattern ((img@272@01 x@266@01 i@267@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@266@01 $Ref) (i1@267@01 Int) (x2@266@01 $Ref) (i2@267@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@266@01 xs@264@01) (Seq_contains is@265@01 i1@267@01))
      (and (Set_in x2@266@01 xs@264@01) (Seq_contains is@265@01 i2@267@01))
      (and (= x1@266@01 x2@266@01) (= i1@267@01 i2@267@01)))
    (and (= x1@266@01 x2@266@01) (= i1@267@01 i2@267@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@266@01 $Ref) (i@267@01 Int)) (!
  (=>
    (and (Set_in x@266@01 xs@264@01) (Seq_contains is@265@01 i@267@01))
    (and
      (and
        (= (inv@269@01 x@266@01 i@267@01) x@266@01)
        (= (inv@271@01 x@266@01 i@267@01) i@267@01))
      (and (img@270@01 x@266@01 i@267@01) (img@272@01 x@266@01 i@267@01))))
  :pattern ((Set_in x@266@01 xs@264@01) (Seq_contains is@265@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (Seq_contains_trigger is@265@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (Seq_contains_trigger is@265@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (inv@269@01 x@266@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (inv@271@01 x@266@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (img@270@01 x@266@01 i@267@01))
  :pattern ((Set_in x@266@01 xs@264@01) (img@272@01 x@266@01 i@267@01))
  :pattern ((Seq_contains is@265@01 i@267@01) (inv@269@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (inv@269@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (inv@269@01 x@266@01 i@267@01))
  :pattern ((Seq_contains is@265@01 i@267@01) (inv@271@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (inv@271@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (inv@271@01 x@266@01 i@267@01))
  :pattern ((Seq_contains is@265@01 i@267@01) (img@270@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (img@270@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (img@270@01 x@266@01 i@267@01))
  :pattern ((Seq_contains is@265@01 i@267@01) (img@272@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (img@272@01 x@266@01 i@267@01))
  :pattern ((Seq_contains_trigger is@265@01 i@267@01) (img@272@01 x@266@01 i@267@01))
  :pattern ((inv@269@01 x@266@01 i@267@01))
  :pattern ((inv@271@01 x@266@01 i@267@01))
  :pattern ((img@270@01 x@266@01 i@267@01))
  :pattern ((img@272@01 x@266@01 i@267@01))
  :qid |quant-u-5184|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@270@01 x i) (img@272@01 x i))
      (and
        (Set_in (inv@269@01 x i) xs@264@01)
        (Seq_contains is@265@01 (inv@271@01 x i))))
    (and (= (inv@269@01 x i) x) (= (inv@271@01 x i) i)))
  :pattern ((inv@269@01 x i))
  :pattern ((inv@271@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { addB(x, i) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const $t@273@01 $Snap)
(assert (= $t@273@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { addB(x, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const x@274@01 $Ref)
(declare-const i@275@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 56 | !(x@274@01 in xs@264@01) | live]
; [else-branch: 56 | x@274@01 in xs@264@01 | live]
(push) ; 5
; [then-branch: 56 | !(x@274@01 in xs@264@01)]
(assert (not (Set_in x@274@01 xs@264@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 56 | x@274@01 in xs@264@01]
(assert (Set_in x@274@01 xs@264@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@274@01 xs@264@01) (not (Set_in x@274@01 xs@264@01))))
(push) ; 4
; [then-branch: 57 | x@274@01 in xs@264@01 && i@275@01 in is@265@01 | live]
; [else-branch: 57 | !(x@274@01 in xs@264@01 && i@275@01 in is@265@01) | live]
(push) ; 5
; [then-branch: 57 | x@274@01 in xs@264@01 && i@275@01 in is@265@01]
(assert (and (Set_in x@274@01 xs@264@01) (Seq_contains is@265@01 i@275@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@276@01 ((x $Ref) (i Int) (x@274@01 $Ref) (i@275@01 Int)) $Perm
  (ite
    (and (= x x@274@01) (= i i@275@01))
    ($Perm.min
      (ite
        (and
          (and (img@270@01 x i) (img@272@01 x i))
          (and
            (Set_in (inv@269@01 x i) xs@264@01)
            (Seq_contains is@265@01 (inv@271@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@270@01 x i) (img@272@01 x i))
          (and
            (Set_in (inv@269@01 x i) xs@264@01)
            (Seq_contains is@265@01 (inv@271@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@276@01 x i x@274@01 i@275@01))
    $Perm.No)
  
  :qid |quant-u-5186|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@276@01 x i x@274@01 i@275@01) $Perm.No)
  
  :qid |quant-u-5187|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@274@01) (= i i@275@01))
    (= (- $Perm.Write (pTaken@276@01 x i x@274@01 i@275@01)) $Perm.No))
  
  :qid |quant-u-5188|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@277@01 $PSF<pair>)
(declare-const s@278@01 $Snap)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@270@01 x@274@01 i@275@01) (img@272@01 x@274@01 i@275@01))
    (and
      (Set_in (inv@269@01 x@274@01 i@275@01) xs@264@01)
      (Seq_contains is@265@01 (inv@271@01 x@274@01 i@275@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@274@01)
          ($SortWrappers.IntTo$Snap i@275@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@274@01)
        ($SortWrappers.IntTo$Snap i@275@01)))
      ($PSF.lookup_pair $t@268@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@274@01)
        ($SortWrappers.IntTo$Snap i@275@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@274@01)
  ($SortWrappers.IntTo$Snap i@275@01))) x@274@01 i@275@01))
(assert (=
  ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@274@01)
    ($SortWrappers.IntTo$Snap i@275@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@274@01)
      ($SortWrappers.IntTo$Snap i@275@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@274@01)
      ($SortWrappers.IntTo$Snap i@275@01)))))))
(assert (not (= x@274@01 $Ref.null)))
; [eval] 0 < addB(x, i)
; [eval] addB(x, i)
(set-option :timeout 0)
(push) ; 7
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@274@01)
    ($SortWrappers.IntTo$Snap i@275@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@274@01)
    ($SortWrappers.IntTo$Snap i@275@01))))) x@274@01 i@275@01))
(pop) ; 7
; Joined path conditions
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@274@01)
    ($SortWrappers.IntTo$Snap i@275@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@274@01)
    ($SortWrappers.IntTo$Snap i@275@01))))) x@274@01 i@275@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@270@01 x@274@01 i@275@01) (img@272@01 x@274@01 i@275@01))
      (and
        (Set_in (inv@269@01 x@274@01 i@275@01) xs@264@01)
        (Seq_contains is@265@01 (inv@271@01 x@274@01 i@275@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@274@01)
            ($SortWrappers.IntTo$Snap i@275@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@274@01)
          ($SortWrappers.IntTo$Snap i@275@01)))
        ($PSF.lookup_pair $t@268@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@274@01)
          ($SortWrappers.IntTo$Snap i@275@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@274@01)
    ($SortWrappers.IntTo$Snap i@275@01))) x@274@01 i@275@01)
  (=
    ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@274@01)
      ($SortWrappers.IntTo$Snap i@275@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@274@01)
        ($SortWrappers.IntTo$Snap i@275@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@274@01)
        ($SortWrappers.IntTo$Snap i@275@01))))))
  (not (= x@274@01 $Ref.null))
  (addB%precondition ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@274@01)
      ($SortWrappers.IntTo$Snap i@275@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@274@01)
      ($SortWrappers.IntTo$Snap i@275@01))))) x@274@01 i@275@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 57 | !(x@274@01 in xs@264@01 && i@275@01 in is@265@01)]
(assert (not (and (Set_in x@274@01 xs@264@01) (Seq_contains is@265@01 i@275@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@274@01 xs@264@01) (Seq_contains is@265@01 i@275@01))
  (and
    (Set_in x@274@01 xs@264@01)
    (Seq_contains is@265@01 i@275@01)
    (=>
      (and
        (and (img@270@01 x@274@01 i@275@01) (img@272@01 x@274@01 i@275@01))
        (and
          (Set_in (inv@269@01 x@274@01 i@275@01) xs@264@01)
          (Seq_contains is@265@01 (inv@271@01 x@274@01 i@275@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@274@01)
              ($SortWrappers.IntTo$Snap i@275@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@274@01)
            ($SortWrappers.IntTo$Snap i@275@01)))
          ($PSF.lookup_pair $t@268@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@274@01)
            ($SortWrappers.IntTo$Snap i@275@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@274@01)
      ($SortWrappers.IntTo$Snap i@275@01))) x@274@01 i@275@01)
    (=
      ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@274@01)
        ($SortWrappers.IntTo$Snap i@275@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@274@01)
          ($SortWrappers.IntTo$Snap i@275@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@274@01)
          ($SortWrappers.IntTo$Snap i@275@01))))))
    (not (= x@274@01 $Ref.null))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@274@01)
        ($SortWrappers.IntTo$Snap i@275@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@274@01)
        ($SortWrappers.IntTo$Snap i@275@01))))) x@274@01 i@275@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@274@01 xs@264@01) (Seq_contains is@265@01 i@275@01)))
  (and (Set_in x@274@01 xs@264@01) (Seq_contains is@265@01 i@275@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@274@01 $Ref) (i@275@01 Int)) (!
  (and
    (or (Set_in x@274@01 xs@264@01) (not (Set_in x@274@01 xs@264@01)))
    (=>
      (and (Set_in x@274@01 xs@264@01) (Seq_contains is@265@01 i@275@01))
      (and
        (Set_in x@274@01 xs@264@01)
        (Seq_contains is@265@01 i@275@01)
        (=>
          (and
            (and (img@270@01 x@274@01 i@275@01) (img@272@01 x@274@01 i@275@01))
            (and
              (Set_in (inv@269@01 x@274@01 i@275@01) xs@264@01)
              (Seq_contains is@265@01 (inv@271@01 x@274@01 i@275@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@274@01)
                  ($SortWrappers.IntTo$Snap i@275@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@274@01)
                ($SortWrappers.IntTo$Snap i@275@01)))
              ($PSF.lookup_pair $t@268@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@274@01)
                ($SortWrappers.IntTo$Snap i@275@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@274@01)
          ($SortWrappers.IntTo$Snap i@275@01))) x@274@01 i@275@01)
        (=
          ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@274@01)
            ($SortWrappers.IntTo$Snap i@275@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@274@01)
              ($SortWrappers.IntTo$Snap i@275@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@274@01)
              ($SortWrappers.IntTo$Snap i@275@01))))))
        (not (= x@274@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@274@01)
            ($SortWrappers.IntTo$Snap i@275@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@274@01)
            ($SortWrappers.IntTo$Snap i@275@01))))) x@274@01 i@275@01)))
    (or
      (not (and (Set_in x@274@01 xs@264@01) (Seq_contains is@265@01 i@275@01)))
      (and (Set_in x@274@01 xs@264@01) (Seq_contains is@265@01 i@275@01))))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@274@01)
      ($SortWrappers.IntTo$Snap i@275@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@274@01)
      ($SortWrappers.IntTo$Snap i@275@01))))) x@274@01 i@275@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@137@10@138@66-aux|)))
(assert (forall ((x@274@01 $Ref) (i@275@01 Int)) (!
  (=>
    (and (Set_in x@274@01 xs@264@01) (Seq_contains is@265@01 i@275@01))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@274@01)
          ($SortWrappers.IntTo$Snap i@275@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@274@01)
          ($SortWrappers.IntTo$Snap i@275@01))))) x@274@01 i@275@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@274@01)
      ($SortWrappers.IntTo$Snap i@275@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@274@01)
      ($SortWrappers.IntTo$Snap i@275@01))))) x@274@01 i@275@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@137@10@138@66|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert (forall x: Ref, i: Int ::
;     { addB(x, i) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
; [eval] (forall x: Ref, i: Int :: { addB(x, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const x@279@01 $Ref)
(declare-const i@280@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 58 | !(x@279@01 in xs@264@01) | live]
; [else-branch: 58 | x@279@01 in xs@264@01 | live]
(push) ; 5
; [then-branch: 58 | !(x@279@01 in xs@264@01)]
(assert (not (Set_in x@279@01 xs@264@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 58 | x@279@01 in xs@264@01]
(assert (Set_in x@279@01 xs@264@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@279@01 xs@264@01) (not (Set_in x@279@01 xs@264@01))))
(push) ; 4
; [then-branch: 59 | x@279@01 in xs@264@01 && i@280@01 in is@265@01 | live]
; [else-branch: 59 | !(x@279@01 in xs@264@01 && i@280@01 in is@265@01) | live]
(push) ; 5
; [then-branch: 59 | x@279@01 in xs@264@01 && i@280@01 in is@265@01]
(assert (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@281@01 ((x $Ref) (i Int) (x@279@01 $Ref) (i@280@01 Int)) $Perm
  (ite
    (and (= x x@279@01) (= i i@280@01))
    ($Perm.min
      (ite
        (and
          (and (img@270@01 x i) (img@272@01 x i))
          (and
            (Set_in (inv@269@01 x i) xs@264@01)
            (Seq_contains is@265@01 (inv@271@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@270@01 x i) (img@272@01 x i))
          (and
            (Set_in (inv@269@01 x i) xs@264@01)
            (Seq_contains is@265@01 (inv@271@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@281@01 x i x@279@01 i@280@01))
    $Perm.No)
  
  :qid |quant-u-5190|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@281@01 x i x@279@01 i@280@01) $Perm.No)
  
  :qid |quant-u-5191|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@279@01) (= i i@280@01))
    (= (- $Perm.Write (pTaken@281@01 x i x@279@01 i@280@01)) $Perm.No))
  
  :qid |quant-u-5192|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@270@01 x@279@01 i@280@01) (img@272@01 x@279@01 i@280@01))
    (and
      (Set_in (inv@269@01 x@279@01 i@280@01) xs@264@01)
      (Seq_contains is@265@01 (inv@271@01 x@279@01 i@280@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@279@01)
          ($SortWrappers.IntTo$Snap i@280@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@279@01)
        ($SortWrappers.IntTo$Snap i@280@01)))
      ($PSF.lookup_pair $t@268@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@279@01)
        ($SortWrappers.IntTo$Snap i@280@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@279@01)
  ($SortWrappers.IntTo$Snap i@280@01))) x@279@01 i@280@01))
(assert (=
  ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@279@01)
    ($SortWrappers.IntTo$Snap i@280@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01)))))))
(assert (not (= x@279@01 $Ref.null)))
; [eval] 0 < addB(x, i)
; [eval] addB(x, i)
(set-option :timeout 0)
(push) ; 7
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@279@01)
    ($SortWrappers.IntTo$Snap i@280@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@279@01)
    ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01))
(pop) ; 7
; Joined path conditions
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@279@01)
    ($SortWrappers.IntTo$Snap i@280@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@279@01)
    ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@270@01 x@279@01 i@280@01) (img@272@01 x@279@01 i@280@01))
      (and
        (Set_in (inv@269@01 x@279@01 i@280@01) xs@264@01)
        (Seq_contains is@265@01 (inv@271@01 x@279@01 i@280@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@279@01)
            ($SortWrappers.IntTo$Snap i@280@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@279@01)
          ($SortWrappers.IntTo$Snap i@280@01)))
        ($PSF.lookup_pair $t@268@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@279@01)
          ($SortWrappers.IntTo$Snap i@280@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@279@01)
    ($SortWrappers.IntTo$Snap i@280@01))) x@279@01 i@280@01)
  (=
    ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@279@01)
        ($SortWrappers.IntTo$Snap i@280@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@279@01)
        ($SortWrappers.IntTo$Snap i@280@01))))))
  (not (= x@279@01 $Ref.null))
  (addB%precondition ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 59 | !(x@279@01 in xs@264@01 && i@280@01 in is@265@01)]
(assert (not (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01))
  (and
    (Set_in x@279@01 xs@264@01)
    (Seq_contains is@265@01 i@280@01)
    (=>
      (and
        (and (img@270@01 x@279@01 i@280@01) (img@272@01 x@279@01 i@280@01))
        (and
          (Set_in (inv@269@01 x@279@01 i@280@01) xs@264@01)
          (Seq_contains is@265@01 (inv@271@01 x@279@01 i@280@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@279@01)
              ($SortWrappers.IntTo$Snap i@280@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@279@01)
            ($SortWrappers.IntTo$Snap i@280@01)))
          ($PSF.lookup_pair $t@268@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@279@01)
            ($SortWrappers.IntTo$Snap i@280@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))) x@279@01 i@280@01)
    (=
      ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@279@01)
        ($SortWrappers.IntTo$Snap i@280@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@279@01)
          ($SortWrappers.IntTo$Snap i@280@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@279@01)
          ($SortWrappers.IntTo$Snap i@280@01))))))
    (not (= x@279@01 $Ref.null))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@279@01)
        ($SortWrappers.IntTo$Snap i@280@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@279@01)
        ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01)))
  (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@279@01 $Ref) (i@280@01 Int)) (!
  (and
    (or (Set_in x@279@01 xs@264@01) (not (Set_in x@279@01 xs@264@01)))
    (=>
      (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01))
      (and
        (Set_in x@279@01 xs@264@01)
        (Seq_contains is@265@01 i@280@01)
        (=>
          (and
            (and (img@270@01 x@279@01 i@280@01) (img@272@01 x@279@01 i@280@01))
            (and
              (Set_in (inv@269@01 x@279@01 i@280@01) xs@264@01)
              (Seq_contains is@265@01 (inv@271@01 x@279@01 i@280@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@279@01)
                  ($SortWrappers.IntTo$Snap i@280@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@279@01)
                ($SortWrappers.IntTo$Snap i@280@01)))
              ($PSF.lookup_pair $t@268@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@279@01)
                ($SortWrappers.IntTo$Snap i@280@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@279@01)
          ($SortWrappers.IntTo$Snap i@280@01))) x@279@01 i@280@01)
        (=
          ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@279@01)
            ($SortWrappers.IntTo$Snap i@280@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@279@01)
              ($SortWrappers.IntTo$Snap i@280@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@279@01)
              ($SortWrappers.IntTo$Snap i@280@01))))))
        (not (= x@279@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@279@01)
            ($SortWrappers.IntTo$Snap i@280@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@279@01)
            ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01)))
    (or
      (not (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01)))
      (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01))))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@140@10@141@66-aux|)))
(assert (forall ((x@279@01 $Ref) (i@280@01 Int)) (!
  (=>
    (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@279@01)
        ($SortWrappers.IntTo$Snap i@280@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@279@01)
        ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@140@10@141@66_precondition|)))
(push) ; 3
(assert (not (forall ((x@279@01 $Ref) (i@280@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@279@01)
            ($SortWrappers.IntTo$Snap i@280@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@279@01)
            ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01))
      (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01)))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@279@01)
          ($SortWrappers.IntTo$Snap i@280@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@279@01)
          ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@140@10@141@66|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (forall ((x@279@01 $Ref) (i@280@01 Int)) (!
  (=>
    (and (Set_in x@279@01 xs@264@01) (Seq_contains is@265@01 i@280@01))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@279@01)
          ($SortWrappers.IntTo$Snap i@280@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@279@01)
          ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@277@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@279@01)
      ($SortWrappers.IntTo$Snap i@280@01))))) x@279@01 i@280@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@140@10@141@66|)))
(pop) ; 2
(pop) ; 1
; ---------- test03b ----------
(declare-const xs@282@01 Set<$Ref>)
(declare-const is@283@01 Seq<Int>)
(declare-const xs@284@01 Set<$Ref>)
(declare-const is@285@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var tx: Ref
(declare-const tx@286@01 $Ref)
; [exec]
; var ti: Int
(declare-const ti@287@01 Int)
; [exec]
; var tmp: Int
(declare-const tmp@288@01 Int)
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@289@01 $Ref)
(declare-const i@290@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 60 | !(x@289@01 in xs@284@01) | live]
; [else-branch: 60 | x@289@01 in xs@284@01 | live]
(push) ; 5
; [then-branch: 60 | !(x@289@01 in xs@284@01)]
(assert (not (Set_in x@289@01 xs@284@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 60 | x@289@01 in xs@284@01]
(assert (Set_in x@289@01 xs@284@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@289@01 xs@284@01) (not (Set_in x@289@01 xs@284@01))))
(assert (and (Set_in x@289@01 xs@284@01) (Seq_contains is@285@01 i@290@01)))
(pop) ; 3
(declare-const $t@291@01 $PSF<pair>)
(declare-fun inv@292@01 ($Ref Int) $Ref)
(declare-fun img@293@01 ($Ref Int) Bool)
(declare-fun inv@294@01 ($Ref Int) Int)
(declare-fun img@295@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@289@01 $Ref) (i@290@01 Int)) (!
  (=>
    (and (Set_in x@289@01 xs@284@01) (Seq_contains is@285@01 i@290@01))
    (or (Set_in x@289@01 xs@284@01) (not (Set_in x@289@01 xs@284@01))))
  :pattern ((Set_in x@289@01 xs@284@01) (Seq_contains is@285@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (Seq_contains_trigger is@285@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (Seq_contains_trigger is@285@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (inv@292@01 x@289@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (inv@294@01 x@289@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (img@293@01 x@289@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (img@295@01 x@289@01 i@290@01))
  :pattern ((Seq_contains is@285@01 i@290@01) (inv@292@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (inv@292@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (inv@292@01 x@289@01 i@290@01))
  :pattern ((Seq_contains is@285@01 i@290@01) (inv@294@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (inv@294@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (inv@294@01 x@289@01 i@290@01))
  :pattern ((Seq_contains is@285@01 i@290@01) (img@293@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (img@293@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (img@293@01 x@289@01 i@290@01))
  :pattern ((Seq_contains is@285@01 i@290@01) (img@295@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (img@295@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (img@295@01 x@289@01 i@290@01))
  :pattern ((inv@292@01 x@289@01 i@290@01))
  :pattern ((inv@294@01 x@289@01 i@290@01))
  :pattern ((img@293@01 x@289@01 i@290@01))
  :pattern ((img@295@01 x@289@01 i@290@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@289@01 $Ref) (i1@290@01 Int) (x2@289@01 $Ref) (i2@290@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@289@01 xs@284@01) (Seq_contains is@285@01 i1@290@01))
      (and (Set_in x2@289@01 xs@284@01) (Seq_contains is@285@01 i2@290@01))
      (and (= x1@289@01 x2@289@01) (= i1@290@01 i2@290@01)))
    (and (= x1@289@01 x2@289@01) (= i1@290@01 i2@290@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@289@01 $Ref) (i@290@01 Int)) (!
  (=>
    (and (Set_in x@289@01 xs@284@01) (Seq_contains is@285@01 i@290@01))
    (and
      (and
        (= (inv@292@01 x@289@01 i@290@01) x@289@01)
        (= (inv@294@01 x@289@01 i@290@01) i@290@01))
      (and (img@293@01 x@289@01 i@290@01) (img@295@01 x@289@01 i@290@01))))
  :pattern ((Set_in x@289@01 xs@284@01) (Seq_contains is@285@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (Seq_contains_trigger is@285@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (Seq_contains_trigger is@285@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (inv@292@01 x@289@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (inv@294@01 x@289@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (img@293@01 x@289@01 i@290@01))
  :pattern ((Set_in x@289@01 xs@284@01) (img@295@01 x@289@01 i@290@01))
  :pattern ((Seq_contains is@285@01 i@290@01) (inv@292@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (inv@292@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (inv@292@01 x@289@01 i@290@01))
  :pattern ((Seq_contains is@285@01 i@290@01) (inv@294@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (inv@294@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (inv@294@01 x@289@01 i@290@01))
  :pattern ((Seq_contains is@285@01 i@290@01) (img@293@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (img@293@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (img@293@01 x@289@01 i@290@01))
  :pattern ((Seq_contains is@285@01 i@290@01) (img@295@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (img@295@01 x@289@01 i@290@01))
  :pattern ((Seq_contains_trigger is@285@01 i@290@01) (img@295@01 x@289@01 i@290@01))
  :pattern ((inv@292@01 x@289@01 i@290@01))
  :pattern ((inv@294@01 x@289@01 i@290@01))
  :pattern ((img@293@01 x@289@01 i@290@01))
  :pattern ((img@295@01 x@289@01 i@290@01))
  :qid |quant-u-5194|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@293@01 x i) (img@295@01 x i))
      (and
        (Set_in (inv@292@01 x i) xs@284@01)
        (Seq_contains is@285@01 (inv@294@01 x i))))
    (and (= (inv@292@01 x i) x) (= (inv@294@01 x i) i)))
  :pattern ((inv@292@01 x i))
  :pattern ((inv@294@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { addB(x, i) }
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const $t@296@01 $Snap)
(assert (= $t@296@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { addB(x, i) } { (x in xs), (i in is) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const x@297@01 $Ref)
(declare-const i@298@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 61 | !(x@297@01 in xs@284@01) | live]
; [else-branch: 61 | x@297@01 in xs@284@01 | live]
(push) ; 5
; [then-branch: 61 | !(x@297@01 in xs@284@01)]
(assert (not (Set_in x@297@01 xs@284@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 61 | x@297@01 in xs@284@01]
(assert (Set_in x@297@01 xs@284@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@297@01 xs@284@01) (not (Set_in x@297@01 xs@284@01))))
(push) ; 4
; [then-branch: 62 | x@297@01 in xs@284@01 && i@298@01 in is@285@01 | live]
; [else-branch: 62 | !(x@297@01 in xs@284@01 && i@298@01 in is@285@01) | live]
(push) ; 5
; [then-branch: 62 | x@297@01 in xs@284@01 && i@298@01 in is@285@01]
(assert (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@299@01 ((x $Ref) (i Int) (x@297@01 $Ref) (i@298@01 Int)) $Perm
  (ite
    (and (= x x@297@01) (= i i@298@01))
    ($Perm.min
      (ite
        (and
          (and (img@293@01 x i) (img@295@01 x i))
          (and
            (Set_in (inv@292@01 x i) xs@284@01)
            (Seq_contains is@285@01 (inv@294@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@293@01 x i) (img@295@01 x i))
          (and
            (Set_in (inv@292@01 x i) xs@284@01)
            (Seq_contains is@285@01 (inv@294@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@299@01 x i x@297@01 i@298@01))
    $Perm.No)
  
  :qid |quant-u-5196|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@299@01 x i x@297@01 i@298@01) $Perm.No)
  
  :qid |quant-u-5197|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@297@01) (= i i@298@01))
    (= (- $Perm.Write (pTaken@299@01 x i x@297@01 i@298@01)) $Perm.No))
  
  :qid |quant-u-5198|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@300@01 $PSF<pair>)
(declare-const s@301@01 $Snap)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@293@01 x@297@01 i@298@01) (img@295@01 x@297@01 i@298@01))
    (and
      (Set_in (inv@292@01 x@297@01 i@298@01) xs@284@01)
      (Seq_contains is@285@01 (inv@294@01 x@297@01 i@298@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@297@01)
          ($SortWrappers.IntTo$Snap i@298@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@297@01)
        ($SortWrappers.IntTo$Snap i@298@01)))
      ($PSF.lookup_pair $t@291@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@297@01)
        ($SortWrappers.IntTo$Snap i@298@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@297@01)
  ($SortWrappers.IntTo$Snap i@298@01))) x@297@01 i@298@01))
(assert (=
  ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@297@01)
    ($SortWrappers.IntTo$Snap i@298@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@297@01)
      ($SortWrappers.IntTo$Snap i@298@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@297@01)
      ($SortWrappers.IntTo$Snap i@298@01)))))))
(assert (not (= x@297@01 $Ref.null)))
; [eval] 0 < addB(x, i)
; [eval] addB(x, i)
(set-option :timeout 0)
(push) ; 7
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@297@01)
    ($SortWrappers.IntTo$Snap i@298@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@297@01)
    ($SortWrappers.IntTo$Snap i@298@01))))) x@297@01 i@298@01))
(pop) ; 7
; Joined path conditions
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@297@01)
    ($SortWrappers.IntTo$Snap i@298@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@297@01)
    ($SortWrappers.IntTo$Snap i@298@01))))) x@297@01 i@298@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@293@01 x@297@01 i@298@01) (img@295@01 x@297@01 i@298@01))
      (and
        (Set_in (inv@292@01 x@297@01 i@298@01) xs@284@01)
        (Seq_contains is@285@01 (inv@294@01 x@297@01 i@298@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@297@01)
          ($SortWrappers.IntTo$Snap i@298@01)))
        ($PSF.lookup_pair $t@291@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@297@01)
          ($SortWrappers.IntTo$Snap i@298@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@297@01)
    ($SortWrappers.IntTo$Snap i@298@01))) x@297@01 i@298@01)
  (=
    ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@297@01)
      ($SortWrappers.IntTo$Snap i@298@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@297@01)
        ($SortWrappers.IntTo$Snap i@298@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@297@01)
        ($SortWrappers.IntTo$Snap i@298@01))))))
  (not (= x@297@01 $Ref.null))
  (addB%precondition ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@297@01)
      ($SortWrappers.IntTo$Snap i@298@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@297@01)
      ($SortWrappers.IntTo$Snap i@298@01))))) x@297@01 i@298@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 62 | !(x@297@01 in xs@284@01 && i@298@01 in is@285@01)]
(assert (not (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))
  (and
    (Set_in x@297@01 xs@284@01)
    (Seq_contains is@285@01 i@298@01)
    (=>
      (and
        (and (img@293@01 x@297@01 i@298@01) (img@295@01 x@297@01 i@298@01))
        (and
          (Set_in (inv@292@01 x@297@01 i@298@01) xs@284@01)
          (Seq_contains is@285@01 (inv@294@01 x@297@01 i@298@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@297@01)
              ($SortWrappers.IntTo$Snap i@298@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01)))
          ($PSF.lookup_pair $t@291@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@297@01)
      ($SortWrappers.IntTo$Snap i@298@01))) x@297@01 i@298@01)
    (=
      ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@297@01)
        ($SortWrappers.IntTo$Snap i@298@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@297@01)
          ($SortWrappers.IntTo$Snap i@298@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@297@01)
          ($SortWrappers.IntTo$Snap i@298@01))))))
    (not (= x@297@01 $Ref.null))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@297@01)
        ($SortWrappers.IntTo$Snap i@298@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@297@01)
        ($SortWrappers.IntTo$Snap i@298@01))))) x@297@01 i@298@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01)))
  (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@297@01 $Ref) (i@298@01 Int)) (!
  (and
    (or (Set_in x@297@01 xs@284@01) (not (Set_in x@297@01 xs@284@01)))
    (=>
      (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))
      (and
        (Set_in x@297@01 xs@284@01)
        (Seq_contains is@285@01 i@298@01)
        (=>
          (and
            (and (img@293@01 x@297@01 i@298@01) (img@295@01 x@297@01 i@298@01))
            (and
              (Set_in (inv@292@01 x@297@01 i@298@01) xs@284@01)
              (Seq_contains is@285@01 (inv@294@01 x@297@01 i@298@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@297@01)
                  ($SortWrappers.IntTo$Snap i@298@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@297@01)
                ($SortWrappers.IntTo$Snap i@298@01)))
              ($PSF.lookup_pair $t@291@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@297@01)
                ($SortWrappers.IntTo$Snap i@298@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@297@01)
          ($SortWrappers.IntTo$Snap i@298@01))) x@297@01 i@298@01)
        (=
          ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@297@01)
              ($SortWrappers.IntTo$Snap i@298@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@297@01)
              ($SortWrappers.IntTo$Snap i@298@01))))))
        (not (= x@297@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01))))) x@297@01 i@298@01)))
    (or
      (not (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01)))
      (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@297@01)
      ($SortWrappers.IntTo$Snap i@298@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@297@01)
      ($SortWrappers.IntTo$Snap i@298@01))))) x@297@01 i@298@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@147@10@148@66-aux|)))
(assert (forall ((x@297@01 $Ref) (i@298@01 Int)) (!
  (and
    (or (Set_in x@297@01 xs@284@01) (not (Set_in x@297@01 xs@284@01)))
    (=>
      (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))
      (and
        (Set_in x@297@01 xs@284@01)
        (Seq_contains is@285@01 i@298@01)
        (=>
          (and
            (and (img@293@01 x@297@01 i@298@01) (img@295@01 x@297@01 i@298@01))
            (and
              (Set_in (inv@292@01 x@297@01 i@298@01) xs@284@01)
              (Seq_contains is@285@01 (inv@294@01 x@297@01 i@298@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@297@01)
                  ($SortWrappers.IntTo$Snap i@298@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@297@01)
                ($SortWrappers.IntTo$Snap i@298@01)))
              ($PSF.lookup_pair $t@291@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@297@01)
                ($SortWrappers.IntTo$Snap i@298@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@297@01)
          ($SortWrappers.IntTo$Snap i@298@01))) x@297@01 i@298@01)
        (=
          ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@297@01)
              ($SortWrappers.IntTo$Snap i@298@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@297@01)
              ($SortWrappers.IntTo$Snap i@298@01))))))
        (not (= x@297@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01))))) x@297@01 i@298@01)))
    (or
      (not (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01)))
      (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))))
  :pattern ((Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))
  :pattern ((Set_in x@297@01 xs@284@01) (Seq_contains_trigger is@285@01 i@298@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@147@10@148@66-aux|)))
(assert (forall ((x@297@01 $Ref) (i@298@01 Int)) (!
  (and
    (or (Set_in x@297@01 xs@284@01) (not (Set_in x@297@01 xs@284@01)))
    (=>
      (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))
      (and
        (Set_in x@297@01 xs@284@01)
        (Seq_contains is@285@01 i@298@01)
        (=>
          (and
            (and (img@293@01 x@297@01 i@298@01) (img@295@01 x@297@01 i@298@01))
            (and
              (Set_in (inv@292@01 x@297@01 i@298@01) xs@284@01)
              (Seq_contains is@285@01 (inv@294@01 x@297@01 i@298@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@297@01)
                  ($SortWrappers.IntTo$Snap i@298@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@297@01)
                ($SortWrappers.IntTo$Snap i@298@01)))
              ($PSF.lookup_pair $t@291@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@297@01)
                ($SortWrappers.IntTo$Snap i@298@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@297@01)
          ($SortWrappers.IntTo$Snap i@298@01))) x@297@01 i@298@01)
        (=
          ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@297@01)
              ($SortWrappers.IntTo$Snap i@298@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@297@01)
              ($SortWrappers.IntTo$Snap i@298@01))))))
        (not (= x@297@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@297@01)
            ($SortWrappers.IntTo$Snap i@298@01))))) x@297@01 i@298@01)))
    (or
      (not (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01)))
      (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))))
  :pattern ((Set_in x@297@01 xs@284@01) (Seq_contains_trigger is@285@01 i@298@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@147@10@148@66-aux|)))
(assert (forall ((x@297@01 $Ref) (i@298@01 Int)) (!
  (=>
    (and (Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@297@01)
          ($SortWrappers.IntTo$Snap i@298@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@297@01)
          ($SortWrappers.IntTo$Snap i@298@01))))) x@297@01 i@298@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@297@01)
      ($SortWrappers.IntTo$Snap i@298@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@297@01)
      ($SortWrappers.IntTo$Snap i@298@01))))) x@297@01 i@298@01))
  :pattern ((Set_in x@297@01 xs@284@01) (Seq_contains is@285@01 i@298@01))
  :pattern ((Set_in x@297@01 xs@284@01) (Seq_contains_trigger is@285@01 i@298@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@147@10@148@66|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (tx in xs)
(declare-const $t@302@01 $Snap)
(assert (= $t@302@01 $Snap.unit))
; [eval] (tx in xs)
(assert (Set_in tx@286@01 xs@284@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (ti in is)
(declare-const $t@303@01 $Snap)
(assert (= $t@303@01 $Snap.unit))
; [eval] (ti in is)
(assert (Seq_contains is@285@01 ti@287@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; unfold acc(pair(tx, ti), write)
; Precomputing data for removing quantified permissions
(define-fun pTaken@304@01 ((x $Ref) (i Int)) $Perm
  (ite
    (and (= x tx@286@01) (= i ti@287@01))
    ($Perm.min
      (ite
        (and
          (and (img@293@01 x i) (img@295@01 x i))
          (and
            (Set_in (inv@292@01 x i) xs@284@01)
            (Seq_contains is@285@01 (inv@294@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@293@01 x i) (img@295@01 x i))
          (and
            (Set_in (inv@292@01 x i) xs@284@01)
            (Seq_contains is@285@01 (inv@294@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@304@01 x i))
    $Perm.No)
  
  :qid |quant-u-5200|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@304@01 x i) $Perm.No)
  
  :qid |quant-u-5201|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x tx@286@01) (= i ti@287@01))
    (= (- $Perm.Write (pTaken@304@01 x i)) $Perm.No))
  
  :qid |quant-u-5202|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@293@01 tx@286@01 ti@287@01) (img@295@01 tx@286@01 ti@287@01))
    (and
      (Set_in (inv@292@01 tx@286@01 ti@287@01) xs@284@01)
      (Seq_contains is@285@01 (inv@294@01 tx@286@01 ti@287@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap tx@286@01)
          ($SortWrappers.IntTo$Snap ti@287@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@286@01)
        ($SortWrappers.IntTo$Snap ti@287@01)))
      ($PSF.lookup_pair $t@291@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@286@01)
        ($SortWrappers.IntTo$Snap ti@287@01)))))))
(assert (=
  ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@286@01)
    ($SortWrappers.IntTo$Snap ti@287@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@286@01)
      ($SortWrappers.IntTo$Snap ti@287@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@286@01)
      ($SortWrappers.IntTo$Snap ti@287@01)))))))
(assert (not (= tx@286@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (pair%trigger ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@286@01)
  ($SortWrappers.IntTo$Snap ti@287@01))) tx@286@01 ti@287@01))
; [exec]
; tmp := tx.f
(declare-const tmp@305@01 Int)
(assert (=
  tmp@305@01
  ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@286@01)
    ($SortWrappers.IntTo$Snap ti@287@01)))))))
; [exec]
; tx.f := tx.g
(declare-const f@306@01 Int)
(assert (=
  f@306@01
  ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@300@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@286@01)
    ($SortWrappers.IntTo$Snap ti@287@01)))))))
; [exec]
; tx.g := tmp
; [exec]
; fold acc(pair(tx, ti), write)
(assert (pair%trigger ($Snap.combine
  ($SortWrappers.IntTo$Snap f@306@01)
  ($SortWrappers.IntTo$Snap tmp@305@01)) tx@286@01 ti@287@01))
(declare-const sm@307@01 $PSF<pair>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_pair (as sm@307@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@286@01)
    ($SortWrappers.IntTo$Snap ti@287@01)))
  ($Snap.combine
    ($SortWrappers.IntTo$Snap f@306@01)
    ($SortWrappers.IntTo$Snap tmp@305@01))))
; [exec]
; assert (forall x: Ref, i: Int ::
;     { addB(x, i) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
; [eval] (forall x: Ref, i: Int :: { addB(x, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const x@308@01 $Ref)
(declare-const i@309@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 63 | !(x@308@01 in xs@284@01) | live]
; [else-branch: 63 | x@308@01 in xs@284@01 | live]
(push) ; 5
; [then-branch: 63 | !(x@308@01 in xs@284@01)]
(assert (not (Set_in x@308@01 xs@284@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 63 | x@308@01 in xs@284@01]
(assert (Set_in x@308@01 xs@284@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@308@01 xs@284@01) (not (Set_in x@308@01 xs@284@01))))
(push) ; 4
; [then-branch: 64 | x@308@01 in xs@284@01 && i@309@01 in is@285@01 | live]
; [else-branch: 64 | !(x@308@01 in xs@284@01 && i@309@01 in is@285@01) | live]
(push) ; 5
; [then-branch: 64 | x@308@01 in xs@284@01 && i@309@01 in is@285@01]
(assert (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@286@01 x@308@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@310@01 ((x $Ref) (i Int) (x@308@01 $Ref) (i@309@01 Int)) $Perm
  (ite
    (and (= x x@308@01) (= i i@309@01))
    ($Perm.min
      (ite
        (and
          (and (img@293@01 x i) (img@295@01 x i))
          (and
            (Set_in (inv@292@01 x i) xs@284@01)
            (Seq_contains is@285@01 (inv@294@01 x i))))
        (- $Perm.Write (pTaken@304@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@311@01 ((x $Ref) (i Int) (x@308@01 $Ref) (i@309@01 Int)) $Perm
  (ite
    (and (= x x@308@01) (= i i@309@01))
    ($Perm.min
      (ite (and (= x tx@286@01) (= i ti@287@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@310@01 x i x@308@01 i@309@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@293@01 x i) (img@295@01 x i))
          (and
            (Set_in (inv@292@01 x i) xs@284@01)
            (Seq_contains is@285@01 (inv@294@01 x i))))
        (- $Perm.Write (pTaken@304@01 x i))
        $Perm.No)
      (pTaken@310@01 x i x@308@01 i@309@01))
    $Perm.No)
  
  :qid |quant-u-5204|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@310@01 x i x@308@01 i@309@01) $Perm.No)
  
  :qid |quant-u-5205|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@308@01) (= i i@309@01))
    (= (- $Perm.Write (pTaken@310@01 x i x@308@01 i@309@01)) $Perm.No))
  
  :qid |quant-u-5206|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@311@01 tx@286@01 ti@287@01 x@308@01 i@309@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@311@01 x i x@308@01 i@309@01) $Perm.No)
  
  :qid |quant-u-5208|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@308@01) (= i i@309@01))
    (=
      (-
        (- $Perm.Write (pTaken@310@01 x i x@308@01 i@309@01))
        (pTaken@311@01 x i x@308@01 i@309@01))
      $Perm.No))
  
  :qid |quant-u-5209|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@312@01 $PSF<pair>)
(declare-const s@313@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@308@01 tx@286@01) (= i@309@01 ti@287@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01)))
      ($PSF.lookup_pair (as sm@307@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01)))))))
(assert (=>
  (ite
    (and
      (and (img@293@01 x@308@01 i@309@01) (img@295@01 x@308@01 i@309@01))
      (and
        (Set_in (inv@292@01 x@308@01 i@309@01) xs@284@01)
        (Seq_contains is@285@01 (inv@294@01 x@308@01 i@309@01))))
    (< $Perm.No (- $Perm.Write (pTaken@304@01 x@308@01 i@309@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01)))
      ($PSF.lookup_pair $t@291@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@308@01)
  ($SortWrappers.IntTo$Snap i@309@01))) x@308@01 i@309@01))
(assert (=
  ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@308@01)
    ($SortWrappers.IntTo$Snap i@309@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01)))))))
(assert (not (= x@308@01 $Ref.null)))
; [eval] 0 < addB(x, i)
; [eval] addB(x, i)
(set-option :timeout 0)
(push) ; 7
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@308@01)
    ($SortWrappers.IntTo$Snap i@309@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@308@01)
    ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01))
(pop) ; 7
; Joined path conditions
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@308@01)
    ($SortWrappers.IntTo$Snap i@309@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@308@01)
    ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@308@01 tx@286@01) (= i@309@01 ti@287@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01)))
        ($PSF.lookup_pair (as sm@307@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))))))
  (=>
    (ite
      (and
        (and (img@293@01 x@308@01 i@309@01) (img@295@01 x@308@01 i@309@01))
        (and
          (Set_in (inv@292@01 x@308@01 i@309@01) xs@284@01)
          (Seq_contains is@285@01 (inv@294@01 x@308@01 i@309@01))))
      (< $Perm.No (- $Perm.Write (pTaken@304@01 x@308@01 i@309@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01)))
        ($PSF.lookup_pair $t@291@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@308@01)
    ($SortWrappers.IntTo$Snap i@309@01))) x@308@01 i@309@01)
  (=
    ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01))))))
  (not (= x@308@01 $Ref.null))
  (addB%precondition ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 64 | !(x@308@01 in xs@284@01 && i@309@01 in is@285@01)]
(assert (not (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01))
  (and
    (Set_in x@308@01 xs@284@01)
    (Seq_contains is@285@01 i@309@01)
    (=>
      (and (= x@308@01 tx@286@01) (= i@309@01 ti@287@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@308@01)
              ($SortWrappers.IntTo$Snap i@309@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01)))
          ($PSF.lookup_pair (as sm@307@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01))))))
    (=>
      (ite
        (and
          (and (img@293@01 x@308@01 i@309@01) (img@295@01 x@308@01 i@309@01))
          (and
            (Set_in (inv@292@01 x@308@01 i@309@01) xs@284@01)
            (Seq_contains is@285@01 (inv@294@01 x@308@01 i@309@01))))
        (< $Perm.No (- $Perm.Write (pTaken@304@01 x@308@01 i@309@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@308@01)
              ($SortWrappers.IntTo$Snap i@309@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01)))
          ($PSF.lookup_pair $t@291@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))) x@308@01 i@309@01)
    (=
      ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))))))
    (not (= x@308@01 $Ref.null))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01)))
  (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@308@01 $Ref) (i@309@01 Int)) (!
  (and
    (or (Set_in x@308@01 xs@284@01) (not (Set_in x@308@01 xs@284@01)))
    (=>
      (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01))
      (and
        (Set_in x@308@01 xs@284@01)
        (Seq_contains is@285@01 i@309@01)
        (=>
          (and (= x@308@01 tx@286@01) (= i@309@01 ti@287@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@308@01)
                  ($SortWrappers.IntTo$Snap i@309@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@308@01)
                ($SortWrappers.IntTo$Snap i@309@01)))
              ($PSF.lookup_pair (as sm@307@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@308@01)
                ($SortWrappers.IntTo$Snap i@309@01))))))
        (=>
          (ite
            (and
              (and (img@293@01 x@308@01 i@309@01) (img@295@01 x@308@01 i@309@01))
              (and
                (Set_in (inv@292@01 x@308@01 i@309@01) xs@284@01)
                (Seq_contains is@285@01 (inv@294@01 x@308@01 i@309@01))))
            (< $Perm.No (- $Perm.Write (pTaken@304@01 x@308@01 i@309@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@308@01)
                  ($SortWrappers.IntTo$Snap i@309@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@308@01)
                ($SortWrappers.IntTo$Snap i@309@01)))
              ($PSF.lookup_pair $t@291@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@308@01)
                ($SortWrappers.IntTo$Snap i@309@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))) x@308@01 i@309@01)
        (=
          ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@308@01)
              ($SortWrappers.IntTo$Snap i@309@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@308@01)
              ($SortWrappers.IntTo$Snap i@309@01))))))
        (not (= x@308@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01)))
    (or
      (not (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01)))
      (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01))))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@152@10@153@66-aux|)))
(assert (forall ((x@308@01 $Ref) (i@309@01 Int)) (!
  (=>
    (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@308@01)
        ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@152@10@153@66_precondition|)))
(push) ; 3
(assert (not (forall ((x@308@01 $Ref) (i@309@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@308@01)
            ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01))
      (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01)))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@152@10@153@66|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (forall ((x@308@01 $Ref) (i@309@01 Int)) (!
  (=>
    (and (Set_in x@308@01 xs@284@01) (Seq_contains is@285@01 i@309@01))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@308@01)
          ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@312@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@308@01)
      ($SortWrappers.IntTo$Snap i@309@01))))) x@308@01 i@309@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@152@10@153@66|)))
(pop) ; 2
(pop) ; 1
; ---------- test03c ----------
(declare-const xs@314@01 Set<$Ref>)
(declare-const is@315@01 Seq<Int>)
(declare-const xs@316@01 Set<$Ref>)
(declare-const is@317@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var tx: Ref
(declare-const tx@318@01 $Ref)
; [exec]
; var ti: Int
(declare-const ti@319@01 Int)
; [exec]
; var tmp: Int
(declare-const tmp@320@01 Int)
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@321@01 $Ref)
(declare-const i@322@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 65 | !(x@321@01 in xs@316@01) | live]
; [else-branch: 65 | x@321@01 in xs@316@01 | live]
(push) ; 5
; [then-branch: 65 | !(x@321@01 in xs@316@01)]
(assert (not (Set_in x@321@01 xs@316@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 65 | x@321@01 in xs@316@01]
(assert (Set_in x@321@01 xs@316@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@321@01 xs@316@01) (not (Set_in x@321@01 xs@316@01))))
(assert (and (Set_in x@321@01 xs@316@01) (Seq_contains is@317@01 i@322@01)))
(pop) ; 3
(declare-const $t@323@01 $PSF<pair>)
(declare-fun inv@324@01 ($Ref Int) $Ref)
(declare-fun img@325@01 ($Ref Int) Bool)
(declare-fun inv@326@01 ($Ref Int) Int)
(declare-fun img@327@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@321@01 $Ref) (i@322@01 Int)) (!
  (=>
    (and (Set_in x@321@01 xs@316@01) (Seq_contains is@317@01 i@322@01))
    (or (Set_in x@321@01 xs@316@01) (not (Set_in x@321@01 xs@316@01))))
  :pattern ((Set_in x@321@01 xs@316@01) (Seq_contains is@317@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (Seq_contains_trigger is@317@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (Seq_contains_trigger is@317@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (inv@324@01 x@321@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (inv@326@01 x@321@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (img@325@01 x@321@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (img@327@01 x@321@01 i@322@01))
  :pattern ((Seq_contains is@317@01 i@322@01) (inv@324@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (inv@324@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (inv@324@01 x@321@01 i@322@01))
  :pattern ((Seq_contains is@317@01 i@322@01) (inv@326@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (inv@326@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (inv@326@01 x@321@01 i@322@01))
  :pattern ((Seq_contains is@317@01 i@322@01) (img@325@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (img@325@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (img@325@01 x@321@01 i@322@01))
  :pattern ((Seq_contains is@317@01 i@322@01) (img@327@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (img@327@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (img@327@01 x@321@01 i@322@01))
  :pattern ((inv@324@01 x@321@01 i@322@01))
  :pattern ((inv@326@01 x@321@01 i@322@01))
  :pattern ((img@325@01 x@321@01 i@322@01))
  :pattern ((img@327@01 x@321@01 i@322@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@321@01 $Ref) (i1@322@01 Int) (x2@321@01 $Ref) (i2@322@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@321@01 xs@316@01) (Seq_contains is@317@01 i1@322@01))
      (and (Set_in x2@321@01 xs@316@01) (Seq_contains is@317@01 i2@322@01))
      (and (= x1@321@01 x2@321@01) (= i1@322@01 i2@322@01)))
    (and (= x1@321@01 x2@321@01) (= i1@322@01 i2@322@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@321@01 $Ref) (i@322@01 Int)) (!
  (=>
    (and (Set_in x@321@01 xs@316@01) (Seq_contains is@317@01 i@322@01))
    (and
      (and
        (= (inv@324@01 x@321@01 i@322@01) x@321@01)
        (= (inv@326@01 x@321@01 i@322@01) i@322@01))
      (and (img@325@01 x@321@01 i@322@01) (img@327@01 x@321@01 i@322@01))))
  :pattern ((Set_in x@321@01 xs@316@01) (Seq_contains is@317@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (Seq_contains_trigger is@317@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (Seq_contains_trigger is@317@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (inv@324@01 x@321@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (inv@326@01 x@321@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (img@325@01 x@321@01 i@322@01))
  :pattern ((Set_in x@321@01 xs@316@01) (img@327@01 x@321@01 i@322@01))
  :pattern ((Seq_contains is@317@01 i@322@01) (inv@324@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (inv@324@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (inv@324@01 x@321@01 i@322@01))
  :pattern ((Seq_contains is@317@01 i@322@01) (inv@326@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (inv@326@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (inv@326@01 x@321@01 i@322@01))
  :pattern ((Seq_contains is@317@01 i@322@01) (img@325@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (img@325@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (img@325@01 x@321@01 i@322@01))
  :pattern ((Seq_contains is@317@01 i@322@01) (img@327@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (img@327@01 x@321@01 i@322@01))
  :pattern ((Seq_contains_trigger is@317@01 i@322@01) (img@327@01 x@321@01 i@322@01))
  :pattern ((inv@324@01 x@321@01 i@322@01))
  :pattern ((inv@326@01 x@321@01 i@322@01))
  :pattern ((img@325@01 x@321@01 i@322@01))
  :pattern ((img@327@01 x@321@01 i@322@01))
  :qid |quant-u-5211|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@325@01 x i) (img@327@01 x i))
      (and
        (Set_in (inv@324@01 x i) xs@316@01)
        (Seq_contains is@317@01 (inv@326@01 x i))))
    (and (= (inv@324@01 x i) x) (= (inv@326@01 x i) i)))
  :pattern ((inv@324@01 x i))
  :pattern ((inv@326@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { addB(x, i) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const $t@328@01 $Snap)
(assert (= $t@328@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { addB(x, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const x@329@01 $Ref)
(declare-const i@330@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 66 | !(x@329@01 in xs@316@01) | live]
; [else-branch: 66 | x@329@01 in xs@316@01 | live]
(push) ; 5
; [then-branch: 66 | !(x@329@01 in xs@316@01)]
(assert (not (Set_in x@329@01 xs@316@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 66 | x@329@01 in xs@316@01]
(assert (Set_in x@329@01 xs@316@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@329@01 xs@316@01) (not (Set_in x@329@01 xs@316@01))))
(push) ; 4
; [then-branch: 67 | x@329@01 in xs@316@01 && i@330@01 in is@317@01 | live]
; [else-branch: 67 | !(x@329@01 in xs@316@01 && i@330@01 in is@317@01) | live]
(push) ; 5
; [then-branch: 67 | x@329@01 in xs@316@01 && i@330@01 in is@317@01]
(assert (and (Set_in x@329@01 xs@316@01) (Seq_contains is@317@01 i@330@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@331@01 ((x $Ref) (i Int) (x@329@01 $Ref) (i@330@01 Int)) $Perm
  (ite
    (and (= x x@329@01) (= i i@330@01))
    ($Perm.min
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@331@01 x i x@329@01 i@330@01))
    $Perm.No)
  
  :qid |quant-u-5213|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@331@01 x i x@329@01 i@330@01) $Perm.No)
  
  :qid |quant-u-5214|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@329@01) (= i i@330@01))
    (= (- $Perm.Write (pTaken@331@01 x i x@329@01 i@330@01)) $Perm.No))
  
  :qid |quant-u-5215|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@332@01 $PSF<pair>)
(declare-const s@333@01 $Snap)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@325@01 x@329@01 i@330@01) (img@327@01 x@329@01 i@330@01))
    (and
      (Set_in (inv@324@01 x@329@01 i@330@01) xs@316@01)
      (Seq_contains is@317@01 (inv@326@01 x@329@01 i@330@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@329@01)
          ($SortWrappers.IntTo$Snap i@330@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@329@01)
        ($SortWrappers.IntTo$Snap i@330@01)))
      ($PSF.lookup_pair $t@323@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@329@01)
        ($SortWrappers.IntTo$Snap i@330@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@329@01)
  ($SortWrappers.IntTo$Snap i@330@01))) x@329@01 i@330@01))
(assert (=
  ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@329@01)
    ($SortWrappers.IntTo$Snap i@330@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@329@01)
      ($SortWrappers.IntTo$Snap i@330@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@329@01)
      ($SortWrappers.IntTo$Snap i@330@01)))))))
(assert (not (= x@329@01 $Ref.null)))
; [eval] 0 < addB(x, i)
; [eval] addB(x, i)
(set-option :timeout 0)
(push) ; 7
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@329@01)
    ($SortWrappers.IntTo$Snap i@330@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@329@01)
    ($SortWrappers.IntTo$Snap i@330@01))))) x@329@01 i@330@01))
(pop) ; 7
; Joined path conditions
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@329@01)
    ($SortWrappers.IntTo$Snap i@330@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@329@01)
    ($SortWrappers.IntTo$Snap i@330@01))))) x@329@01 i@330@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@325@01 x@329@01 i@330@01) (img@327@01 x@329@01 i@330@01))
      (and
        (Set_in (inv@324@01 x@329@01 i@330@01) xs@316@01)
        (Seq_contains is@317@01 (inv@326@01 x@329@01 i@330@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@329@01)
            ($SortWrappers.IntTo$Snap i@330@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@329@01)
          ($SortWrappers.IntTo$Snap i@330@01)))
        ($PSF.lookup_pair $t@323@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@329@01)
          ($SortWrappers.IntTo$Snap i@330@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@329@01)
    ($SortWrappers.IntTo$Snap i@330@01))) x@329@01 i@330@01)
  (=
    ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@329@01)
      ($SortWrappers.IntTo$Snap i@330@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@329@01)
        ($SortWrappers.IntTo$Snap i@330@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@329@01)
        ($SortWrappers.IntTo$Snap i@330@01))))))
  (not (= x@329@01 $Ref.null))
  (addB%precondition ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@329@01)
      ($SortWrappers.IntTo$Snap i@330@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@329@01)
      ($SortWrappers.IntTo$Snap i@330@01))))) x@329@01 i@330@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 67 | !(x@329@01 in xs@316@01 && i@330@01 in is@317@01)]
(assert (not (and (Set_in x@329@01 xs@316@01) (Seq_contains is@317@01 i@330@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@329@01 xs@316@01) (Seq_contains is@317@01 i@330@01))
  (and
    (Set_in x@329@01 xs@316@01)
    (Seq_contains is@317@01 i@330@01)
    (=>
      (and
        (and (img@325@01 x@329@01 i@330@01) (img@327@01 x@329@01 i@330@01))
        (and
          (Set_in (inv@324@01 x@329@01 i@330@01) xs@316@01)
          (Seq_contains is@317@01 (inv@326@01 x@329@01 i@330@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@329@01)
              ($SortWrappers.IntTo$Snap i@330@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@329@01)
            ($SortWrappers.IntTo$Snap i@330@01)))
          ($PSF.lookup_pair $t@323@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@329@01)
            ($SortWrappers.IntTo$Snap i@330@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@329@01)
      ($SortWrappers.IntTo$Snap i@330@01))) x@329@01 i@330@01)
    (=
      ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@329@01)
        ($SortWrappers.IntTo$Snap i@330@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@329@01)
          ($SortWrappers.IntTo$Snap i@330@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@329@01)
          ($SortWrappers.IntTo$Snap i@330@01))))))
    (not (= x@329@01 $Ref.null))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@329@01)
        ($SortWrappers.IntTo$Snap i@330@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@329@01)
        ($SortWrappers.IntTo$Snap i@330@01))))) x@329@01 i@330@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@329@01 xs@316@01) (Seq_contains is@317@01 i@330@01)))
  (and (Set_in x@329@01 xs@316@01) (Seq_contains is@317@01 i@330@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@329@01 $Ref) (i@330@01 Int)) (!
  (and
    (or (Set_in x@329@01 xs@316@01) (not (Set_in x@329@01 xs@316@01)))
    (=>
      (and (Set_in x@329@01 xs@316@01) (Seq_contains is@317@01 i@330@01))
      (and
        (Set_in x@329@01 xs@316@01)
        (Seq_contains is@317@01 i@330@01)
        (=>
          (and
            (and (img@325@01 x@329@01 i@330@01) (img@327@01 x@329@01 i@330@01))
            (and
              (Set_in (inv@324@01 x@329@01 i@330@01) xs@316@01)
              (Seq_contains is@317@01 (inv@326@01 x@329@01 i@330@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@329@01)
                  ($SortWrappers.IntTo$Snap i@330@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@329@01)
                ($SortWrappers.IntTo$Snap i@330@01)))
              ($PSF.lookup_pair $t@323@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@329@01)
                ($SortWrappers.IntTo$Snap i@330@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@329@01)
          ($SortWrappers.IntTo$Snap i@330@01))) x@329@01 i@330@01)
        (=
          ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@329@01)
            ($SortWrappers.IntTo$Snap i@330@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@329@01)
              ($SortWrappers.IntTo$Snap i@330@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@329@01)
              ($SortWrappers.IntTo$Snap i@330@01))))))
        (not (= x@329@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@329@01)
            ($SortWrappers.IntTo$Snap i@330@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@329@01)
            ($SortWrappers.IntTo$Snap i@330@01))))) x@329@01 i@330@01)))
    (or
      (not (and (Set_in x@329@01 xs@316@01) (Seq_contains is@317@01 i@330@01)))
      (and (Set_in x@329@01 xs@316@01) (Seq_contains is@317@01 i@330@01))))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@329@01)
      ($SortWrappers.IntTo$Snap i@330@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@329@01)
      ($SortWrappers.IntTo$Snap i@330@01))))) x@329@01 i@330@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@159@10@160@66-aux|)))
(assert (forall ((x@329@01 $Ref) (i@330@01 Int)) (!
  (=>
    (and (Set_in x@329@01 xs@316@01) (Seq_contains is@317@01 i@330@01))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@329@01)
          ($SortWrappers.IntTo$Snap i@330@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@329@01)
          ($SortWrappers.IntTo$Snap i@330@01))))) x@329@01 i@330@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@329@01)
      ($SortWrappers.IntTo$Snap i@330@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@329@01)
      ($SortWrappers.IntTo$Snap i@330@01))))) x@329@01 i@330@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@159@10@160@66|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (tx in xs)
(declare-const $t@334@01 $Snap)
(assert (= $t@334@01 $Snap.unit))
; [eval] (tx in xs)
(assert (Set_in tx@318@01 xs@316@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (ti in is)
(declare-const $t@335@01 $Snap)
(assert (= $t@335@01 $Snap.unit))
; [eval] (ti in is)
(assert (Seq_contains is@317@01 ti@319@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; unfold acc(pair(tx, ti), write)
; Precomputing data for removing quantified permissions
(define-fun pTaken@336@01 ((x $Ref) (i Int)) $Perm
  (ite
    (and (= x tx@318@01) (= i ti@319@01))
    ($Perm.min
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@336@01 x i))
    $Perm.No)
  
  :qid |quant-u-5217|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@336@01 x i) $Perm.No)
  
  :qid |quant-u-5218|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x tx@318@01) (= i ti@319@01))
    (= (- $Perm.Write (pTaken@336@01 x i)) $Perm.No))
  
  :qid |quant-u-5219|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@325@01 tx@318@01 ti@319@01) (img@327@01 tx@318@01 ti@319@01))
    (and
      (Set_in (inv@324@01 tx@318@01 ti@319@01) xs@316@01)
      (Seq_contains is@317@01 (inv@326@01 tx@318@01 ti@319@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap tx@318@01)
          ($SortWrappers.IntTo$Snap ti@319@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@318@01)
        ($SortWrappers.IntTo$Snap ti@319@01)))
      ($PSF.lookup_pair $t@323@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@318@01)
        ($SortWrappers.IntTo$Snap ti@319@01)))))))
(assert (=
  ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@318@01)
    ($SortWrappers.IntTo$Snap ti@319@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@318@01)
      ($SortWrappers.IntTo$Snap ti@319@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@318@01)
      ($SortWrappers.IntTo$Snap ti@319@01)))))))
(assert (not (= tx@318@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (pair%trigger ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@318@01)
  ($SortWrappers.IntTo$Snap ti@319@01))) tx@318@01 ti@319@01))
; [exec]
; tmp := tx.f
(declare-const tmp@337@01 Int)
(assert (=
  tmp@337@01
  ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@318@01)
    ($SortWrappers.IntTo$Snap ti@319@01)))))))
; [exec]
; tx.f := tx.g
(declare-const f@338@01 Int)
(assert (=
  f@338@01
  ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@332@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@318@01)
    ($SortWrappers.IntTo$Snap ti@319@01)))))))
; [exec]
; tx.g := tmp
; [exec]
; fold acc(pair(tx, ti), write)
(assert (pair%trigger ($Snap.combine
  ($SortWrappers.IntTo$Snap f@338@01)
  ($SortWrappers.IntTo$Snap tmp@337@01)) tx@318@01 ti@319@01))
(declare-const sm@339@01 $PSF<pair>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@318@01)
    ($SortWrappers.IntTo$Snap ti@319@01)))
  ($Snap.combine
    ($SortWrappers.IntTo$Snap f@338@01)
    ($SortWrappers.IntTo$Snap tmp@337@01))))
; [exec]
; assert (forall x: Ref, i: Int ::
;     { addB(x, i) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
; [eval] (forall x: Ref, i: Int :: { addB(x, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const x@340@01 $Ref)
(declare-const i@341@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 68 | !(x@340@01 in xs@316@01) | live]
; [else-branch: 68 | x@340@01 in xs@316@01 | live]
(push) ; 5
; [then-branch: 68 | !(x@340@01 in xs@316@01)]
(assert (not (Set_in x@340@01 xs@316@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 68 | x@340@01 in xs@316@01]
(assert (Set_in x@340@01 xs@316@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@340@01 xs@316@01) (not (Set_in x@340@01 xs@316@01))))
(push) ; 4
; [then-branch: 69 | x@340@01 in xs@316@01 && i@341@01 in is@317@01 | live]
; [else-branch: 69 | !(x@340@01 in xs@316@01 && i@341@01 in is@317@01) | live]
(push) ; 5
; [then-branch: 69 | x@340@01 in xs@316@01 && i@341@01 in is@317@01]
(assert (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@318@01 x@340@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@342@01 ((x $Ref) (i Int) (x@340@01 $Ref) (i@341@01 Int)) $Perm
  (ite
    (and (= x x@340@01) (= i i@341@01))
    ($Perm.min
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        (- $Perm.Write (pTaken@336@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@343@01 ((x $Ref) (i Int) (x@340@01 $Ref) (i@341@01 Int)) $Perm
  (ite
    (and (= x x@340@01) (= i i@341@01))
    ($Perm.min
      (ite (and (= x tx@318@01) (= i ti@319@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@342@01 x i x@340@01 i@341@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        (- $Perm.Write (pTaken@336@01 x i))
        $Perm.No)
      (pTaken@342@01 x i x@340@01 i@341@01))
    $Perm.No)
  
  :qid |quant-u-5221|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@342@01 x i x@340@01 i@341@01) $Perm.No)
  
  :qid |quant-u-5222|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@340@01) (= i i@341@01))
    (= (- $Perm.Write (pTaken@342@01 x i x@340@01 i@341@01)) $Perm.No))
  
  :qid |quant-u-5223|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@343@01 tx@318@01 ti@319@01 x@340@01 i@341@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@343@01 x i x@340@01 i@341@01) $Perm.No)
  
  :qid |quant-u-5225|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@340@01) (= i i@341@01))
    (=
      (-
        (- $Perm.Write (pTaken@342@01 x i x@340@01 i@341@01))
        (pTaken@343@01 x i x@340@01 i@341@01))
      $Perm.No))
  
  :qid |quant-u-5226|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@344@01 $PSF<pair>)
(declare-const s@345@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@340@01 tx@318@01) (= i@341@01 ti@319@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01)))
      ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01)))))))
(assert (=>
  (ite
    (and
      (and (img@325@01 x@340@01 i@341@01) (img@327@01 x@340@01 i@341@01))
      (and
        (Set_in (inv@324@01 x@340@01 i@341@01) xs@316@01)
        (Seq_contains is@317@01 (inv@326@01 x@340@01 i@341@01))))
    (< $Perm.No (- $Perm.Write (pTaken@336@01 x@340@01 i@341@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01)))
      ($PSF.lookup_pair $t@323@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@340@01)
  ($SortWrappers.IntTo$Snap i@341@01))) x@340@01 i@341@01))
(assert (=
  ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@340@01)
    ($SortWrappers.IntTo$Snap i@341@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01)))))))
(assert (not (= x@340@01 $Ref.null)))
; [eval] 0 < addB(x, i)
; [eval] addB(x, i)
(set-option :timeout 0)
(push) ; 7
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@340@01)
    ($SortWrappers.IntTo$Snap i@341@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@340@01)
    ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01))
(pop) ; 7
; Joined path conditions
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@340@01)
    ($SortWrappers.IntTo$Snap i@341@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@340@01)
    ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@340@01 tx@318@01) (= i@341@01 ti@319@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01)))
        ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01))))))
  (=>
    (ite
      (and
        (and (img@325@01 x@340@01 i@341@01) (img@327@01 x@340@01 i@341@01))
        (and
          (Set_in (inv@324@01 x@340@01 i@341@01) xs@316@01)
          (Seq_contains is@317@01 (inv@326@01 x@340@01 i@341@01))))
      (< $Perm.No (- $Perm.Write (pTaken@336@01 x@340@01 i@341@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01)))
        ($PSF.lookup_pair $t@323@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@340@01)
    ($SortWrappers.IntTo$Snap i@341@01))) x@340@01 i@341@01)
  (=
    ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01))))))
  (not (= x@340@01 $Ref.null))
  (addB%precondition ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 69 | !(x@340@01 in xs@316@01 && i@341@01 in is@317@01)]
(assert (not (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01))
  (and
    (Set_in x@340@01 xs@316@01)
    (Seq_contains is@317@01 i@341@01)
    (=>
      (and (= x@340@01 tx@318@01) (= i@341@01 ti@319@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@340@01)
              ($SortWrappers.IntTo$Snap i@341@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01)))
          ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01))))))
    (=>
      (ite
        (and
          (and (img@325@01 x@340@01 i@341@01) (img@327@01 x@340@01 i@341@01))
          (and
            (Set_in (inv@324@01 x@340@01 i@341@01) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x@340@01 i@341@01))))
        (< $Perm.No (- $Perm.Write (pTaken@336@01 x@340@01 i@341@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@340@01)
              ($SortWrappers.IntTo$Snap i@341@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01)))
          ($PSF.lookup_pair $t@323@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01))) x@340@01 i@341@01)
    (=
      ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01))))))
    (not (= x@340@01 $Ref.null))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01)))
  (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@340@01 $Ref) (i@341@01 Int)) (!
  (and
    (or (Set_in x@340@01 xs@316@01) (not (Set_in x@340@01 xs@316@01)))
    (=>
      (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01))
      (and
        (Set_in x@340@01 xs@316@01)
        (Seq_contains is@317@01 i@341@01)
        (=>
          (and (= x@340@01 tx@318@01) (= i@341@01 ti@319@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@340@01)
                  ($SortWrappers.IntTo$Snap i@341@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@340@01)
                ($SortWrappers.IntTo$Snap i@341@01)))
              ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@340@01)
                ($SortWrappers.IntTo$Snap i@341@01))))))
        (=>
          (ite
            (and
              (and (img@325@01 x@340@01 i@341@01) (img@327@01 x@340@01 i@341@01))
              (and
                (Set_in (inv@324@01 x@340@01 i@341@01) xs@316@01)
                (Seq_contains is@317@01 (inv@326@01 x@340@01 i@341@01))))
            (< $Perm.No (- $Perm.Write (pTaken@336@01 x@340@01 i@341@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@340@01)
                  ($SortWrappers.IntTo$Snap i@341@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@340@01)
                ($SortWrappers.IntTo$Snap i@341@01)))
              ($PSF.lookup_pair $t@323@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@340@01)
                ($SortWrappers.IntTo$Snap i@341@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01))) x@340@01 i@341@01)
        (=
          ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@340@01)
              ($SortWrappers.IntTo$Snap i@341@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@340@01)
              ($SortWrappers.IntTo$Snap i@341@01))))))
        (not (= x@340@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01)))
    (or
      (not (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01)))
      (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01))))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66-aux|)))
(assert (forall ((x@340@01 $Ref) (i@341@01 Int)) (!
  (=>
    (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@340@01)
        ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66_precondition|)))
(push) ; 3
(assert (not (forall ((x@340@01 $Ref) (i@341@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@340@01)
            ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01))
      (and (Set_in x@340@01 xs@316@01) (Seq_contains is@317@01 i@341@01)))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@340@01)
          ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@344@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@340@01)
      ($SortWrappers.IntTo$Snap i@341@01))))) x@340@01 i@341@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { addB(x, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const x@346@01 $Ref)
(declare-const i@347@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 70 | !(x@346@01 in xs@316@01) | live]
; [else-branch: 70 | x@346@01 in xs@316@01 | live]
(push) ; 5
; [then-branch: 70 | !(x@346@01 in xs@316@01)]
(assert (not (Set_in x@346@01 xs@316@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 70 | x@346@01 in xs@316@01]
(assert (Set_in x@346@01 xs@316@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@346@01 xs@316@01) (not (Set_in x@346@01 xs@316@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 71 | x@346@01 in xs@316@01 && i@347@01 in is@317@01 | live]
; [else-branch: 71 | !(x@346@01 in xs@316@01 && i@347@01 in is@317@01) | live]
(push) ; 5
; [then-branch: 71 | x@346@01 in xs@316@01 && i@347@01 in is@317@01]
(assert (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
(set-option :timeout 0)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@318@01 x@346@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@348@01 ((x $Ref) (i Int) (x@346@01 $Ref) (i@347@01 Int)) $Perm
  (ite
    (and (= x x@346@01) (= i i@347@01))
    ($Perm.min
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        (- $Perm.Write (pTaken@336@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@349@01 ((x $Ref) (i Int) (x@346@01 $Ref) (i@347@01 Int)) $Perm
  (ite
    (and (= x x@346@01) (= i i@347@01))
    ($Perm.min
      (ite (and (= x tx@318@01) (= i ti@319@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@348@01 x i x@346@01 i@347@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        (- $Perm.Write (pTaken@336@01 x i))
        $Perm.No)
      (pTaken@348@01 x i x@346@01 i@347@01))
    $Perm.No)
  
  :qid |quant-u-5228|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@348@01 x i x@346@01 i@347@01) $Perm.No)
  
  :qid |quant-u-5229|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@346@01) (= i i@347@01))
    (= (- $Perm.Write (pTaken@348@01 x i x@346@01 i@347@01)) $Perm.No))
  
  :qid |quant-u-5230|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@349@01 tx@318@01 ti@319@01 x@346@01 i@347@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@349@01 x i x@346@01 i@347@01) $Perm.No)
  
  :qid |quant-u-5232|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@346@01) (= i i@347@01))
    (=
      (-
        (- $Perm.Write (pTaken@348@01 x i x@346@01 i@347@01))
        (pTaken@349@01 x i x@346@01 i@347@01))
      $Perm.No))
  
  :qid |quant-u-5233|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@350@01 $PSF<pair>)
(declare-const s@351@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@346@01 tx@318@01) (= i@347@01 ti@319@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01)))
      ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01)))))))
(assert (=>
  (ite
    (and
      (and (img@325@01 x@346@01 i@347@01) (img@327@01 x@346@01 i@347@01))
      (and
        (Set_in (inv@324@01 x@346@01 i@347@01) xs@316@01)
        (Seq_contains is@317@01 (inv@326@01 x@346@01 i@347@01))))
    (< $Perm.No (- $Perm.Write (pTaken@336@01 x@346@01 i@347@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01)))
      ($PSF.lookup_pair $t@323@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@346@01)
  ($SortWrappers.IntTo$Snap i@347@01))) x@346@01 i@347@01))
(assert (=
  ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@346@01)
    ($SortWrappers.IntTo$Snap i@347@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01)))))))
(assert (not (= x@346@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addB(x, i)
; [eval] addB(x, i)
(set-option :timeout 0)
(push) ; 7
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@346@01)
    ($SortWrappers.IntTo$Snap i@347@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@346@01)
    ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01))
(pop) ; 7
; Joined path conditions
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@346@01)
    ($SortWrappers.IntTo$Snap i@347@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@346@01)
    ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@346@01 tx@318@01) (= i@347@01 ti@319@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01)))
        ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01))))))
  (=>
    (ite
      (and
        (and (img@325@01 x@346@01 i@347@01) (img@327@01 x@346@01 i@347@01))
        (and
          (Set_in (inv@324@01 x@346@01 i@347@01) xs@316@01)
          (Seq_contains is@317@01 (inv@326@01 x@346@01 i@347@01))))
      (< $Perm.No (- $Perm.Write (pTaken@336@01 x@346@01 i@347@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01)))
        ($PSF.lookup_pair $t@323@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@346@01)
    ($SortWrappers.IntTo$Snap i@347@01))) x@346@01 i@347@01)
  (=
    ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01))))))
  (not (= x@346@01 $Ref.null))
  (addB%precondition ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 71 | !(x@346@01 in xs@316@01 && i@347@01 in is@317@01)]
(assert (not (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01))
  (and
    (Set_in x@346@01 xs@316@01)
    (Seq_contains is@317@01 i@347@01)
    (=>
      (and (= x@346@01 tx@318@01) (= i@347@01 ti@319@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@346@01)
              ($SortWrappers.IntTo$Snap i@347@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01)))
          ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01))))))
    (=>
      (ite
        (and
          (and (img@325@01 x@346@01 i@347@01) (img@327@01 x@346@01 i@347@01))
          (and
            (Set_in (inv@324@01 x@346@01 i@347@01) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x@346@01 i@347@01))))
        (< $Perm.No (- $Perm.Write (pTaken@336@01 x@346@01 i@347@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@346@01)
              ($SortWrappers.IntTo$Snap i@347@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01)))
          ($PSF.lookup_pair $t@323@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01))) x@346@01 i@347@01)
    (=
      ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01))))))
    (not (= x@346@01 $Ref.null))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01)))
  (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@346@01 $Ref) (i@347@01 Int)) (!
  (and
    (or (Set_in x@346@01 xs@316@01) (not (Set_in x@346@01 xs@316@01)))
    (=>
      (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01))
      (and
        (Set_in x@346@01 xs@316@01)
        (Seq_contains is@317@01 i@347@01)
        (=>
          (and (= x@346@01 tx@318@01) (= i@347@01 ti@319@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@346@01)
                  ($SortWrappers.IntTo$Snap i@347@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@346@01)
                ($SortWrappers.IntTo$Snap i@347@01)))
              ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@346@01)
                ($SortWrappers.IntTo$Snap i@347@01))))))
        (=>
          (ite
            (and
              (and (img@325@01 x@346@01 i@347@01) (img@327@01 x@346@01 i@347@01))
              (and
                (Set_in (inv@324@01 x@346@01 i@347@01) xs@316@01)
                (Seq_contains is@317@01 (inv@326@01 x@346@01 i@347@01))))
            (< $Perm.No (- $Perm.Write (pTaken@336@01 x@346@01 i@347@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@346@01)
                  ($SortWrappers.IntTo$Snap i@347@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@346@01)
                ($SortWrappers.IntTo$Snap i@347@01)))
              ($PSF.lookup_pair $t@323@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@346@01)
                ($SortWrappers.IntTo$Snap i@347@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01))) x@346@01 i@347@01)
        (=
          ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@346@01)
              ($SortWrappers.IntTo$Snap i@347@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@346@01)
              ($SortWrappers.IntTo$Snap i@347@01))))))
        (not (= x@346@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01)))
    (or
      (not (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01)))
      (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01))))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66-aux|)))
(assert (forall ((x@346@01 $Ref) (i@347@01 Int)) (!
  (=>
    (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@346@01)
        ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@346@01 $Ref) (i@347@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@346@01)
            ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01))
      (and (Set_in x@346@01 xs@316@01) (Seq_contains is@317@01 i@347@01)))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@346@01)
          ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@350@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@346@01)
      ($SortWrappers.IntTo$Snap i@347@01))))) x@346@01 i@347@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { addB(x, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const x@352@01 $Ref)
(declare-const i@353@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 72 | !(x@352@01 in xs@316@01) | live]
; [else-branch: 72 | x@352@01 in xs@316@01 | live]
(push) ; 5
; [then-branch: 72 | !(x@352@01 in xs@316@01)]
(assert (not (Set_in x@352@01 xs@316@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 72 | x@352@01 in xs@316@01]
(assert (Set_in x@352@01 xs@316@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@352@01 xs@316@01) (not (Set_in x@352@01 xs@316@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 73 | x@352@01 in xs@316@01 && i@353@01 in is@317@01 | live]
; [else-branch: 73 | !(x@352@01 in xs@316@01 && i@353@01 in is@317@01) | live]
(push) ; 5
; [then-branch: 73 | x@352@01 in xs@316@01 && i@353@01 in is@317@01]
(assert (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
(set-option :timeout 0)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@318@01 x@352@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@354@01 ((x $Ref) (i Int) (x@352@01 $Ref) (i@353@01 Int)) $Perm
  (ite
    (and (= x x@352@01) (= i i@353@01))
    ($Perm.min
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        (- $Perm.Write (pTaken@336@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@355@01 ((x $Ref) (i Int) (x@352@01 $Ref) (i@353@01 Int)) $Perm
  (ite
    (and (= x x@352@01) (= i i@353@01))
    ($Perm.min
      (ite (and (= x tx@318@01) (= i ti@319@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@354@01 x i x@352@01 i@353@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        (- $Perm.Write (pTaken@336@01 x i))
        $Perm.No)
      (pTaken@354@01 x i x@352@01 i@353@01))
    $Perm.No)
  
  :qid |quant-u-5235|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@354@01 x i x@352@01 i@353@01) $Perm.No)
  
  :qid |quant-u-5236|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@352@01) (= i i@353@01))
    (= (- $Perm.Write (pTaken@354@01 x i x@352@01 i@353@01)) $Perm.No))
  
  :qid |quant-u-5237|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@355@01 tx@318@01 ti@319@01 x@352@01 i@353@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@355@01 x i x@352@01 i@353@01) $Perm.No)
  
  :qid |quant-u-5239|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@352@01) (= i i@353@01))
    (=
      (-
        (- $Perm.Write (pTaken@354@01 x i x@352@01 i@353@01))
        (pTaken@355@01 x i x@352@01 i@353@01))
      $Perm.No))
  
  :qid |quant-u-5240|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@356@01 $PSF<pair>)
(declare-const s@357@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (ite
    (and
      (and (img@325@01 x@352@01 i@353@01) (img@327@01 x@352@01 i@353@01))
      (and
        (Set_in (inv@324@01 x@352@01 i@353@01) xs@316@01)
        (Seq_contains is@317@01 (inv@326@01 x@352@01 i@353@01))))
    (< $Perm.No (- $Perm.Write (pTaken@336@01 x@352@01 i@353@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01)))
      ($PSF.lookup_pair $t@323@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01)))))))
(assert (=>
  (and (= x@352@01 tx@318@01) (= i@353@01 ti@319@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01)))
      ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@352@01)
  ($SortWrappers.IntTo$Snap i@353@01))) x@352@01 i@353@01))
(assert (=
  ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@352@01)
    ($SortWrappers.IntTo$Snap i@353@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01)))))))
(assert (not (= x@352@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addB(x, i)
; [eval] addB(x, i)
(set-option :timeout 0)
(push) ; 7
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@352@01)
    ($SortWrappers.IntTo$Snap i@353@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@352@01)
    ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01))
(pop) ; 7
; Joined path conditions
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@352@01)
    ($SortWrappers.IntTo$Snap i@353@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@352@01)
    ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (ite
      (and
        (and (img@325@01 x@352@01 i@353@01) (img@327@01 x@352@01 i@353@01))
        (and
          (Set_in (inv@324@01 x@352@01 i@353@01) xs@316@01)
          (Seq_contains is@317@01 (inv@326@01 x@352@01 i@353@01))))
      (< $Perm.No (- $Perm.Write (pTaken@336@01 x@352@01 i@353@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01)))
        ($PSF.lookup_pair $t@323@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01))))))
  (=>
    (and (= x@352@01 tx@318@01) (= i@353@01 ti@319@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01)))
        ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@352@01)
    ($SortWrappers.IntTo$Snap i@353@01))) x@352@01 i@353@01)
  (=
    ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01))))))
  (not (= x@352@01 $Ref.null))
  (addB%precondition ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 73 | !(x@352@01 in xs@316@01 && i@353@01 in is@317@01)]
(assert (not (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01))
  (and
    (Set_in x@352@01 xs@316@01)
    (Seq_contains is@317@01 i@353@01)
    (=>
      (ite
        (and
          (and (img@325@01 x@352@01 i@353@01) (img@327@01 x@352@01 i@353@01))
          (and
            (Set_in (inv@324@01 x@352@01 i@353@01) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x@352@01 i@353@01))))
        (< $Perm.No (- $Perm.Write (pTaken@336@01 x@352@01 i@353@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@352@01)
              ($SortWrappers.IntTo$Snap i@353@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01)))
          ($PSF.lookup_pair $t@323@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01))))))
    (=>
      (and (= x@352@01 tx@318@01) (= i@353@01 ti@319@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@352@01)
              ($SortWrappers.IntTo$Snap i@353@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01)))
          ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01))) x@352@01 i@353@01)
    (=
      ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01))))))
    (not (= x@352@01 $Ref.null))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01)))
  (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@352@01 $Ref) (i@353@01 Int)) (!
  (and
    (or (Set_in x@352@01 xs@316@01) (not (Set_in x@352@01 xs@316@01)))
    (=>
      (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01))
      (and
        (Set_in x@352@01 xs@316@01)
        (Seq_contains is@317@01 i@353@01)
        (=>
          (ite
            (and
              (and (img@325@01 x@352@01 i@353@01) (img@327@01 x@352@01 i@353@01))
              (and
                (Set_in (inv@324@01 x@352@01 i@353@01) xs@316@01)
                (Seq_contains is@317@01 (inv@326@01 x@352@01 i@353@01))))
            (< $Perm.No (- $Perm.Write (pTaken@336@01 x@352@01 i@353@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@352@01)
                  ($SortWrappers.IntTo$Snap i@353@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@352@01)
                ($SortWrappers.IntTo$Snap i@353@01)))
              ($PSF.lookup_pair $t@323@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@352@01)
                ($SortWrappers.IntTo$Snap i@353@01))))))
        (=>
          (and (= x@352@01 tx@318@01) (= i@353@01 ti@319@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@352@01)
                  ($SortWrappers.IntTo$Snap i@353@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@352@01)
                ($SortWrappers.IntTo$Snap i@353@01)))
              ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@352@01)
                ($SortWrappers.IntTo$Snap i@353@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01))) x@352@01 i@353@01)
        (=
          ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@352@01)
              ($SortWrappers.IntTo$Snap i@353@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@352@01)
              ($SortWrappers.IntTo$Snap i@353@01))))))
        (not (= x@352@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01)))
    (or
      (not (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01)))
      (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01))))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66-aux|)))
(assert (forall ((x@352@01 $Ref) (i@353@01 Int)) (!
  (=>
    (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@352@01)
        ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@352@01 $Ref) (i@353@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@352@01)
            ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01))
      (and (Set_in x@352@01 xs@316@01) (Seq_contains is@317@01 i@353@01)))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@352@01)
          ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@356@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@352@01)
      ($SortWrappers.IntTo$Snap i@353@01))))) x@352@01 i@353@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { addB(x, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i)))
(declare-const x@358@01 $Ref)
(declare-const i@359@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 74 | !(x@358@01 in xs@316@01) | live]
; [else-branch: 74 | x@358@01 in xs@316@01 | live]
(push) ; 5
; [then-branch: 74 | !(x@358@01 in xs@316@01)]
(assert (not (Set_in x@358@01 xs@316@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 74 | x@358@01 in xs@316@01]
(assert (Set_in x@358@01 xs@316@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@358@01 xs@316@01) (not (Set_in x@358@01 xs@316@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 75 | x@358@01 in xs@316@01 && i@359@01 in is@317@01 | live]
; [else-branch: 75 | !(x@358@01 in xs@316@01 && i@359@01 in is@317@01) | live]
(push) ; 5
; [then-branch: 75 | x@358@01 in xs@316@01 && i@359@01 in is@317@01]
(assert (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (unfolding acc(pair(x, i), write) in 0 < addB(x, i))
(set-option :timeout 0)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@318@01 x@358@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@360@01 ((x $Ref) (i Int) (x@358@01 $Ref) (i@359@01 Int)) $Perm
  (ite
    (and (= x x@358@01) (= i i@359@01))
    ($Perm.min
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        (- $Perm.Write (pTaken@336@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@361@01 ((x $Ref) (i Int) (x@358@01 $Ref) (i@359@01 Int)) $Perm
  (ite
    (and (= x x@358@01) (= i i@359@01))
    ($Perm.min
      (ite (and (= x tx@318@01) (= i ti@319@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@360@01 x i x@358@01 i@359@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@325@01 x i) (img@327@01 x i))
          (and
            (Set_in (inv@324@01 x i) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x i))))
        (- $Perm.Write (pTaken@336@01 x i))
        $Perm.No)
      (pTaken@360@01 x i x@358@01 i@359@01))
    $Perm.No)
  
  :qid |quant-u-5242|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@360@01 x i x@358@01 i@359@01) $Perm.No)
  
  :qid |quant-u-5243|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@358@01) (= i i@359@01))
    (= (- $Perm.Write (pTaken@360@01 x i x@358@01 i@359@01)) $Perm.No))
  
  :qid |quant-u-5244|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@361@01 tx@318@01 ti@319@01 x@358@01 i@359@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@361@01 x i x@358@01 i@359@01) $Perm.No)
  
  :qid |quant-u-5246|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@358@01) (= i i@359@01))
    (=
      (-
        (- $Perm.Write (pTaken@360@01 x i x@358@01 i@359@01))
        (pTaken@361@01 x i x@358@01 i@359@01))
      $Perm.No))
  
  :qid |quant-u-5247|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@362@01 $PSF<pair>)
(declare-const s@363@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@358@01 tx@318@01) (= i@359@01 ti@319@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01)))
      ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01)))))))
(assert (=>
  (ite
    (and
      (and (img@325@01 x@358@01 i@359@01) (img@327@01 x@358@01 i@359@01))
      (and
        (Set_in (inv@324@01 x@358@01 i@359@01) xs@316@01)
        (Seq_contains is@317@01 (inv@326@01 x@358@01 i@359@01))))
    (< $Perm.No (- $Perm.Write (pTaken@336@01 x@358@01 i@359@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01)))
      ($PSF.lookup_pair $t@323@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@358@01)
  ($SortWrappers.IntTo$Snap i@359@01))) x@358@01 i@359@01))
(assert (=
  ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@358@01)
    ($SortWrappers.IntTo$Snap i@359@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01)))))))
(assert (not (= x@358@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addB(x, i)
; [eval] addB(x, i)
(set-option :timeout 0)
(push) ; 7
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@358@01)
    ($SortWrappers.IntTo$Snap i@359@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@358@01)
    ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01))
(pop) ; 7
; Joined path conditions
(assert (addB%precondition ($Snap.combine
  ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@358@01)
    ($SortWrappers.IntTo$Snap i@359@01))))
  ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@358@01)
    ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@358@01 tx@318@01) (= i@359@01 ti@319@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01)))
        ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01))))))
  (=>
    (ite
      (and
        (and (img@325@01 x@358@01 i@359@01) (img@327@01 x@358@01 i@359@01))
        (and
          (Set_in (inv@324@01 x@358@01 i@359@01) xs@316@01)
          (Seq_contains is@317@01 (inv@326@01 x@358@01 i@359@01))))
      (< $Perm.No (- $Perm.Write (pTaken@336@01 x@358@01 i@359@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01)))
        ($PSF.lookup_pair $t@323@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@358@01)
    ($SortWrappers.IntTo$Snap i@359@01))) x@358@01 i@359@01)
  (=
    ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01))))))
  (not (= x@358@01 $Ref.null))
  (addB%precondition ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 75 | !(x@358@01 in xs@316@01 && i@359@01 in is@317@01)]
(assert (not (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01))
  (and
    (Set_in x@358@01 xs@316@01)
    (Seq_contains is@317@01 i@359@01)
    (=>
      (and (= x@358@01 tx@318@01) (= i@359@01 ti@319@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@358@01)
              ($SortWrappers.IntTo$Snap i@359@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01)))
          ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01))))))
    (=>
      (ite
        (and
          (and (img@325@01 x@358@01 i@359@01) (img@327@01 x@358@01 i@359@01))
          (and
            (Set_in (inv@324@01 x@358@01 i@359@01) xs@316@01)
            (Seq_contains is@317@01 (inv@326@01 x@358@01 i@359@01))))
        (< $Perm.No (- $Perm.Write (pTaken@336@01 x@358@01 i@359@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@358@01)
              ($SortWrappers.IntTo$Snap i@359@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01)))
          ($PSF.lookup_pair $t@323@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01))) x@358@01 i@359@01)
    (=
      ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01))))))
    (not (= x@358@01 $Ref.null))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01)))
  (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@358@01 $Ref) (i@359@01 Int)) (!
  (and
    (or (Set_in x@358@01 xs@316@01) (not (Set_in x@358@01 xs@316@01)))
    (=>
      (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01))
      (and
        (Set_in x@358@01 xs@316@01)
        (Seq_contains is@317@01 i@359@01)
        (=>
          (and (= x@358@01 tx@318@01) (= i@359@01 ti@319@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@358@01)
                  ($SortWrappers.IntTo$Snap i@359@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@358@01)
                ($SortWrappers.IntTo$Snap i@359@01)))
              ($PSF.lookup_pair (as sm@339@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@358@01)
                ($SortWrappers.IntTo$Snap i@359@01))))))
        (=>
          (ite
            (and
              (and (img@325@01 x@358@01 i@359@01) (img@327@01 x@358@01 i@359@01))
              (and
                (Set_in (inv@324@01 x@358@01 i@359@01) xs@316@01)
                (Seq_contains is@317@01 (inv@326@01 x@358@01 i@359@01))))
            (< $Perm.No (- $Perm.Write (pTaken@336@01 x@358@01 i@359@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@358@01)
                  ($SortWrappers.IntTo$Snap i@359@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@358@01)
                ($SortWrappers.IntTo$Snap i@359@01)))
              ($PSF.lookup_pair $t@323@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@358@01)
                ($SortWrappers.IntTo$Snap i@359@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01))) x@358@01 i@359@01)
        (=
          ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@358@01)
              ($SortWrappers.IntTo$Snap i@359@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@358@01)
              ($SortWrappers.IntTo$Snap i@359@01))))))
        (not (= x@358@01 $Ref.null))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01)))
    (or
      (not (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01)))
      (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01))))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66-aux|)))
(assert (forall ((x@358@01 $Ref) (i@359@01 Int)) (!
  (=>
    (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01))
    (addB%precondition ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@358@01)
        ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@358@01 $Ref) (i@359@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01))
        (addB%precondition ($Snap.combine
          ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01))))
          ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@358@01)
            ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01))
      (and (Set_in x@358@01 xs@316@01) (Seq_contains is@317@01 i@359@01)))
    (<
      0
      (addB ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@358@01)
          ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01)))
  :pattern ((addB%limited ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@362@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@358@01)
      ($SortWrappers.IntTo$Snap i@359@01))))) x@358@01 i@359@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@165@10@166@66|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(pop) ; 2
(pop) ; 1
; ---------- test04a ----------
(declare-const xs@364@01 Set<$Ref>)
(declare-const is@365@01 Seq<Int>)
(declare-const xs@366@01 Set<$Ref>)
(declare-const is@367@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@368@01 $Ref)
(declare-const i@369@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 76 | !(x@368@01 in xs@366@01) | live]
; [else-branch: 76 | x@368@01 in xs@366@01 | live]
(push) ; 5
; [then-branch: 76 | !(x@368@01 in xs@366@01)]
(assert (not (Set_in x@368@01 xs@366@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 76 | x@368@01 in xs@366@01]
(assert (Set_in x@368@01 xs@366@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@368@01 xs@366@01) (not (Set_in x@368@01 xs@366@01))))
(assert (and (Set_in x@368@01 xs@366@01) (Seq_contains is@367@01 i@369@01)))
(pop) ; 3
(declare-const $t@370@01 $PSF<pair>)
(declare-fun inv@371@01 ($Ref Int) $Ref)
(declare-fun img@372@01 ($Ref Int) Bool)
(declare-fun inv@373@01 ($Ref Int) Int)
(declare-fun img@374@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@368@01 $Ref) (i@369@01 Int)) (!
  (=>
    (and (Set_in x@368@01 xs@366@01) (Seq_contains is@367@01 i@369@01))
    (or (Set_in x@368@01 xs@366@01) (not (Set_in x@368@01 xs@366@01))))
  :pattern ((Set_in x@368@01 xs@366@01) (Seq_contains is@367@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (Seq_contains_trigger is@367@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (Seq_contains_trigger is@367@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (inv@371@01 x@368@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (inv@373@01 x@368@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (img@372@01 x@368@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (img@374@01 x@368@01 i@369@01))
  :pattern ((Seq_contains is@367@01 i@369@01) (inv@371@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (inv@371@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (inv@371@01 x@368@01 i@369@01))
  :pattern ((Seq_contains is@367@01 i@369@01) (inv@373@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (inv@373@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (inv@373@01 x@368@01 i@369@01))
  :pattern ((Seq_contains is@367@01 i@369@01) (img@372@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (img@372@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (img@372@01 x@368@01 i@369@01))
  :pattern ((Seq_contains is@367@01 i@369@01) (img@374@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (img@374@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (img@374@01 x@368@01 i@369@01))
  :pattern ((inv@371@01 x@368@01 i@369@01))
  :pattern ((inv@373@01 x@368@01 i@369@01))
  :pattern ((img@372@01 x@368@01 i@369@01))
  :pattern ((img@374@01 x@368@01 i@369@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@368@01 $Ref) (i1@369@01 Int) (x2@368@01 $Ref) (i2@369@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@368@01 xs@366@01) (Seq_contains is@367@01 i1@369@01))
      (and (Set_in x2@368@01 xs@366@01) (Seq_contains is@367@01 i2@369@01))
      (and (= x1@368@01 x2@368@01) (= i1@369@01 i2@369@01)))
    (and (= x1@368@01 x2@368@01) (= i1@369@01 i2@369@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@368@01 $Ref) (i@369@01 Int)) (!
  (=>
    (and (Set_in x@368@01 xs@366@01) (Seq_contains is@367@01 i@369@01))
    (and
      (and
        (= (inv@371@01 x@368@01 i@369@01) x@368@01)
        (= (inv@373@01 x@368@01 i@369@01) i@369@01))
      (and (img@372@01 x@368@01 i@369@01) (img@374@01 x@368@01 i@369@01))))
  :pattern ((Set_in x@368@01 xs@366@01) (Seq_contains is@367@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (Seq_contains_trigger is@367@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (Seq_contains_trigger is@367@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (inv@371@01 x@368@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (inv@373@01 x@368@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (img@372@01 x@368@01 i@369@01))
  :pattern ((Set_in x@368@01 xs@366@01) (img@374@01 x@368@01 i@369@01))
  :pattern ((Seq_contains is@367@01 i@369@01) (inv@371@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (inv@371@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (inv@371@01 x@368@01 i@369@01))
  :pattern ((Seq_contains is@367@01 i@369@01) (inv@373@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (inv@373@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (inv@373@01 x@368@01 i@369@01))
  :pattern ((Seq_contains is@367@01 i@369@01) (img@372@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (img@372@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (img@372@01 x@368@01 i@369@01))
  :pattern ((Seq_contains is@367@01 i@369@01) (img@374@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (img@374@01 x@368@01 i@369@01))
  :pattern ((Seq_contains_trigger is@367@01 i@369@01) (img@374@01 x@368@01 i@369@01))
  :pattern ((inv@371@01 x@368@01 i@369@01))
  :pattern ((inv@373@01 x@368@01 i@369@01))
  :pattern ((img@372@01 x@368@01 i@369@01))
  :pattern ((img@374@01 x@368@01 i@369@01))
  :qid |quant-u-5249|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@372@01 x i) (img@374@01 x i))
      (and
        (Set_in (inv@371@01 x i) xs@366@01)
        (Seq_contains is@367@01 (inv@373@01 x i))))
    (and (= (inv@371@01 x i) x) (= (inv@373@01 x i) i)))
  :pattern ((inv@371@01 x i))
  :pattern ((inv@373@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { addC(x, x.g, i) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const $t@375@01 $Snap)
(assert (= $t@375@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { addC(x, x.g, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const x@376@01 $Ref)
(declare-const i@377@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 77 | !(x@376@01 in xs@366@01) | live]
; [else-branch: 77 | x@376@01 in xs@366@01 | live]
(push) ; 5
; [then-branch: 77 | !(x@376@01 in xs@366@01)]
(assert (not (Set_in x@376@01 xs@366@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 77 | x@376@01 in xs@366@01]
(assert (Set_in x@376@01 xs@366@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@376@01 xs@366@01) (not (Set_in x@376@01 xs@366@01))))
(push) ; 4
; [then-branch: 78 | x@376@01 in xs@366@01 && i@377@01 in is@367@01 | live]
; [else-branch: 78 | !(x@376@01 in xs@366@01 && i@377@01 in is@367@01) | live]
(push) ; 5
; [then-branch: 78 | x@376@01 in xs@366@01 && i@377@01 in is@367@01]
(assert (and (Set_in x@376@01 xs@366@01) (Seq_contains is@367@01 i@377@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@378@01 ((x $Ref) (i Int) (x@376@01 $Ref) (i@377@01 Int)) $Perm
  (ite
    (and (= x x@376@01) (= i i@377@01))
    ($Perm.min
      (ite
        (and
          (and (img@372@01 x i) (img@374@01 x i))
          (and
            (Set_in (inv@371@01 x i) xs@366@01)
            (Seq_contains is@367@01 (inv@373@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@372@01 x i) (img@374@01 x i))
          (and
            (Set_in (inv@371@01 x i) xs@366@01)
            (Seq_contains is@367@01 (inv@373@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@378@01 x i x@376@01 i@377@01))
    $Perm.No)
  
  :qid |quant-u-5251|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@378@01 x i x@376@01 i@377@01) $Perm.No)
  
  :qid |quant-u-5252|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@376@01) (= i i@377@01))
    (= (- $Perm.Write (pTaken@378@01 x i x@376@01 i@377@01)) $Perm.No))
  
  :qid |quant-u-5253|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@379@01 $PSF<pair>)
(declare-const s@380@01 $Snap)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@372@01 x@376@01 i@377@01) (img@374@01 x@376@01 i@377@01))
    (and
      (Set_in (inv@371@01 x@376@01 i@377@01) xs@366@01)
      (Seq_contains is@367@01 (inv@373@01 x@376@01 i@377@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@376@01)
          ($SortWrappers.IntTo$Snap i@377@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@376@01)
        ($SortWrappers.IntTo$Snap i@377@01)))
      ($PSF.lookup_pair $t@370@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@376@01)
        ($SortWrappers.IntTo$Snap i@377@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@376@01)
  ($SortWrappers.IntTo$Snap i@377@01))) x@376@01 i@377@01))
(assert (=
  ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@376@01)
    ($SortWrappers.IntTo$Snap i@377@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@376@01)
      ($SortWrappers.IntTo$Snap i@377@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@376@01)
      ($SortWrappers.IntTo$Snap i@377@01)))))))
(assert (not (= x@376@01 $Ref.null)))
; [eval] 0 < addC(x, x.g, i)
; [eval] addC(x, x.g, i)
(set-option :timeout 0)
(push) ; 7
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@376@01)
  ($SortWrappers.IntTo$Snap i@377@01)))) x@376@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@376@01)
  ($SortWrappers.IntTo$Snap i@377@01))))) i@377@01))
(pop) ; 7
; Joined path conditions
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@376@01)
  ($SortWrappers.IntTo$Snap i@377@01)))) x@376@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@376@01)
  ($SortWrappers.IntTo$Snap i@377@01))))) i@377@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@372@01 x@376@01 i@377@01) (img@374@01 x@376@01 i@377@01))
      (and
        (Set_in (inv@371@01 x@376@01 i@377@01) xs@366@01)
        (Seq_contains is@367@01 (inv@373@01 x@376@01 i@377@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@376@01)
            ($SortWrappers.IntTo$Snap i@377@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@376@01)
          ($SortWrappers.IntTo$Snap i@377@01)))
        ($PSF.lookup_pair $t@370@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@376@01)
          ($SortWrappers.IntTo$Snap i@377@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@376@01)
    ($SortWrappers.IntTo$Snap i@377@01))) x@376@01 i@377@01)
  (=
    ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@376@01)
      ($SortWrappers.IntTo$Snap i@377@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@376@01)
        ($SortWrappers.IntTo$Snap i@377@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@376@01)
        ($SortWrappers.IntTo$Snap i@377@01))))))
  (not (= x@376@01 $Ref.null))
  (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@376@01)
    ($SortWrappers.IntTo$Snap i@377@01)))) x@376@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@376@01)
    ($SortWrappers.IntTo$Snap i@377@01))))) i@377@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 78 | !(x@376@01 in xs@366@01 && i@377@01 in is@367@01)]
(assert (not (and (Set_in x@376@01 xs@366@01) (Seq_contains is@367@01 i@377@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@376@01 xs@366@01) (Seq_contains is@367@01 i@377@01))
  (and
    (Set_in x@376@01 xs@366@01)
    (Seq_contains is@367@01 i@377@01)
    (=>
      (and
        (and (img@372@01 x@376@01 i@377@01) (img@374@01 x@376@01 i@377@01))
        (and
          (Set_in (inv@371@01 x@376@01 i@377@01) xs@366@01)
          (Seq_contains is@367@01 (inv@373@01 x@376@01 i@377@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@376@01)
              ($SortWrappers.IntTo$Snap i@377@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@376@01)
            ($SortWrappers.IntTo$Snap i@377@01)))
          ($PSF.lookup_pair $t@370@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@376@01)
            ($SortWrappers.IntTo$Snap i@377@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@376@01)
      ($SortWrappers.IntTo$Snap i@377@01))) x@376@01 i@377@01)
    (=
      ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@376@01)
        ($SortWrappers.IntTo$Snap i@377@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@376@01)
          ($SortWrappers.IntTo$Snap i@377@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@376@01)
          ($SortWrappers.IntTo$Snap i@377@01))))))
    (not (= x@376@01 $Ref.null))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@376@01)
      ($SortWrappers.IntTo$Snap i@377@01)))) x@376@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@376@01)
      ($SortWrappers.IntTo$Snap i@377@01))))) i@377@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@376@01 xs@366@01) (Seq_contains is@367@01 i@377@01)))
  (and (Set_in x@376@01 xs@366@01) (Seq_contains is@367@01 i@377@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@376@01 $Ref) (i@377@01 Int)) (!
  (and
    (or (Set_in x@376@01 xs@366@01) (not (Set_in x@376@01 xs@366@01)))
    (=>
      (and (Set_in x@376@01 xs@366@01) (Seq_contains is@367@01 i@377@01))
      (and
        (Set_in x@376@01 xs@366@01)
        (Seq_contains is@367@01 i@377@01)
        (=>
          (and
            (and (img@372@01 x@376@01 i@377@01) (img@374@01 x@376@01 i@377@01))
            (and
              (Set_in (inv@371@01 x@376@01 i@377@01) xs@366@01)
              (Seq_contains is@367@01 (inv@373@01 x@376@01 i@377@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@376@01)
                  ($SortWrappers.IntTo$Snap i@377@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@376@01)
                ($SortWrappers.IntTo$Snap i@377@01)))
              ($PSF.lookup_pair $t@370@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@376@01)
                ($SortWrappers.IntTo$Snap i@377@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@376@01)
          ($SortWrappers.IntTo$Snap i@377@01))) x@376@01 i@377@01)
        (=
          ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@376@01)
            ($SortWrappers.IntTo$Snap i@377@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@376@01)
              ($SortWrappers.IntTo$Snap i@377@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@376@01)
              ($SortWrappers.IntTo$Snap i@377@01))))))
        (not (= x@376@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@376@01)
          ($SortWrappers.IntTo$Snap i@377@01)))) x@376@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@376@01)
          ($SortWrappers.IntTo$Snap i@377@01))))) i@377@01)))
    (or
      (not (and (Set_in x@376@01 xs@366@01) (Seq_contains is@367@01 i@377@01)))
      (and (Set_in x@376@01 xs@366@01) (Seq_contains is@367@01 i@377@01))))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@376@01)
    ($SortWrappers.IntTo$Snap i@377@01)))) x@376@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@376@01)
    ($SortWrappers.IntTo$Snap i@377@01))))) i@377@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@173@10@174@71-aux|)))
(assert (forall ((x@376@01 $Ref) (i@377@01 Int)) (!
  (=>
    (and (Set_in x@376@01 xs@366@01) (Seq_contains is@367@01 i@377@01))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@376@01)
        ($SortWrappers.IntTo$Snap i@377@01)))) x@376@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@376@01)
        ($SortWrappers.IntTo$Snap i@377@01))))) i@377@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@376@01)
    ($SortWrappers.IntTo$Snap i@377@01)))) x@376@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@376@01)
    ($SortWrappers.IntTo$Snap i@377@01))))) i@377@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@173@10@174@71|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; assert (forall x: Ref, i: Int ::
;     { addC(x, x.g, i) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
; [eval] (forall x: Ref, i: Int :: { addC(x, x.g, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const x@381@01 $Ref)
(declare-const i@382@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 79 | !(x@381@01 in xs@366@01) | live]
; [else-branch: 79 | x@381@01 in xs@366@01 | live]
(push) ; 5
; [then-branch: 79 | !(x@381@01 in xs@366@01)]
(assert (not (Set_in x@381@01 xs@366@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 79 | x@381@01 in xs@366@01]
(assert (Set_in x@381@01 xs@366@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@381@01 xs@366@01) (not (Set_in x@381@01 xs@366@01))))
(push) ; 4
; [then-branch: 80 | x@381@01 in xs@366@01 && i@382@01 in is@367@01 | live]
; [else-branch: 80 | !(x@381@01 in xs@366@01 && i@382@01 in is@367@01) | live]
(push) ; 5
; [then-branch: 80 | x@381@01 in xs@366@01 && i@382@01 in is@367@01]
(assert (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@383@01 ((x $Ref) (i Int) (x@381@01 $Ref) (i@382@01 Int)) $Perm
  (ite
    (and (= x x@381@01) (= i i@382@01))
    ($Perm.min
      (ite
        (and
          (and (img@372@01 x i) (img@374@01 x i))
          (and
            (Set_in (inv@371@01 x i) xs@366@01)
            (Seq_contains is@367@01 (inv@373@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@372@01 x i) (img@374@01 x i))
          (and
            (Set_in (inv@371@01 x i) xs@366@01)
            (Seq_contains is@367@01 (inv@373@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@383@01 x i x@381@01 i@382@01))
    $Perm.No)
  
  :qid |quant-u-5255|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@383@01 x i x@381@01 i@382@01) $Perm.No)
  
  :qid |quant-u-5256|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@381@01) (= i i@382@01))
    (= (- $Perm.Write (pTaken@383@01 x i x@381@01 i@382@01)) $Perm.No))
  
  :qid |quant-u-5257|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@372@01 x@381@01 i@382@01) (img@374@01 x@381@01 i@382@01))
    (and
      (Set_in (inv@371@01 x@381@01 i@382@01) xs@366@01)
      (Seq_contains is@367@01 (inv@373@01 x@381@01 i@382@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@381@01)
          ($SortWrappers.IntTo$Snap i@382@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@381@01)
        ($SortWrappers.IntTo$Snap i@382@01)))
      ($PSF.lookup_pair $t@370@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@381@01)
        ($SortWrappers.IntTo$Snap i@382@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@381@01)
  ($SortWrappers.IntTo$Snap i@382@01))) x@381@01 i@382@01))
(assert (=
  ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@381@01)
      ($SortWrappers.IntTo$Snap i@382@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@381@01)
      ($SortWrappers.IntTo$Snap i@382@01)))))))
(assert (not (= x@381@01 $Ref.null)))
; [eval] 0 < addC(x, x.g, i)
; [eval] addC(x, x.g, i)
(set-option :timeout 0)
(push) ; 7
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@381@01)
  ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@381@01)
  ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01))
(pop) ; 7
; Joined path conditions
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@381@01)
  ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@381@01)
  ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@372@01 x@381@01 i@382@01) (img@374@01 x@381@01 i@382@01))
      (and
        (Set_in (inv@371@01 x@381@01 i@382@01) xs@366@01)
        (Seq_contains is@367@01 (inv@373@01 x@381@01 i@382@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@381@01)
            ($SortWrappers.IntTo$Snap i@382@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@381@01)
          ($SortWrappers.IntTo$Snap i@382@01)))
        ($PSF.lookup_pair $t@370@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@381@01)
          ($SortWrappers.IntTo$Snap i@382@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01))) x@381@01 i@382@01)
  (=
    ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@381@01)
      ($SortWrappers.IntTo$Snap i@382@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@381@01)
        ($SortWrappers.IntTo$Snap i@382@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@381@01)
        ($SortWrappers.IntTo$Snap i@382@01))))))
  (not (= x@381@01 $Ref.null))
  (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 80 | !(x@381@01 in xs@366@01 && i@382@01 in is@367@01)]
(assert (not (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01))
  (and
    (Set_in x@381@01 xs@366@01)
    (Seq_contains is@367@01 i@382@01)
    (=>
      (and
        (and (img@372@01 x@381@01 i@382@01) (img@374@01 x@381@01 i@382@01))
        (and
          (Set_in (inv@371@01 x@381@01 i@382@01) xs@366@01)
          (Seq_contains is@367@01 (inv@373@01 x@381@01 i@382@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@381@01)
              ($SortWrappers.IntTo$Snap i@382@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@381@01)
            ($SortWrappers.IntTo$Snap i@382@01)))
          ($PSF.lookup_pair $t@370@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@381@01)
            ($SortWrappers.IntTo$Snap i@382@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@381@01)
      ($SortWrappers.IntTo$Snap i@382@01))) x@381@01 i@382@01)
    (=
      ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@381@01)
        ($SortWrappers.IntTo$Snap i@382@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@381@01)
          ($SortWrappers.IntTo$Snap i@382@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@381@01)
          ($SortWrappers.IntTo$Snap i@382@01))))))
    (not (= x@381@01 $Ref.null))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@381@01)
      ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@381@01)
      ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01)))
  (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@381@01 $Ref) (i@382@01 Int)) (!
  (and
    (or (Set_in x@381@01 xs@366@01) (not (Set_in x@381@01 xs@366@01)))
    (=>
      (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01))
      (and
        (Set_in x@381@01 xs@366@01)
        (Seq_contains is@367@01 i@382@01)
        (=>
          (and
            (and (img@372@01 x@381@01 i@382@01) (img@374@01 x@381@01 i@382@01))
            (and
              (Set_in (inv@371@01 x@381@01 i@382@01) xs@366@01)
              (Seq_contains is@367@01 (inv@373@01 x@381@01 i@382@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@381@01)
                  ($SortWrappers.IntTo$Snap i@382@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@381@01)
                ($SortWrappers.IntTo$Snap i@382@01)))
              ($PSF.lookup_pair $t@370@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@381@01)
                ($SortWrappers.IntTo$Snap i@382@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@381@01)
          ($SortWrappers.IntTo$Snap i@382@01))) x@381@01 i@382@01)
        (=
          ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@381@01)
            ($SortWrappers.IntTo$Snap i@382@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@381@01)
              ($SortWrappers.IntTo$Snap i@382@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@381@01)
              ($SortWrappers.IntTo$Snap i@382@01))))))
        (not (= x@381@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@381@01)
          ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@381@01)
          ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01)))
    (or
      (not (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01)))
      (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01))))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@176@10@177@71-aux|)))
(assert (forall ((x@381@01 $Ref) (i@382@01 Int)) (!
  (=>
    (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@381@01)
      ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@381@01)
      ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@176@10@177@71_precondition|)))
(push) ; 3
(assert (not (forall ((x@381@01 $Ref) (i@382@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@381@01)
          ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@381@01)
          ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01))
      (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01)))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@381@01)
        ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@381@01)
        ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@176@10@177@71|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (forall ((x@381@01 $Ref) (i@382@01 Int)) (!
  (=>
    (and (Set_in x@381@01 xs@366@01) (Seq_contains is@367@01 i@382@01))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@381@01)
        ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@381@01)
        ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01)))) x@381@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@379@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@381@01)
    ($SortWrappers.IntTo$Snap i@382@01))))) i@382@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@176@10@177@71|)))
(pop) ; 2
(pop) ; 1
; ---------- test04b ----------
(declare-const xs@384@01 Set<$Ref>)
(declare-const is@385@01 Seq<Int>)
(declare-const xs@386@01 Set<$Ref>)
(declare-const is@387@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var tx: Ref
(declare-const tx@388@01 $Ref)
; [exec]
; var ti: Int
(declare-const ti@389@01 Int)
; [exec]
; var tmp: Int
(declare-const tmp@390@01 Int)
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@391@01 $Ref)
(declare-const i@392@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 81 | !(x@391@01 in xs@386@01) | live]
; [else-branch: 81 | x@391@01 in xs@386@01 | live]
(push) ; 5
; [then-branch: 81 | !(x@391@01 in xs@386@01)]
(assert (not (Set_in x@391@01 xs@386@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 81 | x@391@01 in xs@386@01]
(assert (Set_in x@391@01 xs@386@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@391@01 xs@386@01) (not (Set_in x@391@01 xs@386@01))))
(assert (and (Set_in x@391@01 xs@386@01) (Seq_contains is@387@01 i@392@01)))
(pop) ; 3
(declare-const $t@393@01 $PSF<pair>)
(declare-fun inv@394@01 ($Ref Int) $Ref)
(declare-fun img@395@01 ($Ref Int) Bool)
(declare-fun inv@396@01 ($Ref Int) Int)
(declare-fun img@397@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@391@01 $Ref) (i@392@01 Int)) (!
  (=>
    (and (Set_in x@391@01 xs@386@01) (Seq_contains is@387@01 i@392@01))
    (or (Set_in x@391@01 xs@386@01) (not (Set_in x@391@01 xs@386@01))))
  :pattern ((Set_in x@391@01 xs@386@01) (Seq_contains is@387@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (Seq_contains_trigger is@387@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (Seq_contains_trigger is@387@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (inv@394@01 x@391@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (inv@396@01 x@391@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (img@395@01 x@391@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (img@397@01 x@391@01 i@392@01))
  :pattern ((Seq_contains is@387@01 i@392@01) (inv@394@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (inv@394@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (inv@394@01 x@391@01 i@392@01))
  :pattern ((Seq_contains is@387@01 i@392@01) (inv@396@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (inv@396@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (inv@396@01 x@391@01 i@392@01))
  :pattern ((Seq_contains is@387@01 i@392@01) (img@395@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (img@395@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (img@395@01 x@391@01 i@392@01))
  :pattern ((Seq_contains is@387@01 i@392@01) (img@397@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (img@397@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (img@397@01 x@391@01 i@392@01))
  :pattern ((inv@394@01 x@391@01 i@392@01))
  :pattern ((inv@396@01 x@391@01 i@392@01))
  :pattern ((img@395@01 x@391@01 i@392@01))
  :pattern ((img@397@01 x@391@01 i@392@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@391@01 $Ref) (i1@392@01 Int) (x2@391@01 $Ref) (i2@392@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@391@01 xs@386@01) (Seq_contains is@387@01 i1@392@01))
      (and (Set_in x2@391@01 xs@386@01) (Seq_contains is@387@01 i2@392@01))
      (and (= x1@391@01 x2@391@01) (= i1@392@01 i2@392@01)))
    (and (= x1@391@01 x2@391@01) (= i1@392@01 i2@392@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@391@01 $Ref) (i@392@01 Int)) (!
  (=>
    (and (Set_in x@391@01 xs@386@01) (Seq_contains is@387@01 i@392@01))
    (and
      (and
        (= (inv@394@01 x@391@01 i@392@01) x@391@01)
        (= (inv@396@01 x@391@01 i@392@01) i@392@01))
      (and (img@395@01 x@391@01 i@392@01) (img@397@01 x@391@01 i@392@01))))
  :pattern ((Set_in x@391@01 xs@386@01) (Seq_contains is@387@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (Seq_contains_trigger is@387@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (Seq_contains_trigger is@387@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (inv@394@01 x@391@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (inv@396@01 x@391@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (img@395@01 x@391@01 i@392@01))
  :pattern ((Set_in x@391@01 xs@386@01) (img@397@01 x@391@01 i@392@01))
  :pattern ((Seq_contains is@387@01 i@392@01) (inv@394@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (inv@394@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (inv@394@01 x@391@01 i@392@01))
  :pattern ((Seq_contains is@387@01 i@392@01) (inv@396@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (inv@396@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (inv@396@01 x@391@01 i@392@01))
  :pattern ((Seq_contains is@387@01 i@392@01) (img@395@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (img@395@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (img@395@01 x@391@01 i@392@01))
  :pattern ((Seq_contains is@387@01 i@392@01) (img@397@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (img@397@01 x@391@01 i@392@01))
  :pattern ((Seq_contains_trigger is@387@01 i@392@01) (img@397@01 x@391@01 i@392@01))
  :pattern ((inv@394@01 x@391@01 i@392@01))
  :pattern ((inv@396@01 x@391@01 i@392@01))
  :pattern ((img@395@01 x@391@01 i@392@01))
  :pattern ((img@397@01 x@391@01 i@392@01))
  :qid |quant-u-5259|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@395@01 x i) (img@397@01 x i))
      (and
        (Set_in (inv@394@01 x i) xs@386@01)
        (Seq_contains is@387@01 (inv@396@01 x i))))
    (and (= (inv@394@01 x i) x) (= (inv@396@01 x i) i)))
  :pattern ((inv@394@01 x i))
  :pattern ((inv@396@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { addC(x, x.g, i) }
;     { (x in xs), (i in is) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const $t@398@01 $Snap)
(assert (= $t@398@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { addC(x, x.g, i) } { (x in xs), (i in is) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const x@399@01 $Ref)
(declare-const i@400@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 82 | !(x@399@01 in xs@386@01) | live]
; [else-branch: 82 | x@399@01 in xs@386@01 | live]
(push) ; 5
; [then-branch: 82 | !(x@399@01 in xs@386@01)]
(assert (not (Set_in x@399@01 xs@386@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 82 | x@399@01 in xs@386@01]
(assert (Set_in x@399@01 xs@386@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@399@01 xs@386@01) (not (Set_in x@399@01 xs@386@01))))
(push) ; 4
; [then-branch: 83 | x@399@01 in xs@386@01 && i@400@01 in is@387@01 | live]
; [else-branch: 83 | !(x@399@01 in xs@386@01 && i@400@01 in is@387@01) | live]
(push) ; 5
; [then-branch: 83 | x@399@01 in xs@386@01 && i@400@01 in is@387@01]
(assert (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@401@01 ((x $Ref) (i Int) (x@399@01 $Ref) (i@400@01 Int)) $Perm
  (ite
    (and (= x x@399@01) (= i i@400@01))
    ($Perm.min
      (ite
        (and
          (and (img@395@01 x i) (img@397@01 x i))
          (and
            (Set_in (inv@394@01 x i) xs@386@01)
            (Seq_contains is@387@01 (inv@396@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@395@01 x i) (img@397@01 x i))
          (and
            (Set_in (inv@394@01 x i) xs@386@01)
            (Seq_contains is@387@01 (inv@396@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@401@01 x i x@399@01 i@400@01))
    $Perm.No)
  
  :qid |quant-u-5261|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@401@01 x i x@399@01 i@400@01) $Perm.No)
  
  :qid |quant-u-5262|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@399@01) (= i i@400@01))
    (= (- $Perm.Write (pTaken@401@01 x i x@399@01 i@400@01)) $Perm.No))
  
  :qid |quant-u-5263|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@402@01 $PSF<pair>)
(declare-const s@403@01 $Snap)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@395@01 x@399@01 i@400@01) (img@397@01 x@399@01 i@400@01))
    (and
      (Set_in (inv@394@01 x@399@01 i@400@01) xs@386@01)
      (Seq_contains is@387@01 (inv@396@01 x@399@01 i@400@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@399@01)
        ($SortWrappers.IntTo$Snap i@400@01)))
      ($PSF.lookup_pair $t@393@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@399@01)
        ($SortWrappers.IntTo$Snap i@400@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@399@01)
  ($SortWrappers.IntTo$Snap i@400@01))) x@399@01 i@400@01))
(assert (=
  ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@399@01)
    ($SortWrappers.IntTo$Snap i@400@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@399@01)
      ($SortWrappers.IntTo$Snap i@400@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@399@01)
      ($SortWrappers.IntTo$Snap i@400@01)))))))
(assert (not (= x@399@01 $Ref.null)))
; [eval] 0 < addC(x, x.g, i)
; [eval] addC(x, x.g, i)
(set-option :timeout 0)
(push) ; 7
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@399@01)
  ($SortWrappers.IntTo$Snap i@400@01)))) x@399@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@399@01)
  ($SortWrappers.IntTo$Snap i@400@01))))) i@400@01))
(pop) ; 7
; Joined path conditions
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@399@01)
  ($SortWrappers.IntTo$Snap i@400@01)))) x@399@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@399@01)
  ($SortWrappers.IntTo$Snap i@400@01))))) i@400@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@395@01 x@399@01 i@400@01) (img@397@01 x@399@01 i@400@01))
      (and
        (Set_in (inv@394@01 x@399@01 i@400@01) xs@386@01)
        (Seq_contains is@387@01 (inv@396@01 x@399@01 i@400@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@399@01)
            ($SortWrappers.IntTo$Snap i@400@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01)))
        ($PSF.lookup_pair $t@393@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@399@01)
    ($SortWrappers.IntTo$Snap i@400@01))) x@399@01 i@400@01)
  (=
    ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@399@01)
      ($SortWrappers.IntTo$Snap i@400@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@399@01)
        ($SortWrappers.IntTo$Snap i@400@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@399@01)
        ($SortWrappers.IntTo$Snap i@400@01))))))
  (not (= x@399@01 $Ref.null))
  (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@399@01)
    ($SortWrappers.IntTo$Snap i@400@01)))) x@399@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@399@01)
    ($SortWrappers.IntTo$Snap i@400@01))))) i@400@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 83 | !(x@399@01 in xs@386@01 && i@400@01 in is@387@01)]
(assert (not (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))
  (and
    (Set_in x@399@01 xs@386@01)
    (Seq_contains is@387@01 i@400@01)
    (=>
      (and
        (and (img@395@01 x@399@01 i@400@01) (img@397@01 x@399@01 i@400@01))
        (and
          (Set_in (inv@394@01 x@399@01 i@400@01) xs@386@01)
          (Seq_contains is@387@01 (inv@396@01 x@399@01 i@400@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@399@01)
              ($SortWrappers.IntTo$Snap i@400@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@399@01)
            ($SortWrappers.IntTo$Snap i@400@01)))
          ($PSF.lookup_pair $t@393@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@399@01)
            ($SortWrappers.IntTo$Snap i@400@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@399@01)
      ($SortWrappers.IntTo$Snap i@400@01))) x@399@01 i@400@01)
    (=
      ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@399@01)
        ($SortWrappers.IntTo$Snap i@400@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01))))))
    (not (= x@399@01 $Ref.null))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@399@01)
      ($SortWrappers.IntTo$Snap i@400@01)))) x@399@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@399@01)
      ($SortWrappers.IntTo$Snap i@400@01))))) i@400@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01)))
  (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@399@01 $Ref) (i@400@01 Int)) (!
  (and
    (or (Set_in x@399@01 xs@386@01) (not (Set_in x@399@01 xs@386@01)))
    (=>
      (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))
      (and
        (Set_in x@399@01 xs@386@01)
        (Seq_contains is@387@01 i@400@01)
        (=>
          (and
            (and (img@395@01 x@399@01 i@400@01) (img@397@01 x@399@01 i@400@01))
            (and
              (Set_in (inv@394@01 x@399@01 i@400@01) xs@386@01)
              (Seq_contains is@387@01 (inv@396@01 x@399@01 i@400@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@399@01)
                  ($SortWrappers.IntTo$Snap i@400@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@399@01)
                ($SortWrappers.IntTo$Snap i@400@01)))
              ($PSF.lookup_pair $t@393@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@399@01)
                ($SortWrappers.IntTo$Snap i@400@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01))) x@399@01 i@400@01)
        (=
          ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@399@01)
            ($SortWrappers.IntTo$Snap i@400@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@399@01)
              ($SortWrappers.IntTo$Snap i@400@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@399@01)
              ($SortWrappers.IntTo$Snap i@400@01))))))
        (not (= x@399@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01)))) x@399@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01))))) i@400@01)))
    (or
      (not (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01)))
      (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@399@01)
    ($SortWrappers.IntTo$Snap i@400@01)))) x@399@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@399@01)
    ($SortWrappers.IntTo$Snap i@400@01))))) i@400@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@183@10@184@71-aux|)))
(assert (forall ((x@399@01 $Ref) (i@400@01 Int)) (!
  (and
    (or (Set_in x@399@01 xs@386@01) (not (Set_in x@399@01 xs@386@01)))
    (=>
      (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))
      (and
        (Set_in x@399@01 xs@386@01)
        (Seq_contains is@387@01 i@400@01)
        (=>
          (and
            (and (img@395@01 x@399@01 i@400@01) (img@397@01 x@399@01 i@400@01))
            (and
              (Set_in (inv@394@01 x@399@01 i@400@01) xs@386@01)
              (Seq_contains is@387@01 (inv@396@01 x@399@01 i@400@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@399@01)
                  ($SortWrappers.IntTo$Snap i@400@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@399@01)
                ($SortWrappers.IntTo$Snap i@400@01)))
              ($PSF.lookup_pair $t@393@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@399@01)
                ($SortWrappers.IntTo$Snap i@400@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01))) x@399@01 i@400@01)
        (=
          ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@399@01)
            ($SortWrappers.IntTo$Snap i@400@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@399@01)
              ($SortWrappers.IntTo$Snap i@400@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@399@01)
              ($SortWrappers.IntTo$Snap i@400@01))))))
        (not (= x@399@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01)))) x@399@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01))))) i@400@01)))
    (or
      (not (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01)))
      (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))))
  :pattern ((Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))
  :pattern ((Set_in x@399@01 xs@386@01) (Seq_contains_trigger is@387@01 i@400@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@183@10@184@71-aux|)))
(assert (forall ((x@399@01 $Ref) (i@400@01 Int)) (!
  (and
    (or (Set_in x@399@01 xs@386@01) (not (Set_in x@399@01 xs@386@01)))
    (=>
      (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))
      (and
        (Set_in x@399@01 xs@386@01)
        (Seq_contains is@387@01 i@400@01)
        (=>
          (and
            (and (img@395@01 x@399@01 i@400@01) (img@397@01 x@399@01 i@400@01))
            (and
              (Set_in (inv@394@01 x@399@01 i@400@01) xs@386@01)
              (Seq_contains is@387@01 (inv@396@01 x@399@01 i@400@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@399@01)
                  ($SortWrappers.IntTo$Snap i@400@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@399@01)
                ($SortWrappers.IntTo$Snap i@400@01)))
              ($PSF.lookup_pair $t@393@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@399@01)
                ($SortWrappers.IntTo$Snap i@400@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01))) x@399@01 i@400@01)
        (=
          ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@399@01)
            ($SortWrappers.IntTo$Snap i@400@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@399@01)
              ($SortWrappers.IntTo$Snap i@400@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@399@01)
              ($SortWrappers.IntTo$Snap i@400@01))))))
        (not (= x@399@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01)))) x@399@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@399@01)
          ($SortWrappers.IntTo$Snap i@400@01))))) i@400@01)))
    (or
      (not (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01)))
      (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))))
  :pattern ((Set_in x@399@01 xs@386@01) (Seq_contains_trigger is@387@01 i@400@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@183@10@184@71-aux|)))
(assert (forall ((x@399@01 $Ref) (i@400@01 Int)) (!
  (=>
    (and (Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@399@01)
        ($SortWrappers.IntTo$Snap i@400@01)))) x@399@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@399@01)
        ($SortWrappers.IntTo$Snap i@400@01))))) i@400@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@399@01)
    ($SortWrappers.IntTo$Snap i@400@01)))) x@399@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@399@01)
    ($SortWrappers.IntTo$Snap i@400@01))))) i@400@01))
  :pattern ((Set_in x@399@01 xs@386@01) (Seq_contains is@387@01 i@400@01))
  :pattern ((Set_in x@399@01 xs@386@01) (Seq_contains_trigger is@387@01 i@400@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@183@10@184@71|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (tx in xs)
(declare-const $t@404@01 $Snap)
(assert (= $t@404@01 $Snap.unit))
; [eval] (tx in xs)
(assert (Set_in tx@388@01 xs@386@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (ti in is)
(declare-const $t@405@01 $Snap)
(assert (= $t@405@01 $Snap.unit))
; [eval] (ti in is)
(assert (Seq_contains is@387@01 ti@389@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; unfold acc(pair(tx, ti), write)
; Precomputing data for removing quantified permissions
(define-fun pTaken@406@01 ((x $Ref) (i Int)) $Perm
  (ite
    (and (= x tx@388@01) (= i ti@389@01))
    ($Perm.min
      (ite
        (and
          (and (img@395@01 x i) (img@397@01 x i))
          (and
            (Set_in (inv@394@01 x i) xs@386@01)
            (Seq_contains is@387@01 (inv@396@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@395@01 x i) (img@397@01 x i))
          (and
            (Set_in (inv@394@01 x i) xs@386@01)
            (Seq_contains is@387@01 (inv@396@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@406@01 x i))
    $Perm.No)
  
  :qid |quant-u-5265|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@406@01 x i) $Perm.No)
  
  :qid |quant-u-5266|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x tx@388@01) (= i ti@389@01))
    (= (- $Perm.Write (pTaken@406@01 x i)) $Perm.No))
  
  :qid |quant-u-5267|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@395@01 tx@388@01 ti@389@01) (img@397@01 tx@388@01 ti@389@01))
    (and
      (Set_in (inv@394@01 tx@388@01 ti@389@01) xs@386@01)
      (Seq_contains is@387@01 (inv@396@01 tx@388@01 ti@389@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap tx@388@01)
          ($SortWrappers.IntTo$Snap ti@389@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@388@01)
        ($SortWrappers.IntTo$Snap ti@389@01)))
      ($PSF.lookup_pair $t@393@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@388@01)
        ($SortWrappers.IntTo$Snap ti@389@01)))))))
(assert (=
  ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@388@01)
    ($SortWrappers.IntTo$Snap ti@389@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@388@01)
      ($SortWrappers.IntTo$Snap ti@389@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@388@01)
      ($SortWrappers.IntTo$Snap ti@389@01)))))))
(assert (not (= tx@388@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (pair%trigger ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@388@01)
  ($SortWrappers.IntTo$Snap ti@389@01))) tx@388@01 ti@389@01))
; [exec]
; tmp := tx.f
(declare-const tmp@407@01 Int)
(assert (=
  tmp@407@01
  ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@388@01)
    ($SortWrappers.IntTo$Snap ti@389@01)))))))
; [exec]
; tx.f := tx.g
(declare-const f@408@01 Int)
(assert (=
  f@408@01
  ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@402@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@388@01)
    ($SortWrappers.IntTo$Snap ti@389@01)))))))
; [exec]
; tx.g := tmp
; [exec]
; fold acc(pair(tx, ti), write)
(assert (pair%trigger ($Snap.combine
  ($SortWrappers.IntTo$Snap f@408@01)
  ($SortWrappers.IntTo$Snap tmp@407@01)) tx@388@01 ti@389@01))
(declare-const sm@409@01 $PSF<pair>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_pair (as sm@409@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@388@01)
    ($SortWrappers.IntTo$Snap ti@389@01)))
  ($Snap.combine
    ($SortWrappers.IntTo$Snap f@408@01)
    ($SortWrappers.IntTo$Snap tmp@407@01))))
; [exec]
; assert (forall x: Ref, i: Int ::
;     { addC(x, x.g, i) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
; [eval] (forall x: Ref, i: Int :: { addC(x, x.g, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const x@410@01 $Ref)
(declare-const i@411@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 84 | !(x@410@01 in xs@386@01) | live]
; [else-branch: 84 | x@410@01 in xs@386@01 | live]
(push) ; 5
; [then-branch: 84 | !(x@410@01 in xs@386@01)]
(assert (not (Set_in x@410@01 xs@386@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 84 | x@410@01 in xs@386@01]
(assert (Set_in x@410@01 xs@386@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@410@01 xs@386@01) (not (Set_in x@410@01 xs@386@01))))
(push) ; 4
; [then-branch: 85 | x@410@01 in xs@386@01 && i@411@01 in is@387@01 | live]
; [else-branch: 85 | !(x@410@01 in xs@386@01 && i@411@01 in is@387@01) | live]
(push) ; 5
; [then-branch: 85 | x@410@01 in xs@386@01 && i@411@01 in is@387@01]
(assert (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@388@01 x@410@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@412@01 ((x $Ref) (i Int) (x@410@01 $Ref) (i@411@01 Int)) $Perm
  (ite
    (and (= x x@410@01) (= i i@411@01))
    ($Perm.min
      (ite
        (and
          (and (img@395@01 x i) (img@397@01 x i))
          (and
            (Set_in (inv@394@01 x i) xs@386@01)
            (Seq_contains is@387@01 (inv@396@01 x i))))
        (- $Perm.Write (pTaken@406@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@413@01 ((x $Ref) (i Int) (x@410@01 $Ref) (i@411@01 Int)) $Perm
  (ite
    (and (= x x@410@01) (= i i@411@01))
    ($Perm.min
      (ite (and (= x tx@388@01) (= i ti@389@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@412@01 x i x@410@01 i@411@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@395@01 x i) (img@397@01 x i))
          (and
            (Set_in (inv@394@01 x i) xs@386@01)
            (Seq_contains is@387@01 (inv@396@01 x i))))
        (- $Perm.Write (pTaken@406@01 x i))
        $Perm.No)
      (pTaken@412@01 x i x@410@01 i@411@01))
    $Perm.No)
  
  :qid |quant-u-5269|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@412@01 x i x@410@01 i@411@01) $Perm.No)
  
  :qid |quant-u-5270|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@410@01) (= i i@411@01))
    (= (- $Perm.Write (pTaken@412@01 x i x@410@01 i@411@01)) $Perm.No))
  
  :qid |quant-u-5271|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@413@01 tx@388@01 ti@389@01 x@410@01 i@411@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@413@01 x i x@410@01 i@411@01) $Perm.No)
  
  :qid |quant-u-5273|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@410@01) (= i i@411@01))
    (=
      (-
        (- $Perm.Write (pTaken@412@01 x i x@410@01 i@411@01))
        (pTaken@413@01 x i x@410@01 i@411@01))
      $Perm.No))
  
  :qid |quant-u-5274|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@414@01 $PSF<pair>)
(declare-const s@415@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@410@01 tx@388@01) (= i@411@01 ti@389@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01)))
      ($PSF.lookup_pair (as sm@409@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01)))))))
(assert (=>
  (ite
    (and
      (and (img@395@01 x@410@01 i@411@01) (img@397@01 x@410@01 i@411@01))
      (and
        (Set_in (inv@394@01 x@410@01 i@411@01) xs@386@01)
        (Seq_contains is@387@01 (inv@396@01 x@410@01 i@411@01))))
    (< $Perm.No (- $Perm.Write (pTaken@406@01 x@410@01 i@411@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01)))
      ($PSF.lookup_pair $t@393@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@410@01)
  ($SortWrappers.IntTo$Snap i@411@01))) x@410@01 i@411@01))
(assert (=
  ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@410@01)
      ($SortWrappers.IntTo$Snap i@411@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@410@01)
      ($SortWrappers.IntTo$Snap i@411@01)))))))
(assert (not (= x@410@01 $Ref.null)))
; [eval] 0 < addC(x, x.g, i)
; [eval] addC(x, x.g, i)
(set-option :timeout 0)
(push) ; 7
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@410@01)
  ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@410@01)
  ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01))
(pop) ; 7
; Joined path conditions
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@410@01)
  ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@410@01)
  ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@410@01 tx@388@01) (= i@411@01 ti@389@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@410@01)
            ($SortWrappers.IntTo$Snap i@411@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01)))
        ($PSF.lookup_pair (as sm@409@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01))))))
  (=>
    (ite
      (and
        (and (img@395@01 x@410@01 i@411@01) (img@397@01 x@410@01 i@411@01))
        (and
          (Set_in (inv@394@01 x@410@01 i@411@01) xs@386@01)
          (Seq_contains is@387@01 (inv@396@01 x@410@01 i@411@01))))
      (< $Perm.No (- $Perm.Write (pTaken@406@01 x@410@01 i@411@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@410@01)
            ($SortWrappers.IntTo$Snap i@411@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01)))
        ($PSF.lookup_pair $t@393@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01))) x@410@01 i@411@01)
  (=
    ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@410@01)
      ($SortWrappers.IntTo$Snap i@411@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01))))))
  (not (= x@410@01 $Ref.null))
  (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 85 | !(x@410@01 in xs@386@01 && i@411@01 in is@387@01)]
(assert (not (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01))
  (and
    (Set_in x@410@01 xs@386@01)
    (Seq_contains is@387@01 i@411@01)
    (=>
      (and (= x@410@01 tx@388@01) (= i@411@01 ti@389@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@410@01)
              ($SortWrappers.IntTo$Snap i@411@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@410@01)
            ($SortWrappers.IntTo$Snap i@411@01)))
          ($PSF.lookup_pair (as sm@409@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@410@01)
            ($SortWrappers.IntTo$Snap i@411@01))))))
    (=>
      (ite
        (and
          (and (img@395@01 x@410@01 i@411@01) (img@397@01 x@410@01 i@411@01))
          (and
            (Set_in (inv@394@01 x@410@01 i@411@01) xs@386@01)
            (Seq_contains is@387@01 (inv@396@01 x@410@01 i@411@01))))
        (< $Perm.No (- $Perm.Write (pTaken@406@01 x@410@01 i@411@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@410@01)
              ($SortWrappers.IntTo$Snap i@411@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@410@01)
            ($SortWrappers.IntTo$Snap i@411@01)))
          ($PSF.lookup_pair $t@393@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@410@01)
            ($SortWrappers.IntTo$Snap i@411@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@410@01)
      ($SortWrappers.IntTo$Snap i@411@01))) x@410@01 i@411@01)
    (=
      ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01))))))
    (not (= x@410@01 $Ref.null))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@410@01)
      ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@410@01)
      ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01)))
  (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@410@01 $Ref) (i@411@01 Int)) (!
  (and
    (or (Set_in x@410@01 xs@386@01) (not (Set_in x@410@01 xs@386@01)))
    (=>
      (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01))
      (and
        (Set_in x@410@01 xs@386@01)
        (Seq_contains is@387@01 i@411@01)
        (=>
          (and (= x@410@01 tx@388@01) (= i@411@01 ti@389@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@410@01)
                  ($SortWrappers.IntTo$Snap i@411@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@410@01)
                ($SortWrappers.IntTo$Snap i@411@01)))
              ($PSF.lookup_pair (as sm@409@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@410@01)
                ($SortWrappers.IntTo$Snap i@411@01))))))
        (=>
          (ite
            (and
              (and (img@395@01 x@410@01 i@411@01) (img@397@01 x@410@01 i@411@01))
              (and
                (Set_in (inv@394@01 x@410@01 i@411@01) xs@386@01)
                (Seq_contains is@387@01 (inv@396@01 x@410@01 i@411@01))))
            (< $Perm.No (- $Perm.Write (pTaken@406@01 x@410@01 i@411@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@410@01)
                  ($SortWrappers.IntTo$Snap i@411@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@410@01)
                ($SortWrappers.IntTo$Snap i@411@01)))
              ($PSF.lookup_pair $t@393@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@410@01)
                ($SortWrappers.IntTo$Snap i@411@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01))) x@410@01 i@411@01)
        (=
          ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@410@01)
            ($SortWrappers.IntTo$Snap i@411@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@410@01)
              ($SortWrappers.IntTo$Snap i@411@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@410@01)
              ($SortWrappers.IntTo$Snap i@411@01))))))
        (not (= x@410@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01)))
    (or
      (not (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01)))
      (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01))))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@188@10@189@71-aux|)))
(assert (forall ((x@410@01 $Ref) (i@411@01 Int)) (!
  (=>
    (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@410@01)
      ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@410@01)
      ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@188@10@189@71_precondition|)))
(push) ; 3
(assert (not (forall ((x@410@01 $Ref) (i@411@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@410@01)
          ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01))
      (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01)))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@188@10@189@71|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (forall ((x@410@01 $Ref) (i@411@01 Int)) (!
  (=>
    (and (Set_in x@410@01 xs@386@01) (Seq_contains is@387@01 i@411@01))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@410@01)
        ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01)))) x@410@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@414@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@410@01)
    ($SortWrappers.IntTo$Snap i@411@01))))) i@411@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@188@10@189@71|)))
(pop) ; 2
(pop) ; 1
; ---------- test04c ----------
(declare-const xs@416@01 Set<$Ref>)
(declare-const is@417@01 Seq<Int>)
(declare-const xs@418@01 Set<$Ref>)
(declare-const is@419@01 Seq<Int>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; var tx: Ref
(declare-const tx@420@01 $Ref)
; [exec]
; var ti: Int
(declare-const ti@421@01 Int)
; [exec]
; var tmp: Int
(declare-const tmp@422@01 Int)
; [exec]
; inhale (forall x: Ref, i: Int ::(x in xs) && (i in is) ==>
;     acc(pair(x, i), write))
(declare-const x@423@01 $Ref)
(declare-const i@424@01 Int)
(push) ; 3
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 86 | !(x@423@01 in xs@418@01) | live]
; [else-branch: 86 | x@423@01 in xs@418@01 | live]
(push) ; 5
; [then-branch: 86 | !(x@423@01 in xs@418@01)]
(assert (not (Set_in x@423@01 xs@418@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 86 | x@423@01 in xs@418@01]
(assert (Set_in x@423@01 xs@418@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@423@01 xs@418@01) (not (Set_in x@423@01 xs@418@01))))
(assert (and (Set_in x@423@01 xs@418@01) (Seq_contains is@419@01 i@424@01)))
(pop) ; 3
(declare-const $t@425@01 $PSF<pair>)
(declare-fun inv@426@01 ($Ref Int) $Ref)
(declare-fun img@427@01 ($Ref Int) Bool)
(declare-fun inv@428@01 ($Ref Int) Int)
(declare-fun img@429@01 ($Ref Int) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((x@423@01 $Ref) (i@424@01 Int)) (!
  (=>
    (and (Set_in x@423@01 xs@418@01) (Seq_contains is@419@01 i@424@01))
    (or (Set_in x@423@01 xs@418@01) (not (Set_in x@423@01 xs@418@01))))
  :pattern ((Set_in x@423@01 xs@418@01) (Seq_contains is@419@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (Seq_contains_trigger is@419@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (Seq_contains_trigger is@419@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (inv@426@01 x@423@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (inv@428@01 x@423@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (img@427@01 x@423@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (img@429@01 x@423@01 i@424@01))
  :pattern ((Seq_contains is@419@01 i@424@01) (inv@426@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (inv@426@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (inv@426@01 x@423@01 i@424@01))
  :pattern ((Seq_contains is@419@01 i@424@01) (inv@428@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (inv@428@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (inv@428@01 x@423@01 i@424@01))
  :pattern ((Seq_contains is@419@01 i@424@01) (img@427@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (img@427@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (img@427@01 x@423@01 i@424@01))
  :pattern ((Seq_contains is@419@01 i@424@01) (img@429@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (img@429@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (img@429@01 x@423@01 i@424@01))
  :pattern ((inv@426@01 x@423@01 i@424@01))
  :pattern ((inv@428@01 x@423@01 i@424@01))
  :pattern ((img@427@01 x@423@01 i@424@01))
  :pattern ((img@429@01 x@423@01 i@424@01))
  :qid |pair-aux|)))
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((x1@423@01 $Ref) (i1@424@01 Int) (x2@423@01 $Ref) (i2@424@01 Int)) (!
  (=>
    (and
      (and (Set_in x1@423@01 xs@418@01) (Seq_contains is@419@01 i1@424@01))
      (and (Set_in x2@423@01 xs@418@01) (Seq_contains is@419@01 i2@424@01))
      (and (= x1@423@01 x2@423@01) (= i1@424@01 i2@424@01)))
    (and (= x1@423@01 x2@423@01) (= i1@424@01 i2@424@01)))
  
  :qid |pair-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((x@423@01 $Ref) (i@424@01 Int)) (!
  (=>
    (and (Set_in x@423@01 xs@418@01) (Seq_contains is@419@01 i@424@01))
    (and
      (and
        (= (inv@426@01 x@423@01 i@424@01) x@423@01)
        (= (inv@428@01 x@423@01 i@424@01) i@424@01))
      (and (img@427@01 x@423@01 i@424@01) (img@429@01 x@423@01 i@424@01))))
  :pattern ((Set_in x@423@01 xs@418@01) (Seq_contains is@419@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (Seq_contains_trigger is@419@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (Seq_contains_trigger is@419@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (inv@426@01 x@423@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (inv@428@01 x@423@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (img@427@01 x@423@01 i@424@01))
  :pattern ((Set_in x@423@01 xs@418@01) (img@429@01 x@423@01 i@424@01))
  :pattern ((Seq_contains is@419@01 i@424@01) (inv@426@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (inv@426@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (inv@426@01 x@423@01 i@424@01))
  :pattern ((Seq_contains is@419@01 i@424@01) (inv@428@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (inv@428@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (inv@428@01 x@423@01 i@424@01))
  :pattern ((Seq_contains is@419@01 i@424@01) (img@427@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (img@427@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (img@427@01 x@423@01 i@424@01))
  :pattern ((Seq_contains is@419@01 i@424@01) (img@429@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (img@429@01 x@423@01 i@424@01))
  :pattern ((Seq_contains_trigger is@419@01 i@424@01) (img@429@01 x@423@01 i@424@01))
  :pattern ((inv@426@01 x@423@01 i@424@01))
  :pattern ((inv@428@01 x@423@01 i@424@01))
  :pattern ((img@427@01 x@423@01 i@424@01))
  :pattern ((img@429@01 x@423@01 i@424@01))
  :qid |quant-u-5276|)))
(assert (forall ((x $Ref) (i Int)) (!
  (=>
    (and
      (and (img@427@01 x i) (img@429@01 x i))
      (and
        (Set_in (inv@426@01 x i) xs@418@01)
        (Seq_contains is@419@01 (inv@428@01 x i))))
    (and (= (inv@426@01 x i) x) (= (inv@428@01 x i) i)))
  :pattern ((inv@426@01 x i))
  :pattern ((inv@428@01 x i))
  :qid |pair-fctOfInv|)))
; Permissions are non-negative
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (forall x: Ref, i: Int ::
;     { addC(x, x.g, i) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const $t@430@01 $Snap)
(assert (= $t@430@01 $Snap.unit))
; [eval] (forall x: Ref, i: Int :: { addC(x, x.g, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const x@431@01 $Ref)
(declare-const i@432@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 87 | !(x@431@01 in xs@418@01) | live]
; [else-branch: 87 | x@431@01 in xs@418@01 | live]
(push) ; 5
; [then-branch: 87 | !(x@431@01 in xs@418@01)]
(assert (not (Set_in x@431@01 xs@418@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 87 | x@431@01 in xs@418@01]
(assert (Set_in x@431@01 xs@418@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@431@01 xs@418@01) (not (Set_in x@431@01 xs@418@01))))
(push) ; 4
; [then-branch: 88 | x@431@01 in xs@418@01 && i@432@01 in is@419@01 | live]
; [else-branch: 88 | !(x@431@01 in xs@418@01 && i@432@01 in is@419@01) | live]
(push) ; 5
; [then-branch: 88 | x@431@01 in xs@418@01 && i@432@01 in is@419@01]
(assert (and (Set_in x@431@01 xs@418@01) (Seq_contains is@419@01 i@432@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
(push) ; 6
; Precomputing data for removing quantified permissions
(define-fun pTaken@433@01 ((x $Ref) (i Int) (x@431@01 $Ref) (i@432@01 Int)) $Perm
  (ite
    (and (= x x@431@01) (= i i@432@01))
    ($Perm.min
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@433@01 x i x@431@01 i@432@01))
    $Perm.No)
  
  :qid |quant-u-5278|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@433@01 x i x@431@01 i@432@01) $Perm.No)
  
  :qid |quant-u-5279|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@431@01) (= i i@432@01))
    (= (- $Perm.Write (pTaken@433@01 x i x@431@01 i@432@01)) $Perm.No))
  
  :qid |quant-u-5280|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@434@01 $PSF<pair>)
(declare-const s@435@01 $Snap)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@427@01 x@431@01 i@432@01) (img@429@01 x@431@01 i@432@01))
    (and
      (Set_in (inv@426@01 x@431@01 i@432@01) xs@418@01)
      (Seq_contains is@419@01 (inv@428@01 x@431@01 i@432@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@431@01)
          ($SortWrappers.IntTo$Snap i@432@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@431@01)
        ($SortWrappers.IntTo$Snap i@432@01)))
      ($PSF.lookup_pair $t@425@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@431@01)
        ($SortWrappers.IntTo$Snap i@432@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@431@01)
  ($SortWrappers.IntTo$Snap i@432@01))) x@431@01 i@432@01))
(assert (=
  ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@431@01)
    ($SortWrappers.IntTo$Snap i@432@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@431@01)
      ($SortWrappers.IntTo$Snap i@432@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@431@01)
      ($SortWrappers.IntTo$Snap i@432@01)))))))
(assert (not (= x@431@01 $Ref.null)))
; [eval] 0 < addC(x, x.g, i)
; [eval] addC(x, x.g, i)
(set-option :timeout 0)
(push) ; 7
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@431@01)
  ($SortWrappers.IntTo$Snap i@432@01)))) x@431@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@431@01)
  ($SortWrappers.IntTo$Snap i@432@01))))) i@432@01))
(pop) ; 7
; Joined path conditions
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@431@01)
  ($SortWrappers.IntTo$Snap i@432@01)))) x@431@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@431@01)
  ($SortWrappers.IntTo$Snap i@432@01))))) i@432@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and
      (and (img@427@01 x@431@01 i@432@01) (img@429@01 x@431@01 i@432@01))
      (and
        (Set_in (inv@426@01 x@431@01 i@432@01) xs@418@01)
        (Seq_contains is@419@01 (inv@428@01 x@431@01 i@432@01))))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@431@01)
            ($SortWrappers.IntTo$Snap i@432@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@431@01)
          ($SortWrappers.IntTo$Snap i@432@01)))
        ($PSF.lookup_pair $t@425@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@431@01)
          ($SortWrappers.IntTo$Snap i@432@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@431@01)
    ($SortWrappers.IntTo$Snap i@432@01))) x@431@01 i@432@01)
  (=
    ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@431@01)
      ($SortWrappers.IntTo$Snap i@432@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@431@01)
        ($SortWrappers.IntTo$Snap i@432@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@431@01)
        ($SortWrappers.IntTo$Snap i@432@01))))))
  (not (= x@431@01 $Ref.null))
  (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@431@01)
    ($SortWrappers.IntTo$Snap i@432@01)))) x@431@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@431@01)
    ($SortWrappers.IntTo$Snap i@432@01))))) i@432@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 88 | !(x@431@01 in xs@418@01 && i@432@01 in is@419@01)]
(assert (not (and (Set_in x@431@01 xs@418@01) (Seq_contains is@419@01 i@432@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@431@01 xs@418@01) (Seq_contains is@419@01 i@432@01))
  (and
    (Set_in x@431@01 xs@418@01)
    (Seq_contains is@419@01 i@432@01)
    (=>
      (and
        (and (img@427@01 x@431@01 i@432@01) (img@429@01 x@431@01 i@432@01))
        (and
          (Set_in (inv@426@01 x@431@01 i@432@01) xs@418@01)
          (Seq_contains is@419@01 (inv@428@01 x@431@01 i@432@01))))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@431@01)
              ($SortWrappers.IntTo$Snap i@432@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@431@01)
            ($SortWrappers.IntTo$Snap i@432@01)))
          ($PSF.lookup_pair $t@425@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@431@01)
            ($SortWrappers.IntTo$Snap i@432@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@431@01)
      ($SortWrappers.IntTo$Snap i@432@01))) x@431@01 i@432@01)
    (=
      ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@431@01)
        ($SortWrappers.IntTo$Snap i@432@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@431@01)
          ($SortWrappers.IntTo$Snap i@432@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@431@01)
          ($SortWrappers.IntTo$Snap i@432@01))))))
    (not (= x@431@01 $Ref.null))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@431@01)
      ($SortWrappers.IntTo$Snap i@432@01)))) x@431@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@431@01)
      ($SortWrappers.IntTo$Snap i@432@01))))) i@432@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@431@01 xs@418@01) (Seq_contains is@419@01 i@432@01)))
  (and (Set_in x@431@01 xs@418@01) (Seq_contains is@419@01 i@432@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@431@01 $Ref) (i@432@01 Int)) (!
  (and
    (or (Set_in x@431@01 xs@418@01) (not (Set_in x@431@01 xs@418@01)))
    (=>
      (and (Set_in x@431@01 xs@418@01) (Seq_contains is@419@01 i@432@01))
      (and
        (Set_in x@431@01 xs@418@01)
        (Seq_contains is@419@01 i@432@01)
        (=>
          (and
            (and (img@427@01 x@431@01 i@432@01) (img@429@01 x@431@01 i@432@01))
            (and
              (Set_in (inv@426@01 x@431@01 i@432@01) xs@418@01)
              (Seq_contains is@419@01 (inv@428@01 x@431@01 i@432@01))))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@431@01)
                  ($SortWrappers.IntTo$Snap i@432@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@431@01)
                ($SortWrappers.IntTo$Snap i@432@01)))
              ($PSF.lookup_pair $t@425@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@431@01)
                ($SortWrappers.IntTo$Snap i@432@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@431@01)
          ($SortWrappers.IntTo$Snap i@432@01))) x@431@01 i@432@01)
        (=
          ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@431@01)
            ($SortWrappers.IntTo$Snap i@432@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@431@01)
              ($SortWrappers.IntTo$Snap i@432@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@431@01)
              ($SortWrappers.IntTo$Snap i@432@01))))))
        (not (= x@431@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@431@01)
          ($SortWrappers.IntTo$Snap i@432@01)))) x@431@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@431@01)
          ($SortWrappers.IntTo$Snap i@432@01))))) i@432@01)))
    (or
      (not (and (Set_in x@431@01 xs@418@01) (Seq_contains is@419@01 i@432@01)))
      (and (Set_in x@431@01 xs@418@01) (Seq_contains is@419@01 i@432@01))))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@431@01)
    ($SortWrappers.IntTo$Snap i@432@01)))) x@431@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@431@01)
    ($SortWrappers.IntTo$Snap i@432@01))))) i@432@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@195@10@196@71-aux|)))
(assert (forall ((x@431@01 $Ref) (i@432@01 Int)) (!
  (=>
    (and (Set_in x@431@01 xs@418@01) (Seq_contains is@419@01 i@432@01))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@431@01)
        ($SortWrappers.IntTo$Snap i@432@01)))) x@431@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@431@01)
        ($SortWrappers.IntTo$Snap i@432@01))))) i@432@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@431@01)
    ($SortWrappers.IntTo$Snap i@432@01)))) x@431@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@431@01)
    ($SortWrappers.IntTo$Snap i@432@01))))) i@432@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@195@10@196@71|)))
; State saturation: after inhale
(set-option :timeout 20)
(check-sat)
; unknown
; [exec]
; inhale (tx in xs)
(declare-const $t@436@01 $Snap)
(assert (= $t@436@01 $Snap.unit))
; [eval] (tx in xs)
(assert (Set_in tx@420@01 xs@418@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; inhale (ti in is)
(declare-const $t@437@01 $Snap)
(assert (= $t@437@01 $Snap.unit))
; [eval] (ti in is)
(assert (Seq_contains is@419@01 ti@421@01))
; State saturation: after inhale
(check-sat)
; unknown
; [exec]
; unfold acc(pair(tx, ti), write)
; Precomputing data for removing quantified permissions
(define-fun pTaken@438@01 ((x $Ref) (i Int)) $Perm
  (ite
    (and (= x tx@420@01) (= i ti@421@01))
    ($Perm.min
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        $Perm.Write
        $Perm.No)
      (pTaken@438@01 x i))
    $Perm.No)
  
  :qid |quant-u-5282|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@438@01 x i) $Perm.No)
  
  :qid |quant-u-5283|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x tx@420@01) (= i ti@421@01))
    (= (- $Perm.Write (pTaken@438@01 x i)) $Perm.No))
  
  :qid |quant-u-5284|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and
    (and (img@427@01 tx@420@01 ti@421@01) (img@429@01 tx@420@01 ti@421@01))
    (and
      (Set_in (inv@426@01 tx@420@01 ti@421@01) xs@418@01)
      (Seq_contains is@419@01 (inv@428@01 tx@420@01 ti@421@01))))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap tx@420@01)
          ($SortWrappers.IntTo$Snap ti@421@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@420@01)
        ($SortWrappers.IntTo$Snap ti@421@01)))
      ($PSF.lookup_pair $t@425@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap tx@420@01)
        ($SortWrappers.IntTo$Snap ti@421@01)))))))
(assert (=
  ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@420@01)
    ($SortWrappers.IntTo$Snap ti@421@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@420@01)
      ($SortWrappers.IntTo$Snap ti@421@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap tx@420@01)
      ($SortWrappers.IntTo$Snap ti@421@01)))))))
(assert (not (= tx@420@01 $Ref.null)))
; State saturation: after unfold
(set-option :timeout 40)
(check-sat)
; unknown
(assert (pair%trigger ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap tx@420@01)
  ($SortWrappers.IntTo$Snap ti@421@01))) tx@420@01 ti@421@01))
; [exec]
; tmp := tx.f
(declare-const tmp@439@01 Int)
(assert (=
  tmp@439@01
  ($SortWrappers.$SnapToInt ($Snap.first ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@420@01)
    ($SortWrappers.IntTo$Snap ti@421@01)))))))
; [exec]
; tx.f := tx.g
(declare-const f@440@01 Int)
(assert (=
  f@440@01
  ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@434@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@420@01)
    ($SortWrappers.IntTo$Snap ti@421@01)))))))
; [exec]
; tx.g := tmp
; [exec]
; fold acc(pair(tx, ti), write)
(assert (pair%trigger ($Snap.combine
  ($SortWrappers.IntTo$Snap f@440@01)
  ($SortWrappers.IntTo$Snap tmp@439@01)) tx@420@01 ti@421@01))
(declare-const sm@441@01 $PSF<pair>)
; Definitional axioms for singleton-SM's value
(assert (=
  ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap tx@420@01)
    ($SortWrappers.IntTo$Snap ti@421@01)))
  ($Snap.combine
    ($SortWrappers.IntTo$Snap f@440@01)
    ($SortWrappers.IntTo$Snap tmp@439@01))))
; [exec]
; assert (forall x: Ref, i: Int ::
;     { addC(x, x.g, i) }
;     (x in xs) && (i in is) ==>
;     (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
; [eval] (forall x: Ref, i: Int :: { addC(x, x.g, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const x@442@01 $Ref)
(declare-const i@443@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 89 | !(x@442@01 in xs@418@01) | live]
; [else-branch: 89 | x@442@01 in xs@418@01 | live]
(push) ; 5
; [then-branch: 89 | !(x@442@01 in xs@418@01)]
(assert (not (Set_in x@442@01 xs@418@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 89 | x@442@01 in xs@418@01]
(assert (Set_in x@442@01 xs@418@01))
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@442@01 xs@418@01) (not (Set_in x@442@01 xs@418@01))))
(push) ; 4
; [then-branch: 90 | x@442@01 in xs@418@01 && i@443@01 in is@419@01 | live]
; [else-branch: 90 | !(x@442@01 in xs@418@01 && i@443@01 in is@419@01) | live]
(push) ; 5
; [then-branch: 90 | x@442@01 in xs@418@01 && i@443@01 in is@419@01]
(assert (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01)))
; [eval] (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@420@01 x@442@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@444@01 ((x $Ref) (i Int) (x@442@01 $Ref) (i@443@01 Int)) $Perm
  (ite
    (and (= x x@442@01) (= i i@443@01))
    ($Perm.min
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        (- $Perm.Write (pTaken@438@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@445@01 ((x $Ref) (i Int) (x@442@01 $Ref) (i@443@01 Int)) $Perm
  (ite
    (and (= x x@442@01) (= i i@443@01))
    ($Perm.min
      (ite (and (= x tx@420@01) (= i ti@421@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@444@01 x i x@442@01 i@443@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        (- $Perm.Write (pTaken@438@01 x i))
        $Perm.No)
      (pTaken@444@01 x i x@442@01 i@443@01))
    $Perm.No)
  
  :qid |quant-u-5286|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@444@01 x i x@442@01 i@443@01) $Perm.No)
  
  :qid |quant-u-5287|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@442@01) (= i i@443@01))
    (= (- $Perm.Write (pTaken@444@01 x i x@442@01 i@443@01)) $Perm.No))
  
  :qid |quant-u-5288|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@445@01 tx@420@01 ti@421@01 x@442@01 i@443@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@445@01 x i x@442@01 i@443@01) $Perm.No)
  
  :qid |quant-u-5290|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@442@01) (= i i@443@01))
    (=
      (-
        (- $Perm.Write (pTaken@444@01 x i x@442@01 i@443@01))
        (pTaken@445@01 x i x@442@01 i@443@01))
      $Perm.No))
  
  :qid |quant-u-5291|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@446@01 $PSF<pair>)
(declare-const s@447@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@442@01 tx@420@01) (= i@443@01 ti@421@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@442@01)
        ($SortWrappers.IntTo$Snap i@443@01)))
      ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@442@01)
        ($SortWrappers.IntTo$Snap i@443@01)))))))
(assert (=>
  (ite
    (and
      (and (img@427@01 x@442@01 i@443@01) (img@429@01 x@442@01 i@443@01))
      (and
        (Set_in (inv@426@01 x@442@01 i@443@01) xs@418@01)
        (Seq_contains is@419@01 (inv@428@01 x@442@01 i@443@01))))
    (< $Perm.No (- $Perm.Write (pTaken@438@01 x@442@01 i@443@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@442@01)
        ($SortWrappers.IntTo$Snap i@443@01)))
      ($PSF.lookup_pair $t@425@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@442@01)
        ($SortWrappers.IntTo$Snap i@443@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@442@01)
  ($SortWrappers.IntTo$Snap i@443@01))) x@442@01 i@443@01))
(assert (=
  ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@442@01)
    ($SortWrappers.IntTo$Snap i@443@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@442@01)
      ($SortWrappers.IntTo$Snap i@443@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@442@01)
      ($SortWrappers.IntTo$Snap i@443@01)))))))
(assert (not (= x@442@01 $Ref.null)))
; [eval] 0 < addC(x, x.g, i)
; [eval] addC(x, x.g, i)
(set-option :timeout 0)
(push) ; 7
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@442@01)
  ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@442@01)
  ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01))
(pop) ; 7
; Joined path conditions
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@442@01)
  ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@442@01)
  ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@442@01 tx@420@01) (= i@443@01 ti@421@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@442@01)
            ($SortWrappers.IntTo$Snap i@443@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01)))
        ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01))))))
  (=>
    (ite
      (and
        (and (img@427@01 x@442@01 i@443@01) (img@429@01 x@442@01 i@443@01))
        (and
          (Set_in (inv@426@01 x@442@01 i@443@01) xs@418@01)
          (Seq_contains is@419@01 (inv@428@01 x@442@01 i@443@01))))
      (< $Perm.No (- $Perm.Write (pTaken@438@01 x@442@01 i@443@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@442@01)
            ($SortWrappers.IntTo$Snap i@443@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01)))
        ($PSF.lookup_pair $t@425@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@442@01)
    ($SortWrappers.IntTo$Snap i@443@01))) x@442@01 i@443@01)
  (=
    ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@442@01)
      ($SortWrappers.IntTo$Snap i@443@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@442@01)
        ($SortWrappers.IntTo$Snap i@443@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@442@01)
        ($SortWrappers.IntTo$Snap i@443@01))))))
  (not (= x@442@01 $Ref.null))
  (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@442@01)
    ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@442@01)
    ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 90 | !(x@442@01 in xs@418@01 && i@443@01 in is@419@01)]
(assert (not (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01))
  (and
    (Set_in x@442@01 xs@418@01)
    (Seq_contains is@419@01 i@443@01)
    (=>
      (and (= x@442@01 tx@420@01) (= i@443@01 ti@421@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@442@01)
              ($SortWrappers.IntTo$Snap i@443@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@442@01)
            ($SortWrappers.IntTo$Snap i@443@01)))
          ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@442@01)
            ($SortWrappers.IntTo$Snap i@443@01))))))
    (=>
      (ite
        (and
          (and (img@427@01 x@442@01 i@443@01) (img@429@01 x@442@01 i@443@01))
          (and
            (Set_in (inv@426@01 x@442@01 i@443@01) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x@442@01 i@443@01))))
        (< $Perm.No (- $Perm.Write (pTaken@438@01 x@442@01 i@443@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@442@01)
              ($SortWrappers.IntTo$Snap i@443@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@442@01)
            ($SortWrappers.IntTo$Snap i@443@01)))
          ($PSF.lookup_pair $t@425@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@442@01)
            ($SortWrappers.IntTo$Snap i@443@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@442@01)
      ($SortWrappers.IntTo$Snap i@443@01))) x@442@01 i@443@01)
    (=
      ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@442@01)
        ($SortWrappers.IntTo$Snap i@443@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01))))))
    (not (= x@442@01 $Ref.null))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@442@01)
      ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@442@01)
      ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01)))
  (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@442@01 $Ref) (i@443@01 Int)) (!
  (and
    (or (Set_in x@442@01 xs@418@01) (not (Set_in x@442@01 xs@418@01)))
    (=>
      (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01))
      (and
        (Set_in x@442@01 xs@418@01)
        (Seq_contains is@419@01 i@443@01)
        (=>
          (and (= x@442@01 tx@420@01) (= i@443@01 ti@421@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@442@01)
                  ($SortWrappers.IntTo$Snap i@443@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@442@01)
                ($SortWrappers.IntTo$Snap i@443@01)))
              ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@442@01)
                ($SortWrappers.IntTo$Snap i@443@01))))))
        (=>
          (ite
            (and
              (and (img@427@01 x@442@01 i@443@01) (img@429@01 x@442@01 i@443@01))
              (and
                (Set_in (inv@426@01 x@442@01 i@443@01) xs@418@01)
                (Seq_contains is@419@01 (inv@428@01 x@442@01 i@443@01))))
            (< $Perm.No (- $Perm.Write (pTaken@438@01 x@442@01 i@443@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@442@01)
                  ($SortWrappers.IntTo$Snap i@443@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@442@01)
                ($SortWrappers.IntTo$Snap i@443@01)))
              ($PSF.lookup_pair $t@425@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@442@01)
                ($SortWrappers.IntTo$Snap i@443@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01))) x@442@01 i@443@01)
        (=
          ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@442@01)
            ($SortWrappers.IntTo$Snap i@443@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@442@01)
              ($SortWrappers.IntTo$Snap i@443@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@442@01)
              ($SortWrappers.IntTo$Snap i@443@01))))))
        (not (= x@442@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01)))
    (or
      (not (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01)))
      (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01))))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@442@01)
    ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@442@01)
    ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71-aux|)))
(assert (forall ((x@442@01 $Ref) (i@443@01 Int)) (!
  (=>
    (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@442@01)
      ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@442@01)
      ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@442@01)
    ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@442@01)
    ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71_precondition|)))
(push) ; 3
(assert (not (forall ((x@442@01 $Ref) (i@443@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@442@01)
          ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01))
      (and (Set_in x@442@01 xs@418@01) (Seq_contains is@419@01 i@443@01)))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@442@01)
        ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@442@01)
        ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@442@01)
    ($SortWrappers.IntTo$Snap i@443@01)))) x@442@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@446@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@442@01)
    ($SortWrappers.IntTo$Snap i@443@01))))) i@443@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { addC(x, x.g, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const x@448@01 $Ref)
(declare-const i@449@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 91 | !(x@448@01 in xs@418@01) | live]
; [else-branch: 91 | x@448@01 in xs@418@01 | live]
(push) ; 5
; [then-branch: 91 | !(x@448@01 in xs@418@01)]
(assert (not (Set_in x@448@01 xs@418@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 91 | x@448@01 in xs@418@01]
(assert (Set_in x@448@01 xs@418@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@448@01 xs@418@01) (not (Set_in x@448@01 xs@418@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 92 | x@448@01 in xs@418@01 && i@449@01 in is@419@01 | live]
; [else-branch: 92 | !(x@448@01 in xs@418@01 && i@449@01 in is@419@01) | live]
(push) ; 5
; [then-branch: 92 | x@448@01 in xs@418@01 && i@449@01 in is@419@01]
(assert (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
(set-option :timeout 0)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@420@01 x@448@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@450@01 ((x $Ref) (i Int) (x@448@01 $Ref) (i@449@01 Int)) $Perm
  (ite
    (and (= x x@448@01) (= i i@449@01))
    ($Perm.min
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        (- $Perm.Write (pTaken@438@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@451@01 ((x $Ref) (i Int) (x@448@01 $Ref) (i@449@01 Int)) $Perm
  (ite
    (and (= x x@448@01) (= i i@449@01))
    ($Perm.min
      (ite (and (= x tx@420@01) (= i ti@421@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@450@01 x i x@448@01 i@449@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        (- $Perm.Write (pTaken@438@01 x i))
        $Perm.No)
      (pTaken@450@01 x i x@448@01 i@449@01))
    $Perm.No)
  
  :qid |quant-u-5293|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@450@01 x i x@448@01 i@449@01) $Perm.No)
  
  :qid |quant-u-5294|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@448@01) (= i i@449@01))
    (= (- $Perm.Write (pTaken@450@01 x i x@448@01 i@449@01)) $Perm.No))
  
  :qid |quant-u-5295|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@451@01 tx@420@01 ti@421@01 x@448@01 i@449@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@451@01 x i x@448@01 i@449@01) $Perm.No)
  
  :qid |quant-u-5297|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@448@01) (= i i@449@01))
    (=
      (-
        (- $Perm.Write (pTaken@450@01 x i x@448@01 i@449@01))
        (pTaken@451@01 x i x@448@01 i@449@01))
      $Perm.No))
  
  :qid |quant-u-5298|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@452@01 $PSF<pair>)
(declare-const s@453@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@448@01 tx@420@01) (= i@449@01 ti@421@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@448@01)
        ($SortWrappers.IntTo$Snap i@449@01)))
      ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@448@01)
        ($SortWrappers.IntTo$Snap i@449@01)))))))
(assert (=>
  (ite
    (and
      (and (img@427@01 x@448@01 i@449@01) (img@429@01 x@448@01 i@449@01))
      (and
        (Set_in (inv@426@01 x@448@01 i@449@01) xs@418@01)
        (Seq_contains is@419@01 (inv@428@01 x@448@01 i@449@01))))
    (< $Perm.No (- $Perm.Write (pTaken@438@01 x@448@01 i@449@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@448@01)
        ($SortWrappers.IntTo$Snap i@449@01)))
      ($PSF.lookup_pair $t@425@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@448@01)
        ($SortWrappers.IntTo$Snap i@449@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@448@01)
  ($SortWrappers.IntTo$Snap i@449@01))) x@448@01 i@449@01))
(assert (=
  ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@448@01)
    ($SortWrappers.IntTo$Snap i@449@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@448@01)
      ($SortWrappers.IntTo$Snap i@449@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@448@01)
      ($SortWrappers.IntTo$Snap i@449@01)))))))
(assert (not (= x@448@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addC(x, x.g, i)
; [eval] addC(x, x.g, i)
(set-option :timeout 0)
(push) ; 7
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@448@01)
  ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@448@01)
  ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01))
(pop) ; 7
; Joined path conditions
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@448@01)
  ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@448@01)
  ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@448@01 tx@420@01) (= i@449@01 ti@421@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@448@01)
            ($SortWrappers.IntTo$Snap i@449@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01)))
        ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01))))))
  (=>
    (ite
      (and
        (and (img@427@01 x@448@01 i@449@01) (img@429@01 x@448@01 i@449@01))
        (and
          (Set_in (inv@426@01 x@448@01 i@449@01) xs@418@01)
          (Seq_contains is@419@01 (inv@428@01 x@448@01 i@449@01))))
      (< $Perm.No (- $Perm.Write (pTaken@438@01 x@448@01 i@449@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@448@01)
            ($SortWrappers.IntTo$Snap i@449@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01)))
        ($PSF.lookup_pair $t@425@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@448@01)
    ($SortWrappers.IntTo$Snap i@449@01))) x@448@01 i@449@01)
  (=
    ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@448@01)
      ($SortWrappers.IntTo$Snap i@449@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@448@01)
        ($SortWrappers.IntTo$Snap i@449@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@448@01)
        ($SortWrappers.IntTo$Snap i@449@01))))))
  (not (= x@448@01 $Ref.null))
  (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@448@01)
    ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@448@01)
    ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 92 | !(x@448@01 in xs@418@01 && i@449@01 in is@419@01)]
(assert (not (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01))
  (and
    (Set_in x@448@01 xs@418@01)
    (Seq_contains is@419@01 i@449@01)
    (=>
      (and (= x@448@01 tx@420@01) (= i@449@01 ti@421@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@448@01)
              ($SortWrappers.IntTo$Snap i@449@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@448@01)
            ($SortWrappers.IntTo$Snap i@449@01)))
          ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@448@01)
            ($SortWrappers.IntTo$Snap i@449@01))))))
    (=>
      (ite
        (and
          (and (img@427@01 x@448@01 i@449@01) (img@429@01 x@448@01 i@449@01))
          (and
            (Set_in (inv@426@01 x@448@01 i@449@01) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x@448@01 i@449@01))))
        (< $Perm.No (- $Perm.Write (pTaken@438@01 x@448@01 i@449@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@448@01)
              ($SortWrappers.IntTo$Snap i@449@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@448@01)
            ($SortWrappers.IntTo$Snap i@449@01)))
          ($PSF.lookup_pair $t@425@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@448@01)
            ($SortWrappers.IntTo$Snap i@449@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@448@01)
      ($SortWrappers.IntTo$Snap i@449@01))) x@448@01 i@449@01)
    (=
      ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@448@01)
        ($SortWrappers.IntTo$Snap i@449@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01))))))
    (not (= x@448@01 $Ref.null))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@448@01)
      ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@448@01)
      ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01)))
  (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@448@01 $Ref) (i@449@01 Int)) (!
  (and
    (or (Set_in x@448@01 xs@418@01) (not (Set_in x@448@01 xs@418@01)))
    (=>
      (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01))
      (and
        (Set_in x@448@01 xs@418@01)
        (Seq_contains is@419@01 i@449@01)
        (=>
          (and (= x@448@01 tx@420@01) (= i@449@01 ti@421@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@448@01)
                  ($SortWrappers.IntTo$Snap i@449@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@448@01)
                ($SortWrappers.IntTo$Snap i@449@01)))
              ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@448@01)
                ($SortWrappers.IntTo$Snap i@449@01))))))
        (=>
          (ite
            (and
              (and (img@427@01 x@448@01 i@449@01) (img@429@01 x@448@01 i@449@01))
              (and
                (Set_in (inv@426@01 x@448@01 i@449@01) xs@418@01)
                (Seq_contains is@419@01 (inv@428@01 x@448@01 i@449@01))))
            (< $Perm.No (- $Perm.Write (pTaken@438@01 x@448@01 i@449@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@448@01)
                  ($SortWrappers.IntTo$Snap i@449@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@448@01)
                ($SortWrappers.IntTo$Snap i@449@01)))
              ($PSF.lookup_pair $t@425@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@448@01)
                ($SortWrappers.IntTo$Snap i@449@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01))) x@448@01 i@449@01)
        (=
          ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@448@01)
            ($SortWrappers.IntTo$Snap i@449@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@448@01)
              ($SortWrappers.IntTo$Snap i@449@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@448@01)
              ($SortWrappers.IntTo$Snap i@449@01))))))
        (not (= x@448@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01)))
    (or
      (not (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01)))
      (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01))))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@448@01)
    ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@448@01)
    ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71-aux|)))
(assert (forall ((x@448@01 $Ref) (i@449@01 Int)) (!
  (=>
    (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@448@01)
      ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@448@01)
      ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@448@01)
    ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@448@01)
    ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@448@01 $Ref) (i@449@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@448@01)
          ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01))
      (and (Set_in x@448@01 xs@418@01) (Seq_contains is@419@01 i@449@01)))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@448@01)
        ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@448@01)
        ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@448@01)
    ($SortWrappers.IntTo$Snap i@449@01)))) x@448@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@452@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@448@01)
    ($SortWrappers.IntTo$Snap i@449@01))))) i@449@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { addC(x, x.g, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const x@454@01 $Ref)
(declare-const i@455@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 93 | !(x@454@01 in xs@418@01) | live]
; [else-branch: 93 | x@454@01 in xs@418@01 | live]
(push) ; 5
; [then-branch: 93 | !(x@454@01 in xs@418@01)]
(assert (not (Set_in x@454@01 xs@418@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 93 | x@454@01 in xs@418@01]
(assert (Set_in x@454@01 xs@418@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@454@01 xs@418@01) (not (Set_in x@454@01 xs@418@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 94 | x@454@01 in xs@418@01 && i@455@01 in is@419@01 | live]
; [else-branch: 94 | !(x@454@01 in xs@418@01 && i@455@01 in is@419@01) | live]
(push) ; 5
; [then-branch: 94 | x@454@01 in xs@418@01 && i@455@01 in is@419@01]
(assert (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
(set-option :timeout 0)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@420@01 x@454@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@456@01 ((x $Ref) (i Int) (x@454@01 $Ref) (i@455@01 Int)) $Perm
  (ite
    (and (= x x@454@01) (= i i@455@01))
    ($Perm.min
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        (- $Perm.Write (pTaken@438@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@457@01 ((x $Ref) (i Int) (x@454@01 $Ref) (i@455@01 Int)) $Perm
  (ite
    (and (= x x@454@01) (= i i@455@01))
    ($Perm.min
      (ite (and (= x tx@420@01) (= i ti@421@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@456@01 x i x@454@01 i@455@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        (- $Perm.Write (pTaken@438@01 x i))
        $Perm.No)
      (pTaken@456@01 x i x@454@01 i@455@01))
    $Perm.No)
  
  :qid |quant-u-5300|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@456@01 x i x@454@01 i@455@01) $Perm.No)
  
  :qid |quant-u-5301|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@454@01) (= i i@455@01))
    (= (- $Perm.Write (pTaken@456@01 x i x@454@01 i@455@01)) $Perm.No))
  
  :qid |quant-u-5302|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@457@01 tx@420@01 ti@421@01 x@454@01 i@455@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@457@01 x i x@454@01 i@455@01) $Perm.No)
  
  :qid |quant-u-5304|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@454@01) (= i i@455@01))
    (=
      (-
        (- $Perm.Write (pTaken@456@01 x i x@454@01 i@455@01))
        (pTaken@457@01 x i x@454@01 i@455@01))
      $Perm.No))
  
  :qid |quant-u-5305|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@458@01 $PSF<pair>)
(declare-const s@459@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (ite
    (and
      (and (img@427@01 x@454@01 i@455@01) (img@429@01 x@454@01 i@455@01))
      (and
        (Set_in (inv@426@01 x@454@01 i@455@01) xs@418@01)
        (Seq_contains is@419@01 (inv@428@01 x@454@01 i@455@01))))
    (< $Perm.No (- $Perm.Write (pTaken@438@01 x@454@01 i@455@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@454@01)
        ($SortWrappers.IntTo$Snap i@455@01)))
      ($PSF.lookup_pair $t@425@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@454@01)
        ($SortWrappers.IntTo$Snap i@455@01)))))))
(assert (=>
  (and (= x@454@01 tx@420@01) (= i@455@01 ti@421@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@454@01)
        ($SortWrappers.IntTo$Snap i@455@01)))
      ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@454@01)
        ($SortWrappers.IntTo$Snap i@455@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@454@01)
  ($SortWrappers.IntTo$Snap i@455@01))) x@454@01 i@455@01))
(assert (=
  ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@454@01)
    ($SortWrappers.IntTo$Snap i@455@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@454@01)
      ($SortWrappers.IntTo$Snap i@455@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@454@01)
      ($SortWrappers.IntTo$Snap i@455@01)))))))
(assert (not (= x@454@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addC(x, x.g, i)
; [eval] addC(x, x.g, i)
(set-option :timeout 0)
(push) ; 7
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@454@01)
  ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@454@01)
  ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01))
(pop) ; 7
; Joined path conditions
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@454@01)
  ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@454@01)
  ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (ite
      (and
        (and (img@427@01 x@454@01 i@455@01) (img@429@01 x@454@01 i@455@01))
        (and
          (Set_in (inv@426@01 x@454@01 i@455@01) xs@418@01)
          (Seq_contains is@419@01 (inv@428@01 x@454@01 i@455@01))))
      (< $Perm.No (- $Perm.Write (pTaken@438@01 x@454@01 i@455@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@454@01)
            ($SortWrappers.IntTo$Snap i@455@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01)))
        ($PSF.lookup_pair $t@425@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01))))))
  (=>
    (and (= x@454@01 tx@420@01) (= i@455@01 ti@421@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@454@01)
            ($SortWrappers.IntTo$Snap i@455@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01)))
        ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@454@01)
    ($SortWrappers.IntTo$Snap i@455@01))) x@454@01 i@455@01)
  (=
    ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@454@01)
      ($SortWrappers.IntTo$Snap i@455@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@454@01)
        ($SortWrappers.IntTo$Snap i@455@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@454@01)
        ($SortWrappers.IntTo$Snap i@455@01))))))
  (not (= x@454@01 $Ref.null))
  (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@454@01)
    ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@454@01)
    ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 94 | !(x@454@01 in xs@418@01 && i@455@01 in is@419@01)]
(assert (not (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01))
  (and
    (Set_in x@454@01 xs@418@01)
    (Seq_contains is@419@01 i@455@01)
    (=>
      (ite
        (and
          (and (img@427@01 x@454@01 i@455@01) (img@429@01 x@454@01 i@455@01))
          (and
            (Set_in (inv@426@01 x@454@01 i@455@01) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x@454@01 i@455@01))))
        (< $Perm.No (- $Perm.Write (pTaken@438@01 x@454@01 i@455@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@454@01)
              ($SortWrappers.IntTo$Snap i@455@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@454@01)
            ($SortWrappers.IntTo$Snap i@455@01)))
          ($PSF.lookup_pair $t@425@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@454@01)
            ($SortWrappers.IntTo$Snap i@455@01))))))
    (=>
      (and (= x@454@01 tx@420@01) (= i@455@01 ti@421@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@454@01)
              ($SortWrappers.IntTo$Snap i@455@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@454@01)
            ($SortWrappers.IntTo$Snap i@455@01)))
          ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@454@01)
            ($SortWrappers.IntTo$Snap i@455@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@454@01)
      ($SortWrappers.IntTo$Snap i@455@01))) x@454@01 i@455@01)
    (=
      ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@454@01)
        ($SortWrappers.IntTo$Snap i@455@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01))))))
    (not (= x@454@01 $Ref.null))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@454@01)
      ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@454@01)
      ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01)))
  (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@454@01 $Ref) (i@455@01 Int)) (!
  (and
    (or (Set_in x@454@01 xs@418@01) (not (Set_in x@454@01 xs@418@01)))
    (=>
      (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01))
      (and
        (Set_in x@454@01 xs@418@01)
        (Seq_contains is@419@01 i@455@01)
        (=>
          (ite
            (and
              (and (img@427@01 x@454@01 i@455@01) (img@429@01 x@454@01 i@455@01))
              (and
                (Set_in (inv@426@01 x@454@01 i@455@01) xs@418@01)
                (Seq_contains is@419@01 (inv@428@01 x@454@01 i@455@01))))
            (< $Perm.No (- $Perm.Write (pTaken@438@01 x@454@01 i@455@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@454@01)
                  ($SortWrappers.IntTo$Snap i@455@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@454@01)
                ($SortWrappers.IntTo$Snap i@455@01)))
              ($PSF.lookup_pair $t@425@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@454@01)
                ($SortWrappers.IntTo$Snap i@455@01))))))
        (=>
          (and (= x@454@01 tx@420@01) (= i@455@01 ti@421@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@454@01)
                  ($SortWrappers.IntTo$Snap i@455@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@454@01)
                ($SortWrappers.IntTo$Snap i@455@01)))
              ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@454@01)
                ($SortWrappers.IntTo$Snap i@455@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01))) x@454@01 i@455@01)
        (=
          ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@454@01)
            ($SortWrappers.IntTo$Snap i@455@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@454@01)
              ($SortWrappers.IntTo$Snap i@455@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@454@01)
              ($SortWrappers.IntTo$Snap i@455@01))))))
        (not (= x@454@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01)))
    (or
      (not (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01)))
      (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01))))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@454@01)
    ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@454@01)
    ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71-aux|)))
(assert (forall ((x@454@01 $Ref) (i@455@01 Int)) (!
  (=>
    (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@454@01)
      ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@454@01)
      ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@454@01)
    ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@454@01)
    ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@454@01 $Ref) (i@455@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@454@01)
          ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01))
      (and (Set_in x@454@01 xs@418@01) (Seq_contains is@419@01 i@455@01)))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@454@01)
        ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@454@01)
        ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@454@01)
    ($SortWrappers.IntTo$Snap i@455@01)))) x@454@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@458@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@454@01)
    ($SortWrappers.IntTo$Snap i@455@01))))) i@455@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (forall x: Ref, i: Int :: { addC(x, x.g, i) } (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i)))
(declare-const x@460@01 $Ref)
(declare-const i@461@01 Int)
(set-option :timeout 0)
(push) ; 3
; [eval] (x in xs) && (i in is) ==> (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
; [eval] (x in xs) && (i in is)
; [eval] (x in xs)
(push) ; 4
; [then-branch: 95 | !(x@460@01 in xs@418@01) | live]
; [else-branch: 95 | x@460@01 in xs@418@01 | live]
(push) ; 5
; [then-branch: 95 | !(x@460@01 in xs@418@01)]
(assert (not (Set_in x@460@01 xs@418@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(set-option :timeout 0)
(push) ; 5
; [else-branch: 95 | x@460@01 in xs@418@01]
(assert (Set_in x@460@01 xs@418@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (i in is)
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (or (Set_in x@460@01 xs@418@01) (not (Set_in x@460@01 xs@418@01))))
(set-option :timeout 0)
(push) ; 4
; [then-branch: 96 | x@460@01 in xs@418@01 && i@461@01 in is@419@01 | live]
; [else-branch: 96 | !(x@460@01 in xs@418@01 && i@461@01 in is@419@01) | live]
(push) ; 5
; [then-branch: 96 | x@460@01 in xs@418@01 && i@461@01 in is@419@01]
(assert (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] (unfolding acc(pair(x, i), write) in 0 < addC(x, x.g, i))
(set-option :timeout 0)
(push) ; 6
(push) ; 7
(set-option :timeout 10)
(assert (not (= tx@420@01 x@460@01)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@462@01 ((x $Ref) (i Int) (x@460@01 $Ref) (i@461@01 Int)) $Perm
  (ite
    (and (= x x@460@01) (= i i@461@01))
    ($Perm.min
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        (- $Perm.Write (pTaken@438@01 x i))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@463@01 ((x $Ref) (i Int) (x@460@01 $Ref) (i@461@01 Int)) $Perm
  (ite
    (and (= x x@460@01) (= i i@461@01))
    ($Perm.min
      (ite (and (= x tx@420@01) (= i ti@421@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@462@01 x i x@460@01 i@461@01)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=
    (-
      (ite
        (and
          (and (img@427@01 x i) (img@429@01 x i))
          (and
            (Set_in (inv@426@01 x i) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x i))))
        (- $Perm.Write (pTaken@438@01 x i))
        $Perm.No)
      (pTaken@462@01 x i x@460@01 i@461@01))
    $Perm.No)
  
  :qid |quant-u-5307|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@462@01 x i x@460@01 i@461@01) $Perm.No)
  
  :qid |quant-u-5308|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@460@01) (= i i@461@01))
    (= (- $Perm.Write (pTaken@462@01 x i x@460@01 i@461@01)) $Perm.No))
  
  :qid |quant-u-5309|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Chunk depleted?
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (=
  (- $Perm.Write (pTaken@463@01 tx@420@01 ti@421@01 x@460@01 i@461@01))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (forall ((x $Ref) (i Int)) (!
  (= (pTaken@463@01 x i x@460@01 i@461@01) $Perm.No)
  
  :qid |quant-u-5311|))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 500)
(assert (not (forall ((x $Ref) (i Int)) (!
  (=>
    (and (= x x@460@01) (= i i@461@01))
    (=
      (-
        (- $Perm.Write (pTaken@462@01 x i x@460@01 i@461@01))
        (pTaken@463@01 x i x@460@01 i@461@01))
      $Perm.No))
  
  :qid |quant-u-5312|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@464@01 $PSF<pair>)
(declare-const s@465@01 $Snap)
; Definitional axioms for snapshot map domain (instantiated)
; Definitional axioms for snapshot map values (instantiated)
(assert (=>
  (and (= x@460@01 tx@420@01) (= i@461@01 ti@421@01))
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@460@01)
        ($SortWrappers.IntTo$Snap i@461@01)))
      ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@460@01)
        ($SortWrappers.IntTo$Snap i@461@01)))))))
(assert (=>
  (ite
    (and
      (and (img@427@01 x@460@01 i@461@01) (img@429@01 x@460@01 i@461@01))
      (and
        (Set_in (inv@426@01 x@460@01 i@461@01) xs@418@01)
        (Seq_contains is@419@01 (inv@428@01 x@460@01 i@461@01))))
    (< $Perm.No (- $Perm.Write (pTaken@438@01 x@460@01 i@461@01)))
    false)
  (and
    (not
      (=
        ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01))
        $Snap.unit))
    (=
      ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@460@01)
        ($SortWrappers.IntTo$Snap i@461@01)))
      ($PSF.lookup_pair $t@425@01 ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@460@01)
        ($SortWrappers.IntTo$Snap i@461@01)))))))
(assert (pair%trigger ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@460@01)
  ($SortWrappers.IntTo$Snap i@461@01))) x@460@01 i@461@01))
(assert (=
  ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@460@01)
    ($SortWrappers.IntTo$Snap i@461@01)))
  ($Snap.combine
    ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@460@01)
      ($SortWrappers.IntTo$Snap i@461@01))))
    ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@460@01)
      ($SortWrappers.IntTo$Snap i@461@01)))))))
(assert (not (= x@460@01 $Ref.null)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; [eval] 0 < addC(x, x.g, i)
; [eval] addC(x, x.g, i)
(set-option :timeout 0)
(push) ; 7
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@460@01)
  ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@460@01)
  ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01))
(pop) ; 7
; Joined path conditions
(assert (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@460@01)
  ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
  ($SortWrappers.$RefTo$Snap x@460@01)
  ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01))
(pop) ; 6
; Joined path conditions
(assert (and
  (=>
    (and (= x@460@01 tx@420@01) (= i@461@01 ti@421@01))
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@460@01)
            ($SortWrappers.IntTo$Snap i@461@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01)))
        ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01))))))
  (=>
    (ite
      (and
        (and (img@427@01 x@460@01 i@461@01) (img@429@01 x@460@01 i@461@01))
        (and
          (Set_in (inv@426@01 x@460@01 i@461@01) xs@418@01)
          (Seq_contains is@419@01 (inv@428@01 x@460@01 i@461@01))))
      (< $Perm.No (- $Perm.Write (pTaken@438@01 x@460@01 i@461@01)))
      false)
    (and
      (not
        (=
          ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@460@01)
            ($SortWrappers.IntTo$Snap i@461@01))
          $Snap.unit))
      (=
        ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01)))
        ($PSF.lookup_pair $t@425@01 ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01))))))
  (pair%trigger ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@460@01)
    ($SortWrappers.IntTo$Snap i@461@01))) x@460@01 i@461@01)
  (=
    ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@460@01)
      ($SortWrappers.IntTo$Snap i@461@01)))
    ($Snap.combine
      ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@460@01)
        ($SortWrappers.IntTo$Snap i@461@01))))
      ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@460@01)
        ($SortWrappers.IntTo$Snap i@461@01))))))
  (not (= x@460@01 $Ref.null))
  (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@460@01)
    ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@460@01)
    ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01)))
(pop) ; 5
(push) ; 5
; [else-branch: 96 | !(x@460@01 in xs@418@01 && i@461@01 in is@419@01)]
(assert (not (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (=>
  (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01))
  (and
    (Set_in x@460@01 xs@418@01)
    (Seq_contains is@419@01 i@461@01)
    (=>
      (and (= x@460@01 tx@420@01) (= i@461@01 ti@421@01))
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@460@01)
              ($SortWrappers.IntTo$Snap i@461@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@460@01)
            ($SortWrappers.IntTo$Snap i@461@01)))
          ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@460@01)
            ($SortWrappers.IntTo$Snap i@461@01))))))
    (=>
      (ite
        (and
          (and (img@427@01 x@460@01 i@461@01) (img@429@01 x@460@01 i@461@01))
          (and
            (Set_in (inv@426@01 x@460@01 i@461@01) xs@418@01)
            (Seq_contains is@419@01 (inv@428@01 x@460@01 i@461@01))))
        (< $Perm.No (- $Perm.Write (pTaken@438@01 x@460@01 i@461@01)))
        false)
      (and
        (not
          (=
            ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@460@01)
              ($SortWrappers.IntTo$Snap i@461@01))
            $Snap.unit))
        (=
          ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@460@01)
            ($SortWrappers.IntTo$Snap i@461@01)))
          ($PSF.lookup_pair $t@425@01 ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@460@01)
            ($SortWrappers.IntTo$Snap i@461@01))))))
    (pair%trigger ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@460@01)
      ($SortWrappers.IntTo$Snap i@461@01))) x@460@01 i@461@01)
    (=
      ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@460@01)
        ($SortWrappers.IntTo$Snap i@461@01)))
      ($Snap.combine
        ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01))))
        ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01))))))
    (not (= x@460@01 $Ref.null))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@460@01)
      ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@460@01)
      ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01))))
; Joined path conditions
(assert (or
  (not (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01)))
  (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01))))
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((x@460@01 $Ref) (i@461@01 Int)) (!
  (and
    (or (Set_in x@460@01 xs@418@01) (not (Set_in x@460@01 xs@418@01)))
    (=>
      (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01))
      (and
        (Set_in x@460@01 xs@418@01)
        (Seq_contains is@419@01 i@461@01)
        (=>
          (and (= x@460@01 tx@420@01) (= i@461@01 ti@421@01))
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@460@01)
                  ($SortWrappers.IntTo$Snap i@461@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@460@01)
                ($SortWrappers.IntTo$Snap i@461@01)))
              ($PSF.lookup_pair (as sm@441@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@460@01)
                ($SortWrappers.IntTo$Snap i@461@01))))))
        (=>
          (ite
            (and
              (and (img@427@01 x@460@01 i@461@01) (img@429@01 x@460@01 i@461@01))
              (and
                (Set_in (inv@426@01 x@460@01 i@461@01) xs@418@01)
                (Seq_contains is@419@01 (inv@428@01 x@460@01 i@461@01))))
            (< $Perm.No (- $Perm.Write (pTaken@438@01 x@460@01 i@461@01)))
            false)
          (and
            (not
              (=
                ($Snap.combine
                  ($SortWrappers.$RefTo$Snap x@460@01)
                  ($SortWrappers.IntTo$Snap i@461@01))
                $Snap.unit))
            (=
              ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@460@01)
                ($SortWrappers.IntTo$Snap i@461@01)))
              ($PSF.lookup_pair $t@425@01 ($Snap.combine
                ($SortWrappers.$RefTo$Snap x@460@01)
                ($SortWrappers.IntTo$Snap i@461@01))))))
        (pair%trigger ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01))) x@460@01 i@461@01)
        (=
          ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
            ($SortWrappers.$RefTo$Snap x@460@01)
            ($SortWrappers.IntTo$Snap i@461@01)))
          ($Snap.combine
            ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@460@01)
              ($SortWrappers.IntTo$Snap i@461@01))))
            ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
              ($SortWrappers.$RefTo$Snap x@460@01)
              ($SortWrappers.IntTo$Snap i@461@01))))))
        (not (= x@460@01 $Ref.null))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01)))
    (or
      (not (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01)))
      (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01))))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@460@01)
    ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@460@01)
    ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71-aux|)))
(assert (forall ((x@460@01 $Ref) (i@461@01 Int)) (!
  (=>
    (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01))
    (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@460@01)
      ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
      ($SortWrappers.$RefTo$Snap x@460@01)
      ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@460@01)
    ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@460@01)
    ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71_precondition|)))
(set-option :timeout 0)
(push) ; 3
(assert (not (forall ((x@460@01 $Ref) (i@461@01 Int)) (!
  (=>
    (and
      (=>
        (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01))
        (addC%precondition ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
          ($SortWrappers.$RefTo$Snap x@460@01)
          ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01))
      (and (Set_in x@460@01 xs@418@01) (Seq_contains is@419@01 i@461@01)))
    (<
      0
      (addC ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@460@01)
        ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
        ($SortWrappers.$RefTo$Snap x@460@01)
        ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01)))
  :pattern ((addC%limited ($Snap.first ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@460@01)
    ($SortWrappers.IntTo$Snap i@461@01)))) x@460@01 ($SortWrappers.$SnapToInt ($Snap.second ($PSF.lookup_pair (as sm@464@01  $PSF<pair>) ($Snap.combine
    ($SortWrappers.$RefTo$Snap x@460@01)
    ($SortWrappers.IntTo$Snap i@461@01))))) i@461@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/src/test/resources/snapshots/test_qps.vpr@201@10@202@71|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(pop) ; 2
(pop) ; 1
