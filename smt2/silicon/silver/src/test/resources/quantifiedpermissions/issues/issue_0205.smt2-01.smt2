(get-info :version)
; (:version "4.12.1")
; Started: 2024-12-26 19:32:28
; Silicon.version: 1.1-SNAPSHOT (457c6eca@(detached))
; Input file: <unknown>
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Necessary for push pop mode
(set-option :auto_config false)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :type_check true)
(set-option :smt.mbqi false)
(set-option :pp.bv_literals false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.arith.solver 2)
(set-option :model.v2 true)
(set-option :smt.qi.max_multi_patterns 1000)
; 
; ; /preamble.smt2
(declare-datatypes (($Snap 0)) ((
    ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM 0)
(declare-sort $PPM 0)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<$Ref> 0)
(declare-sort Seq<Int> 0)
(declare-sort Set<Int> 0)
(declare-sort Set<Seq<$Ref>> 0)
(declare-sort Set<$Ref> 0)
(declare-sort Set<$Snap> 0)
(declare-sort $FVF<f> 0)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<$Ref>To$Snap (Seq<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<$Ref> ($Snap) Seq<$Ref>)
(assert (forall ((x Seq<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSeq<$Ref>($SortWrappers.Seq<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Seq<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSeq<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<$Ref>To$Snap($SortWrappers.$SnapToSeq<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSeq<$Ref> x))
    :qid |$Snap.Seq<$Ref>To$SnapToSeq<$Ref>|
    )))
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<Seq<$Ref>>To$Snap (Set<Seq<$Ref>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Seq<$Ref>> ($Snap) Set<Seq<$Ref>>)
(assert (forall ((x Set<Seq<$Ref>>)) (!
    (= x ($SortWrappers.$SnapToSet<Seq<$Ref>>($SortWrappers.Set<Seq<$Ref>>To$Snap x)))
    :pattern (($SortWrappers.Set<Seq<$Ref>>To$Snap x))
    :qid |$Snap.$SnapToSet<Seq<$Ref>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Seq<$Ref>>To$Snap($SortWrappers.$SnapToSet<Seq<$Ref>> x)))
    :pattern (($SortWrappers.$SnapToSet<Seq<$Ref>> x))
    :qid |$Snap.Set<Seq<$Ref>>To$SnapToSet<Seq<$Ref>>|
    )))
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<f>To$Snap ($FVF<f>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<f> ($Snap) $FVF<f>)
(assert (forall ((x $FVF<f>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<f>($SortWrappers.$FVF<f>To$Snap x)))
    :pattern (($SortWrappers.$FVF<f>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<f>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<f>To$Snap($SortWrappers.$SnapTo$FVF<f> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<f> x))
    :qid |$Snap.$FVF<f>To$SnapTo$FVF<f>|
    )))
; ////////// Symbols
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_skolem_diff (Set<Int> Set<Int>) Int)
(declare-fun Set_card (Set<Seq<$Ref>>) Int)
(declare-const Set_empty Set<Seq<$Ref>>)
(declare-fun Set_in (Seq<$Ref> Set<Seq<$Ref>>) Bool)
(declare-fun Set_singleton (Seq<$Ref>) Set<Seq<$Ref>>)
(declare-fun Set_unionone (Set<Seq<$Ref>> Seq<$Ref>) Set<Seq<$Ref>>)
(declare-fun Set_union (Set<Seq<$Ref>> Set<Seq<$Ref>>) Set<Seq<$Ref>>)
(declare-fun Set_intersection (Set<Seq<$Ref>> Set<Seq<$Ref>>) Set<Seq<$Ref>>)
(declare-fun Set_difference (Set<Seq<$Ref>> Set<Seq<$Ref>>) Set<Seq<$Ref>>)
(declare-fun Set_subset (Set<Seq<$Ref>> Set<Seq<$Ref>>) Bool)
(declare-fun Set_equal (Set<Seq<$Ref>> Set<Seq<$Ref>>) Bool)
(declare-fun Set_skolem_diff (Set<Seq<$Ref>> Set<Seq<$Ref>>) Seq<$Ref>)
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_skolem_diff (Set<$Ref> Set<$Ref>) $Ref)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_skolem_diff (Set<$Snap> Set<$Snap>) $Snap)
(declare-fun Seq_length (Seq<$Ref>) Int)
(declare-const Seq_empty Seq<$Ref>)
(declare-fun Seq_singleton ($Ref) Seq<$Ref>)
(declare-fun Seq_append (Seq<$Ref> Seq<$Ref>) Seq<$Ref>)
(declare-fun Seq_index (Seq<$Ref> Int) $Ref)
(declare-fun Seq_add (Int Int) Int)
(declare-fun Seq_sub (Int Int) Int)
(declare-fun Seq_update (Seq<$Ref> Int $Ref) Seq<$Ref>)
(declare-fun Seq_take (Seq<$Ref> Int) Seq<$Ref>)
(declare-fun Seq_drop (Seq<$Ref> Int) Seq<$Ref>)
(declare-fun Seq_contains (Seq<$Ref> $Ref) Bool)
(declare-fun Seq_contains_trigger (Seq<$Ref> $Ref) Bool)
(declare-fun Seq_skolem (Seq<$Ref> $Ref) Int)
(declare-fun Seq_equal (Seq<$Ref> Seq<$Ref>) Bool)
(declare-fun Seq_skolem_diff (Seq<$Ref> Seq<$Ref>) Int)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_contains_trigger (Seq<Int> Int) Bool)
(declare-fun Seq_skolem (Seq<Int> Int) Int)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_skolem_diff (Seq<Int> Seq<Int>) Int)
(declare-fun Seq_range (Int Int) Seq<Int>)
; /field_value_functions_declarations.smt2 [f: Int]
(declare-fun $FVF.domain_f ($FVF<f>) Set<$Ref>)
(declare-fun $FVF.lookup_f ($FVF<f> $Ref) Int)
(declare-fun $FVF.after_f ($FVF<f> $FVF<f>) Bool)
(declare-fun $FVF.loc_f (Int $Ref) Bool)
(declare-fun $FVF.perm_f ($FPM $Ref) $Perm)
(declare-const $fvfTOP_f $FVF<f>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun fun04qp ($Snap $Ref Int) Int)
(declare-fun fun04qp%limited ($Snap $Ref Int) Int)
(declare-fun fun04qp%stateless ($Ref Int) Bool)
(declare-fun fun04qp%precondition ($Snap $Ref Int) Bool)
(declare-fun fun01qp ($Snap Seq<$Ref> Int) Int)
(declare-fun fun01qp%limited ($Snap Seq<$Ref> Int) Int)
(declare-fun fun01qp%stateless (Seq<$Ref> Int) Bool)
(declare-fun fun01qp%precondition ($Snap Seq<$Ref> Int) Bool)
(declare-fun fun01 ($Snap $Ref $Ref Bool) Int)
(declare-fun fun01%limited ($Snap $Ref $Ref Bool) Int)
(declare-fun fun01%stateless ($Ref $Ref Bool) Bool)
(declare-fun fun01%precondition ($Snap $Ref $Ref Bool) Bool)
(declare-fun fun02qp ($Snap Seq<$Ref> Int) Int)
(declare-fun fun02qp%limited ($Snap Seq<$Ref> Int) Int)
(declare-fun fun02qp%stateless (Seq<$Ref> Int) Bool)
(declare-fun fun02qp%precondition ($Snap Seq<$Ref> Int) Bool)
(declare-fun fun03qp ($Snap $Ref Int) Int)
(declare-fun fun03qp%limited ($Snap $Ref Int) Int)
(declare-fun fun03qp%stateless ($Ref Int) Bool)
(declare-fun fun03qp%precondition ($Snap $Ref Int) Bool)
(declare-fun fun02 ($Snap $Ref $Ref Bool) Int)
(declare-fun fun02%limited ($Snap $Ref $Ref Bool) Int)
(declare-fun fun02%stateless ($Ref $Ref Bool) Bool)
(declare-fun fun02%precondition ($Snap $Ref $Ref Bool) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<$Ref>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  )))
(assert (= (Seq_length (as Seq_empty  Seq<$Ref>)) 0))
(assert (forall ((s Seq<$Ref>)) (!
  (=> (= (Seq_length s) 0) (= s (as Seq_empty  Seq<$Ref>)))
  :pattern ((Seq_length s))
  )))
(assert (forall ((e $Ref)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<$Ref>)))
      (not (= s1 (as Seq_empty  Seq<$Ref>))))
    (= (Seq_length (Seq_append s0 s1)) (+ (Seq_length s0) (Seq_length s1))))
  :pattern ((Seq_length (Seq_append s0 s1)))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>)) (!
  (and
    (=> (= s0 (as Seq_empty  Seq<$Ref>)) (= (Seq_append s0 s1) s1))
    (=> (= s1 (as Seq_empty  Seq<$Ref>)) (= (Seq_append s0 s1) s0)))
  :pattern ((Seq_append s0 s1))
  )))
(assert (forall ((e $Ref)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((i Int) (j Int)) (!
  (= (Seq_add i j) (+ i j))
  :pattern ((Seq_add i j))
  )))
(assert (forall ((i Int) (j Int)) (!
  (= (Seq_sub i j) (- i j))
  :pattern ((Seq_sub i j))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<$Ref>)))
      (and
        (not (= s1 (as Seq_empty  Seq<$Ref>)))
        (and (<= 0 n) (< n (Seq_length s0)))))
    (= (Seq_index (Seq_append s0 s1) n) (Seq_index s0 n)))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  :pattern ((Seq_index s0 n) (Seq_append s0 s1))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<$Ref>)))
      (and
        (not (= s1 (as Seq_empty  Seq<$Ref>)))
        (and (<= (Seq_length s0) n) (< n (Seq_length (Seq_append s0 s1))))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s0)) (Seq_length s0)) n)
      (=
        (Seq_index (Seq_append s0 s1) n)
        (Seq_index s1 (Seq_sub n (Seq_length s0))))))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>) (m Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<$Ref>)))
      (and
        (not (= s1 (as Seq_empty  Seq<$Ref>)))
        (and (<= 0 m) (< m (Seq_length s1)))))
    (and
      (= (Seq_sub (Seq_add m (Seq_length s0)) (Seq_length s0)) m)
      (=
        (Seq_index (Seq_append s0 s1) (Seq_add m (Seq_length s0)))
        (Seq_index s1 m))))
  :pattern ((Seq_index s1 m) (Seq_append s0 s1))
  )))
(assert (forall ((s Seq<$Ref>) (i Int) (v $Ref)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i v)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i v)))
  :pattern ((Seq_length s) (Seq_update s i v))
  )))
(assert (forall ((s Seq<$Ref>) (i Int) (v $Ref) (n Int)) (!
  (=>
    (and (<= 0 n) (< n (Seq_length s)))
    (and
      (=> (= i n) (= (Seq_index (Seq_update s i v) n) v))
      (=> (not (= i n)) (= (Seq_index (Seq_update s i v) n) (Seq_index s n)))))
  :pattern ((Seq_index (Seq_update s i v) n))
  :pattern ((Seq_index s n) (Seq_update s i v))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=> (<= n (Seq_length s)) (= (Seq_length (Seq_take s n)) n))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_take s n)) (Seq_length s)))))
    (=> (< n 0) (= (Seq_length (Seq_take s n)) 0)))
  :pattern ((Seq_length (Seq_take s n)))
  :pattern ((Seq_take s n) (Seq_length s))
  )))
(assert (forall ((s Seq<$Ref>) (n Int) (j Int)) (!
  (=>
    (and (<= 0 j) (and (< j n) (< j (Seq_length s))))
    (= (Seq_index (Seq_take s n) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_take s n) j))
  :pattern ((Seq_index s j) (Seq_take s n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=>
          (<= n (Seq_length s))
          (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n)))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_drop s n)) 0))))
    (=> (< n 0) (= (Seq_length (Seq_drop s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_drop s n)))
  :pattern ((Seq_length s) (Seq_drop s n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int) (j Int)) (!
  (=>
    (and (< 0 n) (and (<= 0 j) (< j (- (Seq_length s) n))))
    (and
      (= (Seq_sub (Seq_add j n) n) j)
      (= (Seq_index (Seq_drop s n) j) (Seq_index s (Seq_add j n)))))
  :pattern ((Seq_index (Seq_drop s n) j))
  )))
(assert (forall ((s Seq<$Ref>) (n Int) (i Int)) (!
  (=>
    (and (< 0 n) (and (<= n i) (< i (Seq_length s))))
    (and
      (= (Seq_add (Seq_sub i n) n) i)
      (= (Seq_index (Seq_drop s n) (Seq_sub i n)) (Seq_index s i))))
  :pattern ((Seq_drop s n) (Seq_index s i))
  )))
(assert (forall ((s Seq<$Ref>) (t Seq<$Ref>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_take (Seq_append s t) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<$Ref>) (t Seq<$Ref>) (n Int)) (!
  (=>
    (and (> n 0) (and (> n (Seq_length s)) (< n (Seq_length (Seq_append s t)))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (=
        (Seq_take (Seq_append s t) n)
        (Seq_append s (Seq_take t (Seq_sub n (Seq_length s)))))))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<$Ref>) (t Seq<$Ref>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_append s t) n) (Seq_append (Seq_drop s n) t)))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<$Ref>) (t Seq<$Ref>) (n Int)) (!
  (=>
    (and (> n 0) (> n (Seq_length s)))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (= (Seq_drop (Seq_append s t) n) (Seq_drop t (Seq_sub n (Seq_length s))))))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (=> (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<$Ref>)))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (=> (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_take s n) s))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<$Ref>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_drop s n) (as Seq_empty  Seq<$Ref>)))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<$Ref>) (x $Ref)) (!
  (=>
    (Seq_contains s x)
    (and
      (<= 0 (Seq_skolem s x))
      (and
        (< (Seq_skolem s x) (Seq_length s))
        (= (Seq_index s (Seq_skolem s x)) x))))
  :pattern ((Seq_contains s x))
  )))
(assert (forall ((s Seq<$Ref>) (x $Ref) (i Int)) (!
  (=>
    (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) x)))
    (Seq_contains s x))
  :pattern ((Seq_contains s x) (Seq_index s i))
  )))
(assert (forall ((s Seq<$Ref>) (i Int)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (Seq_contains_trigger s (Seq_index s i)))
  :pattern ((Seq_index s i))
  )))
(assert (forall ((s0 Seq<$Ref>) (s1 Seq<$Ref>)) (!
  (or
    (and (= s0 s1) (Seq_equal s0 s1))
    (or
      (and
        (not (= s0 s1))
        (and (not (Seq_equal s0 s1)) (not (= (Seq_length s0) (Seq_length s1)))))
      (and
        (not (= s0 s1))
        (and
          (not (Seq_equal s0 s1))
          (and
            (= (Seq_length s0) (Seq_length s1))
            (and
              (= (Seq_skolem_diff s0 s1) (Seq_skolem_diff s1 s0))
              (and
                (<= 0 (Seq_skolem_diff s0 s1))
                (and
                  (< (Seq_skolem_diff s0 s1) (Seq_length s0))
                  (not
                    (=
                      (Seq_index s0 (Seq_skolem_diff s0 s1))
                      (Seq_index s1 (Seq_skolem_diff s0 s1))))))))))))
  :pattern ((Seq_equal s0 s1))
  )))
(assert (forall ((a Seq<$Ref>) (b Seq<$Ref>)) (!
  (=> (Seq_equal a b) (= a b))
  :pattern ((Seq_equal a b))
  )))
(assert (forall ((x $Ref) (y $Ref)) (!
  (= (Seq_contains (Seq_singleton x) y) (= x y))
  :pattern ((Seq_contains (Seq_singleton x) y))
  )))
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  )))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (=> (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  )))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (not (= s1 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s0 s1)) (+ (Seq_length s0) (Seq_length s1))))
  :pattern ((Seq_length (Seq_append s0 s1)))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>)) (!
  (and
    (=> (= s0 (as Seq_empty  Seq<Int>)) (= (Seq_append s0 s1) s1))
    (=> (= s1 (as Seq_empty  Seq<Int>)) (= (Seq_append s0 s1) s0)))
  :pattern ((Seq_append s0 s1))
  )))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_singleton e))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Int>)))
        (and (<= 0 n) (< n (Seq_length s0)))))
    (= (Seq_index (Seq_append s0 s1) n) (Seq_index s0 n)))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  :pattern ((Seq_index s0 n) (Seq_append s0 s1))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>) (n Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Int>)))
        (and (<= (Seq_length s0) n) (< n (Seq_length (Seq_append s0 s1))))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s0)) (Seq_length s0)) n)
      (=
        (Seq_index (Seq_append s0 s1) n)
        (Seq_index s1 (Seq_sub n (Seq_length s0))))))
  :pattern ((Seq_index (Seq_append s0 s1) n))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>) (m Int)) (!
  (=>
    (and
      (not (= s0 (as Seq_empty  Seq<Int>)))
      (and
        (not (= s1 (as Seq_empty  Seq<Int>)))
        (and (<= 0 m) (< m (Seq_length s1)))))
    (and
      (= (Seq_sub (Seq_add m (Seq_length s0)) (Seq_length s0)) m)
      (=
        (Seq_index (Seq_append s0 s1) (Seq_add m (Seq_length s0)))
        (Seq_index s1 m))))
  :pattern ((Seq_index s1 m) (Seq_append s0 s1))
  )))
(assert (forall ((s Seq<Int>) (i Int) (v Int)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i v)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i v)))
  :pattern ((Seq_length s) (Seq_update s i v))
  )))
(assert (forall ((s Seq<Int>) (i Int) (v Int) (n Int)) (!
  (=>
    (and (<= 0 n) (< n (Seq_length s)))
    (and
      (=> (= i n) (= (Seq_index (Seq_update s i v) n) v))
      (=> (not (= i n)) (= (Seq_index (Seq_update s i v) n) (Seq_index s n)))))
  :pattern ((Seq_index (Seq_update s i v) n))
  :pattern ((Seq_index s n) (Seq_update s i v))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=> (<= n (Seq_length s)) (= (Seq_length (Seq_take s n)) n))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_take s n)) (Seq_length s)))))
    (=> (< n 0) (= (Seq_length (Seq_take s n)) 0)))
  :pattern ((Seq_length (Seq_take s n)))
  :pattern ((Seq_take s n) (Seq_length s))
  )))
(assert (forall ((s Seq<Int>) (n Int) (j Int)) (!
  (=>
    (and (<= 0 j) (and (< j n) (< j (Seq_length s))))
    (= (Seq_index (Seq_take s n) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_take s n) j))
  :pattern ((Seq_index s j) (Seq_take s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (and
    (=>
      (<= 0 n)
      (and
        (=>
          (<= n (Seq_length s))
          (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n)))
        (=> (< (Seq_length s) n) (= (Seq_length (Seq_drop s n)) 0))))
    (=> (< n 0) (= (Seq_length (Seq_drop s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_drop s n)))
  :pattern ((Seq_length s) (Seq_drop s n))
  )))
(assert (forall ((s Seq<Int>) (n Int) (j Int)) (!
  (=>
    (and (< 0 n) (and (<= 0 j) (< j (- (Seq_length s) n))))
    (and
      (= (Seq_sub (Seq_add j n) n) j)
      (= (Seq_index (Seq_drop s n) j) (Seq_index s (Seq_add j n)))))
  :pattern ((Seq_index (Seq_drop s n) j))
  )))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (=>
    (and (< 0 n) (and (<= n i) (< i (Seq_length s))))
    (and
      (= (Seq_add (Seq_sub i n) n) i)
      (= (Seq_index (Seq_drop s n) (Seq_sub i n)) (Seq_index s i))))
  :pattern ((Seq_drop s n) (Seq_index s i))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_take (Seq_append s t) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (> n 0) (and (> n (Seq_length s)) (< n (Seq_length (Seq_append s t)))))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (=
        (Seq_take (Seq_append s t) n)
        (Seq_append s (Seq_take t (Seq_sub n (Seq_length s)))))))
  :pattern ((Seq_take (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (< 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_append s t) n) (Seq_append (Seq_drop s n) t)))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (t Seq<Int>) (n Int)) (!
  (=>
    (and (> n 0) (> n (Seq_length s)))
    (and
      (= (Seq_add (Seq_sub n (Seq_length s)) (Seq_length s)) n)
      (= (Seq_drop (Seq_append s t) n) (Seq_drop t (Seq_sub n (Seq_length s))))))
  :pattern ((Seq_drop (Seq_append s t) n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_take s n) s))
  :pattern ((Seq_take s n))
  )))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (=> (>= n (Seq_length s)) (= (Seq_drop s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_drop s n))
  )))
(assert (forall ((s Seq<Int>) (x Int)) (!
  (=>
    (Seq_contains s x)
    (and
      (<= 0 (Seq_skolem s x))
      (and
        (< (Seq_skolem s x) (Seq_length s))
        (= (Seq_index s (Seq_skolem s x)) x))))
  :pattern ((Seq_contains s x))
  )))
(assert (forall ((s Seq<Int>) (x Int) (i Int)) (!
  (=>
    (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) x)))
    (Seq_contains s x))
  :pattern ((Seq_contains s x) (Seq_index s i))
  )))
(assert (forall ((s Seq<Int>) (i Int)) (!
  (=>
    (and (<= 0 i) (< i (Seq_length s)))
    (Seq_contains_trigger s (Seq_index s i)))
  :pattern ((Seq_index s i))
  )))
(assert (forall ((s0 Seq<Int>) (s1 Seq<Int>)) (!
  (or
    (and (= s0 s1) (Seq_equal s0 s1))
    (or
      (and
        (not (= s0 s1))
        (and (not (Seq_equal s0 s1)) (not (= (Seq_length s0) (Seq_length s1)))))
      (and
        (not (= s0 s1))
        (and
          (not (Seq_equal s0 s1))
          (and
            (= (Seq_length s0) (Seq_length s1))
            (and
              (= (Seq_skolem_diff s0 s1) (Seq_skolem_diff s1 s0))
              (and
                (<= 0 (Seq_skolem_diff s0 s1))
                (and
                  (< (Seq_skolem_diff s0 s1) (Seq_length s0))
                  (not
                    (=
                      (Seq_index s0 (Seq_skolem_diff s0 s1))
                      (Seq_index s1 (Seq_skolem_diff s0 s1))))))))))))
  :pattern ((Seq_equal s0 s1))
  )))
(assert (forall ((a Seq<Int>) (b Seq<Int>)) (!
  (=> (Seq_equal a b) (= a b))
  :pattern ((Seq_equal a b))
  )))
(assert (forall ((x Int) (y Int)) (!
  (= (Seq_contains (Seq_singleton x) y) (= x y))
  :pattern ((Seq_contains (Seq_singleton x) y))
  )))
(assert (forall ((min_ Int) (max Int)) (!
  (and
    (=> (< min_ max) (= (Seq_length (Seq_range min_ max)) (- max min_)))
    (=> (<= max min_) (= (Seq_length (Seq_range min_ max)) 0)))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (j Int)) (!
  (=>
    (and (<= 0 j) (< j (- max min_)))
    (= (Seq_index (Seq_range min_ max) j) (+ min_ j)))
  :pattern ((Seq_index (Seq_range min_ max) j))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (v Int)) (!
  (= (Seq_contains (Seq_range min_ max) v) (and (<= min_ v) (< v max)))
  :pattern ((Seq_contains (Seq_range min_ max) v))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o Int)) (!
  (not (Set_in o (as Set_empty  Set<Int>)))
  :pattern ((Set_in o (as Set_empty  Set<Int>)))
  )))
(assert (forall ((s Set<Int>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (=> (not (= (Set_card s) 0)) (exists ((x Int))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r Int)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r Int) (o Int)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r Int)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<Int>) (x Int) (o Int)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<Int>) (x Int)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<Int>) (x Int) (y Int)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<Int>) (x Int)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Int>) (x Int)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (o Int)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (y Int)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (y Int)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (o Int)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (o Int)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>) (y Int)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (=
    (Set_subset a b)
    (forall ((o Int)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<Int>) (b Set<Int>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<Seq<$Ref>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o Seq<$Ref>)) (!
  (not (Set_in o (as Set_empty  Set<Seq<$Ref>>)))
  :pattern ((Set_in o (as Set_empty  Set<Seq<$Ref>>)))
  )))
(assert (forall ((s Set<Seq<$Ref>>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<Seq<$Ref>>)))
    (=> (not (= (Set_card s) 0)) (exists ((x Seq<$Ref>))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r Seq<$Ref>)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r Seq<$Ref>) (o Seq<$Ref>)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r Seq<$Ref>)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (x Seq<$Ref>) (o Seq<$Ref>)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (x Seq<$Ref>)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (x Seq<$Ref>) (y Seq<$Ref>)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (x Seq<$Ref>)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (x Seq<$Ref>)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>) (o Seq<$Ref>)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>) (y Seq<$Ref>)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>) (y Seq<$Ref>)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>) (o Seq<$Ref>)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>) (o Seq<$Ref>)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>) (y Seq<$Ref>)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>)) (!
  (=
    (Set_subset a b)
    (forall ((o Seq<$Ref>)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<Seq<$Ref>>) (b Set<Seq<$Ref>>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Ref)) (!
  (not (Set_in o (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in o (as Set_empty  Set<$Ref>)))
  )))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Ref))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Ref)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Ref) (o $Ref)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Ref)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (o $Ref)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (x $Ref)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (o $Ref)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>) (y $Ref)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Ref)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Ref>) (b Set<$Ref>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  )))
(assert (forall ((o $Snap)) (!
  (not (Set_in o (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in o (as Set_empty  Set<$Snap>)))
  )))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (=> (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (=> (not (= (Set_card s) 0)) (exists ((x $Snap))  (Set_in x s))))
  :pattern ((Set_card s))
  )))
(assert (forall ((r $Snap)) (!
  (Set_in r (Set_singleton r))
  :pattern ((Set_singleton r))
  )))
(assert (forall ((r $Snap) (o $Snap)) (!
  (= (Set_in o (Set_singleton r)) (= r o))
  :pattern ((Set_in o (Set_singleton r)))
  )))
(assert (forall ((r $Snap)) (!
  (= (Set_card (Set_singleton r)) 1)
  :pattern ((Set_card (Set_singleton r)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (o $Snap)) (!
  (= (Set_in o (Set_unionone a x)) (or (= o x) (Set_in o a)))
  :pattern ((Set_in o (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (Set_in x (Set_unionone a x))
  :pattern ((Set_unionone a x))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_unionone a x)))
  :pattern ((Set_unionone a x) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (Set_in x a) (= (Set_card (Set_unionone a x)) (Set_card a)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (x $Snap)) (!
  (=> (not (Set_in x a)) (= (Set_card (Set_unionone a x)) (+ (Set_card a) 1)))
  :pattern ((Set_card (Set_unionone a x)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_union a b)) (or (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y a) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (Set_in y (Set_union a b)))
  :pattern ((Set_union a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_intersection a b)) (and (Set_in o a) (Set_in o b)))
  :pattern ((Set_in o (Set_intersection a b)))
  :pattern ((Set_intersection a b) (Set_in o a))
  :pattern ((Set_intersection a b) (Set_in o b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union (Set_union a b) b) (Set_union a b))
  :pattern ((Set_union (Set_union a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_union a (Set_union a b)) (Set_union a b))
  :pattern ((Set_union a (Set_union a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection a b) b) (Set_intersection a b))
  :pattern ((Set_intersection (Set_intersection a b) b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (= (Set_intersection a (Set_intersection a b)) (Set_intersection a b))
  :pattern ((Set_intersection a (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union a b)) (Set_card (Set_intersection a b)))
    (+ (Set_card a) (Set_card b)))
  :pattern ((Set_card (Set_union a b)))
  :pattern ((Set_card (Set_intersection a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (o $Snap)) (!
  (= (Set_in o (Set_difference a b)) (and (Set_in o a) (not (Set_in o b))))
  :pattern ((Set_in o (Set_difference a b)))
  :pattern ((Set_difference a b) (Set_in o a))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>) (y $Snap)) (!
  (=> (Set_in y b) (not (Set_in y (Set_difference a b))))
  :pattern ((Set_difference a b) (Set_in y b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference a b)) (Set_card (Set_difference b a)))
        (Set_card (Set_intersection a b)))
      (Set_card (Set_union a b)))
    (=
      (Set_card (Set_difference a b))
      (- (Set_card a) (Set_card (Set_intersection a b)))))
  :pattern ((Set_card (Set_difference a b)))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=
    (Set_subset a b)
    (forall ((o $Snap)) (!
      (=> (Set_in o a) (Set_in o b))
      :pattern ((Set_in o a))
      :pattern ((Set_in o b))
      )))
  :pattern ((Set_subset a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (or
    (and (Set_equal a b) (= a b))
    (and
      (not (Set_equal a b))
      (and
        (not (= a b))
        (and
          (= (Set_skolem_diff a b) (Set_skolem_diff b a))
          (not
            (= (Set_in (Set_skolem_diff a b) a) (Set_in (Set_skolem_diff a b) b)))))))
  :pattern ((Set_equal a b))
  )))
(assert (forall ((a Set<$Snap>) (b Set<$Snap>)) (!
  (=> (Set_equal a b) (= a b))
  :pattern ((Set_equal a b))
  )))
; /field_value_functions_axioms.smt2 [f: Int]
(assert (forall ((vs $FVF<f>) (ws $FVF<f>)) (!
    (=>
      (and
        (Set_equal ($FVF.domain_f vs) ($FVF.domain_f ws))
        (forall ((x $Ref)) (!
          (=>
            (Set_in x ($FVF.domain_f vs))
            (= ($FVF.lookup_f vs x) ($FVF.lookup_f ws x)))
          :pattern (($FVF.lookup_f vs x) ($FVF.lookup_f ws x))
          :qid |qp.$FVF<f>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<f>To$Snap vs)
              ($SortWrappers.$FVF<f>To$Snap ws)
              )
    :qid |qp.$FVF<f>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_f pm r))
    :pattern (($FVF.perm_f pm r)))))
(assert (forall ((r $Ref) (f Int)) (!
    (= ($FVF.loc_f f r) true)
    :pattern (($FVF.loc_f f r)))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun inv@21@00 ($Snap $Ref Int $Ref) Int)
(declare-fun img@22@00 ($Snap $Ref Int $Ref) Bool)
(declare-fun inv@24@00 ($Snap Seq<$Ref> Int $Ref) Int)
(declare-fun img@25@00 ($Snap Seq<$Ref> Int $Ref) Bool)
(declare-fun inv@27@00 ($Snap Seq<$Ref> Int $Ref) Int)
(declare-fun img@28@00 ($Snap Seq<$Ref> Int $Ref) Bool)
(declare-fun inv@30@00 ($Snap $Ref Int $Ref) Int)
(declare-fun img@31@00 ($Snap $Ref Int $Ref) Bool)
(assert (forall ((s@$ $Snap) (x@0@00 $Ref) (i@1@00 Int)) (!
  (= (fun04qp%limited s@$ x@0@00 i@1@00) (fun04qp s@$ x@0@00 i@1@00))
  :pattern ((fun04qp s@$ x@0@00 i@1@00))
  :qid |quant-u-12740|)))
(assert (forall ((s@$ $Snap) (x@0@00 $Ref) (i@1@00 Int)) (!
  (fun04qp%stateless x@0@00 i@1@00)
  :pattern ((fun04qp%limited s@$ x@0@00 i@1@00))
  :qid |quant-u-12741|)))
(assert (forall ((s@$ $Snap) (xs@3@00 Seq<$Ref>) (i@4@00 Int)) (!
  (= (fun01qp%limited s@$ xs@3@00 i@4@00) (fun01qp s@$ xs@3@00 i@4@00))
  :pattern ((fun01qp s@$ xs@3@00 i@4@00))
  :qid |quant-u-12742|)))
(assert (forall ((s@$ $Snap) (xs@3@00 Seq<$Ref>) (i@4@00 Int)) (!
  (fun01qp%stateless xs@3@00 i@4@00)
  :pattern ((fun01qp%limited s@$ xs@3@00 i@4@00))
  :qid |quant-u-12743|)))
(assert (forall ((s@$ $Snap) (x@6@00 $Ref) (y@7@00 $Ref) (b@8@00 Bool)) (!
  (= (fun01%limited s@$ x@6@00 y@7@00 b@8@00) (fun01 s@$ x@6@00 y@7@00 b@8@00))
  :pattern ((fun01 s@$ x@6@00 y@7@00 b@8@00))
  :qid |quant-u-12744|)))
(assert (forall ((s@$ $Snap) (x@6@00 $Ref) (y@7@00 $Ref) (b@8@00 Bool)) (!
  (fun01%stateless x@6@00 y@7@00 b@8@00)
  :pattern ((fun01%limited s@$ x@6@00 y@7@00 b@8@00))
  :qid |quant-u-12745|)))
(assert (forall ((s@$ $Snap) (xs@10@00 Seq<$Ref>) (i@11@00 Int)) (!
  (= (fun02qp%limited s@$ xs@10@00 i@11@00) (fun02qp s@$ xs@10@00 i@11@00))
  :pattern ((fun02qp s@$ xs@10@00 i@11@00))
  :qid |quant-u-12746|)))
(assert (forall ((s@$ $Snap) (xs@10@00 Seq<$Ref>) (i@11@00 Int)) (!
  (fun02qp%stateless xs@10@00 i@11@00)
  :pattern ((fun02qp%limited s@$ xs@10@00 i@11@00))
  :qid |quant-u-12747|)))
(assert (forall ((s@$ $Snap) (x@13@00 $Ref) (i@14@00 Int)) (!
  (= (fun03qp%limited s@$ x@13@00 i@14@00) (fun03qp s@$ x@13@00 i@14@00))
  :pattern ((fun03qp s@$ x@13@00 i@14@00))
  :qid |quant-u-12748|)))
(assert (forall ((s@$ $Snap) (x@13@00 $Ref) (i@14@00 Int)) (!
  (fun03qp%stateless x@13@00 i@14@00)
  :pattern ((fun03qp%limited s@$ x@13@00 i@14@00))
  :qid |quant-u-12749|)))
(assert (forall ((s@$ $Snap) (x@16@00 $Ref) (y@17@00 $Ref) (b@18@00 Bool)) (!
  (=
    (fun02%limited s@$ x@16@00 y@17@00 b@18@00)
    (fun02 s@$ x@16@00 y@17@00 b@18@00))
  :pattern ((fun02 s@$ x@16@00 y@17@00 b@18@00))
  :qid |quant-u-12750|)))
(assert (forall ((s@$ $Snap) (x@16@00 $Ref) (y@17@00 $Ref) (b@18@00 Bool)) (!
  (fun02%stateless x@16@00 y@17@00 b@18@00)
  :pattern ((fun02%limited s@$ x@16@00 y@17@00 b@18@00))
  :qid |quant-u-12751|)))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- test01 ----------
(declare-const x@0@01 $Ref)
(declare-const y@1@01 $Ref)
(declare-const b@2@01 Bool)
(declare-const x@3@01 $Ref)
(declare-const y@4@01 $Ref)
(declare-const b@5@01 Bool)
(set-option :timeout 0)
(push) ; 1
(declare-const $t@6@01 $Snap)
(assert (= $t@6@01 ($Snap.combine ($Snap.first $t@6@01) ($Snap.second $t@6@01))))
(assert (not (= x@3@01 $Ref.null)))
(push) ; 2
(set-option :timeout 10)
(assert (not (= x@3@01 y@4@01)))
(check-sat)
; unknown
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(assert (not (= y@4@01 $Ref.null)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; y.f := 0
(push) ; 3
(set-option :timeout 10)
(assert (not (= x@3@01 y@4@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [exec]
; assert fun01(x, y, true) == old(fun01(x, y, true))
; [eval] fun01(x, y, true) == old(fun01(x, y, true))
; [eval] fun01(x, y, true)
(set-option :timeout 0)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 0 | True | live]
; [else-branch: 0 | False | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 0 | True]
(assert (fun01%precondition ($Snap.first $t@6@01) x@3@01 y@4@01 true))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (fun01%precondition ($Snap.first $t@6@01) x@3@01 y@4@01 true))
; [eval] old(fun01(x, y, true))
; [eval] fun01(x, y, true)
(push) ; 3
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; [then-branch: 1 | True | live]
; [else-branch: 1 | False | dead]
(set-option :timeout 0)
(push) ; 4
; [then-branch: 1 | True]
(pop) ; 4
(pop) ; 3
; Joined path conditions
; [exec]
; assert fun02(x, y, true) == old(fun02(x, y, true))
; [eval] fun02(x, y, true) == old(fun02(x, y, true))
; [eval] fun02(x, y, true)
(push) ; 3
; [eval] (b ? write : none)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 2 | True | live]
; [else-branch: 2 | False | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 2 | True]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; [eval] (!b ? write : none)
; [eval] !b
(push) ; 4
; [then-branch: 3 | False | dead]
; [else-branch: 3 | True | live]
(push) ; 5
; [else-branch: 3 | True]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (fun02%precondition ($Snap.combine ($Snap.first $t@6@01) $Snap.unit) x@3@01 y@4@01 true))
(pop) ; 3
; Joined path conditions
(assert (fun02%precondition ($Snap.combine ($Snap.first $t@6@01) $Snap.unit) x@3@01 y@4@01 true))
; [eval] old(fun02(x, y, true))
; [eval] fun02(x, y, true)
(set-option :timeout 0)
(push) ; 3
; [eval] (b ? write : none)
(push) ; 4
(push) ; 5
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [then-branch: 4 | True | live]
; [else-branch: 4 | False | dead]
(set-option :timeout 0)
(push) ; 5
; [then-branch: 4 | True]
(pop) ; 5
(pop) ; 4
; Joined path conditions
; [eval] (!b ? write : none)
; [eval] !b
(push) ; 4
; [then-branch: 5 | False | dead]
; [else-branch: 5 | True | live]
(push) ; 5
; [else-branch: 5 | True]
(pop) ; 5
(pop) ; 4
; Joined path conditions
(push) ; 4
(set-option :timeout 10)
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(pop) ; 3
; Joined path conditions
(pop) ; 2
(pop) ; 1
; ---------- test02 ----------
(declare-const xs@7@01 Seq<$Ref>)
(declare-const i1@8@01 Int)
(declare-const i2@9@01 Int)
(declare-const x@10@01 $Ref)
(declare-const xs@11@01 Seq<$Ref>)
(declare-const i1@12@01 Int)
(declare-const i2@13@01 Int)
(declare-const x@14@01 $Ref)
(set-option :timeout 0)
(push) ; 1
(declare-const $t@15@01 $Snap)
(assert (= $t@15@01 ($Snap.combine ($Snap.first $t@15@01) ($Snap.second $t@15@01))))
(assert (= ($Snap.first $t@15@01) $Snap.unit))
; [eval] 0 <= i1
(assert (<= 0 i1@12@01))
(assert (=
  ($Snap.second $t@15@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@15@01))
    ($Snap.second ($Snap.second $t@15@01)))))
(assert (= ($Snap.first ($Snap.second $t@15@01)) $Snap.unit))
; [eval] i1 < |xs|
; [eval] |xs|
(assert (< i1@12@01 (Seq_length xs@11@01)))
(assert (=
  ($Snap.second ($Snap.second $t@15@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@15@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@15@01))) $Snap.unit))
; [eval] 0 <= i2
(assert (<= 0 i2@13@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@15@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@15@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@15@01))))
  $Snap.unit))
; [eval] i2 < |xs|
; [eval] |xs|
(assert (< i2@13@01 (Seq_length xs@11@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))
  $Snap.unit))
; [eval] i1 != i2
(assert (not (= i1@12@01 i2@13@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))
  $Snap.unit))
; [eval] (forall j1: Int, j2: Int :: { (j1 in [0..|xs|)), (j2 in [0..|xs|)) } { (j1 in [0..|xs|)), xs[j2] } { (j2 in [0..|xs|)), xs[j1] } { xs[j1], xs[j2] } (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2) ==> xs[j1] != xs[j2])
(declare-const j1@16@01 Int)
(declare-const j2@17@01 Int)
(push) ; 2
; [eval] (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2) ==> xs[j1] != xs[j2]
; [eval] (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2)
; [eval] (j1 in [0..|xs|))
; [eval] [0..|xs|)
; [eval] |xs|
(push) ; 3
; [then-branch: 6 | !(j1@16@01 in [0..|xs@11@01|]) | live]
; [else-branch: 6 | j1@16@01 in [0..|xs@11@01|] | live]
(push) ; 4
; [then-branch: 6 | !(j1@16@01 in [0..|xs@11@01|])]
(assert (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 6 | j1@16@01 in [0..|xs@11@01|]]
(assert (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01))
; [eval] (j2 in [0..|xs|))
; [eval] [0..|xs|)
; [eval] |xs|
(push) ; 5
; [then-branch: 7 | !(j2@17@01 in [0..|xs@11@01|]) | live]
; [else-branch: 7 | j2@17@01 in [0..|xs@11@01|] | live]
(push) ; 6
; [then-branch: 7 | !(j2@17@01 in [0..|xs@11@01|])]
(assert (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 7 | j2@17@01 in [0..|xs@11@01|]]
(assert (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01))
; [eval] j1 != j2
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
  (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01))))))
(assert (or
  (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
  (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01))))
(push) ; 3
; [then-branch: 8 | j1@16@01 in [0..|xs@11@01|] && j2@17@01 in [0..|xs@11@01|] && j1@16@01 != j2@17@01 | live]
; [else-branch: 8 | !(j1@16@01 in [0..|xs@11@01|] && j2@17@01 in [0..|xs@11@01|] && j1@16@01 != j2@17@01) | live]
(push) ; 4
; [then-branch: 8 | j1@16@01 in [0..|xs@11@01|] && j2@17@01 in [0..|xs@11@01|] && j1@16@01 != j2@17@01]
(assert (and
  (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
    (not (= j1@16@01 j2@17@01)))))
; [eval] xs[j1] != xs[j2]
; [eval] xs[j1]
(push) ; 5
(assert (not (>= j1@16@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(assert (not (< j1@16@01 (Seq_length xs@11@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [eval] xs[j2]
(push) ; 5
(assert (not (>= j2@17@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(assert (not (< j2@17@01 (Seq_length xs@11@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 8 | !(j1@16@01 in [0..|xs@11@01|] && j2@17@01 in [0..|xs@11@01|] && j1@16@01 != j2@17@01)]
(assert (not
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
      (not (= j1@16@01 j2@17@01))))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=>
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
      (not (= j1@16@01 j2@17@01))))
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
    (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
    (not (= j1@16@01 j2@17@01)))))
; Joined path conditions
(assert (or
  (not
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
        (not (= j1@16@01 j2@17@01)))))
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
      (not (= j1@16@01 j2@17@01))))))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((j1@16@01 Int) (j2@17@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
        (not (= j1@16@01 j2@17@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
            (not (= j1@16@01 j2@17@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01) (Seq_contains
    (Seq_range 0 (Seq_length xs@11@01))
    j2@17@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@11@01)) j1@16@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@11@01))
    j2@17@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@51@12@51@106-aux|)))
(assert (forall ((j1@16@01 Int) (j2@17@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
        (not (= j1@16@01 j2@17@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
            (not (= j1@16@01 j2@17@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@11@01)) j1@16@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@11@01))
    j2@17@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@51@12@51@106-aux|)))
(assert (forall ((j1@16@01 Int) (j2@17@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
        (not (= j1@16@01 j2@17@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
            (not (= j1@16@01 j2@17@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01) (Seq_index
    xs@11@01
    j2@17@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@11@01)) j1@16@01) (Seq_index
    xs@11@01
    j2@17@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@51@12@51@106-aux|)))
(assert (forall ((j1@16@01 Int) (j2@17@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
        (not (= j1@16@01 j2@17@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
            (not (= j1@16@01 j2@17@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@11@01)) j1@16@01) (Seq_index
    xs@11@01
    j2@17@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@51@12@51@106-aux|)))
(assert (forall ((j1@16@01 Int) (j2@17@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
        (not (= j1@16@01 j2@17@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
            (not (= j1@16@01 j2@17@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01) (Seq_index
    xs@11@01
    j1@16@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@11@01)) j2@17@01) (Seq_index
    xs@11@01
    j1@16@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@51@12@51@106-aux|)))
(assert (forall ((j1@16@01 Int) (j2@17@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
        (not (= j1@16@01 j2@17@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
            (not (= j1@16@01 j2@17@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@11@01)) j2@17@01) (Seq_index
    xs@11@01
    j1@16@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@51@12@51@106-aux|)))
(assert (forall ((j1@16@01 Int) (j2@17@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
        (not (= j1@16@01 j2@17@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
            (not (= j1@16@01 j2@17@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
          (not (= j1@16@01 j2@17@01))))))
  :pattern ((Seq_index xs@11@01 j1@16@01) (Seq_index xs@11@01 j2@17@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@51@12@51@106-aux|)))
(assert (forall ((j1@16@01 Int) (j2@17@01 Int)) (!
  (=>
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01)
        (not (= j1@16@01 j2@17@01))))
    (not (= (Seq_index xs@11@01 j1@16@01) (Seq_index xs@11@01 j2@17@01))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01) (Seq_contains
    (Seq_range 0 (Seq_length xs@11@01))
    j2@17@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@11@01)) j1@16@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@11@01))
    j2@17@01))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j1@16@01) (Seq_index
    xs@11@01
    j2@17@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@11@01)) j1@16@01) (Seq_index
    xs@11@01
    j2@17@01))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@11@01)) j2@17@01) (Seq_index
    xs@11@01
    j1@16@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@11@01)) j2@17@01) (Seq_index
    xs@11@01
    j1@16@01))
  :pattern ((Seq_index xs@11@01 j1@16@01) (Seq_index xs@11@01 j2@17@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@51@12@51@106|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))
(declare-const j@18@01 Int)
(push) ; 2
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 3
; [then-branch: 9 | !(0 <= j@18@01) | live]
; [else-branch: 9 | 0 <= j@18@01 | live]
(push) ; 4
; [then-branch: 9 | !(0 <= j@18@01)]
(assert (not (<= 0 j@18@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 9 | 0 <= j@18@01]
(assert (<= 0 j@18@01))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@18@01) (not (<= 0 j@18@01))))
(assert (and (<= 0 j@18@01) (< j@18@01 (Seq_length xs@11@01))))
; [eval] xs[j]
(push) ; 3
(assert (not (>= j@18@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(pop) ; 2
(declare-fun inv@19@01 ($Ref) Int)
(declare-fun img@20@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@18@01 Int)) (!
  (=>
    (and (<= 0 j@18@01) (< j@18@01 (Seq_length xs@11@01)))
    (or (<= 0 j@18@01) (not (<= 0 j@18@01))))
  :pattern ((Seq_index xs@11@01 j@18@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((j1@18@01 Int) (j2@18@01 Int)) (!
  (=>
    (and
      (and (<= 0 j1@18@01) (< j1@18@01 (Seq_length xs@11@01)))
      (and (<= 0 j2@18@01) (< j2@18@01 (Seq_length xs@11@01)))
      (= (Seq_index xs@11@01 j1@18@01) (Seq_index xs@11@01 j2@18@01)))
    (= j1@18@01 j2@18@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@18@01 Int)) (!
  (=>
    (and (<= 0 j@18@01) (< j@18@01 (Seq_length xs@11@01)))
    (and
      (= (inv@19@01 (Seq_index xs@11@01 j@18@01)) j@18@01)
      (img@20@01 (Seq_index xs@11@01 j@18@01))))
  :pattern ((Seq_index xs@11@01 j@18@01))
  :qid |quant-u-12761|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@20@01 r)
      (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
    (= (Seq_index xs@11@01 (inv@19@01 r)) r))
  :pattern ((inv@19@01 r))
  :qid |f-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((j@18@01 Int)) (!
  (=>
    (and (<= 0 j@18@01) (< j@18@01 (Seq_length xs@11@01)))
    (not (= (Seq_index xs@11@01 j@18@01) $Ref.null)))
  :pattern ((Seq_index xs@11@01 j@18@01))
  :qid |f-permImpliesNonNull|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
(assert (not (= x@14@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
  $Snap.unit))
; [eval] x.elems == xs
(assert (Seq_equal
  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
  xs@11@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; xs[i1].f := 0
; [eval] xs[i1]
(push) ; 3
(assert (not (>= i1@12@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@21@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@11@01 i1@12@01))
    ($Perm.min
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        $Perm.Write
        $Perm.No)
      (pTaken@21@01 r))
    $Perm.No)
  
  :qid |quant-u-12763|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@21@01 r) $Perm.No)
  
  :qid |quant-u-12764|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (= (- $Perm.Write (pTaken@21@01 r)) $Perm.No))
  
  :qid |quant-u-12765|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@22@01 $FVF<f>)
; Definitional axioms for singleton-FVF's value
(assert (= ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)) 0))
; [exec]
; assert fun01qp(xs, i2) == old(fun01qp(xs, i2))
; [eval] fun01qp(xs, i2) == old(fun01qp(xs, i2))
; [eval] fun01qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@23@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |xs| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 10 | !(0 <= j@23@01) | live]
; [else-branch: 10 | 0 <= j@23@01 | live]
(push) ; 6
; [then-branch: 10 | !(0 <= j@23@01)]
(assert (not (<= 0 j@23@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 10 | 0 <= j@23@01]
(assert (<= 0 j@23@01))
; [eval] j < |xs|
; [eval] |xs|
(push) ; 7
; [then-branch: 11 | !(j@23@01 < |xs@11@01|) | live]
; [else-branch: 11 | j@23@01 < |xs@11@01| | live]
(push) ; 8
; [then-branch: 11 | !(j@23@01 < |xs@11@01|)]
(assert (not (< j@23@01 (Seq_length xs@11@01))))
(pop) ; 8
(push) ; 8
; [else-branch: 11 | j@23@01 < |xs@11@01|]
(assert (< j@23@01 (Seq_length xs@11@01)))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or (< j@23@01 (Seq_length xs@11@01)) (not (< j@23@01 (Seq_length xs@11@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@23@01)
  (and
    (<= 0 j@23@01)
    (or
      (< j@23@01 (Seq_length xs@11@01))
      (not (< j@23@01 (Seq_length xs@11@01)))))))
(assert (or (<= 0 j@23@01) (not (<= 0 j@23@01))))
(assert (and (<= 0 j@23@01) (and (< j@23@01 (Seq_length xs@11@01)) (= j@23@01 i2@13@01))))
; [eval] xs[j]
(push) ; 5
(assert (not (>= j@23@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@24@01 ($Ref) Int)
(declare-fun img@25@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@23@01 Int)) (!
  (=>
    (and
      (<= 0 j@23@01)
      (and (< j@23@01 (Seq_length xs@11@01)) (= j@23@01 i2@13@01)))
    (and
      (=>
        (<= 0 j@23@01)
        (and
          (<= 0 j@23@01)
          (or
            (< j@23@01 (Seq_length xs@11@01))
            (not (< j@23@01 (Seq_length xs@11@01))))))
      (or (<= 0 j@23@01) (not (<= 0 j@23@01)))))
  :pattern ((Seq_index xs@11@01 j@23@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@23@01 Int) (j2@23@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@23@01)
        (and (< j1@23@01 (Seq_length xs@11@01)) (= j1@23@01 i2@13@01)))
      (and
        (<= 0 j2@23@01)
        (and (< j2@23@01 (Seq_length xs@11@01)) (= j2@23@01 i2@13@01)))
      (= (Seq_index xs@11@01 j1@23@01) (Seq_index xs@11@01 j2@23@01)))
    (= j1@23@01 j2@23@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@23@01 Int)) (!
  (=>
    (and
      (<= 0 j@23@01)
      (and (< j@23@01 (Seq_length xs@11@01)) (= j@23@01 i2@13@01)))
    (and
      (= (inv@24@01 (Seq_index xs@11@01 j@23@01)) j@23@01)
      (img@25@01 (Seq_index xs@11@01 j@23@01))))
  :pattern ((Seq_index xs@11@01 j@23@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@25@01 r)
      (and
        (<= 0 (inv@24@01 r))
        (and (< (inv@24@01 r) (Seq_length xs@11@01)) (= (inv@24@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@24@01 r)) r))
  :pattern ((inv@24@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@24@01 r))
        (and (< (inv@24@01 r) (Seq_length xs@11@01)) (= (inv@24@01 r) i2@13@01)))
      (img@25@01 r)
      (= r (Seq_index xs@11@01 (inv@24@01 r))))
    (>
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- $Perm.Write (pTaken@21@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12767|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@26@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@26@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@24@01 r))
          (and
            (< (inv@24@01 r) (Seq_length xs@11@01))
            (= (inv@24@01 r) i2@13@01)))
        (img@25@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@24@01 r))
          (and
            (< (inv@24@01 r) (Seq_length xs@11@01))
            (= (inv@24@01 r) i2@13@01)))
        (img@25@01 r))
      (Set_in r ($FVF.domain_f (as sm@26@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@26@01  $FVF<f>))))
  :qid |qp.fvfDomDef2|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@24@01 r))
          (and
            (< (inv@24@01 r) (Seq_length xs@11@01))
            (= (inv@24@01 r) i2@13@01)))
        (img@25@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@26@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@26@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef0|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@24@01 r))
          (and
            (< (inv@24@01 r) (Seq_length xs@11@01))
            (= (inv@24@01 r) i2@13@01)))
        (img@25@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- $Perm.Write (pTaken@21@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@26@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@26@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef1|)))
(assert (fun01qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@26@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@23@01 Int)) (!
  (=>
    (and
      (<= 0 j@23@01)
      (and (< j@23@01 (Seq_length xs@11@01)) (= j@23@01 i2@13@01)))
    (and
      (= (inv@24@01 (Seq_index xs@11@01 j@23@01)) j@23@01)
      (img@25@01 (Seq_index xs@11@01 j@23@01))))
  :pattern ((Seq_index xs@11@01 j@23@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@25@01 r)
      (and
        (<= 0 (inv@24@01 r))
        (and (< (inv@24@01 r) (Seq_length xs@11@01)) (= (inv@24@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@24@01 r)) r))
  :pattern ((inv@24@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@26@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@24@01 r))
          (and
            (< (inv@24@01 r) (Seq_length xs@11@01))
            (= (inv@24@01 r) i2@13@01)))
        (img@25@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@24@01 r))
          (and
            (< (inv@24@01 r) (Seq_length xs@11@01))
            (= (inv@24@01 r) i2@13@01)))
        (img@25@01 r))
      (Set_in r ($FVF.domain_f (as sm@26@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@26@01  $FVF<f>))))
  :qid |qp.fvfDomDef2|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@24@01 r))
          (and
            (< (inv@24@01 r) (Seq_length xs@11@01))
            (= (inv@24@01 r) i2@13@01)))
        (img@25@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@26@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@26@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef0|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@24@01 r))
          (and
            (< (inv@24@01 r) (Seq_length xs@11@01))
            (= (inv@24@01 r) i2@13@01)))
        (img@25@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- $Perm.Write (pTaken@21@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@26@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@26@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef1|)))
(assert (and
  (forall ((j@23@01 Int)) (!
    (=>
      (and
        (<= 0 j@23@01)
        (and (< j@23@01 (Seq_length xs@11@01)) (= j@23@01 i2@13@01)))
      (and
        (=>
          (<= 0 j@23@01)
          (and
            (<= 0 j@23@01)
            (or
              (< j@23@01 (Seq_length xs@11@01))
              (not (< j@23@01 (Seq_length xs@11@01))))))
        (or (<= 0 j@23@01) (not (<= 0 j@23@01)))))
    :pattern ((Seq_index xs@11@01 j@23@01))
    :qid |f-aux|))
  (fun01qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@26@01  $FVF<f>)))) xs@11@01 i2@13@01)))
; [eval] old(fun01qp(xs, i2))
; [eval] fun01qp(xs, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@27@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |xs| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 12 | !(0 <= j@27@01) | live]
; [else-branch: 12 | 0 <= j@27@01 | live]
(push) ; 6
; [then-branch: 12 | !(0 <= j@27@01)]
(assert (not (<= 0 j@27@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 12 | 0 <= j@27@01]
(assert (<= 0 j@27@01))
; [eval] j < |xs|
; [eval] |xs|
(push) ; 7
; [then-branch: 13 | !(j@27@01 < |xs@11@01|) | live]
; [else-branch: 13 | j@27@01 < |xs@11@01| | live]
(push) ; 8
; [then-branch: 13 | !(j@27@01 < |xs@11@01|)]
(assert (not (< j@27@01 (Seq_length xs@11@01))))
(pop) ; 8
(push) ; 8
; [else-branch: 13 | j@27@01 < |xs@11@01|]
(assert (< j@27@01 (Seq_length xs@11@01)))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or (< j@27@01 (Seq_length xs@11@01)) (not (< j@27@01 (Seq_length xs@11@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@27@01)
  (and
    (<= 0 j@27@01)
    (or
      (< j@27@01 (Seq_length xs@11@01))
      (not (< j@27@01 (Seq_length xs@11@01)))))))
(assert (or (<= 0 j@27@01) (not (<= 0 j@27@01))))
(assert (and (<= 0 j@27@01) (and (< j@27@01 (Seq_length xs@11@01)) (= j@27@01 i2@13@01))))
; [eval] xs[j]
(push) ; 5
(assert (not (>= j@27@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@28@01 ($Ref) Int)
(declare-fun img@29@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@27@01 Int)) (!
  (=>
    (and
      (<= 0 j@27@01)
      (and (< j@27@01 (Seq_length xs@11@01)) (= j@27@01 i2@13@01)))
    (and
      (=>
        (<= 0 j@27@01)
        (and
          (<= 0 j@27@01)
          (or
            (< j@27@01 (Seq_length xs@11@01))
            (not (< j@27@01 (Seq_length xs@11@01))))))
      (or (<= 0 j@27@01) (not (<= 0 j@27@01)))))
  :pattern ((Seq_index xs@11@01 j@27@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@27@01 Int) (j2@27@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@27@01)
        (and (< j1@27@01 (Seq_length xs@11@01)) (= j1@27@01 i2@13@01)))
      (and
        (<= 0 j2@27@01)
        (and (< j2@27@01 (Seq_length xs@11@01)) (= j2@27@01 i2@13@01)))
      (= (Seq_index xs@11@01 j1@27@01) (Seq_index xs@11@01 j2@27@01)))
    (= j1@27@01 j2@27@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@27@01 Int)) (!
  (=>
    (and
      (<= 0 j@27@01)
      (and (< j@27@01 (Seq_length xs@11@01)) (= j@27@01 i2@13@01)))
    (and
      (= (inv@28@01 (Seq_index xs@11@01 j@27@01)) j@27@01)
      (img@29@01 (Seq_index xs@11@01 j@27@01))))
  :pattern ((Seq_index xs@11@01 j@27@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@29@01 r)
      (and
        (<= 0 (inv@28@01 r))
        (and (< (inv@28@01 r) (Seq_length xs@11@01)) (= (inv@28@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@28@01 r)) r))
  :pattern ((inv@28@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@28@01 r))
        (and (< (inv@28@01 r) (Seq_length xs@11@01)) (= (inv@28@01 r) i2@13@01)))
      (img@29@01 r)
      (= r (Seq_index xs@11@01 (inv@28@01 r))))
    (>
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12769|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@30@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@30@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@28@01 r))
          (and
            (< (inv@28@01 r) (Seq_length xs@11@01))
            (= (inv@28@01 r) i2@13@01)))
        (img@29@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@28@01 r))
          (and
            (< (inv@28@01 r) (Seq_length xs@11@01))
            (= (inv@28@01 r) i2@13@01)))
        (img@29@01 r))
      (Set_in r ($FVF.domain_f (as sm@30@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@30@01  $FVF<f>))))
  :qid |qp.fvfDomDef4|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@28@01 r))
          (and
            (< (inv@28@01 r) (Seq_length xs@11@01))
            (= (inv@28@01 r) i2@13@01)))
        (img@29@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@30@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@30@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef3|)))
(assert (fun01qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@30@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@27@01 Int)) (!
  (=>
    (and
      (<= 0 j@27@01)
      (and (< j@27@01 (Seq_length xs@11@01)) (= j@27@01 i2@13@01)))
    (and
      (= (inv@28@01 (Seq_index xs@11@01 j@27@01)) j@27@01)
      (img@29@01 (Seq_index xs@11@01 j@27@01))))
  :pattern ((Seq_index xs@11@01 j@27@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@29@01 r)
      (and
        (<= 0 (inv@28@01 r))
        (and (< (inv@28@01 r) (Seq_length xs@11@01)) (= (inv@28@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@28@01 r)) r))
  :pattern ((inv@28@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@30@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@28@01 r))
          (and
            (< (inv@28@01 r) (Seq_length xs@11@01))
            (= (inv@28@01 r) i2@13@01)))
        (img@29@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@28@01 r))
          (and
            (< (inv@28@01 r) (Seq_length xs@11@01))
            (= (inv@28@01 r) i2@13@01)))
        (img@29@01 r))
      (Set_in r ($FVF.domain_f (as sm@30@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@30@01  $FVF<f>))))
  :qid |qp.fvfDomDef4|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@28@01 r))
          (and
            (< (inv@28@01 r) (Seq_length xs@11@01))
            (= (inv@28@01 r) i2@13@01)))
        (img@29@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@30@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@30@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef3|)))
(assert (and
  (forall ((j@27@01 Int)) (!
    (=>
      (and
        (<= 0 j@27@01)
        (and (< j@27@01 (Seq_length xs@11@01)) (= j@27@01 i2@13@01)))
      (and
        (=>
          (<= 0 j@27@01)
          (and
            (<= 0 j@27@01)
            (or
              (< j@27@01 (Seq_length xs@11@01))
              (not (< j@27@01 (Seq_length xs@11@01))))))
        (or (<= 0 j@27@01) (not (<= 0 j@27@01)))))
    :pattern ((Seq_index xs@11@01 j@27@01))
    :qid |f-aux|))
  (fun01qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@30@01  $FVF<f>)))) xs@11@01 i2@13@01)))
(push) ; 3
(assert (not (=
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@26@01  $FVF<f>)))) xs@11@01 i2@13@01)
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@30@01  $FVF<f>)))) xs@11@01 i2@13@01))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (=
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@26@01  $FVF<f>)))) xs@11@01 i2@13@01)
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@30@01  $FVF<f>)))) xs@11@01 i2@13@01)))
; [exec]
; assert fun02qp(xs, i2) == old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2) == old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@31@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 14 | !(0 <= j@31@01) | live]
; [else-branch: 14 | 0 <= j@31@01 | live]
(push) ; 6
; [then-branch: 14 | !(0 <= j@31@01)]
(assert (not (<= 0 j@31@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 14 | 0 <= j@31@01]
(assert (<= 0 j@31@01))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@31@01) (not (<= 0 j@31@01))))
(assert (and (<= 0 j@31@01) (< j@31@01 (Seq_length xs@11@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 15 | j@31@01 == i2@13@01 | live]
; [else-branch: 15 | j@31@01 != i2@13@01 | live]
(push) ; 6
; [then-branch: 15 | j@31@01 == i2@13@01]
(assert (= j@31@01 i2@13@01))
(pop) ; 6
(push) ; 6
; [else-branch: 15 | j@31@01 != i2@13@01]
(assert (not (= j@31@01 i2@13@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@31@01 i2@13@01)) (= j@31@01 i2@13@01)))
; [eval] xs[j]
(push) ; 5
(assert (not (>= j@31@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@32@01 ($Ref) Int)
(declare-fun img@33@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@31@01 Int)) (!
  (=>
    (and (<= 0 j@31@01) (< j@31@01 (Seq_length xs@11@01)))
    (and
      (or (<= 0 j@31@01) (not (<= 0 j@31@01)))
      (or (not (= j@31@01 i2@13@01)) (= j@31@01 i2@13@01))))
  :pattern ((Seq_index xs@11@01 j@31@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@31@01 Int)) (!
  (=>
    (and (<= 0 j@31@01) (< j@31@01 (Seq_length xs@11@01)))
    (or
      (= (ite (= j@31@01 i2@13@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@31@01 i2@13@01)))
  
  :qid |quant-u-12770|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@31@01 Int) (j2@31@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@31@01) (< j1@31@01 (Seq_length xs@11@01)))
        (= j1@31@01 i2@13@01))
      (and
        (and (<= 0 j2@31@01) (< j2@31@01 (Seq_length xs@11@01)))
        (= j2@31@01 i2@13@01))
      (= (Seq_index xs@11@01 j1@31@01) (Seq_index xs@11@01 j2@31@01)))
    (= j1@31@01 j2@31@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@31@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@31@01) (< j@31@01 (Seq_length xs@11@01)))
      (= j@31@01 i2@13@01))
    (and
      (= (inv@32@01 (Seq_index xs@11@01 j@31@01)) j@31@01)
      (img@33@01 (Seq_index xs@11@01 j@31@01))))
  :pattern ((Seq_index xs@11@01 j@31@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@33@01 r)
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (= (inv@32@01 r) i2@13@01)))
    (= (Seq_index xs@11@01 (inv@32@01 r)) r))
  :pattern ((inv@32@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (img@33@01 r)
        (= r (Seq_index xs@11@01 (inv@32@01 r))))
      (> (ite (= (inv@32@01 r) i2@13@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- $Perm.Write (pTaken@21@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12771|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@34@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@34@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (= (inv@32@01 r) i2@13@01)
        (img@33@01 r)))
    (=>
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (= (inv@32@01 r) i2@13@01)
        (img@33@01 r))
      (Set_in r ($FVF.domain_f (as sm@34@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@34@01  $FVF<f>))))
  :qid |qp.fvfDomDef7|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (= (inv@32@01 r) i2@13@01)
        (img@33@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@34@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@34@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef5|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (= (inv@32@01 r) i2@13@01)
        (img@33@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- $Perm.Write (pTaken@21@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@34@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@34@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef6|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@34@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@31@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@31@01) (< j@31@01 (Seq_length xs@11@01)))
      (= j@31@01 i2@13@01))
    (and
      (= (inv@32@01 (Seq_index xs@11@01 j@31@01)) j@31@01)
      (img@33@01 (Seq_index xs@11@01 j@31@01))))
  :pattern ((Seq_index xs@11@01 j@31@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@33@01 r)
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (= (inv@32@01 r) i2@13@01)))
    (= (Seq_index xs@11@01 (inv@32@01 r)) r))
  :pattern ((inv@32@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@34@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (= (inv@32@01 r) i2@13@01)
        (img@33@01 r)))
    (=>
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (= (inv@32@01 r) i2@13@01)
        (img@33@01 r))
      (Set_in r ($FVF.domain_f (as sm@34@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@34@01  $FVF<f>))))
  :qid |qp.fvfDomDef7|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (= (inv@32@01 r) i2@13@01)
        (img@33@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@34@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@34@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef5|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@32@01 r)) (< (inv@32@01 r) (Seq_length xs@11@01)))
        (= (inv@32@01 r) i2@13@01)
        (img@33@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- $Perm.Write (pTaken@21@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@34@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@34@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef6|)))
(assert (and
  (forall ((j@31@01 Int)) (!
    (=>
      (and (<= 0 j@31@01) (< j@31@01 (Seq_length xs@11@01)))
      (and
        (or (<= 0 j@31@01) (not (<= 0 j@31@01)))
        (or (not (= j@31@01 i2@13@01)) (= j@31@01 i2@13@01))))
    :pattern ((Seq_index xs@11@01 j@31@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@34@01  $FVF<f>)))) xs@11@01 i2@13@01)))
; [eval] old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@35@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 16 | !(0 <= j@35@01) | live]
; [else-branch: 16 | 0 <= j@35@01 | live]
(push) ; 6
; [then-branch: 16 | !(0 <= j@35@01)]
(assert (not (<= 0 j@35@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 16 | 0 <= j@35@01]
(assert (<= 0 j@35@01))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@35@01) (not (<= 0 j@35@01))))
(assert (and (<= 0 j@35@01) (< j@35@01 (Seq_length xs@11@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 17 | j@35@01 == i2@13@01 | live]
; [else-branch: 17 | j@35@01 != i2@13@01 | live]
(push) ; 6
; [then-branch: 17 | j@35@01 == i2@13@01]
(assert (= j@35@01 i2@13@01))
(pop) ; 6
(push) ; 6
; [else-branch: 17 | j@35@01 != i2@13@01]
(assert (not (= j@35@01 i2@13@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@35@01 i2@13@01)) (= j@35@01 i2@13@01)))
; [eval] xs[j]
(push) ; 5
(assert (not (>= j@35@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@36@01 ($Ref) Int)
(declare-fun img@37@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@35@01 Int)) (!
  (=>
    (and (<= 0 j@35@01) (< j@35@01 (Seq_length xs@11@01)))
    (and
      (or (<= 0 j@35@01) (not (<= 0 j@35@01)))
      (or (not (= j@35@01 i2@13@01)) (= j@35@01 i2@13@01))))
  :pattern ((Seq_index xs@11@01 j@35@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@35@01 Int)) (!
  (=>
    (and (<= 0 j@35@01) (< j@35@01 (Seq_length xs@11@01)))
    (or
      (= (ite (= j@35@01 i2@13@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@35@01 i2@13@01)))
  
  :qid |quant-u-12772|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@35@01 Int) (j2@35@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@35@01) (< j1@35@01 (Seq_length xs@11@01)))
        (= j1@35@01 i2@13@01))
      (and
        (and (<= 0 j2@35@01) (< j2@35@01 (Seq_length xs@11@01)))
        (= j2@35@01 i2@13@01))
      (= (Seq_index xs@11@01 j1@35@01) (Seq_index xs@11@01 j2@35@01)))
    (= j1@35@01 j2@35@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@35@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@35@01) (< j@35@01 (Seq_length xs@11@01)))
      (= j@35@01 i2@13@01))
    (and
      (= (inv@36@01 (Seq_index xs@11@01 j@35@01)) j@35@01)
      (img@37@01 (Seq_index xs@11@01 j@35@01))))
  :pattern ((Seq_index xs@11@01 j@35@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@37@01 r)
      (and
        (and (<= 0 (inv@36@01 r)) (< (inv@36@01 r) (Seq_length xs@11@01)))
        (= (inv@36@01 r) i2@13@01)))
    (= (Seq_index xs@11@01 (inv@36@01 r)) r))
  :pattern ((inv@36@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@36@01 r)) (< (inv@36@01 r) (Seq_length xs@11@01)))
        (img@37@01 r)
        (= r (Seq_index xs@11@01 (inv@36@01 r))))
      (> (ite (= (inv@36@01 r) i2@13@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12773|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@38@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@38@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@36@01 r)) (< (inv@36@01 r) (Seq_length xs@11@01)))
        (= (inv@36@01 r) i2@13@01)
        (img@37@01 r)))
    (=>
      (and
        (and (<= 0 (inv@36@01 r)) (< (inv@36@01 r) (Seq_length xs@11@01)))
        (= (inv@36@01 r) i2@13@01)
        (img@37@01 r))
      (Set_in r ($FVF.domain_f (as sm@38@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@38@01  $FVF<f>))))
  :qid |qp.fvfDomDef9|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@36@01 r)) (< (inv@36@01 r) (Seq_length xs@11@01)))
        (= (inv@36@01 r) i2@13@01)
        (img@37@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@38@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@38@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef8|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@38@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@35@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@35@01) (< j@35@01 (Seq_length xs@11@01)))
      (= j@35@01 i2@13@01))
    (and
      (= (inv@36@01 (Seq_index xs@11@01 j@35@01)) j@35@01)
      (img@37@01 (Seq_index xs@11@01 j@35@01))))
  :pattern ((Seq_index xs@11@01 j@35@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@37@01 r)
      (and
        (and (<= 0 (inv@36@01 r)) (< (inv@36@01 r) (Seq_length xs@11@01)))
        (= (inv@36@01 r) i2@13@01)))
    (= (Seq_index xs@11@01 (inv@36@01 r)) r))
  :pattern ((inv@36@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@38@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@36@01 r)) (< (inv@36@01 r) (Seq_length xs@11@01)))
        (= (inv@36@01 r) i2@13@01)
        (img@37@01 r)))
    (=>
      (and
        (and (<= 0 (inv@36@01 r)) (< (inv@36@01 r) (Seq_length xs@11@01)))
        (= (inv@36@01 r) i2@13@01)
        (img@37@01 r))
      (Set_in r ($FVF.domain_f (as sm@38@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@38@01  $FVF<f>))))
  :qid |qp.fvfDomDef9|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@36@01 r)) (< (inv@36@01 r) (Seq_length xs@11@01)))
        (= (inv@36@01 r) i2@13@01)
        (img@37@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@38@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@38@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef8|)))
(assert (and
  (forall ((j@35@01 Int)) (!
    (=>
      (and (<= 0 j@35@01) (< j@35@01 (Seq_length xs@11@01)))
      (and
        (or (<= 0 j@35@01) (not (<= 0 j@35@01)))
        (or (not (= j@35@01 i2@13@01)) (= j@35@01 i2@13@01))))
    :pattern ((Seq_index xs@11@01 j@35@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@38@01  $FVF<f>)))) xs@11@01 i2@13@01)))
(push) ; 3
(assert (not (=
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@34@01  $FVF<f>)))) xs@11@01 i2@13@01)
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@38@01  $FVF<f>)))) xs@11@01 i2@13@01))))
(check-sat)
; unsat
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(assert (=
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@34@01  $FVF<f>)))) xs@11@01 i2@13@01)
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@38@01  $FVF<f>)))) xs@11@01 i2@13@01)))
; [exec]
; assert fun03qp(x, i2) == old(fun03qp(x, i2))
; [eval] fun03qp(x, i2) == old(fun03qp(x, i2))
; [eval] fun03qp(x, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(push) ; 4
(assert (not (<
  i2@13@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (<
  i2@13@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
(declare-const j@39@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 18 | !(0 <= j@39@01) | live]
; [else-branch: 18 | 0 <= j@39@01 | live]
(push) ; 6
; [then-branch: 18 | !(0 <= j@39@01)]
(assert (not (<= 0 j@39@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 18 | 0 <= j@39@01]
(assert (<= 0 j@39@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(push) ; 7
; [then-branch: 19 | !(j@39@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@15@01))))))))|) | live]
; [else-branch: 19 | j@39@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@15@01))))))))| | live]
(push) ; 8
; [then-branch: 19 | !(j@39@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@15@01))))))))|)]
(assert (not
  (<
    j@39@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))))
(pop) ; 8
(push) ; 8
; [else-branch: 19 | j@39@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@15@01))))))))|]
(assert (<
  j@39@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (<
    j@39@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
  (not
    (<
      j@39@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@39@01)
  (and
    (<= 0 j@39@01)
    (or
      (<
        j@39@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
      (not
        (<
          j@39@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))))))
(assert (or (<= 0 j@39@01) (not (<= 0 j@39@01))))
(assert (and
  (<= 0 j@39@01)
  (and
    (<
      j@39@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
    (= j@39@01 i2@13@01))))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@39@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@40@01 ($Ref) Int)
(declare-fun img@41@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@39@01 Int)) (!
  (=>
    (and
      (<= 0 j@39@01)
      (and
        (<
          j@39@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
        (= j@39@01 i2@13@01)))
    (and
      (=>
        (<= 0 j@39@01)
        (and
          (<= 0 j@39@01)
          (or
            (<
              j@39@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (not
              (<
                j@39@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))))))
      (or (<= 0 j@39@01) (not (<= 0 j@39@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@39@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@39@01 Int) (j2@39@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@39@01)
        (and
          (<
            j1@39@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= j1@39@01 i2@13@01)))
      (and
        (<= 0 j2@39@01)
        (and
          (<
            j2@39@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= j2@39@01 i2@13@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j1@39@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j2@39@01)))
    (= j1@39@01 j2@39@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@39@01 Int)) (!
  (=>
    (and
      (<= 0 j@39@01)
      (and
        (<
          j@39@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
        (= j@39@01 i2@13@01)))
    (and
      (=
        (inv@40@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j@39@01))
        j@39@01)
      (img@41@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        j@39@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@39@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@41@01 r)
      (and
        (<= 0 (inv@40@01 r))
        (and
          (<
            (inv@40@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= (inv@40@01 r) i2@13@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        (inv@40@01 r))
      r))
  :pattern ((inv@40@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@39@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
      j@39@01)
    (Seq_index xs@11@01 j@39@01))
  
  :qid |quant-u-12775|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@40@01 r))
        (and
          (<
            (inv@40@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= (inv@40@01 r) i2@13@01)))
      (img@41@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          (inv@40@01 r))))
    (>
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- $Perm.Write (pTaken@21@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12776|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@42@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@42@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@40@01 r))
          (and
            (<
              (inv@40@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@40@01 r) i2@13@01)))
        (img@41@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@40@01 r))
          (and
            (<
              (inv@40@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@40@01 r) i2@13@01)))
        (img@41@01 r))
      (Set_in r ($FVF.domain_f (as sm@42@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@42@01  $FVF<f>))))
  :qid |qp.fvfDomDef12|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@40@01 r))
          (and
            (<
              (inv@40@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@40@01 r) i2@13@01)))
        (img@41@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@42@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@42@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef10|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@40@01 r))
          (and
            (<
              (inv@40@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@40@01 r) i2@13@01)))
        (img@41@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- $Perm.Write (pTaken@21@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@42@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@42@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef11|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@42@01  $FVF<f>))))) x@14@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@39@01 Int)) (!
  (=>
    (and
      (<= 0 j@39@01)
      (and
        (<
          j@39@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
        (= j@39@01 i2@13@01)))
    (and
      (=
        (inv@40@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j@39@01))
        j@39@01)
      (img@41@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        j@39@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@39@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@41@01 r)
      (and
        (<= 0 (inv@40@01 r))
        (and
          (<
            (inv@40@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= (inv@40@01 r) i2@13@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        (inv@40@01 r))
      r))
  :pattern ((inv@40@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@42@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@40@01 r))
          (and
            (<
              (inv@40@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@40@01 r) i2@13@01)))
        (img@41@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@40@01 r))
          (and
            (<
              (inv@40@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@40@01 r) i2@13@01)))
        (img@41@01 r))
      (Set_in r ($FVF.domain_f (as sm@42@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@42@01  $FVF<f>))))
  :qid |qp.fvfDomDef12|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@40@01 r))
          (and
            (<
              (inv@40@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@40@01 r) i2@13@01)))
        (img@41@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@42@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@42@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef10|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@40@01 r))
          (and
            (<
              (inv@40@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@40@01 r) i2@13@01)))
        (img@41@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- $Perm.Write (pTaken@21@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@42@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@42@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef11|)))
(assert (and
  (<
    i2@13@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
  (forall ((j@39@01 Int)) (!
    (=>
      (and
        (<= 0 j@39@01)
        (and
          (<
            j@39@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= j@39@01 i2@13@01)))
      (and
        (=>
          (<= 0 j@39@01)
          (and
            (<= 0 j@39@01)
            (or
              (<
                j@39@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
              (not
                (<
                  j@39@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))))))
        (or (<= 0 j@39@01) (not (<= 0 j@39@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
      j@39@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@42@01  $FVF<f>))))) x@14@01 i2@13@01)))
; [eval] old(fun03qp(x, i2))
; [eval] fun03qp(x, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@43@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 20 | !(0 <= j@43@01) | live]
; [else-branch: 20 | 0 <= j@43@01 | live]
(push) ; 6
; [then-branch: 20 | !(0 <= j@43@01)]
(assert (not (<= 0 j@43@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 20 | 0 <= j@43@01]
(assert (<= 0 j@43@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(push) ; 7
; [then-branch: 21 | !(j@43@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@15@01))))))))|) | live]
; [else-branch: 21 | j@43@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@15@01))))))))| | live]
(push) ; 8
; [then-branch: 21 | !(j@43@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@15@01))))))))|)]
(assert (not
  (<
    j@43@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))))
(pop) ; 8
(push) ; 8
; [else-branch: 21 | j@43@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@15@01))))))))|]
(assert (<
  j@43@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (<
    j@43@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
  (not
    (<
      j@43@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@43@01)
  (and
    (<= 0 j@43@01)
    (or
      (<
        j@43@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
      (not
        (<
          j@43@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))))))
(assert (or (<= 0 j@43@01) (not (<= 0 j@43@01))))
(assert (and
  (<= 0 j@43@01)
  (and
    (<
      j@43@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
    (= j@43@01 i2@13@01))))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@43@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@44@01 ($Ref) Int)
(declare-fun img@45@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@43@01 Int)) (!
  (=>
    (and
      (<= 0 j@43@01)
      (and
        (<
          j@43@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
        (= j@43@01 i2@13@01)))
    (and
      (=>
        (<= 0 j@43@01)
        (and
          (<= 0 j@43@01)
          (or
            (<
              j@43@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (not
              (<
                j@43@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))))))
      (or (<= 0 j@43@01) (not (<= 0 j@43@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@43@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@43@01 Int) (j2@43@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@43@01)
        (and
          (<
            j1@43@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= j1@43@01 i2@13@01)))
      (and
        (<= 0 j2@43@01)
        (and
          (<
            j2@43@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= j2@43@01 i2@13@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j1@43@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j2@43@01)))
    (= j1@43@01 j2@43@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@43@01 Int)) (!
  (=>
    (and
      (<= 0 j@43@01)
      (and
        (<
          j@43@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
        (= j@43@01 i2@13@01)))
    (and
      (=
        (inv@44@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j@43@01))
        j@43@01)
      (img@45@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        j@43@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@43@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@45@01 r)
      (and
        (<= 0 (inv@44@01 r))
        (and
          (<
            (inv@44@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= (inv@44@01 r) i2@13@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        (inv@44@01 r))
      r))
  :pattern ((inv@44@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@43@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
      j@43@01)
    (Seq_index xs@11@01 j@43@01))
  
  :qid |quant-u-12778|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@44@01 r))
        (and
          (<
            (inv@44@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= (inv@44@01 r) i2@13@01)))
      (img@45@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          (inv@44@01 r))))
    (>
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12779|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@46@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@46@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@44@01 r))
          (and
            (<
              (inv@44@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@44@01 r) i2@13@01)))
        (img@45@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@44@01 r))
          (and
            (<
              (inv@44@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@44@01 r) i2@13@01)))
        (img@45@01 r))
      (Set_in r ($FVF.domain_f (as sm@46@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@46@01  $FVF<f>))))
  :qid |qp.fvfDomDef14|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@44@01 r))
          (and
            (<
              (inv@44@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@44@01 r) i2@13@01)))
        (img@45@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@46@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@46@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef13|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@46@01  $FVF<f>))))) x@14@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@43@01 Int)) (!
  (=>
    (and
      (<= 0 j@43@01)
      (and
        (<
          j@43@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
        (= j@43@01 i2@13@01)))
    (and
      (=
        (inv@44@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j@43@01))
        j@43@01)
      (img@45@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        j@43@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@43@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@45@01 r)
      (and
        (<= 0 (inv@44@01 r))
        (and
          (<
            (inv@44@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= (inv@44@01 r) i2@13@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        (inv@44@01 r))
      r))
  :pattern ((inv@44@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@46@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@44@01 r))
          (and
            (<
              (inv@44@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@44@01 r) i2@13@01)))
        (img@45@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@44@01 r))
          (and
            (<
              (inv@44@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@44@01 r) i2@13@01)))
        (img@45@01 r))
      (Set_in r ($FVF.domain_f (as sm@46@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@46@01  $FVF<f>))))
  :qid |qp.fvfDomDef14|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@44@01 r))
          (and
            (<
              (inv@44@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
            (= (inv@44@01 r) i2@13@01)))
        (img@45@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@46@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@46@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef13|)))
(assert (and
  (forall ((j@43@01 Int)) (!
    (=>
      (and
        (<= 0 j@43@01)
        (and
          (<
            j@43@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
          (= j@43@01 i2@13@01)))
      (and
        (=>
          (<= 0 j@43@01)
          (and
            (<= 0 j@43@01)
            (or
              (<
                j@43@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))
              (not
                (<
                  j@43@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))))))
        (or (<= 0 j@43@01) (not (<= 0 j@43@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
      j@43@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@46@01  $FVF<f>))))) x@14@01 i2@13@01)))
(push) ; 3
(assert (not (=
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@42@01  $FVF<f>))))) x@14@01 i2@13@01)
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@46@01  $FVF<f>))))) x@14@01 i2@13@01))))
(check-sat)
; unsat
(pop) ; 3
; 0.02s
; (get-info :all-statistics)
(assert (=
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@42@01  $FVF<f>))))) x@14@01 i2@13@01)
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@46@01  $FVF<f>))))) x@14@01 i2@13@01)))
; [exec]
; assert fun04qp(x, i2) == old(fun04qp(x, i2))
; [eval] fun04qp(x, i2) == old(fun04qp(x, i2))
; [eval] fun04qp(x, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@47@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 22 | !(0 <= j@47@01) | live]
; [else-branch: 22 | 0 <= j@47@01 | live]
(push) ; 6
; [then-branch: 22 | !(0 <= j@47@01)]
(assert (not (<= 0 j@47@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 22 | 0 <= j@47@01]
(assert (<= 0 j@47@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@47@01) (not (<= 0 j@47@01))))
(assert (and
  (<= 0 j@47@01)
  (<
    j@47@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 23 | j@47@01 == i2@13@01 | live]
; [else-branch: 23 | j@47@01 != i2@13@01 | live]
(push) ; 6
; [then-branch: 23 | j@47@01 == i2@13@01]
(assert (= j@47@01 i2@13@01))
(pop) ; 6
(push) ; 6
; [else-branch: 23 | j@47@01 != i2@13@01]
(assert (not (= j@47@01 i2@13@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@47@01 i2@13@01)) (= j@47@01 i2@13@01)))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@47@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@48@01 ($Ref) Int)
(declare-fun img@49@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@47@01 Int)) (!
  (=>
    (and
      (<= 0 j@47@01)
      (<
        j@47@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
    (and
      (or (<= 0 j@47@01) (not (<= 0 j@47@01)))
      (or (not (= j@47@01 i2@13@01)) (= j@47@01 i2@13@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@47@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@47@01 Int)) (!
  (=>
    (and
      (<= 0 j@47@01)
      (<
        j@47@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
    (or
      (= (ite (= j@47@01 i2@13@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@47@01 i2@13@01)))
  
  :qid |quant-u-12780|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@47@01 Int) (j2@47@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@47@01)
          (<
            j1@47@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= j1@47@01 i2@13@01))
      (and
        (and
          (<= 0 j2@47@01)
          (<
            j2@47@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= j2@47@01 i2@13@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j1@47@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j2@47@01)))
    (= j1@47@01 j2@47@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@47@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@47@01)
        (<
          j@47@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
      (= j@47@01 i2@13@01))
    (and
      (=
        (inv@48@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j@47@01))
        j@47@01)
      (img@49@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        j@47@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@47@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@49@01 r)
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@48@01 r) i2@13@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        (inv@48@01 r))
      r))
  :pattern ((inv@48@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@47@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
      j@47@01)
    (Seq_index xs@11@01 j@47@01))
  
  :qid |quant-u-12781|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (img@49@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
            (inv@48@01 r))))
      (> (ite (= (inv@48@01 r) i2@13@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- $Perm.Write (pTaken@21@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12782|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@50@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@50@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@48@01 r) i2@13@01)
        (img@49@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@48@01 r) i2@13@01)
        (img@49@01 r))
      (Set_in r ($FVF.domain_f (as sm@50@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@50@01  $FVF<f>))))
  :qid |qp.fvfDomDef17|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@48@01 r) i2@13@01)
        (img@49@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@50@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@50@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@48@01 r) i2@13@01)
        (img@49@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- $Perm.Write (pTaken@21@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@50@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@50@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef16|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@50@01  $FVF<f>))))) x@14@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@47@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@47@01)
        (<
          j@47@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
      (= j@47@01 i2@13@01))
    (and
      (=
        (inv@48@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j@47@01))
        j@47@01)
      (img@49@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        j@47@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@47@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@49@01 r)
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@48@01 r) i2@13@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        (inv@48@01 r))
      r))
  :pattern ((inv@48@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@50@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@48@01 r) i2@13@01)
        (img@49@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@48@01 r) i2@13@01)
        (img@49@01 r))
      (Set_in r ($FVF.domain_f (as sm@50@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@50@01  $FVF<f>))))
  :qid |qp.fvfDomDef17|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@48@01 r) i2@13@01)
        (img@49@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@50@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@50@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@48@01 r))
          (<
            (inv@48@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@48@01 r) i2@13@01)
        (img@49@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- $Perm.Write (pTaken@21@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@50@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@50@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef16|)))
(assert (and
  (forall ((j@47@01 Int)) (!
    (=>
      (and
        (<= 0 j@47@01)
        (<
          j@47@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
      (and
        (or (<= 0 j@47@01) (not (<= 0 j@47@01)))
        (or (not (= j@47@01 i2@13@01)) (= j@47@01 i2@13@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
      j@47@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@50@01  $FVF<f>))))) x@14@01 i2@13@01)))
; [eval] old(fun04qp(x, i2))
; [eval] fun04qp(x, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@51@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 24 | !(0 <= j@51@01) | live]
; [else-branch: 24 | 0 <= j@51@01 | live]
(push) ; 6
; [then-branch: 24 | !(0 <= j@51@01)]
(assert (not (<= 0 j@51@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 24 | 0 <= j@51@01]
(assert (<= 0 j@51@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@51@01) (not (<= 0 j@51@01))))
(assert (and
  (<= 0 j@51@01)
  (<
    j@51@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 25 | j@51@01 == i2@13@01 | live]
; [else-branch: 25 | j@51@01 != i2@13@01 | live]
(push) ; 6
; [then-branch: 25 | j@51@01 == i2@13@01]
(assert (= j@51@01 i2@13@01))
(pop) ; 6
(push) ; 6
; [else-branch: 25 | j@51@01 != i2@13@01]
(assert (not (= j@51@01 i2@13@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@51@01 i2@13@01)) (= j@51@01 i2@13@01)))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@51@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@52@01 ($Ref) Int)
(declare-fun img@53@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@51@01 Int)) (!
  (=>
    (and
      (<= 0 j@51@01)
      (<
        j@51@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
    (and
      (or (<= 0 j@51@01) (not (<= 0 j@51@01)))
      (or (not (= j@51@01 i2@13@01)) (= j@51@01 i2@13@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@51@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@51@01 Int)) (!
  (=>
    (and
      (<= 0 j@51@01)
      (<
        j@51@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
    (or
      (= (ite (= j@51@01 i2@13@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@51@01 i2@13@01)))
  
  :qid |quant-u-12783|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@51@01 Int) (j2@51@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@51@01)
          (<
            j1@51@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= j1@51@01 i2@13@01))
      (and
        (and
          (<= 0 j2@51@01)
          (<
            j2@51@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= j2@51@01 i2@13@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j1@51@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j2@51@01)))
    (= j1@51@01 j2@51@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@51@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@51@01)
        (<
          j@51@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
      (= j@51@01 i2@13@01))
    (and
      (=
        (inv@52@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j@51@01))
        j@51@01)
      (img@53@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        j@51@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@51@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@53@01 r)
      (and
        (and
          (<= 0 (inv@52@01 r))
          (<
            (inv@52@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@52@01 r) i2@13@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        (inv@52@01 r))
      r))
  :pattern ((inv@52@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@51@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
      j@51@01)
    (Seq_index xs@11@01 j@51@01))
  
  :qid |quant-u-12784|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@52@01 r))
          (<
            (inv@52@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (img@53@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
            (inv@52@01 r))))
      (> (ite (= (inv@52@01 r) i2@13@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12785|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@54@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@54@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@52@01 r))
          (<
            (inv@52@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@52@01 r) i2@13@01)
        (img@53@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@52@01 r))
          (<
            (inv@52@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@52@01 r) i2@13@01)
        (img@53@01 r))
      (Set_in r ($FVF.domain_f (as sm@54@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@54@01  $FVF<f>))))
  :qid |qp.fvfDomDef19|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@52@01 r))
          (<
            (inv@52@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@52@01 r) i2@13@01)
        (img@53@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@54@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@54@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef18|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@54@01  $FVF<f>))))) x@14@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@51@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@51@01)
        (<
          j@51@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
      (= j@51@01 i2@13@01))
    (and
      (=
        (inv@52@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
          j@51@01))
        j@51@01)
      (img@53@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        j@51@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
    j@51@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@53@01 r)
      (and
        (and
          (<= 0 (inv@52@01 r))
          (<
            (inv@52@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@52@01 r) i2@13@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
        (inv@52@01 r))
      r))
  :pattern ((inv@52@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@54@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@52@01 r))
          (<
            (inv@52@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@52@01 r) i2@13@01)
        (img@53@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@52@01 r))
          (<
            (inv@52@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@52@01 r) i2@13@01)
        (img@53@01 r))
      (Set_in r ($FVF.domain_f (as sm@54@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@54@01  $FVF<f>))))
  :qid |qp.fvfDomDef19|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@52@01 r))
          (<
            (inv@52@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
        (= (inv@52@01 r) i2@13@01)
        (img@53@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@54@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@54@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef18|)))
(assert (and
  (forall ((j@51@01 Int)) (!
    (=>
      (and
        (<= 0 j@51@01)
        (<
          j@51@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))))))
      (and
        (or (<= 0 j@51@01) (not (<= 0 j@51@01)))
        (or (not (= j@51@01 i2@13@01)) (= j@51@01 i2@13@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))))
      j@51@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@54@01  $FVF<f>))))) x@14@01 i2@13@01)))
(push) ; 3
(assert (not (=
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@50@01  $FVF<f>))))) x@14@01 i2@13@01)
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@54@01  $FVF<f>))))) x@14@01 i2@13@01))))
(check-sat)
; unsat
(pop) ; 3
; 0.03s
; (get-info :all-statistics)
(assert (=
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@50@01  $FVF<f>))))) x@14@01 i2@13@01)
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@54@01  $FVF<f>))))) x@14@01 i2@13@01)))
; [exec]
; xs[i2].f := 0
; [eval] xs[i2]
(push) ; 3
(assert (not (>= i2@13@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(push) ; 3
(set-option :timeout 10)
(assert (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@55@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@11@01 i2@13@01))
    ($Perm.min
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (- $Perm.Write (pTaken@21@01 r))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@56@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@11@01 i2@13@01))
    ($Perm.min
      (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@55@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (- $Perm.Write (pTaken@21@01 r))
        $Perm.No)
      (pTaken@55@01 r))
    $Perm.No)
  
  :qid |quant-u-12787|))))
(check-sat)
; unknown
(pop) ; 3
; 0.02s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@55@01 r) $Perm.No)
  
  :qid |quant-u-12788|))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (= (- $Perm.Write (pTaken@55@01 r)) $Perm.No))
  
  :qid |quant-u-12789|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@57@01 $FVF<f>)
; Definitional axioms for singleton-FVF's value
(assert (= ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)) 0))
; [exec]
; assert fun01qp(xs, i2) == old(fun01qp(xs, i2))
; [eval] fun01qp(xs, i2) == old(fun01qp(xs, i2))
; [eval] fun01qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@58@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |xs| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 26 | !(0 <= j@58@01) | live]
; [else-branch: 26 | 0 <= j@58@01 | live]
(push) ; 6
; [then-branch: 26 | !(0 <= j@58@01)]
(assert (not (<= 0 j@58@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 26 | 0 <= j@58@01]
(assert (<= 0 j@58@01))
; [eval] j < |xs|
; [eval] |xs|
(push) ; 7
; [then-branch: 27 | !(j@58@01 < |xs@11@01|) | live]
; [else-branch: 27 | j@58@01 < |xs@11@01| | live]
(push) ; 8
; [then-branch: 27 | !(j@58@01 < |xs@11@01|)]
(assert (not (< j@58@01 (Seq_length xs@11@01))))
(pop) ; 8
(push) ; 8
; [else-branch: 27 | j@58@01 < |xs@11@01|]
(assert (< j@58@01 (Seq_length xs@11@01)))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or (< j@58@01 (Seq_length xs@11@01)) (not (< j@58@01 (Seq_length xs@11@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@58@01)
  (and
    (<= 0 j@58@01)
    (or
      (< j@58@01 (Seq_length xs@11@01))
      (not (< j@58@01 (Seq_length xs@11@01)))))))
(assert (or (<= 0 j@58@01) (not (<= 0 j@58@01))))
(assert (and (<= 0 j@58@01) (and (< j@58@01 (Seq_length xs@11@01)) (= j@58@01 i2@13@01))))
; [eval] xs[j]
(push) ; 5
(assert (not (>= j@58@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@59@01 ($Ref) Int)
(declare-fun img@60@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@58@01 Int)) (!
  (=>
    (and
      (<= 0 j@58@01)
      (and (< j@58@01 (Seq_length xs@11@01)) (= j@58@01 i2@13@01)))
    (and
      (=>
        (<= 0 j@58@01)
        (and
          (<= 0 j@58@01)
          (or
            (< j@58@01 (Seq_length xs@11@01))
            (not (< j@58@01 (Seq_length xs@11@01))))))
      (or (<= 0 j@58@01) (not (<= 0 j@58@01)))))
  :pattern ((Seq_index xs@11@01 j@58@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@58@01 Int) (j2@58@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@58@01)
        (and (< j1@58@01 (Seq_length xs@11@01)) (= j1@58@01 i2@13@01)))
      (and
        (<= 0 j2@58@01)
        (and (< j2@58@01 (Seq_length xs@11@01)) (= j2@58@01 i2@13@01)))
      (= (Seq_index xs@11@01 j1@58@01) (Seq_index xs@11@01 j2@58@01)))
    (= j1@58@01 j2@58@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@58@01 Int)) (!
  (=>
    (and
      (<= 0 j@58@01)
      (and (< j@58@01 (Seq_length xs@11@01)) (= j@58@01 i2@13@01)))
    (and
      (= (inv@59@01 (Seq_index xs@11@01 j@58@01)) j@58@01)
      (img@60@01 (Seq_index xs@11@01 j@58@01))))
  :pattern ((Seq_index xs@11@01 j@58@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@60@01 r)
      (and
        (<= 0 (inv@59@01 r))
        (and (< (inv@59@01 r) (Seq_length xs@11@01)) (= (inv@59@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@59@01 r)) r))
  :pattern ((inv@59@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@59@01 r))
        (and (< (inv@59@01 r) (Seq_length xs@11@01)) (= (inv@59@01 r) i2@13@01)))
      (img@60@01 r)
      (= r (Seq_index xs@11@01 (inv@59@01 r))))
    (>
      (+
        (+
          (ite
            (and
              (img@20@01 r)
              (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
            (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12791|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@61@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@61@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@59@01 r))
          (and
            (< (inv@59@01 r) (Seq_length xs@11@01))
            (= (inv@59@01 r) i2@13@01)))
        (img@60@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@59@01 r))
          (and
            (< (inv@59@01 r) (Seq_length xs@11@01))
            (= (inv@59@01 r) i2@13@01)))
        (img@60@01 r))
      (Set_in r ($FVF.domain_f (as sm@61@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@61@01  $FVF<f>))))
  :qid |qp.fvfDomDef23|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@59@01 r))
          (and
            (< (inv@59@01 r) (Seq_length xs@11@01))
            (= (inv@59@01 r) i2@13@01)))
        (img@60@01 r))
      (= r (Seq_index xs@11@01 i2@13@01)))
    (=
      ($FVF.lookup_f (as sm@61@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@61@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@59@01 r))
          (and
            (< (inv@59@01 r) (Seq_length xs@11@01))
            (= (inv@59@01 r) i2@13@01)))
        (img@60@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@61@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@61@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@59@01 r))
          (and
            (< (inv@59@01 r) (Seq_length xs@11@01))
            (= (inv@59@01 r) i2@13@01)))
        (img@60@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@61@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@61@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef22|)))
(assert (fun01qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@61@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@58@01 Int)) (!
  (=>
    (and
      (<= 0 j@58@01)
      (and (< j@58@01 (Seq_length xs@11@01)) (= j@58@01 i2@13@01)))
    (and
      (= (inv@59@01 (Seq_index xs@11@01 j@58@01)) j@58@01)
      (img@60@01 (Seq_index xs@11@01 j@58@01))))
  :pattern ((Seq_index xs@11@01 j@58@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@60@01 r)
      (and
        (<= 0 (inv@59@01 r))
        (and (< (inv@59@01 r) (Seq_length xs@11@01)) (= (inv@59@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@59@01 r)) r))
  :pattern ((inv@59@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@61@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@59@01 r))
          (and
            (< (inv@59@01 r) (Seq_length xs@11@01))
            (= (inv@59@01 r) i2@13@01)))
        (img@60@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@59@01 r))
          (and
            (< (inv@59@01 r) (Seq_length xs@11@01))
            (= (inv@59@01 r) i2@13@01)))
        (img@60@01 r))
      (Set_in r ($FVF.domain_f (as sm@61@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@61@01  $FVF<f>))))
  :qid |qp.fvfDomDef23|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@59@01 r))
          (and
            (< (inv@59@01 r) (Seq_length xs@11@01))
            (= (inv@59@01 r) i2@13@01)))
        (img@60@01 r))
      (= r (Seq_index xs@11@01 i2@13@01)))
    (=
      ($FVF.lookup_f (as sm@61@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@61@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@59@01 r))
          (and
            (< (inv@59@01 r) (Seq_length xs@11@01))
            (= (inv@59@01 r) i2@13@01)))
        (img@60@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@61@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@61@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@59@01 r))
          (and
            (< (inv@59@01 r) (Seq_length xs@11@01))
            (= (inv@59@01 r) i2@13@01)))
        (img@60@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@61@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@61@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef22|)))
(assert (and
  (forall ((j@58@01 Int)) (!
    (=>
      (and
        (<= 0 j@58@01)
        (and (< j@58@01 (Seq_length xs@11@01)) (= j@58@01 i2@13@01)))
      (and
        (=>
          (<= 0 j@58@01)
          (and
            (<= 0 j@58@01)
            (or
              (< j@58@01 (Seq_length xs@11@01))
              (not (< j@58@01 (Seq_length xs@11@01))))))
        (or (<= 0 j@58@01) (not (<= 0 j@58@01)))))
    :pattern ((Seq_index xs@11@01 j@58@01))
    :qid |f-aux|))
  (fun01qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@61@01  $FVF<f>)))) xs@11@01 i2@13@01)))
; [eval] old(fun01qp(xs, i2))
; [eval] fun01qp(xs, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@62@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |xs| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 28 | !(0 <= j@62@01) | live]
; [else-branch: 28 | 0 <= j@62@01 | live]
(push) ; 6
; [then-branch: 28 | !(0 <= j@62@01)]
(assert (not (<= 0 j@62@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 28 | 0 <= j@62@01]
(assert (<= 0 j@62@01))
; [eval] j < |xs|
; [eval] |xs|
(push) ; 7
; [then-branch: 29 | !(j@62@01 < |xs@11@01|) | live]
; [else-branch: 29 | j@62@01 < |xs@11@01| | live]
(push) ; 8
; [then-branch: 29 | !(j@62@01 < |xs@11@01|)]
(assert (not (< j@62@01 (Seq_length xs@11@01))))
(pop) ; 8
(push) ; 8
; [else-branch: 29 | j@62@01 < |xs@11@01|]
(assert (< j@62@01 (Seq_length xs@11@01)))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or (< j@62@01 (Seq_length xs@11@01)) (not (< j@62@01 (Seq_length xs@11@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@62@01)
  (and
    (<= 0 j@62@01)
    (or
      (< j@62@01 (Seq_length xs@11@01))
      (not (< j@62@01 (Seq_length xs@11@01)))))))
(assert (or (<= 0 j@62@01) (not (<= 0 j@62@01))))
(assert (and (<= 0 j@62@01) (and (< j@62@01 (Seq_length xs@11@01)) (= j@62@01 i2@13@01))))
; [eval] xs[j]
(push) ; 5
(assert (not (>= j@62@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@63@01 ($Ref) Int)
(declare-fun img@64@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@62@01 Int)) (!
  (=>
    (and
      (<= 0 j@62@01)
      (and (< j@62@01 (Seq_length xs@11@01)) (= j@62@01 i2@13@01)))
    (and
      (=>
        (<= 0 j@62@01)
        (and
          (<= 0 j@62@01)
          (or
            (< j@62@01 (Seq_length xs@11@01))
            (not (< j@62@01 (Seq_length xs@11@01))))))
      (or (<= 0 j@62@01) (not (<= 0 j@62@01)))))
  :pattern ((Seq_index xs@11@01 j@62@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@62@01 Int) (j2@62@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@62@01)
        (and (< j1@62@01 (Seq_length xs@11@01)) (= j1@62@01 i2@13@01)))
      (and
        (<= 0 j2@62@01)
        (and (< j2@62@01 (Seq_length xs@11@01)) (= j2@62@01 i2@13@01)))
      (= (Seq_index xs@11@01 j1@62@01) (Seq_index xs@11@01 j2@62@01)))
    (= j1@62@01 j2@62@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@62@01 Int)) (!
  (=>
    (and
      (<= 0 j@62@01)
      (and (< j@62@01 (Seq_length xs@11@01)) (= j@62@01 i2@13@01)))
    (and
      (= (inv@63@01 (Seq_index xs@11@01 j@62@01)) j@62@01)
      (img@64@01 (Seq_index xs@11@01 j@62@01))))
  :pattern ((Seq_index xs@11@01 j@62@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@64@01 r)
      (and
        (<= 0 (inv@63@01 r))
        (and (< (inv@63@01 r) (Seq_length xs@11@01)) (= (inv@63@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@63@01 r)) r))
  :pattern ((inv@63@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@63@01 r))
        (and (< (inv@63@01 r) (Seq_length xs@11@01)) (= (inv@63@01 r) i2@13@01)))
      (img@64@01 r)
      (= r (Seq_index xs@11@01 (inv@63@01 r))))
    (>
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12793|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@65@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@65@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@63@01 r))
          (and
            (< (inv@63@01 r) (Seq_length xs@11@01))
            (= (inv@63@01 r) i2@13@01)))
        (img@64@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@63@01 r))
          (and
            (< (inv@63@01 r) (Seq_length xs@11@01))
            (= (inv@63@01 r) i2@13@01)))
        (img@64@01 r))
      (Set_in r ($FVF.domain_f (as sm@65@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@65@01  $FVF<f>))))
  :qid |qp.fvfDomDef25|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@63@01 r))
          (and
            (< (inv@63@01 r) (Seq_length xs@11@01))
            (= (inv@63@01 r) i2@13@01)))
        (img@64@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@65@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@65@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (fun01qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@65@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@62@01 Int)) (!
  (=>
    (and
      (<= 0 j@62@01)
      (and (< j@62@01 (Seq_length xs@11@01)) (= j@62@01 i2@13@01)))
    (and
      (= (inv@63@01 (Seq_index xs@11@01 j@62@01)) j@62@01)
      (img@64@01 (Seq_index xs@11@01 j@62@01))))
  :pattern ((Seq_index xs@11@01 j@62@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@64@01 r)
      (and
        (<= 0 (inv@63@01 r))
        (and (< (inv@63@01 r) (Seq_length xs@11@01)) (= (inv@63@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@63@01 r)) r))
  :pattern ((inv@63@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@65@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@63@01 r))
          (and
            (< (inv@63@01 r) (Seq_length xs@11@01))
            (= (inv@63@01 r) i2@13@01)))
        (img@64@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@63@01 r))
          (and
            (< (inv@63@01 r) (Seq_length xs@11@01))
            (= (inv@63@01 r) i2@13@01)))
        (img@64@01 r))
      (Set_in r ($FVF.domain_f (as sm@65@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@65@01  $FVF<f>))))
  :qid |qp.fvfDomDef25|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@63@01 r))
          (and
            (< (inv@63@01 r) (Seq_length xs@11@01))
            (= (inv@63@01 r) i2@13@01)))
        (img@64@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@65@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@65@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (and
  (forall ((j@62@01 Int)) (!
    (=>
      (and
        (<= 0 j@62@01)
        (and (< j@62@01 (Seq_length xs@11@01)) (= j@62@01 i2@13@01)))
      (and
        (=>
          (<= 0 j@62@01)
          (and
            (<= 0 j@62@01)
            (or
              (< j@62@01 (Seq_length xs@11@01))
              (not (< j@62@01 (Seq_length xs@11@01))))))
        (or (<= 0 j@62@01) (not (<= 0 j@62@01)))))
    :pattern ((Seq_index xs@11@01 j@62@01))
    :qid |f-aux|))
  (fun01qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@65@01  $FVF<f>)))) xs@11@01 i2@13@01)))
(push) ; 3
(assert (not (=
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@61@01  $FVF<f>)))) xs@11@01 i2@13@01)
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@65@01  $FVF<f>)))) xs@11@01 i2@13@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.04s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
(declare-const sm@66@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@66@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@66@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@66@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@66@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@66@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@66@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef28|)))
(declare-const pm@67@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@67@01  $FPM) r)
    (+
      (+
        (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
        $Perm.No)))
  :pattern (($FVF.perm_f (as pm@67@01  $FPM) r))
  :qid |qp.resPrmSumDef29|)))
(assert (<= ($FVF.perm_f (as pm@67@01  $FPM) (Seq_index xs@11@01 i2@13@01)) $Perm.Write))
(assert (<= ($FVF.perm_f (as pm@67@01  $FPM) (Seq_index xs@11@01 i1@12@01)) $Perm.Write))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@67@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun01qp(xs, i2) == old(fun01qp(xs, i2))
; [eval] fun01qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@68@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |xs| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 30 | !(0 <= j@68@01) | live]
; [else-branch: 30 | 0 <= j@68@01 | live]
(push) ; 6
; [then-branch: 30 | !(0 <= j@68@01)]
(assert (not (<= 0 j@68@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(declare-const sm@69@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef30|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef32|)))
(declare-const pm@70@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@70@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@70@01  $FPM) r))
  :qid |qp.resPrmSumDef33|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@70@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<= ($FVF.perm_f (as pm@70@01  $FPM) (Seq_index xs@11@01 i1@12@01)) $Perm.Write))
(assert (<= ($FVF.perm_f (as pm@70@01  $FPM) (Seq_index xs@11@01 i2@13@01)) $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 30 | 0 <= j@68@01]
(assert (<= 0 j@68@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(declare-const sm@71@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef36|)))
(declare-const pm@72@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@72@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@72@01  $FPM) r))
  :qid |qp.resPrmSumDef37|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@72@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<= ($FVF.perm_f (as pm@72@01  $FPM) (Seq_index xs@11@01 i1@12@01)) $Perm.Write))
(assert (<= ($FVF.perm_f (as pm@72@01  $FPM) (Seq_index xs@11@01 i2@13@01)) $Perm.Write))
; [eval] j < |xs|
; [eval] |xs|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 31 | !(j@68@01 < |xs@11@01|) | live]
; [else-branch: 31 | j@68@01 < |xs@11@01| | live]
(push) ; 8
; [then-branch: 31 | !(j@68@01 < |xs@11@01|)]
(assert (not (< j@68@01 (Seq_length xs@11@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 31 | j@68@01 < |xs@11@01|]
(assert (< j@68@01 (Seq_length xs@11@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  (not (< j@68@01 (Seq_length xs@11@01)))
  (and
    (not (< j@68@01 (Seq_length xs@11@01)))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01))))))
; Joined path conditions
(assert (=>
  (< j@68@01 (Seq_length xs@11@01))
  (and
    (< j@68@01 (Seq_length xs@11@01))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01))))))
(assert (or (< j@68@01 (Seq_length xs@11@01)) (not (< j@68@01 (Seq_length xs@11@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef30|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@70@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@70@01  $FPM) r))
  :qid |qp.resPrmSumDef33|)))
(assert (=>
  (not (<= 0 j@68@01))
  (and
    (not (<= 0 j@68@01))
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@70@01  $FPM) r) $Perm.Write)
      :pattern ((inv@19@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@70@01  $FPM) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@70@01  $FPM) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef36|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@72@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@72@01  $FPM) r))
  :qid |qp.resPrmSumDef37|)))
(assert (=>
  (<= 0 j@68@01)
  (and
    (<= 0 j@68@01)
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@72@01  $FPM) r) $Perm.Write)
      :pattern ((inv@19@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@72@01  $FPM) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@72@01  $FPM) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write)
    (=>
      (not (< j@68@01 (Seq_length xs@11@01)))
      (and
        (not (< j@68@01 (Seq_length xs@11@01)))
        (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
        (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
    (=>
      (< j@68@01 (Seq_length xs@11@01))
      (and
        (< j@68@01 (Seq_length xs@11@01))
        (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
        (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
    (or
      (< j@68@01 (Seq_length xs@11@01))
      (not (< j@68@01 (Seq_length xs@11@01)))))))
(assert (or (<= 0 j@68@01) (not (<= 0 j@68@01))))
(assert (and (<= 0 j@68@01) (and (< j@68@01 (Seq_length xs@11@01)) (= j@68@01 i2@13@01))))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@68@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@73@01 ($Ref) Int)
(declare-fun img@74@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef30|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@70@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@70@01  $FPM) r))
  :qid |qp.resPrmSumDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef36|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@72@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@72@01  $FPM) r))
  :qid |qp.resPrmSumDef37|)))
; Nested auxiliary terms: non-globals
(assert (forall ((j@68@01 Int)) (!
  (=>
    (and
      (<= 0 j@68@01)
      (and (< j@68@01 (Seq_length xs@11@01)) (= j@68@01 i2@13@01)))
    (and
      (=>
        (not (<= 0 j@68@01))
        (and
          (not (<= 0 j@68@01))
          (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
          (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@70@01  $FPM) r) $Perm.Write)
            :pattern ((inv@19@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@70@01  $FPM) (Seq_index xs@11@01 i1@12@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@70@01  $FPM) (Seq_index xs@11@01 i2@13@01))
            $Perm.Write)))
      (=>
        (<= 0 j@68@01)
        (and
          (<= 0 j@68@01)
          (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
          (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@72@01  $FPM) r) $Perm.Write)
            :pattern ((inv@19@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@72@01  $FPM) (Seq_index xs@11@01 i1@12@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@72@01  $FPM) (Seq_index xs@11@01 i2@13@01))
            $Perm.Write)
          (=>
            (not (< j@68@01 (Seq_length xs@11@01)))
            (and
              (not (< j@68@01 (Seq_length xs@11@01)))
              (not
                (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
              (not
                (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
          (=>
            (< j@68@01 (Seq_length xs@11@01))
            (and
              (< j@68@01 (Seq_length xs@11@01))
              (not
                (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
              (not
                (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
          (or
            (< j@68@01 (Seq_length xs@11@01))
            (not (< j@68@01 (Seq_length xs@11@01))))))
      (or (<= 0 j@68@01) (not (<= 0 j@68@01)))))
  :pattern ((Seq_index xs@11@01 j@68@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@68@01 Int) (j2@68@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@68@01)
        (and (< j1@68@01 (Seq_length xs@11@01)) (= j1@68@01 i2@13@01)))
      (and
        (<= 0 j2@68@01)
        (and (< j2@68@01 (Seq_length xs@11@01)) (= j2@68@01 i2@13@01)))
      (= (Seq_index xs@11@01 j1@68@01) (Seq_index xs@11@01 j2@68@01)))
    (= j1@68@01 j2@68@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@68@01 Int)) (!
  (=>
    (and
      (<= 0 j@68@01)
      (and (< j@68@01 (Seq_length xs@11@01)) (= j@68@01 i2@13@01)))
    (and
      (= (inv@73@01 (Seq_index xs@11@01 j@68@01)) j@68@01)
      (img@74@01 (Seq_index xs@11@01 j@68@01))))
  :pattern ((Seq_index xs@11@01 j@68@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@74@01 r)
      (and
        (<= 0 (inv@73@01 r))
        (and (< (inv@73@01 r) (Seq_length xs@11@01)) (= (inv@73@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@73@01 r)) r))
  :pattern ((inv@73@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@73@01 r))
        (and (< (inv@73@01 r) (Seq_length xs@11@01)) (= (inv@73@01 r) i2@13@01)))
      (img@74@01 r)
      (= r (Seq_index xs@11@01 (inv@73@01 r))))
    (>
      (+
        (+
          (ite
            (and
              (img@20@01 r)
              (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
            (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12795|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@75@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@75@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@73@01 r))
          (and
            (< (inv@73@01 r) (Seq_length xs@11@01))
            (= (inv@73@01 r) i2@13@01)))
        (img@74@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@73@01 r))
          (and
            (< (inv@73@01 r) (Seq_length xs@11@01))
            (= (inv@73@01 r) i2@13@01)))
        (img@74@01 r))
      (Set_in r ($FVF.domain_f (as sm@75@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@75@01  $FVF<f>))))
  :qid |qp.fvfDomDef41|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@73@01 r))
          (and
            (< (inv@73@01 r) (Seq_length xs@11@01))
            (= (inv@73@01 r) i2@13@01)))
        (img@74@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@75@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@75@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@73@01 r))
          (and
            (< (inv@73@01 r) (Seq_length xs@11@01))
            (= (inv@73@01 r) i2@13@01)))
        (img@74@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@75@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@75@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef39|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@73@01 r))
          (and
            (< (inv@73@01 r) (Seq_length xs@11@01))
            (= (inv@73@01 r) i2@13@01)))
        (img@74@01 r))
      (= r (Seq_index xs@11@01 i2@13@01)))
    (=
      ($FVF.lookup_f (as sm@75@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@75@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef40|)))
(assert (fun01qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@75@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef30|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@69@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@69@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@70@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@70@01  $FPM) r))
  :qid |qp.resPrmSumDef33|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef34|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@71@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@71@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef36|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@72@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@72@01  $FPM) r))
  :qid |qp.resPrmSumDef37|)))
(assert (forall ((j@68@01 Int)) (!
  (=>
    (and
      (<= 0 j@68@01)
      (and (< j@68@01 (Seq_length xs@11@01)) (= j@68@01 i2@13@01)))
    (and
      (= (inv@73@01 (Seq_index xs@11@01 j@68@01)) j@68@01)
      (img@74@01 (Seq_index xs@11@01 j@68@01))))
  :pattern ((Seq_index xs@11@01 j@68@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@74@01 r)
      (and
        (<= 0 (inv@73@01 r))
        (and (< (inv@73@01 r) (Seq_length xs@11@01)) (= (inv@73@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@73@01 r)) r))
  :pattern ((inv@73@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@75@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@73@01 r))
          (and
            (< (inv@73@01 r) (Seq_length xs@11@01))
            (= (inv@73@01 r) i2@13@01)))
        (img@74@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@73@01 r))
          (and
            (< (inv@73@01 r) (Seq_length xs@11@01))
            (= (inv@73@01 r) i2@13@01)))
        (img@74@01 r))
      (Set_in r ($FVF.domain_f (as sm@75@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@75@01  $FVF<f>))))
  :qid |qp.fvfDomDef41|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@73@01 r))
          (and
            (< (inv@73@01 r) (Seq_length xs@11@01))
            (= (inv@73@01 r) i2@13@01)))
        (img@74@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@75@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@75@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@73@01 r))
          (and
            (< (inv@73@01 r) (Seq_length xs@11@01))
            (= (inv@73@01 r) i2@13@01)))
        (img@74@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@75@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@75@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef39|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@73@01 r))
          (and
            (< (inv@73@01 r) (Seq_length xs@11@01))
            (= (inv@73@01 r) i2@13@01)))
        (img@74@01 r))
      (= r (Seq_index xs@11@01 i2@13@01)))
    (=
      ($FVF.lookup_f (as sm@75@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@75@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef40|)))
(assert (and
  (forall ((j@68@01 Int)) (!
    (=>
      (and
        (<= 0 j@68@01)
        (and (< j@68@01 (Seq_length xs@11@01)) (= j@68@01 i2@13@01)))
      (and
        (=>
          (not (<= 0 j@68@01))
          (and
            (not (<= 0 j@68@01))
            (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
            (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@70@01  $FPM) r) $Perm.Write)
              :pattern ((inv@19@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@70@01  $FPM) (Seq_index xs@11@01 i1@12@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@70@01  $FPM) (Seq_index xs@11@01 i2@13@01))
              $Perm.Write)))
        (=>
          (<= 0 j@68@01)
          (and
            (<= 0 j@68@01)
            (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
            (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@72@01  $FPM) r) $Perm.Write)
              :pattern ((inv@19@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@72@01  $FPM) (Seq_index xs@11@01 i1@12@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@72@01  $FPM) (Seq_index xs@11@01 i2@13@01))
              $Perm.Write)
            (=>
              (not (< j@68@01 (Seq_length xs@11@01)))
              (and
                (not (< j@68@01 (Seq_length xs@11@01)))
                (not
                  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
                (not
                  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
            (=>
              (< j@68@01 (Seq_length xs@11@01))
              (and
                (< j@68@01 (Seq_length xs@11@01))
                (not
                  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
                (not
                  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
            (or
              (< j@68@01 (Seq_length xs@11@01))
              (not (< j@68@01 (Seq_length xs@11@01))))))
        (or (<= 0 j@68@01) (not (<= 0 j@68@01)))))
    :pattern ((Seq_index xs@11@01 j@68@01))
    :qid |f-aux|))
  (fun01qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@75@01  $FVF<f>)))) xs@11@01 i2@13@01)))
; [eval] old(fun01qp(xs, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@76@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@20@01 r)
      (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
    (=
      ($FVF.lookup_f (as sm@76@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@76@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef42|)))
(declare-const pm@77@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@77@01  $FPM) r)
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@77@01  $FPM) r))
  :qid |qp.resPrmSumDef43|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@77@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun01qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@78@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |xs| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 32 | !(0 <= j@78@01) | live]
; [else-branch: 32 | 0 <= j@78@01 | live]
(push) ; 6
; [then-branch: 32 | !(0 <= j@78@01)]
(assert (not (<= 0 j@78@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 32 | 0 <= j@78@01]
(assert (<= 0 j@78@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |xs|
; [eval] |xs|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 33 | !(j@78@01 < |xs@11@01|) | live]
; [else-branch: 33 | j@78@01 < |xs@11@01| | live]
(push) ; 8
; [then-branch: 33 | !(j@78@01 < |xs@11@01|)]
(assert (not (< j@78@01 (Seq_length xs@11@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 33 | j@78@01 < |xs@11@01|]
(assert (< j@78@01 (Seq_length xs@11@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or (< j@78@01 (Seq_length xs@11@01)) (not (< j@78@01 (Seq_length xs@11@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@78@01)
  (and
    (<= 0 j@78@01)
    (or
      (< j@78@01 (Seq_length xs@11@01))
      (not (< j@78@01 (Seq_length xs@11@01)))))))
(assert (or (<= 0 j@78@01) (not (<= 0 j@78@01))))
(assert (and (<= 0 j@78@01) (and (< j@78@01 (Seq_length xs@11@01)) (= j@78@01 i2@13@01))))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@78@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@79@01 ($Ref) Int)
(declare-fun img@80@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@78@01 Int)) (!
  (=>
    (and
      (<= 0 j@78@01)
      (and (< j@78@01 (Seq_length xs@11@01)) (= j@78@01 i2@13@01)))
    (and
      (=>
        (<= 0 j@78@01)
        (and
          (<= 0 j@78@01)
          (or
            (< j@78@01 (Seq_length xs@11@01))
            (not (< j@78@01 (Seq_length xs@11@01))))))
      (or (<= 0 j@78@01) (not (<= 0 j@78@01)))))
  :pattern ((Seq_index xs@11@01 j@78@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@78@01 Int) (j2@78@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@78@01)
        (and (< j1@78@01 (Seq_length xs@11@01)) (= j1@78@01 i2@13@01)))
      (and
        (<= 0 j2@78@01)
        (and (< j2@78@01 (Seq_length xs@11@01)) (= j2@78@01 i2@13@01)))
      (= (Seq_index xs@11@01 j1@78@01) (Seq_index xs@11@01 j2@78@01)))
    (= j1@78@01 j2@78@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@78@01 Int)) (!
  (=>
    (and
      (<= 0 j@78@01)
      (and (< j@78@01 (Seq_length xs@11@01)) (= j@78@01 i2@13@01)))
    (and
      (= (inv@79@01 (Seq_index xs@11@01 j@78@01)) j@78@01)
      (img@80@01 (Seq_index xs@11@01 j@78@01))))
  :pattern ((Seq_index xs@11@01 j@78@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@80@01 r)
      (and
        (<= 0 (inv@79@01 r))
        (and (< (inv@79@01 r) (Seq_length xs@11@01)) (= (inv@79@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@79@01 r)) r))
  :pattern ((inv@79@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@79@01 r))
        (and (< (inv@79@01 r) (Seq_length xs@11@01)) (= (inv@79@01 r) i2@13@01)))
      (img@80@01 r)
      (= r (Seq_index xs@11@01 (inv@79@01 r))))
    (>
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12797|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@81@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@81@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@79@01 r))
          (and
            (< (inv@79@01 r) (Seq_length xs@11@01))
            (= (inv@79@01 r) i2@13@01)))
        (img@80@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@79@01 r))
          (and
            (< (inv@79@01 r) (Seq_length xs@11@01))
            (= (inv@79@01 r) i2@13@01)))
        (img@80@01 r))
      (Set_in r ($FVF.domain_f (as sm@81@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@81@01  $FVF<f>))))
  :qid |qp.fvfDomDef45|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@79@01 r))
          (and
            (< (inv@79@01 r) (Seq_length xs@11@01))
            (= (inv@79@01 r) i2@13@01)))
        (img@80@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@81@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@81@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef44|)))
(assert (fun01qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@81@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@78@01 Int)) (!
  (=>
    (and
      (<= 0 j@78@01)
      (and (< j@78@01 (Seq_length xs@11@01)) (= j@78@01 i2@13@01)))
    (and
      (= (inv@79@01 (Seq_index xs@11@01 j@78@01)) j@78@01)
      (img@80@01 (Seq_index xs@11@01 j@78@01))))
  :pattern ((Seq_index xs@11@01 j@78@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@80@01 r)
      (and
        (<= 0 (inv@79@01 r))
        (and (< (inv@79@01 r) (Seq_length xs@11@01)) (= (inv@79@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@79@01 r)) r))
  :pattern ((inv@79@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@81@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@79@01 r))
          (and
            (< (inv@79@01 r) (Seq_length xs@11@01))
            (= (inv@79@01 r) i2@13@01)))
        (img@80@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@79@01 r))
          (and
            (< (inv@79@01 r) (Seq_length xs@11@01))
            (= (inv@79@01 r) i2@13@01)))
        (img@80@01 r))
      (Set_in r ($FVF.domain_f (as sm@81@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@81@01  $FVF<f>))))
  :qid |qp.fvfDomDef45|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@79@01 r))
          (and
            (< (inv@79@01 r) (Seq_length xs@11@01))
            (= (inv@79@01 r) i2@13@01)))
        (img@80@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@81@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@81@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef44|)))
(assert (and
  (forall ((j@78@01 Int)) (!
    (=>
      (and
        (<= 0 j@78@01)
        (and (< j@78@01 (Seq_length xs@11@01)) (= j@78@01 i2@13@01)))
      (and
        (=>
          (<= 0 j@78@01)
          (and
            (<= 0 j@78@01)
            (or
              (< j@78@01 (Seq_length xs@11@01))
              (not (< j@78@01 (Seq_length xs@11@01))))))
        (or (<= 0 j@78@01) (not (<= 0 j@78@01)))))
    :pattern ((Seq_index xs@11@01 j@78@01))
    :qid |f-aux|))
  (fun01qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@81@01  $FVF<f>)))) xs@11@01 i2@13@01)))
(push) ; 3
(assert (not (=
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@75@01  $FVF<f>)))) xs@11@01 i2@13@01)
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@81@01  $FVF<f>)))) xs@11@01 i2@13@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.04s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
(declare-const sm@82@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@82@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@82@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@82@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@82@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef47|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@82@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@82@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef48|)))
(declare-const pm@83@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@83@01  $FPM) r)
    (+
      (+
        (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
        $Perm.No)))
  :pattern (($FVF.perm_f (as pm@83@01  $FPM) r))
  :qid |qp.resPrmSumDef49|)))
(assert (<= ($FVF.perm_f (as pm@83@01  $FPM) (Seq_index xs@11@01 i2@13@01)) $Perm.Write))
(assert (<= ($FVF.perm_f (as pm@83@01  $FPM) (Seq_index xs@11@01 i1@12@01)) $Perm.Write))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@83@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun01qp(xs, i2) == old(fun01qp(xs, i2))
; [eval] fun01qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@84@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |xs| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 34 | !(0 <= j@84@01) | live]
; [else-branch: 34 | 0 <= j@84@01 | live]
(push) ; 6
; [then-branch: 34 | !(0 <= j@84@01)]
(assert (not (<= 0 j@84@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 34 | 0 <= j@84@01]
(assert (<= 0 j@84@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |xs|
; [eval] |xs|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 35 | !(j@84@01 < |xs@11@01|) | live]
; [else-branch: 35 | j@84@01 < |xs@11@01| | live]
(push) ; 8
; [then-branch: 35 | !(j@84@01 < |xs@11@01|)]
(assert (not (< j@84@01 (Seq_length xs@11@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(declare-const sm@85@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef52|)))
(declare-const pm@86@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@86@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@86@01  $FPM) r))
  :qid |qp.resPrmSumDef53|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@86@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<= ($FVF.perm_f (as pm@86@01  $FPM) (Seq_index xs@11@01 i1@12@01)) $Perm.Write))
(assert (<= ($FVF.perm_f (as pm@86@01  $FPM) (Seq_index xs@11@01 i2@13@01)) $Perm.Write))
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 35 | j@84@01 < |xs@11@01|]
(assert (< j@84@01 (Seq_length xs@11@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(declare-const sm@87@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef56|)))
(declare-const pm@88@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@88@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@88@01  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@88@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<= ($FVF.perm_f (as pm@88@01  $FPM) (Seq_index xs@11@01 i1@12@01)) $Perm.Write))
(assert (<= ($FVF.perm_f (as pm@88@01  $FPM) (Seq_index xs@11@01 i2@13@01)) $Perm.Write))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@86@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@86@01  $FPM) r))
  :qid |qp.resPrmSumDef53|)))
(assert (=>
  (not (< j@84@01 (Seq_length xs@11@01)))
  (and
    (not (< j@84@01 (Seq_length xs@11@01)))
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@86@01  $FPM) r) $Perm.Write)
      :pattern ((inv@19@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@86@01  $FPM) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@86@01  $FPM) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@88@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@88@01  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (=>
  (< j@84@01 (Seq_length xs@11@01))
  (and
    (< j@84@01 (Seq_length xs@11@01))
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@88@01  $FPM) r) $Perm.Write)
      :pattern ((inv@19@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@88@01  $FPM) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@88@01  $FPM) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write))))
(assert (or (< j@84@01 (Seq_length xs@11@01)) (not (< j@84@01 (Seq_length xs@11@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (not (<= 0 j@84@01))
  (and
    (not (<= 0 j@84@01))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01))))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@86@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@86@01  $FPM) r))
  :qid |qp.resPrmSumDef53|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@88@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@88@01  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (=>
  (<= 0 j@84@01)
  (and
    (<= 0 j@84@01)
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
    (=>
      (not (< j@84@01 (Seq_length xs@11@01)))
      (and
        (not (< j@84@01 (Seq_length xs@11@01)))
        (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
        (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_f (as pm@86@01  $FPM) r) $Perm.Write)
          :pattern ((inv@19@01 r))
          :qid |qp-fld-prm-bnd|))
        (<=
          ($FVF.perm_f (as pm@86@01  $FPM) (Seq_index xs@11@01 i1@12@01))
          $Perm.Write)
        (<=
          ($FVF.perm_f (as pm@86@01  $FPM) (Seq_index xs@11@01 i2@13@01))
          $Perm.Write)))
    (=>
      (< j@84@01 (Seq_length xs@11@01))
      (and
        (< j@84@01 (Seq_length xs@11@01))
        (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
        (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_f (as pm@88@01  $FPM) r) $Perm.Write)
          :pattern ((inv@19@01 r))
          :qid |qp-fld-prm-bnd|))
        (<=
          ($FVF.perm_f (as pm@88@01  $FPM) (Seq_index xs@11@01 i1@12@01))
          $Perm.Write)
        (<=
          ($FVF.perm_f (as pm@88@01  $FPM) (Seq_index xs@11@01 i2@13@01))
          $Perm.Write)))
    (or
      (< j@84@01 (Seq_length xs@11@01))
      (not (< j@84@01 (Seq_length xs@11@01)))))))
(assert (or (<= 0 j@84@01) (not (<= 0 j@84@01))))
(assert (and (<= 0 j@84@01) (and (< j@84@01 (Seq_length xs@11@01)) (= j@84@01 i2@13@01))))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@84@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@89@01 ($Ref) Int)
(declare-fun img@90@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@86@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@86@01  $FPM) r))
  :qid |qp.resPrmSumDef53|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@88@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@88@01  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
; Nested auxiliary terms: non-globals
(assert (forall ((j@84@01 Int)) (!
  (=>
    (and
      (<= 0 j@84@01)
      (and (< j@84@01 (Seq_length xs@11@01)) (= j@84@01 i2@13@01)))
    (and
      (=>
        (not (<= 0 j@84@01))
        (and
          (not (<= 0 j@84@01))
          (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
          (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
      (=>
        (<= 0 j@84@01)
        (and
          (<= 0 j@84@01)
          (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
          (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
          (=>
            (not (< j@84@01 (Seq_length xs@11@01)))
            (and
              (not (< j@84@01 (Seq_length xs@11@01)))
              (not
                (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
              (not
                (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
              (forall ((r $Ref)) (!
                (<= ($FVF.perm_f (as pm@86@01  $FPM) r) $Perm.Write)
                :pattern ((inv@19@01 r))
                :qid |qp-fld-prm-bnd|))
              (<=
                ($FVF.perm_f (as pm@86@01  $FPM) (Seq_index xs@11@01 i1@12@01))
                $Perm.Write)
              (<=
                ($FVF.perm_f (as pm@86@01  $FPM) (Seq_index xs@11@01 i2@13@01))
                $Perm.Write)))
          (=>
            (< j@84@01 (Seq_length xs@11@01))
            (and
              (< j@84@01 (Seq_length xs@11@01))
              (not
                (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
              (not
                (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
              (forall ((r $Ref)) (!
                (<= ($FVF.perm_f (as pm@88@01  $FPM) r) $Perm.Write)
                :pattern ((inv@19@01 r))
                :qid |qp-fld-prm-bnd|))
              (<=
                ($FVF.perm_f (as pm@88@01  $FPM) (Seq_index xs@11@01 i1@12@01))
                $Perm.Write)
              (<=
                ($FVF.perm_f (as pm@88@01  $FPM) (Seq_index xs@11@01 i2@13@01))
                $Perm.Write)))
          (or
            (< j@84@01 (Seq_length xs@11@01))
            (not (< j@84@01 (Seq_length xs@11@01))))))
      (or (<= 0 j@84@01) (not (<= 0 j@84@01)))))
  :pattern ((Seq_index xs@11@01 j@84@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@84@01 Int) (j2@84@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@84@01)
        (and (< j1@84@01 (Seq_length xs@11@01)) (= j1@84@01 i2@13@01)))
      (and
        (<= 0 j2@84@01)
        (and (< j2@84@01 (Seq_length xs@11@01)) (= j2@84@01 i2@13@01)))
      (= (Seq_index xs@11@01 j1@84@01) (Seq_index xs@11@01 j2@84@01)))
    (= j1@84@01 j2@84@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@84@01 Int)) (!
  (=>
    (and
      (<= 0 j@84@01)
      (and (< j@84@01 (Seq_length xs@11@01)) (= j@84@01 i2@13@01)))
    (and
      (= (inv@89@01 (Seq_index xs@11@01 j@84@01)) j@84@01)
      (img@90@01 (Seq_index xs@11@01 j@84@01))))
  :pattern ((Seq_index xs@11@01 j@84@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@90@01 r)
      (and
        (<= 0 (inv@89@01 r))
        (and (< (inv@89@01 r) (Seq_length xs@11@01)) (= (inv@89@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@89@01 r)) r))
  :pattern ((inv@89@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@89@01 r))
        (and (< (inv@89@01 r) (Seq_length xs@11@01)) (= (inv@89@01 r) i2@13@01)))
      (img@90@01 r)
      (= r (Seq_index xs@11@01 (inv@89@01 r))))
    (>
      (+
        (+
          (ite
            (and
              (img@20@01 r)
              (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
            (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12799|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@91@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@91@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@89@01 r))
          (and
            (< (inv@89@01 r) (Seq_length xs@11@01))
            (= (inv@89@01 r) i2@13@01)))
        (img@90@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@89@01 r))
          (and
            (< (inv@89@01 r) (Seq_length xs@11@01))
            (= (inv@89@01 r) i2@13@01)))
        (img@90@01 r))
      (Set_in r ($FVF.domain_f (as sm@91@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@91@01  $FVF<f>))))
  :qid |qp.fvfDomDef61|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@89@01 r))
          (and
            (< (inv@89@01 r) (Seq_length xs@11@01))
            (= (inv@89@01 r) i2@13@01)))
        (img@90@01 r))
      (= r (Seq_index xs@11@01 i2@13@01)))
    (=
      ($FVF.lookup_f (as sm@91@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@91@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@89@01 r))
          (and
            (< (inv@89@01 r) (Seq_length xs@11@01))
            (= (inv@89@01 r) i2@13@01)))
        (img@90@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@91@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@91@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@89@01 r))
          (and
            (< (inv@89@01 r) (Seq_length xs@11@01))
            (= (inv@89@01 r) i2@13@01)))
        (img@90@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@91@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@91@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef60|)))
(assert (fun01qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@91@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@85@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@85@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@86@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@86@01  $FPM) r))
  :qid |qp.resPrmSumDef53|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef55|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@87@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@87@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@88@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@88@01  $FPM) r))
  :qid |qp.resPrmSumDef57|)))
(assert (forall ((j@84@01 Int)) (!
  (=>
    (and
      (<= 0 j@84@01)
      (and (< j@84@01 (Seq_length xs@11@01)) (= j@84@01 i2@13@01)))
    (and
      (= (inv@89@01 (Seq_index xs@11@01 j@84@01)) j@84@01)
      (img@90@01 (Seq_index xs@11@01 j@84@01))))
  :pattern ((Seq_index xs@11@01 j@84@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@90@01 r)
      (and
        (<= 0 (inv@89@01 r))
        (and (< (inv@89@01 r) (Seq_length xs@11@01)) (= (inv@89@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@89@01 r)) r))
  :pattern ((inv@89@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@91@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@89@01 r))
          (and
            (< (inv@89@01 r) (Seq_length xs@11@01))
            (= (inv@89@01 r) i2@13@01)))
        (img@90@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@89@01 r))
          (and
            (< (inv@89@01 r) (Seq_length xs@11@01))
            (= (inv@89@01 r) i2@13@01)))
        (img@90@01 r))
      (Set_in r ($FVF.domain_f (as sm@91@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@91@01  $FVF<f>))))
  :qid |qp.fvfDomDef61|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@89@01 r))
          (and
            (< (inv@89@01 r) (Seq_length xs@11@01))
            (= (inv@89@01 r) i2@13@01)))
        (img@90@01 r))
      (= r (Seq_index xs@11@01 i2@13@01)))
    (=
      ($FVF.lookup_f (as sm@91@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@91@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@89@01 r))
          (and
            (< (inv@89@01 r) (Seq_length xs@11@01))
            (= (inv@89@01 r) i2@13@01)))
        (img@90@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@91@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@91@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@89@01 r))
          (and
            (< (inv@89@01 r) (Seq_length xs@11@01))
            (= (inv@89@01 r) i2@13@01)))
        (img@90@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@91@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@91@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef60|)))
(assert (and
  (forall ((j@84@01 Int)) (!
    (=>
      (and
        (<= 0 j@84@01)
        (and (< j@84@01 (Seq_length xs@11@01)) (= j@84@01 i2@13@01)))
      (and
        (=>
          (not (<= 0 j@84@01))
          (and
            (not (<= 0 j@84@01))
            (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
            (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
        (=>
          (<= 0 j@84@01)
          (and
            (<= 0 j@84@01)
            (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
            (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
            (=>
              (not (< j@84@01 (Seq_length xs@11@01)))
              (and
                (not (< j@84@01 (Seq_length xs@11@01)))
                (not
                  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
                (not
                  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
                (forall ((r $Ref)) (!
                  (<= ($FVF.perm_f (as pm@86@01  $FPM) r) $Perm.Write)
                  :pattern ((inv@19@01 r))
                  :qid |qp-fld-prm-bnd|))
                (<=
                  ($FVF.perm_f (as pm@86@01  $FPM) (Seq_index xs@11@01 i1@12@01))
                  $Perm.Write)
                (<=
                  ($FVF.perm_f (as pm@86@01  $FPM) (Seq_index xs@11@01 i2@13@01))
                  $Perm.Write)))
            (=>
              (< j@84@01 (Seq_length xs@11@01))
              (and
                (< j@84@01 (Seq_length xs@11@01))
                (not
                  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
                (not
                  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
                (forall ((r $Ref)) (!
                  (<= ($FVF.perm_f (as pm@88@01  $FPM) r) $Perm.Write)
                  :pattern ((inv@19@01 r))
                  :qid |qp-fld-prm-bnd|))
                (<=
                  ($FVF.perm_f (as pm@88@01  $FPM) (Seq_index xs@11@01 i1@12@01))
                  $Perm.Write)
                (<=
                  ($FVF.perm_f (as pm@88@01  $FPM) (Seq_index xs@11@01 i2@13@01))
                  $Perm.Write)))
            (or
              (< j@84@01 (Seq_length xs@11@01))
              (not (< j@84@01 (Seq_length xs@11@01))))))
        (or (<= 0 j@84@01) (not (<= 0 j@84@01)))))
    :pattern ((Seq_index xs@11@01 j@84@01))
    :qid |f-aux|))
  (fun01qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@91@01  $FVF<f>)))) xs@11@01 i2@13@01)))
; [eval] old(fun01qp(xs, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@92@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@20@01 r)
      (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
    (=
      ($FVF.lookup_f (as sm@92@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@92@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef62|)))
(declare-const pm@93@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@93@01  $FPM) r)
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@93@01  $FPM) r))
  :qid |qp.resPrmSumDef63|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@93@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun01qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@94@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |xs| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 36 | !(0 <= j@94@01) | live]
; [else-branch: 36 | 0 <= j@94@01 | live]
(push) ; 6
; [then-branch: 36 | !(0 <= j@94@01)]
(assert (not (<= 0 j@94@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 36 | 0 <= j@94@01]
(assert (<= 0 j@94@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |xs|
; [eval] |xs|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 37 | !(j@94@01 < |xs@11@01|) | live]
; [else-branch: 37 | j@94@01 < |xs@11@01| | live]
(push) ; 8
; [then-branch: 37 | !(j@94@01 < |xs@11@01|)]
(assert (not (< j@94@01 (Seq_length xs@11@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 37 | j@94@01 < |xs@11@01|]
(assert (< j@94@01 (Seq_length xs@11@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or (< j@94@01 (Seq_length xs@11@01)) (not (< j@94@01 (Seq_length xs@11@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@94@01)
  (and
    (<= 0 j@94@01)
    (or
      (< j@94@01 (Seq_length xs@11@01))
      (not (< j@94@01 (Seq_length xs@11@01)))))))
(assert (or (<= 0 j@94@01) (not (<= 0 j@94@01))))
(assert (and (<= 0 j@94@01) (and (< j@94@01 (Seq_length xs@11@01)) (= j@94@01 i2@13@01))))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@94@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@95@01 ($Ref) Int)
(declare-fun img@96@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@94@01 Int)) (!
  (=>
    (and
      (<= 0 j@94@01)
      (and (< j@94@01 (Seq_length xs@11@01)) (= j@94@01 i2@13@01)))
    (and
      (=>
        (<= 0 j@94@01)
        (and
          (<= 0 j@94@01)
          (or
            (< j@94@01 (Seq_length xs@11@01))
            (not (< j@94@01 (Seq_length xs@11@01))))))
      (or (<= 0 j@94@01) (not (<= 0 j@94@01)))))
  :pattern ((Seq_index xs@11@01 j@94@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@94@01 Int) (j2@94@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@94@01)
        (and (< j1@94@01 (Seq_length xs@11@01)) (= j1@94@01 i2@13@01)))
      (and
        (<= 0 j2@94@01)
        (and (< j2@94@01 (Seq_length xs@11@01)) (= j2@94@01 i2@13@01)))
      (= (Seq_index xs@11@01 j1@94@01) (Seq_index xs@11@01 j2@94@01)))
    (= j1@94@01 j2@94@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@94@01 Int)) (!
  (=>
    (and
      (<= 0 j@94@01)
      (and (< j@94@01 (Seq_length xs@11@01)) (= j@94@01 i2@13@01)))
    (and
      (= (inv@95@01 (Seq_index xs@11@01 j@94@01)) j@94@01)
      (img@96@01 (Seq_index xs@11@01 j@94@01))))
  :pattern ((Seq_index xs@11@01 j@94@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@96@01 r)
      (and
        (<= 0 (inv@95@01 r))
        (and (< (inv@95@01 r) (Seq_length xs@11@01)) (= (inv@95@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@95@01 r)) r))
  :pattern ((inv@95@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@95@01 r))
        (and (< (inv@95@01 r) (Seq_length xs@11@01)) (= (inv@95@01 r) i2@13@01)))
      (img@96@01 r)
      (= r (Seq_index xs@11@01 (inv@95@01 r))))
    (>
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12801|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@97@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@97@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@95@01 r))
          (and
            (< (inv@95@01 r) (Seq_length xs@11@01))
            (= (inv@95@01 r) i2@13@01)))
        (img@96@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@95@01 r))
          (and
            (< (inv@95@01 r) (Seq_length xs@11@01))
            (= (inv@95@01 r) i2@13@01)))
        (img@96@01 r))
      (Set_in r ($FVF.domain_f (as sm@97@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@97@01  $FVF<f>))))
  :qid |qp.fvfDomDef65|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@95@01 r))
          (and
            (< (inv@95@01 r) (Seq_length xs@11@01))
            (= (inv@95@01 r) i2@13@01)))
        (img@96@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@97@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@97@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (fun01qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@97@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@94@01 Int)) (!
  (=>
    (and
      (<= 0 j@94@01)
      (and (< j@94@01 (Seq_length xs@11@01)) (= j@94@01 i2@13@01)))
    (and
      (= (inv@95@01 (Seq_index xs@11@01 j@94@01)) j@94@01)
      (img@96@01 (Seq_index xs@11@01 j@94@01))))
  :pattern ((Seq_index xs@11@01 j@94@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@96@01 r)
      (and
        (<= 0 (inv@95@01 r))
        (and (< (inv@95@01 r) (Seq_length xs@11@01)) (= (inv@95@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@95@01 r)) r))
  :pattern ((inv@95@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@97@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@95@01 r))
          (and
            (< (inv@95@01 r) (Seq_length xs@11@01))
            (= (inv@95@01 r) i2@13@01)))
        (img@96@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@95@01 r))
          (and
            (< (inv@95@01 r) (Seq_length xs@11@01))
            (= (inv@95@01 r) i2@13@01)))
        (img@96@01 r))
      (Set_in r ($FVF.domain_f (as sm@97@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@97@01  $FVF<f>))))
  :qid |qp.fvfDomDef65|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@95@01 r))
          (and
            (< (inv@95@01 r) (Seq_length xs@11@01))
            (= (inv@95@01 r) i2@13@01)))
        (img@96@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@97@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@97@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (and
  (forall ((j@94@01 Int)) (!
    (=>
      (and
        (<= 0 j@94@01)
        (and (< j@94@01 (Seq_length xs@11@01)) (= j@94@01 i2@13@01)))
      (and
        (=>
          (<= 0 j@94@01)
          (and
            (<= 0 j@94@01)
            (or
              (< j@94@01 (Seq_length xs@11@01))
              (not (< j@94@01 (Seq_length xs@11@01))))))
        (or (<= 0 j@94@01) (not (<= 0 j@94@01)))))
    :pattern ((Seq_index xs@11@01 j@94@01))
    :qid |f-aux|))
  (fun01qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@97@01  $FVF<f>)))) xs@11@01 i2@13@01)))
(push) ; 3
(assert (not (=
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@91@01  $FVF<f>)))) xs@11@01 i2@13@01)
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@97@01  $FVF<f>)))) xs@11@01 i2@13@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.04s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] fun01qp(xs, i2) == old(fun01qp(xs, i2))
; [eval] fun01qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@98@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |xs| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 38 | !(0 <= j@98@01) | live]
; [else-branch: 38 | 0 <= j@98@01 | live]
(push) ; 6
; [then-branch: 38 | !(0 <= j@98@01)]
(assert (not (<= 0 j@98@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(declare-const sm@99@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef68|)))
(declare-const pm@100@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@100@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@100@01  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@100@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<= ($FVF.perm_f (as pm@100@01  $FPM) (Seq_index xs@11@01 i1@12@01)) $Perm.Write))
(assert (<= ($FVF.perm_f (as pm@100@01  $FPM) (Seq_index xs@11@01 i2@13@01)) $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 38 | 0 <= j@98@01]
(assert (<= 0 j@98@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(declare-const sm@101@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef72|)))
(declare-const pm@102@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@102@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@102@01  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@102@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<= ($FVF.perm_f (as pm@102@01  $FPM) (Seq_index xs@11@01 i1@12@01)) $Perm.Write))
(assert (<= ($FVF.perm_f (as pm@102@01  $FPM) (Seq_index xs@11@01 i2@13@01)) $Perm.Write))
; [eval] j < |xs|
; [eval] |xs|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 39 | !(j@98@01 < |xs@11@01|) | live]
; [else-branch: 39 | j@98@01 < |xs@11@01| | live]
(push) ; 8
; [then-branch: 39 | !(j@98@01 < |xs@11@01|)]
(assert (not (< j@98@01 (Seq_length xs@11@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 39 | j@98@01 < |xs@11@01|]
(assert (< j@98@01 (Seq_length xs@11@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01))
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01))
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i1@12@01))
    (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i2@13@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) (Seq_index xs@11@01 i1@12@01))
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) (Seq_index xs@11@01 i2@13@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
  (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  (not (< j@98@01 (Seq_length xs@11@01)))
  (and
    (not (< j@98@01 (Seq_length xs@11@01)))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01))))))
; Joined path conditions
(assert (=>
  (< j@98@01 (Seq_length xs@11@01))
  (and
    (< j@98@01 (Seq_length xs@11@01))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01))))))
(assert (or (< j@98@01 (Seq_length xs@11@01)) (not (< j@98@01 (Seq_length xs@11@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@100@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@100@01  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (=>
  (not (<= 0 j@98@01))
  (and
    (not (<= 0 j@98@01))
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@100@01  $FPM) r) $Perm.Write)
      :pattern ((inv@19@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@100@01  $FPM) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@100@01  $FPM) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@102@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@102@01  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (=>
  (<= 0 j@98@01)
  (and
    (<= 0 j@98@01)
    (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
    (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@102@01  $FPM) r) $Perm.Write)
      :pattern ((inv@19@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@102@01  $FPM) (Seq_index xs@11@01 i1@12@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@102@01  $FPM) (Seq_index xs@11@01 i2@13@01))
      $Perm.Write)
    (=>
      (not (< j@98@01 (Seq_length xs@11@01)))
      (and
        (not (< j@98@01 (Seq_length xs@11@01)))
        (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
        (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
    (=>
      (< j@98@01 (Seq_length xs@11@01))
      (and
        (< j@98@01 (Seq_length xs@11@01))
        (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
        (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
    (or
      (< j@98@01 (Seq_length xs@11@01))
      (not (< j@98@01 (Seq_length xs@11@01)))))))
(assert (or (<= 0 j@98@01) (not (<= 0 j@98@01))))
(assert (and (<= 0 j@98@01) (and (< j@98@01 (Seq_length xs@11@01)) (= j@98@01 i2@13@01))))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@98@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@103@01 ($Ref) Int)
(declare-fun img@104@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@100@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@100@01  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@102@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@102@01  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
; Nested auxiliary terms: non-globals
(assert (forall ((j@98@01 Int)) (!
  (=>
    (and
      (<= 0 j@98@01)
      (and (< j@98@01 (Seq_length xs@11@01)) (= j@98@01 i2@13@01)))
    (and
      (=>
        (not (<= 0 j@98@01))
        (and
          (not (<= 0 j@98@01))
          (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
          (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@100@01  $FPM) r) $Perm.Write)
            :pattern ((inv@19@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@100@01  $FPM) (Seq_index xs@11@01 i1@12@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@100@01  $FPM) (Seq_index xs@11@01 i2@13@01))
            $Perm.Write)))
      (=>
        (<= 0 j@98@01)
        (and
          (<= 0 j@98@01)
          (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
          (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@102@01  $FPM) r) $Perm.Write)
            :pattern ((inv@19@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@102@01  $FPM) (Seq_index xs@11@01 i1@12@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@102@01  $FPM) (Seq_index xs@11@01 i2@13@01))
            $Perm.Write)
          (=>
            (not (< j@98@01 (Seq_length xs@11@01)))
            (and
              (not (< j@98@01 (Seq_length xs@11@01)))
              (not
                (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
              (not
                (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
          (=>
            (< j@98@01 (Seq_length xs@11@01))
            (and
              (< j@98@01 (Seq_length xs@11@01))
              (not
                (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
              (not
                (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
          (or
            (< j@98@01 (Seq_length xs@11@01))
            (not (< j@98@01 (Seq_length xs@11@01))))))
      (or (<= 0 j@98@01) (not (<= 0 j@98@01)))))
  :pattern ((Seq_index xs@11@01 j@98@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@98@01 Int) (j2@98@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@98@01)
        (and (< j1@98@01 (Seq_length xs@11@01)) (= j1@98@01 i2@13@01)))
      (and
        (<= 0 j2@98@01)
        (and (< j2@98@01 (Seq_length xs@11@01)) (= j2@98@01 i2@13@01)))
      (= (Seq_index xs@11@01 j1@98@01) (Seq_index xs@11@01 j2@98@01)))
    (= j1@98@01 j2@98@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@98@01 Int)) (!
  (=>
    (and
      (<= 0 j@98@01)
      (and (< j@98@01 (Seq_length xs@11@01)) (= j@98@01 i2@13@01)))
    (and
      (= (inv@103@01 (Seq_index xs@11@01 j@98@01)) j@98@01)
      (img@104@01 (Seq_index xs@11@01 j@98@01))))
  :pattern ((Seq_index xs@11@01 j@98@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@104@01 r)
      (and
        (<= 0 (inv@103@01 r))
        (and
          (< (inv@103@01 r) (Seq_length xs@11@01))
          (= (inv@103@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@103@01 r)) r))
  :pattern ((inv@103@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@103@01 r))
        (and
          (< (inv@103@01 r) (Seq_length xs@11@01))
          (= (inv@103@01 r) i2@13@01)))
      (img@104@01 r)
      (= r (Seq_index xs@11@01 (inv@103@01 r))))
    (>
      (+
        (+
          (ite
            (and
              (img@20@01 r)
              (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
            (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12803|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@105@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@105@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@103@01 r))
          (and
            (< (inv@103@01 r) (Seq_length xs@11@01))
            (= (inv@103@01 r) i2@13@01)))
        (img@104@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@103@01 r))
          (and
            (< (inv@103@01 r) (Seq_length xs@11@01))
            (= (inv@103@01 r) i2@13@01)))
        (img@104@01 r))
      (Set_in r ($FVF.domain_f (as sm@105@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@105@01  $FVF<f>))))
  :qid |qp.fvfDomDef77|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@103@01 r))
          (and
            (< (inv@103@01 r) (Seq_length xs@11@01))
            (= (inv@103@01 r) i2@13@01)))
        (img@104@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@105@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@105@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@103@01 r))
          (and
            (< (inv@103@01 r) (Seq_length xs@11@01))
            (= (inv@103@01 r) i2@13@01)))
        (img@104@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@105@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@105@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@103@01 r))
          (and
            (< (inv@103@01 r) (Seq_length xs@11@01))
            (= (inv@103@01 r) i2@13@01)))
        (img@104@01 r))
      (= r (Seq_index xs@11@01 i2@13@01)))
    (=
      ($FVF.lookup_f (as sm@105@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@105@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef76|)))
(assert (fun01qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@105@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@99@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@99@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef68|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@100@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@100@01  $FPM) r))
  :qid |qp.resPrmSumDef69|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i1@12@01))
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@11@01 i2@13@01))
    (=
      ($FVF.lookup_f (as sm@101@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@101@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@102@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@20@01 r)
            (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
          (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@11@01 i1@12@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@11@01 i2@13@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@102@01  $FPM) r))
  :qid |qp.resPrmSumDef73|)))
(assert (forall ((j@98@01 Int)) (!
  (=>
    (and
      (<= 0 j@98@01)
      (and (< j@98@01 (Seq_length xs@11@01)) (= j@98@01 i2@13@01)))
    (and
      (= (inv@103@01 (Seq_index xs@11@01 j@98@01)) j@98@01)
      (img@104@01 (Seq_index xs@11@01 j@98@01))))
  :pattern ((Seq_index xs@11@01 j@98@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@104@01 r)
      (and
        (<= 0 (inv@103@01 r))
        (and
          (< (inv@103@01 r) (Seq_length xs@11@01))
          (= (inv@103@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@103@01 r)) r))
  :pattern ((inv@103@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@105@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@103@01 r))
          (and
            (< (inv@103@01 r) (Seq_length xs@11@01))
            (= (inv@103@01 r) i2@13@01)))
        (img@104@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@103@01 r))
          (and
            (< (inv@103@01 r) (Seq_length xs@11@01))
            (= (inv@103@01 r) i2@13@01)))
        (img@104@01 r))
      (Set_in r ($FVF.domain_f (as sm@105@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@105@01  $FVF<f>))))
  :qid |qp.fvfDomDef77|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@103@01 r))
          (and
            (< (inv@103@01 r) (Seq_length xs@11@01))
            (= (inv@103@01 r) i2@13@01)))
        (img@104@01 r))
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@21@01 r)) (pTaken@55@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@105@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@105@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@103@01 r))
          (and
            (< (inv@103@01 r) (Seq_length xs@11@01))
            (= (inv@103@01 r) i2@13@01)))
        (img@104@01 r))
      (= r (Seq_index xs@11@01 i1@12@01)))
    (=
      ($FVF.lookup_f (as sm@105@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@22@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@105@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@22@01  $FVF<f>) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@103@01 r))
          (and
            (< (inv@103@01 r) (Seq_length xs@11@01))
            (= (inv@103@01 r) i2@13@01)))
        (img@104@01 r))
      (= r (Seq_index xs@11@01 i2@13@01)))
    (=
      ($FVF.lookup_f (as sm@105@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@57@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@105@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@57@01  $FVF<f>) r))
  :qid |qp.fvfValDef76|)))
(assert (and
  (forall ((j@98@01 Int)) (!
    (=>
      (and
        (<= 0 j@98@01)
        (and (< j@98@01 (Seq_length xs@11@01)) (= j@98@01 i2@13@01)))
      (and
        (=>
          (not (<= 0 j@98@01))
          (and
            (not (<= 0 j@98@01))
            (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
            (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@100@01  $FPM) r) $Perm.Write)
              :pattern ((inv@19@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@100@01  $FPM) (Seq_index xs@11@01 i1@12@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@100@01  $FPM) (Seq_index xs@11@01 i2@13@01))
              $Perm.Write)))
        (=>
          (<= 0 j@98@01)
          (and
            (<= 0 j@98@01)
            (not (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))
            (not (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@102@01  $FPM) r) $Perm.Write)
              :pattern ((inv@19@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@102@01  $FPM) (Seq_index xs@11@01 i1@12@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@102@01  $FPM) (Seq_index xs@11@01 i2@13@01))
              $Perm.Write)
            (=>
              (not (< j@98@01 (Seq_length xs@11@01)))
              (and
                (not (< j@98@01 (Seq_length xs@11@01)))
                (not
                  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
                (not
                  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
            (=>
              (< j@98@01 (Seq_length xs@11@01))
              (and
                (< j@98@01 (Seq_length xs@11@01))
                (not
                  (= (Seq_index xs@11@01 i2@13@01) (Seq_index xs@11@01 i1@12@01)))
                (not
                  (= (Seq_index xs@11@01 i1@12@01) (Seq_index xs@11@01 i2@13@01)))))
            (or
              (< j@98@01 (Seq_length xs@11@01))
              (not (< j@98@01 (Seq_length xs@11@01))))))
        (or (<= 0 j@98@01) (not (<= 0 j@98@01)))))
    :pattern ((Seq_index xs@11@01 j@98@01))
    :qid |f-aux|))
  (fun01qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@105@01  $FVF<f>)))) xs@11@01 i2@13@01)))
; [eval] old(fun01qp(xs, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@106@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@20@01 r)
      (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
    (=
      ($FVF.lookup_f (as sm@106@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@106@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef78|)))
(declare-const pm@107@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@107@01  $FPM) r)
    (ite
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@107@01  $FPM) r))
  :qid |qp.resPrmSumDef79|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@107@01  $FPM) r) $Perm.Write)
  :pattern ((inv@19@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun01qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@108@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |xs| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 40 | !(0 <= j@108@01) | live]
; [else-branch: 40 | 0 <= j@108@01 | live]
(push) ; 6
; [then-branch: 40 | !(0 <= j@108@01)]
(assert (not (<= 0 j@108@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 40 | 0 <= j@108@01]
(assert (<= 0 j@108@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |xs|
; [eval] |xs|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 41 | !(j@108@01 < |xs@11@01|) | live]
; [else-branch: 41 | j@108@01 < |xs@11@01| | live]
(push) ; 8
; [then-branch: 41 | !(j@108@01 < |xs@11@01|)]
(assert (not (< j@108@01 (Seq_length xs@11@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 41 | j@108@01 < |xs@11@01|]
(assert (< j@108@01 (Seq_length xs@11@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or (< j@108@01 (Seq_length xs@11@01)) (not (< j@108@01 (Seq_length xs@11@01)))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@108@01)
  (and
    (<= 0 j@108@01)
    (or
      (< j@108@01 (Seq_length xs@11@01))
      (not (< j@108@01 (Seq_length xs@11@01)))))))
(assert (or (<= 0 j@108@01) (not (<= 0 j@108@01))))
(assert (and
  (<= 0 j@108@01)
  (and (< j@108@01 (Seq_length xs@11@01)) (= j@108@01 i2@13@01))))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@108@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@109@01 ($Ref) Int)
(declare-fun img@110@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@108@01 Int)) (!
  (=>
    (and
      (<= 0 j@108@01)
      (and (< j@108@01 (Seq_length xs@11@01)) (= j@108@01 i2@13@01)))
    (and
      (=>
        (<= 0 j@108@01)
        (and
          (<= 0 j@108@01)
          (or
            (< j@108@01 (Seq_length xs@11@01))
            (not (< j@108@01 (Seq_length xs@11@01))))))
      (or (<= 0 j@108@01) (not (<= 0 j@108@01)))))
  :pattern ((Seq_index xs@11@01 j@108@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@108@01 Int) (j2@108@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@108@01)
        (and (< j1@108@01 (Seq_length xs@11@01)) (= j1@108@01 i2@13@01)))
      (and
        (<= 0 j2@108@01)
        (and (< j2@108@01 (Seq_length xs@11@01)) (= j2@108@01 i2@13@01)))
      (= (Seq_index xs@11@01 j1@108@01) (Seq_index xs@11@01 j2@108@01)))
    (= j1@108@01 j2@108@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@108@01 Int)) (!
  (=>
    (and
      (<= 0 j@108@01)
      (and (< j@108@01 (Seq_length xs@11@01)) (= j@108@01 i2@13@01)))
    (and
      (= (inv@109@01 (Seq_index xs@11@01 j@108@01)) j@108@01)
      (img@110@01 (Seq_index xs@11@01 j@108@01))))
  :pattern ((Seq_index xs@11@01 j@108@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@110@01 r)
      (and
        (<= 0 (inv@109@01 r))
        (and
          (< (inv@109@01 r) (Seq_length xs@11@01))
          (= (inv@109@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@109@01 r)) r))
  :pattern ((inv@109@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@109@01 r))
        (and
          (< (inv@109@01 r) (Seq_length xs@11@01))
          (= (inv@109@01 r) i2@13@01)))
      (img@110@01 r)
      (= r (Seq_index xs@11@01 (inv@109@01 r))))
    (>
      (ite
        (and
          (img@20@01 r)
          (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12805|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@111@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@111@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@109@01 r))
          (and
            (< (inv@109@01 r) (Seq_length xs@11@01))
            (= (inv@109@01 r) i2@13@01)))
        (img@110@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@109@01 r))
          (and
            (< (inv@109@01 r) (Seq_length xs@11@01))
            (= (inv@109@01 r) i2@13@01)))
        (img@110@01 r))
      (Set_in r ($FVF.domain_f (as sm@111@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@111@01  $FVF<f>))))
  :qid |qp.fvfDomDef81|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@109@01 r))
          (and
            (< (inv@109@01 r) (Seq_length xs@11@01))
            (= (inv@109@01 r) i2@13@01)))
        (img@110@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@111@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@111@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef80|)))
(assert (fun01qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@111@01  $FVF<f>)))) xs@11@01 i2@13@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@108@01 Int)) (!
  (=>
    (and
      (<= 0 j@108@01)
      (and (< j@108@01 (Seq_length xs@11@01)) (= j@108@01 i2@13@01)))
    (and
      (= (inv@109@01 (Seq_index xs@11@01 j@108@01)) j@108@01)
      (img@110@01 (Seq_index xs@11@01 j@108@01))))
  :pattern ((Seq_index xs@11@01 j@108@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@110@01 r)
      (and
        (<= 0 (inv@109@01 r))
        (and
          (< (inv@109@01 r) (Seq_length xs@11@01))
          (= (inv@109@01 r) i2@13@01))))
    (= (Seq_index xs@11@01 (inv@109@01 r)) r))
  :pattern ((inv@109@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@111@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@109@01 r))
          (and
            (< (inv@109@01 r) (Seq_length xs@11@01))
            (= (inv@109@01 r) i2@13@01)))
        (img@110@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@109@01 r))
          (and
            (< (inv@109@01 r) (Seq_length xs@11@01))
            (= (inv@109@01 r) i2@13@01)))
        (img@110@01 r))
      (Set_in r ($FVF.domain_f (as sm@111@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@111@01  $FVF<f>))))
  :qid |qp.fvfDomDef81|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@109@01 r))
          (and
            (< (inv@109@01 r) (Seq_length xs@11@01))
            (= (inv@109@01 r) i2@13@01)))
        (img@110@01 r))
      (and
        (img@20@01 r)
        (and (<= 0 (inv@19@01 r)) (< (inv@19@01 r) (Seq_length xs@11@01)))))
    (=
      ($FVF.lookup_f (as sm@111@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@111@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@15@01)))))))) r))
  :qid |qp.fvfValDef80|)))
(assert (and
  (forall ((j@108@01 Int)) (!
    (=>
      (and
        (<= 0 j@108@01)
        (and (< j@108@01 (Seq_length xs@11@01)) (= j@108@01 i2@13@01)))
      (and
        (=>
          (<= 0 j@108@01)
          (and
            (<= 0 j@108@01)
            (or
              (< j@108@01 (Seq_length xs@11@01))
              (not (< j@108@01 (Seq_length xs@11@01))))))
        (or (<= 0 j@108@01) (not (<= 0 j@108@01)))))
    :pattern ((Seq_index xs@11@01 j@108@01))
    :qid |f-aux|))
  (fun01qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@111@01  $FVF<f>)))) xs@11@01 i2@13@01)))
(push) ; 3
(assert (not (=
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@105@01  $FVF<f>)))) xs@11@01 i2@13@01)
  (fun01qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@111@01  $FVF<f>)))) xs@11@01 i2@13@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.05s
; (get-info :all-statistics)
(pop) ; 2
(pop) ; 1
; ---------- test03 ----------
(declare-const xs@112@01 Seq<$Ref>)
(declare-const i1@113@01 Int)
(declare-const i2@114@01 Int)
(declare-const x@115@01 $Ref)
(declare-const xs@116@01 Seq<$Ref>)
(declare-const i1@117@01 Int)
(declare-const i2@118@01 Int)
(declare-const x@119@01 $Ref)
(push) ; 1
(declare-const $t@120@01 $Snap)
(assert (= $t@120@01 ($Snap.combine ($Snap.first $t@120@01) ($Snap.second $t@120@01))))
(assert (= ($Snap.first $t@120@01) $Snap.unit))
; [eval] 0 <= i1
(assert (<= 0 i1@117@01))
(assert (=
  ($Snap.second $t@120@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@120@01))
    ($Snap.second ($Snap.second $t@120@01)))))
(assert (= ($Snap.first ($Snap.second $t@120@01)) $Snap.unit))
; [eval] i1 < |xs|
; [eval] |xs|
(assert (< i1@117@01 (Seq_length xs@116@01)))
(assert (=
  ($Snap.second ($Snap.second $t@120@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@120@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@120@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@120@01))) $Snap.unit))
; [eval] 0 <= i2
(assert (<= 0 i2@118@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@120@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@120@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@120@01))))
  $Snap.unit))
; [eval] i2 < |xs|
; [eval] |xs|
(assert (< i2@118@01 (Seq_length xs@116@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))
  $Snap.unit))
; [eval] i1 != i2
(assert (not (= i1@117@01 i2@118@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01))))))
  $Snap.unit))
; [eval] (forall j1: Int, j2: Int :: { (j1 in [0..|xs|)), (j2 in [0..|xs|)) } { (j1 in [0..|xs|)), xs[j2] } { (j2 in [0..|xs|)), xs[j1] } { xs[j1], xs[j2] } (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2) ==> xs[j1] != xs[j2])
(declare-const j1@121@01 Int)
(declare-const j2@122@01 Int)
(push) ; 2
; [eval] (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2) ==> xs[j1] != xs[j2]
; [eval] (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2)
; [eval] (j1 in [0..|xs|))
; [eval] [0..|xs|)
; [eval] |xs|
(push) ; 3
; [then-branch: 42 | !(j1@121@01 in [0..|xs@116@01|]) | live]
; [else-branch: 42 | j1@121@01 in [0..|xs@116@01|] | live]
(push) ; 4
; [then-branch: 42 | !(j1@121@01 in [0..|xs@116@01|])]
(assert (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 42 | j1@121@01 in [0..|xs@116@01|]]
(assert (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01))
; [eval] (j2 in [0..|xs|))
; [eval] [0..|xs|)
; [eval] |xs|
(push) ; 5
; [then-branch: 43 | !(j2@122@01 in [0..|xs@116@01|]) | live]
; [else-branch: 43 | j2@122@01 in [0..|xs@116@01|] | live]
(push) ; 6
; [then-branch: 43 | !(j2@122@01 in [0..|xs@116@01|])]
(assert (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 43 | j2@122@01 in [0..|xs@116@01|]]
(assert (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01))
; [eval] j1 != j2
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
  (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01))))))
(assert (or
  (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
  (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01))))
(push) ; 3
; [then-branch: 44 | j1@121@01 in [0..|xs@116@01|] && j2@122@01 in [0..|xs@116@01|] && j1@121@01 != j2@122@01 | live]
; [else-branch: 44 | !(j1@121@01 in [0..|xs@116@01|] && j2@122@01 in [0..|xs@116@01|] && j1@121@01 != j2@122@01) | live]
(push) ; 4
; [then-branch: 44 | j1@121@01 in [0..|xs@116@01|] && j2@122@01 in [0..|xs@116@01|] && j1@121@01 != j2@122@01]
(assert (and
  (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
    (not (= j1@121@01 j2@122@01)))))
; [eval] xs[j1] != xs[j2]
; [eval] xs[j1]
(push) ; 5
(assert (not (>= j1@121@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(assert (not (< j1@121@01 (Seq_length xs@116@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [eval] xs[j2]
(push) ; 5
(assert (not (>= j2@122@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(assert (not (< j2@122@01 (Seq_length xs@116@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 44 | !(j1@121@01 in [0..|xs@116@01|] && j2@122@01 in [0..|xs@116@01|] && j1@121@01 != j2@122@01)]
(assert (not
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
      (not (= j1@121@01 j2@122@01))))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=>
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
      (not (= j1@121@01 j2@122@01))))
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
    (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
    (not (= j1@121@01 j2@122@01)))))
; Joined path conditions
(assert (or
  (not
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
        (not (= j1@121@01 j2@122@01)))))
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
      (not (= j1@121@01 j2@122@01))))))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((j1@121@01 Int) (j2@122@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
        (not (= j1@121@01 j2@122@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
            (not (= j1@121@01 j2@122@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01) (Seq_contains
    (Seq_range 0 (Seq_length xs@116@01))
    j2@122@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@116@01)) j1@121@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@116@01))
    j2@122@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@75@12@75@106-aux|)))
(assert (forall ((j1@121@01 Int) (j2@122@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
        (not (= j1@121@01 j2@122@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
            (not (= j1@121@01 j2@122@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@116@01)) j1@121@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@116@01))
    j2@122@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@75@12@75@106-aux|)))
(assert (forall ((j1@121@01 Int) (j2@122@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
        (not (= j1@121@01 j2@122@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
            (not (= j1@121@01 j2@122@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01) (Seq_index
    xs@116@01
    j2@122@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@116@01)) j1@121@01) (Seq_index
    xs@116@01
    j2@122@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@75@12@75@106-aux|)))
(assert (forall ((j1@121@01 Int) (j2@122@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
        (not (= j1@121@01 j2@122@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
            (not (= j1@121@01 j2@122@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@116@01)) j1@121@01) (Seq_index
    xs@116@01
    j2@122@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@75@12@75@106-aux|)))
(assert (forall ((j1@121@01 Int) (j2@122@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
        (not (= j1@121@01 j2@122@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
            (not (= j1@121@01 j2@122@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01) (Seq_index
    xs@116@01
    j1@121@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@116@01)) j2@122@01) (Seq_index
    xs@116@01
    j1@121@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@75@12@75@106-aux|)))
(assert (forall ((j1@121@01 Int) (j2@122@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
        (not (= j1@121@01 j2@122@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
            (not (= j1@121@01 j2@122@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@116@01)) j2@122@01) (Seq_index
    xs@116@01
    j1@121@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@75@12@75@106-aux|)))
(assert (forall ((j1@121@01 Int) (j2@122@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
        (not (= j1@121@01 j2@122@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
            (not (= j1@121@01 j2@122@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
          (not (= j1@121@01 j2@122@01))))))
  :pattern ((Seq_index xs@116@01 j1@121@01) (Seq_index xs@116@01 j2@122@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@75@12@75@106-aux|)))
(assert (forall ((j1@121@01 Int) (j2@122@01 Int)) (!
  (=>
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01)
        (not (= j1@121@01 j2@122@01))))
    (not (= (Seq_index xs@116@01 j1@121@01) (Seq_index xs@116@01 j2@122@01))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01) (Seq_contains
    (Seq_range 0 (Seq_length xs@116@01))
    j2@122@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@116@01)) j1@121@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@116@01))
    j2@122@01))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j1@121@01) (Seq_index
    xs@116@01
    j2@122@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@116@01)) j1@121@01) (Seq_index
    xs@116@01
    j2@122@01))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@116@01)) j2@122@01) (Seq_index
    xs@116@01
    j1@121@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@116@01)) j2@122@01) (Seq_index
    xs@116@01
    j1@121@01))
  :pattern ((Seq_index xs@116@01 j1@121@01) (Seq_index xs@116@01 j2@122@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@75@12@75@106|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01))))))))))
(declare-const j@123@01 Int)
(push) ; 2
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 3
; [then-branch: 45 | !(0 <= j@123@01) | live]
; [else-branch: 45 | 0 <= j@123@01 | live]
(push) ; 4
; [then-branch: 45 | !(0 <= j@123@01)]
(assert (not (<= 0 j@123@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 45 | 0 <= j@123@01]
(assert (<= 0 j@123@01))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@123@01) (not (<= 0 j@123@01))))
(assert (and (<= 0 j@123@01) (< j@123@01 (Seq_length xs@116@01))))
; [eval] xs[j]
(push) ; 3
(assert (not (>= j@123@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(pop) ; 2
(declare-fun inv@124@01 ($Ref) Int)
(declare-fun img@125@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@123@01 Int)) (!
  (=>
    (and (<= 0 j@123@01) (< j@123@01 (Seq_length xs@116@01)))
    (or (<= 0 j@123@01) (not (<= 0 j@123@01))))
  :pattern ((Seq_index xs@116@01 j@123@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((j1@123@01 Int) (j2@123@01 Int)) (!
  (=>
    (and
      (and (<= 0 j1@123@01) (< j1@123@01 (Seq_length xs@116@01)))
      (and (<= 0 j2@123@01) (< j2@123@01 (Seq_length xs@116@01)))
      (= (Seq_index xs@116@01 j1@123@01) (Seq_index xs@116@01 j2@123@01)))
    (= j1@123@01 j2@123@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@123@01 Int)) (!
  (=>
    (and (<= 0 j@123@01) (< j@123@01 (Seq_length xs@116@01)))
    (and
      (= (inv@124@01 (Seq_index xs@116@01 j@123@01)) j@123@01)
      (img@125@01 (Seq_index xs@116@01 j@123@01))))
  :pattern ((Seq_index xs@116@01 j@123@01))
  :qid |quant-u-12807|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@125@01 r)
      (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
    (= (Seq_index xs@116@01 (inv@124@01 r)) r))
  :pattern ((inv@124@01 r))
  :qid |f-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((j@123@01 Int)) (!
  (=>
    (and (<= 0 j@123@01) (< j@123@01 (Seq_length xs@116@01)))
    (not (= (Seq_index xs@116@01 j@123@01) $Ref.null)))
  :pattern ((Seq_index xs@116@01 j@123@01))
  :qid |f-permImpliesNonNull|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))))))
(assert (not (= x@119@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01))))))))
  $Snap.unit))
; [eval] x.elems == xs
(assert (Seq_equal
  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))))
  xs@116@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; xs[i1].f := 0
; [eval] xs[i1]
(push) ; 3
(assert (not (>= i1@117@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@126@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@116@01 i1@117@01))
    ($Perm.min
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        $Perm.Write
        $Perm.No)
      (pTaken@126@01 r))
    $Perm.No)
  
  :qid |quant-u-12809|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@126@01 r) $Perm.No)
  
  :qid |quant-u-12810|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (= (- $Perm.Write (pTaken@126@01 r)) $Perm.No))
  
  :qid |quant-u-12811|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@127@01 $FVF<f>)
; Definitional axioms for singleton-FVF's value
(assert (= ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)) 0))
; [exec]
; assert fun02qp(xs, i2) == old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2) == old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@128@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 46 | !(0 <= j@128@01) | live]
; [else-branch: 46 | 0 <= j@128@01 | live]
(push) ; 6
; [then-branch: 46 | !(0 <= j@128@01)]
(assert (not (<= 0 j@128@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 46 | 0 <= j@128@01]
(assert (<= 0 j@128@01))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@128@01) (not (<= 0 j@128@01))))
(assert (and (<= 0 j@128@01) (< j@128@01 (Seq_length xs@116@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 47 | j@128@01 == i2@118@01 | live]
; [else-branch: 47 | j@128@01 != i2@118@01 | live]
(push) ; 6
; [then-branch: 47 | j@128@01 == i2@118@01]
(assert (= j@128@01 i2@118@01))
(pop) ; 6
(push) ; 6
; [else-branch: 47 | j@128@01 != i2@118@01]
(assert (not (= j@128@01 i2@118@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@128@01 i2@118@01)) (= j@128@01 i2@118@01)))
; [eval] xs[j]
(push) ; 5
(assert (not (>= j@128@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@129@01 ($Ref) Int)
(declare-fun img@130@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@128@01 Int)) (!
  (=>
    (and (<= 0 j@128@01) (< j@128@01 (Seq_length xs@116@01)))
    (and
      (or (<= 0 j@128@01) (not (<= 0 j@128@01)))
      (or (not (= j@128@01 i2@118@01)) (= j@128@01 i2@118@01))))
  :pattern ((Seq_index xs@116@01 j@128@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@128@01 Int)) (!
  (=>
    (and (<= 0 j@128@01) (< j@128@01 (Seq_length xs@116@01)))
    (or
      (= (ite (= j@128@01 i2@118@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@128@01 i2@118@01)))
  
  :qid |quant-u-12812|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@128@01 Int) (j2@128@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@128@01) (< j1@128@01 (Seq_length xs@116@01)))
        (= j1@128@01 i2@118@01))
      (and
        (and (<= 0 j2@128@01) (< j2@128@01 (Seq_length xs@116@01)))
        (= j2@128@01 i2@118@01))
      (= (Seq_index xs@116@01 j1@128@01) (Seq_index xs@116@01 j2@128@01)))
    (= j1@128@01 j2@128@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@128@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@128@01) (< j@128@01 (Seq_length xs@116@01)))
      (= j@128@01 i2@118@01))
    (and
      (= (inv@129@01 (Seq_index xs@116@01 j@128@01)) j@128@01)
      (img@130@01 (Seq_index xs@116@01 j@128@01))))
  :pattern ((Seq_index xs@116@01 j@128@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@130@01 r)
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (= (inv@129@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@129@01 r)) r))
  :pattern ((inv@129@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (img@130@01 r)
        (= r (Seq_index xs@116@01 (inv@129@01 r))))
      (> (ite (= (inv@129@01 r) i2@118@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- $Perm.Write (pTaken@126@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12813|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@131@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@131@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (= (inv@129@01 r) i2@118@01)
        (img@130@01 r)))
    (=>
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (= (inv@129@01 r) i2@118@01)
        (img@130@01 r))
      (Set_in r ($FVF.domain_f (as sm@131@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@131@01  $FVF<f>))))
  :qid |qp.fvfDomDef84|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (= (inv@129@01 r) i2@118@01)
        (img@130@01 r))
      (= r (Seq_index xs@116@01 i1@117@01)))
    (=
      ($FVF.lookup_f (as sm@131@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@131@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (= (inv@129@01 r) i2@118@01)
        (img@130@01 r))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (< $Perm.No (- $Perm.Write (pTaken@126@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@131@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@131@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef83|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@131@01  $FVF<f>)))) xs@116@01 i2@118@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@128@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@128@01) (< j@128@01 (Seq_length xs@116@01)))
      (= j@128@01 i2@118@01))
    (and
      (= (inv@129@01 (Seq_index xs@116@01 j@128@01)) j@128@01)
      (img@130@01 (Seq_index xs@116@01 j@128@01))))
  :pattern ((Seq_index xs@116@01 j@128@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@130@01 r)
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (= (inv@129@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@129@01 r)) r))
  :pattern ((inv@129@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@131@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (= (inv@129@01 r) i2@118@01)
        (img@130@01 r)))
    (=>
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (= (inv@129@01 r) i2@118@01)
        (img@130@01 r))
      (Set_in r ($FVF.domain_f (as sm@131@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@131@01  $FVF<f>))))
  :qid |qp.fvfDomDef84|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (= (inv@129@01 r) i2@118@01)
        (img@130@01 r))
      (= r (Seq_index xs@116@01 i1@117@01)))
    (=
      ($FVF.lookup_f (as sm@131@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@131@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@129@01 r)) (< (inv@129@01 r) (Seq_length xs@116@01)))
        (= (inv@129@01 r) i2@118@01)
        (img@130@01 r))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (< $Perm.No (- $Perm.Write (pTaken@126@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@131@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@131@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef83|)))
(assert (and
  (forall ((j@128@01 Int)) (!
    (=>
      (and (<= 0 j@128@01) (< j@128@01 (Seq_length xs@116@01)))
      (and
        (or (<= 0 j@128@01) (not (<= 0 j@128@01)))
        (or (not (= j@128@01 i2@118@01)) (= j@128@01 i2@118@01))))
    :pattern ((Seq_index xs@116@01 j@128@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@131@01  $FVF<f>)))) xs@116@01 i2@118@01)))
; [eval] old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@132@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 48 | !(0 <= j@132@01) | live]
; [else-branch: 48 | 0 <= j@132@01 | live]
(push) ; 6
; [then-branch: 48 | !(0 <= j@132@01)]
(assert (not (<= 0 j@132@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 48 | 0 <= j@132@01]
(assert (<= 0 j@132@01))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@132@01) (not (<= 0 j@132@01))))
(assert (and (<= 0 j@132@01) (< j@132@01 (Seq_length xs@116@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 49 | j@132@01 == i2@118@01 | live]
; [else-branch: 49 | j@132@01 != i2@118@01 | live]
(push) ; 6
; [then-branch: 49 | j@132@01 == i2@118@01]
(assert (= j@132@01 i2@118@01))
(pop) ; 6
(push) ; 6
; [else-branch: 49 | j@132@01 != i2@118@01]
(assert (not (= j@132@01 i2@118@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@132@01 i2@118@01)) (= j@132@01 i2@118@01)))
; [eval] xs[j]
(push) ; 5
(assert (not (>= j@132@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@133@01 ($Ref) Int)
(declare-fun img@134@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@132@01 Int)) (!
  (=>
    (and (<= 0 j@132@01) (< j@132@01 (Seq_length xs@116@01)))
    (and
      (or (<= 0 j@132@01) (not (<= 0 j@132@01)))
      (or (not (= j@132@01 i2@118@01)) (= j@132@01 i2@118@01))))
  :pattern ((Seq_index xs@116@01 j@132@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@132@01 Int)) (!
  (=>
    (and (<= 0 j@132@01) (< j@132@01 (Seq_length xs@116@01)))
    (or
      (= (ite (= j@132@01 i2@118@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@132@01 i2@118@01)))
  
  :qid |quant-u-12814|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@132@01 Int) (j2@132@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@132@01) (< j1@132@01 (Seq_length xs@116@01)))
        (= j1@132@01 i2@118@01))
      (and
        (and (<= 0 j2@132@01) (< j2@132@01 (Seq_length xs@116@01)))
        (= j2@132@01 i2@118@01))
      (= (Seq_index xs@116@01 j1@132@01) (Seq_index xs@116@01 j2@132@01)))
    (= j1@132@01 j2@132@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@132@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@132@01) (< j@132@01 (Seq_length xs@116@01)))
      (= j@132@01 i2@118@01))
    (and
      (= (inv@133@01 (Seq_index xs@116@01 j@132@01)) j@132@01)
      (img@134@01 (Seq_index xs@116@01 j@132@01))))
  :pattern ((Seq_index xs@116@01 j@132@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@134@01 r)
      (and
        (and (<= 0 (inv@133@01 r)) (< (inv@133@01 r) (Seq_length xs@116@01)))
        (= (inv@133@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@133@01 r)) r))
  :pattern ((inv@133@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@133@01 r)) (< (inv@133@01 r) (Seq_length xs@116@01)))
        (img@134@01 r)
        (= r (Seq_index xs@116@01 (inv@133@01 r))))
      (> (ite (= (inv@133@01 r) i2@118@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12815|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@135@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@135@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@133@01 r)) (< (inv@133@01 r) (Seq_length xs@116@01)))
        (= (inv@133@01 r) i2@118@01)
        (img@134@01 r)))
    (=>
      (and
        (and (<= 0 (inv@133@01 r)) (< (inv@133@01 r) (Seq_length xs@116@01)))
        (= (inv@133@01 r) i2@118@01)
        (img@134@01 r))
      (Set_in r ($FVF.domain_f (as sm@135@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@135@01  $FVF<f>))))
  :qid |qp.fvfDomDef86|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@133@01 r)) (< (inv@133@01 r) (Seq_length xs@116@01)))
        (= (inv@133@01 r) i2@118@01)
        (img@134@01 r))
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01)))))
    (=
      ($FVF.lookup_f (as sm@135@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@135@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef85|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@135@01  $FVF<f>)))) xs@116@01 i2@118@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@132@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@132@01) (< j@132@01 (Seq_length xs@116@01)))
      (= j@132@01 i2@118@01))
    (and
      (= (inv@133@01 (Seq_index xs@116@01 j@132@01)) j@132@01)
      (img@134@01 (Seq_index xs@116@01 j@132@01))))
  :pattern ((Seq_index xs@116@01 j@132@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@134@01 r)
      (and
        (and (<= 0 (inv@133@01 r)) (< (inv@133@01 r) (Seq_length xs@116@01)))
        (= (inv@133@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@133@01 r)) r))
  :pattern ((inv@133@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@135@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@133@01 r)) (< (inv@133@01 r) (Seq_length xs@116@01)))
        (= (inv@133@01 r) i2@118@01)
        (img@134@01 r)))
    (=>
      (and
        (and (<= 0 (inv@133@01 r)) (< (inv@133@01 r) (Seq_length xs@116@01)))
        (= (inv@133@01 r) i2@118@01)
        (img@134@01 r))
      (Set_in r ($FVF.domain_f (as sm@135@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@135@01  $FVF<f>))))
  :qid |qp.fvfDomDef86|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@133@01 r)) (< (inv@133@01 r) (Seq_length xs@116@01)))
        (= (inv@133@01 r) i2@118@01)
        (img@134@01 r))
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01)))))
    (=
      ($FVF.lookup_f (as sm@135@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@135@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef85|)))
(assert (and
  (forall ((j@132@01 Int)) (!
    (=>
      (and (<= 0 j@132@01) (< j@132@01 (Seq_length xs@116@01)))
      (and
        (or (<= 0 j@132@01) (not (<= 0 j@132@01)))
        (or (not (= j@132@01 i2@118@01)) (= j@132@01 i2@118@01))))
    :pattern ((Seq_index xs@116@01 j@132@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@135@01  $FVF<f>)))) xs@116@01 i2@118@01)))
(push) ; 3
(assert (not (=
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@131@01  $FVF<f>)))) xs@116@01 i2@118@01)
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@135@01  $FVF<f>)))) xs@116@01 i2@118@01))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (=
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@131@01  $FVF<f>)))) xs@116@01 i2@118@01)
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@135@01  $FVF<f>)))) xs@116@01 i2@118@01)))
; [exec]
; xs[i2].f := 0
; [eval] xs[i2]
(push) ; 3
(assert (not (>= i2@118@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(push) ; 3
(set-option :timeout 10)
(assert (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@136@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@116@01 i2@118@01))
    ($Perm.min
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (- $Perm.Write (pTaken@126@01 r))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@137@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@116@01 i2@118@01))
    ($Perm.min
      (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@136@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (- $Perm.Write (pTaken@126@01 r))
        $Perm.No)
      (pTaken@136@01 r))
    $Perm.No)
  
  :qid |quant-u-12817|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@136@01 r) $Perm.No)
  
  :qid |quant-u-12818|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (= (- $Perm.Write (pTaken@136@01 r)) $Perm.No))
  
  :qid |quant-u-12819|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@138@01 $FVF<f>)
; Definitional axioms for singleton-FVF's value
(assert (= ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)) 0))
; [exec]
; assert fun02qp(xs, i2) == old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2) == old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@139@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 50 | !(0 <= j@139@01) | live]
; [else-branch: 50 | 0 <= j@139@01 | live]
(push) ; 6
; [then-branch: 50 | !(0 <= j@139@01)]
(assert (not (<= 0 j@139@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 50 | 0 <= j@139@01]
(assert (<= 0 j@139@01))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@139@01) (not (<= 0 j@139@01))))
(assert (and (<= 0 j@139@01) (< j@139@01 (Seq_length xs@116@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 51 | j@139@01 == i2@118@01 | live]
; [else-branch: 51 | j@139@01 != i2@118@01 | live]
(push) ; 6
; [then-branch: 51 | j@139@01 == i2@118@01]
(assert (= j@139@01 i2@118@01))
(pop) ; 6
(push) ; 6
; [else-branch: 51 | j@139@01 != i2@118@01]
(assert (not (= j@139@01 i2@118@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@139@01 i2@118@01)) (= j@139@01 i2@118@01)))
; [eval] xs[j]
(push) ; 5
(assert (not (>= j@139@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@140@01 ($Ref) Int)
(declare-fun img@141@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@139@01 Int)) (!
  (=>
    (and (<= 0 j@139@01) (< j@139@01 (Seq_length xs@116@01)))
    (and
      (or (<= 0 j@139@01) (not (<= 0 j@139@01)))
      (or (not (= j@139@01 i2@118@01)) (= j@139@01 i2@118@01))))
  :pattern ((Seq_index xs@116@01 j@139@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@139@01 Int)) (!
  (=>
    (and (<= 0 j@139@01) (< j@139@01 (Seq_length xs@116@01)))
    (or
      (= (ite (= j@139@01 i2@118@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@139@01 i2@118@01)))
  
  :qid |quant-u-12820|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@139@01 Int) (j2@139@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@139@01) (< j1@139@01 (Seq_length xs@116@01)))
        (= j1@139@01 i2@118@01))
      (and
        (and (<= 0 j2@139@01) (< j2@139@01 (Seq_length xs@116@01)))
        (= j2@139@01 i2@118@01))
      (= (Seq_index xs@116@01 j1@139@01) (Seq_index xs@116@01 j2@139@01)))
    (= j1@139@01 j2@139@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@139@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@139@01) (< j@139@01 (Seq_length xs@116@01)))
      (= j@139@01 i2@118@01))
    (and
      (= (inv@140@01 (Seq_index xs@116@01 j@139@01)) j@139@01)
      (img@141@01 (Seq_index xs@116@01 j@139@01))))
  :pattern ((Seq_index xs@116@01 j@139@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@141@01 r)
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@140@01 r)) r))
  :pattern ((inv@140@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (img@141@01 r)
        (= r (Seq_index xs@116@01 (inv@140@01 r))))
      (> (ite (= (inv@140@01 r) i2@118@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (+
          (ite
            (and
              (img@125@01 r)
              (and
                (<= 0 (inv@124@01 r))
                (< (inv@124@01 r) (Seq_length xs@116@01))))
            (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12821|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@142@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@142@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)
        (img@141@01 r)))
    (=>
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)
        (img@141@01 r))
      (Set_in r ($FVF.domain_f (as sm@142@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@142@01  $FVF<f>))))
  :qid |qp.fvfDomDef90|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)
        (img@141@01 r))
      (= r (Seq_index xs@116@01 i2@118@01)))
    (=
      ($FVF.lookup_f (as sm@142@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@142@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)
        (img@141@01 r))
      (= r (Seq_index xs@116@01 i1@117@01)))
    (=
      ($FVF.lookup_f (as sm@142@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@142@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)
        (img@141@01 r))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@142@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@142@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@142@01  $FVF<f>)))) xs@116@01 i2@118@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@139@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@139@01) (< j@139@01 (Seq_length xs@116@01)))
      (= j@139@01 i2@118@01))
    (and
      (= (inv@140@01 (Seq_index xs@116@01 j@139@01)) j@139@01)
      (img@141@01 (Seq_index xs@116@01 j@139@01))))
  :pattern ((Seq_index xs@116@01 j@139@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@141@01 r)
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@140@01 r)) r))
  :pattern ((inv@140@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@142@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)
        (img@141@01 r)))
    (=>
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)
        (img@141@01 r))
      (Set_in r ($FVF.domain_f (as sm@142@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@142@01  $FVF<f>))))
  :qid |qp.fvfDomDef90|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)
        (img@141@01 r))
      (= r (Seq_index xs@116@01 i2@118@01)))
    (=
      ($FVF.lookup_f (as sm@142@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@142@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)
        (img@141@01 r))
      (= r (Seq_index xs@116@01 i1@117@01)))
    (=
      ($FVF.lookup_f (as sm@142@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@142@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@140@01 r)) (< (inv@140@01 r) (Seq_length xs@116@01)))
        (= (inv@140@01 r) i2@118@01)
        (img@141@01 r))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@142@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@142@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (and
  (forall ((j@139@01 Int)) (!
    (=>
      (and (<= 0 j@139@01) (< j@139@01 (Seq_length xs@116@01)))
      (and
        (or (<= 0 j@139@01) (not (<= 0 j@139@01)))
        (or (not (= j@139@01 i2@118@01)) (= j@139@01 i2@118@01))))
    :pattern ((Seq_index xs@116@01 j@139@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@142@01  $FVF<f>)))) xs@116@01 i2@118@01)))
; [eval] old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@143@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 52 | !(0 <= j@143@01) | live]
; [else-branch: 52 | 0 <= j@143@01 | live]
(push) ; 6
; [then-branch: 52 | !(0 <= j@143@01)]
(assert (not (<= 0 j@143@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 52 | 0 <= j@143@01]
(assert (<= 0 j@143@01))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@143@01) (not (<= 0 j@143@01))))
(assert (and (<= 0 j@143@01) (< j@143@01 (Seq_length xs@116@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 53 | j@143@01 == i2@118@01 | live]
; [else-branch: 53 | j@143@01 != i2@118@01 | live]
(push) ; 6
; [then-branch: 53 | j@143@01 == i2@118@01]
(assert (= j@143@01 i2@118@01))
(pop) ; 6
(push) ; 6
; [else-branch: 53 | j@143@01 != i2@118@01]
(assert (not (= j@143@01 i2@118@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@143@01 i2@118@01)) (= j@143@01 i2@118@01)))
; [eval] xs[j]
(push) ; 5
(assert (not (>= j@143@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@144@01 ($Ref) Int)
(declare-fun img@145@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@143@01 Int)) (!
  (=>
    (and (<= 0 j@143@01) (< j@143@01 (Seq_length xs@116@01)))
    (and
      (or (<= 0 j@143@01) (not (<= 0 j@143@01)))
      (or (not (= j@143@01 i2@118@01)) (= j@143@01 i2@118@01))))
  :pattern ((Seq_index xs@116@01 j@143@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@143@01 Int)) (!
  (=>
    (and (<= 0 j@143@01) (< j@143@01 (Seq_length xs@116@01)))
    (or
      (= (ite (= j@143@01 i2@118@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@143@01 i2@118@01)))
  
  :qid |quant-u-12822|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@143@01 Int) (j2@143@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@143@01) (< j1@143@01 (Seq_length xs@116@01)))
        (= j1@143@01 i2@118@01))
      (and
        (and (<= 0 j2@143@01) (< j2@143@01 (Seq_length xs@116@01)))
        (= j2@143@01 i2@118@01))
      (= (Seq_index xs@116@01 j1@143@01) (Seq_index xs@116@01 j2@143@01)))
    (= j1@143@01 j2@143@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@143@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@143@01) (< j@143@01 (Seq_length xs@116@01)))
      (= j@143@01 i2@118@01))
    (and
      (= (inv@144@01 (Seq_index xs@116@01 j@143@01)) j@143@01)
      (img@145@01 (Seq_index xs@116@01 j@143@01))))
  :pattern ((Seq_index xs@116@01 j@143@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@145@01 r)
      (and
        (and (<= 0 (inv@144@01 r)) (< (inv@144@01 r) (Seq_length xs@116@01)))
        (= (inv@144@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@144@01 r)) r))
  :pattern ((inv@144@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@144@01 r)) (< (inv@144@01 r) (Seq_length xs@116@01)))
        (img@145@01 r)
        (= r (Seq_index xs@116@01 (inv@144@01 r))))
      (> (ite (= (inv@144@01 r) i2@118@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12823|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@146@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@146@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@144@01 r)) (< (inv@144@01 r) (Seq_length xs@116@01)))
        (= (inv@144@01 r) i2@118@01)
        (img@145@01 r)))
    (=>
      (and
        (and (<= 0 (inv@144@01 r)) (< (inv@144@01 r) (Seq_length xs@116@01)))
        (= (inv@144@01 r) i2@118@01)
        (img@145@01 r))
      (Set_in r ($FVF.domain_f (as sm@146@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@146@01  $FVF<f>))))
  :qid |qp.fvfDomDef92|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@144@01 r)) (< (inv@144@01 r) (Seq_length xs@116@01)))
        (= (inv@144@01 r) i2@118@01)
        (img@145@01 r))
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01)))))
    (=
      ($FVF.lookup_f (as sm@146@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@146@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef91|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@146@01  $FVF<f>)))) xs@116@01 i2@118@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@143@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@143@01) (< j@143@01 (Seq_length xs@116@01)))
      (= j@143@01 i2@118@01))
    (and
      (= (inv@144@01 (Seq_index xs@116@01 j@143@01)) j@143@01)
      (img@145@01 (Seq_index xs@116@01 j@143@01))))
  :pattern ((Seq_index xs@116@01 j@143@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@145@01 r)
      (and
        (and (<= 0 (inv@144@01 r)) (< (inv@144@01 r) (Seq_length xs@116@01)))
        (= (inv@144@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@144@01 r)) r))
  :pattern ((inv@144@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@146@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@144@01 r)) (< (inv@144@01 r) (Seq_length xs@116@01)))
        (= (inv@144@01 r) i2@118@01)
        (img@145@01 r)))
    (=>
      (and
        (and (<= 0 (inv@144@01 r)) (< (inv@144@01 r) (Seq_length xs@116@01)))
        (= (inv@144@01 r) i2@118@01)
        (img@145@01 r))
      (Set_in r ($FVF.domain_f (as sm@146@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@146@01  $FVF<f>))))
  :qid |qp.fvfDomDef92|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@144@01 r)) (< (inv@144@01 r) (Seq_length xs@116@01)))
        (= (inv@144@01 r) i2@118@01)
        (img@145@01 r))
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01)))))
    (=
      ($FVF.lookup_f (as sm@146@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@146@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef91|)))
(assert (and
  (forall ((j@143@01 Int)) (!
    (=>
      (and (<= 0 j@143@01) (< j@143@01 (Seq_length xs@116@01)))
      (and
        (or (<= 0 j@143@01) (not (<= 0 j@143@01)))
        (or (not (= j@143@01 i2@118@01)) (= j@143@01 i2@118@01))))
    :pattern ((Seq_index xs@116@01 j@143@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@146@01  $FVF<f>)))) xs@116@01 i2@118@01)))
(push) ; 3
(assert (not (=
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@142@01  $FVF<f>)))) xs@116@01 i2@118@01)
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@146@01  $FVF<f>)))) xs@116@01 i2@118@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
(declare-const sm@147@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@147@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@147@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@147@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@147@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@147@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@147@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef95|)))
(declare-const pm@148@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@148@01  $FPM) r)
    (+
      (+
        (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
        $Perm.No)))
  :pattern (($FVF.perm_f (as pm@148@01  $FPM) r))
  :qid |qp.resPrmSumDef96|)))
(assert (<=
  ($FVF.perm_f (as pm@148@01  $FPM) (Seq_index xs@116@01 i2@118@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@148@01  $FPM) (Seq_index xs@116@01 i1@117@01))
  $Perm.Write))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@148@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun02qp(xs, i2) == old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@149@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 54 | !(0 <= j@149@01) | live]
; [else-branch: 54 | 0 <= j@149@01 | live]
(push) ; 6
; [then-branch: 54 | !(0 <= j@149@01)]
(assert (not (<= 0 j@149@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(declare-const sm@150@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef99|)))
(declare-const pm@151@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@151@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@151@01  $FPM) r))
  :qid |qp.resPrmSumDef100|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@151@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@151@01  $FPM) (Seq_index xs@116@01 i1@117@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@151@01  $FPM) (Seq_index xs@116@01 i2@118@01))
  $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 54 | 0 <= j@149@01]
(assert (<= 0 j@149@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(declare-const sm@152@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef103|)))
(declare-const pm@153@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@153@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@153@01  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
  $Perm.Write))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef99|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@151@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@151@01  $FPM) r))
  :qid |qp.resPrmSumDef100|)))
(assert (=>
  (not (<= 0 j@149@01))
  (and
    (not (<= 0 j@149@01))
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@151@01  $FPM) r) $Perm.Write)
      :pattern ((inv@124@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@151@01  $FPM) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@151@01  $FPM) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@153@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@153@01  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (=>
  (<= 0 j@149@01)
  (and
    (<= 0 j@149@01)
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
      :pattern ((inv@124@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write))))
(assert (or (<= 0 j@149@01) (not (<= 0 j@149@01))))
(assert (and (<= 0 j@149@01) (< j@149@01 (Seq_length xs@116@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 55 | j@149@01 == i2@118@01 | live]
; [else-branch: 55 | j@149@01 != i2@118@01 | live]
(push) ; 6
; [then-branch: 55 | j@149@01 == i2@118@01]
(assert (= j@149@01 i2@118@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
  $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 55 | j@149@01 != i2@118@01]
(assert (not (= j@149@01 i2@118@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
  $Perm.Write))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (= j@149@01 i2@118@01)
  (and
    (= j@149@01 i2@118@01)
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
      :pattern ((inv@124@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write))))
; Joined path conditions
(assert (=>
  (not (= j@149@01 i2@118@01))
  (and
    (not (= j@149@01 i2@118@01))
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
      :pattern ((inv@124@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write))))
(assert (or (not (= j@149@01 i2@118@01)) (= j@149@01 i2@118@01)))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@149@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@154@01 ($Ref) Int)
(declare-fun img@155@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef99|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@151@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@151@01  $FPM) r))
  :qid |qp.resPrmSumDef100|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@153@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@153@01  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
; Nested auxiliary terms: non-globals
(assert (forall ((j@149@01 Int)) (!
  (=>
    (and (<= 0 j@149@01) (< j@149@01 (Seq_length xs@116@01)))
    (and
      (=>
        (not (<= 0 j@149@01))
        (and
          (not (<= 0 j@149@01))
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@151@01  $FPM) r) $Perm.Write)
            :pattern ((inv@124@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@151@01  $FPM) (Seq_index xs@116@01 i1@117@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@151@01  $FPM) (Seq_index xs@116@01 i2@118@01))
            $Perm.Write)))
      (=>
        (<= 0 j@149@01)
        (and
          (<= 0 j@149@01)
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
            :pattern ((inv@124@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
            $Perm.Write)))
      (or (<= 0 j@149@01) (not (<= 0 j@149@01)))
      (=>
        (= j@149@01 i2@118@01)
        (and
          (= j@149@01 i2@118@01)
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
            :pattern ((inv@124@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
            $Perm.Write)))
      (=>
        (not (= j@149@01 i2@118@01))
        (and
          (not (= j@149@01 i2@118@01))
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
            :pattern ((inv@124@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
            $Perm.Write)))
      (or (not (= j@149@01 i2@118@01)) (= j@149@01 i2@118@01))))
  :pattern ((Seq_index xs@116@01 j@149@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@149@01 Int)) (!
  (=>
    (and (<= 0 j@149@01) (< j@149@01 (Seq_length xs@116@01)))
    (or
      (= (ite (= j@149@01 i2@118@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@149@01 i2@118@01)))
  
  :qid |quant-u-12824|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@149@01 Int) (j2@149@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@149@01) (< j1@149@01 (Seq_length xs@116@01)))
        (= j1@149@01 i2@118@01))
      (and
        (and (<= 0 j2@149@01) (< j2@149@01 (Seq_length xs@116@01)))
        (= j2@149@01 i2@118@01))
      (= (Seq_index xs@116@01 j1@149@01) (Seq_index xs@116@01 j2@149@01)))
    (= j1@149@01 j2@149@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@149@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@149@01) (< j@149@01 (Seq_length xs@116@01)))
      (= j@149@01 i2@118@01))
    (and
      (= (inv@154@01 (Seq_index xs@116@01 j@149@01)) j@149@01)
      (img@155@01 (Seq_index xs@116@01 j@149@01))))
  :pattern ((Seq_index xs@116@01 j@149@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@155@01 r)
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@154@01 r)) r))
  :pattern ((inv@154@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (img@155@01 r)
        (= r (Seq_index xs@116@01 (inv@154@01 r))))
      (> (ite (= (inv@154@01 r) i2@118@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (+
          (ite
            (and
              (img@125@01 r)
              (and
                (<= 0 (inv@124@01 r))
                (< (inv@124@01 r) (Seq_length xs@116@01))))
            (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12825|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@156@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@156@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)
        (img@155@01 r)))
    (=>
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)
        (img@155@01 r))
      (Set_in r ($FVF.domain_f (as sm@156@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@156@01  $FVF<f>))))
  :qid |qp.fvfDomDef108|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)
        (img@155@01 r))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@156@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@156@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef105|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)
        (img@155@01 r))
      (= r (Seq_index xs@116@01 i1@117@01)))
    (=
      ($FVF.lookup_f (as sm@156@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@156@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)
        (img@155@01 r))
      (= r (Seq_index xs@116@01 i2@118@01)))
    (=
      ($FVF.lookup_f (as sm@156@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@156@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef107|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@156@01  $FVF<f>)))) xs@116@01 i2@118@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@150@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@150@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef99|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@151@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@151@01  $FPM) r))
  :qid |qp.resPrmSumDef100|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@152@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@152@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef103|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@153@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@153@01  $FPM) r))
  :qid |qp.resPrmSumDef104|)))
(assert (forall ((j@149@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@149@01) (< j@149@01 (Seq_length xs@116@01)))
      (= j@149@01 i2@118@01))
    (and
      (= (inv@154@01 (Seq_index xs@116@01 j@149@01)) j@149@01)
      (img@155@01 (Seq_index xs@116@01 j@149@01))))
  :pattern ((Seq_index xs@116@01 j@149@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@155@01 r)
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@154@01 r)) r))
  :pattern ((inv@154@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@156@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)
        (img@155@01 r)))
    (=>
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)
        (img@155@01 r))
      (Set_in r ($FVF.domain_f (as sm@156@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@156@01  $FVF<f>))))
  :qid |qp.fvfDomDef108|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)
        (img@155@01 r))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@156@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@156@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef105|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)
        (img@155@01 r))
      (= r (Seq_index xs@116@01 i1@117@01)))
    (=
      ($FVF.lookup_f (as sm@156@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@156@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@154@01 r)) (< (inv@154@01 r) (Seq_length xs@116@01)))
        (= (inv@154@01 r) i2@118@01)
        (img@155@01 r))
      (= r (Seq_index xs@116@01 i2@118@01)))
    (=
      ($FVF.lookup_f (as sm@156@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@156@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef107|)))
(assert (and
  (forall ((j@149@01 Int)) (!
    (=>
      (and (<= 0 j@149@01) (< j@149@01 (Seq_length xs@116@01)))
      (and
        (=>
          (not (<= 0 j@149@01))
          (and
            (not (<= 0 j@149@01))
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@151@01  $FPM) r) $Perm.Write)
              :pattern ((inv@124@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@151@01  $FPM) (Seq_index xs@116@01 i1@117@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@151@01  $FPM) (Seq_index xs@116@01 i2@118@01))
              $Perm.Write)))
        (=>
          (<= 0 j@149@01)
          (and
            (<= 0 j@149@01)
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
              :pattern ((inv@124@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
              $Perm.Write)))
        (or (<= 0 j@149@01) (not (<= 0 j@149@01)))
        (=>
          (= j@149@01 i2@118@01)
          (and
            (= j@149@01 i2@118@01)
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
              :pattern ((inv@124@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
              $Perm.Write)))
        (=>
          (not (= j@149@01 i2@118@01))
          (and
            (not (= j@149@01 i2@118@01))
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@153@01  $FPM) r) $Perm.Write)
              :pattern ((inv@124@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i1@117@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@153@01  $FPM) (Seq_index xs@116@01 i2@118@01))
              $Perm.Write)))
        (or (not (= j@149@01 i2@118@01)) (= j@149@01 i2@118@01))))
    :pattern ((Seq_index xs@116@01 j@149@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@156@01  $FVF<f>)))) xs@116@01 i2@118@01)))
; [eval] old(fun02qp(xs, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@157@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@125@01 r)
      (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
    (=
      ($FVF.lookup_f (as sm@157@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@157@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef109|)))
(declare-const pm@158@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@158@01  $FPM) r)
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@158@01  $FPM) r))
  :qid |qp.resPrmSumDef110|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@158@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun02qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@159@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 56 | !(0 <= j@159@01) | live]
; [else-branch: 56 | 0 <= j@159@01 | live]
(push) ; 6
; [then-branch: 56 | !(0 <= j@159@01)]
(assert (not (<= 0 j@159@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 56 | 0 <= j@159@01]
(assert (<= 0 j@159@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@159@01) (not (<= 0 j@159@01))))
(assert (and (<= 0 j@159@01) (< j@159@01 (Seq_length xs@116@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 57 | j@159@01 == i2@118@01 | live]
; [else-branch: 57 | j@159@01 != i2@118@01 | live]
(push) ; 6
; [then-branch: 57 | j@159@01 == i2@118@01]
(assert (= j@159@01 i2@118@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 57 | j@159@01 != i2@118@01]
(assert (not (= j@159@01 i2@118@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@159@01 i2@118@01)) (= j@159@01 i2@118@01)))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@159@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@160@01 ($Ref) Int)
(declare-fun img@161@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@159@01 Int)) (!
  (=>
    (and (<= 0 j@159@01) (< j@159@01 (Seq_length xs@116@01)))
    (and
      (or (<= 0 j@159@01) (not (<= 0 j@159@01)))
      (or (not (= j@159@01 i2@118@01)) (= j@159@01 i2@118@01))))
  :pattern ((Seq_index xs@116@01 j@159@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@159@01 Int)) (!
  (=>
    (and (<= 0 j@159@01) (< j@159@01 (Seq_length xs@116@01)))
    (or
      (= (ite (= j@159@01 i2@118@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@159@01 i2@118@01)))
  
  :qid |quant-u-12826|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@159@01 Int) (j2@159@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@159@01) (< j1@159@01 (Seq_length xs@116@01)))
        (= j1@159@01 i2@118@01))
      (and
        (and (<= 0 j2@159@01) (< j2@159@01 (Seq_length xs@116@01)))
        (= j2@159@01 i2@118@01))
      (= (Seq_index xs@116@01 j1@159@01) (Seq_index xs@116@01 j2@159@01)))
    (= j1@159@01 j2@159@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@159@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@159@01) (< j@159@01 (Seq_length xs@116@01)))
      (= j@159@01 i2@118@01))
    (and
      (= (inv@160@01 (Seq_index xs@116@01 j@159@01)) j@159@01)
      (img@161@01 (Seq_index xs@116@01 j@159@01))))
  :pattern ((Seq_index xs@116@01 j@159@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@161@01 r)
      (and
        (and (<= 0 (inv@160@01 r)) (< (inv@160@01 r) (Seq_length xs@116@01)))
        (= (inv@160@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@160@01 r)) r))
  :pattern ((inv@160@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@160@01 r)) (< (inv@160@01 r) (Seq_length xs@116@01)))
        (img@161@01 r)
        (= r (Seq_index xs@116@01 (inv@160@01 r))))
      (> (ite (= (inv@160@01 r) i2@118@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12827|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@162@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@162@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@160@01 r)) (< (inv@160@01 r) (Seq_length xs@116@01)))
        (= (inv@160@01 r) i2@118@01)
        (img@161@01 r)))
    (=>
      (and
        (and (<= 0 (inv@160@01 r)) (< (inv@160@01 r) (Seq_length xs@116@01)))
        (= (inv@160@01 r) i2@118@01)
        (img@161@01 r))
      (Set_in r ($FVF.domain_f (as sm@162@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@162@01  $FVF<f>))))
  :qid |qp.fvfDomDef112|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@160@01 r)) (< (inv@160@01 r) (Seq_length xs@116@01)))
        (= (inv@160@01 r) i2@118@01)
        (img@161@01 r))
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01)))))
    (=
      ($FVF.lookup_f (as sm@162@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@162@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef111|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@162@01  $FVF<f>)))) xs@116@01 i2@118@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@159@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@159@01) (< j@159@01 (Seq_length xs@116@01)))
      (= j@159@01 i2@118@01))
    (and
      (= (inv@160@01 (Seq_index xs@116@01 j@159@01)) j@159@01)
      (img@161@01 (Seq_index xs@116@01 j@159@01))))
  :pattern ((Seq_index xs@116@01 j@159@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@161@01 r)
      (and
        (and (<= 0 (inv@160@01 r)) (< (inv@160@01 r) (Seq_length xs@116@01)))
        (= (inv@160@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@160@01 r)) r))
  :pattern ((inv@160@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@162@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@160@01 r)) (< (inv@160@01 r) (Seq_length xs@116@01)))
        (= (inv@160@01 r) i2@118@01)
        (img@161@01 r)))
    (=>
      (and
        (and (<= 0 (inv@160@01 r)) (< (inv@160@01 r) (Seq_length xs@116@01)))
        (= (inv@160@01 r) i2@118@01)
        (img@161@01 r))
      (Set_in r ($FVF.domain_f (as sm@162@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@162@01  $FVF<f>))))
  :qid |qp.fvfDomDef112|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@160@01 r)) (< (inv@160@01 r) (Seq_length xs@116@01)))
        (= (inv@160@01 r) i2@118@01)
        (img@161@01 r))
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01)))))
    (=
      ($FVF.lookup_f (as sm@162@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@162@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef111|)))
(assert (and
  (forall ((j@159@01 Int)) (!
    (=>
      (and (<= 0 j@159@01) (< j@159@01 (Seq_length xs@116@01)))
      (and
        (or (<= 0 j@159@01) (not (<= 0 j@159@01)))
        (or (not (= j@159@01 i2@118@01)) (= j@159@01 i2@118@01))))
    :pattern ((Seq_index xs@116@01 j@159@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@162@01  $FVF<f>)))) xs@116@01 i2@118@01)))
(push) ; 3
(assert (not (=
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@156@01  $FVF<f>)))) xs@116@01 i2@118@01)
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@162@01  $FVF<f>)))) xs@116@01 i2@118@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
(declare-const sm@163@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@163@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@163@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef113|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@163@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@163@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef114|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@163@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@163@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef115|)))
(declare-const pm@164@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@164@01  $FPM) r)
    (+
      (+
        (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
        $Perm.No)))
  :pattern (($FVF.perm_f (as pm@164@01  $FPM) r))
  :qid |qp.resPrmSumDef116|)))
(assert (<=
  ($FVF.perm_f (as pm@164@01  $FPM) (Seq_index xs@116@01 i2@118@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@164@01  $FPM) (Seq_index xs@116@01 i1@117@01))
  $Perm.Write))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@164@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun02qp(xs, i2) == old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@165@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 58 | !(0 <= j@165@01) | live]
; [else-branch: 58 | 0 <= j@165@01 | live]
(push) ; 6
; [then-branch: 58 | !(0 <= j@165@01)]
(assert (not (<= 0 j@165@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 58 | 0 <= j@165@01]
(assert (<= 0 j@165@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (not (<= 0 j@165@01))
  (and
    (not (<= 0 j@165@01))
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01))))))
; Joined path conditions
(assert (=>
  (<= 0 j@165@01)
  (and
    (<= 0 j@165@01)
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01))))))
(assert (or (<= 0 j@165@01) (not (<= 0 j@165@01))))
(assert (and (<= 0 j@165@01) (< j@165@01 (Seq_length xs@116@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 59 | j@165@01 == i2@118@01 | live]
; [else-branch: 59 | j@165@01 != i2@118@01 | live]
(push) ; 6
; [then-branch: 59 | j@165@01 == i2@118@01]
(assert (= j@165@01 i2@118@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 59 | j@165@01 != i2@118@01]
(assert (not (= j@165@01 i2@118@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (= j@165@01 i2@118@01)
  (and
    (= j@165@01 i2@118@01)
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01))))))
; Joined path conditions
(assert (=>
  (not (= j@165@01 i2@118@01))
  (and
    (not (= j@165@01 i2@118@01))
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01))))))
(assert (or (not (= j@165@01 i2@118@01)) (= j@165@01 i2@118@01)))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@165@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@166@01 ($Ref) Int)
(declare-fun img@167@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@165@01 Int)) (!
  (=>
    (and (<= 0 j@165@01) (< j@165@01 (Seq_length xs@116@01)))
    (and
      (=>
        (not (<= 0 j@165@01))
        (and
          (not (<= 0 j@165@01))
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
      (=>
        (<= 0 j@165@01)
        (and
          (<= 0 j@165@01)
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
      (or (<= 0 j@165@01) (not (<= 0 j@165@01)))
      (=>
        (= j@165@01 i2@118@01)
        (and
          (= j@165@01 i2@118@01)
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
      (=>
        (not (= j@165@01 i2@118@01))
        (and
          (not (= j@165@01 i2@118@01))
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
      (or (not (= j@165@01 i2@118@01)) (= j@165@01 i2@118@01))))
  :pattern ((Seq_index xs@116@01 j@165@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@165@01 Int)) (!
  (=>
    (and (<= 0 j@165@01) (< j@165@01 (Seq_length xs@116@01)))
    (or
      (= (ite (= j@165@01 i2@118@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@165@01 i2@118@01)))
  
  :qid |quant-u-12828|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@165@01 Int) (j2@165@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@165@01) (< j1@165@01 (Seq_length xs@116@01)))
        (= j1@165@01 i2@118@01))
      (and
        (and (<= 0 j2@165@01) (< j2@165@01 (Seq_length xs@116@01)))
        (= j2@165@01 i2@118@01))
      (= (Seq_index xs@116@01 j1@165@01) (Seq_index xs@116@01 j2@165@01)))
    (= j1@165@01 j2@165@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@165@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@165@01) (< j@165@01 (Seq_length xs@116@01)))
      (= j@165@01 i2@118@01))
    (and
      (= (inv@166@01 (Seq_index xs@116@01 j@165@01)) j@165@01)
      (img@167@01 (Seq_index xs@116@01 j@165@01))))
  :pattern ((Seq_index xs@116@01 j@165@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@167@01 r)
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@166@01 r)) r))
  :pattern ((inv@166@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (img@167@01 r)
        (= r (Seq_index xs@116@01 (inv@166@01 r))))
      (> (ite (= (inv@166@01 r) i2@118@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (+
          (ite
            (and
              (img@125@01 r)
              (and
                (<= 0 (inv@124@01 r))
                (< (inv@124@01 r) (Seq_length xs@116@01))))
            (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12829|))))
(check-sat)
; unsat
(pop) ; 4
; 0.01s
; (get-info :all-statistics)
(declare-const sm@168@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@168@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)
        (img@167@01 r)))
    (=>
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)
        (img@167@01 r))
      (Set_in r ($FVF.domain_f (as sm@168@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@168@01  $FVF<f>))))
  :qid |qp.fvfDomDef120|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)
        (img@167@01 r))
      (= r (Seq_index xs@116@01 i2@118@01)))
    (=
      ($FVF.lookup_f (as sm@168@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@168@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)
        (img@167@01 r))
      (= r (Seq_index xs@116@01 i1@117@01)))
    (=
      ($FVF.lookup_f (as sm@168@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@168@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)
        (img@167@01 r))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@168@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@168@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef119|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@168@01  $FVF<f>)))) xs@116@01 i2@118@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@165@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@165@01) (< j@165@01 (Seq_length xs@116@01)))
      (= j@165@01 i2@118@01))
    (and
      (= (inv@166@01 (Seq_index xs@116@01 j@165@01)) j@165@01)
      (img@167@01 (Seq_index xs@116@01 j@165@01))))
  :pattern ((Seq_index xs@116@01 j@165@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@167@01 r)
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@166@01 r)) r))
  :pattern ((inv@166@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@168@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)
        (img@167@01 r)))
    (=>
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)
        (img@167@01 r))
      (Set_in r ($FVF.domain_f (as sm@168@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@168@01  $FVF<f>))))
  :qid |qp.fvfDomDef120|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)
        (img@167@01 r))
      (= r (Seq_index xs@116@01 i2@118@01)))
    (=
      ($FVF.lookup_f (as sm@168@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@168@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)
        (img@167@01 r))
      (= r (Seq_index xs@116@01 i1@117@01)))
    (=
      ($FVF.lookup_f (as sm@168@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@168@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@166@01 r)) (< (inv@166@01 r) (Seq_length xs@116@01)))
        (= (inv@166@01 r) i2@118@01)
        (img@167@01 r))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@168@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@168@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef119|)))
(assert (and
  (forall ((j@165@01 Int)) (!
    (=>
      (and (<= 0 j@165@01) (< j@165@01 (Seq_length xs@116@01)))
      (and
        (=>
          (not (<= 0 j@165@01))
          (and
            (not (<= 0 j@165@01))
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
        (=>
          (<= 0 j@165@01)
          (and
            (<= 0 j@165@01)
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
        (or (<= 0 j@165@01) (not (<= 0 j@165@01)))
        (=>
          (= j@165@01 i2@118@01)
          (and
            (= j@165@01 i2@118@01)
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
        (=>
          (not (= j@165@01 i2@118@01))
          (and
            (not (= j@165@01 i2@118@01))
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
        (or (not (= j@165@01 i2@118@01)) (= j@165@01 i2@118@01))))
    :pattern ((Seq_index xs@116@01 j@165@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@168@01  $FVF<f>)))) xs@116@01 i2@118@01)))
; [eval] old(fun02qp(xs, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@169@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@125@01 r)
      (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
    (=
      ($FVF.lookup_f (as sm@169@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@169@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef121|)))
(declare-const pm@170@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@170@01  $FPM) r)
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@170@01  $FPM) r))
  :qid |qp.resPrmSumDef122|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@170@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun02qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@171@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 60 | !(0 <= j@171@01) | live]
; [else-branch: 60 | 0 <= j@171@01 | live]
(push) ; 6
; [then-branch: 60 | !(0 <= j@171@01)]
(assert (not (<= 0 j@171@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 60 | 0 <= j@171@01]
(assert (<= 0 j@171@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@171@01) (not (<= 0 j@171@01))))
(assert (and (<= 0 j@171@01) (< j@171@01 (Seq_length xs@116@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 61 | j@171@01 == i2@118@01 | live]
; [else-branch: 61 | j@171@01 != i2@118@01 | live]
(push) ; 6
; [then-branch: 61 | j@171@01 == i2@118@01]
(assert (= j@171@01 i2@118@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 61 | j@171@01 != i2@118@01]
(assert (not (= j@171@01 i2@118@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@171@01 i2@118@01)) (= j@171@01 i2@118@01)))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@171@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@172@01 ($Ref) Int)
(declare-fun img@173@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@171@01 Int)) (!
  (=>
    (and (<= 0 j@171@01) (< j@171@01 (Seq_length xs@116@01)))
    (and
      (or (<= 0 j@171@01) (not (<= 0 j@171@01)))
      (or (not (= j@171@01 i2@118@01)) (= j@171@01 i2@118@01))))
  :pattern ((Seq_index xs@116@01 j@171@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@171@01 Int)) (!
  (=>
    (and (<= 0 j@171@01) (< j@171@01 (Seq_length xs@116@01)))
    (or
      (= (ite (= j@171@01 i2@118@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@171@01 i2@118@01)))
  
  :qid |quant-u-12830|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@171@01 Int) (j2@171@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@171@01) (< j1@171@01 (Seq_length xs@116@01)))
        (= j1@171@01 i2@118@01))
      (and
        (and (<= 0 j2@171@01) (< j2@171@01 (Seq_length xs@116@01)))
        (= j2@171@01 i2@118@01))
      (= (Seq_index xs@116@01 j1@171@01) (Seq_index xs@116@01 j2@171@01)))
    (= j1@171@01 j2@171@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@171@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@171@01) (< j@171@01 (Seq_length xs@116@01)))
      (= j@171@01 i2@118@01))
    (and
      (= (inv@172@01 (Seq_index xs@116@01 j@171@01)) j@171@01)
      (img@173@01 (Seq_index xs@116@01 j@171@01))))
  :pattern ((Seq_index xs@116@01 j@171@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@173@01 r)
      (and
        (and (<= 0 (inv@172@01 r)) (< (inv@172@01 r) (Seq_length xs@116@01)))
        (= (inv@172@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@172@01 r)) r))
  :pattern ((inv@172@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@172@01 r)) (< (inv@172@01 r) (Seq_length xs@116@01)))
        (img@173@01 r)
        (= r (Seq_index xs@116@01 (inv@172@01 r))))
      (> (ite (= (inv@172@01 r) i2@118@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12831|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@174@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@174@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@172@01 r)) (< (inv@172@01 r) (Seq_length xs@116@01)))
        (= (inv@172@01 r) i2@118@01)
        (img@173@01 r)))
    (=>
      (and
        (and (<= 0 (inv@172@01 r)) (< (inv@172@01 r) (Seq_length xs@116@01)))
        (= (inv@172@01 r) i2@118@01)
        (img@173@01 r))
      (Set_in r ($FVF.domain_f (as sm@174@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@174@01  $FVF<f>))))
  :qid |qp.fvfDomDef124|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@172@01 r)) (< (inv@172@01 r) (Seq_length xs@116@01)))
        (= (inv@172@01 r) i2@118@01)
        (img@173@01 r))
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01)))))
    (=
      ($FVF.lookup_f (as sm@174@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@174@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef123|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@174@01  $FVF<f>)))) xs@116@01 i2@118@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@171@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@171@01) (< j@171@01 (Seq_length xs@116@01)))
      (= j@171@01 i2@118@01))
    (and
      (= (inv@172@01 (Seq_index xs@116@01 j@171@01)) j@171@01)
      (img@173@01 (Seq_index xs@116@01 j@171@01))))
  :pattern ((Seq_index xs@116@01 j@171@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@173@01 r)
      (and
        (and (<= 0 (inv@172@01 r)) (< (inv@172@01 r) (Seq_length xs@116@01)))
        (= (inv@172@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@172@01 r)) r))
  :pattern ((inv@172@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@174@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@172@01 r)) (< (inv@172@01 r) (Seq_length xs@116@01)))
        (= (inv@172@01 r) i2@118@01)
        (img@173@01 r)))
    (=>
      (and
        (and (<= 0 (inv@172@01 r)) (< (inv@172@01 r) (Seq_length xs@116@01)))
        (= (inv@172@01 r) i2@118@01)
        (img@173@01 r))
      (Set_in r ($FVF.domain_f (as sm@174@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@174@01  $FVF<f>))))
  :qid |qp.fvfDomDef124|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@172@01 r)) (< (inv@172@01 r) (Seq_length xs@116@01)))
        (= (inv@172@01 r) i2@118@01)
        (img@173@01 r))
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01)))))
    (=
      ($FVF.lookup_f (as sm@174@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@174@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef123|)))
(assert (and
  (forall ((j@171@01 Int)) (!
    (=>
      (and (<= 0 j@171@01) (< j@171@01 (Seq_length xs@116@01)))
      (and
        (or (<= 0 j@171@01) (not (<= 0 j@171@01)))
        (or (not (= j@171@01 i2@118@01)) (= j@171@01 i2@118@01))))
    :pattern ((Seq_index xs@116@01 j@171@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@174@01  $FVF<f>)))) xs@116@01 i2@118@01)))
(push) ; 3
(assert (not (=
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@168@01  $FVF<f>)))) xs@116@01 i2@118@01)
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@174@01  $FVF<f>)))) xs@116@01 i2@118@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] fun02qp(xs, i2) == old(fun02qp(xs, i2))
; [eval] fun02qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@175@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 62 | !(0 <= j@175@01) | live]
; [else-branch: 62 | 0 <= j@175@01 | live]
(push) ; 6
; [then-branch: 62 | !(0 <= j@175@01)]
(assert (not (<= 0 j@175@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(declare-const sm@176@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef127|)))
(declare-const pm@177@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@177@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@177@01  $FPM) r))
  :qid |qp.resPrmSumDef128|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@177@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@177@01  $FPM) (Seq_index xs@116@01 i1@117@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@177@01  $FPM) (Seq_index xs@116@01 i2@118@01))
  $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 62 | 0 <= j@175@01]
(assert (<= 0 j@175@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
(declare-const sm@178@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef130|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef131|)))
(declare-const pm@179@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@179@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@179@01  $FPM) r))
  :qid |qp.resPrmSumDef132|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
  $Perm.Write))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef127|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@177@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@177@01  $FPM) r))
  :qid |qp.resPrmSumDef128|)))
(assert (=>
  (not (<= 0 j@175@01))
  (and
    (not (<= 0 j@175@01))
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@177@01  $FPM) r) $Perm.Write)
      :pattern ((inv@124@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@177@01  $FPM) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@177@01  $FPM) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef130|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@179@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@179@01  $FPM) r))
  :qid |qp.resPrmSumDef132|)))
(assert (=>
  (<= 0 j@175@01)
  (and
    (<= 0 j@175@01)
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
      :pattern ((inv@124@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write))))
(assert (or (<= 0 j@175@01) (not (<= 0 j@175@01))))
(assert (and (<= 0 j@175@01) (< j@175@01 (Seq_length xs@116@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 63 | j@175@01 == i2@118@01 | live]
; [else-branch: 63 | j@175@01 != i2@118@01 | live]
(push) ; 6
; [then-branch: 63 | j@175@01 == i2@118@01]
(assert (= j@175@01 i2@118@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
  $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 63 | j@175@01 != i2@118@01]
(assert (not (= j@175@01 i2@118@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01))
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01))
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i2@118@01))
    (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i1@117@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) (Seq_index xs@116@01 i2@118@01))
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) (Seq_index xs@116@01 i1@117@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
  (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
  $Perm.Write))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (= j@175@01 i2@118@01)
  (and
    (= j@175@01 i2@118@01)
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
      :pattern ((inv@124@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write))))
; Joined path conditions
(assert (=>
  (not (= j@175@01 i2@118@01))
  (and
    (not (= j@175@01 i2@118@01))
    (not (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
    (not (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
      :pattern ((inv@124@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
      $Perm.Write))))
(assert (or (not (= j@175@01 i2@118@01)) (= j@175@01 i2@118@01)))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@175@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@180@01 ($Ref) Int)
(declare-fun img@181@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef127|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@177@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@177@01  $FPM) r))
  :qid |qp.resPrmSumDef128|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef130|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@179@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@179@01  $FPM) r))
  :qid |qp.resPrmSumDef132|)))
; Nested auxiliary terms: non-globals
(assert (forall ((j@175@01 Int)) (!
  (=>
    (and (<= 0 j@175@01) (< j@175@01 (Seq_length xs@116@01)))
    (and
      (=>
        (not (<= 0 j@175@01))
        (and
          (not (<= 0 j@175@01))
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@177@01  $FPM) r) $Perm.Write)
            :pattern ((inv@124@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@177@01  $FPM) (Seq_index xs@116@01 i1@117@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@177@01  $FPM) (Seq_index xs@116@01 i2@118@01))
            $Perm.Write)))
      (=>
        (<= 0 j@175@01)
        (and
          (<= 0 j@175@01)
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
            :pattern ((inv@124@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
            $Perm.Write)))
      (or (<= 0 j@175@01) (not (<= 0 j@175@01)))
      (=>
        (= j@175@01 i2@118@01)
        (and
          (= j@175@01 i2@118@01)
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
            :pattern ((inv@124@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
            $Perm.Write)))
      (=>
        (not (= j@175@01 i2@118@01))
        (and
          (not (= j@175@01 i2@118@01))
          (not
            (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
          (not
            (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
            :pattern ((inv@124@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
            $Perm.Write)))
      (or (not (= j@175@01 i2@118@01)) (= j@175@01 i2@118@01))))
  :pattern ((Seq_index xs@116@01 j@175@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@175@01 Int)) (!
  (=>
    (and (<= 0 j@175@01) (< j@175@01 (Seq_length xs@116@01)))
    (or
      (= (ite (= j@175@01 i2@118@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@175@01 i2@118@01)))
  
  :qid |quant-u-12832|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@175@01 Int) (j2@175@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@175@01) (< j1@175@01 (Seq_length xs@116@01)))
        (= j1@175@01 i2@118@01))
      (and
        (and (<= 0 j2@175@01) (< j2@175@01 (Seq_length xs@116@01)))
        (= j2@175@01 i2@118@01))
      (= (Seq_index xs@116@01 j1@175@01) (Seq_index xs@116@01 j2@175@01)))
    (= j1@175@01 j2@175@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@175@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@175@01) (< j@175@01 (Seq_length xs@116@01)))
      (= j@175@01 i2@118@01))
    (and
      (= (inv@180@01 (Seq_index xs@116@01 j@175@01)) j@175@01)
      (img@181@01 (Seq_index xs@116@01 j@175@01))))
  :pattern ((Seq_index xs@116@01 j@175@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@181@01 r)
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@180@01 r)) r))
  :pattern ((inv@180@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (img@181@01 r)
        (= r (Seq_index xs@116@01 (inv@180@01 r))))
      (> (ite (= (inv@180@01 r) i2@118@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (+
          (ite
            (and
              (img@125@01 r)
              (and
                (<= 0 (inv@124@01 r))
                (< (inv@124@01 r) (Seq_length xs@116@01))))
            (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12833|))))
(check-sat)
; unsat
(pop) ; 4
; 0.02s
; (get-info :all-statistics)
(declare-const sm@182@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@182@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)
        (img@181@01 r)))
    (=>
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)
        (img@181@01 r))
      (Set_in r ($FVF.domain_f (as sm@182@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@182@01  $FVF<f>))))
  :qid |qp.fvfDomDef136|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)
        (img@181@01 r))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@182@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@182@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef133|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)
        (img@181@01 r))
      (= r (Seq_index xs@116@01 i1@117@01)))
    (=
      ($FVF.lookup_f (as sm@182@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@182@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)
        (img@181@01 r))
      (= r (Seq_index xs@116@01 i2@118@01)))
    (=
      ($FVF.lookup_f (as sm@182@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@182@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef135|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@182@01  $FVF<f>)))) xs@116@01 i2@118@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@176@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@176@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef127|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@177@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@177@01  $FPM) r))
  :qid |qp.resPrmSumDef128|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i1@117@01))
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef130|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@116@01 i2@118@01))
    (=
      ($FVF.lookup_f (as sm@178@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@178@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@179@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@125@01 r)
            (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
          (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@116@01 i1@117@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@116@01 i2@118@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@179@01  $FPM) r))
  :qid |qp.resPrmSumDef132|)))
(assert (forall ((j@175@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@175@01) (< j@175@01 (Seq_length xs@116@01)))
      (= j@175@01 i2@118@01))
    (and
      (= (inv@180@01 (Seq_index xs@116@01 j@175@01)) j@175@01)
      (img@181@01 (Seq_index xs@116@01 j@175@01))))
  :pattern ((Seq_index xs@116@01 j@175@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@181@01 r)
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@180@01 r)) r))
  :pattern ((inv@180@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@182@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)
        (img@181@01 r)))
    (=>
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)
        (img@181@01 r))
      (Set_in r ($FVF.domain_f (as sm@182@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@182@01  $FVF<f>))))
  :qid |qp.fvfDomDef136|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)
        (img@181@01 r))
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@126@01 r)) (pTaken@136@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@182@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@182@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef133|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)
        (img@181@01 r))
      (= r (Seq_index xs@116@01 i1@117@01)))
    (=
      ($FVF.lookup_f (as sm@182@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@127@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@182@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@127@01  $FVF<f>) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@180@01 r)) (< (inv@180@01 r) (Seq_length xs@116@01)))
        (= (inv@180@01 r) i2@118@01)
        (img@181@01 r))
      (= r (Seq_index xs@116@01 i2@118@01)))
    (=
      ($FVF.lookup_f (as sm@182@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@138@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@182@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@138@01  $FVF<f>) r))
  :qid |qp.fvfValDef135|)))
(assert (and
  (forall ((j@175@01 Int)) (!
    (=>
      (and (<= 0 j@175@01) (< j@175@01 (Seq_length xs@116@01)))
      (and
        (=>
          (not (<= 0 j@175@01))
          (and
            (not (<= 0 j@175@01))
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@177@01  $FPM) r) $Perm.Write)
              :pattern ((inv@124@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@177@01  $FPM) (Seq_index xs@116@01 i1@117@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@177@01  $FPM) (Seq_index xs@116@01 i2@118@01))
              $Perm.Write)))
        (=>
          (<= 0 j@175@01)
          (and
            (<= 0 j@175@01)
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
              :pattern ((inv@124@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
              $Perm.Write)))
        (or (<= 0 j@175@01) (not (<= 0 j@175@01)))
        (=>
          (= j@175@01 i2@118@01)
          (and
            (= j@175@01 i2@118@01)
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
              :pattern ((inv@124@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
              $Perm.Write)))
        (=>
          (not (= j@175@01 i2@118@01))
          (and
            (not (= j@175@01 i2@118@01))
            (not
              (= (Seq_index xs@116@01 i1@117@01) (Seq_index xs@116@01 i2@118@01)))
            (not
              (= (Seq_index xs@116@01 i2@118@01) (Seq_index xs@116@01 i1@117@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@179@01  $FPM) r) $Perm.Write)
              :pattern ((inv@124@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i1@117@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@179@01  $FPM) (Seq_index xs@116@01 i2@118@01))
              $Perm.Write)))
        (or (not (= j@175@01 i2@118@01)) (= j@175@01 i2@118@01))))
    :pattern ((Seq_index xs@116@01 j@175@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@182@01  $FVF<f>)))) xs@116@01 i2@118@01)))
; [eval] old(fun02qp(xs, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@183@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@125@01 r)
      (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
    (=
      ($FVF.lookup_f (as sm@183@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@183@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef137|)))
(declare-const pm@184@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@184@01  $FPM) r)
    (ite
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@184@01  $FPM) r))
  :qid |qp.resPrmSumDef138|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@184@01  $FPM) r) $Perm.Write)
  :pattern ((inv@124@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun02qp(xs, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |xs|
; [eval] |xs|
(declare-const j@185@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 64 | !(0 <= j@185@01) | live]
; [else-branch: 64 | 0 <= j@185@01 | live]
(push) ; 6
; [then-branch: 64 | !(0 <= j@185@01)]
(assert (not (<= 0 j@185@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 64 | 0 <= j@185@01]
(assert (<= 0 j@185@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@185@01) (not (<= 0 j@185@01))))
(assert (and (<= 0 j@185@01) (< j@185@01 (Seq_length xs@116@01))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 65 | j@185@01 == i2@118@01 | live]
; [else-branch: 65 | j@185@01 != i2@118@01 | live]
(push) ; 6
; [then-branch: 65 | j@185@01 == i2@118@01]
(assert (= j@185@01 i2@118@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 65 | j@185@01 != i2@118@01]
(assert (not (= j@185@01 i2@118@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@185@01 i2@118@01)) (= j@185@01 i2@118@01)))
; [eval] xs[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@185@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@186@01 ($Ref) Int)
(declare-fun img@187@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@185@01 Int)) (!
  (=>
    (and (<= 0 j@185@01) (< j@185@01 (Seq_length xs@116@01)))
    (and
      (or (<= 0 j@185@01) (not (<= 0 j@185@01)))
      (or (not (= j@185@01 i2@118@01)) (= j@185@01 i2@118@01))))
  :pattern ((Seq_index xs@116@01 j@185@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@185@01 Int)) (!
  (=>
    (and (<= 0 j@185@01) (< j@185@01 (Seq_length xs@116@01)))
    (or
      (= (ite (= j@185@01 i2@118@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@185@01 i2@118@01)))
  
  :qid |quant-u-12834|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@185@01 Int) (j2@185@01 Int)) (!
  (=>
    (and
      (and
        (and (<= 0 j1@185@01) (< j1@185@01 (Seq_length xs@116@01)))
        (= j1@185@01 i2@118@01))
      (and
        (and (<= 0 j2@185@01) (< j2@185@01 (Seq_length xs@116@01)))
        (= j2@185@01 i2@118@01))
      (= (Seq_index xs@116@01 j1@185@01) (Seq_index xs@116@01 j2@185@01)))
    (= j1@185@01 j2@185@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@185@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@185@01) (< j@185@01 (Seq_length xs@116@01)))
      (= j@185@01 i2@118@01))
    (and
      (= (inv@186@01 (Seq_index xs@116@01 j@185@01)) j@185@01)
      (img@187@01 (Seq_index xs@116@01 j@185@01))))
  :pattern ((Seq_index xs@116@01 j@185@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@187@01 r)
      (and
        (and (<= 0 (inv@186@01 r)) (< (inv@186@01 r) (Seq_length xs@116@01)))
        (= (inv@186@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@186@01 r)) r))
  :pattern ((inv@186@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@186@01 r)) (< (inv@186@01 r) (Seq_length xs@116@01)))
        (img@187@01 r)
        (= r (Seq_index xs@116@01 (inv@186@01 r))))
      (> (ite (= (inv@186@01 r) i2@118@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@125@01 r)
          (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12835|))))
(check-sat)
; unsat
(pop) ; 4
; 0.02s
; (get-info :all-statistics)
(declare-const sm@188@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@188@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@186@01 r)) (< (inv@186@01 r) (Seq_length xs@116@01)))
        (= (inv@186@01 r) i2@118@01)
        (img@187@01 r)))
    (=>
      (and
        (and (<= 0 (inv@186@01 r)) (< (inv@186@01 r) (Seq_length xs@116@01)))
        (= (inv@186@01 r) i2@118@01)
        (img@187@01 r))
      (Set_in r ($FVF.domain_f (as sm@188@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@188@01  $FVF<f>))))
  :qid |qp.fvfDomDef140|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@186@01 r)) (< (inv@186@01 r) (Seq_length xs@116@01)))
        (= (inv@186@01 r) i2@118@01)
        (img@187@01 r))
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01)))))
    (=
      ($FVF.lookup_f (as sm@188@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@188@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef139|)))
(assert (fun02qp%precondition ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($SortWrappers.$FVF<f>To$Snap (as sm@188@01  $FVF<f>)))) xs@116@01 i2@118@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@185@01 Int)) (!
  (=>
    (and
      (and (<= 0 j@185@01) (< j@185@01 (Seq_length xs@116@01)))
      (= j@185@01 i2@118@01))
    (and
      (= (inv@186@01 (Seq_index xs@116@01 j@185@01)) j@185@01)
      (img@187@01 (Seq_index xs@116@01 j@185@01))))
  :pattern ((Seq_index xs@116@01 j@185@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@187@01 r)
      (and
        (and (<= 0 (inv@186@01 r)) (< (inv@186@01 r) (Seq_length xs@116@01)))
        (= (inv@186@01 r) i2@118@01)))
    (= (Seq_index xs@116@01 (inv@186@01 r)) r))
  :pattern ((inv@186@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@188@01  $FVF<f>)))
      (and
        (and (<= 0 (inv@186@01 r)) (< (inv@186@01 r) (Seq_length xs@116@01)))
        (= (inv@186@01 r) i2@118@01)
        (img@187@01 r)))
    (=>
      (and
        (and (<= 0 (inv@186@01 r)) (< (inv@186@01 r) (Seq_length xs@116@01)))
        (= (inv@186@01 r) i2@118@01)
        (img@187@01 r))
      (Set_in r ($FVF.domain_f (as sm@188@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@188@01  $FVF<f>))))
  :qid |qp.fvfDomDef140|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and (<= 0 (inv@186@01 r)) (< (inv@186@01 r) (Seq_length xs@116@01)))
        (= (inv@186@01 r) i2@118@01)
        (img@187@01 r))
      (and
        (img@125@01 r)
        (and (<= 0 (inv@124@01 r)) (< (inv@124@01 r) (Seq_length xs@116@01)))))
    (=
      ($FVF.lookup_f (as sm@188@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@188@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@120@01)))))))) r))
  :qid |qp.fvfValDef139|)))
(assert (and
  (forall ((j@185@01 Int)) (!
    (=>
      (and (<= 0 j@185@01) (< j@185@01 (Seq_length xs@116@01)))
      (and
        (or (<= 0 j@185@01) (not (<= 0 j@185@01)))
        (or (not (= j@185@01 i2@118@01)) (= j@185@01 i2@118@01))))
    :pattern ((Seq_index xs@116@01 j@185@01))
    :qid |f-aux|))
  (fun02qp%precondition ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@188@01  $FVF<f>)))) xs@116@01 i2@118@01)))
(push) ; 3
(assert (not (=
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@182@01  $FVF<f>)))) xs@116@01 i2@118@01)
  (fun02qp ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@188@01  $FVF<f>)))) xs@116@01 i2@118@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(pop) ; 2
(pop) ; 1
; ---------- test04 ----------
(declare-const xs@189@01 Seq<$Ref>)
(declare-const i1@190@01 Int)
(declare-const i2@191@01 Int)
(declare-const x@192@01 $Ref)
(declare-const xs@193@01 Seq<$Ref>)
(declare-const i1@194@01 Int)
(declare-const i2@195@01 Int)
(declare-const x@196@01 $Ref)
(push) ; 1
(declare-const $t@197@01 $Snap)
(assert (= $t@197@01 ($Snap.combine ($Snap.first $t@197@01) ($Snap.second $t@197@01))))
(assert (= ($Snap.first $t@197@01) $Snap.unit))
; [eval] 0 <= i1
(assert (<= 0 i1@194@01))
(assert (=
  ($Snap.second $t@197@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@197@01))
    ($Snap.second ($Snap.second $t@197@01)))))
(assert (= ($Snap.first ($Snap.second $t@197@01)) $Snap.unit))
; [eval] i1 < |xs|
; [eval] |xs|
(assert (< i1@194@01 (Seq_length xs@193@01)))
(assert (=
  ($Snap.second ($Snap.second $t@197@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@197@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@197@01))) $Snap.unit))
; [eval] 0 <= i2
(assert (<= 0 i2@195@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@197@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@197@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@197@01))))
  $Snap.unit))
; [eval] i2 < |xs|
; [eval] |xs|
(assert (< i2@195@01 (Seq_length xs@193@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))
  $Snap.unit))
; [eval] i1 != i2
(assert (not (= i1@194@01 i2@195@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))
  $Snap.unit))
; [eval] (forall j1: Int, j2: Int :: { (j1 in [0..|xs|)), (j2 in [0..|xs|)) } { (j1 in [0..|xs|)), xs[j2] } { (j2 in [0..|xs|)), xs[j1] } { xs[j1], xs[j2] } (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2) ==> xs[j1] != xs[j2])
(declare-const j1@198@01 Int)
(declare-const j2@199@01 Int)
(push) ; 2
; [eval] (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2) ==> xs[j1] != xs[j2]
; [eval] (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2)
; [eval] (j1 in [0..|xs|))
; [eval] [0..|xs|)
; [eval] |xs|
(push) ; 3
; [then-branch: 66 | !(j1@198@01 in [0..|xs@193@01|]) | live]
; [else-branch: 66 | j1@198@01 in [0..|xs@193@01|] | live]
(push) ; 4
; [then-branch: 66 | !(j1@198@01 in [0..|xs@193@01|])]
(assert (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 66 | j1@198@01 in [0..|xs@193@01|]]
(assert (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01))
; [eval] (j2 in [0..|xs|))
; [eval] [0..|xs|)
; [eval] |xs|
(push) ; 5
; [then-branch: 67 | !(j2@199@01 in [0..|xs@193@01|]) | live]
; [else-branch: 67 | j2@199@01 in [0..|xs@193@01|] | live]
(push) ; 6
; [then-branch: 67 | !(j2@199@01 in [0..|xs@193@01|])]
(assert (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 67 | j2@199@01 in [0..|xs@193@01|]]
(assert (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01))
; [eval] j1 != j2
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
  (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01))))))
(assert (or
  (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
  (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01))))
(push) ; 3
; [then-branch: 68 | j1@198@01 in [0..|xs@193@01|] && j2@199@01 in [0..|xs@193@01|] && j1@198@01 != j2@199@01 | live]
; [else-branch: 68 | !(j1@198@01 in [0..|xs@193@01|] && j2@199@01 in [0..|xs@193@01|] && j1@198@01 != j2@199@01) | live]
(push) ; 4
; [then-branch: 68 | j1@198@01 in [0..|xs@193@01|] && j2@199@01 in [0..|xs@193@01|] && j1@198@01 != j2@199@01]
(assert (and
  (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
    (not (= j1@198@01 j2@199@01)))))
; [eval] xs[j1] != xs[j2]
; [eval] xs[j1]
(push) ; 5
(assert (not (>= j1@198@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(assert (not (< j1@198@01 (Seq_length xs@193@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [eval] xs[j2]
(push) ; 5
(assert (not (>= j2@199@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(assert (not (< j2@199@01 (Seq_length xs@193@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 68 | !(j1@198@01 in [0..|xs@193@01|] && j2@199@01 in [0..|xs@193@01|] && j1@198@01 != j2@199@01)]
(assert (not
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
      (not (= j1@198@01 j2@199@01))))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=>
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
      (not (= j1@198@01 j2@199@01))))
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
    (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
    (not (= j1@198@01 j2@199@01)))))
; Joined path conditions
(assert (or
  (not
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
        (not (= j1@198@01 j2@199@01)))))
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
      (not (= j1@198@01 j2@199@01))))))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((j1@198@01 Int) (j2@199@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
        (not (= j1@198@01 j2@199@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
            (not (= j1@198@01 j2@199@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01) (Seq_contains
    (Seq_range 0 (Seq_length xs@193@01))
    j2@199@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@193@01)) j1@198@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@193@01))
    j2@199@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@95@12@95@106-aux|)))
(assert (forall ((j1@198@01 Int) (j2@199@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
        (not (= j1@198@01 j2@199@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
            (not (= j1@198@01 j2@199@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@193@01)) j1@198@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@193@01))
    j2@199@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@95@12@95@106-aux|)))
(assert (forall ((j1@198@01 Int) (j2@199@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
        (not (= j1@198@01 j2@199@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
            (not (= j1@198@01 j2@199@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01) (Seq_index
    xs@193@01
    j2@199@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@193@01)) j1@198@01) (Seq_index
    xs@193@01
    j2@199@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@95@12@95@106-aux|)))
(assert (forall ((j1@198@01 Int) (j2@199@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
        (not (= j1@198@01 j2@199@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
            (not (= j1@198@01 j2@199@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@193@01)) j1@198@01) (Seq_index
    xs@193@01
    j2@199@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@95@12@95@106-aux|)))
(assert (forall ((j1@198@01 Int) (j2@199@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
        (not (= j1@198@01 j2@199@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
            (not (= j1@198@01 j2@199@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01) (Seq_index
    xs@193@01
    j1@198@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@193@01)) j2@199@01) (Seq_index
    xs@193@01
    j1@198@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@95@12@95@106-aux|)))
(assert (forall ((j1@198@01 Int) (j2@199@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
        (not (= j1@198@01 j2@199@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
            (not (= j1@198@01 j2@199@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@193@01)) j2@199@01) (Seq_index
    xs@193@01
    j1@198@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@95@12@95@106-aux|)))
(assert (forall ((j1@198@01 Int) (j2@199@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
        (not (= j1@198@01 j2@199@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
            (not (= j1@198@01 j2@199@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
          (not (= j1@198@01 j2@199@01))))))
  :pattern ((Seq_index xs@193@01 j1@198@01) (Seq_index xs@193@01 j2@199@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@95@12@95@106-aux|)))
(assert (forall ((j1@198@01 Int) (j2@199@01 Int)) (!
  (=>
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01)
        (not (= j1@198@01 j2@199@01))))
    (not (= (Seq_index xs@193@01 j1@198@01) (Seq_index xs@193@01 j2@199@01))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01) (Seq_contains
    (Seq_range 0 (Seq_length xs@193@01))
    j2@199@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@193@01)) j1@198@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@193@01))
    j2@199@01))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j1@198@01) (Seq_index
    xs@193@01
    j2@199@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@193@01)) j1@198@01) (Seq_index
    xs@193@01
    j2@199@01))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@193@01)) j2@199@01) (Seq_index
    xs@193@01
    j1@198@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@193@01)) j2@199@01) (Seq_index
    xs@193@01
    j1@198@01))
  :pattern ((Seq_index xs@193@01 j1@198@01) (Seq_index xs@193@01 j2@199@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@95@12@95@106|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))
(declare-const j@200@01 Int)
(push) ; 2
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 3
; [then-branch: 69 | !(0 <= j@200@01) | live]
; [else-branch: 69 | 0 <= j@200@01 | live]
(push) ; 4
; [then-branch: 69 | !(0 <= j@200@01)]
(assert (not (<= 0 j@200@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 69 | 0 <= j@200@01]
(assert (<= 0 j@200@01))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@200@01) (not (<= 0 j@200@01))))
(assert (and (<= 0 j@200@01) (< j@200@01 (Seq_length xs@193@01))))
; [eval] xs[j]
(push) ; 3
(assert (not (>= j@200@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(pop) ; 2
(declare-fun inv@201@01 ($Ref) Int)
(declare-fun img@202@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@200@01 Int)) (!
  (=>
    (and (<= 0 j@200@01) (< j@200@01 (Seq_length xs@193@01)))
    (or (<= 0 j@200@01) (not (<= 0 j@200@01))))
  :pattern ((Seq_index xs@193@01 j@200@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((j1@200@01 Int) (j2@200@01 Int)) (!
  (=>
    (and
      (and (<= 0 j1@200@01) (< j1@200@01 (Seq_length xs@193@01)))
      (and (<= 0 j2@200@01) (< j2@200@01 (Seq_length xs@193@01)))
      (= (Seq_index xs@193@01 j1@200@01) (Seq_index xs@193@01 j2@200@01)))
    (= j1@200@01 j2@200@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@200@01 Int)) (!
  (=>
    (and (<= 0 j@200@01) (< j@200@01 (Seq_length xs@193@01)))
    (and
      (= (inv@201@01 (Seq_index xs@193@01 j@200@01)) j@200@01)
      (img@202@01 (Seq_index xs@193@01 j@200@01))))
  :pattern ((Seq_index xs@193@01 j@200@01))
  :qid |quant-u-12837|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@202@01 r)
      (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
    (= (Seq_index xs@193@01 (inv@201@01 r)) r))
  :pattern ((inv@201@01 r))
  :qid |f-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((j@200@01 Int)) (!
  (=>
    (and (<= 0 j@200@01) (< j@200@01 (Seq_length xs@193@01)))
    (not (= (Seq_index xs@193@01 j@200@01) $Ref.null)))
  :pattern ((Seq_index xs@193@01 j@200@01))
  :qid |f-permImpliesNonNull|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
(assert (not (= x@196@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  $Snap.unit))
; [eval] x.elems == xs
(assert (Seq_equal
  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
  xs@193@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; xs[i1].f := 0
; [eval] xs[i1]
(push) ; 3
(assert (not (>= i1@194@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@203@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@193@01 i1@194@01))
    ($Perm.min
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        $Perm.Write
        $Perm.No)
      (pTaken@203@01 r))
    $Perm.No)
  
  :qid |quant-u-12839|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@203@01 r) $Perm.No)
  
  :qid |quant-u-12840|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (= (- $Perm.Write (pTaken@203@01 r)) $Perm.No))
  
  :qid |quant-u-12841|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@204@01 $FVF<f>)
; Definitional axioms for singleton-FVF's value
(assert (= ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)) 0))
; [exec]
; assert fun03qp(x, i2) == old(fun03qp(x, i2))
; [eval] fun03qp(x, i2) == old(fun03qp(x, i2))
; [eval] fun03qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(push) ; 4
(assert (not (<
  i2@195@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (<
  i2@195@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
(declare-const j@205@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 70 | !(0 <= j@205@01) | live]
; [else-branch: 70 | 0 <= j@205@01 | live]
(push) ; 6
; [then-branch: 70 | !(0 <= j@205@01)]
(assert (not (<= 0 j@205@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 70 | 0 <= j@205@01]
(assert (<= 0 j@205@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(push) ; 7
; [then-branch: 71 | !(j@205@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|) | live]
; [else-branch: 71 | j@205@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))| | live]
(push) ; 8
; [then-branch: 71 | !(j@205@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|)]
(assert (not
  (<
    j@205@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
(pop) ; 8
(push) ; 8
; [else-branch: 71 | j@205@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|]
(assert (<
  j@205@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (<
    j@205@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (not
    (<
      j@205@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@205@01)
  (and
    (<= 0 j@205@01)
    (or
      (<
        j@205@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (not
        (<
          j@205@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))))
(assert (or (<= 0 j@205@01) (not (<= 0 j@205@01))))
(assert (and
  (<= 0 j@205@01)
  (and
    (<
      j@205@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (= j@205@01 i2@195@01))))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@205@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@206@01 ($Ref) Int)
(declare-fun img@207@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@205@01 Int)) (!
  (=>
    (and
      (<= 0 j@205@01)
      (and
        (<
          j@205@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@205@01 i2@195@01)))
    (and
      (=>
        (<= 0 j@205@01)
        (and
          (<= 0 j@205@01)
          (or
            (<
              j@205@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (not
              (<
                j@205@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
      (or (<= 0 j@205@01) (not (<= 0 j@205@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@205@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@205@01 Int) (j2@205@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@205@01)
        (and
          (<
            j1@205@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j1@205@01 i2@195@01)))
      (and
        (<= 0 j2@205@01)
        (and
          (<
            j2@205@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j2@205@01 i2@195@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j1@205@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j2@205@01)))
    (= j1@205@01 j2@205@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@205@01 Int)) (!
  (=>
    (and
      (<= 0 j@205@01)
      (and
        (<
          j@205@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@205@01 i2@195@01)))
    (and
      (=
        (inv@206@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@205@01))
        j@205@01)
      (img@207@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@205@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@205@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@207@01 r)
      (and
        (<= 0 (inv@206@01 r))
        (and
          (<
            (inv@206@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@206@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@206@01 r))
      r))
  :pattern ((inv@206@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@205@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@205@01)
    (Seq_index xs@193@01 j@205@01))
  
  :qid |quant-u-12843|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@206@01 r))
        (and
          (<
            (inv@206@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@206@01 r) i2@195@01)))
      (img@207@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          (inv@206@01 r))))
    (>
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- $Perm.Write (pTaken@203@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12844|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@208@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@208@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@206@01 r))
          (and
            (<
              (inv@206@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@206@01 r) i2@195@01)))
        (img@207@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@206@01 r))
          (and
            (<
              (inv@206@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@206@01 r) i2@195@01)))
        (img@207@01 r))
      (Set_in r ($FVF.domain_f (as sm@208@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@208@01  $FVF<f>))))
  :qid |qp.fvfDomDef143|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@206@01 r))
          (and
            (<
              (inv@206@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@206@01 r) i2@195@01)))
        (img@207@01 r))
      (= r (Seq_index xs@193@01 i1@194@01)))
    (=
      ($FVF.lookup_f (as sm@208@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@208@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef141|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@206@01 r))
          (and
            (<
              (inv@206@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@206@01 r) i2@195@01)))
        (img@207@01 r))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (< $Perm.No (- $Perm.Write (pTaken@203@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@208@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@208@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef142|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@208@01  $FVF<f>))))) x@196@01 i2@195@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@205@01 Int)) (!
  (=>
    (and
      (<= 0 j@205@01)
      (and
        (<
          j@205@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@205@01 i2@195@01)))
    (and
      (=
        (inv@206@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@205@01))
        j@205@01)
      (img@207@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@205@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@205@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@207@01 r)
      (and
        (<= 0 (inv@206@01 r))
        (and
          (<
            (inv@206@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@206@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@206@01 r))
      r))
  :pattern ((inv@206@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@208@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@206@01 r))
          (and
            (<
              (inv@206@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@206@01 r) i2@195@01)))
        (img@207@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@206@01 r))
          (and
            (<
              (inv@206@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@206@01 r) i2@195@01)))
        (img@207@01 r))
      (Set_in r ($FVF.domain_f (as sm@208@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@208@01  $FVF<f>))))
  :qid |qp.fvfDomDef143|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@206@01 r))
          (and
            (<
              (inv@206@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@206@01 r) i2@195@01)))
        (img@207@01 r))
      (= r (Seq_index xs@193@01 i1@194@01)))
    (=
      ($FVF.lookup_f (as sm@208@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@208@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef141|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@206@01 r))
          (and
            (<
              (inv@206@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@206@01 r) i2@195@01)))
        (img@207@01 r))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (< $Perm.No (- $Perm.Write (pTaken@203@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@208@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@208@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef142|)))
(assert (and
  (<
    i2@195@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (forall ((j@205@01 Int)) (!
    (=>
      (and
        (<= 0 j@205@01)
        (and
          (<
            j@205@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j@205@01 i2@195@01)))
      (and
        (=>
          (<= 0 j@205@01)
          (and
            (<= 0 j@205@01)
            (or
              (<
                j@205@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (<
                  j@205@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
        (or (<= 0 j@205@01) (not (<= 0 j@205@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@205@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@208@01  $FVF<f>))))) x@196@01 i2@195@01)))
; [eval] old(fun03qp(x, i2))
; [eval] fun03qp(x, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@209@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 72 | !(0 <= j@209@01) | live]
; [else-branch: 72 | 0 <= j@209@01 | live]
(push) ; 6
; [then-branch: 72 | !(0 <= j@209@01)]
(assert (not (<= 0 j@209@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 72 | 0 <= j@209@01]
(assert (<= 0 j@209@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(push) ; 7
; [then-branch: 73 | !(j@209@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|) | live]
; [else-branch: 73 | j@209@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))| | live]
(push) ; 8
; [then-branch: 73 | !(j@209@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|)]
(assert (not
  (<
    j@209@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
(pop) ; 8
(push) ; 8
; [else-branch: 73 | j@209@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|]
(assert (<
  j@209@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (<
    j@209@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (not
    (<
      j@209@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@209@01)
  (and
    (<= 0 j@209@01)
    (or
      (<
        j@209@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (not
        (<
          j@209@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))))
(assert (or (<= 0 j@209@01) (not (<= 0 j@209@01))))
(assert (and
  (<= 0 j@209@01)
  (and
    (<
      j@209@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (= j@209@01 i2@195@01))))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@209@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@210@01 ($Ref) Int)
(declare-fun img@211@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@209@01 Int)) (!
  (=>
    (and
      (<= 0 j@209@01)
      (and
        (<
          j@209@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@209@01 i2@195@01)))
    (and
      (=>
        (<= 0 j@209@01)
        (and
          (<= 0 j@209@01)
          (or
            (<
              j@209@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (not
              (<
                j@209@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
      (or (<= 0 j@209@01) (not (<= 0 j@209@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@209@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@209@01 Int) (j2@209@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@209@01)
        (and
          (<
            j1@209@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j1@209@01 i2@195@01)))
      (and
        (<= 0 j2@209@01)
        (and
          (<
            j2@209@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j2@209@01 i2@195@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j1@209@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j2@209@01)))
    (= j1@209@01 j2@209@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@209@01 Int)) (!
  (=>
    (and
      (<= 0 j@209@01)
      (and
        (<
          j@209@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@209@01 i2@195@01)))
    (and
      (=
        (inv@210@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@209@01))
        j@209@01)
      (img@211@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@209@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@209@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@211@01 r)
      (and
        (<= 0 (inv@210@01 r))
        (and
          (<
            (inv@210@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@210@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@210@01 r))
      r))
  :pattern ((inv@210@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@209@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@209@01)
    (Seq_index xs@193@01 j@209@01))
  
  :qid |quant-u-12846|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@210@01 r))
        (and
          (<
            (inv@210@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@210@01 r) i2@195@01)))
      (img@211@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          (inv@210@01 r))))
    (>
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12847|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@212@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@212@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@210@01 r))
          (and
            (<
              (inv@210@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@210@01 r) i2@195@01)))
        (img@211@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@210@01 r))
          (and
            (<
              (inv@210@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@210@01 r) i2@195@01)))
        (img@211@01 r))
      (Set_in r ($FVF.domain_f (as sm@212@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@212@01  $FVF<f>))))
  :qid |qp.fvfDomDef145|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@210@01 r))
          (and
            (<
              (inv@210@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@210@01 r) i2@195@01)))
        (img@211@01 r))
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01)))))
    (=
      ($FVF.lookup_f (as sm@212@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@212@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef144|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@212@01  $FVF<f>))))) x@196@01 i2@195@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@209@01 Int)) (!
  (=>
    (and
      (<= 0 j@209@01)
      (and
        (<
          j@209@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@209@01 i2@195@01)))
    (and
      (=
        (inv@210@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@209@01))
        j@209@01)
      (img@211@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@209@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@209@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@211@01 r)
      (and
        (<= 0 (inv@210@01 r))
        (and
          (<
            (inv@210@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@210@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@210@01 r))
      r))
  :pattern ((inv@210@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@212@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@210@01 r))
          (and
            (<
              (inv@210@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@210@01 r) i2@195@01)))
        (img@211@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@210@01 r))
          (and
            (<
              (inv@210@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@210@01 r) i2@195@01)))
        (img@211@01 r))
      (Set_in r ($FVF.domain_f (as sm@212@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@212@01  $FVF<f>))))
  :qid |qp.fvfDomDef145|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@210@01 r))
          (and
            (<
              (inv@210@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@210@01 r) i2@195@01)))
        (img@211@01 r))
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01)))))
    (=
      ($FVF.lookup_f (as sm@212@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@212@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef144|)))
(assert (and
  (forall ((j@209@01 Int)) (!
    (=>
      (and
        (<= 0 j@209@01)
        (and
          (<
            j@209@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j@209@01 i2@195@01)))
      (and
        (=>
          (<= 0 j@209@01)
          (and
            (<= 0 j@209@01)
            (or
              (<
                j@209@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (<
                  j@209@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
        (or (<= 0 j@209@01) (not (<= 0 j@209@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@209@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@212@01  $FVF<f>))))) x@196@01 i2@195@01)))
(push) ; 3
(assert (not (=
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@208@01  $FVF<f>))))) x@196@01 i2@195@01)
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@212@01  $FVF<f>))))) x@196@01 i2@195@01))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (=
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@208@01  $FVF<f>))))) x@196@01 i2@195@01)
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@212@01  $FVF<f>))))) x@196@01 i2@195@01)))
; [exec]
; xs[i2].f := 0
; [eval] xs[i2]
(push) ; 3
(assert (not (>= i2@195@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(push) ; 3
(set-option :timeout 10)
(assert (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@213@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@193@01 i2@195@01))
    ($Perm.min
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (- $Perm.Write (pTaken@203@01 r))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@214@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@193@01 i2@195@01))
    ($Perm.min
      (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@213@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (- $Perm.Write (pTaken@203@01 r))
        $Perm.No)
      (pTaken@213@01 r))
    $Perm.No)
  
  :qid |quant-u-12849|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@213@01 r) $Perm.No)
  
  :qid |quant-u-12850|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (= (- $Perm.Write (pTaken@213@01 r)) $Perm.No))
  
  :qid |quant-u-12851|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@215@01 $FVF<f>)
; Definitional axioms for singleton-FVF's value
(assert (= ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)) 0))
; [exec]
; assert fun03qp(x, i2) == old(fun03qp(x, i2))
; [eval] fun03qp(x, i2) == old(fun03qp(x, i2))
; [eval] fun03qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@216@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 74 | !(0 <= j@216@01) | live]
; [else-branch: 74 | 0 <= j@216@01 | live]
(push) ; 6
; [then-branch: 74 | !(0 <= j@216@01)]
(assert (not (<= 0 j@216@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 74 | 0 <= j@216@01]
(assert (<= 0 j@216@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(push) ; 7
; [then-branch: 75 | !(j@216@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|) | live]
; [else-branch: 75 | j@216@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))| | live]
(push) ; 8
; [then-branch: 75 | !(j@216@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|)]
(assert (not
  (<
    j@216@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
(pop) ; 8
(push) ; 8
; [else-branch: 75 | j@216@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|]
(assert (<
  j@216@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (<
    j@216@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (not
    (<
      j@216@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@216@01)
  (and
    (<= 0 j@216@01)
    (or
      (<
        j@216@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (not
        (<
          j@216@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))))
(assert (or (<= 0 j@216@01) (not (<= 0 j@216@01))))
(assert (and
  (<= 0 j@216@01)
  (and
    (<
      j@216@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (= j@216@01 i2@195@01))))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@216@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@217@01 ($Ref) Int)
(declare-fun img@218@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@216@01 Int)) (!
  (=>
    (and
      (<= 0 j@216@01)
      (and
        (<
          j@216@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@216@01 i2@195@01)))
    (and
      (=>
        (<= 0 j@216@01)
        (and
          (<= 0 j@216@01)
          (or
            (<
              j@216@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (not
              (<
                j@216@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
      (or (<= 0 j@216@01) (not (<= 0 j@216@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@216@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@216@01 Int) (j2@216@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@216@01)
        (and
          (<
            j1@216@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j1@216@01 i2@195@01)))
      (and
        (<= 0 j2@216@01)
        (and
          (<
            j2@216@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j2@216@01 i2@195@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j1@216@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j2@216@01)))
    (= j1@216@01 j2@216@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@216@01 Int)) (!
  (=>
    (and
      (<= 0 j@216@01)
      (and
        (<
          j@216@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@216@01 i2@195@01)))
    (and
      (=
        (inv@217@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@216@01))
        j@216@01)
      (img@218@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@216@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@216@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@218@01 r)
      (and
        (<= 0 (inv@217@01 r))
        (and
          (<
            (inv@217@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@217@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@217@01 r))
      r))
  :pattern ((inv@217@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@216@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@216@01)
    (Seq_index xs@193@01 j@216@01))
  
  :qid |quant-u-12853|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@217@01 r))
        (and
          (<
            (inv@217@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@217@01 r) i2@195@01)))
      (img@218@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          (inv@217@01 r))))
    (>
      (+
        (+
          (ite
            (and
              (img@202@01 r)
              (and
                (<= 0 (inv@201@01 r))
                (< (inv@201@01 r) (Seq_length xs@193@01))))
            (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12854|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@219@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@219@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@217@01 r))
          (and
            (<
              (inv@217@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@217@01 r) i2@195@01)))
        (img@218@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@217@01 r))
          (and
            (<
              (inv@217@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@217@01 r) i2@195@01)))
        (img@218@01 r))
      (Set_in r ($FVF.domain_f (as sm@219@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@219@01  $FVF<f>))))
  :qid |qp.fvfDomDef149|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@217@01 r))
          (and
            (<
              (inv@217@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@217@01 r) i2@195@01)))
        (img@218@01 r))
      (= r (Seq_index xs@193@01 i2@195@01)))
    (=
      ($FVF.lookup_f (as sm@219@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@219@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef146|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@217@01 r))
          (and
            (<
              (inv@217@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@217@01 r) i2@195@01)))
        (img@218@01 r))
      (= r (Seq_index xs@193@01 i1@194@01)))
    (=
      ($FVF.lookup_f (as sm@219@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@219@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef147|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@217@01 r))
          (and
            (<
              (inv@217@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@217@01 r) i2@195@01)))
        (img@218@01 r))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@219@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@219@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef148|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@219@01  $FVF<f>))))) x@196@01 i2@195@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@216@01 Int)) (!
  (=>
    (and
      (<= 0 j@216@01)
      (and
        (<
          j@216@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@216@01 i2@195@01)))
    (and
      (=
        (inv@217@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@216@01))
        j@216@01)
      (img@218@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@216@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@216@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@218@01 r)
      (and
        (<= 0 (inv@217@01 r))
        (and
          (<
            (inv@217@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@217@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@217@01 r))
      r))
  :pattern ((inv@217@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@219@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@217@01 r))
          (and
            (<
              (inv@217@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@217@01 r) i2@195@01)))
        (img@218@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@217@01 r))
          (and
            (<
              (inv@217@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@217@01 r) i2@195@01)))
        (img@218@01 r))
      (Set_in r ($FVF.domain_f (as sm@219@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@219@01  $FVF<f>))))
  :qid |qp.fvfDomDef149|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@217@01 r))
          (and
            (<
              (inv@217@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@217@01 r) i2@195@01)))
        (img@218@01 r))
      (= r (Seq_index xs@193@01 i2@195@01)))
    (=
      ($FVF.lookup_f (as sm@219@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@219@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef146|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@217@01 r))
          (and
            (<
              (inv@217@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@217@01 r) i2@195@01)))
        (img@218@01 r))
      (= r (Seq_index xs@193@01 i1@194@01)))
    (=
      ($FVF.lookup_f (as sm@219@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@219@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef147|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@217@01 r))
          (and
            (<
              (inv@217@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@217@01 r) i2@195@01)))
        (img@218@01 r))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@219@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@219@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef148|)))
(assert (and
  (forall ((j@216@01 Int)) (!
    (=>
      (and
        (<= 0 j@216@01)
        (and
          (<
            j@216@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j@216@01 i2@195@01)))
      (and
        (=>
          (<= 0 j@216@01)
          (and
            (<= 0 j@216@01)
            (or
              (<
                j@216@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (<
                  j@216@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
        (or (<= 0 j@216@01) (not (<= 0 j@216@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@216@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@219@01  $FVF<f>))))) x@196@01 i2@195@01)))
; [eval] old(fun03qp(x, i2))
; [eval] fun03qp(x, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@220@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 76 | !(0 <= j@220@01) | live]
; [else-branch: 76 | 0 <= j@220@01 | live]
(push) ; 6
; [then-branch: 76 | !(0 <= j@220@01)]
(assert (not (<= 0 j@220@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 76 | 0 <= j@220@01]
(assert (<= 0 j@220@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(push) ; 7
; [then-branch: 77 | !(j@220@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|) | live]
; [else-branch: 77 | j@220@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))| | live]
(push) ; 8
; [then-branch: 77 | !(j@220@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|)]
(assert (not
  (<
    j@220@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
(pop) ; 8
(push) ; 8
; [else-branch: 77 | j@220@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|]
(assert (<
  j@220@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (<
    j@220@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (not
    (<
      j@220@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@220@01)
  (and
    (<= 0 j@220@01)
    (or
      (<
        j@220@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (not
        (<
          j@220@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))))
(assert (or (<= 0 j@220@01) (not (<= 0 j@220@01))))
(assert (and
  (<= 0 j@220@01)
  (and
    (<
      j@220@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (= j@220@01 i2@195@01))))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@220@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@221@01 ($Ref) Int)
(declare-fun img@222@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@220@01 Int)) (!
  (=>
    (and
      (<= 0 j@220@01)
      (and
        (<
          j@220@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@220@01 i2@195@01)))
    (and
      (=>
        (<= 0 j@220@01)
        (and
          (<= 0 j@220@01)
          (or
            (<
              j@220@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (not
              (<
                j@220@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
      (or (<= 0 j@220@01) (not (<= 0 j@220@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@220@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@220@01 Int) (j2@220@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@220@01)
        (and
          (<
            j1@220@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j1@220@01 i2@195@01)))
      (and
        (<= 0 j2@220@01)
        (and
          (<
            j2@220@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j2@220@01 i2@195@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j1@220@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j2@220@01)))
    (= j1@220@01 j2@220@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@220@01 Int)) (!
  (=>
    (and
      (<= 0 j@220@01)
      (and
        (<
          j@220@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@220@01 i2@195@01)))
    (and
      (=
        (inv@221@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@220@01))
        j@220@01)
      (img@222@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@220@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@220@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@222@01 r)
      (and
        (<= 0 (inv@221@01 r))
        (and
          (<
            (inv@221@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@221@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@221@01 r))
      r))
  :pattern ((inv@221@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@220@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@220@01)
    (Seq_index xs@193@01 j@220@01))
  
  :qid |quant-u-12856|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@221@01 r))
        (and
          (<
            (inv@221@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@221@01 r) i2@195@01)))
      (img@222@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          (inv@221@01 r))))
    (>
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12857|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@223@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@223@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@221@01 r))
          (and
            (<
              (inv@221@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@221@01 r) i2@195@01)))
        (img@222@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@221@01 r))
          (and
            (<
              (inv@221@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@221@01 r) i2@195@01)))
        (img@222@01 r))
      (Set_in r ($FVF.domain_f (as sm@223@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@223@01  $FVF<f>))))
  :qid |qp.fvfDomDef151|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@221@01 r))
          (and
            (<
              (inv@221@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@221@01 r) i2@195@01)))
        (img@222@01 r))
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01)))))
    (=
      ($FVF.lookup_f (as sm@223@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@223@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef150|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@223@01  $FVF<f>))))) x@196@01 i2@195@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@220@01 Int)) (!
  (=>
    (and
      (<= 0 j@220@01)
      (and
        (<
          j@220@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@220@01 i2@195@01)))
    (and
      (=
        (inv@221@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@220@01))
        j@220@01)
      (img@222@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@220@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@220@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@222@01 r)
      (and
        (<= 0 (inv@221@01 r))
        (and
          (<
            (inv@221@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@221@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@221@01 r))
      r))
  :pattern ((inv@221@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@223@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@221@01 r))
          (and
            (<
              (inv@221@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@221@01 r) i2@195@01)))
        (img@222@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@221@01 r))
          (and
            (<
              (inv@221@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@221@01 r) i2@195@01)))
        (img@222@01 r))
      (Set_in r ($FVF.domain_f (as sm@223@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@223@01  $FVF<f>))))
  :qid |qp.fvfDomDef151|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@221@01 r))
          (and
            (<
              (inv@221@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@221@01 r) i2@195@01)))
        (img@222@01 r))
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01)))))
    (=
      ($FVF.lookup_f (as sm@223@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@223@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef150|)))
(assert (and
  (forall ((j@220@01 Int)) (!
    (=>
      (and
        (<= 0 j@220@01)
        (and
          (<
            j@220@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j@220@01 i2@195@01)))
      (and
        (=>
          (<= 0 j@220@01)
          (and
            (<= 0 j@220@01)
            (or
              (<
                j@220@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (<
                  j@220@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
        (or (<= 0 j@220@01) (not (<= 0 j@220@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@220@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@223@01  $FVF<f>))))) x@196@01 i2@195@01)))
(push) ; 3
(assert (not (=
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@219@01  $FVF<f>))))) x@196@01 i2@195@01)
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@223@01  $FVF<f>))))) x@196@01 i2@195@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
(declare-const sm@224@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@224@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@224@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef152|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@224@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@224@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef153|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@224@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@224@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef154|)))
(declare-const pm@225@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@225@01  $FPM) r)
    (+
      (+
        (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
        $Perm.No)))
  :pattern (($FVF.perm_f (as pm@225@01  $FPM) r))
  :qid |qp.resPrmSumDef155|)))
(assert (<=
  ($FVF.perm_f (as pm@225@01  $FPM) (Seq_index xs@193@01 i2@195@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@225@01  $FPM) (Seq_index xs@193@01 i1@194@01))
  $Perm.Write))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@225@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun03qp(x, i2) == old(fun03qp(x, i2))
; [eval] fun03qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@226@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 78 | !(0 <= j@226@01) | live]
; [else-branch: 78 | 0 <= j@226@01 | live]
(push) ; 6
; [then-branch: 78 | !(0 <= j@226@01)]
(assert (not (<= 0 j@226@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(declare-const sm@227@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef156|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef157|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef158|)))
(declare-const pm@228@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@228@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@228@01  $FPM) r))
  :qid |qp.resPrmSumDef159|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@228@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@228@01  $FPM) (Seq_index xs@193@01 i1@194@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@228@01  $FPM) (Seq_index xs@193@01 i2@195@01))
  $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 78 | 0 <= j@226@01]
(assert (<= 0 j@226@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(declare-const sm@229@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef162|)))
(declare-const pm@230@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@230@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@230@01  $FPM) r))
  :qid |qp.resPrmSumDef163|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@230@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@230@01  $FPM) (Seq_index xs@193@01 i1@194@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@230@01  $FPM) (Seq_index xs@193@01 i2@195@01))
  $Perm.Write))
; [eval] j < |x.elems|
; [eval] |x.elems|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 79 | !(j@226@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|) | live]
; [else-branch: 79 | j@226@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))| | live]
(push) ; 8
; [then-branch: 79 | !(j@226@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|)]
(assert (not
  (<
    j@226@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 79 | j@226@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|]
(assert (<
  j@226@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  (not
    (<
      j@226@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
  (and
    (not
      (<
        j@226@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01))))))
; Joined path conditions
(assert (=>
  (<
    j@226@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (and
    (<
      j@226@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01))))))
(assert (or
  (<
    j@226@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (not
    (<
      j@226@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef156|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef157|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef158|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@228@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@228@01  $FPM) r))
  :qid |qp.resPrmSumDef159|)))
(assert (=>
  (not (<= 0 j@226@01))
  (and
    (not (<= 0 j@226@01))
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@228@01  $FPM) r) $Perm.Write)
      :pattern ((inv@201@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@228@01  $FPM) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@228@01  $FPM) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef162|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@230@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@230@01  $FPM) r))
  :qid |qp.resPrmSumDef163|)))
(assert (=>
  (<= 0 j@226@01)
  (and
    (<= 0 j@226@01)
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@230@01  $FPM) r) $Perm.Write)
      :pattern ((inv@201@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@230@01  $FPM) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@230@01  $FPM) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write)
    (=>
      (not
        (<
          j@226@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
      (and
        (not
          (<
            j@226@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
        (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
        (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
    (=>
      (<
        j@226@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (and
        (<
          j@226@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
        (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
    (or
      (<
        j@226@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (not
        (<
          j@226@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))))
(assert (or (<= 0 j@226@01) (not (<= 0 j@226@01))))
(assert (and
  (<= 0 j@226@01)
  (and
    (<
      j@226@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (= j@226@01 i2@195@01))))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@226@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@231@01 ($Ref) Int)
(declare-fun img@232@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef156|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef157|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef158|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@228@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@228@01  $FPM) r))
  :qid |qp.resPrmSumDef159|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef162|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@230@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@230@01  $FPM) r))
  :qid |qp.resPrmSumDef163|)))
; Nested auxiliary terms: non-globals
(assert (forall ((j@226@01 Int)) (!
  (=>
    (and
      (<= 0 j@226@01)
      (and
        (<
          j@226@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@226@01 i2@195@01)))
    (and
      (=>
        (not (<= 0 j@226@01))
        (and
          (not (<= 0 j@226@01))
          (not
            (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
          (not
            (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@228@01  $FPM) r) $Perm.Write)
            :pattern ((inv@201@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@228@01  $FPM) (Seq_index xs@193@01 i1@194@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@228@01  $FPM) (Seq_index xs@193@01 i2@195@01))
            $Perm.Write)))
      (=>
        (<= 0 j@226@01)
        (and
          (<= 0 j@226@01)
          (not
            (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
          (not
            (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@230@01  $FPM) r) $Perm.Write)
            :pattern ((inv@201@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@230@01  $FPM) (Seq_index xs@193@01 i1@194@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@230@01  $FPM) (Seq_index xs@193@01 i2@195@01))
            $Perm.Write)
          (=>
            (not
              (<
                j@226@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
            (and
              (not
                (<
                  j@226@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
              (not
                (=
                  (Seq_index xs@193@01 i2@195@01)
                  (Seq_index xs@193@01 i1@194@01)))
              (not
                (=
                  (Seq_index xs@193@01 i1@194@01)
                  (Seq_index xs@193@01 i2@195@01)))))
          (=>
            (<
              j@226@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (and
              (<
                j@226@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (=
                  (Seq_index xs@193@01 i2@195@01)
                  (Seq_index xs@193@01 i1@194@01)))
              (not
                (=
                  (Seq_index xs@193@01 i1@194@01)
                  (Seq_index xs@193@01 i2@195@01)))))
          (or
            (<
              j@226@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (not
              (<
                j@226@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
      (or (<= 0 j@226@01) (not (<= 0 j@226@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@226@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@226@01 Int) (j2@226@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@226@01)
        (and
          (<
            j1@226@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j1@226@01 i2@195@01)))
      (and
        (<= 0 j2@226@01)
        (and
          (<
            j2@226@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j2@226@01 i2@195@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j1@226@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j2@226@01)))
    (= j1@226@01 j2@226@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@226@01 Int)) (!
  (=>
    (and
      (<= 0 j@226@01)
      (and
        (<
          j@226@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@226@01 i2@195@01)))
    (and
      (=
        (inv@231@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@226@01))
        j@226@01)
      (img@232@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@226@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@226@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@232@01 r)
      (and
        (<= 0 (inv@231@01 r))
        (and
          (<
            (inv@231@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@231@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@231@01 r))
      r))
  :pattern ((inv@231@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@226@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@226@01)
    (Seq_index xs@193@01 j@226@01))
  
  :qid |quant-u-12859|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@231@01 r))
        (and
          (<
            (inv@231@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@231@01 r) i2@195@01)))
      (img@232@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          (inv@231@01 r))))
    (>
      (+
        (+
          (ite
            (and
              (img@202@01 r)
              (and
                (<= 0 (inv@201@01 r))
                (< (inv@201@01 r) (Seq_length xs@193@01))))
            (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12860|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@233@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@233@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@231@01 r))
          (and
            (<
              (inv@231@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@231@01 r) i2@195@01)))
        (img@232@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@231@01 r))
          (and
            (<
              (inv@231@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@231@01 r) i2@195@01)))
        (img@232@01 r))
      (Set_in r ($FVF.domain_f (as sm@233@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@233@01  $FVF<f>))))
  :qid |qp.fvfDomDef167|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@231@01 r))
          (and
            (<
              (inv@231@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@231@01 r) i2@195@01)))
        (img@232@01 r))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@233@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@233@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef164|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@231@01 r))
          (and
            (<
              (inv@231@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@231@01 r) i2@195@01)))
        (img@232@01 r))
      (= r (Seq_index xs@193@01 i1@194@01)))
    (=
      ($FVF.lookup_f (as sm@233@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@233@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef165|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@231@01 r))
          (and
            (<
              (inv@231@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@231@01 r) i2@195@01)))
        (img@232@01 r))
      (= r (Seq_index xs@193@01 i2@195@01)))
    (=
      ($FVF.lookup_f (as sm@233@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@233@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef166|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@233@01  $FVF<f>))))) x@196@01 i2@195@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef156|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef157|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@227@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@227@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef158|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@228@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@228@01  $FPM) r))
  :qid |qp.resPrmSumDef159|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef161|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@229@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@229@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef162|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@230@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@230@01  $FPM) r))
  :qid |qp.resPrmSumDef163|)))
(assert (forall ((j@226@01 Int)) (!
  (=>
    (and
      (<= 0 j@226@01)
      (and
        (<
          j@226@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@226@01 i2@195@01)))
    (and
      (=
        (inv@231@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@226@01))
        j@226@01)
      (img@232@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@226@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@226@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@232@01 r)
      (and
        (<= 0 (inv@231@01 r))
        (and
          (<
            (inv@231@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@231@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@231@01 r))
      r))
  :pattern ((inv@231@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@233@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@231@01 r))
          (and
            (<
              (inv@231@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@231@01 r) i2@195@01)))
        (img@232@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@231@01 r))
          (and
            (<
              (inv@231@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@231@01 r) i2@195@01)))
        (img@232@01 r))
      (Set_in r ($FVF.domain_f (as sm@233@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@233@01  $FVF<f>))))
  :qid |qp.fvfDomDef167|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@231@01 r))
          (and
            (<
              (inv@231@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@231@01 r) i2@195@01)))
        (img@232@01 r))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@233@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@233@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef164|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@231@01 r))
          (and
            (<
              (inv@231@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@231@01 r) i2@195@01)))
        (img@232@01 r))
      (= r (Seq_index xs@193@01 i1@194@01)))
    (=
      ($FVF.lookup_f (as sm@233@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@233@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef165|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@231@01 r))
          (and
            (<
              (inv@231@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@231@01 r) i2@195@01)))
        (img@232@01 r))
      (= r (Seq_index xs@193@01 i2@195@01)))
    (=
      ($FVF.lookup_f (as sm@233@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@233@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef166|)))
(assert (and
  (forall ((j@226@01 Int)) (!
    (=>
      (and
        (<= 0 j@226@01)
        (and
          (<
            j@226@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j@226@01 i2@195@01)))
      (and
        (=>
          (not (<= 0 j@226@01))
          (and
            (not (<= 0 j@226@01))
            (not
              (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
            (not
              (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@228@01  $FPM) r) $Perm.Write)
              :pattern ((inv@201@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@228@01  $FPM) (Seq_index xs@193@01 i1@194@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@228@01  $FPM) (Seq_index xs@193@01 i2@195@01))
              $Perm.Write)))
        (=>
          (<= 0 j@226@01)
          (and
            (<= 0 j@226@01)
            (not
              (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
            (not
              (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@230@01  $FPM) r) $Perm.Write)
              :pattern ((inv@201@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@230@01  $FPM) (Seq_index xs@193@01 i1@194@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@230@01  $FPM) (Seq_index xs@193@01 i2@195@01))
              $Perm.Write)
            (=>
              (not
                (<
                  j@226@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
              (and
                (not
                  (<
                    j@226@01
                    (Seq_length
                      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
                (not
                  (=
                    (Seq_index xs@193@01 i2@195@01)
                    (Seq_index xs@193@01 i1@194@01)))
                (not
                  (=
                    (Seq_index xs@193@01 i1@194@01)
                    (Seq_index xs@193@01 i2@195@01)))))
            (=>
              (<
                j@226@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (and
                (<
                  j@226@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
                (not
                  (=
                    (Seq_index xs@193@01 i2@195@01)
                    (Seq_index xs@193@01 i1@194@01)))
                (not
                  (=
                    (Seq_index xs@193@01 i1@194@01)
                    (Seq_index xs@193@01 i2@195@01)))))
            (or
              (<
                j@226@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (<
                  j@226@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
        (or (<= 0 j@226@01) (not (<= 0 j@226@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@226@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@233@01  $FVF<f>))))) x@196@01 i2@195@01)))
; [eval] old(fun03qp(x, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@234@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@202@01 r)
      (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
    (=
      ($FVF.lookup_f (as sm@234@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@234@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef168|)))
(declare-const pm@235@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@235@01  $FPM) r)
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@235@01  $FPM) r))
  :qid |qp.resPrmSumDef169|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@235@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun03qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@236@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 80 | !(0 <= j@236@01) | live]
; [else-branch: 80 | 0 <= j@236@01 | live]
(push) ; 6
; [then-branch: 80 | !(0 <= j@236@01)]
(assert (not (<= 0 j@236@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 80 | 0 <= j@236@01]
(assert (<= 0 j@236@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |x.elems|
; [eval] |x.elems|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 81 | !(j@236@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|) | live]
; [else-branch: 81 | j@236@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))| | live]
(push) ; 8
; [then-branch: 81 | !(j@236@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|)]
(assert (not
  (<
    j@236@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 81 | j@236@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|]
(assert (<
  j@236@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (<
    j@236@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (not
    (<
      j@236@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@236@01)
  (and
    (<= 0 j@236@01)
    (or
      (<
        j@236@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (not
        (<
          j@236@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))))
(assert (or (<= 0 j@236@01) (not (<= 0 j@236@01))))
(assert (and
  (<= 0 j@236@01)
  (and
    (<
      j@236@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (= j@236@01 i2@195@01))))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@236@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@237@01 ($Ref) Int)
(declare-fun img@238@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@236@01 Int)) (!
  (=>
    (and
      (<= 0 j@236@01)
      (and
        (<
          j@236@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@236@01 i2@195@01)))
    (and
      (=>
        (<= 0 j@236@01)
        (and
          (<= 0 j@236@01)
          (or
            (<
              j@236@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (not
              (<
                j@236@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
      (or (<= 0 j@236@01) (not (<= 0 j@236@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@236@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@236@01 Int) (j2@236@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@236@01)
        (and
          (<
            j1@236@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j1@236@01 i2@195@01)))
      (and
        (<= 0 j2@236@01)
        (and
          (<
            j2@236@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j2@236@01 i2@195@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j1@236@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j2@236@01)))
    (= j1@236@01 j2@236@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@236@01 Int)) (!
  (=>
    (and
      (<= 0 j@236@01)
      (and
        (<
          j@236@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@236@01 i2@195@01)))
    (and
      (=
        (inv@237@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@236@01))
        j@236@01)
      (img@238@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@236@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@236@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@238@01 r)
      (and
        (<= 0 (inv@237@01 r))
        (and
          (<
            (inv@237@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@237@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@237@01 r))
      r))
  :pattern ((inv@237@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@236@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@236@01)
    (Seq_index xs@193@01 j@236@01))
  
  :qid |quant-u-12862|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@237@01 r))
        (and
          (<
            (inv@237@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@237@01 r) i2@195@01)))
      (img@238@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          (inv@237@01 r))))
    (>
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12863|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@239@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@239@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@237@01 r))
          (and
            (<
              (inv@237@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@237@01 r) i2@195@01)))
        (img@238@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@237@01 r))
          (and
            (<
              (inv@237@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@237@01 r) i2@195@01)))
        (img@238@01 r))
      (Set_in r ($FVF.domain_f (as sm@239@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@239@01  $FVF<f>))))
  :qid |qp.fvfDomDef171|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@237@01 r))
          (and
            (<
              (inv@237@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@237@01 r) i2@195@01)))
        (img@238@01 r))
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01)))))
    (=
      ($FVF.lookup_f (as sm@239@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@239@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef170|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@239@01  $FVF<f>))))) x@196@01 i2@195@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@236@01 Int)) (!
  (=>
    (and
      (<= 0 j@236@01)
      (and
        (<
          j@236@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@236@01 i2@195@01)))
    (and
      (=
        (inv@237@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@236@01))
        j@236@01)
      (img@238@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@236@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@236@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@238@01 r)
      (and
        (<= 0 (inv@237@01 r))
        (and
          (<
            (inv@237@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@237@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@237@01 r))
      r))
  :pattern ((inv@237@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@239@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@237@01 r))
          (and
            (<
              (inv@237@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@237@01 r) i2@195@01)))
        (img@238@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@237@01 r))
          (and
            (<
              (inv@237@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@237@01 r) i2@195@01)))
        (img@238@01 r))
      (Set_in r ($FVF.domain_f (as sm@239@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@239@01  $FVF<f>))))
  :qid |qp.fvfDomDef171|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@237@01 r))
          (and
            (<
              (inv@237@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@237@01 r) i2@195@01)))
        (img@238@01 r))
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01)))))
    (=
      ($FVF.lookup_f (as sm@239@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@239@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef170|)))
(assert (and
  (forall ((j@236@01 Int)) (!
    (=>
      (and
        (<= 0 j@236@01)
        (and
          (<
            j@236@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j@236@01 i2@195@01)))
      (and
        (=>
          (<= 0 j@236@01)
          (and
            (<= 0 j@236@01)
            (or
              (<
                j@236@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (<
                  j@236@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
        (or (<= 0 j@236@01) (not (<= 0 j@236@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@236@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@239@01  $FVF<f>))))) x@196@01 i2@195@01)))
(push) ; 3
(assert (not (=
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@233@01  $FVF<f>))))) x@196@01 i2@195@01)
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@239@01  $FVF<f>))))) x@196@01 i2@195@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
(declare-const sm@240@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@240@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@240@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef172|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@240@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@240@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@240@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@240@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef174|)))
(declare-const pm@241@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@241@01  $FPM) r)
    (+
      (+
        (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
        $Perm.No)))
  :pattern (($FVF.perm_f (as pm@241@01  $FPM) r))
  :qid |qp.resPrmSumDef175|)))
(assert (<=
  ($FVF.perm_f (as pm@241@01  $FPM) (Seq_index xs@193@01 i2@195@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@241@01  $FPM) (Seq_index xs@193@01 i1@194@01))
  $Perm.Write))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@241@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun03qp(x, i2) == old(fun03qp(x, i2))
; [eval] fun03qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@242@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 82 | !(0 <= j@242@01) | live]
; [else-branch: 82 | 0 <= j@242@01 | live]
(push) ; 6
; [then-branch: 82 | !(0 <= j@242@01)]
(assert (not (<= 0 j@242@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 82 | 0 <= j@242@01]
(assert (<= 0 j@242@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |x.elems|
; [eval] |x.elems|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 83 | !(j@242@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|) | live]
; [else-branch: 83 | j@242@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))| | live]
(push) ; 8
; [then-branch: 83 | !(j@242@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|)]
(assert (not
  (<
    j@242@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(declare-const sm@243@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef178|)))
(declare-const pm@244@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@244@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@244@01  $FPM) r))
  :qid |qp.resPrmSumDef179|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@244@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@244@01  $FPM) (Seq_index xs@193@01 i1@194@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@244@01  $FPM) (Seq_index xs@193@01 i2@195@01))
  $Perm.Write))
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 83 | j@242@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|]
(assert (<
  j@242@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(declare-const sm@245@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef180|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef182|)))
(declare-const pm@246@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@246@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@246@01  $FPM) r))
  :qid |qp.resPrmSumDef183|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@246@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@246@01  $FPM) (Seq_index xs@193@01 i1@194@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@246@01  $FPM) (Seq_index xs@193@01 i2@195@01))
  $Perm.Write))
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@244@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@244@01  $FPM) r))
  :qid |qp.resPrmSumDef179|)))
(assert (=>
  (not
    (<
      j@242@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
  (and
    (not
      (<
        j@242@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@244@01  $FPM) r) $Perm.Write)
      :pattern ((inv@201@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@244@01  $FPM) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@244@01  $FPM) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef180|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@246@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@246@01  $FPM) r))
  :qid |qp.resPrmSumDef183|)))
(assert (=>
  (<
    j@242@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (and
    (<
      j@242@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@246@01  $FPM) r) $Perm.Write)
      :pattern ((inv@201@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@246@01  $FPM) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@246@01  $FPM) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write))))
(assert (or
  (<
    j@242@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (not
    (<
      j@242@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (not (<= 0 j@242@01))
  (and
    (not (<= 0 j@242@01))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01))))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@244@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@244@01  $FPM) r))
  :qid |qp.resPrmSumDef179|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef180|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@246@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@246@01  $FPM) r))
  :qid |qp.resPrmSumDef183|)))
(assert (=>
  (<= 0 j@242@01)
  (and
    (<= 0 j@242@01)
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
    (=>
      (not
        (<
          j@242@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
      (and
        (not
          (<
            j@242@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
        (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
        (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_f (as pm@244@01  $FPM) r) $Perm.Write)
          :pattern ((inv@201@01 r))
          :qid |qp-fld-prm-bnd|))
        (<=
          ($FVF.perm_f (as pm@244@01  $FPM) (Seq_index xs@193@01 i1@194@01))
          $Perm.Write)
        (<=
          ($FVF.perm_f (as pm@244@01  $FPM) (Seq_index xs@193@01 i2@195@01))
          $Perm.Write)))
    (=>
      (<
        j@242@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (and
        (<
          j@242@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
        (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_f (as pm@246@01  $FPM) r) $Perm.Write)
          :pattern ((inv@201@01 r))
          :qid |qp-fld-prm-bnd|))
        (<=
          ($FVF.perm_f (as pm@246@01  $FPM) (Seq_index xs@193@01 i1@194@01))
          $Perm.Write)
        (<=
          ($FVF.perm_f (as pm@246@01  $FPM) (Seq_index xs@193@01 i2@195@01))
          $Perm.Write)))
    (or
      (<
        j@242@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (not
        (<
          j@242@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))))
(assert (or (<= 0 j@242@01) (not (<= 0 j@242@01))))
(assert (and
  (<= 0 j@242@01)
  (and
    (<
      j@242@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (= j@242@01 i2@195@01))))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@242@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@247@01 ($Ref) Int)
(declare-fun img@248@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@244@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@244@01  $FPM) r))
  :qid |qp.resPrmSumDef179|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef180|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@246@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@246@01  $FPM) r))
  :qid |qp.resPrmSumDef183|)))
; Nested auxiliary terms: non-globals
(assert (forall ((j@242@01 Int)) (!
  (=>
    (and
      (<= 0 j@242@01)
      (and
        (<
          j@242@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@242@01 i2@195@01)))
    (and
      (=>
        (not (<= 0 j@242@01))
        (and
          (not (<= 0 j@242@01))
          (not
            (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
          (not
            (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
      (=>
        (<= 0 j@242@01)
        (and
          (<= 0 j@242@01)
          (not
            (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
          (not
            (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
          (=>
            (not
              (<
                j@242@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
            (and
              (not
                (<
                  j@242@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
              (not
                (=
                  (Seq_index xs@193@01 i1@194@01)
                  (Seq_index xs@193@01 i2@195@01)))
              (not
                (=
                  (Seq_index xs@193@01 i2@195@01)
                  (Seq_index xs@193@01 i1@194@01)))
              (forall ((r $Ref)) (!
                (<= ($FVF.perm_f (as pm@244@01  $FPM) r) $Perm.Write)
                :pattern ((inv@201@01 r))
                :qid |qp-fld-prm-bnd|))
              (<=
                ($FVF.perm_f (as pm@244@01  $FPM) (Seq_index xs@193@01 i1@194@01))
                $Perm.Write)
              (<=
                ($FVF.perm_f (as pm@244@01  $FPM) (Seq_index xs@193@01 i2@195@01))
                $Perm.Write)))
          (=>
            (<
              j@242@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (and
              (<
                j@242@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (=
                  (Seq_index xs@193@01 i1@194@01)
                  (Seq_index xs@193@01 i2@195@01)))
              (not
                (=
                  (Seq_index xs@193@01 i2@195@01)
                  (Seq_index xs@193@01 i1@194@01)))
              (forall ((r $Ref)) (!
                (<= ($FVF.perm_f (as pm@246@01  $FPM) r) $Perm.Write)
                :pattern ((inv@201@01 r))
                :qid |qp-fld-prm-bnd|))
              (<=
                ($FVF.perm_f (as pm@246@01  $FPM) (Seq_index xs@193@01 i1@194@01))
                $Perm.Write)
              (<=
                ($FVF.perm_f (as pm@246@01  $FPM) (Seq_index xs@193@01 i2@195@01))
                $Perm.Write)))
          (or
            (<
              j@242@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (not
              (<
                j@242@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
      (or (<= 0 j@242@01) (not (<= 0 j@242@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@242@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@242@01 Int) (j2@242@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@242@01)
        (and
          (<
            j1@242@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j1@242@01 i2@195@01)))
      (and
        (<= 0 j2@242@01)
        (and
          (<
            j2@242@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j2@242@01 i2@195@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j1@242@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j2@242@01)))
    (= j1@242@01 j2@242@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@242@01 Int)) (!
  (=>
    (and
      (<= 0 j@242@01)
      (and
        (<
          j@242@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@242@01 i2@195@01)))
    (and
      (=
        (inv@247@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@242@01))
        j@242@01)
      (img@248@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@242@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@242@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@248@01 r)
      (and
        (<= 0 (inv@247@01 r))
        (and
          (<
            (inv@247@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@247@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@247@01 r))
      r))
  :pattern ((inv@247@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@242@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@242@01)
    (Seq_index xs@193@01 j@242@01))
  
  :qid |quant-u-12865|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@247@01 r))
        (and
          (<
            (inv@247@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@247@01 r) i2@195@01)))
      (img@248@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          (inv@247@01 r))))
    (>
      (+
        (+
          (ite
            (and
              (img@202@01 r)
              (and
                (<= 0 (inv@201@01 r))
                (< (inv@201@01 r) (Seq_length xs@193@01))))
            (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12866|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@249@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@249@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@247@01 r))
          (and
            (<
              (inv@247@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@247@01 r) i2@195@01)))
        (img@248@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@247@01 r))
          (and
            (<
              (inv@247@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@247@01 r) i2@195@01)))
        (img@248@01 r))
      (Set_in r ($FVF.domain_f (as sm@249@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@249@01  $FVF<f>))))
  :qid |qp.fvfDomDef187|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@247@01 r))
          (and
            (<
              (inv@247@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@247@01 r) i2@195@01)))
        (img@248@01 r))
      (= r (Seq_index xs@193@01 i2@195@01)))
    (=
      ($FVF.lookup_f (as sm@249@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@249@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@247@01 r))
          (and
            (<
              (inv@247@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@247@01 r) i2@195@01)))
        (img@248@01 r))
      (= r (Seq_index xs@193@01 i1@194@01)))
    (=
      ($FVF.lookup_f (as sm@249@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@249@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef185|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@247@01 r))
          (and
            (<
              (inv@247@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@247@01 r) i2@195@01)))
        (img@248@01 r))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@249@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@249@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef186|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@249@01  $FVF<f>))))) x@196@01 i2@195@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef176|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef177|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@243@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@243@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@244@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@244@01  $FPM) r))
  :qid |qp.resPrmSumDef179|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef180|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef181|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@245@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@245@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef182|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@246@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@246@01  $FPM) r))
  :qid |qp.resPrmSumDef183|)))
(assert (forall ((j@242@01 Int)) (!
  (=>
    (and
      (<= 0 j@242@01)
      (and
        (<
          j@242@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@242@01 i2@195@01)))
    (and
      (=
        (inv@247@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@242@01))
        j@242@01)
      (img@248@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@242@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@242@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@248@01 r)
      (and
        (<= 0 (inv@247@01 r))
        (and
          (<
            (inv@247@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@247@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@247@01 r))
      r))
  :pattern ((inv@247@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@249@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@247@01 r))
          (and
            (<
              (inv@247@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@247@01 r) i2@195@01)))
        (img@248@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@247@01 r))
          (and
            (<
              (inv@247@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@247@01 r) i2@195@01)))
        (img@248@01 r))
      (Set_in r ($FVF.domain_f (as sm@249@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@249@01  $FVF<f>))))
  :qid |qp.fvfDomDef187|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@247@01 r))
          (and
            (<
              (inv@247@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@247@01 r) i2@195@01)))
        (img@248@01 r))
      (= r (Seq_index xs@193@01 i2@195@01)))
    (=
      ($FVF.lookup_f (as sm@249@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@249@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef184|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@247@01 r))
          (and
            (<
              (inv@247@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@247@01 r) i2@195@01)))
        (img@248@01 r))
      (= r (Seq_index xs@193@01 i1@194@01)))
    (=
      ($FVF.lookup_f (as sm@249@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@249@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef185|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@247@01 r))
          (and
            (<
              (inv@247@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@247@01 r) i2@195@01)))
        (img@248@01 r))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@249@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@249@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef186|)))
(assert (and
  (forall ((j@242@01 Int)) (!
    (=>
      (and
        (<= 0 j@242@01)
        (and
          (<
            j@242@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j@242@01 i2@195@01)))
      (and
        (=>
          (not (<= 0 j@242@01))
          (and
            (not (<= 0 j@242@01))
            (not
              (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
            (not
              (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
        (=>
          (<= 0 j@242@01)
          (and
            (<= 0 j@242@01)
            (not
              (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
            (not
              (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
            (=>
              (not
                (<
                  j@242@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
              (and
                (not
                  (<
                    j@242@01
                    (Seq_length
                      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
                (not
                  (=
                    (Seq_index xs@193@01 i1@194@01)
                    (Seq_index xs@193@01 i2@195@01)))
                (not
                  (=
                    (Seq_index xs@193@01 i2@195@01)
                    (Seq_index xs@193@01 i1@194@01)))
                (forall ((r $Ref)) (!
                  (<= ($FVF.perm_f (as pm@244@01  $FPM) r) $Perm.Write)
                  :pattern ((inv@201@01 r))
                  :qid |qp-fld-prm-bnd|))
                (<=
                  ($FVF.perm_f (as pm@244@01  $FPM) (Seq_index
                    xs@193@01
                    i1@194@01))
                  $Perm.Write)
                (<=
                  ($FVF.perm_f (as pm@244@01  $FPM) (Seq_index
                    xs@193@01
                    i2@195@01))
                  $Perm.Write)))
            (=>
              (<
                j@242@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (and
                (<
                  j@242@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
                (not
                  (=
                    (Seq_index xs@193@01 i1@194@01)
                    (Seq_index xs@193@01 i2@195@01)))
                (not
                  (=
                    (Seq_index xs@193@01 i2@195@01)
                    (Seq_index xs@193@01 i1@194@01)))
                (forall ((r $Ref)) (!
                  (<= ($FVF.perm_f (as pm@246@01  $FPM) r) $Perm.Write)
                  :pattern ((inv@201@01 r))
                  :qid |qp-fld-prm-bnd|))
                (<=
                  ($FVF.perm_f (as pm@246@01  $FPM) (Seq_index
                    xs@193@01
                    i1@194@01))
                  $Perm.Write)
                (<=
                  ($FVF.perm_f (as pm@246@01  $FPM) (Seq_index
                    xs@193@01
                    i2@195@01))
                  $Perm.Write)))
            (or
              (<
                j@242@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (<
                  j@242@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
        (or (<= 0 j@242@01) (not (<= 0 j@242@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@242@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@249@01  $FVF<f>))))) x@196@01 i2@195@01)))
; [eval] old(fun03qp(x, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@250@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@202@01 r)
      (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
    (=
      ($FVF.lookup_f (as sm@250@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@250@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef188|)))
(declare-const pm@251@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@251@01  $FPM) r)
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@251@01  $FPM) r))
  :qid |qp.resPrmSumDef189|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@251@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun03qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@252@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 84 | !(0 <= j@252@01) | live]
; [else-branch: 84 | 0 <= j@252@01 | live]
(push) ; 6
; [then-branch: 84 | !(0 <= j@252@01)]
(assert (not (<= 0 j@252@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 84 | 0 <= j@252@01]
(assert (<= 0 j@252@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |x.elems|
; [eval] |x.elems|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 85 | !(j@252@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|) | live]
; [else-branch: 85 | j@252@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))| | live]
(push) ; 8
; [then-branch: 85 | !(j@252@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|)]
(assert (not
  (<
    j@252@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 85 | j@252@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|]
(assert (<
  j@252@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (<
    j@252@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (not
    (<
      j@252@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@252@01)
  (and
    (<= 0 j@252@01)
    (or
      (<
        j@252@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (not
        (<
          j@252@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))))
(assert (or (<= 0 j@252@01) (not (<= 0 j@252@01))))
(assert (and
  (<= 0 j@252@01)
  (and
    (<
      j@252@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (= j@252@01 i2@195@01))))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@252@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@253@01 ($Ref) Int)
(declare-fun img@254@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@252@01 Int)) (!
  (=>
    (and
      (<= 0 j@252@01)
      (and
        (<
          j@252@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@252@01 i2@195@01)))
    (and
      (=>
        (<= 0 j@252@01)
        (and
          (<= 0 j@252@01)
          (or
            (<
              j@252@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (not
              (<
                j@252@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
      (or (<= 0 j@252@01) (not (<= 0 j@252@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@252@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@252@01 Int) (j2@252@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@252@01)
        (and
          (<
            j1@252@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j1@252@01 i2@195@01)))
      (and
        (<= 0 j2@252@01)
        (and
          (<
            j2@252@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j2@252@01 i2@195@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j1@252@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j2@252@01)))
    (= j1@252@01 j2@252@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@252@01 Int)) (!
  (=>
    (and
      (<= 0 j@252@01)
      (and
        (<
          j@252@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@252@01 i2@195@01)))
    (and
      (=
        (inv@253@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@252@01))
        j@252@01)
      (img@254@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@252@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@252@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@254@01 r)
      (and
        (<= 0 (inv@253@01 r))
        (and
          (<
            (inv@253@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@253@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@253@01 r))
      r))
  :pattern ((inv@253@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@252@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@252@01)
    (Seq_index xs@193@01 j@252@01))
  
  :qid |quant-u-12868|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@253@01 r))
        (and
          (<
            (inv@253@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@253@01 r) i2@195@01)))
      (img@254@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          (inv@253@01 r))))
    (>
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12869|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@255@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@255@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@253@01 r))
          (and
            (<
              (inv@253@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@253@01 r) i2@195@01)))
        (img@254@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@253@01 r))
          (and
            (<
              (inv@253@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@253@01 r) i2@195@01)))
        (img@254@01 r))
      (Set_in r ($FVF.domain_f (as sm@255@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@255@01  $FVF<f>))))
  :qid |qp.fvfDomDef191|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@253@01 r))
          (and
            (<
              (inv@253@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@253@01 r) i2@195@01)))
        (img@254@01 r))
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01)))))
    (=
      ($FVF.lookup_f (as sm@255@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@255@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef190|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@255@01  $FVF<f>))))) x@196@01 i2@195@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@252@01 Int)) (!
  (=>
    (and
      (<= 0 j@252@01)
      (and
        (<
          j@252@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@252@01 i2@195@01)))
    (and
      (=
        (inv@253@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@252@01))
        j@252@01)
      (img@254@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@252@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@252@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@254@01 r)
      (and
        (<= 0 (inv@253@01 r))
        (and
          (<
            (inv@253@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@253@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@253@01 r))
      r))
  :pattern ((inv@253@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@255@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@253@01 r))
          (and
            (<
              (inv@253@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@253@01 r) i2@195@01)))
        (img@254@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@253@01 r))
          (and
            (<
              (inv@253@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@253@01 r) i2@195@01)))
        (img@254@01 r))
      (Set_in r ($FVF.domain_f (as sm@255@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@255@01  $FVF<f>))))
  :qid |qp.fvfDomDef191|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@253@01 r))
          (and
            (<
              (inv@253@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@253@01 r) i2@195@01)))
        (img@254@01 r))
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01)))))
    (=
      ($FVF.lookup_f (as sm@255@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@255@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef190|)))
(assert (and
  (forall ((j@252@01 Int)) (!
    (=>
      (and
        (<= 0 j@252@01)
        (and
          (<
            j@252@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j@252@01 i2@195@01)))
      (and
        (=>
          (<= 0 j@252@01)
          (and
            (<= 0 j@252@01)
            (or
              (<
                j@252@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (<
                  j@252@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
        (or (<= 0 j@252@01) (not (<= 0 j@252@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@252@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@255@01  $FVF<f>))))) x@196@01 i2@195@01)))
(push) ; 3
(assert (not (=
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@249@01  $FVF<f>))))) x@196@01 i2@195@01)
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@255@01  $FVF<f>))))) x@196@01 i2@195@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] fun03qp(x, i2) == old(fun03qp(x, i2))
; [eval] fun03qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@256@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 86 | !(0 <= j@256@01) | live]
; [else-branch: 86 | 0 <= j@256@01 | live]
(push) ; 6
; [then-branch: 86 | !(0 <= j@256@01)]
(assert (not (<= 0 j@256@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(declare-const sm@257@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef193|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef194|)))
(declare-const pm@258@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@258@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@258@01  $FPM) r))
  :qid |qp.resPrmSumDef195|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@258@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@258@01  $FPM) (Seq_index xs@193@01 i1@194@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@258@01  $FPM) (Seq_index xs@193@01 i2@195@01))
  $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 86 | 0 <= j@256@01]
(assert (<= 0 j@256@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.01s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(declare-const sm@259@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef198|)))
(declare-const pm@260@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@260@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@260@01  $FPM) r))
  :qid |qp.resPrmSumDef199|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@260@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@260@01  $FPM) (Seq_index xs@193@01 i1@194@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@260@01  $FPM) (Seq_index xs@193@01 i2@195@01))
  $Perm.Write))
; [eval] j < |x.elems|
; [eval] |x.elems|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 87 | !(j@256@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|) | live]
; [else-branch: 87 | j@256@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))| | live]
(push) ; 8
; [then-branch: 87 | !(j@256@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|)]
(assert (not
  (<
    j@256@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 87 | j@256@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|]
(assert (<
  j@256@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01))
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01))
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 9
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i1@194@01))
    (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i2@195@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) (Seq_index xs@193@01 i1@194@01))
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) (Seq_index xs@193@01 i2@195@01)))))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
  (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (=>
  (not
    (<
      j@256@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
  (and
    (not
      (<
        j@256@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01))))))
; Joined path conditions
(assert (=>
  (<
    j@256@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (and
    (<
      j@256@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01))))))
(assert (or
  (<
    j@256@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (not
    (<
      j@256@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef193|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@258@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@258@01  $FPM) r))
  :qid |qp.resPrmSumDef195|)))
(assert (=>
  (not (<= 0 j@256@01))
  (and
    (not (<= 0 j@256@01))
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@258@01  $FPM) r) $Perm.Write)
      :pattern ((inv@201@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@258@01  $FPM) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@258@01  $FPM) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef198|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@260@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@260@01  $FPM) r))
  :qid |qp.resPrmSumDef199|)))
(assert (=>
  (<= 0 j@256@01)
  (and
    (<= 0 j@256@01)
    (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
    (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@260@01  $FPM) r) $Perm.Write)
      :pattern ((inv@201@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@260@01  $FPM) (Seq_index xs@193@01 i1@194@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@260@01  $FPM) (Seq_index xs@193@01 i2@195@01))
      $Perm.Write)
    (=>
      (not
        (<
          j@256@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
      (and
        (not
          (<
            j@256@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
        (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
        (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
    (=>
      (<
        j@256@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (and
        (<
          j@256@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (not (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
        (not (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))))
    (or
      (<
        j@256@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (not
        (<
          j@256@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))))
(assert (or (<= 0 j@256@01) (not (<= 0 j@256@01))))
(assert (and
  (<= 0 j@256@01)
  (and
    (<
      j@256@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (= j@256@01 i2@195@01))))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@256@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@261@01 ($Ref) Int)
(declare-fun img@262@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef193|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@258@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@258@01  $FPM) r))
  :qid |qp.resPrmSumDef195|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef198|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@260@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@260@01  $FPM) r))
  :qid |qp.resPrmSumDef199|)))
; Nested auxiliary terms: non-globals
(assert (forall ((j@256@01 Int)) (!
  (=>
    (and
      (<= 0 j@256@01)
      (and
        (<
          j@256@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@256@01 i2@195@01)))
    (and
      (=>
        (not (<= 0 j@256@01))
        (and
          (not (<= 0 j@256@01))
          (not
            (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
          (not
            (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@258@01  $FPM) r) $Perm.Write)
            :pattern ((inv@201@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@258@01  $FPM) (Seq_index xs@193@01 i1@194@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@258@01  $FPM) (Seq_index xs@193@01 i2@195@01))
            $Perm.Write)))
      (=>
        (<= 0 j@256@01)
        (and
          (<= 0 j@256@01)
          (not
            (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
          (not
            (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@260@01  $FPM) r) $Perm.Write)
            :pattern ((inv@201@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@260@01  $FPM) (Seq_index xs@193@01 i1@194@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@260@01  $FPM) (Seq_index xs@193@01 i2@195@01))
            $Perm.Write)
          (=>
            (not
              (<
                j@256@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
            (and
              (not
                (<
                  j@256@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
              (not
                (=
                  (Seq_index xs@193@01 i2@195@01)
                  (Seq_index xs@193@01 i1@194@01)))
              (not
                (=
                  (Seq_index xs@193@01 i1@194@01)
                  (Seq_index xs@193@01 i2@195@01)))))
          (=>
            (<
              j@256@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (and
              (<
                j@256@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (=
                  (Seq_index xs@193@01 i2@195@01)
                  (Seq_index xs@193@01 i1@194@01)))
              (not
                (=
                  (Seq_index xs@193@01 i1@194@01)
                  (Seq_index xs@193@01 i2@195@01)))))
          (or
            (<
              j@256@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (not
              (<
                j@256@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
      (or (<= 0 j@256@01) (not (<= 0 j@256@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@256@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@256@01 Int) (j2@256@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@256@01)
        (and
          (<
            j1@256@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j1@256@01 i2@195@01)))
      (and
        (<= 0 j2@256@01)
        (and
          (<
            j2@256@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j2@256@01 i2@195@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j1@256@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j2@256@01)))
    (= j1@256@01 j2@256@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@256@01 Int)) (!
  (=>
    (and
      (<= 0 j@256@01)
      (and
        (<
          j@256@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@256@01 i2@195@01)))
    (and
      (=
        (inv@261@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@256@01))
        j@256@01)
      (img@262@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@256@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@256@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@262@01 r)
      (and
        (<= 0 (inv@261@01 r))
        (and
          (<
            (inv@261@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@261@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@261@01 r))
      r))
  :pattern ((inv@261@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@256@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@256@01)
    (Seq_index xs@193@01 j@256@01))
  
  :qid |quant-u-12871|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@261@01 r))
        (and
          (<
            (inv@261@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@261@01 r) i2@195@01)))
      (img@262@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          (inv@261@01 r))))
    (>
      (+
        (+
          (ite
            (and
              (img@202@01 r)
              (and
                (<= 0 (inv@201@01 r))
                (< (inv@201@01 r) (Seq_length xs@193@01))))
            (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12872|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@263@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@263@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@261@01 r))
          (and
            (<
              (inv@261@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@261@01 r) i2@195@01)))
        (img@262@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@261@01 r))
          (and
            (<
              (inv@261@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@261@01 r) i2@195@01)))
        (img@262@01 r))
      (Set_in r ($FVF.domain_f (as sm@263@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@263@01  $FVF<f>))))
  :qid |qp.fvfDomDef203|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@261@01 r))
          (and
            (<
              (inv@261@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@261@01 r) i2@195@01)))
        (img@262@01 r))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@263@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@263@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef200|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@261@01 r))
          (and
            (<
              (inv@261@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@261@01 r) i2@195@01)))
        (img@262@01 r))
      (= r (Seq_index xs@193@01 i1@194@01)))
    (=
      ($FVF.lookup_f (as sm@263@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@263@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef201|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@261@01 r))
          (and
            (<
              (inv@261@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@261@01 r) i2@195@01)))
        (img@262@01 r))
      (= r (Seq_index xs@193@01 i2@195@01)))
    (=
      ($FVF.lookup_f (as sm@263@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@263@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef202|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@263@01  $FVF<f>))))) x@196@01 i2@195@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef192|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef193|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@257@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@257@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef194|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@258@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@258@01  $FPM) r))
  :qid |qp.resPrmSumDef195|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef196|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i1@194@01))
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef197|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@193@01 i2@195@01))
    (=
      ($FVF.lookup_f (as sm@259@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@259@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef198|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@260@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@202@01 r)
            (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
          (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@193@01 i1@194@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@193@01 i2@195@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@260@01  $FPM) r))
  :qid |qp.resPrmSumDef199|)))
(assert (forall ((j@256@01 Int)) (!
  (=>
    (and
      (<= 0 j@256@01)
      (and
        (<
          j@256@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@256@01 i2@195@01)))
    (and
      (=
        (inv@261@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@256@01))
        j@256@01)
      (img@262@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@256@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@256@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@262@01 r)
      (and
        (<= 0 (inv@261@01 r))
        (and
          (<
            (inv@261@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@261@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@261@01 r))
      r))
  :pattern ((inv@261@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@263@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@261@01 r))
          (and
            (<
              (inv@261@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@261@01 r) i2@195@01)))
        (img@262@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@261@01 r))
          (and
            (<
              (inv@261@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@261@01 r) i2@195@01)))
        (img@262@01 r))
      (Set_in r ($FVF.domain_f (as sm@263@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@263@01  $FVF<f>))))
  :qid |qp.fvfDomDef203|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@261@01 r))
          (and
            (<
              (inv@261@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@261@01 r) i2@195@01)))
        (img@262@01 r))
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@203@01 r)) (pTaken@213@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@263@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@263@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef200|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@261@01 r))
          (and
            (<
              (inv@261@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@261@01 r) i2@195@01)))
        (img@262@01 r))
      (= r (Seq_index xs@193@01 i1@194@01)))
    (=
      ($FVF.lookup_f (as sm@263@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@204@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@263@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@204@01  $FVF<f>) r))
  :qid |qp.fvfValDef201|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@261@01 r))
          (and
            (<
              (inv@261@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@261@01 r) i2@195@01)))
        (img@262@01 r))
      (= r (Seq_index xs@193@01 i2@195@01)))
    (=
      ($FVF.lookup_f (as sm@263@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@215@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@263@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@215@01  $FVF<f>) r))
  :qid |qp.fvfValDef202|)))
(assert (and
  (forall ((j@256@01 Int)) (!
    (=>
      (and
        (<= 0 j@256@01)
        (and
          (<
            j@256@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j@256@01 i2@195@01)))
      (and
        (=>
          (not (<= 0 j@256@01))
          (and
            (not (<= 0 j@256@01))
            (not
              (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
            (not
              (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@258@01  $FPM) r) $Perm.Write)
              :pattern ((inv@201@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@258@01  $FPM) (Seq_index xs@193@01 i1@194@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@258@01  $FPM) (Seq_index xs@193@01 i2@195@01))
              $Perm.Write)))
        (=>
          (<= 0 j@256@01)
          (and
            (<= 0 j@256@01)
            (not
              (= (Seq_index xs@193@01 i1@194@01) (Seq_index xs@193@01 i2@195@01)))
            (not
              (= (Seq_index xs@193@01 i2@195@01) (Seq_index xs@193@01 i1@194@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@260@01  $FPM) r) $Perm.Write)
              :pattern ((inv@201@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@260@01  $FPM) (Seq_index xs@193@01 i1@194@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@260@01  $FPM) (Seq_index xs@193@01 i2@195@01))
              $Perm.Write)
            (=>
              (not
                (<
                  j@256@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
              (and
                (not
                  (<
                    j@256@01
                    (Seq_length
                      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
                (not
                  (=
                    (Seq_index xs@193@01 i2@195@01)
                    (Seq_index xs@193@01 i1@194@01)))
                (not
                  (=
                    (Seq_index xs@193@01 i1@194@01)
                    (Seq_index xs@193@01 i2@195@01)))))
            (=>
              (<
                j@256@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (and
                (<
                  j@256@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
                (not
                  (=
                    (Seq_index xs@193@01 i2@195@01)
                    (Seq_index xs@193@01 i1@194@01)))
                (not
                  (=
                    (Seq_index xs@193@01 i1@194@01)
                    (Seq_index xs@193@01 i2@195@01)))))
            (or
              (<
                j@256@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (<
                  j@256@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
        (or (<= 0 j@256@01) (not (<= 0 j@256@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@256@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@263@01  $FVF<f>))))) x@196@01 i2@195@01)))
; [eval] old(fun03qp(x, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@264@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@202@01 r)
      (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
    (=
      ($FVF.lookup_f (as sm@264@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@264@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef204|)))
(declare-const pm@265@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@265@01  $FPM) r)
    (ite
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@265@01  $FPM) r))
  :qid |qp.resPrmSumDef205|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@265@01  $FPM) r) $Perm.Write)
  :pattern ((inv@201@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun03qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@266@01 Int)
(push) ; 4
; [eval] 0 <= j && (j < |x.elems| && j == i)
; [eval] 0 <= j
(push) ; 5
; [then-branch: 88 | !(0 <= j@266@01) | live]
; [else-branch: 88 | 0 <= j@266@01 | live]
(push) ; 6
; [then-branch: 88 | !(0 <= j@266@01)]
(assert (not (<= 0 j@266@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 88 | 0 <= j@266@01]
(assert (<= 0 j@266@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |x.elems|
; [eval] |x.elems|
(set-option :timeout 0)
(push) ; 7
; [then-branch: 89 | !(j@266@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|) | live]
; [else-branch: 89 | j@266@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))| | live]
(push) ; 8
; [then-branch: 89 | !(j@266@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|)]
(assert (not
  (<
    j@266@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 8
(set-option :timeout 0)
(push) ; 8
; [else-branch: 89 | j@266@01 < |First:(Second:(Second:(Second:(Second:(Second:(Second:(Second:($t@197@01))))))))|]
(assert (<
  j@266@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j == i
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (or
  (<
    j@266@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
  (not
    (<
      j@266@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (=>
  (<= 0 j@266@01)
  (and
    (<= 0 j@266@01)
    (or
      (<
        j@266@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
      (not
        (<
          j@266@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))))))))))
(assert (or (<= 0 j@266@01) (not (<= 0 j@266@01))))
(assert (and
  (<= 0 j@266@01)
  (and
    (<
      j@266@01
      (Seq_length
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
    (= j@266@01 i2@195@01))))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@266@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@267@01 ($Ref) Int)
(declare-fun img@268@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@266@01 Int)) (!
  (=>
    (and
      (<= 0 j@266@01)
      (and
        (<
          j@266@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@266@01 i2@195@01)))
    (and
      (=>
        (<= 0 j@266@01)
        (and
          (<= 0 j@266@01)
          (or
            (<
              j@266@01
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (not
              (<
                j@266@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
      (or (<= 0 j@266@01) (not (<= 0 j@266@01)))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@266@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@266@01 Int) (j2@266@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j1@266@01)
        (and
          (<
            j1@266@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j1@266@01 i2@195@01)))
      (and
        (<= 0 j2@266@01)
        (and
          (<
            j2@266@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j2@266@01 i2@195@01)))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j1@266@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j2@266@01)))
    (= j1@266@01 j2@266@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@266@01 Int)) (!
  (=>
    (and
      (<= 0 j@266@01)
      (and
        (<
          j@266@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@266@01 i2@195@01)))
    (and
      (=
        (inv@267@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@266@01))
        j@266@01)
      (img@268@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@266@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@266@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@268@01 r)
      (and
        (<= 0 (inv@267@01 r))
        (and
          (<
            (inv@267@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@267@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@267@01 r))
      r))
  :pattern ((inv@267@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@266@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@266@01)
    (Seq_index xs@193@01 j@266@01))
  
  :qid |quant-u-12874|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (<= 0 (inv@267@01 r))
        (and
          (<
            (inv@267@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@267@01 r) i2@195@01)))
      (img@268@01 r)
      (=
        r
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          (inv@267@01 r))))
    (>
      (ite
        (and
          (img@202@01 r)
          (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12875|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@269@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@269@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@267@01 r))
          (and
            (<
              (inv@267@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@267@01 r) i2@195@01)))
        (img@268@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@267@01 r))
          (and
            (<
              (inv@267@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@267@01 r) i2@195@01)))
        (img@268@01 r))
      (Set_in r ($FVF.domain_f (as sm@269@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@269@01  $FVF<f>))))
  :qid |qp.fvfDomDef207|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@267@01 r))
          (and
            (<
              (inv@267@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@267@01 r) i2@195@01)))
        (img@268@01 r))
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01)))))
    (=
      ($FVF.lookup_f (as sm@269@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@269@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef206|)))
(assert (fun03qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@269@01  $FVF<f>))))) x@196@01 i2@195@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@266@01 Int)) (!
  (=>
    (and
      (<= 0 j@266@01)
      (and
        (<
          j@266@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
        (= j@266@01 i2@195@01)))
    (and
      (=
        (inv@267@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
          j@266@01))
        j@266@01)
      (img@268@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        j@266@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
    j@266@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@268@01 r)
      (and
        (<= 0 (inv@267@01 r))
        (and
          (<
            (inv@267@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= (inv@267@01 r) i2@195@01))))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
        (inv@267@01 r))
      r))
  :pattern ((inv@267@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@269@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@267@01 r))
          (and
            (<
              (inv@267@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@267@01 r) i2@195@01)))
        (img@268@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@267@01 r))
          (and
            (<
              (inv@267@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@267@01 r) i2@195@01)))
        (img@268@01 r))
      (Set_in r ($FVF.domain_f (as sm@269@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@269@01  $FVF<f>))))
  :qid |qp.fvfDomDef207|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@267@01 r))
          (and
            (<
              (inv@267@01 r)
              (Seq_length
                ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
            (= (inv@267@01 r) i2@195@01)))
        (img@268@01 r))
      (and
        (img@202@01 r)
        (and (<= 0 (inv@201@01 r)) (< (inv@201@01 r) (Seq_length xs@193@01)))))
    (=
      ($FVF.lookup_f (as sm@269@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@269@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))) r))
  :qid |qp.fvfValDef206|)))
(assert (and
  (forall ((j@266@01 Int)) (!
    (=>
      (and
        (<= 0 j@266@01)
        (and
          (<
            j@266@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
          (= j@266@01 i2@195@01)))
      (and
        (=>
          (<= 0 j@266@01)
          (and
            (<= 0 j@266@01)
            (or
              (<
                j@266@01
                (Seq_length
                  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))
              (not
                (<
                  j@266@01
                  (Seq_length
                    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))))))))
        (or (<= 0 j@266@01) (not (<= 0 j@266@01)))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01)))))))))
      j@266@01))
    :qid |f-aux|))
  (fun03qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@269@01  $FVF<f>))))) x@196@01 i2@195@01)))
(push) ; 3
(assert (not (=
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@263@01  $FVF<f>))))) x@196@01 i2@195@01)
  (fun03qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@197@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@269@01  $FVF<f>))))) x@196@01 i2@195@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(pop) ; 2
(pop) ; 1
; ---------- test05 ----------
(declare-const xs@270@01 Seq<$Ref>)
(declare-const i1@271@01 Int)
(declare-const i2@272@01 Int)
(declare-const x@273@01 $Ref)
(declare-const xs@274@01 Seq<$Ref>)
(declare-const i1@275@01 Int)
(declare-const i2@276@01 Int)
(declare-const x@277@01 $Ref)
(push) ; 1
(declare-const $t@278@01 $Snap)
(assert (= $t@278@01 ($Snap.combine ($Snap.first $t@278@01) ($Snap.second $t@278@01))))
(assert (= ($Snap.first $t@278@01) $Snap.unit))
; [eval] 0 <= i1
(assert (<= 0 i1@275@01))
(assert (=
  ($Snap.second $t@278@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@278@01))
    ($Snap.second ($Snap.second $t@278@01)))))
(assert (= ($Snap.first ($Snap.second $t@278@01)) $Snap.unit))
; [eval] i1 < |xs|
; [eval] |xs|
(assert (< i1@275@01 (Seq_length xs@274@01)))
(assert (=
  ($Snap.second ($Snap.second $t@278@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@278@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@278@01))) $Snap.unit))
; [eval] 0 <= i2
(assert (<= 0 i2@276@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@278@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@278@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@278@01))))
  $Snap.unit))
; [eval] i2 < |xs|
; [eval] |xs|
(assert (< i2@276@01 (Seq_length xs@274@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))
  $Snap.unit))
; [eval] i1 != i2
(assert (not (= i1@275@01 i2@276@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))
  $Snap.unit))
; [eval] (forall j1: Int, j2: Int :: { (j1 in [0..|xs|)), (j2 in [0..|xs|)) } { (j1 in [0..|xs|)), xs[j2] } { (j2 in [0..|xs|)), xs[j1] } { xs[j1], xs[j2] } (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2) ==> xs[j1] != xs[j2])
(declare-const j1@279@01 Int)
(declare-const j2@280@01 Int)
(push) ; 2
; [eval] (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2) ==> xs[j1] != xs[j2]
; [eval] (j1 in [0..|xs|)) && ((j2 in [0..|xs|)) && j1 != j2)
; [eval] (j1 in [0..|xs|))
; [eval] [0..|xs|)
; [eval] |xs|
(push) ; 3
; [then-branch: 90 | !(j1@279@01 in [0..|xs@274@01|]) | live]
; [else-branch: 90 | j1@279@01 in [0..|xs@274@01|] | live]
(push) ; 4
; [then-branch: 90 | !(j1@279@01 in [0..|xs@274@01|])]
(assert (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 90 | j1@279@01 in [0..|xs@274@01|]]
(assert (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01))
; [eval] (j2 in [0..|xs|))
; [eval] [0..|xs|)
; [eval] |xs|
(push) ; 5
; [then-branch: 91 | !(j2@280@01 in [0..|xs@274@01|]) | live]
; [else-branch: 91 | j2@280@01 in [0..|xs@274@01|] | live]
(push) ; 6
; [then-branch: 91 | !(j2@280@01 in [0..|xs@274@01|])]
(assert (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 91 | j2@280@01 in [0..|xs@274@01|]]
(assert (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01))
; [eval] j1 != j2
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or
  (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
  (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (=>
  (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01))))))
(assert (or
  (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
  (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01))))
(push) ; 3
; [then-branch: 92 | j1@279@01 in [0..|xs@274@01|] && j2@280@01 in [0..|xs@274@01|] && j1@279@01 != j2@280@01 | live]
; [else-branch: 92 | !(j1@279@01 in [0..|xs@274@01|] && j2@280@01 in [0..|xs@274@01|] && j1@279@01 != j2@280@01) | live]
(push) ; 4
; [then-branch: 92 | j1@279@01 in [0..|xs@274@01|] && j2@280@01 in [0..|xs@274@01|] && j1@279@01 != j2@280@01]
(assert (and
  (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
    (not (= j1@279@01 j2@280@01)))))
; [eval] xs[j1] != xs[j2]
; [eval] xs[j1]
(push) ; 5
(assert (not (>= j1@279@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(assert (not (< j1@279@01 (Seq_length xs@274@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
; [eval] xs[j2]
(push) ; 5
(assert (not (>= j2@280@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(push) ; 5
(assert (not (< j2@280@01 (Seq_length xs@274@01))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(push) ; 4
; [else-branch: 92 | !(j1@279@01 in [0..|xs@274@01|] && j2@280@01 in [0..|xs@274@01|] && j1@279@01 != j2@280@01)]
(assert (not
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
      (not (= j1@279@01 j2@280@01))))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (=>
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
      (not (= j1@279@01 j2@280@01))))
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
    (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
    (not (= j1@279@01 j2@280@01)))))
; Joined path conditions
(assert (or
  (not
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
        (not (= j1@279@01 j2@280@01)))))
  (and
    (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
      (not (= j1@279@01 j2@280@01))))))
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((j1@279@01 Int) (j2@280@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
        (not (= j1@279@01 j2@280@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
            (not (= j1@279@01 j2@280@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01) (Seq_contains
    (Seq_range 0 (Seq_length xs@274@01))
    j2@280@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@274@01)) j1@279@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@274@01))
    j2@280@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@115@12@115@106-aux|)))
(assert (forall ((j1@279@01 Int) (j2@280@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
        (not (= j1@279@01 j2@280@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
            (not (= j1@279@01 j2@280@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@274@01)) j1@279@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@274@01))
    j2@280@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@115@12@115@106-aux|)))
(assert (forall ((j1@279@01 Int) (j2@280@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
        (not (= j1@279@01 j2@280@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
            (not (= j1@279@01 j2@280@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01) (Seq_index
    xs@274@01
    j2@280@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@274@01)) j1@279@01) (Seq_index
    xs@274@01
    j2@280@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@115@12@115@106-aux|)))
(assert (forall ((j1@279@01 Int) (j2@280@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
        (not (= j1@279@01 j2@280@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
            (not (= j1@279@01 j2@280@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@274@01)) j1@279@01) (Seq_index
    xs@274@01
    j2@280@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@115@12@115@106-aux|)))
(assert (forall ((j1@279@01 Int) (j2@280@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
        (not (= j1@279@01 j2@280@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
            (not (= j1@279@01 j2@280@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01) (Seq_index
    xs@274@01
    j1@279@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@274@01)) j2@280@01) (Seq_index
    xs@274@01
    j1@279@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@115@12@115@106-aux|)))
(assert (forall ((j1@279@01 Int) (j2@280@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
        (not (= j1@279@01 j2@280@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
            (not (= j1@279@01 j2@280@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@274@01)) j2@280@01) (Seq_index
    xs@274@01
    j1@279@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@115@12@115@106-aux|)))
(assert (forall ((j1@279@01 Int) (j2@280@01 Int)) (!
  (and
    (=>
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (or
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)))))
    (or
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (not (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)))
    (=>
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
        (not (= j1@279@01 j2@280@01))))
    (or
      (not
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
          (and
            (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
            (not (= j1@279@01 j2@280@01)))))
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
        (and
          (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
          (not (= j1@279@01 j2@280@01))))))
  :pattern ((Seq_index xs@274@01 j1@279@01) (Seq_index xs@274@01 j2@280@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@115@12@115@106-aux|)))
(assert (forall ((j1@279@01 Int) (j2@280@01 Int)) (!
  (=>
    (and
      (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01)
      (and
        (Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01)
        (not (= j1@279@01 j2@280@01))))
    (not (= (Seq_index xs@274@01 j1@279@01) (Seq_index xs@274@01 j2@280@01))))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01) (Seq_contains
    (Seq_range 0 (Seq_length xs@274@01))
    j2@280@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@274@01)) j1@279@01) (Seq_contains_trigger
    (Seq_range 0 (Seq_length xs@274@01))
    j2@280@01))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j1@279@01) (Seq_index
    xs@274@01
    j2@280@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@274@01)) j1@279@01) (Seq_index
    xs@274@01
    j2@280@01))
  :pattern ((Seq_contains (Seq_range 0 (Seq_length xs@274@01)) j2@280@01) (Seq_index
    xs@274@01
    j1@279@01))
  :pattern ((Seq_contains_trigger (Seq_range 0 (Seq_length xs@274@01)) j2@280@01) (Seq_index
    xs@274@01
    j1@279@01))
  :pattern ((Seq_index xs@274@01 j1@279@01) (Seq_index xs@274@01 j2@280@01))
  :qid |prog./home/runner/work/smt-logs/smt-logs/viper/viperserver/silicon/silver/src/test/resources/quantifiedpermissions/issues/issue_0205.vpr@115@12@115@106|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))
(declare-const j@281@01 Int)
(push) ; 2
; [eval] 0 <= j && j < |xs|
; [eval] 0 <= j
(push) ; 3
; [then-branch: 93 | !(0 <= j@281@01) | live]
; [else-branch: 93 | 0 <= j@281@01 | live]
(push) ; 4
; [then-branch: 93 | !(0 <= j@281@01)]
(assert (not (<= 0 j@281@01)))
(pop) ; 4
(push) ; 4
; [else-branch: 93 | 0 <= j@281@01]
(assert (<= 0 j@281@01))
; [eval] j < |xs|
; [eval] |xs|
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@281@01) (not (<= 0 j@281@01))))
(assert (and (<= 0 j@281@01) (< j@281@01 (Seq_length xs@274@01))))
; [eval] xs[j]
(push) ; 3
(assert (not (>= j@281@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(pop) ; 2
(declare-fun inv@282@01 ($Ref) Int)
(declare-fun img@283@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@281@01 Int)) (!
  (=>
    (and (<= 0 j@281@01) (< j@281@01 (Seq_length xs@274@01)))
    (or (<= 0 j@281@01) (not (<= 0 j@281@01))))
  :pattern ((Seq_index xs@274@01 j@281@01))
  :qid |f-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((j1@281@01 Int) (j2@281@01 Int)) (!
  (=>
    (and
      (and (<= 0 j1@281@01) (< j1@281@01 (Seq_length xs@274@01)))
      (and (<= 0 j2@281@01) (< j2@281@01 (Seq_length xs@274@01)))
      (= (Seq_index xs@274@01 j1@281@01) (Seq_index xs@274@01 j2@281@01)))
    (= j1@281@01 j2@281@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@281@01 Int)) (!
  (=>
    (and (<= 0 j@281@01) (< j@281@01 (Seq_length xs@274@01)))
    (and
      (= (inv@282@01 (Seq_index xs@274@01 j@281@01)) j@281@01)
      (img@283@01 (Seq_index xs@274@01 j@281@01))))
  :pattern ((Seq_index xs@274@01 j@281@01))
  :qid |quant-u-12877|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@283@01 r)
      (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
    (= (Seq_index xs@274@01 (inv@282@01 r)) r))
  :pattern ((inv@282@01 r))
  :qid |f-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((j@281@01 Int)) (!
  (=>
    (and (<= 0 j@281@01) (< j@281@01 (Seq_length xs@274@01)))
    (not (= (Seq_index xs@274@01 j@281@01) $Ref.null)))
  :pattern ((Seq_index xs@274@01 j@281@01))
  :qid |f-permImpliesNonNull|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))
(assert (not (= x@277@01 $Ref.null)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  $Snap.unit))
; [eval] x.elems == xs
(assert (Seq_equal
  ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
  xs@274@01))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 2
(pop) ; 2
(push) ; 2
; [exec]
; xs[i1].f := 0
; [eval] xs[i1]
(push) ; 3
(assert (not (>= i1@275@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@284@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@274@01 i1@275@01))
    ($Perm.min
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        $Perm.Write
        $Perm.No)
      (pTaken@284@01 r))
    $Perm.No)
  
  :qid |quant-u-12879|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@284@01 r) $Perm.No)
  
  :qid |quant-u-12880|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (= (- $Perm.Write (pTaken@284@01 r)) $Perm.No))
  
  :qid |quant-u-12881|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@285@01 $FVF<f>)
; Definitional axioms for singleton-FVF's value
(assert (= ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)) 0))
; [exec]
; assert fun04qp(x, i2) == old(fun04qp(x, i2))
; [eval] fun04qp(x, i2) == old(fun04qp(x, i2))
; [eval] fun04qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(push) ; 4
(assert (not (<
  i2@276@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(assert (<
  i2@276@01
  (Seq_length
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
(declare-const j@286@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 94 | !(0 <= j@286@01) | live]
; [else-branch: 94 | 0 <= j@286@01 | live]
(push) ; 6
; [then-branch: 94 | !(0 <= j@286@01)]
(assert (not (<= 0 j@286@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 94 | 0 <= j@286@01]
(assert (<= 0 j@286@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@286@01) (not (<= 0 j@286@01))))
(assert (and
  (<= 0 j@286@01)
  (<
    j@286@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 95 | j@286@01 == i2@276@01 | live]
; [else-branch: 95 | j@286@01 != i2@276@01 | live]
(push) ; 6
; [then-branch: 95 | j@286@01 == i2@276@01]
(assert (= j@286@01 i2@276@01))
(pop) ; 6
(push) ; 6
; [else-branch: 95 | j@286@01 != i2@276@01]
(assert (not (= j@286@01 i2@276@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@286@01 i2@276@01)) (= j@286@01 i2@276@01)))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@286@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@287@01 ($Ref) Int)
(declare-fun img@288@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@286@01 Int)) (!
  (=>
    (and
      (<= 0 j@286@01)
      (<
        j@286@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (and
      (or (<= 0 j@286@01) (not (<= 0 j@286@01)))
      (or (not (= j@286@01 i2@276@01)) (= j@286@01 i2@276@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@286@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@286@01 Int)) (!
  (=>
    (and
      (<= 0 j@286@01)
      (<
        j@286@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (or
      (= (ite (= j@286@01 i2@276@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@286@01 i2@276@01)))
  
  :qid |quant-u-12882|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@286@01 Int) (j2@286@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@286@01)
          (<
            j1@286@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j1@286@01 i2@276@01))
      (and
        (and
          (<= 0 j2@286@01)
          (<
            j2@286@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j2@286@01 i2@276@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j1@286@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j2@286@01)))
    (= j1@286@01 j2@286@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@286@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@286@01)
        (<
          j@286@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@286@01 i2@276@01))
    (and
      (=
        (inv@287@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@286@01))
        j@286@01)
      (img@288@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@286@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@286@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@288@01 r)
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@287@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@287@01 r))
      r))
  :pattern ((inv@287@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@286@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@286@01)
    (Seq_index xs@274@01 j@286@01))
  
  :qid |quant-u-12883|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (img@288@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
            (inv@287@01 r))))
      (> (ite (= (inv@287@01 r) i2@276@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- $Perm.Write (pTaken@284@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12884|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@289@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@289@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@287@01 r) i2@276@01)
        (img@288@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@287@01 r) i2@276@01)
        (img@288@01 r))
      (Set_in r ($FVF.domain_f (as sm@289@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@289@01  $FVF<f>))))
  :qid |qp.fvfDomDef210|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@287@01 r) i2@276@01)
        (img@288@01 r))
      (= r (Seq_index xs@274@01 i1@275@01)))
    (=
      ($FVF.lookup_f (as sm@289@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@289@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef208|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@287@01 r) i2@276@01)
        (img@288@01 r))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (< $Perm.No (- $Perm.Write (pTaken@284@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@289@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@289@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef209|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@289@01  $FVF<f>))))) x@277@01 i2@276@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@286@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@286@01)
        (<
          j@286@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@286@01 i2@276@01))
    (and
      (=
        (inv@287@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@286@01))
        j@286@01)
      (img@288@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@286@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@286@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@288@01 r)
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@287@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@287@01 r))
      r))
  :pattern ((inv@287@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@289@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@287@01 r) i2@276@01)
        (img@288@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@287@01 r) i2@276@01)
        (img@288@01 r))
      (Set_in r ($FVF.domain_f (as sm@289@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@289@01  $FVF<f>))))
  :qid |qp.fvfDomDef210|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@287@01 r) i2@276@01)
        (img@288@01 r))
      (= r (Seq_index xs@274@01 i1@275@01)))
    (=
      ($FVF.lookup_f (as sm@289@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@289@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef208|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@287@01 r))
          (<
            (inv@287@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@287@01 r) i2@276@01)
        (img@288@01 r))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (< $Perm.No (- $Perm.Write (pTaken@284@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@289@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@289@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef209|)))
(assert (and
  (<
    i2@276@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))
  (forall ((j@286@01 Int)) (!
    (=>
      (and
        (<= 0 j@286@01)
        (<
          j@286@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (and
        (or (<= 0 j@286@01) (not (<= 0 j@286@01)))
        (or (not (= j@286@01 i2@276@01)) (= j@286@01 i2@276@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@286@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@289@01  $FVF<f>))))) x@277@01 i2@276@01)))
; [eval] old(fun04qp(x, i2))
; [eval] fun04qp(x, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@290@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 96 | !(0 <= j@290@01) | live]
; [else-branch: 96 | 0 <= j@290@01 | live]
(push) ; 6
; [then-branch: 96 | !(0 <= j@290@01)]
(assert (not (<= 0 j@290@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 96 | 0 <= j@290@01]
(assert (<= 0 j@290@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@290@01) (not (<= 0 j@290@01))))
(assert (and
  (<= 0 j@290@01)
  (<
    j@290@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 97 | j@290@01 == i2@276@01 | live]
; [else-branch: 97 | j@290@01 != i2@276@01 | live]
(push) ; 6
; [then-branch: 97 | j@290@01 == i2@276@01]
(assert (= j@290@01 i2@276@01))
(pop) ; 6
(push) ; 6
; [else-branch: 97 | j@290@01 != i2@276@01]
(assert (not (= j@290@01 i2@276@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@290@01 i2@276@01)) (= j@290@01 i2@276@01)))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@290@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@291@01 ($Ref) Int)
(declare-fun img@292@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@290@01 Int)) (!
  (=>
    (and
      (<= 0 j@290@01)
      (<
        j@290@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (and
      (or (<= 0 j@290@01) (not (<= 0 j@290@01)))
      (or (not (= j@290@01 i2@276@01)) (= j@290@01 i2@276@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@290@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@290@01 Int)) (!
  (=>
    (and
      (<= 0 j@290@01)
      (<
        j@290@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (or
      (= (ite (= j@290@01 i2@276@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@290@01 i2@276@01)))
  
  :qid |quant-u-12885|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@290@01 Int) (j2@290@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@290@01)
          (<
            j1@290@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j1@290@01 i2@276@01))
      (and
        (and
          (<= 0 j2@290@01)
          (<
            j2@290@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j2@290@01 i2@276@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j1@290@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j2@290@01)))
    (= j1@290@01 j2@290@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@290@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@290@01)
        (<
          j@290@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@290@01 i2@276@01))
    (and
      (=
        (inv@291@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@290@01))
        j@290@01)
      (img@292@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@290@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@290@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@292@01 r)
      (and
        (and
          (<= 0 (inv@291@01 r))
          (<
            (inv@291@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@291@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@291@01 r))
      r))
  :pattern ((inv@291@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@290@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@290@01)
    (Seq_index xs@274@01 j@290@01))
  
  :qid |quant-u-12886|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@291@01 r))
          (<
            (inv@291@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (img@292@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
            (inv@291@01 r))))
      (> (ite (= (inv@291@01 r) i2@276@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12887|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@293@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@293@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@291@01 r))
          (<
            (inv@291@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@291@01 r) i2@276@01)
        (img@292@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@291@01 r))
          (<
            (inv@291@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@291@01 r) i2@276@01)
        (img@292@01 r))
      (Set_in r ($FVF.domain_f (as sm@293@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@293@01  $FVF<f>))))
  :qid |qp.fvfDomDef212|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@291@01 r))
          (<
            (inv@291@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@291@01 r) i2@276@01)
        (img@292@01 r))
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01)))))
    (=
      ($FVF.lookup_f (as sm@293@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@293@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef211|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@293@01  $FVF<f>))))) x@277@01 i2@276@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@290@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@290@01)
        (<
          j@290@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@290@01 i2@276@01))
    (and
      (=
        (inv@291@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@290@01))
        j@290@01)
      (img@292@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@290@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@290@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@292@01 r)
      (and
        (and
          (<= 0 (inv@291@01 r))
          (<
            (inv@291@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@291@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@291@01 r))
      r))
  :pattern ((inv@291@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@293@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@291@01 r))
          (<
            (inv@291@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@291@01 r) i2@276@01)
        (img@292@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@291@01 r))
          (<
            (inv@291@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@291@01 r) i2@276@01)
        (img@292@01 r))
      (Set_in r ($FVF.domain_f (as sm@293@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@293@01  $FVF<f>))))
  :qid |qp.fvfDomDef212|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@291@01 r))
          (<
            (inv@291@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@291@01 r) i2@276@01)
        (img@292@01 r))
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01)))))
    (=
      ($FVF.lookup_f (as sm@293@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@293@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef211|)))
(assert (and
  (forall ((j@290@01 Int)) (!
    (=>
      (and
        (<= 0 j@290@01)
        (<
          j@290@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (and
        (or (<= 0 j@290@01) (not (<= 0 j@290@01)))
        (or (not (= j@290@01 i2@276@01)) (= j@290@01 i2@276@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@290@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@293@01  $FVF<f>))))) x@277@01 i2@276@01)))
(push) ; 3
(assert (not (=
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@289@01  $FVF<f>))))) x@277@01 i2@276@01)
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@293@01  $FVF<f>))))) x@277@01 i2@276@01))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (=
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@289@01  $FVF<f>))))) x@277@01 i2@276@01)
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@293@01  $FVF<f>))))) x@277@01 i2@276@01)))
; [exec]
; xs[i2].f := 0
; [eval] xs[i2]
(push) ; 3
(assert (not (>= i2@276@01 0)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(push) ; 3
(set-option :timeout 10)
(assert (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Precomputing data for removing quantified permissions
(define-fun pTaken@294@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@274@01 i2@276@01))
    ($Perm.min
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (- $Perm.Write (pTaken@284@01 r))
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@295@01 ((r $Ref)) $Perm
  (ite
    (= r (Seq_index xs@274@01 i2@276@01))
    ($Perm.min
      (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No)
      (- $Perm.Write (pTaken@294@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (- $Perm.Write (pTaken@284@01 r))
        $Perm.No)
      (pTaken@294@01 r))
    $Perm.No)
  
  :qid |quant-u-12889|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (forall ((r $Ref)) (!
  (= (pTaken@294@01 r) $Perm.No)
  
  :qid |quant-u-12890|))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Intermediate check if already taken enough permissions
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 500)
(assert (not (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (= (- $Perm.Write (pTaken@294@01 r)) $Perm.No))
  
  :qid |quant-u-12891|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@296@01 $FVF<f>)
; Definitional axioms for singleton-FVF's value
(assert (= ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)) 0))
; [exec]
; assert fun04qp(x, i2) == old(fun04qp(x, i2))
; [eval] fun04qp(x, i2) == old(fun04qp(x, i2))
; [eval] fun04qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@297@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 98 | !(0 <= j@297@01) | live]
; [else-branch: 98 | 0 <= j@297@01 | live]
(push) ; 6
; [then-branch: 98 | !(0 <= j@297@01)]
(assert (not (<= 0 j@297@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 98 | 0 <= j@297@01]
(assert (<= 0 j@297@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@297@01) (not (<= 0 j@297@01))))
(assert (and
  (<= 0 j@297@01)
  (<
    j@297@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 99 | j@297@01 == i2@276@01 | live]
; [else-branch: 99 | j@297@01 != i2@276@01 | live]
(push) ; 6
; [then-branch: 99 | j@297@01 == i2@276@01]
(assert (= j@297@01 i2@276@01))
(pop) ; 6
(push) ; 6
; [else-branch: 99 | j@297@01 != i2@276@01]
(assert (not (= j@297@01 i2@276@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@297@01 i2@276@01)) (= j@297@01 i2@276@01)))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@297@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@298@01 ($Ref) Int)
(declare-fun img@299@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@297@01 Int)) (!
  (=>
    (and
      (<= 0 j@297@01)
      (<
        j@297@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (and
      (or (<= 0 j@297@01) (not (<= 0 j@297@01)))
      (or (not (= j@297@01 i2@276@01)) (= j@297@01 i2@276@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@297@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@297@01 Int)) (!
  (=>
    (and
      (<= 0 j@297@01)
      (<
        j@297@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (or
      (= (ite (= j@297@01 i2@276@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@297@01 i2@276@01)))
  
  :qid |quant-u-12892|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@297@01 Int) (j2@297@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@297@01)
          (<
            j1@297@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j1@297@01 i2@276@01))
      (and
        (and
          (<= 0 j2@297@01)
          (<
            j2@297@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j2@297@01 i2@276@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j1@297@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j2@297@01)))
    (= j1@297@01 j2@297@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@297@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@297@01)
        (<
          j@297@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@297@01 i2@276@01))
    (and
      (=
        (inv@298@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@297@01))
        j@297@01)
      (img@299@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@297@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@297@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@299@01 r)
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@298@01 r))
      r))
  :pattern ((inv@298@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@297@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@297@01)
    (Seq_index xs@274@01 j@297@01))
  
  :qid |quant-u-12893|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (img@299@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
            (inv@298@01 r))))
      (> (ite (= (inv@298@01 r) i2@276@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (+
          (ite
            (and
              (img@283@01 r)
              (and
                (<= 0 (inv@282@01 r))
                (< (inv@282@01 r) (Seq_length xs@274@01))))
            (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12894|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@300@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@300@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)
        (img@299@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)
        (img@299@01 r))
      (Set_in r ($FVF.domain_f (as sm@300@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@300@01  $FVF<f>))))
  :qid |qp.fvfDomDef216|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)
        (img@299@01 r))
      (= r (Seq_index xs@274@01 i2@276@01)))
    (=
      ($FVF.lookup_f (as sm@300@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@300@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef213|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)
        (img@299@01 r))
      (= r (Seq_index xs@274@01 i1@275@01)))
    (=
      ($FVF.lookup_f (as sm@300@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@300@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)
        (img@299@01 r))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@300@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@300@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef215|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@300@01  $FVF<f>))))) x@277@01 i2@276@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@297@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@297@01)
        (<
          j@297@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@297@01 i2@276@01))
    (and
      (=
        (inv@298@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@297@01))
        j@297@01)
      (img@299@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@297@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@297@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@299@01 r)
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@298@01 r))
      r))
  :pattern ((inv@298@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@300@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)
        (img@299@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)
        (img@299@01 r))
      (Set_in r ($FVF.domain_f (as sm@300@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@300@01  $FVF<f>))))
  :qid |qp.fvfDomDef216|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)
        (img@299@01 r))
      (= r (Seq_index xs@274@01 i2@276@01)))
    (=
      ($FVF.lookup_f (as sm@300@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@300@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef213|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)
        (img@299@01 r))
      (= r (Seq_index xs@274@01 i1@275@01)))
    (=
      ($FVF.lookup_f (as sm@300@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@300@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef214|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@298@01 r))
          (<
            (inv@298@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@298@01 r) i2@276@01)
        (img@299@01 r))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@300@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@300@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef215|)))
(assert (and
  (forall ((j@297@01 Int)) (!
    (=>
      (and
        (<= 0 j@297@01)
        (<
          j@297@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (and
        (or (<= 0 j@297@01) (not (<= 0 j@297@01)))
        (or (not (= j@297@01 i2@276@01)) (= j@297@01 i2@276@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@297@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@300@01  $FVF<f>))))) x@277@01 i2@276@01)))
; [eval] old(fun04qp(x, i2))
; [eval] fun04qp(x, i2)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@301@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 100 | !(0 <= j@301@01) | live]
; [else-branch: 100 | 0 <= j@301@01 | live]
(push) ; 6
; [then-branch: 100 | !(0 <= j@301@01)]
(assert (not (<= 0 j@301@01)))
(pop) ; 6
(push) ; 6
; [else-branch: 100 | 0 <= j@301@01]
(assert (<= 0 j@301@01))
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@301@01) (not (<= 0 j@301@01))))
(assert (and
  (<= 0 j@301@01)
  (<
    j@301@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(push) ; 5
; [then-branch: 101 | j@301@01 == i2@276@01 | live]
; [else-branch: 101 | j@301@01 != i2@276@01 | live]
(push) ; 6
; [then-branch: 101 | j@301@01 == i2@276@01]
(assert (= j@301@01 i2@276@01))
(pop) ; 6
(push) ; 6
; [else-branch: 101 | j@301@01 != i2@276@01]
(assert (not (= j@301@01 i2@276@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@301@01 i2@276@01)) (= j@301@01 i2@276@01)))
; [eval] x.elems[j]
(push) ; 5
(assert (not (>= j@301@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@302@01 ($Ref) Int)
(declare-fun img@303@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@301@01 Int)) (!
  (=>
    (and
      (<= 0 j@301@01)
      (<
        j@301@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (and
      (or (<= 0 j@301@01) (not (<= 0 j@301@01)))
      (or (not (= j@301@01 i2@276@01)) (= j@301@01 i2@276@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@301@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@301@01 Int)) (!
  (=>
    (and
      (<= 0 j@301@01)
      (<
        j@301@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (or
      (= (ite (= j@301@01 i2@276@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@301@01 i2@276@01)))
  
  :qid |quant-u-12895|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@301@01 Int) (j2@301@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@301@01)
          (<
            j1@301@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j1@301@01 i2@276@01))
      (and
        (and
          (<= 0 j2@301@01)
          (<
            j2@301@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j2@301@01 i2@276@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j1@301@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j2@301@01)))
    (= j1@301@01 j2@301@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@301@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@301@01)
        (<
          j@301@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@301@01 i2@276@01))
    (and
      (=
        (inv@302@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@301@01))
        j@301@01)
      (img@303@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@301@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@301@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@303@01 r)
      (and
        (and
          (<= 0 (inv@302@01 r))
          (<
            (inv@302@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@302@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@302@01 r))
      r))
  :pattern ((inv@302@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@301@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@301@01)
    (Seq_index xs@274@01 j@301@01))
  
  :qid |quant-u-12896|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@302@01 r))
          (<
            (inv@302@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (img@303@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
            (inv@302@01 r))))
      (> (ite (= (inv@302@01 r) i2@276@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12897|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@304@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@304@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@302@01 r))
          (<
            (inv@302@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@302@01 r) i2@276@01)
        (img@303@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@302@01 r))
          (<
            (inv@302@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@302@01 r) i2@276@01)
        (img@303@01 r))
      (Set_in r ($FVF.domain_f (as sm@304@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@304@01  $FVF<f>))))
  :qid |qp.fvfDomDef218|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@302@01 r))
          (<
            (inv@302@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@302@01 r) i2@276@01)
        (img@303@01 r))
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01)))))
    (=
      ($FVF.lookup_f (as sm@304@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@304@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef217|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@304@01  $FVF<f>))))) x@277@01 i2@276@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@301@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@301@01)
        (<
          j@301@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@301@01 i2@276@01))
    (and
      (=
        (inv@302@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@301@01))
        j@301@01)
      (img@303@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@301@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@301@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@303@01 r)
      (and
        (and
          (<= 0 (inv@302@01 r))
          (<
            (inv@302@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@302@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@302@01 r))
      r))
  :pattern ((inv@302@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@304@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@302@01 r))
          (<
            (inv@302@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@302@01 r) i2@276@01)
        (img@303@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@302@01 r))
          (<
            (inv@302@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@302@01 r) i2@276@01)
        (img@303@01 r))
      (Set_in r ($FVF.domain_f (as sm@304@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@304@01  $FVF<f>))))
  :qid |qp.fvfDomDef218|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@302@01 r))
          (<
            (inv@302@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@302@01 r) i2@276@01)
        (img@303@01 r))
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01)))))
    (=
      ($FVF.lookup_f (as sm@304@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@304@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef217|)))
(assert (and
  (forall ((j@301@01 Int)) (!
    (=>
      (and
        (<= 0 j@301@01)
        (<
          j@301@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (and
        (or (<= 0 j@301@01) (not (<= 0 j@301@01)))
        (or (not (= j@301@01 i2@276@01)) (= j@301@01 i2@276@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@301@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@304@01  $FVF<f>))))) x@277@01 i2@276@01)))
(push) ; 3
(assert (not (=
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@300@01  $FVF<f>))))) x@277@01 i2@276@01)
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@304@01  $FVF<f>))))) x@277@01 i2@276@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
(declare-const sm@305@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@305@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@305@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef219|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@305@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@305@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef220|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@305@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@305@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef221|)))
(declare-const pm@306@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@306@01  $FPM) r)
    (+
      (+
        (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
        $Perm.No)))
  :pattern (($FVF.perm_f (as pm@306@01  $FPM) r))
  :qid |qp.resPrmSumDef222|)))
(assert (<=
  ($FVF.perm_f (as pm@306@01  $FPM) (Seq_index xs@274@01 i2@276@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@306@01  $FPM) (Seq_index xs@274@01 i1@275@01))
  $Perm.Write))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@306@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun04qp(x, i2) == old(fun04qp(x, i2))
; [eval] fun04qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@307@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 102 | !(0 <= j@307@01) | live]
; [else-branch: 102 | 0 <= j@307@01 | live]
(push) ; 6
; [then-branch: 102 | !(0 <= j@307@01)]
(assert (not (<= 0 j@307@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(declare-const sm@308@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef223|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef225|)))
(declare-const pm@309@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@309@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@309@01  $FPM) r))
  :qid |qp.resPrmSumDef226|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@309@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@309@01  $FPM) (Seq_index xs@274@01 i1@275@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@309@01  $FPM) (Seq_index xs@274@01 i2@276@01))
  $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 102 | 0 <= j@307@01]
(assert (<= 0 j@307@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(declare-const sm@310@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef228|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef229|)))
(declare-const pm@311@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@311@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@311@01  $FPM) r))
  :qid |qp.resPrmSumDef230|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
  $Perm.Write))
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef223|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@309@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@309@01  $FPM) r))
  :qid |qp.resPrmSumDef226|)))
(assert (=>
  (not (<= 0 j@307@01))
  (and
    (not (<= 0 j@307@01))
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@309@01  $FPM) r) $Perm.Write)
      :pattern ((inv@282@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@309@01  $FPM) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@309@01  $FPM) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef228|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef229|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@311@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@311@01  $FPM) r))
  :qid |qp.resPrmSumDef230|)))
(assert (=>
  (<= 0 j@307@01)
  (and
    (<= 0 j@307@01)
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
      :pattern ((inv@282@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write))))
(assert (or (<= 0 j@307@01) (not (<= 0 j@307@01))))
(assert (and
  (<= 0 j@307@01)
  (<
    j@307@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 103 | j@307@01 == i2@276@01 | live]
; [else-branch: 103 | j@307@01 != i2@276@01 | live]
(push) ; 6
; [then-branch: 103 | j@307@01 == i2@276@01]
(assert (= j@307@01 i2@276@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
  $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 103 | j@307@01 != i2@276@01]
(assert (not (= j@307@01 i2@276@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
  $Perm.Write))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (= j@307@01 i2@276@01)
  (and
    (= j@307@01 i2@276@01)
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
      :pattern ((inv@282@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write))))
; Joined path conditions
(assert (=>
  (not (= j@307@01 i2@276@01))
  (and
    (not (= j@307@01 i2@276@01))
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
      :pattern ((inv@282@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write))))
(assert (or (not (= j@307@01 i2@276@01)) (= j@307@01 i2@276@01)))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@307@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@312@01 ($Ref) Int)
(declare-fun img@313@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef223|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@309@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@309@01  $FPM) r))
  :qid |qp.resPrmSumDef226|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef228|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef229|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@311@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@311@01  $FPM) r))
  :qid |qp.resPrmSumDef230|)))
; Nested auxiliary terms: non-globals
(assert (forall ((j@307@01 Int)) (!
  (=>
    (and
      (<= 0 j@307@01)
      (<
        j@307@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (and
      (=>
        (not (<= 0 j@307@01))
        (and
          (not (<= 0 j@307@01))
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@309@01  $FPM) r) $Perm.Write)
            :pattern ((inv@282@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@309@01  $FPM) (Seq_index xs@274@01 i1@275@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@309@01  $FPM) (Seq_index xs@274@01 i2@276@01))
            $Perm.Write)))
      (=>
        (<= 0 j@307@01)
        (and
          (<= 0 j@307@01)
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
            :pattern ((inv@282@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
            $Perm.Write)))
      (or (<= 0 j@307@01) (not (<= 0 j@307@01)))
      (=>
        (= j@307@01 i2@276@01)
        (and
          (= j@307@01 i2@276@01)
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
            :pattern ((inv@282@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
            $Perm.Write)))
      (=>
        (not (= j@307@01 i2@276@01))
        (and
          (not (= j@307@01 i2@276@01))
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
            :pattern ((inv@282@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
            $Perm.Write)))
      (or (not (= j@307@01 i2@276@01)) (= j@307@01 i2@276@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@307@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@307@01 Int)) (!
  (=>
    (and
      (<= 0 j@307@01)
      (<
        j@307@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (or
      (= (ite (= j@307@01 i2@276@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@307@01 i2@276@01)))
  
  :qid |quant-u-12898|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@307@01 Int) (j2@307@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@307@01)
          (<
            j1@307@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j1@307@01 i2@276@01))
      (and
        (and
          (<= 0 j2@307@01)
          (<
            j2@307@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j2@307@01 i2@276@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j1@307@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j2@307@01)))
    (= j1@307@01 j2@307@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@307@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@307@01)
        (<
          j@307@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@307@01 i2@276@01))
    (and
      (=
        (inv@312@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@307@01))
        j@307@01)
      (img@313@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@307@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@307@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@313@01 r)
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@312@01 r))
      r))
  :pattern ((inv@312@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@307@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@307@01)
    (Seq_index xs@274@01 j@307@01))
  
  :qid |quant-u-12899|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (img@313@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
            (inv@312@01 r))))
      (> (ite (= (inv@312@01 r) i2@276@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (+
          (ite
            (and
              (img@283@01 r)
              (and
                (<= 0 (inv@282@01 r))
                (< (inv@282@01 r) (Seq_length xs@274@01))))
            (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12900|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@314@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@314@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)
        (img@313@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)
        (img@313@01 r))
      (Set_in r ($FVF.domain_f (as sm@314@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@314@01  $FVF<f>))))
  :qid |qp.fvfDomDef234|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)
        (img@313@01 r))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@314@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@314@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef231|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)
        (img@313@01 r))
      (= r (Seq_index xs@274@01 i1@275@01)))
    (=
      ($FVF.lookup_f (as sm@314@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@314@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef232|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)
        (img@313@01 r))
      (= r (Seq_index xs@274@01 i2@276@01)))
    (=
      ($FVF.lookup_f (as sm@314@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@314@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef233|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@314@01  $FVF<f>))))) x@277@01 i2@276@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef223|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef224|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@308@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@308@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef225|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@309@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@309@01  $FPM) r))
  :qid |qp.resPrmSumDef226|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef227|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef228|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@310@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@310@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef229|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@311@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@311@01  $FPM) r))
  :qid |qp.resPrmSumDef230|)))
(assert (forall ((j@307@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@307@01)
        (<
          j@307@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@307@01 i2@276@01))
    (and
      (=
        (inv@312@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@307@01))
        j@307@01)
      (img@313@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@307@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@307@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@313@01 r)
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@312@01 r))
      r))
  :pattern ((inv@312@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@314@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)
        (img@313@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)
        (img@313@01 r))
      (Set_in r ($FVF.domain_f (as sm@314@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@314@01  $FVF<f>))))
  :qid |qp.fvfDomDef234|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)
        (img@313@01 r))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@314@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@314@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef231|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)
        (img@313@01 r))
      (= r (Seq_index xs@274@01 i1@275@01)))
    (=
      ($FVF.lookup_f (as sm@314@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@314@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef232|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@312@01 r))
          (<
            (inv@312@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@312@01 r) i2@276@01)
        (img@313@01 r))
      (= r (Seq_index xs@274@01 i2@276@01)))
    (=
      ($FVF.lookup_f (as sm@314@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@314@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef233|)))
(assert (and
  (forall ((j@307@01 Int)) (!
    (=>
      (and
        (<= 0 j@307@01)
        (<
          j@307@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (and
        (=>
          (not (<= 0 j@307@01))
          (and
            (not (<= 0 j@307@01))
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@309@01  $FPM) r) $Perm.Write)
              :pattern ((inv@282@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@309@01  $FPM) (Seq_index xs@274@01 i1@275@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@309@01  $FPM) (Seq_index xs@274@01 i2@276@01))
              $Perm.Write)))
        (=>
          (<= 0 j@307@01)
          (and
            (<= 0 j@307@01)
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
              :pattern ((inv@282@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
              $Perm.Write)))
        (or (<= 0 j@307@01) (not (<= 0 j@307@01)))
        (=>
          (= j@307@01 i2@276@01)
          (and
            (= j@307@01 i2@276@01)
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
              :pattern ((inv@282@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
              $Perm.Write)))
        (=>
          (not (= j@307@01 i2@276@01))
          (and
            (not (= j@307@01 i2@276@01))
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@311@01  $FPM) r) $Perm.Write)
              :pattern ((inv@282@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i1@275@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@311@01  $FPM) (Seq_index xs@274@01 i2@276@01))
              $Perm.Write)))
        (or (not (= j@307@01 i2@276@01)) (= j@307@01 i2@276@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@307@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@314@01  $FVF<f>))))) x@277@01 i2@276@01)))
; [eval] old(fun04qp(x, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@315@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@283@01 r)
      (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
    (=
      ($FVF.lookup_f (as sm@315@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@315@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef235|)))
(declare-const pm@316@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@316@01  $FPM) r)
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@316@01  $FPM) r))
  :qid |qp.resPrmSumDef236|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@316@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun04qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@317@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 104 | !(0 <= j@317@01) | live]
; [else-branch: 104 | 0 <= j@317@01 | live]
(push) ; 6
; [then-branch: 104 | !(0 <= j@317@01)]
(assert (not (<= 0 j@317@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 104 | 0 <= j@317@01]
(assert (<= 0 j@317@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@317@01) (not (<= 0 j@317@01))))
(assert (and
  (<= 0 j@317@01)
  (<
    j@317@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 105 | j@317@01 == i2@276@01 | live]
; [else-branch: 105 | j@317@01 != i2@276@01 | live]
(push) ; 6
; [then-branch: 105 | j@317@01 == i2@276@01]
(assert (= j@317@01 i2@276@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 105 | j@317@01 != i2@276@01]
(assert (not (= j@317@01 i2@276@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@317@01 i2@276@01)) (= j@317@01 i2@276@01)))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@317@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@318@01 ($Ref) Int)
(declare-fun img@319@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@317@01 Int)) (!
  (=>
    (and
      (<= 0 j@317@01)
      (<
        j@317@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (and
      (or (<= 0 j@317@01) (not (<= 0 j@317@01)))
      (or (not (= j@317@01 i2@276@01)) (= j@317@01 i2@276@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@317@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@317@01 Int)) (!
  (=>
    (and
      (<= 0 j@317@01)
      (<
        j@317@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (or
      (= (ite (= j@317@01 i2@276@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@317@01 i2@276@01)))
  
  :qid |quant-u-12901|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@317@01 Int) (j2@317@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@317@01)
          (<
            j1@317@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j1@317@01 i2@276@01))
      (and
        (and
          (<= 0 j2@317@01)
          (<
            j2@317@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j2@317@01 i2@276@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j1@317@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j2@317@01)))
    (= j1@317@01 j2@317@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@317@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@317@01)
        (<
          j@317@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@317@01 i2@276@01))
    (and
      (=
        (inv@318@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@317@01))
        j@317@01)
      (img@319@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@317@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@317@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@319@01 r)
      (and
        (and
          (<= 0 (inv@318@01 r))
          (<
            (inv@318@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@318@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@318@01 r))
      r))
  :pattern ((inv@318@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@317@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@317@01)
    (Seq_index xs@274@01 j@317@01))
  
  :qid |quant-u-12902|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@318@01 r))
          (<
            (inv@318@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (img@319@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
            (inv@318@01 r))))
      (> (ite (= (inv@318@01 r) i2@276@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12903|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@320@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@320@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@318@01 r))
          (<
            (inv@318@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@318@01 r) i2@276@01)
        (img@319@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@318@01 r))
          (<
            (inv@318@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@318@01 r) i2@276@01)
        (img@319@01 r))
      (Set_in r ($FVF.domain_f (as sm@320@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@320@01  $FVF<f>))))
  :qid |qp.fvfDomDef238|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@318@01 r))
          (<
            (inv@318@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@318@01 r) i2@276@01)
        (img@319@01 r))
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01)))))
    (=
      ($FVF.lookup_f (as sm@320@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@320@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef237|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@320@01  $FVF<f>))))) x@277@01 i2@276@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@317@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@317@01)
        (<
          j@317@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@317@01 i2@276@01))
    (and
      (=
        (inv@318@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@317@01))
        j@317@01)
      (img@319@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@317@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@317@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@319@01 r)
      (and
        (and
          (<= 0 (inv@318@01 r))
          (<
            (inv@318@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@318@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@318@01 r))
      r))
  :pattern ((inv@318@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@320@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@318@01 r))
          (<
            (inv@318@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@318@01 r) i2@276@01)
        (img@319@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@318@01 r))
          (<
            (inv@318@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@318@01 r) i2@276@01)
        (img@319@01 r))
      (Set_in r ($FVF.domain_f (as sm@320@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@320@01  $FVF<f>))))
  :qid |qp.fvfDomDef238|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@318@01 r))
          (<
            (inv@318@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@318@01 r) i2@276@01)
        (img@319@01 r))
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01)))))
    (=
      ($FVF.lookup_f (as sm@320@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@320@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef237|)))
(assert (and
  (forall ((j@317@01 Int)) (!
    (=>
      (and
        (<= 0 j@317@01)
        (<
          j@317@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (and
        (or (<= 0 j@317@01) (not (<= 0 j@317@01)))
        (or (not (= j@317@01 i2@276@01)) (= j@317@01 i2@276@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@317@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@320@01  $FVF<f>))))) x@277@01 i2@276@01)))
(push) ; 3
(assert (not (=
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@314@01  $FVF<f>))))) x@277@01 i2@276@01)
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@320@01  $FVF<f>))))) x@277@01 i2@276@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
(declare-const sm@321@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@321@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@321@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef239|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@321@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@321@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef240|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@321@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@321@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef241|)))
(declare-const pm@322@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@322@01  $FPM) r)
    (+
      (+
        (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
        $Perm.No)))
  :pattern (($FVF.perm_f (as pm@322@01  $FPM) r))
  :qid |qp.resPrmSumDef242|)))
(assert (<=
  ($FVF.perm_f (as pm@322@01  $FPM) (Seq_index xs@274@01 i2@276@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@322@01  $FPM) (Seq_index xs@274@01 i1@275@01))
  $Perm.Write))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@322@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun04qp(x, i2) == old(fun04qp(x, i2))
; [eval] fun04qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@323@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 106 | !(0 <= j@323@01) | live]
; [else-branch: 106 | 0 <= j@323@01 | live]
(push) ; 6
; [then-branch: 106 | !(0 <= j@323@01)]
(assert (not (<= 0 j@323@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 106 | 0 <= j@323@01]
(assert (<= 0 j@323@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (not (<= 0 j@323@01))
  (and
    (not (<= 0 j@323@01))
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01))))))
; Joined path conditions
(assert (=>
  (<= 0 j@323@01)
  (and
    (<= 0 j@323@01)
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01))))))
(assert (or (<= 0 j@323@01) (not (<= 0 j@323@01))))
(assert (and
  (<= 0 j@323@01)
  (<
    j@323@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 107 | j@323@01 == i2@276@01 | live]
; [else-branch: 107 | j@323@01 != i2@276@01 | live]
(push) ; 6
; [then-branch: 107 | j@323@01 == i2@276@01]
(assert (= j@323@01 i2@276@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 107 | j@323@01 != i2@276@01]
(assert (not (= j@323@01 i2@276@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (= j@323@01 i2@276@01)
  (and
    (= j@323@01 i2@276@01)
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01))))))
; Joined path conditions
(assert (=>
  (not (= j@323@01 i2@276@01))
  (and
    (not (= j@323@01 i2@276@01))
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01))))))
(assert (or (not (= j@323@01 i2@276@01)) (= j@323@01 i2@276@01)))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@323@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@324@01 ($Ref) Int)
(declare-fun img@325@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@323@01 Int)) (!
  (=>
    (and
      (<= 0 j@323@01)
      (<
        j@323@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (and
      (=>
        (not (<= 0 j@323@01))
        (and
          (not (<= 0 j@323@01))
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
      (=>
        (<= 0 j@323@01)
        (and
          (<= 0 j@323@01)
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
      (or (<= 0 j@323@01) (not (<= 0 j@323@01)))
      (=>
        (= j@323@01 i2@276@01)
        (and
          (= j@323@01 i2@276@01)
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
      (=>
        (not (= j@323@01 i2@276@01))
        (and
          (not (= j@323@01 i2@276@01))
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
      (or (not (= j@323@01 i2@276@01)) (= j@323@01 i2@276@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@323@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@323@01 Int)) (!
  (=>
    (and
      (<= 0 j@323@01)
      (<
        j@323@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (or
      (= (ite (= j@323@01 i2@276@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@323@01 i2@276@01)))
  
  :qid |quant-u-12904|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@323@01 Int) (j2@323@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@323@01)
          (<
            j1@323@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j1@323@01 i2@276@01))
      (and
        (and
          (<= 0 j2@323@01)
          (<
            j2@323@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j2@323@01 i2@276@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j1@323@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j2@323@01)))
    (= j1@323@01 j2@323@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@323@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@323@01)
        (<
          j@323@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@323@01 i2@276@01))
    (and
      (=
        (inv@324@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@323@01))
        j@323@01)
      (img@325@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@323@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@323@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@325@01 r)
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@324@01 r))
      r))
  :pattern ((inv@324@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@323@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@323@01)
    (Seq_index xs@274@01 j@323@01))
  
  :qid |quant-u-12905|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (img@325@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
            (inv@324@01 r))))
      (> (ite (= (inv@324@01 r) i2@276@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (+
          (ite
            (and
              (img@283@01 r)
              (and
                (<= 0 (inv@282@01 r))
                (< (inv@282@01 r) (Seq_length xs@274@01))))
            (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12906|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@326@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@326@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)
        (img@325@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)
        (img@325@01 r))
      (Set_in r ($FVF.domain_f (as sm@326@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@326@01  $FVF<f>))))
  :qid |qp.fvfDomDef246|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)
        (img@325@01 r))
      (= r (Seq_index xs@274@01 i2@276@01)))
    (=
      ($FVF.lookup_f (as sm@326@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@326@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef243|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)
        (img@325@01 r))
      (= r (Seq_index xs@274@01 i1@275@01)))
    (=
      ($FVF.lookup_f (as sm@326@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@326@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef244|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)
        (img@325@01 r))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@326@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@326@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef245|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@326@01  $FVF<f>))))) x@277@01 i2@276@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@323@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@323@01)
        (<
          j@323@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@323@01 i2@276@01))
    (and
      (=
        (inv@324@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@323@01))
        j@323@01)
      (img@325@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@323@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@323@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@325@01 r)
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@324@01 r))
      r))
  :pattern ((inv@324@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@326@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)
        (img@325@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)
        (img@325@01 r))
      (Set_in r ($FVF.domain_f (as sm@326@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@326@01  $FVF<f>))))
  :qid |qp.fvfDomDef246|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)
        (img@325@01 r))
      (= r (Seq_index xs@274@01 i2@276@01)))
    (=
      ($FVF.lookup_f (as sm@326@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@326@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef243|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)
        (img@325@01 r))
      (= r (Seq_index xs@274@01 i1@275@01)))
    (=
      ($FVF.lookup_f (as sm@326@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@326@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef244|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@324@01 r))
          (<
            (inv@324@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@324@01 r) i2@276@01)
        (img@325@01 r))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@326@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@326@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef245|)))
(assert (and
  (forall ((j@323@01 Int)) (!
    (=>
      (and
        (<= 0 j@323@01)
        (<
          j@323@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (and
        (=>
          (not (<= 0 j@323@01))
          (and
            (not (<= 0 j@323@01))
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
        (=>
          (<= 0 j@323@01)
          (and
            (<= 0 j@323@01)
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
        (or (<= 0 j@323@01) (not (<= 0 j@323@01)))
        (=>
          (= j@323@01 i2@276@01)
          (and
            (= j@323@01 i2@276@01)
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
        (=>
          (not (= j@323@01 i2@276@01))
          (and
            (not (= j@323@01 i2@276@01))
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
        (or (not (= j@323@01 i2@276@01)) (= j@323@01 i2@276@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@323@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@326@01  $FVF<f>))))) x@277@01 i2@276@01)))
; [eval] old(fun04qp(x, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@327@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@283@01 r)
      (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
    (=
      ($FVF.lookup_f (as sm@327@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@327@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef247|)))
(declare-const pm@328@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@328@01  $FPM) r)
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@328@01  $FPM) r))
  :qid |qp.resPrmSumDef248|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@328@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun04qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@329@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 108 | !(0 <= j@329@01) | live]
; [else-branch: 108 | 0 <= j@329@01 | live]
(push) ; 6
; [then-branch: 108 | !(0 <= j@329@01)]
(assert (not (<= 0 j@329@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 108 | 0 <= j@329@01]
(assert (<= 0 j@329@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@329@01) (not (<= 0 j@329@01))))
(assert (and
  (<= 0 j@329@01)
  (<
    j@329@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 109 | j@329@01 == i2@276@01 | live]
; [else-branch: 109 | j@329@01 != i2@276@01 | live]
(push) ; 6
; [then-branch: 109 | j@329@01 == i2@276@01]
(assert (= j@329@01 i2@276@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 109 | j@329@01 != i2@276@01]
(assert (not (= j@329@01 i2@276@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@329@01 i2@276@01)) (= j@329@01 i2@276@01)))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@329@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@330@01 ($Ref) Int)
(declare-fun img@331@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@329@01 Int)) (!
  (=>
    (and
      (<= 0 j@329@01)
      (<
        j@329@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (and
      (or (<= 0 j@329@01) (not (<= 0 j@329@01)))
      (or (not (= j@329@01 i2@276@01)) (= j@329@01 i2@276@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@329@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@329@01 Int)) (!
  (=>
    (and
      (<= 0 j@329@01)
      (<
        j@329@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (or
      (= (ite (= j@329@01 i2@276@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@329@01 i2@276@01)))
  
  :qid |quant-u-12907|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@329@01 Int) (j2@329@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@329@01)
          (<
            j1@329@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j1@329@01 i2@276@01))
      (and
        (and
          (<= 0 j2@329@01)
          (<
            j2@329@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j2@329@01 i2@276@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j1@329@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j2@329@01)))
    (= j1@329@01 j2@329@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@329@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@329@01)
        (<
          j@329@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@329@01 i2@276@01))
    (and
      (=
        (inv@330@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@329@01))
        j@329@01)
      (img@331@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@329@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@329@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@331@01 r)
      (and
        (and
          (<= 0 (inv@330@01 r))
          (<
            (inv@330@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@330@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@330@01 r))
      r))
  :pattern ((inv@330@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@329@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@329@01)
    (Seq_index xs@274@01 j@329@01))
  
  :qid |quant-u-12908|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@330@01 r))
          (<
            (inv@330@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (img@331@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
            (inv@330@01 r))))
      (> (ite (= (inv@330@01 r) i2@276@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12909|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@332@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@332@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@330@01 r))
          (<
            (inv@330@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@330@01 r) i2@276@01)
        (img@331@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@330@01 r))
          (<
            (inv@330@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@330@01 r) i2@276@01)
        (img@331@01 r))
      (Set_in r ($FVF.domain_f (as sm@332@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@332@01  $FVF<f>))))
  :qid |qp.fvfDomDef250|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@330@01 r))
          (<
            (inv@330@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@330@01 r) i2@276@01)
        (img@331@01 r))
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01)))))
    (=
      ($FVF.lookup_f (as sm@332@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@332@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef249|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@332@01  $FVF<f>))))) x@277@01 i2@276@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@329@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@329@01)
        (<
          j@329@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@329@01 i2@276@01))
    (and
      (=
        (inv@330@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@329@01))
        j@329@01)
      (img@331@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@329@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@329@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@331@01 r)
      (and
        (and
          (<= 0 (inv@330@01 r))
          (<
            (inv@330@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@330@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@330@01 r))
      r))
  :pattern ((inv@330@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@332@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@330@01 r))
          (<
            (inv@330@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@330@01 r) i2@276@01)
        (img@331@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@330@01 r))
          (<
            (inv@330@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@330@01 r) i2@276@01)
        (img@331@01 r))
      (Set_in r ($FVF.domain_f (as sm@332@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@332@01  $FVF<f>))))
  :qid |qp.fvfDomDef250|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@330@01 r))
          (<
            (inv@330@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@330@01 r) i2@276@01)
        (img@331@01 r))
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01)))))
    (=
      ($FVF.lookup_f (as sm@332@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@332@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef249|)))
(assert (and
  (forall ((j@329@01 Int)) (!
    (=>
      (and
        (<= 0 j@329@01)
        (<
          j@329@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (and
        (or (<= 0 j@329@01) (not (<= 0 j@329@01)))
        (or (not (= j@329@01 i2@276@01)) (= j@329@01 i2@276@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@329@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@332@01  $FVF<f>))))) x@277@01 i2@276@01)))
(push) ; 3
(assert (not (=
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@326@01  $FVF<f>))))) x@277@01 i2@276@01)
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@332@01  $FVF<f>))))) x@277@01 i2@276@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 3
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] fun04qp(x, i2) == old(fun04qp(x, i2))
; [eval] fun04qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@333@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 110 | !(0 <= j@333@01) | live]
; [else-branch: 110 | 0 <= j@333@01 | live]
(push) ; 6
; [then-branch: 110 | !(0 <= j@333@01)]
(assert (not (<= 0 j@333@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(declare-const sm@334@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef251|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef252|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef253|)))
(declare-const pm@335@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@335@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@335@01  $FPM) r))
  :qid |qp.resPrmSumDef254|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@335@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@335@01  $FPM) (Seq_index xs@274@01 i1@275@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@335@01  $FPM) (Seq_index xs@274@01 i2@276@01))
  $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 110 | 0 <= j@333@01]
(assert (<= 0 j@333@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
(declare-const sm@336@01 $FVF<f>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef255|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef256|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef257|)))
(declare-const pm@337@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@337@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@337@01  $FPM) r))
  :qid |qp.resPrmSumDef258|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
  $Perm.Write))
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef251|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef252|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef253|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@335@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@335@01  $FPM) r))
  :qid |qp.resPrmSumDef254|)))
(assert (=>
  (not (<= 0 j@333@01))
  (and
    (not (<= 0 j@333@01))
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@335@01  $FPM) r) $Perm.Write)
      :pattern ((inv@282@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@335@01  $FPM) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@335@01  $FPM) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef255|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef256|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef257|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@337@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@337@01  $FPM) r))
  :qid |qp.resPrmSumDef258|)))
(assert (=>
  (<= 0 j@333@01)
  (and
    (<= 0 j@333@01)
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
      :pattern ((inv@282@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write))))
(assert (or (<= 0 j@333@01) (not (<= 0 j@333@01))))
(assert (and
  (<= 0 j@333@01)
  (<
    j@333@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 111 | j@333@01 == i2@276@01 | live]
; [else-branch: 111 | j@333@01 != i2@276@01 | live]
(push) ; 6
; [then-branch: 111 | j@333@01 == i2@276@01]
(assert (= j@333@01 i2@276@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
  $Perm.Write))
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 111 | j@333@01 != i2@276@01]
(assert (not (= j@333@01 i2@276@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (<
  $Perm.Write
  (+
    (ite
      (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write
      $Perm.No)
    (ite
      (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01))
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01))
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 7
(set-option :timeout 10)
(assert (not (and
  (and
    (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i2@276@01))
    (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i1@275@01)))
  (not
    (=
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) (Seq_index xs@274@01 i2@276@01))
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) (Seq_index xs@274@01 i1@275@01)))))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(assert (and
  (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
  (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))))
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
(assert (<=
  ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
  $Perm.Write))
(assert (<=
  ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
  $Perm.Write))
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (=>
  (= j@333@01 i2@276@01)
  (and
    (= j@333@01 i2@276@01)
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
      :pattern ((inv@282@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write))))
; Joined path conditions
(assert (=>
  (not (= j@333@01 i2@276@01))
  (and
    (not (= j@333@01 i2@276@01))
    (not (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
    (not (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
      :pattern ((inv@282@01 r))
      :qid |qp-fld-prm-bnd|))
    (<=
      ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
      $Perm.Write)
    (<=
      ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
      $Perm.Write))))
(assert (or (not (= j@333@01 i2@276@01)) (= j@333@01 i2@276@01)))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@333@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@338@01 ($Ref) Int)
(declare-fun img@339@01 ($Ref) Bool)
; Nested auxiliary terms: globals
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef251|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef252|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef253|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@335@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@335@01  $FPM) r))
  :qid |qp.resPrmSumDef254|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef255|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef256|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef257|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@337@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@337@01  $FPM) r))
  :qid |qp.resPrmSumDef258|)))
; Nested auxiliary terms: non-globals
(assert (forall ((j@333@01 Int)) (!
  (=>
    (and
      (<= 0 j@333@01)
      (<
        j@333@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (and
      (=>
        (not (<= 0 j@333@01))
        (and
          (not (<= 0 j@333@01))
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@335@01  $FPM) r) $Perm.Write)
            :pattern ((inv@282@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@335@01  $FPM) (Seq_index xs@274@01 i1@275@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@335@01  $FPM) (Seq_index xs@274@01 i2@276@01))
            $Perm.Write)))
      (=>
        (<= 0 j@333@01)
        (and
          (<= 0 j@333@01)
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
            :pattern ((inv@282@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
            $Perm.Write)))
      (or (<= 0 j@333@01) (not (<= 0 j@333@01)))
      (=>
        (= j@333@01 i2@276@01)
        (and
          (= j@333@01 i2@276@01)
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
            :pattern ((inv@282@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
            $Perm.Write)))
      (=>
        (not (= j@333@01 i2@276@01))
        (and
          (not (= j@333@01 i2@276@01))
          (not
            (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
          (not
            (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
          (forall ((r $Ref)) (!
            (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
            :pattern ((inv@282@01 r))
            :qid |qp-fld-prm-bnd|))
          (<=
            ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
            $Perm.Write)
          (<=
            ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
            $Perm.Write)))
      (or (not (= j@333@01 i2@276@01)) (= j@333@01 i2@276@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@333@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@333@01 Int)) (!
  (=>
    (and
      (<= 0 j@333@01)
      (<
        j@333@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (or
      (= (ite (= j@333@01 i2@276@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@333@01 i2@276@01)))
  
  :qid |quant-u-12910|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@333@01 Int) (j2@333@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@333@01)
          (<
            j1@333@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j1@333@01 i2@276@01))
      (and
        (and
          (<= 0 j2@333@01)
          (<
            j2@333@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j2@333@01 i2@276@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j1@333@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j2@333@01)))
    (= j1@333@01 j2@333@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@333@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@333@01)
        (<
          j@333@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@333@01 i2@276@01))
    (and
      (=
        (inv@338@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@333@01))
        j@333@01)
      (img@339@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@333@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@333@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@339@01 r)
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@338@01 r))
      r))
  :pattern ((inv@338@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@333@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@333@01)
    (Seq_index xs@274@01 j@333@01))
  
  :qid |quant-u-12911|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (img@339@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
            (inv@338@01 r))))
      (> (ite (= (inv@338@01 r) i2@276@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (+
        (+
          (ite
            (and
              (img@283@01 r)
              (and
                (<= 0 (inv@282@01 r))
                (< (inv@282@01 r) (Seq_length xs@274@01))))
            (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
            $Perm.No)
          (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
        (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No))
      $Perm.No))
  
  :qid |quant-u-12912|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@340@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@340@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)
        (img@339@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)
        (img@339@01 r))
      (Set_in r ($FVF.domain_f (as sm@340@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@340@01  $FVF<f>))))
  :qid |qp.fvfDomDef262|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)
        (img@339@01 r))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@340@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@340@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef259|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)
        (img@339@01 r))
      (= r (Seq_index xs@274@01 i1@275@01)))
    (=
      ($FVF.lookup_f (as sm@340@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@340@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef260|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)
        (img@339@01 r))
      (= r (Seq_index xs@274@01 i2@276@01)))
    (=
      ($FVF.lookup_f (as sm@340@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@340@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef261|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@340@01  $FVF<f>))))) x@277@01 i2@276@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef251|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef252|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@334@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@334@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef253|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@335@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@335@01  $FPM) r))
  :qid |qp.resPrmSumDef254|)))
(assert (forall ((r $Ref)) (!
  (=>
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
      false)
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef255|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i1@275@01))
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef256|)))
(assert (forall ((r $Ref)) (!
  (=>
    (= r (Seq_index xs@274@01 i2@276@01))
    (=
      ($FVF.lookup_f (as sm@336@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@336@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef257|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@337@01  $FPM) r)
    (+
      (+
        (ite
          (and
            (img@283@01 r)
            (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
          (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r))
          $Perm.No)
        (ite (= r (Seq_index xs@274@01 i1@275@01)) $Perm.Write $Perm.No))
      (ite (= r (Seq_index xs@274@01 i2@276@01)) $Perm.Write $Perm.No)))
  :pattern (($FVF.perm_f (as pm@337@01  $FPM) r))
  :qid |qp.resPrmSumDef258|)))
(assert (forall ((j@333@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@333@01)
        (<
          j@333@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@333@01 i2@276@01))
    (and
      (=
        (inv@338@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@333@01))
        j@333@01)
      (img@339@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@333@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@333@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@339@01 r)
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@338@01 r))
      r))
  :pattern ((inv@338@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@340@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)
        (img@339@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)
        (img@339@01 r))
      (Set_in r ($FVF.domain_f (as sm@340@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@340@01  $FVF<f>))))
  :qid |qp.fvfDomDef262|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)
        (img@339@01 r))
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        (< $Perm.No (- (- $Perm.Write (pTaken@284@01 r)) (pTaken@294@01 r)))
        false))
    (=
      ($FVF.lookup_f (as sm@340@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@340@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef259|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)
        (img@339@01 r))
      (= r (Seq_index xs@274@01 i1@275@01)))
    (=
      ($FVF.lookup_f (as sm@340@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@285@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@340@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@285@01  $FVF<f>) r))
  :qid |qp.fvfValDef260|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@338@01 r))
          (<
            (inv@338@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@338@01 r) i2@276@01)
        (img@339@01 r))
      (= r (Seq_index xs@274@01 i2@276@01)))
    (=
      ($FVF.lookup_f (as sm@340@01  $FVF<f>) r)
      ($FVF.lookup_f (as sm@296@01  $FVF<f>) r)))
  :pattern (($FVF.lookup_f (as sm@340@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f (as sm@296@01  $FVF<f>) r))
  :qid |qp.fvfValDef261|)))
(assert (and
  (forall ((j@333@01 Int)) (!
    (=>
      (and
        (<= 0 j@333@01)
        (<
          j@333@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (and
        (=>
          (not (<= 0 j@333@01))
          (and
            (not (<= 0 j@333@01))
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@335@01  $FPM) r) $Perm.Write)
              :pattern ((inv@282@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@335@01  $FPM) (Seq_index xs@274@01 i1@275@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@335@01  $FPM) (Seq_index xs@274@01 i2@276@01))
              $Perm.Write)))
        (=>
          (<= 0 j@333@01)
          (and
            (<= 0 j@333@01)
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
              :pattern ((inv@282@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
              $Perm.Write)))
        (or (<= 0 j@333@01) (not (<= 0 j@333@01)))
        (=>
          (= j@333@01 i2@276@01)
          (and
            (= j@333@01 i2@276@01)
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
              :pattern ((inv@282@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
              $Perm.Write)))
        (=>
          (not (= j@333@01 i2@276@01))
          (and
            (not (= j@333@01 i2@276@01))
            (not
              (= (Seq_index xs@274@01 i1@275@01) (Seq_index xs@274@01 i2@276@01)))
            (not
              (= (Seq_index xs@274@01 i2@276@01) (Seq_index xs@274@01 i1@275@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_f (as pm@337@01  $FPM) r) $Perm.Write)
              :pattern ((inv@282@01 r))
              :qid |qp-fld-prm-bnd|))
            (<=
              ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i1@275@01))
              $Perm.Write)
            (<=
              ($FVF.perm_f (as pm@337@01  $FPM) (Seq_index xs@274@01 i2@276@01))
              $Perm.Write)))
        (or (not (= j@333@01 i2@276@01)) (= j@333@01 i2@276@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@333@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@340@01  $FVF<f>))))) x@277@01 i2@276@01)))
; [eval] old(fun04qp(x, i2))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@341@01 $FVF<f>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@283@01 r)
      (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
    (=
      ($FVF.lookup_f (as sm@341@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@341@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef263|)))
(declare-const pm@342@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_f (as pm@342@01  $FPM) r)
    (ite
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
      $Perm.Write
      $Perm.No))
  :pattern (($FVF.perm_f (as pm@342@01  $FPM) r))
  :qid |qp.resPrmSumDef264|)))
; Assume upper permission bound for field f
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_f (as pm@342@01  $FPM) r) $Perm.Write)
  :pattern ((inv@282@01 r))
  :qid |qp-fld-prm-bnd|)))
; [eval] fun04qp(x, i2)
(set-option :timeout 0)
(push) ; 3
; [eval] 0 <= i
; [eval] i < |x.elems|
; [eval] |x.elems|
(declare-const j@343@01 Int)
(push) ; 4
; [eval] 0 <= j && j < |x.elems|
; [eval] 0 <= j
(push) ; 5
; [then-branch: 112 | !(0 <= j@343@01) | live]
; [else-branch: 112 | 0 <= j@343@01 | live]
(push) ; 6
; [then-branch: 112 | !(0 <= j@343@01)]
(assert (not (<= 0 j@343@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 112 | 0 <= j@343@01]
(assert (<= 0 j@343@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
; [eval] j < |x.elems|
; [eval] |x.elems|
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (<= 0 j@343@01) (not (<= 0 j@343@01))))
(assert (and
  (<= 0 j@343@01)
  (<
    j@343@01
    (Seq_length
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))))))
; [eval] (j == i ? write : none)
; [eval] j == i
(set-option :timeout 0)
(push) ; 5
; [then-branch: 113 | j@343@01 == i2@276@01 | live]
; [else-branch: 113 | j@343@01 != i2@276@01 | live]
(push) ; 6
; [then-branch: 113 | j@343@01 == i2@276@01]
(assert (= j@343@01 i2@276@01))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(set-option :timeout 0)
(push) ; 6
; [else-branch: 113 | j@343@01 != i2@276@01]
(assert (not (= j@343@01 i2@276@01)))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Assume upper permission bound for field f
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (or (not (= j@343@01 i2@276@01)) (= j@343@01 i2@276@01)))
; [eval] x.elems[j]
(set-option :timeout 0)
(push) ; 5
(assert (not (>= j@343@01 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(pop) ; 4
(declare-fun inv@344@01 ($Ref) Int)
(declare-fun img@345@01 ($Ref) Bool)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((j@343@01 Int)) (!
  (=>
    (and
      (<= 0 j@343@01)
      (<
        j@343@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (and
      (or (<= 0 j@343@01) (not (<= 0 j@343@01)))
      (or (not (= j@343@01 i2@276@01)) (= j@343@01 i2@276@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@343@01))
  :qid |f-aux|)))
(push) ; 4
(assert (not (forall ((j@343@01 Int)) (!
  (=>
    (and
      (<= 0 j@343@01)
      (<
        j@343@01
        (Seq_length
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
    (or
      (= (ite (= j@343@01 i2@276@01) $Perm.Write $Perm.No) $Perm.No)
      (= j@343@01 i2@276@01)))
  
  :qid |quant-u-12913|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((j1@343@01 Int) (j2@343@01 Int)) (!
  (=>
    (and
      (and
        (and
          (<= 0 j1@343@01)
          (<
            j1@343@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j1@343@01 i2@276@01))
      (and
        (and
          (<= 0 j2@343@01)
          (<
            j2@343@01
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= j2@343@01 i2@276@01))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j1@343@01)
        (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j2@343@01)))
    (= j1@343@01 j2@343@01))
  
  :qid |f-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
; Definitional axioms for inverse functions
(assert (forall ((j@343@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@343@01)
        (<
          j@343@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@343@01 i2@276@01))
    (and
      (=
        (inv@344@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@343@01))
        j@343@01)
      (img@345@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@343@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@343@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@345@01 r)
      (and
        (and
          (<= 0 (inv@344@01 r))
          (<
            (inv@344@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@344@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@344@01 r))
      r))
  :pattern ((inv@344@01 r))
  :qid |f-fctOfInv|)))
(push) ; 4
(set-option :timeout 10)
(assert (not (forall ((j@343@01 Int)) (!
  (=
    (Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@343@01)
    (Seq_index xs@274@01 j@343@01))
  
  :qid |quant-u-12914|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(set-option :timeout 0)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@344@01 r))
          (<
            (inv@344@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (img@345@01 r)
        (=
          r
          (Seq_index
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
            (inv@344@01 r))))
      (> (ite (= (inv@344@01 r) i2@276@01) $Perm.Write $Perm.No) $Perm.No))
    (>
      (ite
        (and
          (img@283@01 r)
          (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01))))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  
  :qid |quant-u-12915|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(declare-const sm@346@01 $FVF<f>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@346@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@344@01 r))
          (<
            (inv@344@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@344@01 r) i2@276@01)
        (img@345@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@344@01 r))
          (<
            (inv@344@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@344@01 r) i2@276@01)
        (img@345@01 r))
      (Set_in r ($FVF.domain_f (as sm@346@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@346@01  $FVF<f>))))
  :qid |qp.fvfDomDef266|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@344@01 r))
          (<
            (inv@344@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@344@01 r) i2@276@01)
        (img@345@01 r))
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01)))))
    (=
      ($FVF.lookup_f (as sm@346@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@346@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef265|)))
(assert (fun04qp%precondition ($Snap.combine
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<f>To$Snap (as sm@346@01  $FVF<f>))))) x@277@01 i2@276@01))
(pop) ; 3
; Joined path conditions
(assert (forall ((j@343@01 Int)) (!
  (=>
    (and
      (and
        (<= 0 j@343@01)
        (<
          j@343@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (= j@343@01 i2@276@01))
    (and
      (=
        (inv@344@01 (Seq_index
          ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
          j@343@01))
        j@343@01)
      (img@345@01 (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        j@343@01))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
    j@343@01))
  :qid |f-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (img@345@01 r)
      (and
        (and
          (<= 0 (inv@344@01 r))
          (<
            (inv@344@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@344@01 r) i2@276@01)))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
        (inv@344@01 r))
      r))
  :pattern ((inv@344@01 r))
  :qid |f-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (and
    (=>
      (Set_in r ($FVF.domain_f (as sm@346@01  $FVF<f>)))
      (and
        (and
          (<= 0 (inv@344@01 r))
          (<
            (inv@344@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@344@01 r) i2@276@01)
        (img@345@01 r)))
    (=>
      (and
        (and
          (<= 0 (inv@344@01 r))
          (<
            (inv@344@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@344@01 r) i2@276@01)
        (img@345@01 r))
      (Set_in r ($FVF.domain_f (as sm@346@01  $FVF<f>)))))
  :pattern ((Set_in r ($FVF.domain_f (as sm@346@01  $FVF<f>))))
  :qid |qp.fvfDomDef266|)))
(assert (forall ((r $Ref)) (!
  (=>
    (and
      (and
        (and
          (<= 0 (inv@344@01 r))
          (<
            (inv@344@01 r)
            (Seq_length
              ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
        (= (inv@344@01 r) i2@276@01)
        (img@345@01 r))
      (and
        (img@283@01 r)
        (and (<= 0 (inv@282@01 r)) (< (inv@282@01 r) (Seq_length xs@274@01)))))
    (=
      ($FVF.lookup_f (as sm@346@01  $FVF<f>) r)
      ($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r)))
  :pattern (($FVF.lookup_f (as sm@346@01  $FVF<f>) r))
  :pattern (($FVF.lookup_f ($SortWrappers.$SnapTo$FVF<f> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))) r))
  :qid |qp.fvfValDef265|)))
(assert (and
  (forall ((j@343@01 Int)) (!
    (=>
      (and
        (<= 0 j@343@01)
        (<
          j@343@01
          (Seq_length
            ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))))))
      (and
        (or (<= 0 j@343@01) (not (<= 0 j@343@01)))
        (or (not (= j@343@01 i2@276@01)) (= j@343@01 i2@276@01))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<$Ref> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01)))))))))
      j@343@01))
    :qid |f-aux|))
  (fun04qp%precondition ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@346@01  $FVF<f>))))) x@277@01 i2@276@01)))
(push) ; 3
(assert (not (=
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@340@01  $FVF<f>))))) x@277@01 i2@276@01)
  (fun04qp ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@278@01))))))))
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<f>To$Snap (as sm@346@01  $FVF<f>))))) x@277@01 i2@276@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.01s
; (get-info :all-statistics)
(pop) ; 2
(pop) ; 1
